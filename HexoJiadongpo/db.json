{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/images/cenrise10.jpg","path":"images/cenrise10.jpg","modified":0,"renderable":0},{"_id":"source/images/douban.jpg","path":"images/douban.jpg","modified":0,"renderable":0},{"_id":"source/images/github.png","path":"images/github.png","modified":0,"renderable":0},{"_id":"source/images/favicon.ico","path":"images/favicon.ico","modified":0,"renderable":0},{"_id":"source/images/meizhuang.png","path":"images/meizhuang.png","modified":0,"renderable":0},{"_id":"source/images/quora.jpeg","path":"images/quora.jpeg","modified":0,"renderable":0},{"_id":"source/images/taobao.png","path":"images/taobao.png","modified":0,"renderable":0},{"_id":"source/images/twitter.png","path":"images/twitter.png","modified":0,"renderable":0},{"_id":"source/images/weibo.jpg","path":"images/weibo.jpg","modified":0,"renderable":0},{"_id":"source/images/zhihu.png","path":"images/zhihu.png","modified":0,"renderable":0},{"_id":"source/images/alipay.jpg","path":"images/alipay.jpg","modified":0,"renderable":0},{"_id":"source/images/facebook.png","path":"images/facebook.png","modified":0,"renderable":0},{"_id":"source/images/wechatpay.jpg","path":"images/wechatpay.jpg","modified":0,"renderable":0},{"_id":"source/images/kettle/mail.jpg","path":"images/kettle/mail.jpg","modified":0,"renderable":0},{"_id":"source/images/kettle/sorted merger1.jpg","path":"images/kettle/sorted merger1.jpg","modified":0,"renderable":0},{"_id":"source/images/kettle/开源ETL工具-kettle_ETL是什么.png","path":"images/kettle/开源ETL工具-kettle_ETL是什么.png","modified":0,"renderable":0},{"_id":"source/images/kettle/开源ETL工具-kettle_Jobs（工作）4.png","path":"images/kettle/开源ETL工具-kettle_Jobs（工作）4.png","modified":0,"renderable":0},{"_id":"source/images/kettle/开源ETL工具-kettle_Jobs（工作）5.png","path":"images/kettle/开源ETL工具-kettle_Jobs（工作）5.png","modified":0,"renderable":0},{"_id":"source/images/kettle/开源ETL工具-kettle_Jobs（工作）6.png","path":"images/kettle/开源ETL工具-kettle_Jobs（工作）6.png","modified":0,"renderable":0},{"_id":"source/images/kettle/开源ETL工具-kettle_Jobs（工作）9.png","path":"images/kettle/开源ETL工具-kettle_Jobs（工作）9.png","modified":0,"renderable":0},{"_id":"source/images/kettle/开源ETL工具-kettle_Step（步骤）.png","path":"images/kettle/开源ETL工具-kettle_Step（步骤）.png","modified":0,"renderable":0},{"_id":"source/images/kettle/开源ETL工具-kettle_Transformation(转换).jpg","path":"images/kettle/开源ETL工具-kettle_Transformation(转换).jpg","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon.ico","path":"images/favicon.ico","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"source/images/kettle/Kettle插件架构001.jpg","path":"images/kettle/Kettle插件架构001.jpg","modified":0,"renderable":0},{"_id":"source/images/kettle/开源ETL工具-kettle_Jobs（工作）3.png","path":"images/kettle/开源ETL工具-kettle_Jobs（工作）3.png","modified":0,"renderable":0},{"_id":"source/images/kettle/开源ETL工具-kettle_Jobs（工作）8.png","path":"images/kettle/开源ETL工具-kettle_Jobs（工作）8.png","modified":0,"renderable":0},{"_id":"source/images/kettle/开源ETL工具-kettle_Jobs（工作）7.png","path":"images/kettle/开源ETL工具-kettle_Jobs（工作）7.png","modified":0,"renderable":0},{"_id":"source/images/kettle/开源ETL工具-kettle_Kettle构成.jpg","path":"images/kettle/开源ETL工具-kettle_Kettle构成.jpg","modified":0,"renderable":0},{"_id":"source/images/数据中台/标准数据中台构架.jpg","path":"images/数据中台/标准数据中台构架.jpg","modified":0,"renderable":0},{"_id":"source/images/数据中台/理想的仓库.jpg","path":"images/数据中台/理想的仓库.jpg","modified":0,"renderable":0},{"_id":"source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"source/images/数据中台/现有的数据仓库架构.jpg","path":"images/数据中台/现有的数据仓库架构.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":1},{"_id":"source/images/kettle/开源ETL工具-kettle_Jobs（工作）.png","path":"images/kettle/开源ETL工具-kettle_Jobs（工作）.png","modified":0,"renderable":0},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"source/images/hadoop/kylin/Kylin的技术架构.jpg","path":"images/hadoop/kylin/Kylin的技术架构.jpg","modified":0,"renderable":0},{"_id":"source/images/数据中台/管理驾驶舱设计-页面跳转设计.jpg","path":"images/数据中台/管理驾驶舱设计-页面跳转设计.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"source/images/hadoop/kylin/一个四维Cube的例子.jpg","path":"images/hadoop/kylin/一个四维Cube的例子.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"source/images/数据中台/管理驾驶舱设计-页面流设计.jpg","path":"images/数据中台/管理驾驶舱设计-页面流设计.jpg","modified":0,"renderable":0},{"_id":"source/images/hadoop/kylin/维度和度量的例子.jpg","path":"images/hadoop/kylin/维度和度量的例子.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"source/README.md","hash":"b81afdbb8b6ccd3ecef5c916718fd50f4f7c3768","modified":1557890699920},{"_id":"source/CNAME","hash":"92e9e439012ba1f244f1573d366b6df6f69e8360","modified":1557890692788},{"_id":"source/.DS_Store","hash":"f0e2fec17be559f24d3b5d9995bafc9d54325512","modified":1539077716060},{"_id":"source/baidu_verify_iea4FlOhCY.html","hash":"3e15a1400f4178f4535b05a5360442d961a82cc5","modified":1503249010000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1526368421362},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1526368421362},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1526368421361},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1526368421362},{"_id":"themes/next/.gitignore","hash":"a18c2e83bb20991b899b58e6aeadcb87dd8aa16e","modified":1526368421365},{"_id":"themes/next/.stickler.yml","hash":"b7939095038cbdc4883fc10950e163a60a643b43","modified":1526368421365},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1526368421365},{"_id":"themes/next/.travis.yml","hash":"3d1dc928c4a97933e64379cfde749dedf62f252c","modified":1526368421365},{"_id":"themes/next/_config.yml","hash":"31c740e45e70a781dfd3a509091282634d53b180","modified":1557892668809},{"_id":"themes/next/LICENSE.md","hash":"fc7227c508af3351120181cbf2f9b99dc41f063e","modified":1526368421365},{"_id":"themes/next/README.md","hash":"807c28ad6473b221101251d244aa08e2a61b0d60","modified":1526368421366},{"_id":"themes/next/bower.json","hash":"29515e8a97ae28e07a934e38d0fc79af695d14fc","modified":1526368421367},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1526368421367},{"_id":"themes/next/gulpfile.coffee","hash":"48d2f9fa88a4210308fc41cc7d3f6d53989f71b7","modified":1526368421375},{"_id":"themes/next/package.json","hash":"d2eccdf5f241a3b42f2c9a873e3a063e54316ea9","modified":1526368421416},{"_id":"source/images/cenrise10.jpg","hash":"004afe6e4189ddb75ea1f4289ed2f5a0fc63ae44","modified":1503249010000},{"_id":"source/images/douban.jpg","hash":"7bd59f85ca708d96a65dddd6981086cbb639cd81","modified":1503249010000},{"_id":"source/images/github.png","hash":"ec237c5368083111c4952dbd80148e8e375e206e","modified":1503249010000},{"_id":"source/images/favicon.ico","hash":"6ed407cb30e21a406a45d0076a4a3226d2633bf0","modified":1503249010000},{"_id":"source/images/meizhuang.png","hash":"422b2633c2a77683e03387c91c8e0e72638b427b","modified":1503249010000},{"_id":"source/images/quora.jpeg","hash":"576783adddddee7ab97f15fcf3eba4565f4027dd","modified":1503249010000},{"_id":"source/images/taobao.png","hash":"c84ef7815c69fd97edaeb4b84772dfb89bc6ef52","modified":1503249010000},{"_id":"source/images/twitter.png","hash":"8b678142eae17a91d47d6fbe6260ae5cd9781c9f","modified":1503249010000},{"_id":"source/images/weibo.jpg","hash":"7f3fcab888eb49a6b21e9fb1b5a300bc9f7e1860","modified":1503249010000},{"_id":"source/about/index.md","hash":"8f21fb5e4d03ceb9671d08f86e23715bb3163ac8","modified":1557891590609},{"_id":"source/images/zhihu.png","hash":"46f6e7bc2f6fb30b7bdbda83f9678efa003a68d5","modified":1531805271347},{"_id":"source/categories/index.md","hash":"0fa7c5b3e1e66035e222ae40db8da30dc6b0d86b","modified":1526385667149},{"_id":"source/_posts/Markdown基础入门.md","hash":"ebffa095d8e09d35bb30fefad0d7f93720f8d6a6","modified":1503020675000},{"_id":"source/_posts/.DS_Store","hash":"2fd64ae8a260e30d5bd641c3222381ede880beb0","modified":1531801469364},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1526368421354},{"_id":"themes/next/.git/config","hash":"e2ca9fa6f115d4406d24bf0df53fc26ce13e0c9b","modified":1526368421356},{"_id":"source/tags/index.md","hash":"281b4a8c5aadb520edb7df2276833512630b3a08","modified":1526385677440},{"_id":"themes/next/.git/COMMIT_EDITMSG","hash":"8c4e3b3a8416a1c446215488e248c3c8f0eff15a","modified":1552987445474},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1526368410490},{"_id":"themes/next/.git/index","hash":"02d94bdee7251af691110ff0d67f50c4a61b0472","modified":1552987445472},{"_id":"themes/next/.git/packed-refs","hash":"acc0900604a227f71d02fef59211dfb60dc224e7","modified":1526368421352},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"b63696d41f022525e40d7e7870c3785b6bc7536b","modified":1526368421363},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"00c25366764e6b9ccb40b877c60dc13b2916bbf7","modified":1526368421363},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"f846118d7fc68c053df47b24e1f661241645373f","modified":1526368421363},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"7abbb4c8a29b2c14e576a00f53dbc0b4f5669c13","modified":1526368421364},{"_id":"themes/next/.github/stale.yml","hash":"fd0856f6745db8bd0228079ccb92a662830cc4fb","modified":1526368421364},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1526368421364},{"_id":"themes/next/docs/AUTHORS.md","hash":"7b24be2891167bdedb9284a682c2344ec63e50b5","modified":1526368421368},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"141e989844d0b5ae2e09fb162a280715afb39b0d","modified":1526368421368},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1526368421367},{"_id":"themes/next/docs/DATA-FILES.md","hash":"8e1962dd3e1b700169b3ae5bba43992f100651ce","modified":1526368421369},{"_id":"themes/next/docs/INSTALLATION.md","hash":"2bbdd6c1751b2b42ce9b9335da420c6026a483e9","modified":1526368421369},{"_id":"themes/next/docs/LICENSE","hash":"fe607fe22fc9308f6434b892a7f2d2c5514b8f0d","modified":1526368421369},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"120750c03ec30ccaa470b113bbe39f3d423c67f0","modified":1526368421369},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"ad57c168d12ba01cf144a1ea0627b2ffd1847d3e","modified":1526368421370},{"_id":"themes/next/docs/MATH.md","hash":"0ae4258950de01a457ea8123a8d13ec6db496e53","modified":1526368421369},{"_id":"themes/next/languages/de.yml","hash":"fb478c5040a4e58a4c1ad5fb52a91e5983d65a3a","modified":1526368421379},{"_id":"themes/next/languages/fr.yml","hash":"0162a85ae4175e66882a9ead1249fedb89200467","modified":1526368421381},{"_id":"themes/next/languages/default.yml","hash":"c540c3a0d7db2d4239293c8783881962640b6c34","modified":1526368421380},{"_id":"themes/next/languages/en.yml","hash":"c540c3a0d7db2d4239293c8783881962640b6c34","modified":1526368421380},{"_id":"themes/next/languages/id.yml","hash":"e7fb582e117a0785036dcdbb853a6551263d6aa6","modified":1526368421382},{"_id":"themes/next/languages/ja.yml","hash":"5f8e54c666393d1ca2e257f6b1e3b4116f6657d8","modified":1526368421382},{"_id":"themes/next/languages/it.yml","hash":"62ef41d0a9a3816939cb4d93a524e6930ab9c517","modified":1526368421382},{"_id":"themes/next/languages/ko.yml","hash":"fae155018ae0efdf68669b2c7dd3f959c2e45cc9","modified":1526368421383},{"_id":"themes/next/languages/pt.yml","hash":"3cb51937d13ff12fcce747f972ccb664840a9ef3","modified":1526368421384},{"_id":"themes/next/languages/pt-BR.yml","hash":"bfc80c8a363fa2e8dde38ea2bc85cd19e15ab653","modified":1526368421383},{"_id":"themes/next/languages/ru.yml","hash":"db0644e738d2306ac38567aa183ca3e859a3980f","modified":1526368421384},{"_id":"themes/next/languages/nl.yml","hash":"bb9ce8adfa5ee94bc6b5fac6ad24ba4605d180d3","modified":1526368421383},{"_id":"themes/next/languages/tr.yml","hash":"c5f0c20743b1dd52ccb256050b1397d023e6bcd9","modified":1526368421385},{"_id":"themes/next/languages/zh-CN.yml","hash":"fbbf3a0b664ae8e927c700b0a813692b94345156","modified":1526368421386},{"_id":"themes/next/languages/vi.yml","hash":"8da921dd8335dd676efce31bf75fdd4af7ce6448","modified":1526368421386},{"_id":"themes/next/languages/zh-HK.yml","hash":"7903b96912c605e630fb695534012501b2fad805","modified":1526368421387},{"_id":"themes/next/languages/zh-TW.yml","hash":"6e6d2cd8f4244cb1b349b94904cb4770935acefd","modified":1526368421387},{"_id":"themes/next/layout/_layout.swig","hash":"09e8a6bfe5aa901c66d314601c872e57f05509e8","modified":1526368421388},{"_id":"themes/next/layout/archive.swig","hash":"2b6450c6b6d2bcbcd123ad9f59922a5e323d77a5","modified":1526368421413},{"_id":"themes/next/layout/category.swig","hash":"5d955284a42f802a48560b4452c80906a5d1da02","modified":1526368421414},{"_id":"themes/next/layout/index.swig","hash":"53300ca42c00cba050bc98b0a3f2d888d71829b1","modified":1526368421414},{"_id":"themes/next/layout/page.swig","hash":"79040bae5ec14291441b33eea341a24a7c0e9f93","modified":1526368421414},{"_id":"themes/next/layout/post.swig","hash":"e7458f896ac33086d9427979f0f963475b43338e","modified":1526368421415},{"_id":"themes/next/scripts/helpers.js","hash":"392cda207757d4c055b53492a98f81386379fc4f","modified":1526368421416},{"_id":"themes/next/layout/schedule.swig","hash":"3e9cba5313bf3b98a38ccb6ef78b56ffa11d66ee","modified":1526368421415},{"_id":"themes/next/scripts/merge-configs.js","hash":"33afe97284d34542015d358a720823feeebef120","modified":1526368421417},{"_id":"themes/next/layout/tag.swig","hash":"ba402ce8fd55e80b240e019e8d8c48949b194373","modified":1526368421415},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1526368421418},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1526368421470},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1526368421470},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1526368421471},{"_id":"source/images/alipay.jpg","hash":"28b5cc9292796d0b37c8fdb2ed28a6b7e806c92f","modified":1531806167000},{"_id":"source/images/facebook.png","hash":"a404e32587f618a63375fcbae73d3c99ee4b590b","modified":1503249010000},{"_id":"source/images/wechatpay.jpg","hash":"3e83b139440b86ddaaa7868c62be1fba567d91e4","modified":1531805085000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1526368421450},{"_id":"source/images/kettle/mail.jpg","hash":"7d1916b0d92f7c9aa9c1e747f7fefaeecd97d126","modified":1531805715000},{"_id":"source/images/kettle/sorted merger1.jpg","hash":"ba3ed99f8f4684e81e064d41780f5bc1a87e79fb","modified":1503249010000},{"_id":"source/images/kettle/开源ETL工具-kettle_ETL是什么.png","hash":"8da47a6bc4a7cccc87476040b8abf530dbd2aca1","modified":1503249010000},{"_id":"source/images/kettle/开源ETL工具-kettle_Jobs（工作）4.png","hash":"3a58daf90045124022e3c5cd0271f090c3ac3fd6","modified":1503249010000},{"_id":"source/images/kettle/开源ETL工具-kettle_Jobs（工作）5.png","hash":"c7ca49eac6954c3caf7a278b2e57b811d7ccddc3","modified":1503249010000},{"_id":"source/images/kettle/开源ETL工具-kettle_Jobs（工作）6.png","hash":"6c0c4f78e4a29da901770ff00cc0dadee2f1f1c0","modified":1503249010000},{"_id":"source/images/kettle/开源ETL工具-kettle_Jobs（工作）9.png","hash":"2e16235c079e3911348061430614bd6f790f21cd","modified":1503249010000},{"_id":"source/images/kettle/开源ETL工具-kettle_Step（步骤）.png","hash":"f26ad03a18d856fd198a3dfc0c898cc30b5d77a4","modified":1503249010000},{"_id":"source/images/kettle/开源ETL工具-kettle_Transformation(转换).jpg","hash":"60a026f89af1642da224c52a001a1e215366bfb2","modified":1503249010000},{"_id":"source/_posts/kettle/Sorted Merge组件.md","hash":"20b425dcda4d4d978187e1a3a1e69d1d02a6a814","modified":1552531850654},{"_id":"source/_posts/kettle/开源ETL工具-kettle.md","hash":"b8b6ecbf4897395e22ef7ff97fa2e5956b663feb","modified":1503020675000},{"_id":"source/_posts/kettle/Kettle源码构建过程.md","hash":"7dc1dc61c2026ce5c12c27789283de7af7e7ce60","modified":1503020675000},{"_id":"source/_posts/hadoop/HBase入门概念.md","hash":"23365bd2407d35989a40023981bcf88cb1677db9","modified":1503020675000},{"_id":"source/_posts/hadoop/Apache Spark与Apache Hadoop的关系.md","hash":"e4bab854f301ed13632448874e069c185218250e","modified":1503020675000},{"_id":"source/_posts/hadoop/HDFS入门概念.md","hash":"bb981c816721c5e0335eb09022289718db517dbf","modified":1503020675000},{"_id":"source/_posts/hadoop/Hadoop之分布式存储.md","hash":"c693b49467f47f8210f1299984cdf6b92f070cb6","modified":1503020675000},{"_id":"source/_posts/hadoop/Hadoop之分布式计算 .md","hash":"69b817e1953087ae80f25e1fac79f3ace79cffc7","modified":1503020675000},{"_id":"source/_posts/hadoop/Hadoop之实时分析.md","hash":"35a7152458b73dd346f9b6fac2f055164933b4f3","modified":1503020675000},{"_id":"source/_posts/hadoop/Hadoop之数据采集.md","hash":"928744f402f88fb98e5fe92bd8ad90c6dcb148f2","modified":1503020675000},{"_id":"source/_posts/hadoop/Hadoop之流式计算.md","hash":"689f8c488fe46a3ad97681d7c62c7aa75eb19100","modified":1503020675000},{"_id":"source/_posts/hadoop/Hadoop知识点.md","hash":"3715102cebfb17842888473ac84b8c6ccafb697e","modified":1503020675000},{"_id":"source/_posts/hadoop/Hive入门概念.md","hash":"52afb0ded34a21420ddbb289c83501361b61f03d","modified":1503020675000},{"_id":"source/_posts/hadoop/Kylin入门概念.md","hash":"24ec9922dd5134345d4ee8e37fb9c9cd1370dff2","modified":1503020675000},{"_id":"source/_posts/hadoop/数据分析软件分类.md","hash":"79bbca6f498423f533448281158e4082a8e6f434","modified":1503020675000},{"_id":"source/_posts/java/JDK源码分析之集合框架HashMap.md","hash":"d54ba7b5b5c97defa6690d5d484c524e30323ddf","modified":1503020675000},{"_id":"source/_posts/java/Java基础之转型.md","hash":"e6fadf077f2a7155d64a909586c0bc34dc50bd0b","modified":1503020675000},{"_id":"source/_posts/java/java中Object转String.md","hash":"567ebf1de7e7b3e2c43cb29e1bbcf692bb691294","modified":1503020675000},{"_id":"source/_posts/java/jdk环境变量配置.md","hash":"1d16258177970a40fac7213af28e1c4ac2b282f8","modified":1503020675000},{"_id":"source/_posts/linux/Linux固定IP上网方式.md","hash":"cdca6298ad6f2897112ff1d0f86776d93a71f0f0","modified":1503020675000},{"_id":"source/_posts/java/消息传送基础.md","hash":"a39188ee09c9cc48fbdef73dd266866b11ce73f0","modified":1503020675000},{"_id":"source/_posts/linux/Linux常用命令及操作.md","hash":"ed12c1455ad7c66c057be9dfe79ef7fe73eef9a4","modified":1503020675000},{"_id":"source/_posts/linux/SSH用户等效性配置.md","hash":"95202030963d4ee9585f5b95f7c95d333ff012cd","modified":1503020675000},{"_id":"source/_posts/oracle/Oracle SQL优化.md","hash":"6b584fe42d496b9351d5525d419d299577798664","modified":1503020675000},{"_id":"source/_posts/oracle/Oracle数据库系统架构.md","hash":"15d44c295d3c7f4ba2ce31f1fa9378e8fa716450","modified":1503020675000},{"_id":"source/_posts/review/Sonar代码审查-缺陷和修改.md","hash":"26abdfb559ec1b94cc7079ca3f946ddfd0594a71","modified":1527673087550},{"_id":"source/_posts/oracle/Oracle网络和数据库连接.md","hash":"ed5e5ac1a8e2098629993ae0007c22ab021e326f","modified":1503020675000},{"_id":"source/_posts/oracle/RAW类型.md","hash":"106fa1b1506606f968d392d40860959eb5606e5a","modified":1503020675000},{"_id":"source/_posts/spark/TODO-Spark体系概述.md","hash":"ff573c8338b6cc703215d9c6207b5346c1b09209","modified":1503020675000},{"_id":"source/_posts/spring/Spring源码分析之环境准备.md","hash":"22dce836f39e578e11294d1a5375db5402021928","modified":1503020675000},{"_id":"source/_posts/异常/JasperListener类找不到.md","hash":"f2c19527ec44a0e4078275841b6f39f909ae8c2c","modified":1503250560000},{"_id":"source/_posts/异常/Java_heap_space_OutOfMemoryError.md","hash":"3ae2384822c8c24f98f4d55bded3fd362d469c72","modified":1526363826605},{"_id":"source/_posts/分布式/负载均衡初识.md","hash":"8616aa6f8d917409ed583e3f5bc6ff0357f792dd","modified":1530958137374},{"_id":"source/_posts/异常/connection_holder_is_null.md","hash":"cd39cd6cee89ce1222c34e0b77fd5801f0898560","modified":1503250560000},{"_id":"source/_posts/tools/通过Hexo找寻自己的Github Pages.md","hash":"64a84d30a77c868856b1c91ee1a8248a073966f1","modified":1539067637052},{"_id":"source/_posts/异常/permGen_space_OutOfMemoryError.md","hash":"11ba61b4f873fdf798dc9c29fee208510cad1f18","modified":1503250560000},{"_id":"source/_posts/网络安全/企业安全组.md","hash":"5ac378a0c5f496885fb611ffbdef9b6dd550f2c1","modified":1503020675000},{"_id":"source/_posts/算法/常用算法概述.md","hash":"f4835c00aef52fa1463e118612013ebcffb9e865","modified":1503020675000},{"_id":"source/_posts/服务/和田市卫浴安装家具安装.md","hash":"2f395f27e892cd4a0c4c4553aabe5b3fd2352e23","modified":1503020675000},{"_id":"source/_posts/网络安全/安全组第一次会议提出的问题整理.md","hash":"e3c1644ae45762b835cde78efe7576bcb5a3ba1f","modified":1503020675000},{"_id":"source/_posts/设计模式/主要设计模式及简要介绍.md","hash":"25621291936921e3d41ba09aafd2d1fa2e046c0f","modified":1503020675000},{"_id":"source/_posts/数据中台/指标体系规划与管理驾驶舱设计.md","hash":"c79c8087078d1cd07993e38ac64b30b4be5822be","modified":1552531750334},{"_id":"source/_posts/数据中台/分布式SQL查询引擎-Presto.md","hash":"ab5b3b1a20387133b83791ae9309d2d454cc7abf","modified":1552471875326},{"_id":"source/_posts/数据中台/数据中台建设杂谈.md","hash":"817963b4355426e01142c67d0f5f0eae89399c5c","modified":1552531850663},{"_id":"source/_posts/数据中台/数据建模-维度.md","hash":"57829df62fd016a1576ab326e1c37e10dac1b211","modified":1552471110046},{"_id":"source/_posts/数据中台/数据建模-事实表.md","hash":"a3c9e0e0f0a3380d1a32988eb8f0ffe624e65b51","modified":1552471163527},{"_id":"source/_posts/数据中台/数据建模方法论.md","hash":"d44c89fda97c31cee078ba492d2d8f12cbdcf907","modified":1552471273482},{"_id":"source/_posts/数据中台/数据建模-元数据.md","hash":"ac2b3df01f061d11438c3f507dcbdad4aaa85f24","modified":1552986410949},{"_id":"source/_posts/读书/文章格式 .md","hash":"545fbfd5fb0c38ab4231c6d74a45ed381ce86174","modified":1539073570825},{"_id":"source/_posts/广告/微小店.md","hash":"7aee4aa79eae31f4d55d99cac3c268a6a2e4a30d","modified":1547998074214},{"_id":"source/_posts/读书/确定目标|方法论-SMART原则.md","hash":"99e3cbf9bf02a34777286938488c4e582d2ffa5c","modified":1531883446238},{"_id":"source/_posts/读书/综合分析|方法论-SOWT分析法.md","hash":"b0121fa9bcaa545b8211a0d8bc25978ed591a6a5","modified":1531883487220},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1526368410491},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1526368410490},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1526368410493},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1526368410493},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1526368410491},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1526368410491},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1526368410493},{"_id":"themes/next/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1526368410492},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1526368410493},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1526368410492},{"_id":"themes/next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1526368410484},{"_id":"themes/next/.git/logs/HEAD","hash":"172f755447b004adfc7d30929643fe7ac54943d0","modified":1552987445476},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"b1dd18d9b890b21718883ea1832e7e02a773104a","modified":1526368421371},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"6c5d69e94961c793da156217ecf1179e868d7ba1","modified":1526368421370},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"d6d20f60f77a76c77f8e65d0c9adbd79d0274557","modified":1526368421370},{"_id":"themes/next/docs/ru/README.md","hash":"712d9a9a557c54dd6638adfb0e1d2bb345b60756","modified":1526368421371},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"6855402e2ef59aae307e8bd2a990647d3a605eb8","modified":1526368421371},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"a45a791b49954331390d548ac34169d573ea5922","modified":1526368421371},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"44e4fb7ce2eca20dfa98cdd1700b50d6def4086f","modified":1526368421372},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"f3eec572a7d83542e2710a7404082014aaa1a5e7","modified":1526368421373},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"b19a6e0ae96eb7c756fb5b1ba03934c7f9cbb3c3","modified":1526368421373},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"24cf2618d164440b047bb9396263de83bee5b993","modified":1526368421374},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"e03607b608db4aa7d46f6726827c51ac16623339","modified":1526368421374},{"_id":"themes/next/docs/zh-CN/README.md","hash":"84d349fda6b9973c81a9ad4677db9d9ee1828506","modified":1526368421375},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"c1ba919f70efe87a39e6217883e1625af0b2c23c","modified":1526368421375},{"_id":"themes/next/layout/_custom/head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1526368421388},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1526368421388},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"0a0129e926c27fffc6e7ef87fe370016bc7a4564","modified":1526368421396},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1526368421388},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"6fc63d5da49cb6157b8792f39c7305b55a0d1593","modified":1526368421396},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"ac3ad2c0eccdf16edaa48816d111aaf51200a54b","modified":1526368421396},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"e0bdc723d1dc858b41fd66e44e2786e6519f259f","modified":1526368421398},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1526368421389},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"05e67c50a4f3a20fad879ed61b890de8ca6ba4ea","modified":1526368421389},{"_id":"themes/next/layout/_macro/reward.swig","hash":"bd5778d509c51f4b1d8da3a2bc35462929f08c75","modified":1526368421390},{"_id":"themes/next/layout/_macro/post-related.swig","hash":"08fe30ce8909b920540231e36c97e28cfbce62b6","modified":1526368421389},{"_id":"themes/next/layout/_macro/post.swig","hash":"686e60ede86547bdd7bc34c3629e4c9dbd134a21","modified":1526368421390},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"1f3121ef66a4698fd78f34bf2594ef79a407c92c","modified":1526368421390},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"a9e1346b83cf99e06bed59a53fc069279751e52a","modified":1526368421390},{"_id":"themes/next/layout/_partials/breadcrumb.swig","hash":"6994d891e064f10607bce23f6e2997db7994010e","modified":1526368421391},{"_id":"themes/next/layout/_partials/comments.swig","hash":"5df32b286a8265ba82a4ef5e1439ff34751545ad","modified":1526368421391},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1aaf32bed57b976c4c1913fd801be34d4838cc72","modified":1526368421393},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"dbe321bcf3cf45917cc11a3e3f50d8572bac2c70","modified":1526368421394},{"_id":"themes/next/layout/_partials/footer.swig","hash":"129c018522275592affa73817d47cedba8ab4079","modified":1526379787966},{"_id":"themes/next/layout/_third-party/bookmark.swig","hash":"60001c8e08b21bf3a7afaf029839e1455340e95d","modified":1526368421407},{"_id":"themes/next/layout/_third-party/copy-code.swig","hash":"a8ab2035654dd06d94faf11a35750529e922d719","modified":1526368421409},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"f532ce257fca6108e84b8f35329c53f272c2ce84","modified":1526368421409},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"927f19160ae14e7030df306fc7114ba777476282","modified":1526368421410},{"_id":"themes/next/layout/_third-party/github-banner.swig","hash":"cabd9640dc3027a0b3ac06f5ebce777e50754065","modified":1526368421409},{"_id":"themes/next/layout/_third-party/pangu.swig","hash":"6b75c5fd76ae7cf0a7b04024510bd5221607eab3","modified":1526368421410},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1526368421411},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"b0ca46e0d1ff4c08cb0a3a8c1994f20d0260cef9","modified":1526368421411},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1526368421411},{"_id":"themes/next/scripts/tags/button.js","hash":"5a61c2da25970a4981fbd65f4a57c5e85db4dcda","modified":1526368421418},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"db70a841e7c1708f95ca97b44413b526b267fa9b","modified":1526368421419},{"_id":"themes/next/scripts/tags/full-image.js","hash":"a98fc19a90924f2368e1982f8c449cbc09df8439","modified":1526368421420},{"_id":"themes/next/scripts/tags/exturl.js","hash":"2b3a4dc15dea33972c0b6d46a1483dabbf06fb5b","modified":1526368421419},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"1b97b1b5364945b8ab3e50813bef84273055234f","modified":1526368421420},{"_id":"themes/next/scripts/tags/include-raw.js","hash":"b7600f6b868d8f4f7032126242d9738cd1e6ad71","modified":1526368421420},{"_id":"themes/next/scripts/tags/label.js","hash":"621004f2836040b12c4e8fef77e62cf22c561297","modified":1526368421421},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"460e5e1f305847dcd4bcab9da2038a85f0a1c273","modified":1526368421421},{"_id":"themes/next/scripts/tags/note.js","hash":"4975d4433e11161b2e9a5744b7287c2d667b3c76","modified":1526368421421},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1526368421421},{"_id":"themes/next/source/css/main.styl","hash":"c26ca6e7b5bd910b9046d6722c8e00be672890e0","modified":1526368421449},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1526368421451},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1526368421450},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1526368421450},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1526368421451},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1526368421452},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1526368421452},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1526368421452},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1526368421453},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1526368421453},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1526368421453},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1526368421454},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1526368421453},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1526368421454},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1526368421454},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1526368421454},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1526368421454},{"_id":"themes/next/source/images/favicon.ico","hash":"6ed407cb30e21a406a45d0076a4a3226d2633bf0","modified":1503249010000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1526368421455},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1526368421455},{"_id":"source/images/kettle/Kettle插件架构001.jpg","hash":"142c232a45620ca45831388a094cacd8137c0671","modified":1503249010000},{"_id":"source/images/kettle/开源ETL工具-kettle_Jobs（工作）3.png","hash":"8fbfeefaa2346dbcff8a735077c003b3731d720e","modified":1503249010000},{"_id":"source/images/kettle/开源ETL工具-kettle_Jobs（工作）8.png","hash":"50c05f7fa4fa0e9bf0295e784c57e6c53bf2f660","modified":1503249010000},{"_id":"source/images/kettle/开源ETL工具-kettle_Jobs（工作）7.png","hash":"fd96587bd686fa59031e9d41b69c0d917f061b3a","modified":1503249010000},{"_id":"source/images/kettle/开源ETL工具-kettle_Kettle构成.jpg","hash":"0f34cfda2c040aaf3617352325d8c2776454cd43","modified":1503249010000},{"_id":"source/images/数据中台/标准数据中台构架.jpg","hash":"ce4e578f3bef76e002b33e8d2885f0eca3458692","modified":1552472053000},{"_id":"source/images/数据中台/理想的仓库.jpg","hash":"d9b1054eee18075750503aead44de6cc786ae28d","modified":1552472068000},{"_id":"source/_posts/kettle/Kettle插件架构.md","hash":"2a45db5a783f878fb62a15703c8c1c1b44e5df49","modified":1503020675000},{"_id":"source/_posts/oracle/Oracle SQL基础知识.md","hash":"6bc1bff15467512b1163eadda15ae0d1f1f101f3","modified":1503020675000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1526368421397},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1526368421397},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1526368421441},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1526368421442},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1526368421442},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1526368421449},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1526368421449},{"_id":"source/images/avatar.jpg","hash":"e02f499056e9d6fde4dd9f4cd468a652359d6fd7","modified":1503249010000},{"_id":"source/_posts/tools/emacs/TODO-emacs入门.md","hash":"ef244d28f6aea7dcea09b25633b5301319a0e358","modified":1503020675000},{"_id":"source/_posts/tools/vim/TODO-vim入门实践.md","hash":"007bb54b8746f7c5a7d2d8454d36ee022b142e2b","modified":1503020675000},{"_id":"source/_posts/review/Findbug代码审查-缺陷和修改.md","hash":"b5e1597d3dd79d844d0c3b4fba65aa46ede96546","modified":1527672756444},{"_id":"source/_posts/前端/react.js/TODO-react.js入门之HelloWorld.md","hash":"7cf7728c9c84b5b1b9ba4a696694a14eff42d6f5","modified":1503020675000},{"_id":"source/_posts/前端/angular.js/TODO-angular.js入门之HelloWorld.md","hash":"8a47edcf4d77a4668b0dca29a3cf24d7771aa543","modified":1503020675000},{"_id":"source/_posts/前端/vue.js/TODO-vue.js入门之HelloWorld.md","hash":"6ecc7fc6f31b1e30d5b6535d9a7efe7e6e6ece6a","modified":1503020675000},{"_id":"source/_posts/读书/《卖掉法拉利的高僧》摘要 .md","hash":"5684259830f839faed7f61180b41e8c517446729","modified":1531802269667},{"_id":"themes/next/.git/objects/12/fe86aad4cd5201098d78c3d50dbc01dc6ed8a7","hash":"b418d6a958853e43e1a92fcaba0ffbd70bb9740b","modified":1547998985362},{"_id":"themes/next/.git/objects/18/232e0fd2a5d4ea062411af1df6e3390bc827f3","hash":"7bf2eac12b3c7b4613c2d6b0f2ef943d6fd1dc71","modified":1547998985356},{"_id":"themes/next/.git/objects/52/f1a279b3eaafc288cf509c3b7f4bece787402e","hash":"33c75c862acabf6e77a556ef2e597c40b2400a3b","modified":1547998985352},{"_id":"themes/next/.git/objects/7a/0db714aa33e3f15895b81dd94a2942053915e2","hash":"1c838911fec7f72f52bdc4efabfbc4017240fb72","modified":1552987445474},{"_id":"themes/next/.git/objects/82/92d17cd363e14663efb941359afdebf3772961","hash":"1444259b39162bec4cede6c31f0054c9a6c7cf31","modified":1547998985312},{"_id":"themes/next/.git/objects/af/e7f1e4e589159bbb0e7edd67e74859803b29c0","hash":"38fa24d3ccb1eb2ca10f7fe0e6198a1a7edd77ea","modified":1552987445472},{"_id":"themes/next/.git/objects/b5/6cd0c08b7063577b87f2c6bc17b621d693aa70","hash":"3cc0963a79f6c296eb6ca9df8e37423c51a14e00","modified":1526382648446},{"_id":"themes/next/.git/objects/db/355d9e7b099d05fcbce97833e7645655237c74","hash":"2a42eb2f911db4b2df4a58640610d2e11f914762","modified":1547998985357},{"_id":"themes/next/.git/objects/2b/7b7a414105a52473e4111c26e9b618a94f76a1","hash":"b065b1b1b599654fdd4ee1b297eda00b8eaeffe3","modified":1552987445427},{"_id":"themes/next/.git/objects/f6/1975ddd2ee6d453bd661fc01298676fe30ecec","hash":"39ed19b1a6ce34ec5a074c92294df94eced955ee","modified":1547998985313},{"_id":"themes/next/.git/refs/heads/master","hash":"7296c4e7a95c8974f6d738967847856252c10c2f","modified":1552987445476},{"_id":"themes/next/.git/objects/f6/59a7a3616716d175ad223ee149e8717effb7f8","hash":"79d56993a1e323a68efd49087e1a3cef7fc496fc","modified":1547998985358},{"_id":"themes/next/.git/objects/fe/2214b49725d9f531fe33aae76b6609837aa41f","hash":"590c6af9e9b6e73a2a1f98dca06b251a5466e5b5","modified":1547998985351},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"cc865af4a3cb6d25a0be171b7fc919ade306bb50","modified":1526368421397},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"ea03fe9c98ddcfcc0ecfdbe5a2b622f9cde3b3a1","modified":1526368421397},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"ea03fe9c98ddcfcc0ecfdbe5a2b622f9cde3b3a1","modified":1526368421397},{"_id":"themes/next/layout/_macro/menu/menu-item.swig","hash":"d1b73c926109145e52605929b75914cc8b60fb89","modified":1526368421389},{"_id":"themes/next/layout/_macro/menu/menu-badge.swig","hash":"65c5e585982dae7ae1542cada71858b4ea1f73d6","modified":1526368421389},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1526368421392},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"00bf33b3c557b8f7e9faf49b226ea6ff7df5cda0","modified":1526368421392},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"a7e376b087ae77f2e2a61ba6af81cde5af693174","modified":1526368421392},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"fd780171713aada5eb4f4ffed8e714617c8ae6be","modified":1526368421393},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"2082f5077551123e695e8afec471c9c44b436acb","modified":1526368421393},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"3db735d0cd2d449edf2674310ac1e7c0043cb357","modified":1526368421393},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"88b4b6051592d26bff59788acb76346ce4e398c2","modified":1526368421393},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"a33b29ccbdc2248aedff23b04e0627f435824406","modified":1526368421394},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1526368421394},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1526368421394},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1526368421394},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1526368421395},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1526368421395},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1526368421396},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1526368421395},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1526368421399},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1526368421399},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1526368421399},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1526368421400},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"67f0cb55e6702c492e99a9f697827629da036a0c","modified":1526368421399},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1526368421400},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"94b26dfbcd1cf2eb87dd9752d58213338926af27","modified":1526368421400},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1526368421402},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"beb53371c035b62e1a2c7bb76c63afbb595fe6e5","modified":1526368421401},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1526368421404},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"cee047575ae324398025423696b760db64d04e6f","modified":1526368421403},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1526368421406},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1526368421406},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1526368421407},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"8878241797f8494a70968756c57cacdfc77b61c7","modified":1526368421407},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"fe8177e4698df764e470354b6acde8292a3515e0","modified":1526368421407},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"17a54796f6e03fc834880a58efca45c286e40e40","modified":1526368421408},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"40e3cacbd5fa5f2948d0179eff6dd88053e8648e","modified":1526368421408},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"42f62695029834d45934705c619035733762309e","modified":1526368421409},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"6f340d122a9816ccdf4b45b662880a4b2d087671","modified":1526368421408},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"c0eb6123464d745ac5324ce6deac8ded601f432f","modified":1526368421408},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"a6fc00ec7f5642aabd66aa1cf51c6acc5b10e012","modified":1526368421410},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"97dbc2035bcb5aa7eafb80a4202dc827cce34983","modified":1526368421410},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"9b9ff4cc6d5474ab03f09835a2be80e0dba9fe89","modified":1526368421410},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1526368421412},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1526368421413},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1526368421413},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"b15e10abe85b4270860a56c970b559baa258b2a8","modified":1526368421412},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1526368421441},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1526368421441},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"2640a54fa63bdd4c547eab7ce2fc1192cf0ccec8","modified":1526368421442},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"81ca13d6d0beff8b1a4b542a51e3b0fb68f08efd","modified":1526368421442},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"7a2706304465b9e673d5561b715e7c72a238437c","modified":1526368421448},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1526368421448},{"_id":"themes/next/source/css/_variables/base.styl","hash":"cfb03ec629f13883509eac66e561e9dba562333f","modified":1526368421449},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"32392d213f5d05bc26b2dc452f2fc6fea9d44f6d","modified":1526368421449},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1526368421455},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1526368421455},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"40de94fd18fcbd67a327d63b0d1e242a08aa5404","modified":1526368421456},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1526368421456},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1526368421456},{"_id":"themes/next/source/js/src/motion.js","hash":"50e57f8acb6924c6999cdcc664ddd3f0730d2061","modified":1526368421456},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1526368421457},{"_id":"themes/next/source/js/src/post-details.js","hash":"d1333fb588d4521b4d1e9c69aef06e0ad1bf0b12","modified":1526368421457},{"_id":"themes/next/source/js/src/utils.js","hash":"4284c67ea1435de2acd523f6d48c0d073fd1ad03","modified":1526368421458},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1526368421459},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1526368421458},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1526368421459},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1526368421459},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1526368421459},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1526368421460},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1526368421469},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1526368421469},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1526368421470},{"_id":"source/images/数据中台/现有的数据仓库架构.jpg","hash":"03674f7d88ee7c6eca252f4438117b5698f32b17","modified":1552472037000},{"_id":"themes/next/.git/objects/pack/pack-dc27a68dafb9ad03581d6f941c3feaf9f927bfc3.idx","hash":"ed0d055ffa2a43d71fdde6be4108cd88f5014c57","modified":1526368421336},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1526368421466},{"_id":"themes/next/source/images/avatar.jpg","hash":"e02f499056e9d6fde4dd9f4cd468a652359d6fd7","modified":1503249010000},{"_id":"source/images/kettle/开源ETL工具-kettle_Jobs（工作）.png","hash":"420f30fb3d264b426b0d466106384dbabb0dc8df","modified":1503249010000},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"172f755447b004adfc7d30929643fe7ac54943d0","modified":1552987445477},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1526368421354},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"6958a97fde63e03983ec2394a4f8e408860fb42b","modified":1526368421412},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1526368421412},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1526368421439},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"18309b68ff33163a6f76a39437e618bb6ed411f8","modified":1526368421440},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1526368421440},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1526368421440},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"0810e7c43d6c8adc8434a8fa66eabe0436ab8178","modified":1526368421441},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1526368421441},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1526368421441},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"f362fbc791dafb378807cabbc58abf03e097af6d","modified":1526368421442},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1526368421443},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1526368421443},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"0bef9f0dc134215bc4d0984ba3a16a1a0b6f87ec","modified":1526368421443},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"f43c821ea272f80703862260b140932fe4aa0e1f","modified":1526368421443},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"2212511ae14258d93bec57993c0385e5ffbb382b","modified":1526368421443},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1526368421444},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1526368421445},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"5e12572b18846250e016a872a738026478ceef37","modified":1526368421444},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"35f093fe4c1861661ac1542d6e8ea5a9bbfeb659","modified":1526368421445},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1526368421445},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1526368421446},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"d5e8ea6336bc2e237d501ed0d5bbcbbfe296c832","modified":1526368421446},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1526368421447},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"05a5abf02e84ba8f639b6f9533418359f0ae4ecb","modified":1526368421447},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1526368421447},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"ba1842dbeb97e46c6c4d2ae0e7a2ca6d610ada67","modified":1526368421447},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"5779cc8086b1cfde9bc4f1afdd85223bdc45f0a0","modified":1526368421448},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"41f9cdafa00e256561c50ae0b97ab7fcd7c1d6a2","modified":1526368421448},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1526368421422},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"ffa870c3fa37a48b01dc6f967e66f5df508d02bf","modified":1526368421448},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1526368421422},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1526368421422},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1526368421422},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1526368421423},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1526368421427},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1526368421457},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1526368421435},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1526368421461},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1526368421460},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1526368421461},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1526368421466},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1526368421467},{"_id":"source/images/hadoop/kylin/Kylin的技术架构.jpg","hash":"bb0ae5d716d913bcbffa15fd1b8cc14307a1aa36","modified":1503249010000},{"_id":"source/images/数据中台/管理驾驶舱设计-页面跳转设计.jpg","hash":"7ad5bdaceaa69c2c971eb415d5fb848da4913458","modified":1552472791000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1526368421464},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1526368421465},{"_id":"source/images/hadoop/kylin/一个四维Cube的例子.jpg","hash":"69401999f9322bbe99d7537ea438a431a479118c","modified":1503249010000},{"_id":"themes/next/.git/objects/07/14eaa6e0ac8607fd134c6b1e93c16c7ede8225","hash":"342cb43ba1c85481a52daf397c5adfb1460f7ad8","modified":1526381654522},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"6a8952dd2db8ea48c2f7f63d92aa247fad2992fb","modified":1526368421354},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1526368421444},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1526368421445},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1526368421446},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1526368421424},{"_id":"themes/next/source/css/_common/components/header/github-banner.styl","hash":"ee37e6c465b9b2a7e39175fccfcbed14f2db039b","modified":1526368421423},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1526368421424},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"7cc3f36222494c9a1325c5347d7eb9ae53755a32","modified":1526368421423},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1526368421424},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1526368421424},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"17b95828f9db7f131ec0361a8c0e89b0b5c9bff5","modified":1526368421425},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1526368421425},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1526368421425},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"fb451dc4cc0355b57849c27d3eb110c73562f794","modified":1526368421426},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"7dd9a0378ccff3e4a2003f486b1a34e74c20dac6","modified":1526368421425},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1526368421426},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1526368421427},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1526368421427},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1526368421426},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"39dee82d481dd9d44e33658960ec63e47cd0a715","modified":1526368421423},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1526368421428},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1526368421428},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1526368421428},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"ca89b167d368eac50a4f808fa53ba67e69cbef94","modified":1526368421428},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1526368421429},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"417f05ff12a2aaca6ceeac8b7e7eb26e9440c4c3","modified":1526368421429},{"_id":"themes/next/source/css/_common/components/post/post-reading_progress.styl","hash":"f4e9f870baa56eae423a123062f00e24cc780be1","modified":1526368421430},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1526368421429},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1526368421430},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1526368421430},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1526368421430},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"c0ac49fadd33ca4a9a0a04d5ff2ac6560d0ecd9e","modified":1526368421430},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1526368421425},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1526368421431},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1526368421431},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"35c0350096921dd8e2222ec41b6c17a4ea6b44f2","modified":1526368421432},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"8bf095377d28881f63a30bd7db97526829103bf2","modified":1526368421431},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1526368421433},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"bbe0d111f6451fc04e52719fd538bd0753ec17f9","modified":1526368421432},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1526368421432},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1526368421433},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1526368421434},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1526368421433},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"4427ed3250483ed5b7baad74fa93474bd1eda729","modified":1526368421434},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"43bc58daa8d35d5d515dc787ceb21dd77633fe49","modified":1526368421434},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1526368421435},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1526368421435},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1526368421435},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"5d15cc8bbefe44c77a9b9f96bf04a6033a4b35b8","modified":1526368421436},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1526368421436},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1526368421436},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1526368421437},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1526368421437},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1526368421436},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"10e9bb3392826a5a8f4cabfc14c6d81645f33fe6","modified":1526368421437},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1526368421437},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1526368421438},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1526368421438},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1526368421438},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1526368421438},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1526368421438},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1526368421439},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1526368421439},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"76937db9702053d772f6758d9cea4088c2a6e2a3","modified":1526368421439},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1c06be422bc41fd35e5c7948cdea2c09961207f6","modified":1526368421439},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1526368421463},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1526368421468},{"_id":"source/images/数据中台/管理驾驶舱设计-页面流设计.jpg","hash":"c971fe3663b92dd3614e285b1f5ea9ad50dd98ba","modified":1552472772000},{"_id":"source/images/hadoop/kylin/维度和度量的例子.jpg","hash":"6c6dfb29f569da77258ef8247073f63383214f47","modified":1503249010000},{"_id":"themes/next/.git/objects/pack/pack-dc27a68dafb9ad03581d6f941c3feaf9f927bfc3.pack","hash":"79dcd2540e094616455afc031dc97ec0747dfaf1","modified":1526368421335},{"_id":"public/baidu_verify_iea4FlOhCY.html","hash":"a4dfa4aea72ac2f80d150ab3370a0945e3546883","modified":1557892712472},{"_id":"public/archives/2016/09/index.html","hash":"f6429941d6f1493e9ba81d892ba1cebfadd0d276","modified":1557892712472},{"_id":"public/archives/2017/06/index.html","hash":"93d58acd386636b19b97e83ac26890f505c66be1","modified":1557892712473},{"_id":"public/archives/2018/05/index.html","hash":"8996796005be739b9e061e0d57a6fb0efe7bb32e","modified":1557892712473},{"_id":"public/archives/2018/12/index.html","hash":"8276920abd680ac263a37c1d4189c1a8a3958f4f","modified":1557892712473},{"_id":"public/archives/2019/03/index.html","hash":"906274af19e4f32dfcffc46b08d6c712d7ff8949","modified":1557892712473},{"_id":"public/categories/markdown/index.html","hash":"8f7fce1d46754e287353076ba7e8a6bbfbe576f6","modified":1557892712473},{"_id":"public/categories/分布式/hbase/index.html","hash":"eeca1036531ee34f4c5f20a8b1df8a041b7a03f8","modified":1557892712473},{"_id":"public/categories/大数据/hdfs/index.html","hash":"dc0e447091073a7063e85934f258dc4ec5091cc5","modified":1557892712473},{"_id":"public/categories/分布式/分布式存储/index.html","hash":"f895a89cd9f2cb5bb0f9be998f2d7d866d8fb8bc","modified":1557892712473},{"_id":"public/categories/大数据/实时分析/index.html","hash":"28a42a84e3bfbaecb520dd73b1d81b45e8b94787","modified":1557892712473},{"_id":"public/categories/大数据/spark/index.html","hash":"be98a8655a9a16641e4775861cb36254b3d64c63","modified":1557892712473},{"_id":"public/categories/开源项目/spring/index.html","hash":"1ac0867d7a179a6ee5af9bec5aaf63b559c4334a","modified":1557892712473},{"_id":"public/categories/大数据/流式计算/index.html","hash":"e30e9aa742afc52b8b67b01a507b4e443edfcb05","modified":1557892712473},{"_id":"public/categories/分布式/负载均衡/index.html","hash":"ad972bb9fb26dbc1be5505a9cf188eddda4f92f3","modified":1557892712473},{"_id":"public/categories/大数据/hive/index.html","hash":"fb5dedf47ff28cc69f6bf8118e7735d471ef4112","modified":1557892712473},{"_id":"public/categories/大数据/数据分析/index.html","hash":"495ea13662393d699f76b9ffc5ae8589cda5dcf5","modified":1557892712473},{"_id":"public/categories/服务/index.html","hash":"114c8bf64e4d27ae1cb12072dac9258c6ca001a7","modified":1557892712473},{"_id":"public/categories/java/jdk源码/index.html","hash":"d59532f9cab0e5d2e97d1644207ff97f03e89f01","modified":1557892712473},{"_id":"public/categories/写作/index.html","hash":"abcfa937cfbe3dc1a8f933f5d03fd1903bd075d5","modified":1557892712473},{"_id":"public/categories/广告/index.html","hash":"1467790e1a9d41beabd1d706c3ab134dfafe7672","modified":1557892712473},{"_id":"public/categories/linux/网络/index.html","hash":"005f17865c602926143abf2182e01becb53c48f7","modified":1557892712473},{"_id":"public/categories/tools/博客/index.html","hash":"486dcab234e740fa6d0046049b64eea0a70858e6","modified":1557892712474},{"_id":"public/categories/软件工程/算法/index.html","hash":"fa6dd28776fd4ae710e093cdf088c161ce9d0dc3","modified":1557892712474},{"_id":"public/categories/软件工程/设计模式/index.html","hash":"0a16fdb391c4d61e83c108b8fe6c9a1a6db49473","modified":1557892712474},{"_id":"public/categories/分布式/分布式计算/index.html","hash":"f3900103cda49276d647058214e8c7b2b805a552","modified":1557892712474},{"_id":"public/categories/大数据/数据仓库/index.html","hash":"6cc8fcf2741e662e968113ed2c8ea0c1ca51ca78","modified":1557892712474},{"_id":"public/categories/java/jms/index.html","hash":"bcb14e5589c492e5f31bab89d9de53b97820603b","modified":1557892712474},{"_id":"public/categories/数据中台/管理驾驶舱设计/index.html","hash":"458f169c5318185571146a46a909e27409a9ddbe","modified":1557892712474},{"_id":"public/categories/大数据技术/index.html","hash":"70057ca25364dc3fdce8032cbd7f4aa3e211b2dc","modified":1557892712474},{"_id":"public/categories/tools/emacs/index.html","hash":"4ef8024fbc5021fb57178a7f2b4ee509ae95f8a1","modified":1557892712474},{"_id":"public/categories/tools/vim/index.html","hash":"83530d3e41b7cb9f4793fe644eda9fc6a26d0dd0","modified":1557892712474},{"_id":"public/categories/大数据技术/Presto/index.html","hash":"fb054a50269d0b2b5b098c1a578b045fa6283ec6","modified":1557892712474},{"_id":"public/categories/前端/react-js/index.html","hash":"f4aaf882e0f2beca48f8fae4ca8df6fe48591d4f","modified":1557892712474},{"_id":"public/categories/大数据/kylin/index.html","hash":"b5f62bb286298777c35c04ac9a62f54b5d103c0d","modified":1557892712474},{"_id":"public/categories/读书/index.html","hash":"04c415e4d6162a6f2b0150ecf1717414adf9f317","modified":1557892712474},{"_id":"public/tags/markdown/index.html","hash":"1f13c060706030e5e864adbd0598a7a18eca3858","modified":1557892712474},{"_id":"public/tags/hbase/index.html","hash":"6061076625b06389db83f820f0b603519704ffa9","modified":1557892712474},{"_id":"public/tags/分布式存储/index.html","hash":"594ec8df4b909e122c22a598f7444d73d8fcb460","modified":1557892712474},{"_id":"public/tags/实时分析/index.html","hash":"a5a6d429f20fa5d75d415f9c37a41db719441399","modified":1557892712474},{"_id":"public/tags/流式计算/index.html","hash":"31f6b753c6cee32b6b6ec8d826fd152c25814b4c","modified":1557892712474},{"_id":"public/tags/hive/index.html","hash":"3fddbe634a0b6eff5d25a4040955dcf5336ec4ee","modified":1557892712474},{"_id":"public/tags/数据分析/index.html","hash":"c127a72b8c7d9e4d7af97ef08a813bf5f393c60f","modified":1557892712474},{"_id":"public/tags/jdk源码/index.html","hash":"1f52bd007999eeb91ab0e8e80dd6a79ec5cec799","modified":1557892712474},{"_id":"public/tags/网络/index.html","hash":"4c7b9048f84d13ee27a25c7152b21ca2c14756f6","modified":1557892712474},{"_id":"public/tags/spring/index.html","hash":"85dc92004a59e35228e8bf064c2bd13f57bacdf3","modified":1557892712475},{"_id":"public/tags/负载均衡/index.html","hash":"96f1a73575999d1310ab2a6c92e36ff09d15b89c","modified":1557892712475},{"_id":"public/tags/tools-博客/index.html","hash":"7982672ab5edce6c8e63165d2348089946266db8","modified":1557892712475},{"_id":"public/tags/服务/index.html","hash":"7b42fff104c9920b487ef3fb2459f9ac5ade9fe2","modified":1557892712475},{"_id":"public/tags/算法/index.html","hash":"38d80c0230ae99fdc40178d3e709da14dab4b7fb","modified":1557892712475},{"_id":"public/tags/设计模式/index.html","hash":"a888358a55e56d2afca96184f95259de62a5a12f","modified":1557892712475},{"_id":"public/tags/写作/index.html","hash":"7698ed2f33f2d7ec2d50742f0f08c35de0ff8623","modified":1557892712475},{"_id":"public/tags/广告/index.html","hash":"f8b1f92ac8702b7b2c53780b93d4c71bc5ef521f","modified":1557892712475},{"_id":"public/tags/分布式计算/index.html","hash":"78c75b00355308dbd7f03d6521a6ac69c86871ab","modified":1557892712475},{"_id":"public/tags/数据仓库/index.html","hash":"84dcd783721c7a2744b419cffa3678fd2711f2f5","modified":1557892712475},{"_id":"public/tags/数据采集/index.html","hash":"807a935d3713eb16b1edb864cb1172d1c9788d1b","modified":1557892712475},{"_id":"public/tags/jms/index.html","hash":"4fc4d2a70278635a5ea06bb92b5f562e059a6113","modified":1557892712475},{"_id":"public/tags/管理驾驶舱设计/index.html","hash":"1dd901c5251041727002dd44bff81ba39e470106","modified":1557892712475},{"_id":"public/tags/Presto/index.html","hash":"65b8190431e28ddf129165806d6241a48bb55eeb","modified":1557892712475},{"_id":"public/tags/tools-emacs/index.html","hash":"eff7e4d71cd4cc819160eddc06ad0ed2f289e082","modified":1557892712475},{"_id":"public/tags/tools-vim/index.html","hash":"f19d580471c52aab8165f690c6bc3be2fa025dd9","modified":1557892712475},{"_id":"public/tags/react-js/index.html","hash":"bd59c4945306e4679807fceab6e658e2dd8f0baf","modified":1557892712476},{"_id":"public/tags/kylin/index.html","hash":"7ffd3209c178c26c4945ffc8a23e92812f120f97","modified":1557892712476},{"_id":"public/tags/读书/index.html","hash":"17ca38c0b2180e832730bf2bb24eb8ee93aed87f","modified":1557892712476},{"_id":"public/README.html","hash":"b95874352e4d362ad551d8480532bf237842279a","modified":1557892712476},{"_id":"public/categories/index.html","hash":"ec00dffa20a3cb9dc49b223261bb8d7c519d9172","modified":1557892712476},{"_id":"public/about/index.html","hash":"03442096643fe5d3f5f964f3772ee398aa93057f","modified":1557892712476},{"_id":"public/tags/index.html","hash":"321c688b1f08f2702069db92f2e80f547045e606","modified":1557892712476},{"_id":"public/2019/03/13/数据中台/指标体系规划与管理驾驶舱设计/index.html","hash":"86a3302cc93900a0a4fb55f4e195fda7a6122c19","modified":1557892712476},{"_id":"public/2019/02/05/数据中台/数据建模方法论/index.html","hash":"7d1ed6f6d5b6fde88bbf2bcb759c095fb318339d","modified":1557892712476},{"_id":"public/2019/02/05/数据中台/数据建模-元数据/index.html","hash":"59b39546a07751d4cae4f13135cf9b74ae4fad23","modified":1557892712476},{"_id":"public/2019/02/01/数据中台/数据建模-事实表/index.html","hash":"23bf1d7465bf80649cd32f3fb97a2189cfba9baf","modified":1557892712476},{"_id":"public/2019/02/01/数据中台/分布式SQL查询引擎-Presto/index.html","hash":"eecc9cf3f1232bb928bf5fad69b7762ede96147c","modified":1557892712476},{"_id":"public/2019/01/20/广告/微小店/index.html","hash":"b13d301df3b07d41e54ec1eb2f3108b6b1dd6d53","modified":1557892712476},{"_id":"public/2019/01/18/数据中台/数据建模-维度/index.html","hash":"bdb01bcfe5fc2e30c28ee18c6ba04df0795a8184","modified":1557892712476},{"_id":"public/2018/12/05/数据中台/数据中台建设杂谈/index.html","hash":"8fb76abea9d96bf96d895fafb67fb85958523fd4","modified":1557892712476},{"_id":"public/2018/10/09/tools/通过Hexo找寻自己的Github Pages/index.html","hash":"8b640e546012da359c94e3fd35bf0a6360cee23e","modified":1557892712476},{"_id":"public/2018/10/09/读书/文章格式 /index.html","hash":"ac73a466bf6b28fd7a7bdd788d2d0a99515a4c44","modified":1557892712476},{"_id":"public/2018/07/18/读书/确定目标|方法论-SMART原则/index.html","hash":"deb39ee0c33c8b2234826c6758ad430ff929391d","modified":1557892712476},{"_id":"public/2018/07/18/读书/综合分析|方法论-SOWT分析法/index.html","hash":"215415650d0e6ec5e21603a297145a00866bfab1","modified":1557892712476},{"_id":"public/2018/07/07/读书/《卖掉法拉利的高僧》摘要 /index.html","hash":"7e21b3e92ba0ca7b6d312288c6d7ee8cd68d7ff6","modified":1557892712477},{"_id":"public/2018/05/22/分布式/负载均衡初识/index.html","hash":"e9d3ea2d7b14cd828f8ae1ad31b9f766e1127dca","modified":1557892712477},{"_id":"public/2017/08/18/异常/Java_heap_space_OutOfMemoryError/index.html","hash":"eab597d046bd1d55e3ab5cc6cf727f6dc8a56acd","modified":1557892712477},{"_id":"public/2017/08/18/异常/JasperListener类找不到/index.html","hash":"684139e8a16c4960e56ad4738de79fd18b4d9e21","modified":1557892712477},{"_id":"public/2017/08/18/异常/connection_holder_is_null/index.html","hash":"4a7639be8dc985aa02ad7a73c28d02d20cd2f1f9","modified":1557892712477},{"_id":"public/2017/08/18/异常/permGen_space_OutOfMemoryError/index.html","hash":"74733b9362a8295f26f10ef8c8619356bb339d40","modified":1557892712477},{"_id":"public/2017/06/09/服务/和田市卫浴安装家具安装/index.html","hash":"da4cdbf2bca67cb037694d6a15b090399c0aea18","modified":1557892712477},{"_id":"public/2017/05/30/review/Sonar代码审查-缺陷和修改/index.html","hash":"97e1208a163a8a39e2bf0fae74e1a5cce2571993","modified":1557892712477},{"_id":"public/2017/05/30/review/Findbug代码审查-缺陷和修改/index.html","hash":"c5fb003fd7ce1da0b5117b6af05d85c5f3ee4d89","modified":1557892712477},{"_id":"public/2017/05/16/网络安全/安全组第一次会议提出的问题整理/index.html","hash":"317e23ab8119154e5055f9ffd393970e7ee99926","modified":1557892712477},{"_id":"public/2017/05/08/hadoop/Hadoop知识点/index.html","hash":"7dea79e86fd527bb121847b312d6bf6bec365a46","modified":1557892712477},{"_id":"public/2017/05/04/tools/emacs/TODO-emacs入门/index.html","hash":"d01884b5653b728039c1464a4569047c45c08d80","modified":1557892712477},{"_id":"public/2017/05/04/tools/vim/TODO-vim入门实践/index.html","hash":"0eecdbad374cf4dd77b54a2e70b9365ace63ddb9","modified":1557892712477},{"_id":"public/2017/05/02/设计模式/主要设计模式及简要介绍/index.html","hash":"9ad3bd3025876fd9379be747ff4f8c6952b2450b","modified":1557892712477},{"_id":"public/2017/05/02/linux/Linux常用命令及操作/index.html","hash":"839b9e2f71933b7ba2b391e8ffd904df6e368e72","modified":1557892712478},{"_id":"public/2017/05/02/hadoop/HBase入门概念/index.html","hash":"8aa4f78febbed41a41f9bc070c621287a92059c3","modified":1557892712478},{"_id":"public/2017/05/02/hadoop/Hive入门概念/index.html","hash":"96635f6c185d6d9db0e45f159cc0f527e507371e","modified":1557892712478},{"_id":"public/2017/04/27/前端/angular.js/TODO-angular.js入门之HelloWorld/index.html","hash":"f6d28160b0423b462581eb7847819bfde7578d3c","modified":1557892712478},{"_id":"public/2017/04/27/前端/react.js/TODO-react.js入门之HelloWorld/index.html","hash":"0468cec947487845d384f06f39231cd39f0610f8","modified":1557892712478},{"_id":"public/2017/04/27/前端/vue.js/TODO-vue.js入门之HelloWorld/index.html","hash":"dba234aa16f7f3d983bac43b80c5e19bcb979295","modified":1557892712478},{"_id":"public/2017/04/18/java/jdk环境变量配置/index.html","hash":"02621c43e452ac2de85d8f7f9bbb0f95a0ed5422","modified":1557892712478},{"_id":"public/2017/04/18/Markdown基础入门/index.html","hash":"dc8d684b7908badda6ee94f181217e0347f76dd1","modified":1557892712478},{"_id":"public/2017/04/18/java/JDK源码分析之集合框架HashMap/index.html","hash":"91352259fcf16d4c01793d67f1e5053cc35a6502","modified":1557892712478},{"_id":"public/2017/04/18/spring/Spring源码分析之环境准备/index.html","hash":"3a5297bae8f440c0bcdd98362c7d17bced6a306b","modified":1557892712478},{"_id":"public/2017/04/16/hadoop/HDFS入门概念/index.html","hash":"031cd5a25298dc26f332844cb650b433b0e29a38","modified":1557892712478},{"_id":"public/2017/04/16/hadoop/Hadoop之分布式存储/index.html","hash":"e3896027b90c211b40f8df0cb46bee1cd33a28f9","modified":1557892712478},{"_id":"public/2017/04/16/hadoop/Hadoop之实时分析/index.html","hash":"7eed3025a167365f029ca5142957055d79701778","modified":1557892712478},{"_id":"public/2017/04/16/hadoop/Hadoop之流式计算/index.html","hash":"251d61c8fc223f5f131b47425b88813322646380","modified":1557892712478},{"_id":"public/2017/04/16/hadoop/数据分析软件分类/index.html","hash":"be416e9213397aeaf1c669fa001e8675b40a342e","modified":1557892712478},{"_id":"public/2017/04/16/spark/TODO-Spark体系概述/index.html","hash":"342ccf02ac07cd192b6d4ed048d3c77eeaa627c8","modified":1557892712478},{"_id":"public/2017/04/16/hadoop/Apache Spark与Apache Hadoop的关系/index.html","hash":"4403ccd18ee706fade6afc931318cd1096926e26","modified":1557892712478},{"_id":"public/2017/04/16/hadoop/Hadoop之分布式计算 /index.html","hash":"8dd234cc9104b5fac24999ddce4e63ed310b8a76","modified":1557892712478},{"_id":"public/2017/04/16/hadoop/Hadoop之数据采集/index.html","hash":"022c80c3c6357ada90853ccf329a52e7beade6d1","modified":1557892712479},{"_id":"public/2017/04/16/hadoop/Kylin入门概念/index.html","hash":"5b0a7f9b6bea69ebb0696ea8b7bb43307842b067","modified":1557892712479},{"_id":"public/2017/04/15/kettle/Kettle插件架构/index.html","hash":"f0931b5cf6d422791bd989201873c1d4ab6b4a77","modified":1557892712479},{"_id":"public/2017/04/15/kettle/开源ETL工具-kettle/index.html","hash":"f39143db0994e03d87ce3cfd713adfdb5007afe5","modified":1557892712479},{"_id":"public/2017/04/01/oracle/Oracle网络和数据库连接/index.html","hash":"2b276f233df47a6076e446b01b86450edf379d92","modified":1557892712479},{"_id":"public/2017/01/01/oracle/Oracle SQL优化/index.html","hash":"74160ba682649b2530b0005cb7e78489b1be8148","modified":1557892712479},{"_id":"public/2017/01/01/oracle/Oracle数据库系统架构/index.html","hash":"8306b0044a3eaa7174ea2364c20b317ef4c0aa8e","modified":1557892712479},{"_id":"public/2017/01/01/网络安全/企业安全组/index.html","hash":"a94c00cf5894143985656fc82d0512f4f3bd58a4","modified":1557892712479},{"_id":"public/2017/01/01/算法/常用算法概述/index.html","hash":"b49c0fab631d754ffc7da55c8bd9c5bb14aa3cb7","modified":1557892712479},{"_id":"public/2016/09/20/linux/Linux固定IP上网方式/index.html","hash":"abb27509e59e12d07b5d14199e33436340a8915b","modified":1557892712479},{"_id":"public/2016/05/22/kettle/Sorted Merge组件/index.html","hash":"16964b4f5fc99efc4a79b3893df42b4f0f5c33b7","modified":1557892712479},{"_id":"public/2016/05/22/kettle/Kettle源码构建过程/index.html","hash":"e4df006d3977f30f91af538522cb2aa3b78eb106","modified":1557892712479},{"_id":"public/2016/05/22/oracle/Oracle SQL基础知识/index.html","hash":"e8a9f086b2dc2b4e9446653317d71a34d960a960","modified":1557892712479},{"_id":"public/2016/05/21/oracle/RAW类型/index.html","hash":"5c1eef33c97b5675288bb34ac28c79496d9ad0b9","modified":1557892712479},{"_id":"public/2016/05/21/java/消息传送基础/index.html","hash":"8e8b09c2c0e82cc6be7f8d3c446363d000eb41b5","modified":1557892712479},{"_id":"public/2016/05/20/java/Java基础之转型/index.html","hash":"7f9a1ffb4b8f425e02b07546e6d47fd04d6377a1","modified":1557892712479},{"_id":"public/2016/05/20/linux/SSH用户等效性配置/index.html","hash":"7b20a06dcc41caa9582fe55c9b7b37a91dee876b","modified":1557892712480},{"_id":"public/2016/05/20/java/java中Object转String/index.html","hash":"14cb81c9a6746436aa3d2069dc86353b5b5afc1c","modified":1557892712480},{"_id":"public/archives/index.html","hash":"0fc9f80bce3b765bd6f7d9edefc18b58570ea720","modified":1557892712480},{"_id":"public/archives/page/3/index.html","hash":"90f87109077c68e052d1243d25b2169de2d377ea","modified":1557892712480},{"_id":"public/archives/page/2/index.html","hash":"46c7ac702c5c486ef89c2a51e1eb1ea57893da40","modified":1557892712480},{"_id":"public/archives/page/4/index.html","hash":"65a7d34eb6a88c7d181c5b6978dc89516f906b7a","modified":1557892712480},{"_id":"public/archives/page/5/index.html","hash":"018c37ece4a30a00baf6275b418826d14b3b1fcf","modified":1557892712480},{"_id":"public/archives/page/6/index.html","hash":"91a104368c3fba18ced48ad19ddceac6ad8b85ac","modified":1557892712480},{"_id":"public/archives/page/7/index.html","hash":"904c8075ae85004097d2c3ceb6720366f7e41820","modified":1557892712480},{"_id":"public/archives/2016/index.html","hash":"7f926e4e9784646e0b28d49897e09243f23087b2","modified":1557892712480},{"_id":"public/archives/2016/05/index.html","hash":"1645f422bbc3e95821f0bb7596ce13e5787edd5e","modified":1557892712480},{"_id":"public/archives/2017/index.html","hash":"ee20106e326b93d9b16abe538106a537eb017582","modified":1557892712480},{"_id":"public/archives/2017/page/3/index.html","hash":"ef4cd0a8cee11785321cd64c31198807ab35ebe3","modified":1557892712480},{"_id":"public/archives/2017/page/2/index.html","hash":"3153152cc70e94cccfa17fb0fed4db8fe7f7169e","modified":1557892712480},{"_id":"public/archives/2017/page/4/index.html","hash":"8c217d73a6e8ede42329a3ac2aa5d538075465a4","modified":1557892712480},{"_id":"public/archives/2017/01/index.html","hash":"054b210e610ef2c31734130d4af1fda855114d4b","modified":1557892712480},{"_id":"public/archives/2017/04/index.html","hash":"00afba5f760907413c2e2364bc83925f369493d8","modified":1557892712480},{"_id":"public/archives/2017/04/page/2/index.html","hash":"fcfecc4ccb92c64d0aab55633674f2a0a133e48a","modified":1557892712480},{"_id":"public/archives/2017/05/index.html","hash":"85da9575abb9738ee5ccf3701f6506ee20372e11","modified":1557892712481},{"_id":"public/archives/2017/08/index.html","hash":"fbadc345ea47eeb84d19fe09fdd5252a5d5e09bd","modified":1557892712481},{"_id":"public/archives/2018/index.html","hash":"0d9cab5fbd85ab0bcc89f6a7e91c729fc4afc90c","modified":1557892712481},{"_id":"public/archives/2018/07/index.html","hash":"25a4644ae434ec899d3cef1f41ef892196a5fd2a","modified":1557892712481},{"_id":"public/archives/2018/10/index.html","hash":"e90122213f4a086d6e7bd7cd46f53bf83215d43c","modified":1557892712481},{"_id":"public/archives/2019/index.html","hash":"f520cd2efa35a9439df6943cbeec93fd6559cb73","modified":1557892712481},{"_id":"public/archives/2019/01/index.html","hash":"9662d615dde47e5521d00ff0e43c1b4b4170817c","modified":1557892712481},{"_id":"public/archives/2019/02/index.html","hash":"0babe64960a4af77e329dd7a21e150a9d98f8f53","modified":1557892712481},{"_id":"public/index.html","hash":"d185da6ca8959f7a6bf9b03b4543d162095bc12c","modified":1557892712481},{"_id":"public/page/2/index.html","hash":"45ad097fc41907768f115ca6b5f85e7f9393cf5b","modified":1557892712481},{"_id":"public/page/3/index.html","hash":"e5051ad4fdb4daa7d477598924dd61681cbf2698","modified":1557892712481},{"_id":"public/page/4/index.html","hash":"bce7f72808045f04fdd843e564b9384a127dcbad","modified":1557892712482},{"_id":"public/page/5/index.html","hash":"7b53903564acaa6f7f75244ba7472dcb8a544f47","modified":1557892712482},{"_id":"public/page/6/index.html","hash":"86154d4f9c4ea8393b560f96230edaff2278e67a","modified":1557892712482},{"_id":"public/page/7/index.html","hash":"69de2a19f959885a52ba17d1f3c483473b326bcd","modified":1557892712482},{"_id":"public/categories/开源项目/index.html","hash":"af441160bf8e91decfb35e6e0e7c3360bcaafc65","modified":1557892712482},{"_id":"public/categories/分布式/index.html","hash":"4dda68380b1e4669aeb57efa76fe550a1c4f0be0","modified":1557892712482},{"_id":"public/categories/开源项目/kettle/index.html","hash":"71b33063762d900f5f99b74be8d315315237784e","modified":1557892712483},{"_id":"public/categories/大数据/index.html","hash":"ad01912041eabef05e7cd19e9c302edc1c9c5670","modified":1557892712483},{"_id":"public/categories/java/index.html","hash":"d45c11880a5fc87752a0178b570ba975df5ebb84","modified":1557892712483},{"_id":"public/categories/linux/index.html","hash":"a2b45f4a7f864e60002b5447d70fee20c972347a","modified":1557892712483},{"_id":"public/categories/数据库/index.html","hash":"df6d0c7f0c21bf848f0b63e7edfe48d2f6562d05","modified":1557892712483},{"_id":"public/categories/异常/index.html","hash":"a420543059293c96d5717d08f9e3f7320149513d","modified":1557892712483},{"_id":"public/categories/tools/index.html","hash":"81496f73f7c10b6a5da3f3c051f980e55b348e38","modified":1557892712483},{"_id":"public/categories/网络安全/index.html","hash":"65641138c969da93614ba03ea41ee4cbbed1542c","modified":1557892712483},{"_id":"public/categories/软件工程/index.html","hash":"94ec04f18fe76c5e80638b73e3bd9ee7a3beb2af","modified":1557892712483},{"_id":"public/categories/数据中台/index.html","hash":"65a8f4624b5759da8d5a950743e8d44c3e1ef05c","modified":1557892712483},{"_id":"public/categories/java/java基础/index.html","hash":"070bc0ee03e727d881b67c9db87f7ff5785548db","modified":1557892712483},{"_id":"public/categories/方法论/index.html","hash":"49d663b193a30b37a66106008a857acc5a806cbf","modified":1557892712483},{"_id":"public/categories/linux/linux基本配置/index.html","hash":"52072af20a1c442eeb7bd0a6f62b7426b3477be7","modified":1557892712483},{"_id":"public/categories/数据库/oracle/index.html","hash":"a1ad46a2fcb3199cead973d55f90a1445d0f0544","modified":1557892712483},{"_id":"public/categories/异常/tomcat/index.html","hash":"b4ad606e74f354e6d2f2da70087f78ba97f55f63","modified":1557892712483},{"_id":"public/categories/网络安全/安全小组/index.html","hash":"05fcded44a75ff2e59cafdab216ee1c931f11ae6","modified":1557892712483},{"_id":"public/categories/数据中台/模型设计/index.html","hash":"5d80ebf34c35bfa0540b9603cef01da8caa7b887","modified":1557892712484},{"_id":"public/categories/大数据/hadoop/index.html","hash":"4ae3213588f9aeed74e8c5fa027ba314e16506d7","modified":1557892712484},{"_id":"public/categories/前端/index.html","hash":"738c059eca94cf6fb8c301d98855c34d6d93586c","modified":1557892712484},{"_id":"public/categories/前端/angular-js/index.html","hash":"a6911af8132a7be1cd081c3d79d823c6f05ff9ab","modified":1557892712484},{"_id":"public/categories/review/index.html","hash":"f5c1278cc67dd070d024b13d9f57564e1b5287e8","modified":1557892712484},{"_id":"public/tags/开源项目/index.html","hash":"751ec863f7c3a3798a9d0f86ac66aa17cc88d44f","modified":1557892712484},{"_id":"public/tags/kettle/index.html","hash":"3e07a296119d5cf461e913c300313aace7650cf9","modified":1557892712484},{"_id":"public/tags/分布式/index.html","hash":"ec75f6c79a9cf52e1e96676511f54183bb85e19e","modified":1557892712484},{"_id":"public/tags/大数据/index.html","hash":"2de38ee4c44adf4ae905ff2149372c3ceee5700a","modified":1557892712484},{"_id":"public/tags/hadoop/index.html","hash":"9d37588b000def2009e984263a9224437c7a0323","modified":1557892712484},{"_id":"public/tags/java/index.html","hash":"81e9718e7a382b281abf27154ab1f776da028a62","modified":1557892712484},{"_id":"public/tags/java基础/index.html","hash":"bc066cf083b30992014a09d42cc470bf14dee609","modified":1557892712484},{"_id":"public/tags/linux/index.html","hash":"dc4a6d8c2eb911dc76d11fc704ad57264a0b373a","modified":1557892712484},{"_id":"public/tags/oracle/index.html","hash":"cbc12c8b74792d725a89d59638a68a1a212c5f6e","modified":1557892712484},{"_id":"public/tags/数据库/index.html","hash":"0202ecc41f081410e9c2a6dc3f87c530fce7007f","modified":1557892712484},{"_id":"public/tags/spark/index.html","hash":"3d4fdd313709ba67c01fe2d47ef05be4be01bb65","modified":1557892712484},{"_id":"public/tags/异常/index.html","hash":"6680a6d99c551504b7c32d91098c7797c440a512","modified":1557892712484},{"_id":"public/tags/tomcat/index.html","hash":"a048e9e9bc9bcec459ddc0d992be1b76e2edb96c","modified":1557892712484},{"_id":"public/tags/网络安全/index.html","hash":"43214c2d80c4b24a412e8d6e93a3b759ff2eab81","modified":1557892712484},{"_id":"public/tags/安全小组/index.html","hash":"58696dd37b6bcae0063c4fcd46d27f3b71d646a4","modified":1557892712484},{"_id":"public/tags/软件工程/index.html","hash":"d8fa2cd45c992f1998cdff7442c2ef94a47040b8","modified":1557892712485},{"_id":"public/tags/模型设计/index.html","hash":"0ff705819a4147ef79aeee0c15a5215f351c2319","modified":1557892712485},{"_id":"public/tags/方法论/index.html","hash":"54a24e4ed52fe876f1869a28ccb5013f7212bdf3","modified":1557892712485},{"_id":"public/tags/angular-js/index.html","hash":"89b2fef7a066e11120b0ce85e403e46f07e23666","modified":1557892712485},{"_id":"public/tags/review/index.html","hash":"a3d2c184544cf368274c06686b6536117edbacc2","modified":1557892712485},{"_id":"public/CNAME","hash":"92e9e439012ba1f244f1573d366b6df6f69e8360","modified":1557892712495},{"_id":"public/images/github.png","hash":"ec237c5368083111c4952dbd80148e8e375e206e","modified":1557892712495},{"_id":"public/images/cenrise10.jpg","hash":"004afe6e4189ddb75ea1f4289ed2f5a0fc63ae44","modified":1557892712496},{"_id":"public/images/favicon.ico","hash":"6ed407cb30e21a406a45d0076a4a3226d2633bf0","modified":1557892712496},{"_id":"public/images/douban.jpg","hash":"7bd59f85ca708d96a65dddd6981086cbb639cd81","modified":1557892712496},{"_id":"public/images/quora.jpeg","hash":"576783adddddee7ab97f15fcf3eba4565f4027dd","modified":1557892712496},{"_id":"public/images/meizhuang.png","hash":"422b2633c2a77683e03387c91c8e0e72638b427b","modified":1557892712496},{"_id":"public/images/twitter.png","hash":"8b678142eae17a91d47d6fbe6260ae5cd9781c9f","modified":1557892712496},{"_id":"public/images/taobao.png","hash":"c84ef7815c69fd97edaeb4b84772dfb89bc6ef52","modified":1557892712496},{"_id":"public/images/weibo.jpg","hash":"7f3fcab888eb49a6b21e9fb1b5a300bc9f7e1860","modified":1557892712496},{"_id":"public/images/zhihu.png","hash":"46f6e7bc2f6fb30b7bdbda83f9678efa003a68d5","modified":1557892712496},{"_id":"public/images/kettle/mail.jpg","hash":"7d1916b0d92f7c9aa9c1e747f7fefaeecd97d126","modified":1557892712496},{"_id":"public/images/kettle/sorted merger1.jpg","hash":"ba3ed99f8f4684e81e064d41780f5bc1a87e79fb","modified":1557892712496},{"_id":"public/images/kettle/开源ETL工具-kettle_ETL是什么.png","hash":"8da47a6bc4a7cccc87476040b8abf530dbd2aca1","modified":1557892712496},{"_id":"public/images/kettle/开源ETL工具-kettle_Jobs（工作）6.png","hash":"6c0c4f78e4a29da901770ff00cc0dadee2f1f1c0","modified":1557892712496},{"_id":"public/images/kettle/开源ETL工具-kettle_Jobs（工作）5.png","hash":"c7ca49eac6954c3caf7a278b2e57b811d7ccddc3","modified":1557892712496},{"_id":"public/images/kettle/开源ETL工具-kettle_Jobs（工作）4.png","hash":"3a58daf90045124022e3c5cd0271f090c3ac3fd6","modified":1557892712496},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1557892712496},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1557892712496},{"_id":"public/images/kettle/开源ETL工具-kettle_Jobs（工作）9.png","hash":"2e16235c079e3911348061430614bd6f790f21cd","modified":1557892712496},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1557892712496},{"_id":"public/images/kettle/开源ETL工具-kettle_Transformation(转换).jpg","hash":"60a026f89af1642da224c52a001a1e215366bfb2","modified":1557892712497},{"_id":"public/images/kettle/开源ETL工具-kettle_Step（步骤）.png","hash":"f26ad03a18d856fd198a3dfc0c898cc30b5d77a4","modified":1557892712497},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1557892712497},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1557892712497},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1557892712497},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1557892712497},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1557892712497},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1557892712497},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1557892712497},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1557892712497},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1557892712497},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1557892712497},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1557892712497},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1557892712497},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1557892712497},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1557892712497},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1557892712497},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1557892712497},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1557892712497},{"_id":"public/images/alipay.jpg","hash":"28b5cc9292796d0b37c8fdb2ed28a6b7e806c92f","modified":1557892712942},{"_id":"public/images/facebook.png","hash":"a404e32587f618a63375fcbae73d3c99ee4b590b","modified":1557892712943},{"_id":"public/images/wechatpay.jpg","hash":"3e83b139440b86ddaaa7868c62be1fba567d91e4","modified":1557892712944},{"_id":"public/images/kettle/开源ETL工具-kettle_Jobs（工作）3.png","hash":"8fbfeefaa2346dbcff8a735077c003b3731d720e","modified":1557892712944},{"_id":"public/images/kettle/开源ETL工具-kettle_Jobs（工作）8.png","hash":"50c05f7fa4fa0e9bf0295e784c57e6c53bf2f660","modified":1557892712944},{"_id":"public/images/kettle/Kettle插件架构001.jpg","hash":"142c232a45620ca45831388a094cacd8137c0671","modified":1557892712944},{"_id":"public/images/kettle/开源ETL工具-kettle_Jobs（工作）7.png","hash":"fd96587bd686fa59031e9d41b69c0d917f061b3a","modified":1557892712944},{"_id":"public/images/kettle/开源ETL工具-kettle_Kettle构成.jpg","hash":"0f34cfda2c040aaf3617352325d8c2776454cd43","modified":1557892712944},{"_id":"public/images/数据中台/标准数据中台构架.jpg","hash":"ce4e578f3bef76e002b33e8d2885f0eca3458692","modified":1557892712944},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1557892712944},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1557892712944},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1557892712950},{"_id":"public/js/src/bootstrap.js","hash":"40de94fd18fcbd67a327d63b0d1e242a08aa5404","modified":1557892712950},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1557892712951},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1557892712951},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1557892712951},{"_id":"public/js/src/post-details.js","hash":"d1333fb588d4521b4d1e9c69aef06e0ad1bf0b12","modified":1557892712951},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1557892712951},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1557892712951},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1557892712951},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1557892712951},{"_id":"public/css/main.css","hash":"46c9c1e7c71a8b283de5d4d2336feca6916a2373","modified":1557892712951},{"_id":"public/images/数据中台/理想的仓库.jpg","hash":"d9b1054eee18075750503aead44de6cc786ae28d","modified":1557892712951},{"_id":"public/images/数据中台/现有的数据仓库架构.jpg","hash":"03674f7d88ee7c6eca252f4438117b5698f32b17","modified":1557892712951},{"_id":"public/js/src/motion.js","hash":"50e57f8acb6924c6999cdcc664ddd3f0730d2061","modified":1557892712958},{"_id":"public/js/src/utils.js","hash":"4284c67ea1435de2acd523f6d48c0d073fd1ad03","modified":1557892712958},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1557892712958},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1557892712959},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1557892712959},{"_id":"public/images/kettle/开源ETL工具-kettle_Jobs（工作）.png","hash":"420f30fb3d264b426b0d466106384dbabb0dc8df","modified":1557892712963},{"_id":"public/images/hadoop/kylin/Kylin的技术架构.jpg","hash":"bb0ae5d716d913bcbffa15fd1b8cc14307a1aa36","modified":1557892712963},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1557892712963},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1557892712968},{"_id":"public/images/avatar.jpg","hash":"e02f499056e9d6fde4dd9f4cd468a652359d6fd7","modified":1557892712968},{"_id":"public/images/hadoop/kylin/一个四维Cube的例子.jpg","hash":"69401999f9322bbe99d7537ea438a431a479118c","modified":1557892712969},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1557892712971},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1557892712971},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1557892712971},{"_id":"public/images/数据中台/管理驾驶舱设计-页面跳转设计.jpg","hash":"7ad5bdaceaa69c2c971eb415d5fb848da4913458","modified":1557892712983},{"_id":"public/images/数据中台/管理驾驶舱设计-页面流设计.jpg","hash":"c971fe3663b92dd3614e285b1f5ea9ad50dd98ba","modified":1557892713016},{"_id":"public/images/hadoop/kylin/维度和度量的例子.jpg","hash":"6c6dfb29f569da77258ef8247073f63383214f47","modified":1557892713029},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1557892713038},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1557892713069}],"Category":[{"name":"markdown","_id":"cjvop3bh10005s77rmmvchelx"},{"name":"开源项目","_id":"cjvop3biv000cs77rtq74aims"},{"name":"分布式","_id":"cjvop3bj7000qs77rqovv5r0d"},{"name":"kettle","parent":"cjvop3biv000cs77rtq74aims","_id":"cjvop3bja000vs77rk12by62p"},{"name":"大数据","_id":"cjvop3bjd0012s77r447mhogj"},{"name":"hbase","parent":"cjvop3bj7000qs77rqovv5r0d","_id":"cjvop3bjx002as77rbr5wtxi9"},{"name":"java","_id":"cjvop3bk1002gs77rnltrg203"},{"name":"linux","_id":"cjvop3bkk0032s77r630w2f8z"},{"name":"hdfs","parent":"cjvop3bjd0012s77r447mhogj","_id":"cjvop3bkn0038s77rmt02sd07"},{"name":"分布式存储","parent":"cjvop3bj7000qs77rqovv5r0d","_id":"cjvop3bkq003js77rskfc8v3i"},{"name":"数据库","_id":"cjvop3bkr003ms77rs491m1xk"},{"name":"实时分析","parent":"cjvop3bjd0012s77r447mhogj","_id":"cjvop3bkt003xs77rwkh5lni7"},{"name":"spark","parent":"cjvop3bjd0012s77r447mhogj","_id":"cjvop3bku0040s77rnzrd6scb"},{"name":"spring","parent":"cjvop3biv000cs77rtq74aims","_id":"cjvop3bkv0045s77rjdowso2s"},{"name":"异常","_id":"cjvop3bkv0049s77r9t3jcckb"},{"name":"流式计算","parent":"cjvop3bjd0012s77r447mhogj","_id":"cjvop3bkx004es77rzs4xsl7p"},{"name":"负载均衡","parent":"cjvop3bj7000qs77rqovv5r0d","_id":"cjvop3bky004ms77rv80mi0k3"},{"name":"tools","_id":"cjvop3bl0004ts77r5cdlxchh"},{"name":"hive","parent":"cjvop3bjd0012s77r447mhogj","_id":"cjvop3bl0004ys77rktha3y7g"},{"name":"网络安全","_id":"cjvop3bl20054s77rbnwds7my"},{"name":"数据分析","parent":"cjvop3bjd0012s77r447mhogj","_id":"cjvop3bl3005as77rh5qn3nn2"},{"name":"服务","_id":"cjvop3bl4005fs77rufciu60p"},{"name":"软件工程","_id":"cjvop3bl4005is77rt2x4x5z5"},{"name":"jdk源码","parent":"cjvop3bk1002gs77rnltrg203","_id":"cjvop3bl5005ts77ri1lxxy30"},{"name":"数据中台","_id":"cjvop3bl6005ws77ricghei5f"},{"name":"java基础","parent":"cjvop3bk1002gs77rnltrg203","_id":"cjvop3bl80066s77rgtb1ouyv"},{"name":"写作","_id":"cjvop3blc006ns77rj4qm5e4o"},{"name":"广告","_id":"cjvop3ble006rs77r6bqxjhw4"},{"name":"方法论","_id":"cjvop3blf006ws77rc0g93ckt"},{"name":"网络","parent":"cjvop3bkk0032s77r630w2f8z","_id":"cjvop3blf0070s77rra7cvfsz"},{"name":"linux基本配置","parent":"cjvop3bkk0032s77r630w2f8z","_id":"cjvop3blg0077s77r8voc3ye5"},{"name":"oracle","parent":"cjvop3bkr003ms77rs491m1xk","_id":"cjvop3bli007hs77rmf2aga6j"},{"name":"tomcat","parent":"cjvop3bkv0049s77r9t3jcckb","_id":"cjvop3blk007vs77rzzgj4b1o"},{"name":"博客","parent":"cjvop3bl0004ts77r5cdlxchh","_id":"cjvop3blo008bs77rz16qetev"},{"name":"安全小组","parent":"cjvop3bl20054s77rbnwds7my","_id":"cjvop3blp008ks77rovhd9m1s"},{"name":"算法","parent":"cjvop3bl4005is77rt2x4x5z5","_id":"cjvop3blq008qs77rlk5hmeej"},{"name":"设计模式","parent":"cjvop3bl4005is77rt2x4x5z5","_id":"cjvop3bls008ys77r0260syl4"},{"name":"模型设计","parent":"cjvop3bl6005ws77ricghei5f","_id":"cjvop3bls0092s77r5ghian5w"},{"name":"hadoop","parent":"cjvop3bjd0012s77r447mhogj","_id":"cjvop3bmd009ls77r0disjqid"},{"name":"分布式计算","parent":"cjvop3bj7000qs77rqovv5r0d","_id":"cjvop3bmh009rs77reolnf8k0"},{"name":"数据仓库","parent":"cjvop3bjd0012s77r447mhogj","_id":"cjvop3bmj009xs77rzjysrd8b"},{"name":"jms","parent":"cjvop3bk1002gs77rnltrg203","_id":"cjvop3bml00a3s77ry8nqv4gk"},{"name":"管理驾驶舱设计","parent":"cjvop3bl6005ws77ricghei5f","_id":"cjvop3bmm00a8s77r25svqhgg"},{"name":"大数据技术","_id":"cjvop3boz00aqs77rh6tc1p36"},{"name":"emacs","parent":"cjvop3bl0004ts77r5cdlxchh","_id":"cjvop3bp400ays77rw4fp6r9a"},{"name":"vim","parent":"cjvop3bl0004ts77r5cdlxchh","_id":"cjvop3bp600b2s77r5vmb1iu7"},{"name":"前端","_id":"cjvop3bp700b6s77rtwmfr29p"},{"name":"Presto","parent":"cjvop3boz00aqs77rh6tc1p36","_id":"cjvop3bp800bbs77r06sj33j4"},{"name":"angular.js","parent":"cjvop3bp700b6s77rtwmfr29p","_id":"cjvop3bpb00bms77r200ki2pe"},{"name":"react.js","parent":"cjvop3bp700b6s77rtwmfr29p","_id":"cjvop3bpb00bns77rvdh8gb05"},{"name":"kylin","parent":"cjvop3bjd0012s77r447mhogj","_id":"cjvop3bpq00bys77r006y7z8g"},{"name":"review","_id":"cjvop3bpq00c0s77rawmesu07"},{"name":"读书","_id":"cjvop3bqg00cls77rwnb3i6cn"}],"Data":[],"Page":[{"_content":"# jiadongpo.github.io\nbiannuo.com\n","source":"README.md","raw":"# jiadongpo.github.io\nbiannuo.com\n","date":"2019-05-15T03:24:59.921Z","updated":"2019-05-15T03:24:59.920Z","path":"README.html","title":"","comments":1,"layout":"page","_id":"cjvop3baa0000s77ro9ttkw1w","content":"<h1 id=\"jiadongpo-github-io\"><a href=\"#jiadongpo-github-io\" class=\"headerlink\" title=\"jiadongpo.github.io\"></a>jiadongpo.github.io</h1><p>biannuo.com</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"jiadongpo-github-io\"><a href=\"#jiadongpo-github-io\" class=\"headerlink\" title=\"jiadongpo.github.io\"></a>jiadongpo.github.io</h1><p>biannuo.com</p>\n"},{"_content":"iea4FlOhCY","source":"baidu_verify_iea4FlOhCY.html","raw":"iea4FlOhCY","date":"2018-10-09T06:58:30.617Z","updated":"2017-08-20T17:10:10.000Z","path":"baidu_verify_iea4FlOhCY.html","title":"","comments":1,"layout":"page","_id":"cjvop3bac0001s77rsiyxhs4e","content":"iea4FlOhCY","site":{"data":{}},"excerpt":"","more":"iea4FlOhCY"},{"title":"分类","date":"2016-05-20T07:30:28.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2016-05-20 15:30:28\ntype: \"categories\"\ncomments: false\n---\n","updated":"2018-05-15T12:01:07.149Z","path":"categories/index.html","layout":"page","_id":"cjvop3bgu0002s77rubi624nb","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"关于","date":"2016-05-20T09:50:35.000Z","type":"about","comments":0,"_content":"\n推介：\n----------\n本站记录个人日常生活感悟、读书笔记及摘要、网络内容评论、技术等内容。\n\n起因\n----------\n该站起于2015年10月22号，当时无意中发现了Github Pages，于是就试着搭建了这个博客，后来出于对写博客的重要性认知不足，导致此站一度荒废，后来也有意无意更新过部分内容。  \n\n本站意图是用于激励自己更好的成长、积极的分享。知行合一，行远致胜!\n\n特别声明\n----------\n本站非商业用途，如有侵权还请告知。邮箱：295445156@qq.com。\n\n ","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2016-05-20 17:50:35\ntype: \"about\"\ncomments: false\n---\n\n推介：\n----------\n本站记录个人日常生活感悟、读书笔记及摘要、网络内容评论、技术等内容。\n\n起因\n----------\n该站起于2015年10月22号，当时无意中发现了Github Pages，于是就试着搭建了这个博客，后来出于对写博客的重要性认知不足，导致此站一度荒废，后来也有意无意更新过部分内容。  \n\n本站意图是用于激励自己更好的成长、积极的分享。知行合一，行远致胜!\n\n特别声明\n----------\n本站非商业用途，如有侵权还请告知。邮箱：295445156@qq.com。\n\n ","updated":"2019-05-15T03:39:50.609Z","path":"about/index.html","layout":"page","_id":"cjvop3bgz0004s77rubosadx3","content":"<h2 id=\"推介：\"><a href=\"#推介：\" class=\"headerlink\" title=\"推介：\"></a>推介：</h2><p>本站记录个人日常生活感悟、读书笔记及摘要、网络内容评论、技术等内容。</p>\n<h2 id=\"起因\"><a href=\"#起因\" class=\"headerlink\" title=\"起因\"></a>起因</h2><p>该站起于2015年10月22号，当时无意中发现了Github Pages，于是就试着搭建了这个博客，后来出于对写博客的重要性认知不足，导致此站一度荒废，后来也有意无意更新过部分内容。  </p>\n<p>本站意图是用于激励自己更好的成长、积极的分享。知行合一，行远致胜!</p>\n<h2 id=\"特别声明\"><a href=\"#特别声明\" class=\"headerlink\" title=\"特别声明\"></a>特别声明</h2><p>本站非商业用途，如有侵权还请告知。邮箱：<a href=\"mailto:295445156@qq.com\" target=\"_blank\" rel=\"noopener\">295445156@qq.com</a>。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"推介：\"><a href=\"#推介：\" class=\"headerlink\" title=\"推介：\"></a>推介：</h2><p>本站记录个人日常生活感悟、读书笔记及摘要、网络内容评论、技术等内容。</p>\n<h2 id=\"起因\"><a href=\"#起因\" class=\"headerlink\" title=\"起因\"></a>起因</h2><p>该站起于2015年10月22号，当时无意中发现了Github Pages，于是就试着搭建了这个博客，后来出于对写博客的重要性认知不足，导致此站一度荒废，后来也有意无意更新过部分内容。  </p>\n<p>本站意图是用于激励自己更好的成长、积极的分享。知行合一，行远致胜!</p>\n<h2 id=\"特别声明\"><a href=\"#特别声明\" class=\"headerlink\" title=\"特别声明\"></a>特别声明</h2><p>本站非商业用途，如有侵权还请告知。邮箱：<a href=\"mailto:295445156@qq.com\" target=\"_blank\" rel=\"noopener\">295445156@qq.com</a>。</p>\n"},{"title":"标签","date":"2016-05-20T07:30:01.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2016-05-20 15:30:01\ntype: \"tags\"\ncomments: false\n---\n","updated":"2018-05-15T12:01:17.440Z","path":"tags/index.html","layout":"page","_id":"cjvop3bh30007s77r2vk24kao","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Markdown基础入门","date":"2017-04-18T07:00:00.000Z","_content":"\n简介\n----------\nMarkdown 的目标是实现「易读易写」。\n\n\n表格\n----------\n实现表格的两种方式  \n方式一：当某项过长时，表格可能如下显示，不好看。  \n具体使用方式请看示例。  \n•\t------: 为右对齐。  \n•\t:------ 为左对齐。  \n•\t:------: 为居中对齐。  \n•\t------- 为使用默认居中对齐。  \n1.9.2 示例  \n|         属性项               |                    属性说明    \n|    ------: |    :-------:    |    :---------   |    ------    |\n|    组件名称    |    步骤的名字，这个名字在一个转换中必须是唯一的。    | \n|    字段    |    指定字段名和排序方向(升序/降序);点击获取字段检索列表字段从输入流    | \n|字段|指定排序的字段名。|\n|升序|排序原则：升序或降序。如果选择升序，排序顺序将是：数字->英文->汉字，汉字是按照拼音排序的，也同样会按照声调排序。如果是多音字，只会取一个读音，无法根据语境判断其的读音。|\n\n显示如下：  \n \n注意  \n1.\t每个Markdown解析器都不一样，可能左右居中对齐方式的表示方式不一样。  \n\n方式二：表格形式（推荐）    \n\n`<table>\n    <tr>  \n        <th>属性项</th>  \n        <th>属性说明</th>  \n    </tr>\n    <tr>\n        <td>组件名称</td>\n        <td>步骤的名字，这个名字在一个转换中必须是唯一的。</td>\n    </tr>\n    <tr>\n        <td>字段</td>\n        <td>指定字段名和排序方向(升序/降序);点击获取字段检索列表字段从输入流。</td>\n    </tr>\n    <tr>\n        <td>字段</td>\n        <td>指定排序的字段名。</td>\n    </tr>\n    <tr>\n        <td>升序</td>\n        <td>排序原则：升序或降序。如果选择升序，    \n        排序顺序将是：数字->英文->汉字，汉字是按照拼音排序的，    \n        也同样会按照声调排序。如果是多音字，只会取一个读音，    \n        无法根据语境判断其的读音。</td>\n    </tr>\n</table>`\n输出如下：  \n<table>\n    <tr>  \n        <th>属性项</th>  \n        <th>属性说明</th>  \n    </tr>\n    <tr>\n        <td>组件名称</td>\n        <td>步骤的名字，这个名字在一个转换中必须是唯一的。</td>\n    </tr>\n    <tr>\n        <td>字段</td>\n        <td>指定字段名和排序方向(升序/降序);</td>\n    </tr>\n    <tr>\n        <td>字段</td>\n        <td>指定排序的字段名。</td>\n    </tr>\n    <tr>\n        <td>升序</td>\n        <td>排序原则：升序或降序。如果选择升\n    </tr>\n</table>\n\n\n\n\n首行缩进\n----------\n由于markdown语法主要考虑的是英文，所以对于中文的首行缩进并不太友好，两种方法都可以完美解决这个问题。\n\n- 把输入法由半角改为全角。 两次空格之后就能够有两个汉字的缩进。  \n\n\n- 在开头的时候，先输入下面的代码，然后紧跟着输入文本即可。分号也不要掉。   \n\n直接写  \n半方大的空白```&ensp;```或```&#8194;```   \n全方大的空白```&emsp;```或```&#8195;```  \n不断行的空白格```&nbsp;```或```&#160;```\n做为显示时这几个转义不能单独写，要在前后添加```\n\n","source":"_posts/Markdown基础入门.md","raw":"---\ntitle: Markdown基础入门\ndate: 2017-04-18 15:00:00\ntags: [markdown]\ncategories: [markdown]\n---\n\n简介\n----------\nMarkdown 的目标是实现「易读易写」。\n\n\n表格\n----------\n实现表格的两种方式  \n方式一：当某项过长时，表格可能如下显示，不好看。  \n具体使用方式请看示例。  \n•\t------: 为右对齐。  \n•\t:------ 为左对齐。  \n•\t:------: 为居中对齐。  \n•\t------- 为使用默认居中对齐。  \n1.9.2 示例  \n|         属性项               |                    属性说明    \n|    ------: |    :-------:    |    :---------   |    ------    |\n|    组件名称    |    步骤的名字，这个名字在一个转换中必须是唯一的。    | \n|    字段    |    指定字段名和排序方向(升序/降序);点击获取字段检索列表字段从输入流    | \n|字段|指定排序的字段名。|\n|升序|排序原则：升序或降序。如果选择升序，排序顺序将是：数字->英文->汉字，汉字是按照拼音排序的，也同样会按照声调排序。如果是多音字，只会取一个读音，无法根据语境判断其的读音。|\n\n显示如下：  \n \n注意  \n1.\t每个Markdown解析器都不一样，可能左右居中对齐方式的表示方式不一样。  \n\n方式二：表格形式（推荐）    \n\n`<table>\n    <tr>  \n        <th>属性项</th>  \n        <th>属性说明</th>  \n    </tr>\n    <tr>\n        <td>组件名称</td>\n        <td>步骤的名字，这个名字在一个转换中必须是唯一的。</td>\n    </tr>\n    <tr>\n        <td>字段</td>\n        <td>指定字段名和排序方向(升序/降序);点击获取字段检索列表字段从输入流。</td>\n    </tr>\n    <tr>\n        <td>字段</td>\n        <td>指定排序的字段名。</td>\n    </tr>\n    <tr>\n        <td>升序</td>\n        <td>排序原则：升序或降序。如果选择升序，    \n        排序顺序将是：数字->英文->汉字，汉字是按照拼音排序的，    \n        也同样会按照声调排序。如果是多音字，只会取一个读音，    \n        无法根据语境判断其的读音。</td>\n    </tr>\n</table>`\n输出如下：  \n<table>\n    <tr>  \n        <th>属性项</th>  \n        <th>属性说明</th>  \n    </tr>\n    <tr>\n        <td>组件名称</td>\n        <td>步骤的名字，这个名字在一个转换中必须是唯一的。</td>\n    </tr>\n    <tr>\n        <td>字段</td>\n        <td>指定字段名和排序方向(升序/降序);</td>\n    </tr>\n    <tr>\n        <td>字段</td>\n        <td>指定排序的字段名。</td>\n    </tr>\n    <tr>\n        <td>升序</td>\n        <td>排序原则：升序或降序。如果选择升\n    </tr>\n</table>\n\n\n\n\n首行缩进\n----------\n由于markdown语法主要考虑的是英文，所以对于中文的首行缩进并不太友好，两种方法都可以完美解决这个问题。\n\n- 把输入法由半角改为全角。 两次空格之后就能够有两个汉字的缩进。  \n\n\n- 在开头的时候，先输入下面的代码，然后紧跟着输入文本即可。分号也不要掉。   \n\n直接写  \n半方大的空白```&ensp;```或```&#8194;```   \n全方大的空白```&emsp;```或```&#8195;```  \n不断行的空白格```&nbsp;```或```&#160;```\n做为显示时这几个转义不能单独写，要在前后添加```\n\n","slug":"Markdown基础入门","published":1,"updated":"2017-08-18T01:44:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bgv0003s77rrxo1rgr2","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Markdown 的目标是实现「易读易写」。</p>\n<h2 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h2><p>实现表格的两种方式<br>方式一：当某项过长时，表格可能如下显示，不好看。<br>具体使用方式请看示例。<br>•    ——: 为右对齐。<br>•    :—— 为左对齐。<br>•    :——: 为居中对齐。<br>•    ——- 为使用默认居中对齐。<br>1.9.2 示例<br>|         属性项               |                    属性说明<br>|    ——: |    :——-:    |    :———   |    ——    |<br>|    组件名称    |    步骤的名字，这个名字在一个转换中必须是唯一的。    |<br>|    字段    |    指定字段名和排序方向(升序/降序);点击获取字段检索列表字段从输入流    |<br>|字段|指定排序的字段名。|<br>|升序|排序原则：升序或降序。如果选择升序，排序顺序将是：数字-&gt;英文-&gt;汉字，汉字是按照拼音排序的，也同样会按照声调排序。如果是多音字，只会取一个读音，无法根据语境判断其的读音。|</p>\n<p>显示如下：  </p>\n<p>注意  </p>\n<ol>\n<li>每个Markdown解析器都不一样，可能左右居中对齐方式的表示方式不一样。  </li>\n</ol>\n<p>方式二：表格形式（推荐）    </p>\n<p><code>&lt;table&gt;\n    &lt;tr&gt;  \n        &lt;th&gt;属性项&lt;/th&gt;  \n        &lt;th&gt;属性说明&lt;/th&gt;  \n    &lt;/tr&gt;\n    &lt;tr&gt;\n        &lt;td&gt;组件名称&lt;/td&gt;\n        &lt;td&gt;步骤的名字，这个名字在一个转换中必须是唯一的。&lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n        &lt;td&gt;字段&lt;/td&gt;\n        &lt;td&gt;指定字段名和排序方向(升序/降序);点击获取字段检索列表字段从输入流。&lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n        &lt;td&gt;字段&lt;/td&gt;\n        &lt;td&gt;指定排序的字段名。&lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n        &lt;td&gt;升序&lt;/td&gt;\n        &lt;td&gt;排序原则：升序或降序。如果选择升序，    \n        排序顺序将是：数字-&gt;英文-&gt;汉字，汉字是按照拼音排序的，    \n        也同样会按照声调排序。如果是多音字，只会取一个读音，    \n        无法根据语境判断其的读音。&lt;/td&gt;\n    &lt;/tr&gt;\n&lt;/table&gt;</code><br>输出如下：  </p>\n<table><br>    <tr><br>        <th>属性项</th><br>        <th>属性说明</th><br>    </tr><br>    <tr><br>        <td>组件名称</td><br>        <td>步骤的名字，这个名字在一个转换中必须是唯一的。</td><br>    </tr><br>    <tr><br>        <td>字段</td><br>        <td>指定字段名和排序方向(升序/降序);</td><br>    </tr><br>    <tr><br>        <td>字段</td><br>        <td>指定排序的字段名。</td><br>    </tr><br>    <tr><br>        <td>升序</td><br>        <td>排序原则：升序或降序。如果选择升<br>    </td></tr><br></table>\n\n\n\n\n<h2 id=\"首行缩进\"><a href=\"#首行缩进\" class=\"headerlink\" title=\"首行缩进\"></a>首行缩进</h2><p>由于markdown语法主要考虑的是英文，所以对于中文的首行缩进并不太友好，两种方法都可以完美解决这个问题。</p>\n<ul>\n<li>把输入法由半角改为全角。 两次空格之后就能够有两个汉字的缩进。  </li>\n</ul>\n<ul>\n<li>在开头的时候，先输入下面的代码，然后紧跟着输入文本即可。分号也不要掉。   </li>\n</ul>\n<p>直接写<br>半方大的空白<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">全方大的空白```&amp;emsp;```或```&amp;#8195;```  </span><br><span class=\"line\">不断行的空白格```&amp;nbsp;```或```&amp;#160;</span><br></pre></td></tr></table></figure></p>\n<p>做为显示时这几个转义不能单独写，要在前后添加<code>`</code></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Markdown 的目标是实现「易读易写」。</p>\n<h2 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h2><p>实现表格的两种方式<br>方式一：当某项过长时，表格可能如下显示，不好看。<br>具体使用方式请看示例。<br>•    ——: 为右对齐。<br>•    :—— 为左对齐。<br>•    :——: 为居中对齐。<br>•    ——- 为使用默认居中对齐。<br>1.9.2 示例<br>|         属性项               |                    属性说明<br>|    ——: |    :——-:    |    :———   |    ——    |<br>|    组件名称    |    步骤的名字，这个名字在一个转换中必须是唯一的。    |<br>|    字段    |    指定字段名和排序方向(升序/降序);点击获取字段检索列表字段从输入流    |<br>|字段|指定排序的字段名。|<br>|升序|排序原则：升序或降序。如果选择升序，排序顺序将是：数字-&gt;英文-&gt;汉字，汉字是按照拼音排序的，也同样会按照声调排序。如果是多音字，只会取一个读音，无法根据语境判断其的读音。|</p>\n<p>显示如下：  </p>\n<p>注意  </p>\n<ol>\n<li>每个Markdown解析器都不一样，可能左右居中对齐方式的表示方式不一样。  </li>\n</ol>\n<p>方式二：表格形式（推荐）    </p>\n<p><code>&lt;table&gt;\n    &lt;tr&gt;  \n        &lt;th&gt;属性项&lt;/th&gt;  \n        &lt;th&gt;属性说明&lt;/th&gt;  \n    &lt;/tr&gt;\n    &lt;tr&gt;\n        &lt;td&gt;组件名称&lt;/td&gt;\n        &lt;td&gt;步骤的名字，这个名字在一个转换中必须是唯一的。&lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n        &lt;td&gt;字段&lt;/td&gt;\n        &lt;td&gt;指定字段名和排序方向(升序/降序);点击获取字段检索列表字段从输入流。&lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n        &lt;td&gt;字段&lt;/td&gt;\n        &lt;td&gt;指定排序的字段名。&lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n        &lt;td&gt;升序&lt;/td&gt;\n        &lt;td&gt;排序原则：升序或降序。如果选择升序，    \n        排序顺序将是：数字-&gt;英文-&gt;汉字，汉字是按照拼音排序的，    \n        也同样会按照声调排序。如果是多音字，只会取一个读音，    \n        无法根据语境判断其的读音。&lt;/td&gt;\n    &lt;/tr&gt;\n&lt;/table&gt;</code><br>输出如下：  </p>\n<table><br>    <tr><br>        <th>属性项</th><br>        <th>属性说明</th><br>    </tr><br>    <tr><br>        <td>组件名称</td><br>        <td>步骤的名字，这个名字在一个转换中必须是唯一的。</td><br>    </tr><br>    <tr><br>        <td>字段</td><br>        <td>指定字段名和排序方向(升序/降序);</td><br>    </tr><br>    <tr><br>        <td>字段</td><br>        <td>指定排序的字段名。</td><br>    </tr><br>    <tr><br>        <td>升序</td><br>        <td>排序原则：升序或降序。如果选择升<br>    </td></tr><br></table>\n\n\n\n\n<h2 id=\"首行缩进\"><a href=\"#首行缩进\" class=\"headerlink\" title=\"首行缩进\"></a>首行缩进</h2><p>由于markdown语法主要考虑的是英文，所以对于中文的首行缩进并不太友好，两种方法都可以完美解决这个问题。</p>\n<ul>\n<li>把输入法由半角改为全角。 两次空格之后就能够有两个汉字的缩进。  </li>\n</ul>\n<ul>\n<li>在开头的时候，先输入下面的代码，然后紧跟着输入文本即可。分号也不要掉。   </li>\n</ul>\n<p>直接写<br>半方大的空白<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">全方大的空白```&amp;emsp;```或```&amp;#8195;```  </span><br><span class=\"line\">不断行的空白格```&amp;nbsp;```或```&amp;#160;</span><br></pre></td></tr></table></figure></p>\n<p>做为显示时这几个转义不能单独写，要在前后添加<code>`</code></p>\n"},{"title":"Sorted Merge组件","date":"2016-05-22T06:43:49.000Z","_content":"## Sorted Merge组件 ##\n### 概念##\n<table>\n\t<tr>\n\t\t<th>图标</th>\n\t\t<th>组件名称</th>\n\t\t<th>功能说明</th>\n\t</tr>\n\t<tr>\n\t\t<td>图片</td>\n\t\t<td>Sorted Merge</td>\n\t\t<td>合并来自多个输入步骤的记录，提供按给定的关键字段进行排序后的行记录。</td>\n\t</tr>\n</table>\nSorted Merge组件处理来自多个输入步骤的记录，提供按给定的关键字段进行排序后的行记录的功能。\n    用例:当您并行方式使用“记录排序”步骤的多个副本(通过“改变起始的副本数量”或集群环境中时)的每个排序块需要合并在一起,以确保正确的排序序列。可以通过在在“记录排序”组件后添加”Sorted Merge”组件来处理。\n    注：应用于多个复本或集群环境下的并行运算时，前置组件必须为“记录排序”组件。表 0 15Sorted Merge组件属性说明\n<table>\n    <tr>\n        <th>属性项</th>\n        <th>属性说明</th>\n    </tr>\n    <tr>\n        <td>组件名称</td>\n        <td>步骤的名字，这个名字在一个转换中必须是唯一的。</td>\n    </tr>\n    <tr>\n        <td>字段</td>\n        <td>指定字段名和排序方向(升序/降序);点击获取字段检索列表字段从输入流。</td>\n    </tr>\n    <tr>\n        <td>字段</td>\n        <td>指定排序的字段名。</td>\n    </tr>\n    <tr>\n        <td>升序</td>\n        <td>排序原则：升序或降序。如果选择升序，    \n        排序顺序将是：数字->英文->汉字，汉字是按照拼音排序的，    \n        也同样会按照声调排序。如果是多音字，只会取一个读音，    \n        无法根据语境判断其的读音。</td>\n    </tr>\n</table>\n\n###问题释疑###\n1.\tSorted Merge组件是如何工作的？\n它用来合并2个输入数据流（按同一字段排序后的、相同格式的数据流）。\n \n2.\tSorted Merge组件的原理？\n用于比较两组数据以确保合并后的输出也是排序的。它是通过串行方式来处理的，并不需要考虑整个数据集合。它实际上用于不同机器的集群环境下，而不是在单机上。运行效率取决于你有多少个可用的CPU。\n \n3.\tSorted Merge组件的使用前提？\n对于“Sorted Merge”组件的所有输入行结构需要是相同的（相同的字段布局、字段类型等）且需要按指定的键进行排序。只有这样才能保证输出是该键进行排序的。\n \n4.\t“Sorted Merge”组件的排序字段指定为与“字段排序”组件排序字段相同时，不能按指定排序?\n Sorted Merge组件的合并是基于前置组件（”记录排序“组件）排好顺序的集合里的指定字段进行合并，排序是基于前置组件中相同排序字段的数据集内的排序，所以说在相同排序字段集中指定排序方式时，排序是不变的。既然没有意义为什么要保留呢？是因为与前置组件（Sorted Merge组件）保持一致，如果设计成按照排序字段的选择来去掉”Sorted Merge“组件中的对应字段，会增加复杂性，同时又需要解释为什么少一个字段，索性保留。\n \n5.\t对于的分区功能，Sorted Merge组件必要性？\n不是必须的。因为Sorted Merge多用于并行处理环境，常与分区功能组合使用，Sorted Merge组件是对分区的一种收集方式（Sorted Merge）的支持，所以说不是必须的，如果收集的记录不要求排序，我们完成可以不使用此组件；\n注：分区的收集是指当分区的组件处理完成发送到没有分区的组件时，记录将被合并。目前支持的合并方法有两种方式，一种是轮流从各个分区接收记录，另一种是对于Sorted Merge的收集方式，Kettle中有”Sorted Merge“组件来完成。\n \n6.\t记录排序组件和Sorted Merge组件都可以对多输入流的数据进行排序，有什么区别。\n使用场景不同，Sorted Merge组件应用于并行数据处理环境，是分区后的一种数据收集方式（Sorted Merge收集方式）。在大数据量时，原则上希望把尽可能多的数据处理放在集群上处理，然后在主服务器上进行合并，因为Sorted Merge组件的算法是基于已排好顺序的集合(归并排序算法)，在对已排过序的集合的排序效率高于记录排序。我们完全没必须把从属服务器上收集到的已排序的数据，使用“记录排序”组件再打乱重新排序。基于效率上考虑建议在对已排好序的数据集进行排序时，使用Sorted Merge组件。\n \n7.\t建议：分布式排序\n当需要使用排序组件时，最好将排序组件水平扩展到集群上运行，以获得较好的运行效率。每个从属服务器对传入的记录进行排序，然后在主服务器上使用Sorted Merge组件合并来自从属服务器的排序结果。Sorted Merge组件被设计用来接收从前面的组件接收排序后的记录，并且在合并时能够保证记录的顺序。对于已排序过的多个数据集进行排序时，Sorted Merge的效率高于记录排序，这也是使用Sorted Merge组件的原因。\n\n![\"分布式排序\"](/images/sorted merger1.jpg)\n\n","source":"_posts/kettle/Sorted Merge组件.md","raw":"---\ntitle: Sorted Merge组件\ndate: 2016-05-22 14:43:49\ntags: [开源项目,kettle]\ncategories: [开源项目,kettle]\n---\n## Sorted Merge组件 ##\n### 概念##\n<table>\n\t<tr>\n\t\t<th>图标</th>\n\t\t<th>组件名称</th>\n\t\t<th>功能说明</th>\n\t</tr>\n\t<tr>\n\t\t<td>图片</td>\n\t\t<td>Sorted Merge</td>\n\t\t<td>合并来自多个输入步骤的记录，提供按给定的关键字段进行排序后的行记录。</td>\n\t</tr>\n</table>\nSorted Merge组件处理来自多个输入步骤的记录，提供按给定的关键字段进行排序后的行记录的功能。\n    用例:当您并行方式使用“记录排序”步骤的多个副本(通过“改变起始的副本数量”或集群环境中时)的每个排序块需要合并在一起,以确保正确的排序序列。可以通过在在“记录排序”组件后添加”Sorted Merge”组件来处理。\n    注：应用于多个复本或集群环境下的并行运算时，前置组件必须为“记录排序”组件。表 0 15Sorted Merge组件属性说明\n<table>\n    <tr>\n        <th>属性项</th>\n        <th>属性说明</th>\n    </tr>\n    <tr>\n        <td>组件名称</td>\n        <td>步骤的名字，这个名字在一个转换中必须是唯一的。</td>\n    </tr>\n    <tr>\n        <td>字段</td>\n        <td>指定字段名和排序方向(升序/降序);点击获取字段检索列表字段从输入流。</td>\n    </tr>\n    <tr>\n        <td>字段</td>\n        <td>指定排序的字段名。</td>\n    </tr>\n    <tr>\n        <td>升序</td>\n        <td>排序原则：升序或降序。如果选择升序，    \n        排序顺序将是：数字->英文->汉字，汉字是按照拼音排序的，    \n        也同样会按照声调排序。如果是多音字，只会取一个读音，    \n        无法根据语境判断其的读音。</td>\n    </tr>\n</table>\n\n###问题释疑###\n1.\tSorted Merge组件是如何工作的？\n它用来合并2个输入数据流（按同一字段排序后的、相同格式的数据流）。\n \n2.\tSorted Merge组件的原理？\n用于比较两组数据以确保合并后的输出也是排序的。它是通过串行方式来处理的，并不需要考虑整个数据集合。它实际上用于不同机器的集群环境下，而不是在单机上。运行效率取决于你有多少个可用的CPU。\n \n3.\tSorted Merge组件的使用前提？\n对于“Sorted Merge”组件的所有输入行结构需要是相同的（相同的字段布局、字段类型等）且需要按指定的键进行排序。只有这样才能保证输出是该键进行排序的。\n \n4.\t“Sorted Merge”组件的排序字段指定为与“字段排序”组件排序字段相同时，不能按指定排序?\n Sorted Merge组件的合并是基于前置组件（”记录排序“组件）排好顺序的集合里的指定字段进行合并，排序是基于前置组件中相同排序字段的数据集内的排序，所以说在相同排序字段集中指定排序方式时，排序是不变的。既然没有意义为什么要保留呢？是因为与前置组件（Sorted Merge组件）保持一致，如果设计成按照排序字段的选择来去掉”Sorted Merge“组件中的对应字段，会增加复杂性，同时又需要解释为什么少一个字段，索性保留。\n \n5.\t对于的分区功能，Sorted Merge组件必要性？\n不是必须的。因为Sorted Merge多用于并行处理环境，常与分区功能组合使用，Sorted Merge组件是对分区的一种收集方式（Sorted Merge）的支持，所以说不是必须的，如果收集的记录不要求排序，我们完成可以不使用此组件；\n注：分区的收集是指当分区的组件处理完成发送到没有分区的组件时，记录将被合并。目前支持的合并方法有两种方式，一种是轮流从各个分区接收记录，另一种是对于Sorted Merge的收集方式，Kettle中有”Sorted Merge“组件来完成。\n \n6.\t记录排序组件和Sorted Merge组件都可以对多输入流的数据进行排序，有什么区别。\n使用场景不同，Sorted Merge组件应用于并行数据处理环境，是分区后的一种数据收集方式（Sorted Merge收集方式）。在大数据量时，原则上希望把尽可能多的数据处理放在集群上处理，然后在主服务器上进行合并，因为Sorted Merge组件的算法是基于已排好顺序的集合(归并排序算法)，在对已排过序的集合的排序效率高于记录排序。我们完全没必须把从属服务器上收集到的已排序的数据，使用“记录排序”组件再打乱重新排序。基于效率上考虑建议在对已排好序的数据集进行排序时，使用Sorted Merge组件。\n \n7.\t建议：分布式排序\n当需要使用排序组件时，最好将排序组件水平扩展到集群上运行，以获得较好的运行效率。每个从属服务器对传入的记录进行排序，然后在主服务器上使用Sorted Merge组件合并来自从属服务器的排序结果。Sorted Merge组件被设计用来接收从前面的组件接收排序后的记录，并且在合并时能够保证记录的顺序。对于已排序过的多个数据集进行排序时，Sorted Merge的效率高于记录排序，这也是使用Sorted Merge组件的原因。\n\n![\"分布式排序\"](/images/sorted merger1.jpg)\n\n","slug":"kettle/Sorted Merge组件","published":1,"updated":"2019-03-14T02:50:50.654Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bis000as77ruv0z53jn","content":"<h2 id=\"Sorted-Merge组件\"><a href=\"#Sorted-Merge组件\" class=\"headerlink\" title=\"Sorted Merge组件\"></a>Sorted Merge组件</h2><h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><table><br>    <tr><br>        <th>图标</th><br>        <th>组件名称</th><br>        <th>功能说明</th><br>    </tr><br>    <tr><br>        <td>图片</td><br>        <td>Sorted Merge</td><br>        <td>合并来自多个输入步骤的记录，提供按给定的关键字段进行排序后的行记录。</td><br>    </tr><br></table><br>Sorted Merge组件处理来自多个输入步骤的记录，提供按给定的关键字段进行排序后的行记录的功能。<br>    用例:当您并行方式使用“记录排序”步骤的多个副本(通过“改变起始的副本数量”或集群环境中时)的每个排序块需要合并在一起,以确保正确的排序序列。可以通过在在“记录排序”组件后添加”Sorted Merge”组件来处理。<br>    注：应用于多个复本或集群环境下的并行运算时，前置组件必须为“记录排序”组件。表 0 15Sorted Merge组件属性说明<br><table><br>    <tr><br>        <th>属性项</th><br>        <th>属性说明</th><br>    </tr><br>    <tr><br>        <td>组件名称</td><br>        <td>步骤的名字，这个名字在一个转换中必须是唯一的。</td><br>    </tr><br>    <tr><br>        <td>字段</td><br>        <td>指定字段名和排序方向(升序/降序);点击获取字段检索列表字段从输入流。</td><br>    </tr><br>    <tr><br>        <td>字段</td><br>        <td>指定排序的字段名。</td><br>    </tr><br>    <tr><br>        <td>升序</td><br>        <td>排序原则：升序或降序。如果选择升序，<br>        排序顺序将是：数字-&gt;英文-&gt;汉字，汉字是按照拼音排序的，<br>        也同样会按照声调排序。如果是多音字，只会取一个读音，<br>        无法根据语境判断其的读音。</td><br>    </tr><br></table>\n\n<p>###问题释疑###</p>\n<ol>\n<li><p>Sorted Merge组件是如何工作的？<br>它用来合并2个输入数据流（按同一字段排序后的、相同格式的数据流）。</p>\n</li>\n<li><p>Sorted Merge组件的原理？<br>用于比较两组数据以确保合并后的输出也是排序的。它是通过串行方式来处理的，并不需要考虑整个数据集合。它实际上用于不同机器的集群环境下，而不是在单机上。运行效率取决于你有多少个可用的CPU。</p>\n</li>\n<li><p>Sorted Merge组件的使用前提？<br>对于“Sorted Merge”组件的所有输入行结构需要是相同的（相同的字段布局、字段类型等）且需要按指定的键进行排序。只有这样才能保证输出是该键进行排序的。</p>\n</li>\n<li><p>“Sorted Merge”组件的排序字段指定为与“字段排序”组件排序字段相同时，不能按指定排序?<br>Sorted Merge组件的合并是基于前置组件（”记录排序“组件）排好顺序的集合里的指定字段进行合并，排序是基于前置组件中相同排序字段的数据集内的排序，所以说在相同排序字段集中指定排序方式时，排序是不变的。既然没有意义为什么要保留呢？是因为与前置组件（Sorted Merge组件）保持一致，如果设计成按照排序字段的选择来去掉”Sorted Merge“组件中的对应字段，会增加复杂性，同时又需要解释为什么少一个字段，索性保留。</p>\n</li>\n<li><p>对于的分区功能，Sorted Merge组件必要性？<br>不是必须的。因为Sorted Merge多用于并行处理环境，常与分区功能组合使用，Sorted Merge组件是对分区的一种收集方式（Sorted Merge）的支持，所以说不是必须的，如果收集的记录不要求排序，我们完成可以不使用此组件；<br>注：分区的收集是指当分区的组件处理完成发送到没有分区的组件时，记录将被合并。目前支持的合并方法有两种方式，一种是轮流从各个分区接收记录，另一种是对于Sorted Merge的收集方式，Kettle中有”Sorted Merge“组件来完成。</p>\n</li>\n<li><p>记录排序组件和Sorted Merge组件都可以对多输入流的数据进行排序，有什么区别。<br>使用场景不同，Sorted Merge组件应用于并行数据处理环境，是分区后的一种数据收集方式（Sorted Merge收集方式）。在大数据量时，原则上希望把尽可能多的数据处理放在集群上处理，然后在主服务器上进行合并，因为Sorted Merge组件的算法是基于已排好顺序的集合(归并排序算法)，在对已排过序的集合的排序效率高于记录排序。我们完全没必须把从属服务器上收集到的已排序的数据，使用“记录排序”组件再打乱重新排序。基于效率上考虑建议在对已排好序的数据集进行排序时，使用Sorted Merge组件。</p>\n</li>\n<li><p>建议：分布式排序<br>当需要使用排序组件时，最好将排序组件水平扩展到集群上运行，以获得较好的运行效率。每个从属服务器对传入的记录进行排序，然后在主服务器上使用Sorted Merge组件合并来自从属服务器的排序结果。Sorted Merge组件被设计用来接收从前面的组件接收排序后的记录，并且在合并时能够保证记录的顺序。对于已排序过的多个数据集进行排序时，Sorted Merge的效率高于记录排序，这也是使用Sorted Merge组件的原因。</p>\n</li>\n</ol>\n<p><img src=\"/images/sorted merger1.jpg\" alt=\"&quot;分布式排序&quot;\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Sorted-Merge组件\"><a href=\"#Sorted-Merge组件\" class=\"headerlink\" title=\"Sorted Merge组件\"></a>Sorted Merge组件</h2><h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><table><br>    <tr><br>        <th>图标</th><br>        <th>组件名称</th><br>        <th>功能说明</th><br>    </tr><br>    <tr><br>        <td>图片</td><br>        <td>Sorted Merge</td><br>        <td>合并来自多个输入步骤的记录，提供按给定的关键字段进行排序后的行记录。</td><br>    </tr><br></table><br>Sorted Merge组件处理来自多个输入步骤的记录，提供按给定的关键字段进行排序后的行记录的功能。<br>    用例:当您并行方式使用“记录排序”步骤的多个副本(通过“改变起始的副本数量”或集群环境中时)的每个排序块需要合并在一起,以确保正确的排序序列。可以通过在在“记录排序”组件后添加”Sorted Merge”组件来处理。<br>    注：应用于多个复本或集群环境下的并行运算时，前置组件必须为“记录排序”组件。表 0 15Sorted Merge组件属性说明<br><table><br>    <tr><br>        <th>属性项</th><br>        <th>属性说明</th><br>    </tr><br>    <tr><br>        <td>组件名称</td><br>        <td>步骤的名字，这个名字在一个转换中必须是唯一的。</td><br>    </tr><br>    <tr><br>        <td>字段</td><br>        <td>指定字段名和排序方向(升序/降序);点击获取字段检索列表字段从输入流。</td><br>    </tr><br>    <tr><br>        <td>字段</td><br>        <td>指定排序的字段名。</td><br>    </tr><br>    <tr><br>        <td>升序</td><br>        <td>排序原则：升序或降序。如果选择升序，<br>        排序顺序将是：数字-&gt;英文-&gt;汉字，汉字是按照拼音排序的，<br>        也同样会按照声调排序。如果是多音字，只会取一个读音，<br>        无法根据语境判断其的读音。</td><br>    </tr><br></table>\n\n<p>###问题释疑###</p>\n<ol>\n<li><p>Sorted Merge组件是如何工作的？<br>它用来合并2个输入数据流（按同一字段排序后的、相同格式的数据流）。</p>\n</li>\n<li><p>Sorted Merge组件的原理？<br>用于比较两组数据以确保合并后的输出也是排序的。它是通过串行方式来处理的，并不需要考虑整个数据集合。它实际上用于不同机器的集群环境下，而不是在单机上。运行效率取决于你有多少个可用的CPU。</p>\n</li>\n<li><p>Sorted Merge组件的使用前提？<br>对于“Sorted Merge”组件的所有输入行结构需要是相同的（相同的字段布局、字段类型等）且需要按指定的键进行排序。只有这样才能保证输出是该键进行排序的。</p>\n</li>\n<li><p>“Sorted Merge”组件的排序字段指定为与“字段排序”组件排序字段相同时，不能按指定排序?<br>Sorted Merge组件的合并是基于前置组件（”记录排序“组件）排好顺序的集合里的指定字段进行合并，排序是基于前置组件中相同排序字段的数据集内的排序，所以说在相同排序字段集中指定排序方式时，排序是不变的。既然没有意义为什么要保留呢？是因为与前置组件（Sorted Merge组件）保持一致，如果设计成按照排序字段的选择来去掉”Sorted Merge“组件中的对应字段，会增加复杂性，同时又需要解释为什么少一个字段，索性保留。</p>\n</li>\n<li><p>对于的分区功能，Sorted Merge组件必要性？<br>不是必须的。因为Sorted Merge多用于并行处理环境，常与分区功能组合使用，Sorted Merge组件是对分区的一种收集方式（Sorted Merge）的支持，所以说不是必须的，如果收集的记录不要求排序，我们完成可以不使用此组件；<br>注：分区的收集是指当分区的组件处理完成发送到没有分区的组件时，记录将被合并。目前支持的合并方法有两种方式，一种是轮流从各个分区接收记录，另一种是对于Sorted Merge的收集方式，Kettle中有”Sorted Merge“组件来完成。</p>\n</li>\n<li><p>记录排序组件和Sorted Merge组件都可以对多输入流的数据进行排序，有什么区别。<br>使用场景不同，Sorted Merge组件应用于并行数据处理环境，是分区后的一种数据收集方式（Sorted Merge收集方式）。在大数据量时，原则上希望把尽可能多的数据处理放在集群上处理，然后在主服务器上进行合并，因为Sorted Merge组件的算法是基于已排好顺序的集合(归并排序算法)，在对已排过序的集合的排序效率高于记录排序。我们完全没必须把从属服务器上收集到的已排序的数据，使用“记录排序”组件再打乱重新排序。基于效率上考虑建议在对已排好序的数据集进行排序时，使用Sorted Merge组件。</p>\n</li>\n<li><p>建议：分布式排序<br>当需要使用排序组件时，最好将排序组件水平扩展到集群上运行，以获得较好的运行效率。每个从属服务器对传入的记录进行排序，然后在主服务器上使用Sorted Merge组件合并来自从属服务器的排序结果。Sorted Merge组件被设计用来接收从前面的组件接收排序后的记录，并且在合并时能够保证记录的顺序。对于已排序过的多个数据集进行排序时，Sorted Merge的效率高于记录排序，这也是使用Sorted Merge组件的原因。</p>\n</li>\n</ol>\n<p><img src=\"/images/sorted merger1.jpg\" alt=\"&quot;分布式排序&quot;\"></p>\n"},{"title":"开源ETL工具-kettle","date":"2017-04-15T06:43:49.000Z","_content":"#开源ETL工具-kettle\n说明：本文部分内容参考网络的资料，如果侵权之处请告知一下，不胜感激！\n\nKettle是Pentaho公司开发的一款ETL产品，以工作流为核心，强调面向解决方案而非工具的，基于java平台的商业智能(Business Intelligence,BI)套件。Kettle的开源协议是LGPL，该协议来自GNU，因功能强大，被FSF(Free Software Foundation)列为首选协议。LGPL协议允许Kettle作为商业（非开源）代码的链接库，使用Kettle的商业代码无须开源。LGPL带来的不仅是Kettle API，你还可以对它进行拓展对外提供商业软件或服务。\n##  ##ETL是什么\n\nETL早期作为数据仓库的关键环节，负责将分布的、异构数据源中的数据如关系数据、平面数据文件等抽取到临时中间层后进行清洗、转换、集成，最后加载到数据仓库（Data Warehouse）或数据集市（Data Mart）中，成为联机分析处理（On-Line Analytical Processing，OLAP）、数据挖掘（Data Mining）的基础。\n\n\nExract：从多种异构数据源中抽取数据\n\nTransform：经过清洗，统一化和转换\n\nLoad：将数据加载到目的数据源中\n\n\n\n##  ##Kettle产品特点\n\n适用于将多个应用系统的大批量的、异构的数据进行整合，有强大的数据转换功能。\n高效适配多种类型的异构数据库、文件和应用系统。\n快速构建复杂数据大集中应用、无需编码。\n\nKettle构成\n\nTODO以Github上的名词进行定义Spoon，Cart等\n\n\n左边是集成开发工具（Spoon），可以进行流程的开发、配置、调试、部署、执行(转换、任务)，也可以对运行情况进行监控、对处理过程的日志进行查看、也可以通过接口调用方式进行远程管理。\n\n中间是服务器(Carte)，包括实际执行转换和任务的ETL引擎、监控管理的接口、认证授权接口，还有一个可以拓展的接口。\n\n下面是在开发过程中，用于保存集成开发工具中创建的转换、任务、数据库等项的，资源库包含两类，一个是数据库资源库，一个是文件资源库。\n\n右边个是是第三方平台，可以基于kettle提供的接口实现相应的功能包括状态监控、启停控制、日志查看等功能。\n\n\n组成部分\n名称\n描述\nSpoon\n一个基于swt开发的流式处理客户端，用户开发转换、任务、创建数据库、集群、分区等\nPan\n一个独立的命令行程序，支持通过命令行实现界面的功能，如果转换启停、任务启停。状态查看等\nKitchen\n一个独立的命令行程序，用于执行由Spoon编辑的作业。\nCarte\nCarte是一个轻量级的Web容器，用于建立专用、远程的ETL Server。\n\n\nPDI相关术语和概念\nJob(任务)、Transformation(转换)是kettle的两个最重要的概念。任务做的一件完整的事，包含开始、结束等整个生命周期；而转换是要做这件事的某一个小的功能。比如你要从A数据源中解析数据后放入B数据源，那么你可以创建两个转换，一个是从A数据源加载数据->处理数据->放入存储中；另一个是把数据放入B数据源，然后在一个任务中处理他们。\n\n下面我们通过集成开发工具去了解一个转换和任务\n\nTransformation（转换）\nTransformation（转换)是由step(步骤)和hops(节点连接线)组成，一个转换，可以看成一段数据流，每一个步骤完成一项数据处理的工作，节点连接线用于数据的流动。\n\n转换可以单独运行完成某一项工作，文件的扩展名为.ktr\n\nSteps（步骤）\nSteps（步骤）是转换的重要组件部分，在Spoon中步骤根据功能分为输入类、输出类、脚本类等，每一个步骤完成一种特定的功能，比如excel输出组件，用于把数据流输出为excel文件格式。参考如下：\n\n\nHops（节点连接）\nHops（节点连接）是数据传输的通道，用于连接两个步骤，使数据从一个步骤传递到另一个步骤，支持分发、复制等方式。注意数据处理的顺序并不是按照节点连接箭头的顺序，因为第个步骤都是单独的线程。\n\nJobs（工作）\nJobs（工作）是基于工作流模型的，顺序处理。把步骤、转换组织在一起完成一件完整的事情。\n文件扩展名为.kjb\n\n\n下载使用\nkettle下载 目前最新版7.0\nhttps://sourceforge.net/projects/pentaho/files/Data%20Integration/\n \n下载解压后是一个如：pdi-ce-7.0.0.0-25的文件，目录内容如下\n\nwindown下直接双拼Spoon.bat、linux下直接运行./spoon.sh即可。\n注： could not find the main class:org.pentaho.commons.launcher.Launcher. Program will exit. 表示jdk版本错误 。7.0版本只支持jdk1.8，可以单独配置kettle的jdk，添加配置到系统中即可：\n名称：PENTAHO_JAVA_HOME\n值：C:\\Program Files\\Java\\jdk1.8.0_45 \n    mac系统下/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/\n启动后界面如下\n\n新建转换：快捷键Ctrl+N\n\n\n首先从核心对象区选择“生成记录组件，编辑：\n\n\n然后选择Excel输出组件到工作区，创建生成记录步骤到Excel输出步骤的连接线，编辑excel输出目录和字段\n\n\n\n\n最后生成如下，点击运行：\n\n\n\n\n运行后的结果是输出excel文件，并可以查看每个步骤的处理情况，读、写、输入、输出等\n\n\n其它参考链接\nkettle源码下载，可以选择各个版本下载，自己编译。\nhttps://github.com/pentaho/pentaho-kettle\n大数据插件源码\nhttps://github.com/pentaho/big-data-plugin\nkettle支持的大数据环境源码，主要是hdp,cdh。\nhttps://github.com/pentaho/pentaho-hadoop-shims\nkettle nexus\nhttp://repo.pentaho.org/content/groups/omni/pentaho/  \nhttp://repository.pentaho.org/artifactory/repo/\n所有组件实现说明\nhttp://wiki.pentaho.com/display/EAI/Pentaho+Data+Integration+Steps  \n所有组件测试说明\nhttp://wiki.pentaho.com/display/EAI/test \n帮助\nhttp://help.pentaho.com/Documentation \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/kettle/开源ETL工具-kettle.md","raw":"---\ntitle: 开源ETL工具-kettle\ndate: 2017-04-15 14:43:49\ntags: [开源项目,kettle]\ncategories: [开源项目,kettle]\n---\n#开源ETL工具-kettle\n说明：本文部分内容参考网络的资料，如果侵权之处请告知一下，不胜感激！\n\nKettle是Pentaho公司开发的一款ETL产品，以工作流为核心，强调面向解决方案而非工具的，基于java平台的商业智能(Business Intelligence,BI)套件。Kettle的开源协议是LGPL，该协议来自GNU，因功能强大，被FSF(Free Software Foundation)列为首选协议。LGPL协议允许Kettle作为商业（非开源）代码的链接库，使用Kettle的商业代码无须开源。LGPL带来的不仅是Kettle API，你还可以对它进行拓展对外提供商业软件或服务。\n##  ##ETL是什么\n\nETL早期作为数据仓库的关键环节，负责将分布的、异构数据源中的数据如关系数据、平面数据文件等抽取到临时中间层后进行清洗、转换、集成，最后加载到数据仓库（Data Warehouse）或数据集市（Data Mart）中，成为联机分析处理（On-Line Analytical Processing，OLAP）、数据挖掘（Data Mining）的基础。\n\n\nExract：从多种异构数据源中抽取数据\n\nTransform：经过清洗，统一化和转换\n\nLoad：将数据加载到目的数据源中\n\n\n\n##  ##Kettle产品特点\n\n适用于将多个应用系统的大批量的、异构的数据进行整合，有强大的数据转换功能。\n高效适配多种类型的异构数据库、文件和应用系统。\n快速构建复杂数据大集中应用、无需编码。\n\nKettle构成\n\nTODO以Github上的名词进行定义Spoon，Cart等\n\n\n左边是集成开发工具（Spoon），可以进行流程的开发、配置、调试、部署、执行(转换、任务)，也可以对运行情况进行监控、对处理过程的日志进行查看、也可以通过接口调用方式进行远程管理。\n\n中间是服务器(Carte)，包括实际执行转换和任务的ETL引擎、监控管理的接口、认证授权接口，还有一个可以拓展的接口。\n\n下面是在开发过程中，用于保存集成开发工具中创建的转换、任务、数据库等项的，资源库包含两类，一个是数据库资源库，一个是文件资源库。\n\n右边个是是第三方平台，可以基于kettle提供的接口实现相应的功能包括状态监控、启停控制、日志查看等功能。\n\n\n组成部分\n名称\n描述\nSpoon\n一个基于swt开发的流式处理客户端，用户开发转换、任务、创建数据库、集群、分区等\nPan\n一个独立的命令行程序，支持通过命令行实现界面的功能，如果转换启停、任务启停。状态查看等\nKitchen\n一个独立的命令行程序，用于执行由Spoon编辑的作业。\nCarte\nCarte是一个轻量级的Web容器，用于建立专用、远程的ETL Server。\n\n\nPDI相关术语和概念\nJob(任务)、Transformation(转换)是kettle的两个最重要的概念。任务做的一件完整的事，包含开始、结束等整个生命周期；而转换是要做这件事的某一个小的功能。比如你要从A数据源中解析数据后放入B数据源，那么你可以创建两个转换，一个是从A数据源加载数据->处理数据->放入存储中；另一个是把数据放入B数据源，然后在一个任务中处理他们。\n\n下面我们通过集成开发工具去了解一个转换和任务\n\nTransformation（转换）\nTransformation（转换)是由step(步骤)和hops(节点连接线)组成，一个转换，可以看成一段数据流，每一个步骤完成一项数据处理的工作，节点连接线用于数据的流动。\n\n转换可以单独运行完成某一项工作，文件的扩展名为.ktr\n\nSteps（步骤）\nSteps（步骤）是转换的重要组件部分，在Spoon中步骤根据功能分为输入类、输出类、脚本类等，每一个步骤完成一种特定的功能，比如excel输出组件，用于把数据流输出为excel文件格式。参考如下：\n\n\nHops（节点连接）\nHops（节点连接）是数据传输的通道，用于连接两个步骤，使数据从一个步骤传递到另一个步骤，支持分发、复制等方式。注意数据处理的顺序并不是按照节点连接箭头的顺序，因为第个步骤都是单独的线程。\n\nJobs（工作）\nJobs（工作）是基于工作流模型的，顺序处理。把步骤、转换组织在一起完成一件完整的事情。\n文件扩展名为.kjb\n\n\n下载使用\nkettle下载 目前最新版7.0\nhttps://sourceforge.net/projects/pentaho/files/Data%20Integration/\n \n下载解压后是一个如：pdi-ce-7.0.0.0-25的文件，目录内容如下\n\nwindown下直接双拼Spoon.bat、linux下直接运行./spoon.sh即可。\n注： could not find the main class:org.pentaho.commons.launcher.Launcher. Program will exit. 表示jdk版本错误 。7.0版本只支持jdk1.8，可以单独配置kettle的jdk，添加配置到系统中即可：\n名称：PENTAHO_JAVA_HOME\n值：C:\\Program Files\\Java\\jdk1.8.0_45 \n    mac系统下/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/\n启动后界面如下\n\n新建转换：快捷键Ctrl+N\n\n\n首先从核心对象区选择“生成记录组件，编辑：\n\n\n然后选择Excel输出组件到工作区，创建生成记录步骤到Excel输出步骤的连接线，编辑excel输出目录和字段\n\n\n\n\n最后生成如下，点击运行：\n\n\n\n\n运行后的结果是输出excel文件，并可以查看每个步骤的处理情况，读、写、输入、输出等\n\n\n其它参考链接\nkettle源码下载，可以选择各个版本下载，自己编译。\nhttps://github.com/pentaho/pentaho-kettle\n大数据插件源码\nhttps://github.com/pentaho/big-data-plugin\nkettle支持的大数据环境源码，主要是hdp,cdh。\nhttps://github.com/pentaho/pentaho-hadoop-shims\nkettle nexus\nhttp://repo.pentaho.org/content/groups/omni/pentaho/  \nhttp://repository.pentaho.org/artifactory/repo/\n所有组件实现说明\nhttp://wiki.pentaho.com/display/EAI/Pentaho+Data+Integration+Steps  \n所有组件测试说明\nhttp://wiki.pentaho.com/display/EAI/test \n帮助\nhttp://help.pentaho.com/Documentation \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"kettle/开源ETL工具-kettle","published":1,"updated":"2017-08-18T01:44:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bit000bs77rjvthhpmu","content":"<p>#开源ETL工具-kettle<br>说明：本文部分内容参考网络的资料，如果侵权之处请告知一下，不胜感激！</p>\n<p>Kettle是Pentaho公司开发的一款ETL产品，以工作流为核心，强调面向解决方案而非工具的，基于java平台的商业智能(Business Intelligence,BI)套件。Kettle的开源协议是LGPL，该协议来自GNU，因功能强大，被FSF(Free Software Foundation)列为首选协议。LGPL协议允许Kettle作为商业（非开源）代码的链接库，使用Kettle的商业代码无须开源。LGPL带来的不仅是Kettle API，你还可以对它进行拓展对外提供商业软件或服务。</p>\n<h2 id=\"ETL是什么\"><a href=\"#ETL是什么\" class=\"headerlink\" title=\"##ETL是什么\"></a>##ETL是什么</h2><p>ETL早期作为数据仓库的关键环节，负责将分布的、异构数据源中的数据如关系数据、平面数据文件等抽取到临时中间层后进行清洗、转换、集成，最后加载到数据仓库（Data Warehouse）或数据集市（Data Mart）中，成为联机分析处理（On-Line Analytical Processing，OLAP）、数据挖掘（Data Mining）的基础。</p>\n<p>Exract：从多种异构数据源中抽取数据</p>\n<p>Transform：经过清洗，统一化和转换</p>\n<p>Load：将数据加载到目的数据源中</p>\n<h2 id=\"Kettle产品特点\"><a href=\"#Kettle产品特点\" class=\"headerlink\" title=\"##Kettle产品特点\"></a>##Kettle产品特点</h2><p>适用于将多个应用系统的大批量的、异构的数据进行整合，有强大的数据转换功能。<br>高效适配多种类型的异构数据库、文件和应用系统。<br>快速构建复杂数据大集中应用、无需编码。</p>\n<p>Kettle构成</p>\n<p>TODO以Github上的名词进行定义Spoon，Cart等</p>\n<p>左边是集成开发工具（Spoon），可以进行流程的开发、配置、调试、部署、执行(转换、任务)，也可以对运行情况进行监控、对处理过程的日志进行查看、也可以通过接口调用方式进行远程管理。</p>\n<p>中间是服务器(Carte)，包括实际执行转换和任务的ETL引擎、监控管理的接口、认证授权接口，还有一个可以拓展的接口。</p>\n<p>下面是在开发过程中，用于保存集成开发工具中创建的转换、任务、数据库等项的，资源库包含两类，一个是数据库资源库，一个是文件资源库。</p>\n<p>右边个是是第三方平台，可以基于kettle提供的接口实现相应的功能包括状态监控、启停控制、日志查看等功能。</p>\n<p>组成部分<br>名称<br>描述<br>Spoon<br>一个基于swt开发的流式处理客户端，用户开发转换、任务、创建数据库、集群、分区等<br>Pan<br>一个独立的命令行程序，支持通过命令行实现界面的功能，如果转换启停、任务启停。状态查看等<br>Kitchen<br>一个独立的命令行程序，用于执行由Spoon编辑的作业。<br>Carte<br>Carte是一个轻量级的Web容器，用于建立专用、远程的ETL Server。</p>\n<p>PDI相关术语和概念<br>Job(任务)、Transformation(转换)是kettle的两个最重要的概念。任务做的一件完整的事，包含开始、结束等整个生命周期；而转换是要做这件事的某一个小的功能。比如你要从A数据源中解析数据后放入B数据源，那么你可以创建两个转换，一个是从A数据源加载数据-&gt;处理数据-&gt;放入存储中；另一个是把数据放入B数据源，然后在一个任务中处理他们。</p>\n<p>下面我们通过集成开发工具去了解一个转换和任务</p>\n<p>Transformation（转换）<br>Transformation（转换)是由step(步骤)和hops(节点连接线)组成，一个转换，可以看成一段数据流，每一个步骤完成一项数据处理的工作，节点连接线用于数据的流动。</p>\n<p>转换可以单独运行完成某一项工作，文件的扩展名为.ktr</p>\n<p>Steps（步骤）<br>Steps（步骤）是转换的重要组件部分，在Spoon中步骤根据功能分为输入类、输出类、脚本类等，每一个步骤完成一种特定的功能，比如excel输出组件，用于把数据流输出为excel文件格式。参考如下：</p>\n<p>Hops（节点连接）<br>Hops（节点连接）是数据传输的通道，用于连接两个步骤，使数据从一个步骤传递到另一个步骤，支持分发、复制等方式。注意数据处理的顺序并不是按照节点连接箭头的顺序，因为第个步骤都是单独的线程。</p>\n<p>Jobs（工作）<br>Jobs（工作）是基于工作流模型的，顺序处理。把步骤、转换组织在一起完成一件完整的事情。<br>文件扩展名为.kjb</p>\n<p>下载使用<br>kettle下载 目前最新版7.0<br><a href=\"https://sourceforge.net/projects/pentaho/files/Data%20Integration/\" target=\"_blank\" rel=\"noopener\">https://sourceforge.net/projects/pentaho/files/Data%20Integration/</a></p>\n<p>下载解压后是一个如：pdi-ce-7.0.0.0-25的文件，目录内容如下</p>\n<p>windown下直接双拼Spoon.bat、linux下直接运行./spoon.sh即可。<br>注： could not find the main class:org.pentaho.commons.launcher.Launcher. Program will exit. 表示jdk版本错误 。7.0版本只支持jdk1.8，可以单独配置kettle的jdk，添加配置到系统中即可：<br>名称：PENTAHO_JAVA_HOME<br>值：C:\\Program Files\\Java\\jdk1.8.0_45<br>    mac系统下/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/<br>启动后界面如下</p>\n<p>新建转换：快捷键Ctrl+N</p>\n<p>首先从核心对象区选择“生成记录组件，编辑：</p>\n<p>然后选择Excel输出组件到工作区，创建生成记录步骤到Excel输出步骤的连接线，编辑excel输出目录和字段</p>\n<p>最后生成如下，点击运行：</p>\n<p>运行后的结果是输出excel文件，并可以查看每个步骤的处理情况，读、写、输入、输出等</p>\n<p>其它参考链接<br>kettle源码下载，可以选择各个版本下载，自己编译。<br><a href=\"https://github.com/pentaho/pentaho-kettle\" target=\"_blank\" rel=\"noopener\">https://github.com/pentaho/pentaho-kettle</a><br>大数据插件源码<br><a href=\"https://github.com/pentaho/big-data-plugin\" target=\"_blank\" rel=\"noopener\">https://github.com/pentaho/big-data-plugin</a><br>kettle支持的大数据环境源码，主要是hdp,cdh。<br><a href=\"https://github.com/pentaho/pentaho-hadoop-shims\" target=\"_blank\" rel=\"noopener\">https://github.com/pentaho/pentaho-hadoop-shims</a><br>kettle nexus<br><a href=\"http://repo.pentaho.org/content/groups/omni/pentaho/\" target=\"_blank\" rel=\"noopener\">http://repo.pentaho.org/content/groups/omni/pentaho/</a><br><a href=\"http://repository.pentaho.org/artifactory/repo/\" target=\"_blank\" rel=\"noopener\">http://repository.pentaho.org/artifactory/repo/</a><br>所有组件实现说明<br><a href=\"http://wiki.pentaho.com/display/EAI/Pentaho+Data+Integration+Steps\" target=\"_blank\" rel=\"noopener\">http://wiki.pentaho.com/display/EAI/Pentaho+Data+Integration+Steps</a><br>所有组件测试说明<br><a href=\"http://wiki.pentaho.com/display/EAI/test\" target=\"_blank\" rel=\"noopener\">http://wiki.pentaho.com/display/EAI/test</a><br>帮助<br><a href=\"http://help.pentaho.com/Documentation\" target=\"_blank\" rel=\"noopener\">http://help.pentaho.com/Documentation</a> </p>\n","site":{"data":{}},"excerpt":"","more":"<p>#开源ETL工具-kettle<br>说明：本文部分内容参考网络的资料，如果侵权之处请告知一下，不胜感激！</p>\n<p>Kettle是Pentaho公司开发的一款ETL产品，以工作流为核心，强调面向解决方案而非工具的，基于java平台的商业智能(Business Intelligence,BI)套件。Kettle的开源协议是LGPL，该协议来自GNU，因功能强大，被FSF(Free Software Foundation)列为首选协议。LGPL协议允许Kettle作为商业（非开源）代码的链接库，使用Kettle的商业代码无须开源。LGPL带来的不仅是Kettle API，你还可以对它进行拓展对外提供商业软件或服务。</p>\n<h2 id=\"ETL是什么\"><a href=\"#ETL是什么\" class=\"headerlink\" title=\"##ETL是什么\"></a>##ETL是什么</h2><p>ETL早期作为数据仓库的关键环节，负责将分布的、异构数据源中的数据如关系数据、平面数据文件等抽取到临时中间层后进行清洗、转换、集成，最后加载到数据仓库（Data Warehouse）或数据集市（Data Mart）中，成为联机分析处理（On-Line Analytical Processing，OLAP）、数据挖掘（Data Mining）的基础。</p>\n<p>Exract：从多种异构数据源中抽取数据</p>\n<p>Transform：经过清洗，统一化和转换</p>\n<p>Load：将数据加载到目的数据源中</p>\n<h2 id=\"Kettle产品特点\"><a href=\"#Kettle产品特点\" class=\"headerlink\" title=\"##Kettle产品特点\"></a>##Kettle产品特点</h2><p>适用于将多个应用系统的大批量的、异构的数据进行整合，有强大的数据转换功能。<br>高效适配多种类型的异构数据库、文件和应用系统。<br>快速构建复杂数据大集中应用、无需编码。</p>\n<p>Kettle构成</p>\n<p>TODO以Github上的名词进行定义Spoon，Cart等</p>\n<p>左边是集成开发工具（Spoon），可以进行流程的开发、配置、调试、部署、执行(转换、任务)，也可以对运行情况进行监控、对处理过程的日志进行查看、也可以通过接口调用方式进行远程管理。</p>\n<p>中间是服务器(Carte)，包括实际执行转换和任务的ETL引擎、监控管理的接口、认证授权接口，还有一个可以拓展的接口。</p>\n<p>下面是在开发过程中，用于保存集成开发工具中创建的转换、任务、数据库等项的，资源库包含两类，一个是数据库资源库，一个是文件资源库。</p>\n<p>右边个是是第三方平台，可以基于kettle提供的接口实现相应的功能包括状态监控、启停控制、日志查看等功能。</p>\n<p>组成部分<br>名称<br>描述<br>Spoon<br>一个基于swt开发的流式处理客户端，用户开发转换、任务、创建数据库、集群、分区等<br>Pan<br>一个独立的命令行程序，支持通过命令行实现界面的功能，如果转换启停、任务启停。状态查看等<br>Kitchen<br>一个独立的命令行程序，用于执行由Spoon编辑的作业。<br>Carte<br>Carte是一个轻量级的Web容器，用于建立专用、远程的ETL Server。</p>\n<p>PDI相关术语和概念<br>Job(任务)、Transformation(转换)是kettle的两个最重要的概念。任务做的一件完整的事，包含开始、结束等整个生命周期；而转换是要做这件事的某一个小的功能。比如你要从A数据源中解析数据后放入B数据源，那么你可以创建两个转换，一个是从A数据源加载数据-&gt;处理数据-&gt;放入存储中；另一个是把数据放入B数据源，然后在一个任务中处理他们。</p>\n<p>下面我们通过集成开发工具去了解一个转换和任务</p>\n<p>Transformation（转换）<br>Transformation（转换)是由step(步骤)和hops(节点连接线)组成，一个转换，可以看成一段数据流，每一个步骤完成一项数据处理的工作，节点连接线用于数据的流动。</p>\n<p>转换可以单独运行完成某一项工作，文件的扩展名为.ktr</p>\n<p>Steps（步骤）<br>Steps（步骤）是转换的重要组件部分，在Spoon中步骤根据功能分为输入类、输出类、脚本类等，每一个步骤完成一种特定的功能，比如excel输出组件，用于把数据流输出为excel文件格式。参考如下：</p>\n<p>Hops（节点连接）<br>Hops（节点连接）是数据传输的通道，用于连接两个步骤，使数据从一个步骤传递到另一个步骤，支持分发、复制等方式。注意数据处理的顺序并不是按照节点连接箭头的顺序，因为第个步骤都是单独的线程。</p>\n<p>Jobs（工作）<br>Jobs（工作）是基于工作流模型的，顺序处理。把步骤、转换组织在一起完成一件完整的事情。<br>文件扩展名为.kjb</p>\n<p>下载使用<br>kettle下载 目前最新版7.0<br><a href=\"https://sourceforge.net/projects/pentaho/files/Data%20Integration/\" target=\"_blank\" rel=\"noopener\">https://sourceforge.net/projects/pentaho/files/Data%20Integration/</a></p>\n<p>下载解压后是一个如：pdi-ce-7.0.0.0-25的文件，目录内容如下</p>\n<p>windown下直接双拼Spoon.bat、linux下直接运行./spoon.sh即可。<br>注： could not find the main class:org.pentaho.commons.launcher.Launcher. Program will exit. 表示jdk版本错误 。7.0版本只支持jdk1.8，可以单独配置kettle的jdk，添加配置到系统中即可：<br>名称：PENTAHO_JAVA_HOME<br>值：C:\\Program Files\\Java\\jdk1.8.0_45<br>    mac系统下/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/<br>启动后界面如下</p>\n<p>新建转换：快捷键Ctrl+N</p>\n<p>首先从核心对象区选择“生成记录组件，编辑：</p>\n<p>然后选择Excel输出组件到工作区，创建生成记录步骤到Excel输出步骤的连接线，编辑excel输出目录和字段</p>\n<p>最后生成如下，点击运行：</p>\n<p>运行后的结果是输出excel文件，并可以查看每个步骤的处理情况，读、写、输入、输出等</p>\n<p>其它参考链接<br>kettle源码下载，可以选择各个版本下载，自己编译。<br><a href=\"https://github.com/pentaho/pentaho-kettle\" target=\"_blank\" rel=\"noopener\">https://github.com/pentaho/pentaho-kettle</a><br>大数据插件源码<br><a href=\"https://github.com/pentaho/big-data-plugin\" target=\"_blank\" rel=\"noopener\">https://github.com/pentaho/big-data-plugin</a><br>kettle支持的大数据环境源码，主要是hdp,cdh。<br><a href=\"https://github.com/pentaho/pentaho-hadoop-shims\" target=\"_blank\" rel=\"noopener\">https://github.com/pentaho/pentaho-hadoop-shims</a><br>kettle nexus<br><a href=\"http://repo.pentaho.org/content/groups/omni/pentaho/\" target=\"_blank\" rel=\"noopener\">http://repo.pentaho.org/content/groups/omni/pentaho/</a><br><a href=\"http://repository.pentaho.org/artifactory/repo/\" target=\"_blank\" rel=\"noopener\">http://repository.pentaho.org/artifactory/repo/</a><br>所有组件实现说明<br><a href=\"http://wiki.pentaho.com/display/EAI/Pentaho+Data+Integration+Steps\" target=\"_blank\" rel=\"noopener\">http://wiki.pentaho.com/display/EAI/Pentaho+Data+Integration+Steps</a><br>所有组件测试说明<br><a href=\"http://wiki.pentaho.com/display/EAI/test\" target=\"_blank\" rel=\"noopener\">http://wiki.pentaho.com/display/EAI/test</a><br>帮助<br><a href=\"http://help.pentaho.com/Documentation\" target=\"_blank\" rel=\"noopener\">http://help.pentaho.com/Documentation</a> </p>\n"},{"title":"Kettle源码构建过程","date":"2016-05-22T06:43:49.000Z","_content":"#Kettle 源码构建过程#\n\n&emsp;&emsp;Kettle 的源码托管在 Github 和 SVN上，但是托管在SVN上的源码自 5.0 之后就一直没有更新了，而托管在Github上的源码一直保持着更新状态，所以我猜 svn 上的源码并不会去进行维护了，我们以后只关注 git 上的源码就行。\n\n&emsp;&emsp;Kettle 的二进制文件下载地址：\n  http://sourceforge.net/projects/pentaho/files/Data%20Integration/\n&emsp;&emsp;Kettle 源码地址:\n  git:https://github.com/pentaho/pentaho-kettle\n  svn:svn://source.pentaho.org/svnkettleroot/archive/Kettle/branches\n&emsp;&emsp;其中二进制文件的下载版本分支与 git 上的源码分支是保持一致的，所以git上面的源码是跟着 kettle 的版本随时发布更新的，我们以后fork这个项目就可以一直获取最新发布的源码了。\n\n**下面是我的构建过程(版本5.4)：**  \n下载 ivy (http://ant.apache.org/ivy/download.html)。5.0版本之上的 kettle 项目结构与之前的版本项目结构完全不同，构建工具也由ant 变为了 ant + ivy。所以需要下载 ivy 来完成构建过程。将下载的 ivy-2.4.0.jar包放置到 ant_home/lib 下即可。  \n从 git 上面 clone  kettle 5.4 的源码于某个目录。命令行进入到源码主目录，如下所示：  \n&emsp;&emsp;执行命令：ant clean-all resolve create-dot-classpath。  命令会执行很久很久(资源在国外，如果自己有 vpn 加速会快点)，而且会时不时的报错，找不到 jar 包。当遇到找不到jar 包时，我是自行到kettle 私服(http://nexus.pentaho.org/content/groups/omni/)中去下对应版本jar包，然后放置到ivy 的本地仓库中，并删掉 ivy 本地缓存中的源文件和未下载成功的垃圾文件，然后重复此命令进行构建。本地缓存文件位于C:\\Users\\${username}\\.ivy2\\cache 。一直执行此命令，直到出现 successful 的提示。\n\n执行命令：ant dist ，该命令会根据源码生成一份对应的kettle 版本。同样的，在执行此命令的过程中，也会经常报各种错误，也需要自己去私服中找对应的jar包放置到对应的本地缓存目录。构建成功后，在根目录下会生成 一个 dist 文件夹，打开里面的spoon.bat 就可以使用 kettle 了，我下的5.4 版本的界面与之前的大有不同，感觉比以前的好看些，如下所示：\n\n\n到现在为止，就已经可以用源码构建了。下一步就是搭建好源码，kettle 的源码中分别提供了.project 文件和 .ipr 文件，所以可以用 eclipse和 idea 进行搭建。我是用的 idea 搭建的，eclipse 搭建应该会更简单点。\n\n在搭建之前，我删掉了kettle 中所有的.gitignore、.gitignoreattribute、.template、.project文件，然后在 .ipr 文件中注释掉版本管理的信息和未提供的插件项目信息，这样在导入源码的时候不会提示错误，如下所示：\n\n\n\n源码导入idea 中之后，会出现很多错误，需要手动导入一些jar包，由于里面有很多测试文件，所以我们需要手动依赖 /core/test_lib 文件夹里面的jar 包，范围指定为 test；\n\n\n\n从 libext 目录中复制 win64 位的swt.jar 包到 lib 目录，然后删除 swt_x86_64.jar 包；\n\n复制 ojdbc.jar 包到lib目录(为了解决登录资源库)；\n\n复制 dist/ui/*.xul 文件到 ui/目录；\n\n\n\n\n\n新建simple-jndi 空目录；\n\n\n\n到了这里，源码编译、调试就没问题了，程序启动的入口为org.pentaho.di.ui.spoon.Spoon.java，运行main入口函数即可启动 kettle，如下所示：\n\n\n\n再来欣赏下折腾摸索了这么久才弄出来的东西，确实比以前的好看些了，整体风格感觉统一了，而且向上兼容以前版本的，我用以前版本的转换在5.4 下测试了完全没问题，同时我也把以前写过的插件按照之前的机制进行处理，插件也是能加载出来并正常使用的，所以新的版本下的插件机制并没有发生变化:\n\n\n\n总结：上面这些步骤中好几个步骤是跑代码调试才知道的问题，所以调试还是一如既往的重要哈。\n\n","source":"_posts/kettle/Kettle源码构建过程.md","raw":"---\ntitle: Kettle源码构建过程\ndate: 2016-05-22 14:43:49\ntags: [开源项目,kettle]\ncategories: [开源项目,kettle]\n---\n#Kettle 源码构建过程#\n\n&emsp;&emsp;Kettle 的源码托管在 Github 和 SVN上，但是托管在SVN上的源码自 5.0 之后就一直没有更新了，而托管在Github上的源码一直保持着更新状态，所以我猜 svn 上的源码并不会去进行维护了，我们以后只关注 git 上的源码就行。\n\n&emsp;&emsp;Kettle 的二进制文件下载地址：\n  http://sourceforge.net/projects/pentaho/files/Data%20Integration/\n&emsp;&emsp;Kettle 源码地址:\n  git:https://github.com/pentaho/pentaho-kettle\n  svn:svn://source.pentaho.org/svnkettleroot/archive/Kettle/branches\n&emsp;&emsp;其中二进制文件的下载版本分支与 git 上的源码分支是保持一致的，所以git上面的源码是跟着 kettle 的版本随时发布更新的，我们以后fork这个项目就可以一直获取最新发布的源码了。\n\n**下面是我的构建过程(版本5.4)：**  \n下载 ivy (http://ant.apache.org/ivy/download.html)。5.0版本之上的 kettle 项目结构与之前的版本项目结构完全不同，构建工具也由ant 变为了 ant + ivy。所以需要下载 ivy 来完成构建过程。将下载的 ivy-2.4.0.jar包放置到 ant_home/lib 下即可。  \n从 git 上面 clone  kettle 5.4 的源码于某个目录。命令行进入到源码主目录，如下所示：  \n&emsp;&emsp;执行命令：ant clean-all resolve create-dot-classpath。  命令会执行很久很久(资源在国外，如果自己有 vpn 加速会快点)，而且会时不时的报错，找不到 jar 包。当遇到找不到jar 包时，我是自行到kettle 私服(http://nexus.pentaho.org/content/groups/omni/)中去下对应版本jar包，然后放置到ivy 的本地仓库中，并删掉 ivy 本地缓存中的源文件和未下载成功的垃圾文件，然后重复此命令进行构建。本地缓存文件位于C:\\Users\\${username}\\.ivy2\\cache 。一直执行此命令，直到出现 successful 的提示。\n\n执行命令：ant dist ，该命令会根据源码生成一份对应的kettle 版本。同样的，在执行此命令的过程中，也会经常报各种错误，也需要自己去私服中找对应的jar包放置到对应的本地缓存目录。构建成功后，在根目录下会生成 一个 dist 文件夹，打开里面的spoon.bat 就可以使用 kettle 了，我下的5.4 版本的界面与之前的大有不同，感觉比以前的好看些，如下所示：\n\n\n到现在为止，就已经可以用源码构建了。下一步就是搭建好源码，kettle 的源码中分别提供了.project 文件和 .ipr 文件，所以可以用 eclipse和 idea 进行搭建。我是用的 idea 搭建的，eclipse 搭建应该会更简单点。\n\n在搭建之前，我删掉了kettle 中所有的.gitignore、.gitignoreattribute、.template、.project文件，然后在 .ipr 文件中注释掉版本管理的信息和未提供的插件项目信息，这样在导入源码的时候不会提示错误，如下所示：\n\n\n\n源码导入idea 中之后，会出现很多错误，需要手动导入一些jar包，由于里面有很多测试文件，所以我们需要手动依赖 /core/test_lib 文件夹里面的jar 包，范围指定为 test；\n\n\n\n从 libext 目录中复制 win64 位的swt.jar 包到 lib 目录，然后删除 swt_x86_64.jar 包；\n\n复制 ojdbc.jar 包到lib目录(为了解决登录资源库)；\n\n复制 dist/ui/*.xul 文件到 ui/目录；\n\n\n\n\n\n新建simple-jndi 空目录；\n\n\n\n到了这里，源码编译、调试就没问题了，程序启动的入口为org.pentaho.di.ui.spoon.Spoon.java，运行main入口函数即可启动 kettle，如下所示：\n\n\n\n再来欣赏下折腾摸索了这么久才弄出来的东西，确实比以前的好看些了，整体风格感觉统一了，而且向上兼容以前版本的，我用以前版本的转换在5.4 下测试了完全没问题，同时我也把以前写过的插件按照之前的机制进行处理，插件也是能加载出来并正常使用的，所以新的版本下的插件机制并没有发生变化:\n\n\n\n总结：上面这些步骤中好几个步骤是跑代码调试才知道的问题，所以调试还是一如既往的重要哈。\n\n","slug":"kettle/Kettle源码构建过程","published":1,"updated":"2017-08-18T01:44:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3biv000es77rtohlrpap","content":"<p>#Kettle 源码构建过程#</p>\n<p>&emsp;&emsp;Kettle 的源码托管在 Github 和 SVN上，但是托管在SVN上的源码自 5.0 之后就一直没有更新了，而托管在Github上的源码一直保持着更新状态，所以我猜 svn 上的源码并不会去进行维护了，我们以后只关注 git 上的源码就行。</p>\n<p>&emsp;&emsp;Kettle 的二进制文件下载地址：<br>  <a href=\"http://sourceforge.net/projects/pentaho/files/Data%20Integration/\" target=\"_blank\" rel=\"noopener\">http://sourceforge.net/projects/pentaho/files/Data%20Integration/</a><br>&emsp;&emsp;Kettle 源码地址:<br>  git:<a href=\"https://github.com/pentaho/pentaho-kettle\" target=\"_blank\" rel=\"noopener\">https://github.com/pentaho/pentaho-kettle</a><br>  svn:svn://source.pentaho.org/svnkettleroot/archive/Kettle/branches<br>&emsp;&emsp;其中二进制文件的下载版本分支与 git 上的源码分支是保持一致的，所以git上面的源码是跟着 kettle 的版本随时发布更新的，我们以后fork这个项目就可以一直获取最新发布的源码了。</p>\n<p><strong>下面是我的构建过程(版本5.4)：</strong><br>下载 ivy (<a href=\"http://ant.apache.org/ivy/download.html)。5.0版本之上的\" target=\"_blank\" rel=\"noopener\">http://ant.apache.org/ivy/download.html)。5.0版本之上的</a> kettle 项目结构与之前的版本项目结构完全不同，构建工具也由ant 变为了 ant + ivy。所以需要下载 ivy 来完成构建过程。将下载的 ivy-2.4.0.jar包放置到 ant_home/lib 下即可。<br>从 git 上面 clone  kettle 5.4 的源码于某个目录。命令行进入到源码主目录，如下所示：<br>&emsp;&emsp;执行命令：ant clean-all resolve create-dot-classpath。  命令会执行很久很久(资源在国外，如果自己有 vpn 加速会快点)，而且会时不时的报错，找不到 jar 包。当遇到找不到jar 包时，我是自行到kettle 私服(<a href=\"http://nexus.pentaho.org/content/groups/omni/)中去下对应版本jar包，然后放置到ivy\" target=\"_blank\" rel=\"noopener\">http://nexus.pentaho.org/content/groups/omni/)中去下对应版本jar包，然后放置到ivy</a> 的本地仓库中，并删掉 ivy 本地缓存中的源文件和未下载成功的垃圾文件，然后重复此命令进行构建。本地缓存文件位于C:\\Users\\${username}.ivy2\\cache 。一直执行此命令，直到出现 successful 的提示。</p>\n<p>执行命令：ant dist ，该命令会根据源码生成一份对应的kettle 版本。同样的，在执行此命令的过程中，也会经常报各种错误，也需要自己去私服中找对应的jar包放置到对应的本地缓存目录。构建成功后，在根目录下会生成 一个 dist 文件夹，打开里面的spoon.bat 就可以使用 kettle 了，我下的5.4 版本的界面与之前的大有不同，感觉比以前的好看些，如下所示：</p>\n<p>到现在为止，就已经可以用源码构建了。下一步就是搭建好源码，kettle 的源码中分别提供了.project 文件和 .ipr 文件，所以可以用 eclipse和 idea 进行搭建。我是用的 idea 搭建的，eclipse 搭建应该会更简单点。</p>\n<p>在搭建之前，我删掉了kettle 中所有的.gitignore、.gitignoreattribute、.template、.project文件，然后在 .ipr 文件中注释掉版本管理的信息和未提供的插件项目信息，这样在导入源码的时候不会提示错误，如下所示：</p>\n<p>源码导入idea 中之后，会出现很多错误，需要手动导入一些jar包，由于里面有很多测试文件，所以我们需要手动依赖 /core/test_lib 文件夹里面的jar 包，范围指定为 test；</p>\n<p>从 libext 目录中复制 win64 位的swt.jar 包到 lib 目录，然后删除 swt_x86_64.jar 包；</p>\n<p>复制 ojdbc.jar 包到lib目录(为了解决登录资源库)；</p>\n<p>复制 dist/ui/*.xul 文件到 ui/目录；</p>\n<p>新建simple-jndi 空目录；</p>\n<p>到了这里，源码编译、调试就没问题了，程序启动的入口为org.pentaho.di.ui.spoon.Spoon.java，运行main入口函数即可启动 kettle，如下所示：</p>\n<p>再来欣赏下折腾摸索了这么久才弄出来的东西，确实比以前的好看些了，整体风格感觉统一了，而且向上兼容以前版本的，我用以前版本的转换在5.4 下测试了完全没问题，同时我也把以前写过的插件按照之前的机制进行处理，插件也是能加载出来并正常使用的，所以新的版本下的插件机制并没有发生变化:</p>\n<p>总结：上面这些步骤中好几个步骤是跑代码调试才知道的问题，所以调试还是一如既往的重要哈。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>#Kettle 源码构建过程#</p>\n<p>&emsp;&emsp;Kettle 的源码托管在 Github 和 SVN上，但是托管在SVN上的源码自 5.0 之后就一直没有更新了，而托管在Github上的源码一直保持着更新状态，所以我猜 svn 上的源码并不会去进行维护了，我们以后只关注 git 上的源码就行。</p>\n<p>&emsp;&emsp;Kettle 的二进制文件下载地址：<br>  <a href=\"http://sourceforge.net/projects/pentaho/files/Data%20Integration/\" target=\"_blank\" rel=\"noopener\">http://sourceforge.net/projects/pentaho/files/Data%20Integration/</a><br>&emsp;&emsp;Kettle 源码地址:<br>  git:<a href=\"https://github.com/pentaho/pentaho-kettle\" target=\"_blank\" rel=\"noopener\">https://github.com/pentaho/pentaho-kettle</a><br>  svn:svn://source.pentaho.org/svnkettleroot/archive/Kettle/branches<br>&emsp;&emsp;其中二进制文件的下载版本分支与 git 上的源码分支是保持一致的，所以git上面的源码是跟着 kettle 的版本随时发布更新的，我们以后fork这个项目就可以一直获取最新发布的源码了。</p>\n<p><strong>下面是我的构建过程(版本5.4)：</strong><br>下载 ivy (<a href=\"http://ant.apache.org/ivy/download.html)。5.0版本之上的\" target=\"_blank\" rel=\"noopener\">http://ant.apache.org/ivy/download.html)。5.0版本之上的</a> kettle 项目结构与之前的版本项目结构完全不同，构建工具也由ant 变为了 ant + ivy。所以需要下载 ivy 来完成构建过程。将下载的 ivy-2.4.0.jar包放置到 ant_home/lib 下即可。<br>从 git 上面 clone  kettle 5.4 的源码于某个目录。命令行进入到源码主目录，如下所示：<br>&emsp;&emsp;执行命令：ant clean-all resolve create-dot-classpath。  命令会执行很久很久(资源在国外，如果自己有 vpn 加速会快点)，而且会时不时的报错，找不到 jar 包。当遇到找不到jar 包时，我是自行到kettle 私服(<a href=\"http://nexus.pentaho.org/content/groups/omni/)中去下对应版本jar包，然后放置到ivy\" target=\"_blank\" rel=\"noopener\">http://nexus.pentaho.org/content/groups/omni/)中去下对应版本jar包，然后放置到ivy</a> 的本地仓库中，并删掉 ivy 本地缓存中的源文件和未下载成功的垃圾文件，然后重复此命令进行构建。本地缓存文件位于C:\\Users\\${username}.ivy2\\cache 。一直执行此命令，直到出现 successful 的提示。</p>\n<p>执行命令：ant dist ，该命令会根据源码生成一份对应的kettle 版本。同样的，在执行此命令的过程中，也会经常报各种错误，也需要自己去私服中找对应的jar包放置到对应的本地缓存目录。构建成功后，在根目录下会生成 一个 dist 文件夹，打开里面的spoon.bat 就可以使用 kettle 了，我下的5.4 版本的界面与之前的大有不同，感觉比以前的好看些，如下所示：</p>\n<p>到现在为止，就已经可以用源码构建了。下一步就是搭建好源码，kettle 的源码中分别提供了.project 文件和 .ipr 文件，所以可以用 eclipse和 idea 进行搭建。我是用的 idea 搭建的，eclipse 搭建应该会更简单点。</p>\n<p>在搭建之前，我删掉了kettle 中所有的.gitignore、.gitignoreattribute、.template、.project文件，然后在 .ipr 文件中注释掉版本管理的信息和未提供的插件项目信息，这样在导入源码的时候不会提示错误，如下所示：</p>\n<p>源码导入idea 中之后，会出现很多错误，需要手动导入一些jar包，由于里面有很多测试文件，所以我们需要手动依赖 /core/test_lib 文件夹里面的jar 包，范围指定为 test；</p>\n<p>从 libext 目录中复制 win64 位的swt.jar 包到 lib 目录，然后删除 swt_x86_64.jar 包；</p>\n<p>复制 ojdbc.jar 包到lib目录(为了解决登录资源库)；</p>\n<p>复制 dist/ui/*.xul 文件到 ui/目录；</p>\n<p>新建simple-jndi 空目录；</p>\n<p>到了这里，源码编译、调试就没问题了，程序启动的入口为org.pentaho.di.ui.spoon.Spoon.java，运行main入口函数即可启动 kettle，如下所示：</p>\n<p>再来欣赏下折腾摸索了这么久才弄出来的东西，确实比以前的好看些了，整体风格感觉统一了，而且向上兼容以前版本的，我用以前版本的转换在5.4 下测试了完全没问题，同时我也把以前写过的插件按照之前的机制进行处理，插件也是能加载出来并正常使用的，所以新的版本下的插件机制并没有发生变化:</p>\n<p>总结：上面这些步骤中好几个步骤是跑代码调试才知道的问题，所以调试还是一如既往的重要哈。</p>\n"},{"title":"HBase入门概念","date":"2017-05-02T02:30:00.000Z","_content":"#Hbase概念\nHBase是一个分布式的、面向列的开源数据库。  \n\n##Hbase术语\n**行键Row Key**：主键是用来检索记录的主键，访问hbasetable中的行。  \n**列族Column Family**：Table在水平方向有一个或者多个ColumnFamily组成，一个ColumnFamily中可以由任意多个Column组成，即ColumnFamily支持动态扩展，无需预先定义Column的数量以及类型，所有Column均以二进制格式存储，用户需要自行进行类型转换。  \n**列column**：由Hbase中的列族ColumnFamily + 列的名称（cell）组成列。  \n**单元格cell**：HBase中通过row和columns确定的为一个存贮单元称为cell。  \n**版本version**：每个 cell都保存着同一份数据的多个版本。版本通过时间戳来索引。  \n\n\n#Hbase安装\n三种方式：单机、伪分布式、分布式\n##单机模式\nHbase安装文件下载解压后，直接运行，在单机模式下HBase不使用HDFS。\n##伪分布式\n运行在单个节点上的分布式模式  \n##全分布式\n全分面式模式下的HBase集群需要ZooKeeper实例运行，并且需要所有的HBase节点都能够与ZooKeeper实例通信，默认情况下HBase自身维护着一组默认的ZooKeeper实例，不过用户也可以配置独立的ZooKeeper实例，这样能够使HBase更加健壮。\n\n#运行HBase\n##单机模式\nstart-hbase.sh\nstop-hbase.sh\n##伪分分面式\n由于伪分布式运行基于HDFS，因此在期待运行HBase之前首先需要启动HDFS。\nstart-dfs.sh\n然后start-hbase.sh\n##全分布式\n与伪分布式相同\n\n#Hbase Shell\nHbase Shell提供了HBae命令，可以方便创建、删除及修改表，还可以向表中添加数据、列出表中相关信息等。  \n在启动hbase之后，用户可以通过下面的命令进入Hbase Shell：  \nhbase shell   \n输入help获取帮助    \nalter:修改列族模式  \ncount:统计表中行的数量  \ncreate：创建表  \ndescribe:显示表相关的详细信息  \ndelete:删除指定对象的值（可以为表、行、列对应的值，另外也可以指定时间戳的值）  \ndeleteall:删除指定行的所有元素值  \ndisable:使表无效  \ndrop:删除表  \nenable:使表有效  \nexists：测试表是否存在  \nexit:退出Hbase Shell  \nget:获取行或单元(cell)的值  \nincr:增加指定表、行或列的值  \nlist:列出HBase中存在的所有表  \nput:向指定的表单元添加值  \ntools:列出HBase所支持的工具  \nscan：通过对表的扫描来获取对应的值  \nstatus:返回HBase集群的状态信息  \nshutdown:关闭HBase集群  \ntruncate:重新创建指定表  \nversion:返回HBase版本信息  \n下面介绍几个详细的：  \n（1）create  \n通过表名及用逗号做好事开的列族信息来创建表    \n1）hbase>create 't1',{NAME=>'f1',VERSIONS=>5}  \n2)hbase>create 't1',{NAME=>'f1'},{NAME=>'f2'},{NAME=>'f3'}  \nhbase>#上面的命令可以简写为下面所示的格式：  \nhbase>create 't1','f1','f2','f3'  \n3)hbase>create 't1',{NAME='f1',VERSIONS=>1,TTL=>2592000,BLOCKCACHE=>true}  \n以\"NAME=>'f1'举例说明，其中，列族参数的格式是箭头左侧为参数变量，右侧为参数对应的值，并用“=>”分开。  \n\n（2）list  \n列出HBase中包含的表名称  \nhbase>list   \n\n(3)put  \n向指定的HBase表单元添加值，例如向表t1的行r1、列c1:1添加值v1，并指定时间戳为ts的操作如下：  \nhbase>put 't1','r1','c1:1','value',ta1  \n\n(4)scan  \n获取指定表的相关信息，可以通过逗号分隔来指定扫描参数  \n例如：获取表test的所有值  \nhbase>scan 'test'  \n获取表test的c1列的所有值  \nhbase>scan 'test',{COLUMNS=>'c1'}   \n获取表test的c1列的前一行的所有值   \nhbase>scan 'test',{COLUMNS=>'c1',limit=>1}  \n\n(5)get  \n获取行或单元的值，此命令可以指定表名、行值、以及可选的列值和时间戳。   \n获取表test行r1的值  \nhbase>get 'test','r1'  \n获取表test行r1列c1:1的值  \nhbase>get 'test','r1'{COLUMN=>'c1:1'}  \n需要注意的是，COLUMN和COLUMNS是不同的，scan操作中的COLUMNS指定的是表的列族，get操作中的COLUMN指定的是特定的列，COLUMN的值实质上为“列族+：+列修饰符”。  \n另外，在shell中，常量不需要用引号引起来，但二进制的值需要用双引号引起来，而其他值则用单引号引起来。  \nHBase Shell的常量可以通过shell中输入“Object.constants”命令来查看。  \n\n\n\n\n","source":"_posts/hadoop/HBase入门概念.md","raw":"---\ntitle: HBase入门概念\ndate: 2017-05-02 10:30:00\ntags: [分布式,hbase]\ncategories: [分布式,hbase]\n---\n#Hbase概念\nHBase是一个分布式的、面向列的开源数据库。  \n\n##Hbase术语\n**行键Row Key**：主键是用来检索记录的主键，访问hbasetable中的行。  \n**列族Column Family**：Table在水平方向有一个或者多个ColumnFamily组成，一个ColumnFamily中可以由任意多个Column组成，即ColumnFamily支持动态扩展，无需预先定义Column的数量以及类型，所有Column均以二进制格式存储，用户需要自行进行类型转换。  \n**列column**：由Hbase中的列族ColumnFamily + 列的名称（cell）组成列。  \n**单元格cell**：HBase中通过row和columns确定的为一个存贮单元称为cell。  \n**版本version**：每个 cell都保存着同一份数据的多个版本。版本通过时间戳来索引。  \n\n\n#Hbase安装\n三种方式：单机、伪分布式、分布式\n##单机模式\nHbase安装文件下载解压后，直接运行，在单机模式下HBase不使用HDFS。\n##伪分布式\n运行在单个节点上的分布式模式  \n##全分布式\n全分面式模式下的HBase集群需要ZooKeeper实例运行，并且需要所有的HBase节点都能够与ZooKeeper实例通信，默认情况下HBase自身维护着一组默认的ZooKeeper实例，不过用户也可以配置独立的ZooKeeper实例，这样能够使HBase更加健壮。\n\n#运行HBase\n##单机模式\nstart-hbase.sh\nstop-hbase.sh\n##伪分分面式\n由于伪分布式运行基于HDFS，因此在期待运行HBase之前首先需要启动HDFS。\nstart-dfs.sh\n然后start-hbase.sh\n##全分布式\n与伪分布式相同\n\n#Hbase Shell\nHbase Shell提供了HBae命令，可以方便创建、删除及修改表，还可以向表中添加数据、列出表中相关信息等。  \n在启动hbase之后，用户可以通过下面的命令进入Hbase Shell：  \nhbase shell   \n输入help获取帮助    \nalter:修改列族模式  \ncount:统计表中行的数量  \ncreate：创建表  \ndescribe:显示表相关的详细信息  \ndelete:删除指定对象的值（可以为表、行、列对应的值，另外也可以指定时间戳的值）  \ndeleteall:删除指定行的所有元素值  \ndisable:使表无效  \ndrop:删除表  \nenable:使表有效  \nexists：测试表是否存在  \nexit:退出Hbase Shell  \nget:获取行或单元(cell)的值  \nincr:增加指定表、行或列的值  \nlist:列出HBase中存在的所有表  \nput:向指定的表单元添加值  \ntools:列出HBase所支持的工具  \nscan：通过对表的扫描来获取对应的值  \nstatus:返回HBase集群的状态信息  \nshutdown:关闭HBase集群  \ntruncate:重新创建指定表  \nversion:返回HBase版本信息  \n下面介绍几个详细的：  \n（1）create  \n通过表名及用逗号做好事开的列族信息来创建表    \n1）hbase>create 't1',{NAME=>'f1',VERSIONS=>5}  \n2)hbase>create 't1',{NAME=>'f1'},{NAME=>'f2'},{NAME=>'f3'}  \nhbase>#上面的命令可以简写为下面所示的格式：  \nhbase>create 't1','f1','f2','f3'  \n3)hbase>create 't1',{NAME='f1',VERSIONS=>1,TTL=>2592000,BLOCKCACHE=>true}  \n以\"NAME=>'f1'举例说明，其中，列族参数的格式是箭头左侧为参数变量，右侧为参数对应的值，并用“=>”分开。  \n\n（2）list  \n列出HBase中包含的表名称  \nhbase>list   \n\n(3)put  \n向指定的HBase表单元添加值，例如向表t1的行r1、列c1:1添加值v1，并指定时间戳为ts的操作如下：  \nhbase>put 't1','r1','c1:1','value',ta1  \n\n(4)scan  \n获取指定表的相关信息，可以通过逗号分隔来指定扫描参数  \n例如：获取表test的所有值  \nhbase>scan 'test'  \n获取表test的c1列的所有值  \nhbase>scan 'test',{COLUMNS=>'c1'}   \n获取表test的c1列的前一行的所有值   \nhbase>scan 'test',{COLUMNS=>'c1',limit=>1}  \n\n(5)get  \n获取行或单元的值，此命令可以指定表名、行值、以及可选的列值和时间戳。   \n获取表test行r1的值  \nhbase>get 'test','r1'  \n获取表test行r1列c1:1的值  \nhbase>get 'test','r1'{COLUMN=>'c1:1'}  \n需要注意的是，COLUMN和COLUMNS是不同的，scan操作中的COLUMNS指定的是表的列族，get操作中的COLUMN指定的是特定的列，COLUMN的值实质上为“列族+：+列修饰符”。  \n另外，在shell中，常量不需要用引号引起来，但二进制的值需要用双引号引起来，而其他值则用单引号引起来。  \nHBase Shell的常量可以通过shell中输入“Object.constants”命令来查看。  \n\n\n\n\n","slug":"hadoop/HBase入门概念","published":1,"updated":"2017-08-18T01:44:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3biw000fs77r401l2hy8","content":"<p>#Hbase概念<br>HBase是一个分布式的、面向列的开源数据库。  </p>\n<p>##Hbase术语<br><strong>行键Row Key</strong>：主键是用来检索记录的主键，访问hbasetable中的行。<br><strong>列族Column Family</strong>：Table在水平方向有一个或者多个ColumnFamily组成，一个ColumnFamily中可以由任意多个Column组成，即ColumnFamily支持动态扩展，无需预先定义Column的数量以及类型，所有Column均以二进制格式存储，用户需要自行进行类型转换。<br><strong>列column</strong>：由Hbase中的列族ColumnFamily + 列的名称（cell）组成列。<br><strong>单元格cell</strong>：HBase中通过row和columns确定的为一个存贮单元称为cell。<br><strong>版本version</strong>：每个 cell都保存着同一份数据的多个版本。版本通过时间戳来索引。  </p>\n<p>#Hbase安装<br>三种方式：单机、伪分布式、分布式</p>\n<p>##单机模式<br>Hbase安装文件下载解压后，直接运行，在单机模式下HBase不使用HDFS。</p>\n<p>##伪分布式<br>运行在单个节点上的分布式模式  </p>\n<p>##全分布式<br>全分面式模式下的HBase集群需要ZooKeeper实例运行，并且需要所有的HBase节点都能够与ZooKeeper实例通信，默认情况下HBase自身维护着一组默认的ZooKeeper实例，不过用户也可以配置独立的ZooKeeper实例，这样能够使HBase更加健壮。</p>\n<p>#运行HBase</p>\n<p>##单机模式<br>start-hbase.sh<br>stop-hbase.sh</p>\n<p>##伪分分面式<br>由于伪分布式运行基于HDFS，因此在期待运行HBase之前首先需要启动HDFS。<br>start-dfs.sh<br>然后start-hbase.sh</p>\n<p>##全分布式<br>与伪分布式相同</p>\n<p>#Hbase Shell<br>Hbase Shell提供了HBae命令，可以方便创建、删除及修改表，还可以向表中添加数据、列出表中相关信息等。<br>在启动hbase之后，用户可以通过下面的命令进入Hbase Shell：<br>hbase shell<br>输入help获取帮助<br>alter:修改列族模式<br>count:统计表中行的数量<br>create：创建表<br>describe:显示表相关的详细信息<br>delete:删除指定对象的值（可以为表、行、列对应的值，另外也可以指定时间戳的值）<br>deleteall:删除指定行的所有元素值<br>disable:使表无效<br>drop:删除表<br>enable:使表有效<br>exists：测试表是否存在<br>exit:退出Hbase Shell<br>get:获取行或单元(cell)的值<br>incr:增加指定表、行或列的值<br>list:列出HBase中存在的所有表<br>put:向指定的表单元添加值<br>tools:列出HBase所支持的工具<br>scan：通过对表的扫描来获取对应的值<br>status:返回HBase集群的状态信息<br>shutdown:关闭HBase集群<br>truncate:重新创建指定表<br>version:返回HBase版本信息<br>下面介绍几个详细的：<br>（1）create<br>通过表名及用逗号做好事开的列族信息来创建表<br>1）hbase&gt;create ‘t1’,{NAME=&gt;’f1’,VERSIONS=&gt;5}<br>2)hbase&gt;create ‘t1’,{NAME=&gt;’f1’},{NAME=&gt;’f2’},{NAME=&gt;’f3’}<br>hbase&gt;#上面的命令可以简写为下面所示的格式：<br>hbase&gt;create ‘t1’,’f1’,’f2’,’f3’<br>3)hbase&gt;create ‘t1’,{NAME=’f1’,VERSIONS=&gt;1,TTL=&gt;2592000,BLOCKCACHE=&gt;true}<br>以”NAME=&gt;’f1’举例说明，其中，列族参数的格式是箭头左侧为参数变量，右侧为参数对应的值，并用“=&gt;”分开。  </p>\n<p>（2）list<br>列出HBase中包含的表名称<br>hbase&gt;list   </p>\n<p>(3)put<br>向指定的HBase表单元添加值，例如向表t1的行r1、列c1:1添加值v1，并指定时间戳为ts的操作如下：<br>hbase&gt;put ‘t1’,’r1’,’c1:1’,’value’,ta1  </p>\n<p>(4)scan<br>获取指定表的相关信息，可以通过逗号分隔来指定扫描参数<br>例如：获取表test的所有值<br>hbase&gt;scan ‘test’<br>获取表test的c1列的所有值<br>hbase&gt;scan ‘test’,{COLUMNS=&gt;’c1’}<br>获取表test的c1列的前一行的所有值<br>hbase&gt;scan ‘test’,{COLUMNS=&gt;’c1’,limit=&gt;1}  </p>\n<p>(5)get<br>获取行或单元的值，此命令可以指定表名、行值、以及可选的列值和时间戳。<br>获取表test行r1的值<br>hbase&gt;get ‘test’,’r1’<br>获取表test行r1列c1:1的值<br>hbase&gt;get ‘test’,’r1’{COLUMN=&gt;’c1:1’}<br>需要注意的是，COLUMN和COLUMNS是不同的，scan操作中的COLUMNS指定的是表的列族，get操作中的COLUMN指定的是特定的列，COLUMN的值实质上为“列族+：+列修饰符”。<br>另外，在shell中，常量不需要用引号引起来，但二进制的值需要用双引号引起来，而其他值则用单引号引起来。<br>HBase Shell的常量可以通过shell中输入“Object.constants”命令来查看。  </p>\n","site":{"data":{}},"excerpt":"","more":"<p>#Hbase概念<br>HBase是一个分布式的、面向列的开源数据库。  </p>\n<p>##Hbase术语<br><strong>行键Row Key</strong>：主键是用来检索记录的主键，访问hbasetable中的行。<br><strong>列族Column Family</strong>：Table在水平方向有一个或者多个ColumnFamily组成，一个ColumnFamily中可以由任意多个Column组成，即ColumnFamily支持动态扩展，无需预先定义Column的数量以及类型，所有Column均以二进制格式存储，用户需要自行进行类型转换。<br><strong>列column</strong>：由Hbase中的列族ColumnFamily + 列的名称（cell）组成列。<br><strong>单元格cell</strong>：HBase中通过row和columns确定的为一个存贮单元称为cell。<br><strong>版本version</strong>：每个 cell都保存着同一份数据的多个版本。版本通过时间戳来索引。  </p>\n<p>#Hbase安装<br>三种方式：单机、伪分布式、分布式</p>\n<p>##单机模式<br>Hbase安装文件下载解压后，直接运行，在单机模式下HBase不使用HDFS。</p>\n<p>##伪分布式<br>运行在单个节点上的分布式模式  </p>\n<p>##全分布式<br>全分面式模式下的HBase集群需要ZooKeeper实例运行，并且需要所有的HBase节点都能够与ZooKeeper实例通信，默认情况下HBase自身维护着一组默认的ZooKeeper实例，不过用户也可以配置独立的ZooKeeper实例，这样能够使HBase更加健壮。</p>\n<p>#运行HBase</p>\n<p>##单机模式<br>start-hbase.sh<br>stop-hbase.sh</p>\n<p>##伪分分面式<br>由于伪分布式运行基于HDFS，因此在期待运行HBase之前首先需要启动HDFS。<br>start-dfs.sh<br>然后start-hbase.sh</p>\n<p>##全分布式<br>与伪分布式相同</p>\n<p>#Hbase Shell<br>Hbase Shell提供了HBae命令，可以方便创建、删除及修改表，还可以向表中添加数据、列出表中相关信息等。<br>在启动hbase之后，用户可以通过下面的命令进入Hbase Shell：<br>hbase shell<br>输入help获取帮助<br>alter:修改列族模式<br>count:统计表中行的数量<br>create：创建表<br>describe:显示表相关的详细信息<br>delete:删除指定对象的值（可以为表、行、列对应的值，另外也可以指定时间戳的值）<br>deleteall:删除指定行的所有元素值<br>disable:使表无效<br>drop:删除表<br>enable:使表有效<br>exists：测试表是否存在<br>exit:退出Hbase Shell<br>get:获取行或单元(cell)的值<br>incr:增加指定表、行或列的值<br>list:列出HBase中存在的所有表<br>put:向指定的表单元添加值<br>tools:列出HBase所支持的工具<br>scan：通过对表的扫描来获取对应的值<br>status:返回HBase集群的状态信息<br>shutdown:关闭HBase集群<br>truncate:重新创建指定表<br>version:返回HBase版本信息<br>下面介绍几个详细的：<br>（1）create<br>通过表名及用逗号做好事开的列族信息来创建表<br>1）hbase&gt;create ‘t1’,{NAME=&gt;’f1’,VERSIONS=&gt;5}<br>2)hbase&gt;create ‘t1’,{NAME=&gt;’f1’},{NAME=&gt;’f2’},{NAME=&gt;’f3’}<br>hbase&gt;#上面的命令可以简写为下面所示的格式：<br>hbase&gt;create ‘t1’,’f1’,’f2’,’f3’<br>3)hbase&gt;create ‘t1’,{NAME=’f1’,VERSIONS=&gt;1,TTL=&gt;2592000,BLOCKCACHE=&gt;true}<br>以”NAME=&gt;’f1’举例说明，其中，列族参数的格式是箭头左侧为参数变量，右侧为参数对应的值，并用“=&gt;”分开。  </p>\n<p>（2）list<br>列出HBase中包含的表名称<br>hbase&gt;list   </p>\n<p>(3)put<br>向指定的HBase表单元添加值，例如向表t1的行r1、列c1:1添加值v1，并指定时间戳为ts的操作如下：<br>hbase&gt;put ‘t1’,’r1’,’c1:1’,’value’,ta1  </p>\n<p>(4)scan<br>获取指定表的相关信息，可以通过逗号分隔来指定扫描参数<br>例如：获取表test的所有值<br>hbase&gt;scan ‘test’<br>获取表test的c1列的所有值<br>hbase&gt;scan ‘test’,{COLUMNS=&gt;’c1’}<br>获取表test的c1列的前一行的所有值<br>hbase&gt;scan ‘test’,{COLUMNS=&gt;’c1’,limit=&gt;1}  </p>\n<p>(5)get<br>获取行或单元的值，此命令可以指定表名、行值、以及可选的列值和时间戳。<br>获取表test行r1的值<br>hbase&gt;get ‘test’,’r1’<br>获取表test行r1列c1:1的值<br>hbase&gt;get ‘test’,’r1’{COLUMN=&gt;’c1:1’}<br>需要注意的是，COLUMN和COLUMNS是不同的，scan操作中的COLUMNS指定的是表的列族，get操作中的COLUMN指定的是特定的列，COLUMN的值实质上为“列族+：+列修饰符”。<br>另外，在shell中，常量不需要用引号引起来，但二进制的值需要用双引号引起来，而其他值则用单引号引起来。<br>HBase Shell的常量可以通过shell中输入“Object.constants”命令来查看。  </p>\n"},{"title":"HDFS入门概念","date":"2017-04-16T15:43:49.000Z","_content":"#数据块\n 每个磁盘都有默认的数据块大小，这是磁盘进行数据读/写的最小单位。构建于单个磁盘之上的文件系统通过磁盘块来管理该文件系统的块，该文件系统块的大小的可以是磁盘块的整数倍。文件系统块一般为几千字节，而磁盘块一般为512字节。这些信息--文件系统块大小---对于需要读/写文件的文件系统用户来说是透明的。\n\n\n\n\n","source":"_posts/hadoop/HDFS入门概念.md","raw":"---\ntitle: HDFS入门概念\ndate: 2017-04-16 23:43:49\ntags: [大数据,hadoop]\ncategories: [大数据,hdfs]\n---\n#数据块\n 每个磁盘都有默认的数据块大小，这是磁盘进行数据读/写的最小单位。构建于单个磁盘之上的文件系统通过磁盘块来管理该文件系统的块，该文件系统块的大小的可以是磁盘块的整数倍。文件系统块一般为几千字节，而磁盘块一般为512字节。这些信息--文件系统块大小---对于需要读/写文件的文件系统用户来说是透明的。\n\n\n\n\n","slug":"hadoop/HDFS入门概念","published":1,"updated":"2017-08-18T01:44:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3biz000gs77rgrl02so1","content":"<p>#数据块<br> 每个磁盘都有默认的数据块大小，这是磁盘进行数据读/写的最小单位。构建于单个磁盘之上的文件系统通过磁盘块来管理该文件系统的块，该文件系统块的大小的可以是磁盘块的整数倍。文件系统块一般为几千字节，而磁盘块一般为512字节。这些信息–文件系统块大小—对于需要读/写文件的文件系统用户来说是透明的。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>#数据块<br> 每个磁盘都有默认的数据块大小，这是磁盘进行数据读/写的最小单位。构建于单个磁盘之上的文件系统通过磁盘块来管理该文件系统的块，该文件系统块的大小的可以是磁盘块的整数倍。文件系统块一般为几千字节，而磁盘块一般为512字节。这些信息–文件系统块大小—对于需要读/写文件的文件系统用户来说是透明的。</p>\n"},{"title":"分布式存储","date":"2017-04-16T15:43:49.000Z","_content":"\n\n##Bigtable\nBigtable是非关系型数据库，是一个稀疏的、分布式的、持久化存储的多维度排序map。Bigtable设计的目的是快速且可靠地处理PB级别的数据，并且能够部署到上千台机器上。\n\nBigtable是闭源的，Cloud Bigtable是Google提供的大数据存储云服务。业界相关的Bigtable模型的开源实现为Apache HBase。\n\n##HBase\nHBase是一个高可靠、高性能、面向列、可伸缩的分布式存储系统，利用HBase技术可以在廉价PC上搭建起大规模结构化存储集群。\nHBase是Google Bigtable的开源实现，类似于Google Bigtable利用GFS作为其文件存储系统，HBase利用Hadoop HDFS作为其文件存储系统；Google运行MapRecue来处理Bigtable中的海量数据，HBase同样利用Hadoop MapRecue来处理HBase中的海量数据；Google Bigtable利用Chubby作为协同服务，HBase利用Zookeeper作为对应。\n###特性：\n强一致性读写：HBase不是“Eventual Consistentcy（最终一致性）”数据存储，这让它很适合高速计数聚合类任务；\n自动分片（Automatic sharding）：HBase表通过region分布在集群中，数据增长时，region会自动分割并重新分布；\nRegionServer自动故障转移\nHadoop/HDFS集成：HBase支持开箱即用HDFS作为它的分布式文件系统；\nMapRecue：HBase通过MapRecue支持大并发处理；\nJava客户端API：HBase支持易于使用的Java API进行编程访问;\nThrift/REST API：HBase也支持Thrift和Rest作为非Java前端访问；\nBlock Cache和Bloom Filter：对于大容量查询优化，HBase支持Block Cache和Bloom Filter;\n运维管理：HBase支持JMX提供内置网页用于运维。\n###HBase应用场景\nHBase不适合所有场景。\n首先，确信有足够多数据，如果有上亿或上千亿行数据，HBase是很好的备选。如果只有上千或上百万行，则用传统的RDBMS可能是更好的选择。因为所有数据如果只需要在一两个节点进行存储，会导致集群其他节点闲置。\n其次，确信可以不依赖于RDBMS的额外特性。例如，列数据类型、第二索引、事务、高级查询语言等\n最后，确保有足够的硬件。因为HDFS在小于5个数据节点时，基本上体现不出来它的优势。\n虽然HBase能在单独的笔记本上运行良好，但这应仅当成是开发阶段的配置 。\n###HBase的优点\n列可以动态增加，并且列为空就不存储数据，节省存储空间；\nHBase可以自动切分数据，使得数据存储自动具有水平扩展功能；\nHBase可以提供高并发读写操作的支持；\n与Hadoop MapRecue相结合有利于数据分析；\n容错性；\n版权免费；\n非常灵活的模式设计（或者说没有固定模式的限制）；\n可以跟Hive集成，使用类SQL查询；\n自动故障转移；\n客户端接口易于使用；\n行级别原子性，即PUT操作一定是完全成功或者完全失败。\n###HBase的缺点\n不能支持条件查询，只支持按照row key来查询；\n容易产生单点故障（在只使用一个HMaster的时候）；\n不支持事务；\nJOIN不是数据库层支持的，而需要用MapRecue；\n只能在主键上索引和排序；\n没有内置的身份和权限认证；\n###HBase与Hadoop/HDFS的差异\nHDFS是分布式文件系统，适合保存大文件。官方宣称它并非普通用途的文件系统，不提供文件的个别记录的快速查询。另一方面，HBase基于HDFS，并能够提供大表的记录快速查询和更新。HBase内部将数据放到索引好的“StoreFiles”存储文件中，以便提供高速查询，而存储文件位于HDFS中。\n\n\n##Cassandra\nCassandra是Facebook于2008年7月在Google Code上开源的项目。Cassandra实现了Dynamo风格的副本复制模型和没有单点失效的架构，增加了更加强大的column family数据模型。\n\n\n##Memcached\nMemcached可以更好利用内存\n\n\n##Redis\nRedis是一个key-value模型的内在数据存储系统。\n\n\n##MongoDB\nMongoDB是一个介于关系型数据库和非关系性数据库之间的产品，是非关系型 数据库中功能最丰富、最像关系型 数据库的，旨在为Web应用提供可扩展的高性能数据存储解决方案。\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/hadoop/Hadoop之分布式存储.md","raw":"---\ntitle: 分布式存储 \ndate: 2017-04-16 23:43:49\ntags: [分布式,分布式存储]\ncategories: [分布式,分布式存储]\n---\n\n\n##Bigtable\nBigtable是非关系型数据库，是一个稀疏的、分布式的、持久化存储的多维度排序map。Bigtable设计的目的是快速且可靠地处理PB级别的数据，并且能够部署到上千台机器上。\n\nBigtable是闭源的，Cloud Bigtable是Google提供的大数据存储云服务。业界相关的Bigtable模型的开源实现为Apache HBase。\n\n##HBase\nHBase是一个高可靠、高性能、面向列、可伸缩的分布式存储系统，利用HBase技术可以在廉价PC上搭建起大规模结构化存储集群。\nHBase是Google Bigtable的开源实现，类似于Google Bigtable利用GFS作为其文件存储系统，HBase利用Hadoop HDFS作为其文件存储系统；Google运行MapRecue来处理Bigtable中的海量数据，HBase同样利用Hadoop MapRecue来处理HBase中的海量数据；Google Bigtable利用Chubby作为协同服务，HBase利用Zookeeper作为对应。\n###特性：\n强一致性读写：HBase不是“Eventual Consistentcy（最终一致性）”数据存储，这让它很适合高速计数聚合类任务；\n自动分片（Automatic sharding）：HBase表通过region分布在集群中，数据增长时，region会自动分割并重新分布；\nRegionServer自动故障转移\nHadoop/HDFS集成：HBase支持开箱即用HDFS作为它的分布式文件系统；\nMapRecue：HBase通过MapRecue支持大并发处理；\nJava客户端API：HBase支持易于使用的Java API进行编程访问;\nThrift/REST API：HBase也支持Thrift和Rest作为非Java前端访问；\nBlock Cache和Bloom Filter：对于大容量查询优化，HBase支持Block Cache和Bloom Filter;\n运维管理：HBase支持JMX提供内置网页用于运维。\n###HBase应用场景\nHBase不适合所有场景。\n首先，确信有足够多数据，如果有上亿或上千亿行数据，HBase是很好的备选。如果只有上千或上百万行，则用传统的RDBMS可能是更好的选择。因为所有数据如果只需要在一两个节点进行存储，会导致集群其他节点闲置。\n其次，确信可以不依赖于RDBMS的额外特性。例如，列数据类型、第二索引、事务、高级查询语言等\n最后，确保有足够的硬件。因为HDFS在小于5个数据节点时，基本上体现不出来它的优势。\n虽然HBase能在单独的笔记本上运行良好，但这应仅当成是开发阶段的配置 。\n###HBase的优点\n列可以动态增加，并且列为空就不存储数据，节省存储空间；\nHBase可以自动切分数据，使得数据存储自动具有水平扩展功能；\nHBase可以提供高并发读写操作的支持；\n与Hadoop MapRecue相结合有利于数据分析；\n容错性；\n版权免费；\n非常灵活的模式设计（或者说没有固定模式的限制）；\n可以跟Hive集成，使用类SQL查询；\n自动故障转移；\n客户端接口易于使用；\n行级别原子性，即PUT操作一定是完全成功或者完全失败。\n###HBase的缺点\n不能支持条件查询，只支持按照row key来查询；\n容易产生单点故障（在只使用一个HMaster的时候）；\n不支持事务；\nJOIN不是数据库层支持的，而需要用MapRecue；\n只能在主键上索引和排序；\n没有内置的身份和权限认证；\n###HBase与Hadoop/HDFS的差异\nHDFS是分布式文件系统，适合保存大文件。官方宣称它并非普通用途的文件系统，不提供文件的个别记录的快速查询。另一方面，HBase基于HDFS，并能够提供大表的记录快速查询和更新。HBase内部将数据放到索引好的“StoreFiles”存储文件中，以便提供高速查询，而存储文件位于HDFS中。\n\n\n##Cassandra\nCassandra是Facebook于2008年7月在Google Code上开源的项目。Cassandra实现了Dynamo风格的副本复制模型和没有单点失效的架构，增加了更加强大的column family数据模型。\n\n\n##Memcached\nMemcached可以更好利用内存\n\n\n##Redis\nRedis是一个key-value模型的内在数据存储系统。\n\n\n##MongoDB\nMongoDB是一个介于关系型数据库和非关系性数据库之间的产品，是非关系型 数据库中功能最丰富、最像关系型 数据库的，旨在为Web应用提供可扩展的高性能数据存储解决方案。\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"hadoop/Hadoop之分布式存储","published":1,"updated":"2017-08-18T01:44:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bj2000js77riixt08rj","content":"<p>##Bigtable<br>Bigtable是非关系型数据库，是一个稀疏的、分布式的、持久化存储的多维度排序map。Bigtable设计的目的是快速且可靠地处理PB级别的数据，并且能够部署到上千台机器上。</p>\n<p>Bigtable是闭源的，Cloud Bigtable是Google提供的大数据存储云服务。业界相关的Bigtable模型的开源实现为Apache HBase。</p>\n<p>##HBase<br>HBase是一个高可靠、高性能、面向列、可伸缩的分布式存储系统，利用HBase技术可以在廉价PC上搭建起大规模结构化存储集群。<br>HBase是Google Bigtable的开源实现，类似于Google Bigtable利用GFS作为其文件存储系统，HBase利用Hadoop HDFS作为其文件存储系统；Google运行MapRecue来处理Bigtable中的海量数据，HBase同样利用Hadoop MapRecue来处理HBase中的海量数据；Google Bigtable利用Chubby作为协同服务，HBase利用Zookeeper作为对应。</p>\n<p>###特性：<br>强一致性读写：HBase不是“Eventual Consistentcy（最终一致性）”数据存储，这让它很适合高速计数聚合类任务；<br>自动分片（Automatic sharding）：HBase表通过region分布在集群中，数据增长时，region会自动分割并重新分布；<br>RegionServer自动故障转移<br>Hadoop/HDFS集成：HBase支持开箱即用HDFS作为它的分布式文件系统；<br>MapRecue：HBase通过MapRecue支持大并发处理；<br>Java客户端API：HBase支持易于使用的Java API进行编程访问;<br>Thrift/REST API：HBase也支持Thrift和Rest作为非Java前端访问；<br>Block Cache和Bloom Filter：对于大容量查询优化，HBase支持Block Cache和Bloom Filter;<br>运维管理：HBase支持JMX提供内置网页用于运维。</p>\n<p>###HBase应用场景<br>HBase不适合所有场景。<br>首先，确信有足够多数据，如果有上亿或上千亿行数据，HBase是很好的备选。如果只有上千或上百万行，则用传统的RDBMS可能是更好的选择。因为所有数据如果只需要在一两个节点进行存储，会导致集群其他节点闲置。<br>其次，确信可以不依赖于RDBMS的额外特性。例如，列数据类型、第二索引、事务、高级查询语言等<br>最后，确保有足够的硬件。因为HDFS在小于5个数据节点时，基本上体现不出来它的优势。<br>虽然HBase能在单独的笔记本上运行良好，但这应仅当成是开发阶段的配置 。</p>\n<p>###HBase的优点<br>列可以动态增加，并且列为空就不存储数据，节省存储空间；<br>HBase可以自动切分数据，使得数据存储自动具有水平扩展功能；<br>HBase可以提供高并发读写操作的支持；<br>与Hadoop MapRecue相结合有利于数据分析；<br>容错性；<br>版权免费；<br>非常灵活的模式设计（或者说没有固定模式的限制）；<br>可以跟Hive集成，使用类SQL查询；<br>自动故障转移；<br>客户端接口易于使用；<br>行级别原子性，即PUT操作一定是完全成功或者完全失败。</p>\n<p>###HBase的缺点<br>不能支持条件查询，只支持按照row key来查询；<br>容易产生单点故障（在只使用一个HMaster的时候）；<br>不支持事务；<br>JOIN不是数据库层支持的，而需要用MapRecue；<br>只能在主键上索引和排序；<br>没有内置的身份和权限认证；</p>\n<p>###HBase与Hadoop/HDFS的差异<br>HDFS是分布式文件系统，适合保存大文件。官方宣称它并非普通用途的文件系统，不提供文件的个别记录的快速查询。另一方面，HBase基于HDFS，并能够提供大表的记录快速查询和更新。HBase内部将数据放到索引好的“StoreFiles”存储文件中，以便提供高速查询，而存储文件位于HDFS中。</p>\n<p>##Cassandra<br>Cassandra是Facebook于2008年7月在Google Code上开源的项目。Cassandra实现了Dynamo风格的副本复制模型和没有单点失效的架构，增加了更加强大的column family数据模型。</p>\n<p>##Memcached<br>Memcached可以更好利用内存</p>\n<p>##Redis<br>Redis是一个key-value模型的内在数据存储系统。</p>\n<p>##MongoDB<br>MongoDB是一个介于关系型数据库和非关系性数据库之间的产品，是非关系型 数据库中功能最丰富、最像关系型 数据库的，旨在为Web应用提供可扩展的高性能数据存储解决方案。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>##Bigtable<br>Bigtable是非关系型数据库，是一个稀疏的、分布式的、持久化存储的多维度排序map。Bigtable设计的目的是快速且可靠地处理PB级别的数据，并且能够部署到上千台机器上。</p>\n<p>Bigtable是闭源的，Cloud Bigtable是Google提供的大数据存储云服务。业界相关的Bigtable模型的开源实现为Apache HBase。</p>\n<p>##HBase<br>HBase是一个高可靠、高性能、面向列、可伸缩的分布式存储系统，利用HBase技术可以在廉价PC上搭建起大规模结构化存储集群。<br>HBase是Google Bigtable的开源实现，类似于Google Bigtable利用GFS作为其文件存储系统，HBase利用Hadoop HDFS作为其文件存储系统；Google运行MapRecue来处理Bigtable中的海量数据，HBase同样利用Hadoop MapRecue来处理HBase中的海量数据；Google Bigtable利用Chubby作为协同服务，HBase利用Zookeeper作为对应。</p>\n<p>###特性：<br>强一致性读写：HBase不是“Eventual Consistentcy（最终一致性）”数据存储，这让它很适合高速计数聚合类任务；<br>自动分片（Automatic sharding）：HBase表通过region分布在集群中，数据增长时，region会自动分割并重新分布；<br>RegionServer自动故障转移<br>Hadoop/HDFS集成：HBase支持开箱即用HDFS作为它的分布式文件系统；<br>MapRecue：HBase通过MapRecue支持大并发处理；<br>Java客户端API：HBase支持易于使用的Java API进行编程访问;<br>Thrift/REST API：HBase也支持Thrift和Rest作为非Java前端访问；<br>Block Cache和Bloom Filter：对于大容量查询优化，HBase支持Block Cache和Bloom Filter;<br>运维管理：HBase支持JMX提供内置网页用于运维。</p>\n<p>###HBase应用场景<br>HBase不适合所有场景。<br>首先，确信有足够多数据，如果有上亿或上千亿行数据，HBase是很好的备选。如果只有上千或上百万行，则用传统的RDBMS可能是更好的选择。因为所有数据如果只需要在一两个节点进行存储，会导致集群其他节点闲置。<br>其次，确信可以不依赖于RDBMS的额外特性。例如，列数据类型、第二索引、事务、高级查询语言等<br>最后，确保有足够的硬件。因为HDFS在小于5个数据节点时，基本上体现不出来它的优势。<br>虽然HBase能在单独的笔记本上运行良好，但这应仅当成是开发阶段的配置 。</p>\n<p>###HBase的优点<br>列可以动态增加，并且列为空就不存储数据，节省存储空间；<br>HBase可以自动切分数据，使得数据存储自动具有水平扩展功能；<br>HBase可以提供高并发读写操作的支持；<br>与Hadoop MapRecue相结合有利于数据分析；<br>容错性；<br>版权免费；<br>非常灵活的模式设计（或者说没有固定模式的限制）；<br>可以跟Hive集成，使用类SQL查询；<br>自动故障转移；<br>客户端接口易于使用；<br>行级别原子性，即PUT操作一定是完全成功或者完全失败。</p>\n<p>###HBase的缺点<br>不能支持条件查询，只支持按照row key来查询；<br>容易产生单点故障（在只使用一个HMaster的时候）；<br>不支持事务；<br>JOIN不是数据库层支持的，而需要用MapRecue；<br>只能在主键上索引和排序；<br>没有内置的身份和权限认证；</p>\n<p>###HBase与Hadoop/HDFS的差异<br>HDFS是分布式文件系统，适合保存大文件。官方宣称它并非普通用途的文件系统，不提供文件的个别记录的快速查询。另一方面，HBase基于HDFS，并能够提供大表的记录快速查询和更新。HBase内部将数据放到索引好的“StoreFiles”存储文件中，以便提供高速查询，而存储文件位于HDFS中。</p>\n<p>##Cassandra<br>Cassandra是Facebook于2008年7月在Google Code上开源的项目。Cassandra实现了Dynamo风格的副本复制模型和没有单点失效的架构，增加了更加强大的column family数据模型。</p>\n<p>##Memcached<br>Memcached可以更好利用内存</p>\n<p>##Redis<br>Redis是一个key-value模型的内在数据存储系统。</p>\n<p>##MongoDB<br>MongoDB是一个介于关系型数据库和非关系性数据库之间的产品，是非关系型 数据库中功能最丰富、最像关系型 数据库的，旨在为Web应用提供可扩展的高性能数据存储解决方案。</p>\n"},{"title":"实时分析","date":"2017-04-16T15:43:49.000Z","_content":"少量数据离线分析对于MapRecue这样的批处理系统挑战并不大，如果要求时实而又分为两种情况：如果查询模式单一，那么，可以通过MapRecue预处理后将最终结果导入到在线系统提供实时查询；如果查询模式复杂，例如涉及多个列任意组合查询，那么，只能通过实时分析系统解决。实时分析系统融合了并行数据库和云计算这两类技术，能够从海量数据中快速分析出汇总结果。\n\n\n#MPP架构\n并行数据库往往采用MPP（Massively Parallel Processing，大规模并行处理）架构。MPP架构是一种不共享的结果，每个节点可以运行自己的操作系统、数据库等，每个节点内的CPU不能访问另一个节点的内存，节点之间的信息交互是通过节点互联网络实现的。\n\n#EMC Greenplum\nGreenplum是EMC公司研发的一款采用MPP架构的OLAP产品，底层基于开源的PostgreSQL数据库。\n\n\n#HP Vertica\nVertica是商业版。\n\n\n#Google Dremel\n\n\n\n\n\n\n","source":"_posts/hadoop/Hadoop之实时分析.md","raw":"---\ntitle: 实时分析\ndate: 2017-04-16 23:43:49\ntags: [大数据,实时分析]\ncategories: [大数据,实时分析]\n---\n少量数据离线分析对于MapRecue这样的批处理系统挑战并不大，如果要求时实而又分为两种情况：如果查询模式单一，那么，可以通过MapRecue预处理后将最终结果导入到在线系统提供实时查询；如果查询模式复杂，例如涉及多个列任意组合查询，那么，只能通过实时分析系统解决。实时分析系统融合了并行数据库和云计算这两类技术，能够从海量数据中快速分析出汇总结果。\n\n\n#MPP架构\n并行数据库往往采用MPP（Massively Parallel Processing，大规模并行处理）架构。MPP架构是一种不共享的结果，每个节点可以运行自己的操作系统、数据库等，每个节点内的CPU不能访问另一个节点的内存，节点之间的信息交互是通过节点互联网络实现的。\n\n#EMC Greenplum\nGreenplum是EMC公司研发的一款采用MPP架构的OLAP产品，底层基于开源的PostgreSQL数据库。\n\n\n#HP Vertica\nVertica是商业版。\n\n\n#Google Dremel\n\n\n\n\n\n\n","slug":"hadoop/Hadoop之实时分析","published":1,"updated":"2017-08-18T01:44:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bj3000ks77rhjvx7rl1","content":"<p>少量数据离线分析对于MapRecue这样的批处理系统挑战并不大，如果要求时实而又分为两种情况：如果查询模式单一，那么，可以通过MapRecue预处理后将最终结果导入到在线系统提供实时查询；如果查询模式复杂，例如涉及多个列任意组合查询，那么，只能通过实时分析系统解决。实时分析系统融合了并行数据库和云计算这两类技术，能够从海量数据中快速分析出汇总结果。</p>\n<p>#MPP架构<br>并行数据库往往采用MPP（Massively Parallel Processing，大规模并行处理）架构。MPP架构是一种不共享的结果，每个节点可以运行自己的操作系统、数据库等，每个节点内的CPU不能访问另一个节点的内存，节点之间的信息交互是通过节点互联网络实现的。</p>\n<p>#EMC Greenplum<br>Greenplum是EMC公司研发的一款采用MPP架构的OLAP产品，底层基于开源的PostgreSQL数据库。</p>\n<p>#HP Vertica<br>Vertica是商业版。</p>\n<p>#Google Dremel</p>\n","site":{"data":{}},"excerpt":"","more":"<p>少量数据离线分析对于MapRecue这样的批处理系统挑战并不大，如果要求时实而又分为两种情况：如果查询模式单一，那么，可以通过MapRecue预处理后将最终结果导入到在线系统提供实时查询；如果查询模式复杂，例如涉及多个列任意组合查询，那么，只能通过实时分析系统解决。实时分析系统融合了并行数据库和云计算这两类技术，能够从海量数据中快速分析出汇总结果。</p>\n<p>#MPP架构<br>并行数据库往往采用MPP（Massively Parallel Processing，大规模并行处理）架构。MPP架构是一种不共享的结果，每个节点可以运行自己的操作系统、数据库等，每个节点内的CPU不能访问另一个节点的内存，节点之间的信息交互是通过节点互联网络实现的。</p>\n<p>#EMC Greenplum<br>Greenplum是EMC公司研发的一款采用MPP架构的OLAP产品，底层基于开源的PostgreSQL数据库。</p>\n<p>#HP Vertica<br>Vertica是商业版。</p>\n<p>#Google Dremel</p>\n"},{"title":"流式计算","date":"2017-04-16T15:43:49.000Z","_content":"MapRecue及其扩展解决了离线批处理问题，但是无法保证实时性。对于实时性要求高的场景，可以采用流式计算或者实时分析系统进行处理。\n流式计算（Stream Processing）解决在线聚合（Online Aggregation）、在线过滤（Online Filter）等问题，流式计算同时具有存储系统和计算系统的特点，经常应用在一些类似于反作弊、交易异常监控等场景。流式计算的操作算子和时间相关，处理最近一段时间窗口内的数据。\n\n#原理\n流式计算强调的是数据流的实时性。MapRecue系统主要解决的是对静态数据的批量处理，当MapRecue作业启动时，已经准备好了输入数据，比如保存在分布式文件系统上。而流式计算系统在启动时，输入数据一般并没有完全到位，而是经由外部数据流源源不断地流入。另外，流式计算并不像批处理系统那样，重视数据处理的总吞吐量，而是更加重视对数据处理的延迟。\nMapRecue及其扩展采用的是一种比较静态的模型，如果用它来做数据流的处理，首先需要将数据流缓存并分块，然后放入集群计算。如果MapRecue每次处理的数据量较小，缓存数据流的时间较短，但是，MapRecue框架造成的额外开销将会占用很大比重；如果MapRecue每次处理的数据量较大，缓存数据流的时间会很长，无法满足实时性的要求。\n\n#Yahoo S4\n\n\n#Twitter Stoorm\n\n\n\n\n\n\n\n","source":"_posts/hadoop/Hadoop之流式计算.md","raw":"---\ntitle: 流式计算\ndate: 2017-04-16 23:43:49\ntags: [大数据,流式计算]\ncategories: [大数据,流式计算]\n---\nMapRecue及其扩展解决了离线批处理问题，但是无法保证实时性。对于实时性要求高的场景，可以采用流式计算或者实时分析系统进行处理。\n流式计算（Stream Processing）解决在线聚合（Online Aggregation）、在线过滤（Online Filter）等问题，流式计算同时具有存储系统和计算系统的特点，经常应用在一些类似于反作弊、交易异常监控等场景。流式计算的操作算子和时间相关，处理最近一段时间窗口内的数据。\n\n#原理\n流式计算强调的是数据流的实时性。MapRecue系统主要解决的是对静态数据的批量处理，当MapRecue作业启动时，已经准备好了输入数据，比如保存在分布式文件系统上。而流式计算系统在启动时，输入数据一般并没有完全到位，而是经由外部数据流源源不断地流入。另外，流式计算并不像批处理系统那样，重视数据处理的总吞吐量，而是更加重视对数据处理的延迟。\nMapRecue及其扩展采用的是一种比较静态的模型，如果用它来做数据流的处理，首先需要将数据流缓存并分块，然后放入集群计算。如果MapRecue每次处理的数据量较小，缓存数据流的时间较短，但是，MapRecue框架造成的额外开销将会占用很大比重；如果MapRecue每次处理的数据量较大，缓存数据流的时间会很长，无法满足实时性的要求。\n\n#Yahoo S4\n\n\n#Twitter Stoorm\n\n\n\n\n\n\n\n","slug":"hadoop/Hadoop之流式计算","published":1,"updated":"2017-08-18T01:44:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bj5000ns77r1r8phq9t","content":"<p>MapRecue及其扩展解决了离线批处理问题，但是无法保证实时性。对于实时性要求高的场景，可以采用流式计算或者实时分析系统进行处理。<br>流式计算（Stream Processing）解决在线聚合（Online Aggregation）、在线过滤（Online Filter）等问题，流式计算同时具有存储系统和计算系统的特点，经常应用在一些类似于反作弊、交易异常监控等场景。流式计算的操作算子和时间相关，处理最近一段时间窗口内的数据。</p>\n<p>#原理<br>流式计算强调的是数据流的实时性。MapRecue系统主要解决的是对静态数据的批量处理，当MapRecue作业启动时，已经准备好了输入数据，比如保存在分布式文件系统上。而流式计算系统在启动时，输入数据一般并没有完全到位，而是经由外部数据流源源不断地流入。另外，流式计算并不像批处理系统那样，重视数据处理的总吞吐量，而是更加重视对数据处理的延迟。<br>MapRecue及其扩展采用的是一种比较静态的模型，如果用它来做数据流的处理，首先需要将数据流缓存并分块，然后放入集群计算。如果MapRecue每次处理的数据量较小，缓存数据流的时间较短，但是，MapRecue框架造成的额外开销将会占用很大比重；如果MapRecue每次处理的数据量较大，缓存数据流的时间会很长，无法满足实时性的要求。</p>\n<p>#Yahoo S4</p>\n<p>#Twitter Stoorm</p>\n","site":{"data":{}},"excerpt":"","more":"<p>MapRecue及其扩展解决了离线批处理问题，但是无法保证实时性。对于实时性要求高的场景，可以采用流式计算或者实时分析系统进行处理。<br>流式计算（Stream Processing）解决在线聚合（Online Aggregation）、在线过滤（Online Filter）等问题，流式计算同时具有存储系统和计算系统的特点，经常应用在一些类似于反作弊、交易异常监控等场景。流式计算的操作算子和时间相关，处理最近一段时间窗口内的数据。</p>\n<p>#原理<br>流式计算强调的是数据流的实时性。MapRecue系统主要解决的是对静态数据的批量处理，当MapRecue作业启动时，已经准备好了输入数据，比如保存在分布式文件系统上。而流式计算系统在启动时，输入数据一般并没有完全到位，而是经由外部数据流源源不断地流入。另外，流式计算并不像批处理系统那样，重视数据处理的总吞吐量，而是更加重视对数据处理的延迟。<br>MapRecue及其扩展采用的是一种比较静态的模型，如果用它来做数据流的处理，首先需要将数据流缓存并分块，然后放入集群计算。如果MapRecue每次处理的数据量较小，缓存数据流的时间较短，但是，MapRecue框架造成的额外开销将会占用很大比重；如果MapRecue每次处理的数据量较大，缓存数据流的时间会很长，无法满足实时性的要求。</p>\n<p>#Yahoo S4</p>\n<p>#Twitter Stoorm</p>\n"},{"title":"Hive入门概念","date":"2017-05-02T02:30:00.000Z","_content":"#Hive\n大数据生态下，通过Hadoop MapReduce，实现将计算分割成多个处理单元，然后分散到一群家用或服务器级别的硬件上，从而降低成本并提供可伸缩性；这个计算模型下是HDFS，这是个“可插拔的“文件系统。不过，这里存在一个问题，就是用户如何从一个现有的数据基础架构转移到Hadoop上，而这个基础架构是基于关系型数据库和结构化查询语句（SQL）？\n这就是Hive出现的原因，Hive提供了被称为Hive查询语言的（或称为HiveQL或HQL）的SQL方言，来查询存储在Hadoop集群中的数据。Hive将大多数据的查询转换为MapRecue任务（ｊｏｂ）。\n\n#Hive安装\nHive使用环境变量HADOOP_HOME来指定Hadoop的所有相关JAR和配置文件，因此在安装之前请确认下是否设置好了这个环境变量。\n$cd ~\n$curl -o http://archive.apache.org/dis/hive/hive-0.9.0/hive-0.9.0-bin.tar.gz\n$tar -xzf hive-0.9.0.tar.gz\n$sudo mkdir -p /user/hive/warehouse\n$sudo chmod a+rwx /user/hive/warehouse\n\n可以定义HIVE_HOME环境变量\n$sudo echo \"export HIVE_HOME=$PWD/hive-0.9.0\" > /etc/profile.d/hive.sh\n$sudo echo \"PATH=$PATH:$HIVE_HOME/bin\" >> /etc/profile.d/hive.sh\n$. /etc/profile\n\n#Hive组成\n主要包含三个部分：\n1.代码本身，在$HIVE_HOME/lib下可以看到许多jar，例如hive-exec*.jar，hive-metastore*.ja，每个jar文件都实现了hive功能中某个特定的部分。\n2.可执行文件，在$HIVE_HOME/bin下，包含hive的命令行界面CLI，CLI是使用hive最常用的方式，一般会使用小写的hive代替。CLI用于提供交互式的界面供输入语句或用户执行hive语句的脚本。\n3.metastoreservice（元数据服务），所有的hive客户端都需要元数据服务，hive使用这个服务来存储表模式信息和其他元数据信息。通常会使用关系型数据库来存储这些信息，默认使用内置的DerbySQL服务器，其可以提供有限的、单进程的存储服务。例如，当使用Derby时，用户不能执行2个并发的Hive CLI实例，然而，如果是在个人计算机上或某些开发任务上使用的话这样也没有问题。对于集群来说，需要使用MYSQL或类似的关系型数据库。\n另外，hive还有一些组件，Thrift服务提供可远程访问的其他进程的功能，也提供JDBC和ODBC访问Hive的功能。Hive还提供了一个简单的网页界面HWI，提供远程访问Hive服务。\n\n#Hive启动\n使用$HIVE_HOME/bin/hive命令\n$cd $HIVE_HOME\n$bin/hive\nhive>CREATE TABLE x (a INT);\nhive>SELECT * from x;\nhive>DROP TABLE x; \nhive>exit;\n\n#Hive命令\n[root@cdhmaster~]#hive--help  \nUsage./hive<parameters>--serviceserviceName<serviceparameters>  \nServiceList:beelinecleardanglingscratchdirclihelphiveburninclienthiveserver2hiveserverhwijarlineagemetastoremetatoolorcfiledumprcfilecatschemaToolversion  \nParametersparsed:  \n--auxpath:Auxillaryjars  \n--config:Hiveconfigurationdirectory  \n--service:Startsspecificservice/component.cliisdefault  \nParametersused:  \nHADOOP_HOMEorHADOOP_PREFIX:Hadoopinstalldirectory  \nHIVE_OPT:Hiveoptions  \nForhelponaparticularservice:  \n./hive--serviceserviceName--help  \nDebughelp:./hive--debug--help  \nYouhavenewmailin/var/spool/mail/root  \n需要注意ServiceList:后面的内容，这里提供了几个服务，包括我们绝大多数据时间将要使用的CLI。用户可以通过--servicename服务名称来启用某个服务。  \n\n#常用SQL\n显示数据库  \nhive>showdatabases;  \nOK  \nDefault  \nhive>showdatabaselike'h.*';  \n创建数据库  \nhive>createdatabasetest_test001;  \nuse命令用于将某个数据库设置为用户当前的工作数据库  \nhive>usetest_test001;  \n设置当前工作数据库后，即可查询所有表  \nhive>showtables；  \n删除数据库  \nhive>dropdatabaseifexiststest_test001;  \n\n创建数据  \ncreatetableifnotexistsmydb.employees(  \nnamestringcomment'emplyeename',  \nSalaryfloat  \n)  \n\n删除表  \ndroptableifexiststest_test001;  \n\n修改表  \naltertable只会修改元数据  \n\n表重命名  \naltertabletest_test001renametotes;  \n\nset hive.cli.print.header=true; // 打印列名  \nset hive.cli.print.row.to.vertical=true; // 开启行转列功能, 前提必须开启打印列名功能  \nset hive.cli.print.row.to.vertical.num=1; // 设置每行显示的列数  \n\n\n\n","source":"_posts/hadoop/Hive入门概念.md","raw":"---\ntitle: Hive入门概念\ndate: 2017-05-02 10:30:00\ntags: [大数据,hive]\ncategories: [大数据,hive]\n---\n#Hive\n大数据生态下，通过Hadoop MapReduce，实现将计算分割成多个处理单元，然后分散到一群家用或服务器级别的硬件上，从而降低成本并提供可伸缩性；这个计算模型下是HDFS，这是个“可插拔的“文件系统。不过，这里存在一个问题，就是用户如何从一个现有的数据基础架构转移到Hadoop上，而这个基础架构是基于关系型数据库和结构化查询语句（SQL）？\n这就是Hive出现的原因，Hive提供了被称为Hive查询语言的（或称为HiveQL或HQL）的SQL方言，来查询存储在Hadoop集群中的数据。Hive将大多数据的查询转换为MapRecue任务（ｊｏｂ）。\n\n#Hive安装\nHive使用环境变量HADOOP_HOME来指定Hadoop的所有相关JAR和配置文件，因此在安装之前请确认下是否设置好了这个环境变量。\n$cd ~\n$curl -o http://archive.apache.org/dis/hive/hive-0.9.0/hive-0.9.0-bin.tar.gz\n$tar -xzf hive-0.9.0.tar.gz\n$sudo mkdir -p /user/hive/warehouse\n$sudo chmod a+rwx /user/hive/warehouse\n\n可以定义HIVE_HOME环境变量\n$sudo echo \"export HIVE_HOME=$PWD/hive-0.9.0\" > /etc/profile.d/hive.sh\n$sudo echo \"PATH=$PATH:$HIVE_HOME/bin\" >> /etc/profile.d/hive.sh\n$. /etc/profile\n\n#Hive组成\n主要包含三个部分：\n1.代码本身，在$HIVE_HOME/lib下可以看到许多jar，例如hive-exec*.jar，hive-metastore*.ja，每个jar文件都实现了hive功能中某个特定的部分。\n2.可执行文件，在$HIVE_HOME/bin下，包含hive的命令行界面CLI，CLI是使用hive最常用的方式，一般会使用小写的hive代替。CLI用于提供交互式的界面供输入语句或用户执行hive语句的脚本。\n3.metastoreservice（元数据服务），所有的hive客户端都需要元数据服务，hive使用这个服务来存储表模式信息和其他元数据信息。通常会使用关系型数据库来存储这些信息，默认使用内置的DerbySQL服务器，其可以提供有限的、单进程的存储服务。例如，当使用Derby时，用户不能执行2个并发的Hive CLI实例，然而，如果是在个人计算机上或某些开发任务上使用的话这样也没有问题。对于集群来说，需要使用MYSQL或类似的关系型数据库。\n另外，hive还有一些组件，Thrift服务提供可远程访问的其他进程的功能，也提供JDBC和ODBC访问Hive的功能。Hive还提供了一个简单的网页界面HWI，提供远程访问Hive服务。\n\n#Hive启动\n使用$HIVE_HOME/bin/hive命令\n$cd $HIVE_HOME\n$bin/hive\nhive>CREATE TABLE x (a INT);\nhive>SELECT * from x;\nhive>DROP TABLE x; \nhive>exit;\n\n#Hive命令\n[root@cdhmaster~]#hive--help  \nUsage./hive<parameters>--serviceserviceName<serviceparameters>  \nServiceList:beelinecleardanglingscratchdirclihelphiveburninclienthiveserver2hiveserverhwijarlineagemetastoremetatoolorcfiledumprcfilecatschemaToolversion  \nParametersparsed:  \n--auxpath:Auxillaryjars  \n--config:Hiveconfigurationdirectory  \n--service:Startsspecificservice/component.cliisdefault  \nParametersused:  \nHADOOP_HOMEorHADOOP_PREFIX:Hadoopinstalldirectory  \nHIVE_OPT:Hiveoptions  \nForhelponaparticularservice:  \n./hive--serviceserviceName--help  \nDebughelp:./hive--debug--help  \nYouhavenewmailin/var/spool/mail/root  \n需要注意ServiceList:后面的内容，这里提供了几个服务，包括我们绝大多数据时间将要使用的CLI。用户可以通过--servicename服务名称来启用某个服务。  \n\n#常用SQL\n显示数据库  \nhive>showdatabases;  \nOK  \nDefault  \nhive>showdatabaselike'h.*';  \n创建数据库  \nhive>createdatabasetest_test001;  \nuse命令用于将某个数据库设置为用户当前的工作数据库  \nhive>usetest_test001;  \n设置当前工作数据库后，即可查询所有表  \nhive>showtables；  \n删除数据库  \nhive>dropdatabaseifexiststest_test001;  \n\n创建数据  \ncreatetableifnotexistsmydb.employees(  \nnamestringcomment'emplyeename',  \nSalaryfloat  \n)  \n\n删除表  \ndroptableifexiststest_test001;  \n\n修改表  \naltertable只会修改元数据  \n\n表重命名  \naltertabletest_test001renametotes;  \n\nset hive.cli.print.header=true; // 打印列名  \nset hive.cli.print.row.to.vertical=true; // 开启行转列功能, 前提必须开启打印列名功能  \nset hive.cli.print.row.to.vertical.num=1; // 设置每行显示的列数  \n\n\n\n","slug":"hadoop/Hive入门概念","published":1,"updated":"2017-08-18T01:44:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bj7000ps77rtwwzobhp","content":"<p>#Hive<br>大数据生态下，通过Hadoop MapReduce，实现将计算分割成多个处理单元，然后分散到一群家用或服务器级别的硬件上，从而降低成本并提供可伸缩性；这个计算模型下是HDFS，这是个“可插拔的“文件系统。不过，这里存在一个问题，就是用户如何从一个现有的数据基础架构转移到Hadoop上，而这个基础架构是基于关系型数据库和结构化查询语句（SQL）？<br>这就是Hive出现的原因，Hive提供了被称为Hive查询语言的（或称为HiveQL或HQL）的SQL方言，来查询存储在Hadoop集群中的数据。Hive将大多数据的查询转换为MapRecue任务（ｊｏｂ）。</p>\n<p>#Hive安装<br>Hive使用环境变量HADOOP_HOME来指定Hadoop的所有相关JAR和配置文件，因此在安装之前请确认下是否设置好了这个环境变量。<br>$cd ~<br>$curl -o <a href=\"http://archive.apache.org/dis/hive/hive-0.9.0/hive-0.9.0-bin.tar.gz\" target=\"_blank\" rel=\"noopener\">http://archive.apache.org/dis/hive/hive-0.9.0/hive-0.9.0-bin.tar.gz</a><br>$tar -xzf hive-0.9.0.tar.gz<br>$sudo mkdir -p /user/hive/warehouse<br>$sudo chmod a+rwx /user/hive/warehouse</p>\n<p>可以定义HIVE_HOME环境变量<br>$sudo echo “export HIVE_HOME=$PWD/hive-0.9.0” &gt; /etc/profile.d/hive.sh<br>$sudo echo “PATH=$PATH:$HIVE_HOME/bin” &gt;&gt; /etc/profile.d/hive.sh<br>$. /etc/profile</p>\n<p>#Hive组成<br>主要包含三个部分：<br>1.代码本身，在$HIVE_HOME/lib下可以看到许多jar，例如hive-exec<em>.jar，hive-metastore</em>.ja，每个jar文件都实现了hive功能中某个特定的部分。<br>2.可执行文件，在$HIVE_HOME/bin下，包含hive的命令行界面CLI，CLI是使用hive最常用的方式，一般会使用小写的hive代替。CLI用于提供交互式的界面供输入语句或用户执行hive语句的脚本。<br>3.metastoreservice（元数据服务），所有的hive客户端都需要元数据服务，hive使用这个服务来存储表模式信息和其他元数据信息。通常会使用关系型数据库来存储这些信息，默认使用内置的DerbySQL服务器，其可以提供有限的、单进程的存储服务。例如，当使用Derby时，用户不能执行2个并发的Hive CLI实例，然而，如果是在个人计算机上或某些开发任务上使用的话这样也没有问题。对于集群来说，需要使用MYSQL或类似的关系型数据库。<br>另外，hive还有一些组件，Thrift服务提供可远程访问的其他进程的功能，也提供JDBC和ODBC访问Hive的功能。Hive还提供了一个简单的网页界面HWI，提供远程访问Hive服务。</p>\n<p>#Hive启动<br>使用$HIVE_HOME/bin/hive命令<br>$cd $HIVE_HOME<br>$bin/hive<br>hive&gt;CREATE TABLE x (a INT);<br>hive&gt;SELECT * from x;<br>hive&gt;DROP TABLE x;<br>hive&gt;exit;</p>\n<p>#Hive命令<br>[root@cdhmaster~]#hive–help<br>Usage./hive<parameters>–serviceserviceName<serviceparameters><br>ServiceList:beelinecleardanglingscratchdirclihelphiveburninclienthiveserver2hiveserverhwijarlineagemetastoremetatoolorcfiledumprcfilecatschemaToolversion<br>Parametersparsed:<br>–auxpath:Auxillaryjars<br>–config:Hiveconfigurationdirectory<br>–service:Startsspecificservice/component.cliisdefault<br>Parametersused:<br>HADOOP_HOMEorHADOOP_PREFIX:Hadoopinstalldirectory<br>HIVE_OPT:Hiveoptions<br>Forhelponaparticularservice:<br>./hive–serviceserviceName–help<br>Debughelp:./hive–debug–help<br>Youhavenewmailin/var/spool/mail/root<br>需要注意ServiceList:后面的内容，这里提供了几个服务，包括我们绝大多数据时间将要使用的CLI。用户可以通过–servicename服务名称来启用某个服务。  </serviceparameters></parameters></p>\n<p>#常用SQL<br>显示数据库<br>hive&gt;showdatabases;<br>OK<br>Default<br>hive&gt;showdatabaselike’h.*’;<br>创建数据库<br>hive&gt;createdatabasetest_test001;<br>use命令用于将某个数据库设置为用户当前的工作数据库<br>hive&gt;usetest_test001;<br>设置当前工作数据库后，即可查询所有表<br>hive&gt;showtables；<br>删除数据库<br>hive&gt;dropdatabaseifexiststest_test001;  </p>\n<p>创建数据<br>createtableifnotexistsmydb.employees(<br>namestringcomment’emplyeename’,<br>Salaryfloat<br>)  </p>\n<p>删除表<br>droptableifexiststest_test001;  </p>\n<p>修改表<br>altertable只会修改元数据  </p>\n<p>表重命名<br>altertabletest_test001renametotes;  </p>\n<p>set hive.cli.print.header=true; // 打印列名<br>set hive.cli.print.row.to.vertical=true; // 开启行转列功能, 前提必须开启打印列名功能<br>set hive.cli.print.row.to.vertical.num=1; // 设置每行显示的列数  </p>\n","site":{"data":{}},"excerpt":"","more":"<p>#Hive<br>大数据生态下，通过Hadoop MapReduce，实现将计算分割成多个处理单元，然后分散到一群家用或服务器级别的硬件上，从而降低成本并提供可伸缩性；这个计算模型下是HDFS，这是个“可插拔的“文件系统。不过，这里存在一个问题，就是用户如何从一个现有的数据基础架构转移到Hadoop上，而这个基础架构是基于关系型数据库和结构化查询语句（SQL）？<br>这就是Hive出现的原因，Hive提供了被称为Hive查询语言的（或称为HiveQL或HQL）的SQL方言，来查询存储在Hadoop集群中的数据。Hive将大多数据的查询转换为MapRecue任务（ｊｏｂ）。</p>\n<p>#Hive安装<br>Hive使用环境变量HADOOP_HOME来指定Hadoop的所有相关JAR和配置文件，因此在安装之前请确认下是否设置好了这个环境变量。<br>$cd ~<br>$curl -o <a href=\"http://archive.apache.org/dis/hive/hive-0.9.0/hive-0.9.0-bin.tar.gz\" target=\"_blank\" rel=\"noopener\">http://archive.apache.org/dis/hive/hive-0.9.0/hive-0.9.0-bin.tar.gz</a><br>$tar -xzf hive-0.9.0.tar.gz<br>$sudo mkdir -p /user/hive/warehouse<br>$sudo chmod a+rwx /user/hive/warehouse</p>\n<p>可以定义HIVE_HOME环境变量<br>$sudo echo “export HIVE_HOME=$PWD/hive-0.9.0” &gt; /etc/profile.d/hive.sh<br>$sudo echo “PATH=$PATH:$HIVE_HOME/bin” &gt;&gt; /etc/profile.d/hive.sh<br>$. /etc/profile</p>\n<p>#Hive组成<br>主要包含三个部分：<br>1.代码本身，在$HIVE_HOME/lib下可以看到许多jar，例如hive-exec<em>.jar，hive-metastore</em>.ja，每个jar文件都实现了hive功能中某个特定的部分。<br>2.可执行文件，在$HIVE_HOME/bin下，包含hive的命令行界面CLI，CLI是使用hive最常用的方式，一般会使用小写的hive代替。CLI用于提供交互式的界面供输入语句或用户执行hive语句的脚本。<br>3.metastoreservice（元数据服务），所有的hive客户端都需要元数据服务，hive使用这个服务来存储表模式信息和其他元数据信息。通常会使用关系型数据库来存储这些信息，默认使用内置的DerbySQL服务器，其可以提供有限的、单进程的存储服务。例如，当使用Derby时，用户不能执行2个并发的Hive CLI实例，然而，如果是在个人计算机上或某些开发任务上使用的话这样也没有问题。对于集群来说，需要使用MYSQL或类似的关系型数据库。<br>另外，hive还有一些组件，Thrift服务提供可远程访问的其他进程的功能，也提供JDBC和ODBC访问Hive的功能。Hive还提供了一个简单的网页界面HWI，提供远程访问Hive服务。</p>\n<p>#Hive启动<br>使用$HIVE_HOME/bin/hive命令<br>$cd $HIVE_HOME<br>$bin/hive<br>hive&gt;CREATE TABLE x (a INT);<br>hive&gt;SELECT * from x;<br>hive&gt;DROP TABLE x;<br>hive&gt;exit;</p>\n<p>#Hive命令<br>[root@cdhmaster~]#hive–help<br>Usage./hive<parameters>–serviceserviceName<serviceparameters><br>ServiceList:beelinecleardanglingscratchdirclihelphiveburninclienthiveserver2hiveserverhwijarlineagemetastoremetatoolorcfiledumprcfilecatschemaToolversion<br>Parametersparsed:<br>–auxpath:Auxillaryjars<br>–config:Hiveconfigurationdirectory<br>–service:Startsspecificservice/component.cliisdefault<br>Parametersused:<br>HADOOP_HOMEorHADOOP_PREFIX:Hadoopinstalldirectory<br>HIVE_OPT:Hiveoptions<br>Forhelponaparticularservice:<br>./hive–serviceserviceName–help<br>Debughelp:./hive–debug–help<br>Youhavenewmailin/var/spool/mail/root<br>需要注意ServiceList:后面的内容，这里提供了几个服务，包括我们绝大多数据时间将要使用的CLI。用户可以通过–servicename服务名称来启用某个服务。  </serviceparameters></parameters></p>\n<p>#常用SQL<br>显示数据库<br>hive&gt;showdatabases;<br>OK<br>Default<br>hive&gt;showdatabaselike’h.*’;<br>创建数据库<br>hive&gt;createdatabasetest_test001;<br>use命令用于将某个数据库设置为用户当前的工作数据库<br>hive&gt;usetest_test001;<br>设置当前工作数据库后，即可查询所有表<br>hive&gt;showtables；<br>删除数据库<br>hive&gt;dropdatabaseifexiststest_test001;  </p>\n<p>创建数据<br>createtableifnotexistsmydb.employees(<br>namestringcomment’emplyeename’,<br>Salaryfloat<br>)  </p>\n<p>删除表<br>droptableifexiststest_test001;  </p>\n<p>修改表<br>altertable只会修改元数据  </p>\n<p>表重命名<br>altertabletest_test001renametotes;  </p>\n<p>set hive.cli.print.header=true; // 打印列名<br>set hive.cli.print.row.to.vertical=true; // 开启行转列功能, 前提必须开启打印列名功能<br>set hive.cli.print.row.to.vertical.num=1; // 设置每行显示的列数  </p>\n"},{"title":"数据分析软件分类","date":"2017-04-16T15:43:49.000Z","_content":"\n#数据分析软件分类  \n下面介绍一些适合大数据分析的存储数据库，或者面向大数据分析，适用于TB级以上的数据库存储和分析任务。分为如下几类介绍：  \n1.商业数据库  \n2.开源时序数据库  \n3.开源计算框架  \n4.开源SQL on hadoop  \n5.云端数据分析SaaS  \n\n##商业软件  \n商业数据库软件种类繁多，但是真正能支持TB级别以上的数据存储和分析并不多，下面介绍几个有特点、支持大数据的商用数据库。  \n\n###HP Vertica\nVertica公司成立于2005年，创立者为数据库巨擘Michael Stonebraker。2011成Vertica被惠普收购。Vertica是能够提供高效数据存储和快速查询数据存储数据库实时分析平台，还支持大规模并行 处理（MPP）。产品广泛应用于高端数据营销、互联网客户分析处理，数据达到PB级别。\nVertical特点如下：\n面向列的存储  \n灵活的压缩算法，根据数据的排序性和基数决定压缩算法。  \n高可用数据库和查询  \nMPP架构，分布式存储和任务负载，Shared nothing架构。\n支持标准SQL查询、ODBC/JDBC等..   \n支持Projection（数据投射）功能。\n\n\n###Oracle Exadata\nOracle Exadata是数据库发展史上一个人传奇，它是数据库软件和最新硬件的完美结合。它提供最快、最可靠的数据库平台，不仅支持常规的数据库应用，也支持联机分析处理（OLAP）和数据仓库（DW）的场景。  \nOracle Exadata采用了多种最新的硬件技术，例如40GB的InfiniBan网络\n\n\n###Teradata\nTeradata（天睿）公司是专注于大数据分析、数据仓库和整合营销管理解决方案的供应商。Teradata采用纯粹的Shared noting架构，支持MPP。对于多维度的查询更加灵活，专注于数据仓库的应用领域。  \n\n\n##时序数据库\n时序数据库用于记录过去时间的各个数据点的信息，典型的应用是服务器的各种性能指标，例如CPU、内存使用情况等 。目前时序数据库也广泛应用于各种传感器的数据收集分析工作中，这些数据的收集都有一个特点，就是对时间的依赖非常大，每天产生的数据量非常大，因此定入的量非常大，一般的关系型数据库无法满足这些场景。因此，时序数据库在设计上需要支持高吞吐、高效数据压缩，支持历史查询、分布式部署等。\n\n###1.OpenTSDB\nOpenTSDB是一个开源的时序数据库，支持存储千亿的数据点，并提供精确查询功能。它采用Java语言编写，通过基于HBaser存储实现横向扩展。\n\n\n###2.InfluxDB\nInfluxDB采用GoLang语言开发，也是一个开源应用，社区非常活跃。其技术特点包含：支持任意数量的列，支持方便、强大的查询语言，集成了数据采集、存储和可视化功能。\n\n##开源分布式计算平台\n一个是Hadoop，另一个是Spark，这里就不一一介绍了。\n\n##开源分析数据库\n###Kylin\nKylin是Apache开源的开源分布式分析引擎。 \n与Kylin一样致力于大数据查询问题的开源产品如Apache Drill、Apache Impala、Druid、Hive、Presto（Facebook）、SparkSQL等。  \n从底层技术角度来看，这些开源产品有很大的共性，一些底层技术几乎被所有的产品一致采用。  \n1）大规模并行处理：可以通过增加机器的方式来扩容处理速度，在相同的时间里处理更多的数据。  \n2）列式存储：通过按列存储提高单位时间里数据的I/O吞吐率，还能跳过不需要访问的列。  \n3）索引：利用索引配合查询条件，可以迅速跳过不符合条件的数据块，仅扫描需要扫描的数据内容。  \n4）压缩：压缩数据然后存储，使得存储的密度更高，在有限的I/O速率下，在单位时间里读取更多的记录。  \n综上所述，我们可以注意到，所有这些方法都只是提高了单位时间内处理数据的能力，当大家都一致采用这些技术时，它们之间的区别将只停留在实现层面的代码细节上。最重要的是，这些技术都不会改变一个事实，那就是处理时间与数据量之间的正比例关系。当数据量翻倍时，MPP（在不扩容的前提下）需要翻倍的时间来完成计算；列式存储需要翻倍的存储空间；索引下符合条件的记录数据数也会翻倍；压缩事的数据大小也还是之间的两倍。因此查询速度也会随之就之前的两倍。当数据量成十倍地增长时，这些技术的查询速度就会成十倍地下降，最终变得不能接受。  \nApache Kylin的特色在于，在上述的底层技术之外，另辟蹊径地使用了独特的Cube预计算技术。预计算将数据按维度组合进行了聚合，将结果保存为物化视图。经过聚合，物化视图的规模就只由维度的基数来决定，而不再随着数据量的增长呈线性增长。以电商为例，如果业务扩张，交易量增长了10倍，只要交易数据的维度不变（供应商/商品数量不变），聚合后的物化视图初依旧是原先的大小，查询的速度也将保持不变。  \n与那些类似产品相比，这一导技术的区别使得Kylin从外在功能上呈现出了不同的特性，具体如下：  \n1）SQL接口：除了Druid以外，所有的产品都支持SQL或类SQL接口。巧合的是Druid也是除了Kylin以外，查询性能相对更好的一个。这点除了Druid有自己的存储引擎之外，可能还利益于其较为受限的查询能力。　　\n2）大数据支持：大数据产品的能力在亿级到十亿级数据量之间，再大的数据量将显著降低查询性能。而Kylin因为采用预计算技术，因此查询速度不受数据量的限制。  \n3）查询速度，不会随着数据量的增加而查询性能下降。  \n4）吞吐量：根据之前的实验数据，Kylin的单例吞吐量一般在每秒70个查询左右，并且可以线性扩展，而普通的产品因为所有计算都在查询时完成，所以需要调动集群的更多资源才能完成查询，通常极限在每秒20个查询左右，而且扩容成本较高，需要扩展整个集群。相对的，Kylin系统因为瓶颈不在整个集群，而在于Kylin服务器，因此只需要增加Kylin服务器就能成倍提高吞率，扩容成本低廉。\n\n###Druid\nDruid是什么？  \nDruid是一个分布式的支持实时分析的数据存储系统（Data Store）,是美国广告技术公司MetaMarkets于2011年创建，2012年开源的项目，Druid设计之初是为分析而生。官方网站是：http://druid.io\n\n\n###Pinot\nPinot是Linkin于2015年开源的一个分布式列式数据存储系统。\n\n\n###神秘的谷歌Dremel\nDremel是谷歌的“交互式”数据分析系统，支持上千台机器的集群部署，处理PB级别的数据，可以对网状数据的只读数据进行随机查询访问，帮助数据分析分提供Ad Hoc查询功能，进行尝试的数据探索（Exploration）。\n\n\n###Apache Drill\nApache Drill通过开源方式实现了谷歌Dremel。Drill架构的整个思想还是通过优化查询引擎，进行快速全表扫描，以快速返回结果，其高层架构示意图如下：\n\n\nApache Drill基于SQL的数据分析和商业智能引入了JSON文件模型，这使得用户能查询固定架构，支持各种格式和数据存储中的模式无关数据。该体系架构中的关系查询引擎和数据库构建是有先决条件的，即假设所有数据都有一个简单的静态架构。\n\nApache Drill的架构是独一无二的，它是唯一一个支持复杂和无模式数据的柱状行引擎，也是唯一一个能在查询执行期间进行的数据驱动查询。\n\n###Elasticsearch\nElasticsearch（ES）是Elastic公司推出一个基于Lucerne的分布式\n\n\n","source":"_posts/hadoop/数据分析软件分类.md","raw":"---\ntitle: 数据分析软件分类\ndate: 2017-04-16 23:43:49\ntags: [大数据,数据分析]\ncategories: [大数据,数据分析]\n---\n\n#数据分析软件分类  \n下面介绍一些适合大数据分析的存储数据库，或者面向大数据分析，适用于TB级以上的数据库存储和分析任务。分为如下几类介绍：  \n1.商业数据库  \n2.开源时序数据库  \n3.开源计算框架  \n4.开源SQL on hadoop  \n5.云端数据分析SaaS  \n\n##商业软件  \n商业数据库软件种类繁多，但是真正能支持TB级别以上的数据存储和分析并不多，下面介绍几个有特点、支持大数据的商用数据库。  \n\n###HP Vertica\nVertica公司成立于2005年，创立者为数据库巨擘Michael Stonebraker。2011成Vertica被惠普收购。Vertica是能够提供高效数据存储和快速查询数据存储数据库实时分析平台，还支持大规模并行 处理（MPP）。产品广泛应用于高端数据营销、互联网客户分析处理，数据达到PB级别。\nVertical特点如下：\n面向列的存储  \n灵活的压缩算法，根据数据的排序性和基数决定压缩算法。  \n高可用数据库和查询  \nMPP架构，分布式存储和任务负载，Shared nothing架构。\n支持标准SQL查询、ODBC/JDBC等..   \n支持Projection（数据投射）功能。\n\n\n###Oracle Exadata\nOracle Exadata是数据库发展史上一个人传奇，它是数据库软件和最新硬件的完美结合。它提供最快、最可靠的数据库平台，不仅支持常规的数据库应用，也支持联机分析处理（OLAP）和数据仓库（DW）的场景。  \nOracle Exadata采用了多种最新的硬件技术，例如40GB的InfiniBan网络\n\n\n###Teradata\nTeradata（天睿）公司是专注于大数据分析、数据仓库和整合营销管理解决方案的供应商。Teradata采用纯粹的Shared noting架构，支持MPP。对于多维度的查询更加灵活，专注于数据仓库的应用领域。  \n\n\n##时序数据库\n时序数据库用于记录过去时间的各个数据点的信息，典型的应用是服务器的各种性能指标，例如CPU、内存使用情况等 。目前时序数据库也广泛应用于各种传感器的数据收集分析工作中，这些数据的收集都有一个特点，就是对时间的依赖非常大，每天产生的数据量非常大，因此定入的量非常大，一般的关系型数据库无法满足这些场景。因此，时序数据库在设计上需要支持高吞吐、高效数据压缩，支持历史查询、分布式部署等。\n\n###1.OpenTSDB\nOpenTSDB是一个开源的时序数据库，支持存储千亿的数据点，并提供精确查询功能。它采用Java语言编写，通过基于HBaser存储实现横向扩展。\n\n\n###2.InfluxDB\nInfluxDB采用GoLang语言开发，也是一个开源应用，社区非常活跃。其技术特点包含：支持任意数量的列，支持方便、强大的查询语言，集成了数据采集、存储和可视化功能。\n\n##开源分布式计算平台\n一个是Hadoop，另一个是Spark，这里就不一一介绍了。\n\n##开源分析数据库\n###Kylin\nKylin是Apache开源的开源分布式分析引擎。 \n与Kylin一样致力于大数据查询问题的开源产品如Apache Drill、Apache Impala、Druid、Hive、Presto（Facebook）、SparkSQL等。  \n从底层技术角度来看，这些开源产品有很大的共性，一些底层技术几乎被所有的产品一致采用。  \n1）大规模并行处理：可以通过增加机器的方式来扩容处理速度，在相同的时间里处理更多的数据。  \n2）列式存储：通过按列存储提高单位时间里数据的I/O吞吐率，还能跳过不需要访问的列。  \n3）索引：利用索引配合查询条件，可以迅速跳过不符合条件的数据块，仅扫描需要扫描的数据内容。  \n4）压缩：压缩数据然后存储，使得存储的密度更高，在有限的I/O速率下，在单位时间里读取更多的记录。  \n综上所述，我们可以注意到，所有这些方法都只是提高了单位时间内处理数据的能力，当大家都一致采用这些技术时，它们之间的区别将只停留在实现层面的代码细节上。最重要的是，这些技术都不会改变一个事实，那就是处理时间与数据量之间的正比例关系。当数据量翻倍时，MPP（在不扩容的前提下）需要翻倍的时间来完成计算；列式存储需要翻倍的存储空间；索引下符合条件的记录数据数也会翻倍；压缩事的数据大小也还是之间的两倍。因此查询速度也会随之就之前的两倍。当数据量成十倍地增长时，这些技术的查询速度就会成十倍地下降，最终变得不能接受。  \nApache Kylin的特色在于，在上述的底层技术之外，另辟蹊径地使用了独特的Cube预计算技术。预计算将数据按维度组合进行了聚合，将结果保存为物化视图。经过聚合，物化视图的规模就只由维度的基数来决定，而不再随着数据量的增长呈线性增长。以电商为例，如果业务扩张，交易量增长了10倍，只要交易数据的维度不变（供应商/商品数量不变），聚合后的物化视图初依旧是原先的大小，查询的速度也将保持不变。  \n与那些类似产品相比，这一导技术的区别使得Kylin从外在功能上呈现出了不同的特性，具体如下：  \n1）SQL接口：除了Druid以外，所有的产品都支持SQL或类SQL接口。巧合的是Druid也是除了Kylin以外，查询性能相对更好的一个。这点除了Druid有自己的存储引擎之外，可能还利益于其较为受限的查询能力。　　\n2）大数据支持：大数据产品的能力在亿级到十亿级数据量之间，再大的数据量将显著降低查询性能。而Kylin因为采用预计算技术，因此查询速度不受数据量的限制。  \n3）查询速度，不会随着数据量的增加而查询性能下降。  \n4）吞吐量：根据之前的实验数据，Kylin的单例吞吐量一般在每秒70个查询左右，并且可以线性扩展，而普通的产品因为所有计算都在查询时完成，所以需要调动集群的更多资源才能完成查询，通常极限在每秒20个查询左右，而且扩容成本较高，需要扩展整个集群。相对的，Kylin系统因为瓶颈不在整个集群，而在于Kylin服务器，因此只需要增加Kylin服务器就能成倍提高吞率，扩容成本低廉。\n\n###Druid\nDruid是什么？  \nDruid是一个分布式的支持实时分析的数据存储系统（Data Store）,是美国广告技术公司MetaMarkets于2011年创建，2012年开源的项目，Druid设计之初是为分析而生。官方网站是：http://druid.io\n\n\n###Pinot\nPinot是Linkin于2015年开源的一个分布式列式数据存储系统。\n\n\n###神秘的谷歌Dremel\nDremel是谷歌的“交互式”数据分析系统，支持上千台机器的集群部署，处理PB级别的数据，可以对网状数据的只读数据进行随机查询访问，帮助数据分析分提供Ad Hoc查询功能，进行尝试的数据探索（Exploration）。\n\n\n###Apache Drill\nApache Drill通过开源方式实现了谷歌Dremel。Drill架构的整个思想还是通过优化查询引擎，进行快速全表扫描，以快速返回结果，其高层架构示意图如下：\n\n\nApache Drill基于SQL的数据分析和商业智能引入了JSON文件模型，这使得用户能查询固定架构，支持各种格式和数据存储中的模式无关数据。该体系架构中的关系查询引擎和数据库构建是有先决条件的，即假设所有数据都有一个简单的静态架构。\n\nApache Drill的架构是独一无二的，它是唯一一个支持复杂和无模式数据的柱状行引擎，也是唯一一个能在查询执行期间进行的数据驱动查询。\n\n###Elasticsearch\nElasticsearch（ES）是Elastic公司推出一个基于Lucerne的分布式\n\n\n","slug":"hadoop/数据分析软件分类","published":1,"updated":"2017-08-18T01:44:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bj8000ts77rmqr4oe1n","content":"<p>#数据分析软件分类<br>下面介绍一些适合大数据分析的存储数据库，或者面向大数据分析，适用于TB级以上的数据库存储和分析任务。分为如下几类介绍：<br>1.商业数据库<br>2.开源时序数据库<br>3.开源计算框架<br>4.开源SQL on hadoop<br>5.云端数据分析SaaS  </p>\n<p>##商业软件<br>商业数据库软件种类繁多，但是真正能支持TB级别以上的数据存储和分析并不多，下面介绍几个有特点、支持大数据的商用数据库。  </p>\n<p>###HP Vertica<br>Vertica公司成立于2005年，创立者为数据库巨擘Michael Stonebraker。2011成Vertica被惠普收购。Vertica是能够提供高效数据存储和快速查询数据存储数据库实时分析平台，还支持大规模并行 处理（MPP）。产品广泛应用于高端数据营销、互联网客户分析处理，数据达到PB级别。<br>Vertical特点如下：<br>面向列的存储<br>灵活的压缩算法，根据数据的排序性和基数决定压缩算法。<br>高可用数据库和查询<br>MPP架构，分布式存储和任务负载，Shared nothing架构。<br>支持标准SQL查询、ODBC/JDBC等..<br>支持Projection（数据投射）功能。</p>\n<p>###Oracle Exadata<br>Oracle Exadata是数据库发展史上一个人传奇，它是数据库软件和最新硬件的完美结合。它提供最快、最可靠的数据库平台，不仅支持常规的数据库应用，也支持联机分析处理（OLAP）和数据仓库（DW）的场景。<br>Oracle Exadata采用了多种最新的硬件技术，例如40GB的InfiniBan网络</p>\n<p>###Teradata<br>Teradata（天睿）公司是专注于大数据分析、数据仓库和整合营销管理解决方案的供应商。Teradata采用纯粹的Shared noting架构，支持MPP。对于多维度的查询更加灵活，专注于数据仓库的应用领域。  </p>\n<p>##时序数据库<br>时序数据库用于记录过去时间的各个数据点的信息，典型的应用是服务器的各种性能指标，例如CPU、内存使用情况等 。目前时序数据库也广泛应用于各种传感器的数据收集分析工作中，这些数据的收集都有一个特点，就是对时间的依赖非常大，每天产生的数据量非常大，因此定入的量非常大，一般的关系型数据库无法满足这些场景。因此，时序数据库在设计上需要支持高吞吐、高效数据压缩，支持历史查询、分布式部署等。</p>\n<p>###1.OpenTSDB<br>OpenTSDB是一个开源的时序数据库，支持存储千亿的数据点，并提供精确查询功能。它采用Java语言编写，通过基于HBaser存储实现横向扩展。</p>\n<p>###2.InfluxDB<br>InfluxDB采用GoLang语言开发，也是一个开源应用，社区非常活跃。其技术特点包含：支持任意数量的列，支持方便、强大的查询语言，集成了数据采集、存储和可视化功能。</p>\n<p>##开源分布式计算平台<br>一个是Hadoop，另一个是Spark，这里就不一一介绍了。</p>\n<p>##开源分析数据库</p>\n<p>###Kylin<br>Kylin是Apache开源的开源分布式分析引擎。<br>与Kylin一样致力于大数据查询问题的开源产品如Apache Drill、Apache Impala、Druid、Hive、Presto（Facebook）、SparkSQL等。<br>从底层技术角度来看，这些开源产品有很大的共性，一些底层技术几乎被所有的产品一致采用。<br>1）大规模并行处理：可以通过增加机器的方式来扩容处理速度，在相同的时间里处理更多的数据。<br>2）列式存储：通过按列存储提高单位时间里数据的I/O吞吐率，还能跳过不需要访问的列。<br>3）索引：利用索引配合查询条件，可以迅速跳过不符合条件的数据块，仅扫描需要扫描的数据内容。<br>4）压缩：压缩数据然后存储，使得存储的密度更高，在有限的I/O速率下，在单位时间里读取更多的记录。<br>综上所述，我们可以注意到，所有这些方法都只是提高了单位时间内处理数据的能力，当大家都一致采用这些技术时，它们之间的区别将只停留在实现层面的代码细节上。最重要的是，这些技术都不会改变一个事实，那就是处理时间与数据量之间的正比例关系。当数据量翻倍时，MPP（在不扩容的前提下）需要翻倍的时间来完成计算；列式存储需要翻倍的存储空间；索引下符合条件的记录数据数也会翻倍；压缩事的数据大小也还是之间的两倍。因此查询速度也会随之就之前的两倍。当数据量成十倍地增长时，这些技术的查询速度就会成十倍地下降，最终变得不能接受。<br>Apache Kylin的特色在于，在上述的底层技术之外，另辟蹊径地使用了独特的Cube预计算技术。预计算将数据按维度组合进行了聚合，将结果保存为物化视图。经过聚合，物化视图的规模就只由维度的基数来决定，而不再随着数据量的增长呈线性增长。以电商为例，如果业务扩张，交易量增长了10倍，只要交易数据的维度不变（供应商/商品数量不变），聚合后的物化视图初依旧是原先的大小，查询的速度也将保持不变。<br>与那些类似产品相比，这一导技术的区别使得Kylin从外在功能上呈现出了不同的特性，具体如下：<br>1）SQL接口：除了Druid以外，所有的产品都支持SQL或类SQL接口。巧合的是Druid也是除了Kylin以外，查询性能相对更好的一个。这点除了Druid有自己的存储引擎之外，可能还利益于其较为受限的查询能力。　　<br>2）大数据支持：大数据产品的能力在亿级到十亿级数据量之间，再大的数据量将显著降低查询性能。而Kylin因为采用预计算技术，因此查询速度不受数据量的限制。<br>3）查询速度，不会随着数据量的增加而查询性能下降。<br>4）吞吐量：根据之前的实验数据，Kylin的单例吞吐量一般在每秒70个查询左右，并且可以线性扩展，而普通的产品因为所有计算都在查询时完成，所以需要调动集群的更多资源才能完成查询，通常极限在每秒20个查询左右，而且扩容成本较高，需要扩展整个集群。相对的，Kylin系统因为瓶颈不在整个集群，而在于Kylin服务器，因此只需要增加Kylin服务器就能成倍提高吞率，扩容成本低廉。</p>\n<p>###Druid<br>Druid是什么？<br>Druid是一个分布式的支持实时分析的数据存储系统（Data Store）,是美国广告技术公司MetaMarkets于2011年创建，2012年开源的项目，Druid设计之初是为分析而生。官方网站是：<a href=\"http://druid.io\" target=\"_blank\" rel=\"noopener\">http://druid.io</a></p>\n<p>###Pinot<br>Pinot是Linkin于2015年开源的一个分布式列式数据存储系统。</p>\n<p>###神秘的谷歌Dremel<br>Dremel是谷歌的“交互式”数据分析系统，支持上千台机器的集群部署，处理PB级别的数据，可以对网状数据的只读数据进行随机查询访问，帮助数据分析分提供Ad Hoc查询功能，进行尝试的数据探索（Exploration）。</p>\n<p>###Apache Drill<br>Apache Drill通过开源方式实现了谷歌Dremel。Drill架构的整个思想还是通过优化查询引擎，进行快速全表扫描，以快速返回结果，其高层架构示意图如下：</p>\n<p>Apache Drill基于SQL的数据分析和商业智能引入了JSON文件模型，这使得用户能查询固定架构，支持各种格式和数据存储中的模式无关数据。该体系架构中的关系查询引擎和数据库构建是有先决条件的，即假设所有数据都有一个简单的静态架构。</p>\n<p>Apache Drill的架构是独一无二的，它是唯一一个支持复杂和无模式数据的柱状行引擎，也是唯一一个能在查询执行期间进行的数据驱动查询。</p>\n<p>###Elasticsearch<br>Elasticsearch（ES）是Elastic公司推出一个基于Lucerne的分布式</p>\n","site":{"data":{}},"excerpt":"","more":"<p>#数据分析软件分类<br>下面介绍一些适合大数据分析的存储数据库，或者面向大数据分析，适用于TB级以上的数据库存储和分析任务。分为如下几类介绍：<br>1.商业数据库<br>2.开源时序数据库<br>3.开源计算框架<br>4.开源SQL on hadoop<br>5.云端数据分析SaaS  </p>\n<p>##商业软件<br>商业数据库软件种类繁多，但是真正能支持TB级别以上的数据存储和分析并不多，下面介绍几个有特点、支持大数据的商用数据库。  </p>\n<p>###HP Vertica<br>Vertica公司成立于2005年，创立者为数据库巨擘Michael Stonebraker。2011成Vertica被惠普收购。Vertica是能够提供高效数据存储和快速查询数据存储数据库实时分析平台，还支持大规模并行 处理（MPP）。产品广泛应用于高端数据营销、互联网客户分析处理，数据达到PB级别。<br>Vertical特点如下：<br>面向列的存储<br>灵活的压缩算法，根据数据的排序性和基数决定压缩算法。<br>高可用数据库和查询<br>MPP架构，分布式存储和任务负载，Shared nothing架构。<br>支持标准SQL查询、ODBC/JDBC等..<br>支持Projection（数据投射）功能。</p>\n<p>###Oracle Exadata<br>Oracle Exadata是数据库发展史上一个人传奇，它是数据库软件和最新硬件的完美结合。它提供最快、最可靠的数据库平台，不仅支持常规的数据库应用，也支持联机分析处理（OLAP）和数据仓库（DW）的场景。<br>Oracle Exadata采用了多种最新的硬件技术，例如40GB的InfiniBan网络</p>\n<p>###Teradata<br>Teradata（天睿）公司是专注于大数据分析、数据仓库和整合营销管理解决方案的供应商。Teradata采用纯粹的Shared noting架构，支持MPP。对于多维度的查询更加灵活，专注于数据仓库的应用领域。  </p>\n<p>##时序数据库<br>时序数据库用于记录过去时间的各个数据点的信息，典型的应用是服务器的各种性能指标，例如CPU、内存使用情况等 。目前时序数据库也广泛应用于各种传感器的数据收集分析工作中，这些数据的收集都有一个特点，就是对时间的依赖非常大，每天产生的数据量非常大，因此定入的量非常大，一般的关系型数据库无法满足这些场景。因此，时序数据库在设计上需要支持高吞吐、高效数据压缩，支持历史查询、分布式部署等。</p>\n<p>###1.OpenTSDB<br>OpenTSDB是一个开源的时序数据库，支持存储千亿的数据点，并提供精确查询功能。它采用Java语言编写，通过基于HBaser存储实现横向扩展。</p>\n<p>###2.InfluxDB<br>InfluxDB采用GoLang语言开发，也是一个开源应用，社区非常活跃。其技术特点包含：支持任意数量的列，支持方便、强大的查询语言，集成了数据采集、存储和可视化功能。</p>\n<p>##开源分布式计算平台<br>一个是Hadoop，另一个是Spark，这里就不一一介绍了。</p>\n<p>##开源分析数据库</p>\n<p>###Kylin<br>Kylin是Apache开源的开源分布式分析引擎。<br>与Kylin一样致力于大数据查询问题的开源产品如Apache Drill、Apache Impala、Druid、Hive、Presto（Facebook）、SparkSQL等。<br>从底层技术角度来看，这些开源产品有很大的共性，一些底层技术几乎被所有的产品一致采用。<br>1）大规模并行处理：可以通过增加机器的方式来扩容处理速度，在相同的时间里处理更多的数据。<br>2）列式存储：通过按列存储提高单位时间里数据的I/O吞吐率，还能跳过不需要访问的列。<br>3）索引：利用索引配合查询条件，可以迅速跳过不符合条件的数据块，仅扫描需要扫描的数据内容。<br>4）压缩：压缩数据然后存储，使得存储的密度更高，在有限的I/O速率下，在单位时间里读取更多的记录。<br>综上所述，我们可以注意到，所有这些方法都只是提高了单位时间内处理数据的能力，当大家都一致采用这些技术时，它们之间的区别将只停留在实现层面的代码细节上。最重要的是，这些技术都不会改变一个事实，那就是处理时间与数据量之间的正比例关系。当数据量翻倍时，MPP（在不扩容的前提下）需要翻倍的时间来完成计算；列式存储需要翻倍的存储空间；索引下符合条件的记录数据数也会翻倍；压缩事的数据大小也还是之间的两倍。因此查询速度也会随之就之前的两倍。当数据量成十倍地增长时，这些技术的查询速度就会成十倍地下降，最终变得不能接受。<br>Apache Kylin的特色在于，在上述的底层技术之外，另辟蹊径地使用了独特的Cube预计算技术。预计算将数据按维度组合进行了聚合，将结果保存为物化视图。经过聚合，物化视图的规模就只由维度的基数来决定，而不再随着数据量的增长呈线性增长。以电商为例，如果业务扩张，交易量增长了10倍，只要交易数据的维度不变（供应商/商品数量不变），聚合后的物化视图初依旧是原先的大小，查询的速度也将保持不变。<br>与那些类似产品相比，这一导技术的区别使得Kylin从外在功能上呈现出了不同的特性，具体如下：<br>1）SQL接口：除了Druid以外，所有的产品都支持SQL或类SQL接口。巧合的是Druid也是除了Kylin以外，查询性能相对更好的一个。这点除了Druid有自己的存储引擎之外，可能还利益于其较为受限的查询能力。　　<br>2）大数据支持：大数据产品的能力在亿级到十亿级数据量之间，再大的数据量将显著降低查询性能。而Kylin因为采用预计算技术，因此查询速度不受数据量的限制。<br>3）查询速度，不会随着数据量的增加而查询性能下降。<br>4）吞吐量：根据之前的实验数据，Kylin的单例吞吐量一般在每秒70个查询左右，并且可以线性扩展，而普通的产品因为所有计算都在查询时完成，所以需要调动集群的更多资源才能完成查询，通常极限在每秒20个查询左右，而且扩容成本较高，需要扩展整个集群。相对的，Kylin系统因为瓶颈不在整个集群，而在于Kylin服务器，因此只需要增加Kylin服务器就能成倍提高吞率，扩容成本低廉。</p>\n<p>###Druid<br>Druid是什么？<br>Druid是一个分布式的支持实时分析的数据存储系统（Data Store）,是美国广告技术公司MetaMarkets于2011年创建，2012年开源的项目，Druid设计之初是为分析而生。官方网站是：<a href=\"http://druid.io\" target=\"_blank\" rel=\"noopener\">http://druid.io</a></p>\n<p>###Pinot<br>Pinot是Linkin于2015年开源的一个分布式列式数据存储系统。</p>\n<p>###神秘的谷歌Dremel<br>Dremel是谷歌的“交互式”数据分析系统，支持上千台机器的集群部署，处理PB级别的数据，可以对网状数据的只读数据进行随机查询访问，帮助数据分析分提供Ad Hoc查询功能，进行尝试的数据探索（Exploration）。</p>\n<p>###Apache Drill<br>Apache Drill通过开源方式实现了谷歌Dremel。Drill架构的整个思想还是通过优化查询引擎，进行快速全表扫描，以快速返回结果，其高层架构示意图如下：</p>\n<p>Apache Drill基于SQL的数据分析和商业智能引入了JSON文件模型，这使得用户能查询固定架构，支持各种格式和数据存储中的模式无关数据。该体系架构中的关系查询引擎和数据库构建是有先决条件的，即假设所有数据都有一个简单的静态架构。</p>\n<p>Apache Drill的架构是独一无二的，它是唯一一个支持复杂和无模式数据的柱状行引擎，也是唯一一个能在查询执行期间进行的数据驱动查询。</p>\n<p>###Elasticsearch<br>Elasticsearch（ES）是Elastic公司推出一个基于Lucerne的分布式</p>\n"},{"title":"JDK源码分析之集合框架HashMap","date":"2017-04-18T02:00:00.000Z","_content":"#JDK源码分析之集合框架HashMap\n","source":"_posts/java/JDK源码分析之集合框架HashMap.md","raw":"---\ntitle: JDK源码分析之集合框架HashMap\ndate: 2017-04-18 10:00:00\ntags: [java,jdk源码]\ncategories: [java,jdk源码]\n---\n#JDK源码分析之集合框架HashMap\n","slug":"java/JDK源码分析之集合框架HashMap","published":1,"updated":"2017-08-18T01:44:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bj9000us77r8xw2tgy0","content":"<p>#JDK源码分析之集合框架HashMap</p>\n","site":{"data":{}},"excerpt":"","more":"<p>#JDK源码分析之集合框架HashMap</p>\n"},{"title":"Java基础之转型","date":"2016-05-20T06:43:49.000Z","_content":"上转型对象\n父类的声明指向子类对象（最无争议的说法）\n父类 对象名 = new 子类构造方法();\n(1)该对象可以调用子类重写父类的方法(本质)\n(2)该对象不能调用子类独有的方法\n(3)上转型对象可以强制转化成子类对象 (进而访问子类独有的方法)\n父类 :     Person\n子类 :Teacher    Student\nPerson person = new Teacher();\nStudnet student= (Student)person;\n在企业开发的时候,当别人给你传递一个对象的时候,如果对象的类型,不是很确定,要先测试一下，instanceof :java中的一个关键字,专门用来进行对象 类型的测试,跟强制类型转化,经常结合使用\n    if(person instanceof Student2){\n      Student2 p2 =(Student2) person;\n","source":"_posts/java/Java基础之转型.md","raw":"---\ntitle: Java基础之转型\ndate: 2016-05-20 14:43:49\ntags: [java,java基础]\ncategories: [java,java基础]\n---\n上转型对象\n父类的声明指向子类对象（最无争议的说法）\n父类 对象名 = new 子类构造方法();\n(1)该对象可以调用子类重写父类的方法(本质)\n(2)该对象不能调用子类独有的方法\n(3)上转型对象可以强制转化成子类对象 (进而访问子类独有的方法)\n父类 :     Person\n子类 :Teacher    Student\nPerson person = new Teacher();\nStudnet student= (Student)person;\n在企业开发的时候,当别人给你传递一个对象的时候,如果对象的类型,不是很确定,要先测试一下，instanceof :java中的一个关键字,专门用来进行对象 类型的测试,跟强制类型转化,经常结合使用\n    if(person instanceof Student2){\n      Student2 p2 =(Student2) person;\n","slug":"java/Java基础之转型","published":1,"updated":"2017-08-18T01:44:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bja000xs77r286eru1r","content":"<p>上转型对象<br>父类的声明指向子类对象（最无争议的说法）<br>父类 对象名 = new 子类构造方法();<br>(1)该对象可以调用子类重写父类的方法(本质)<br>(2)该对象不能调用子类独有的方法<br>(3)上转型对象可以强制转化成子类对象 (进而访问子类独有的方法)<br>父类 :     Person<br>子类 :Teacher    Student<br>Person person = new Teacher();<br>Studnet student= (Student)person;<br>在企业开发的时候,当别人给你传递一个对象的时候,如果对象的类型,不是很确定,要先测试一下，instanceof :java中的一个关键字,专门用来进行对象 类型的测试,跟强制类型转化,经常结合使用<br>    if(person instanceof Student2){<br>      Student2 p2 =(Student2) person;</p>\n","site":{"data":{}},"excerpt":"","more":"<p>上转型对象<br>父类的声明指向子类对象（最无争议的说法）<br>父类 对象名 = new 子类构造方法();<br>(1)该对象可以调用子类重写父类的方法(本质)<br>(2)该对象不能调用子类独有的方法<br>(3)上转型对象可以强制转化成子类对象 (进而访问子类独有的方法)<br>父类 :     Person<br>子类 :Teacher    Student<br>Person person = new Teacher();<br>Studnet student= (Student)person;<br>在企业开发的时候,当别人给你传递一个对象的时候,如果对象的类型,不是很确定,要先测试一下，instanceof :java中的一个关键字,专门用来进行对象 类型的测试,跟强制类型转化,经常结合使用<br>    if(person instanceof Student2){<br>      Student2 p2 =(Student2) person;</p>\n"},{"title":"java中Object转String","date":"2016-05-20T06:41:37.000Z","_content":"Object转为String的几种形式\n 在java项目的实际开发和应用中，常常需要用到将对象转为String这一基本功能。本文将对常用的转换方法进行一个总结。常用的方法有Object.toString()，(String)要转换的对象，String.valueOf(Object)等。下面对这些方法一一进行分析。\n方法1：采用 Object.toString()方法\n请看下面的例子：\nObject object = getObject();\nSystem.out.println(object.toString());\n在这种使用方法中，因为java.lang.Object类里已有public方法.toString()，所以对任何严格意义上的java对象都可以调用此方法。但在使用时要注意，必须保证object不是null值，否则将抛出NullPointerException异常。采用这种方法时，通常派生类会覆盖Object里的toString()方法。\n方法2：采用类型转换(String)object方法\n这是标准的类型转换，将object转成String类型的值。使用这种方法时，需要注意的是类型必须能转成String类型。因此最好用instanceof做个类型检查，以判断是否可以转换。否则容易抛出CalssCastException异常。此外，需特别小心的是因定义为Object 类型的对象在转成String时语法检查并不会报错，这将可能导致潜在的错误存在。这时要格外小心。如：\nObject obj = new Integer(100);\nString　strVal = (String)obj;\n在运行时将会出错，因为将Integer类型强制转换为String类型，无法通过。但是，\nInteger obj = new Integer(100);\nString　strVal = (String)obj;\n如是格式代码，将会报语法错误。\n此外，因null值可以强制转换为任何java类类型，(String)null也是合法的。\n方法3：采用String.valueOf(Object)\nString.valueOf(Object)的基础是Object.toString()。但它与Object.toString()又有所不同。在前面方法1的分析中提到，使用第一种时需保证不为null。但采用第三种方法时，将不用担心object是否为null值这一问题。为了便于说明问题，我们来分析一下相关的源代码。Jdk里String.valueOf(Object)源码如下：\n/**\n* Returns the string representation of the Object argument.\n*\n* @param　 obj　 an Object.\n* @return　if the argument is null, then a string equal to\n*　　　　　\"null\"; otherwise, the value of\n*　　　　　obj.toString() is returned.\n* @see　　 java.lang.Object.toString()\n*/\npublic static String valueOf(Object obj) {\nreturn (obj == null) ? \"null\" : obj.toString();\n}\n从上面的源码可以很清晰的看出null值不用担心的理由。但是，这也恰恰给了我们隐患。我们应当注意到，当object为null时，String.valueOf(object)的值是字符串\"null\"，而不是null!在使用过程中切记要注意。试想一下，如果我们用 \n  if(String.valueOf(object)==null)\n{\n  System.out.println(“传入的值是null!\");\n}\n这样的语句将可能会发生什么问题。再想一下，向控制台输出时，在视觉上如下语句在执行的结果上有什么不同：\nSystem.out.println(String.valueOf(null));\nSystem.out.println(null);\n我们看到的输出将是一模一样的东西：null，但它们意义相同吗？\n判断一个字符串为空\n s为一个字符串，判断它为空的方法：\nif   (null==s ||\"\".equals(s))   {  \n......\n  }   \n注意：这里的null==s和\"\".equals(s)不要写成s==null和s.equals(s)，因为\"\"这个值是已经确定的，预知的，而s是未知的，所以用得不小心的时候s.equals(\"\")就会出现nullpoint异常。在这里虽然不会,因为前面有if(null==s),但是习惯跟在那里使用没有关系的。不一定的equals方法，包括其它很多处理，如果用确定的值处理问题会比未确定的处理少很多bug。\n\n来自 <http://www.cnblogs.com/sp2012/archive/2012/02/21/2465693.html> \n","source":"_posts/java/java中Object转String.md","raw":"---\ntitle: java中Object转String\ndate: 2016-05-20 14:41:37\ntags: [java,java基础]\ncategories: [java,java基础]\n---\nObject转为String的几种形式\n 在java项目的实际开发和应用中，常常需要用到将对象转为String这一基本功能。本文将对常用的转换方法进行一个总结。常用的方法有Object.toString()，(String)要转换的对象，String.valueOf(Object)等。下面对这些方法一一进行分析。\n方法1：采用 Object.toString()方法\n请看下面的例子：\nObject object = getObject();\nSystem.out.println(object.toString());\n在这种使用方法中，因为java.lang.Object类里已有public方法.toString()，所以对任何严格意义上的java对象都可以调用此方法。但在使用时要注意，必须保证object不是null值，否则将抛出NullPointerException异常。采用这种方法时，通常派生类会覆盖Object里的toString()方法。\n方法2：采用类型转换(String)object方法\n这是标准的类型转换，将object转成String类型的值。使用这种方法时，需要注意的是类型必须能转成String类型。因此最好用instanceof做个类型检查，以判断是否可以转换。否则容易抛出CalssCastException异常。此外，需特别小心的是因定义为Object 类型的对象在转成String时语法检查并不会报错，这将可能导致潜在的错误存在。这时要格外小心。如：\nObject obj = new Integer(100);\nString　strVal = (String)obj;\n在运行时将会出错，因为将Integer类型强制转换为String类型，无法通过。但是，\nInteger obj = new Integer(100);\nString　strVal = (String)obj;\n如是格式代码，将会报语法错误。\n此外，因null值可以强制转换为任何java类类型，(String)null也是合法的。\n方法3：采用String.valueOf(Object)\nString.valueOf(Object)的基础是Object.toString()。但它与Object.toString()又有所不同。在前面方法1的分析中提到，使用第一种时需保证不为null。但采用第三种方法时，将不用担心object是否为null值这一问题。为了便于说明问题，我们来分析一下相关的源代码。Jdk里String.valueOf(Object)源码如下：\n/**\n* Returns the string representation of the Object argument.\n*\n* @param　 obj　 an Object.\n* @return　if the argument is null, then a string equal to\n*　　　　　\"null\"; otherwise, the value of\n*　　　　　obj.toString() is returned.\n* @see　　 java.lang.Object.toString()\n*/\npublic static String valueOf(Object obj) {\nreturn (obj == null) ? \"null\" : obj.toString();\n}\n从上面的源码可以很清晰的看出null值不用担心的理由。但是，这也恰恰给了我们隐患。我们应当注意到，当object为null时，String.valueOf(object)的值是字符串\"null\"，而不是null!在使用过程中切记要注意。试想一下，如果我们用 \n  if(String.valueOf(object)==null)\n{\n  System.out.println(“传入的值是null!\");\n}\n这样的语句将可能会发生什么问题。再想一下，向控制台输出时，在视觉上如下语句在执行的结果上有什么不同：\nSystem.out.println(String.valueOf(null));\nSystem.out.println(null);\n我们看到的输出将是一模一样的东西：null，但它们意义相同吗？\n判断一个字符串为空\n s为一个字符串，判断它为空的方法：\nif   (null==s ||\"\".equals(s))   {  \n......\n  }   \n注意：这里的null==s和\"\".equals(s)不要写成s==null和s.equals(s)，因为\"\"这个值是已经确定的，预知的，而s是未知的，所以用得不小心的时候s.equals(\"\")就会出现nullpoint异常。在这里虽然不会,因为前面有if(null==s),但是习惯跟在那里使用没有关系的。不一定的equals方法，包括其它很多处理，如果用确定的值处理问题会比未确定的处理少很多bug。\n\n来自 <http://www.cnblogs.com/sp2012/archive/2012/02/21/2465693.html> \n","slug":"java/java中Object转String","published":1,"updated":"2017-08-18T01:44:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bjb000zs77rfz9rcp0c","content":"<p>Object转为String的几种形式<br> 在java项目的实际开发和应用中，常常需要用到将对象转为String这一基本功能。本文将对常用的转换方法进行一个总结。常用的方法有Object.toString()，(String)要转换的对象，String.valueOf(Object)等。下面对这些方法一一进行分析。<br>方法1：采用 Object.toString()方法<br>请看下面的例子：<br>Object object = getObject();<br>System.out.println(object.toString());<br>在这种使用方法中，因为java.lang.Object类里已有public方法.toString()，所以对任何严格意义上的java对象都可以调用此方法。但在使用时要注意，必须保证object不是null值，否则将抛出NullPointerException异常。采用这种方法时，通常派生类会覆盖Object里的toString()方法。<br>方法2：采用类型转换(String)object方法<br>这是标准的类型转换，将object转成String类型的值。使用这种方法时，需要注意的是类型必须能转成String类型。因此最好用instanceof做个类型检查，以判断是否可以转换。否则容易抛出CalssCastException异常。此外，需特别小心的是因定义为Object 类型的对象在转成String时语法检查并不会报错，这将可能导致潜在的错误存在。这时要格外小心。如：<br>Object obj = new Integer(100);<br>String　strVal = (String)obj;<br>在运行时将会出错，因为将Integer类型强制转换为String类型，无法通过。但是，<br>Integer obj = new Integer(100);<br>String　strVal = (String)obj;<br>如是格式代码，将会报语法错误。<br>此外，因null值可以强制转换为任何java类类型，(String)null也是合法的。<br>方法3：采用String.valueOf(Object)<br>String.valueOf(Object)的基础是Object.toString()。但它与Object.toString()又有所不同。在前面方法1的分析中提到，使用第一种时需保证不为null。但采用第三种方法时，将不用担心object是否为null值这一问题。为了便于说明问题，我们来分析一下相关的源代码。Jdk里String.valueOf(Object)源码如下：<br>/**</p>\n<ul>\n<li>Returns the string representation of the Object argument.<br>*</li>\n<li>@param　 obj　 an Object.</li>\n<li>@return　if the argument is null, then a string equal to<br><em>　　　　　“null”; otherwise, the value of\n</em>　　　　　obj.toString() is returned.</li>\n<li>@see　　 java.lang.Object.toString()<br>*/<br>public static String valueOf(Object obj) {<br>return (obj == null) ? “null” : obj.toString();<br>}<br>从上面的源码可以很清晰的看出null值不用担心的理由。但是，这也恰恰给了我们隐患。我们应当注意到，当object为null时，String.valueOf(object)的值是字符串”null”，而不是null!在使用过程中切记要注意。试想一下，如果我们用<br>if(String.valueOf(object)==null)<br>{<br>System.out.println(“传入的值是null!”);<br>}<br>这样的语句将可能会发生什么问题。再想一下，向控制台输出时，在视觉上如下语句在执行的结果上有什么不同：<br>System.out.println(String.valueOf(null));<br>System.out.println(null);<br>我们看到的输出将是一模一样的东西：null，但它们意义相同吗？<br>判断一个字符串为空<br>s为一个字符串，判断它为空的方法：<br>if   (null==s ||””.equals(s))   {<br>……<br>}<br>注意：这里的null==s和””.equals(s)不要写成s==null和s.equals(s)，因为””这个值是已经确定的，预知的，而s是未知的，所以用得不小心的时候s.equals(“”)就会出现nullpoint异常。在这里虽然不会,因为前面有if(null==s),但是习惯跟在那里使用没有关系的。不一定的equals方法，包括其它很多处理，如果用确定的值处理问题会比未确定的处理少很多bug。</li>\n</ul>\n<p>来自 <a href=\"http://www.cnblogs.com/sp2012/archive/2012/02/21/2465693.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/sp2012/archive/2012/02/21/2465693.html</a> </p>\n","site":{"data":{}},"excerpt":"","more":"<p>Object转为String的几种形式<br> 在java项目的实际开发和应用中，常常需要用到将对象转为String这一基本功能。本文将对常用的转换方法进行一个总结。常用的方法有Object.toString()，(String)要转换的对象，String.valueOf(Object)等。下面对这些方法一一进行分析。<br>方法1：采用 Object.toString()方法<br>请看下面的例子：<br>Object object = getObject();<br>System.out.println(object.toString());<br>在这种使用方法中，因为java.lang.Object类里已有public方法.toString()，所以对任何严格意义上的java对象都可以调用此方法。但在使用时要注意，必须保证object不是null值，否则将抛出NullPointerException异常。采用这种方法时，通常派生类会覆盖Object里的toString()方法。<br>方法2：采用类型转换(String)object方法<br>这是标准的类型转换，将object转成String类型的值。使用这种方法时，需要注意的是类型必须能转成String类型。因此最好用instanceof做个类型检查，以判断是否可以转换。否则容易抛出CalssCastException异常。此外，需特别小心的是因定义为Object 类型的对象在转成String时语法检查并不会报错，这将可能导致潜在的错误存在。这时要格外小心。如：<br>Object obj = new Integer(100);<br>String　strVal = (String)obj;<br>在运行时将会出错，因为将Integer类型强制转换为String类型，无法通过。但是，<br>Integer obj = new Integer(100);<br>String　strVal = (String)obj;<br>如是格式代码，将会报语法错误。<br>此外，因null值可以强制转换为任何java类类型，(String)null也是合法的。<br>方法3：采用String.valueOf(Object)<br>String.valueOf(Object)的基础是Object.toString()。但它与Object.toString()又有所不同。在前面方法1的分析中提到，使用第一种时需保证不为null。但采用第三种方法时，将不用担心object是否为null值这一问题。为了便于说明问题，我们来分析一下相关的源代码。Jdk里String.valueOf(Object)源码如下：<br>/**</p>\n<ul>\n<li>Returns the string representation of the Object argument.<br>*</li>\n<li>@param　 obj　 an Object.</li>\n<li>@return　if the argument is null, then a string equal to<br><em>　　　　　“null”; otherwise, the value of\n</em>　　　　　obj.toString() is returned.</li>\n<li>@see　　 java.lang.Object.toString()<br>*/<br>public static String valueOf(Object obj) {<br>return (obj == null) ? “null” : obj.toString();<br>}<br>从上面的源码可以很清晰的看出null值不用担心的理由。但是，这也恰恰给了我们隐患。我们应当注意到，当object为null时，String.valueOf(object)的值是字符串”null”，而不是null!在使用过程中切记要注意。试想一下，如果我们用<br>if(String.valueOf(object)==null)<br>{<br>System.out.println(“传入的值是null!”);<br>}<br>这样的语句将可能会发生什么问题。再想一下，向控制台输出时，在视觉上如下语句在执行的结果上有什么不同：<br>System.out.println(String.valueOf(null));<br>System.out.println(null);<br>我们看到的输出将是一模一样的东西：null，但它们意义相同吗？<br>判断一个字符串为空<br>s为一个字符串，判断它为空的方法：<br>if   (null==s ||””.equals(s))   {<br>……<br>}<br>注意：这里的null==s和””.equals(s)不要写成s==null和s.equals(s)，因为””这个值是已经确定的，预知的，而s是未知的，所以用得不小心的时候s.equals(“”)就会出现nullpoint异常。在这里虽然不会,因为前面有if(null==s),但是习惯跟在那里使用没有关系的。不一定的equals方法，包括其它很多处理，如果用确定的值处理问题会比未确定的处理少很多bug。</li>\n</ul>\n<p>来自 <a href=\"http://www.cnblogs.com/sp2012/archive/2012/02/21/2465693.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/sp2012/archive/2012/02/21/2465693.html</a> </p>\n"},{"title":"jdk环境变量配置","date":"2017-04-18T08:43:49.000Z","_content":"# jdk环境变量配置 \n\njdk环境变量配置 \n进行java开发，首先要安装jdk，安装了jdk后还要进行环境变量配置：\n1、下载jdk（http://java.sun.com/javase/downloads/index.jsp），我下载的版本是：jdk-6u14-windows-i586.exe\n2、安装jdk-6u14-windows-i586.exe\n3、配置环境变量：右击“我的电脑”-->\"高级\"-->\"环境变量\"\n1）在系统变量里新建JAVA_HOME变量，变量值为：C:\\Program Files\\Java\\jdk1.6.0_14（根据自己的安装路径填写）\n2）新建classpath变量，变量值为：.;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tools.jar\n3）在path变量（已存在不用新建）添加变量值：%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin（注意变量值之间用“;”隔开）\n4、“开始”-->“运行”-->输入“javac”-->\"Enter\"，如果能正常打印用法说明配置成功！\n补充环境变量的解析:\nJAVA_HOME:jdk的安装路径\nclasspath:java加载类路径，只有类在classpath中java命令才能识别，在路径前加了个\".\"表示当前路径。\npath：系统在任何路径下都可以识别java,javac命令。\n\n\n\n","source":"_posts/java/jdk环境变量配置.md","raw":"---\ntitle: jdk环境变量配置 \ndate: 2017-04-18 16:43:49\ntags: [java]\ncategories: [java]\n---\n# jdk环境变量配置 \n\njdk环境变量配置 \n进行java开发，首先要安装jdk，安装了jdk后还要进行环境变量配置：\n1、下载jdk（http://java.sun.com/javase/downloads/index.jsp），我下载的版本是：jdk-6u14-windows-i586.exe\n2、安装jdk-6u14-windows-i586.exe\n3、配置环境变量：右击“我的电脑”-->\"高级\"-->\"环境变量\"\n1）在系统变量里新建JAVA_HOME变量，变量值为：C:\\Program Files\\Java\\jdk1.6.0_14（根据自己的安装路径填写）\n2）新建classpath变量，变量值为：.;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tools.jar\n3）在path变量（已存在不用新建）添加变量值：%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin（注意变量值之间用“;”隔开）\n4、“开始”-->“运行”-->输入“javac”-->\"Enter\"，如果能正常打印用法说明配置成功！\n补充环境变量的解析:\nJAVA_HOME:jdk的安装路径\nclasspath:java加载类路径，只有类在classpath中java命令才能识别，在路径前加了个\".\"表示当前路径。\npath：系统在任何路径下都可以识别java,javac命令。\n\n\n\n","slug":"java/jdk环境变量配置","published":1,"updated":"2017-08-18T01:44:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bje0013s77rvqpvqltz","content":"<h1 id=\"jdk环境变量配置\"><a href=\"#jdk环境变量配置\" class=\"headerlink\" title=\"jdk环境变量配置\"></a>jdk环境变量配置</h1><p>jdk环境变量配置<br>进行java开发，首先要安装jdk，安装了jdk后还要进行环境变量配置：<br>1、下载jdk（<a href=\"http://java.sun.com/javase/downloads/index.jsp），我下载的版本是：jdk-6u14-windows-i586.exe\" target=\"_blank\" rel=\"noopener\">http://java.sun.com/javase/downloads/index.jsp），我下载的版本是：jdk-6u14-windows-i586.exe</a><br>2、安装jdk-6u14-windows-i586.exe<br>3、配置环境变量：右击“我的电脑”–&gt;”高级”–&gt;”环境变量”<br>1）在系统变量里新建JAVA_HOME变量，变量值为：C:\\Program Files\\Java\\jdk1.6.0_14（根据自己的安装路径填写）<br>2）新建classpath变量，变量值为：.;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tools.jar<br>3）在path变量（已存在不用新建）添加变量值：%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin（注意变量值之间用“;”隔开）<br>4、“开始”–&gt;“运行”–&gt;输入“javac”–&gt;”Enter”，如果能正常打印用法说明配置成功！<br>补充环境变量的解析:<br>JAVA_HOME:jdk的安装路径<br>classpath:java加载类路径，只有类在classpath中java命令才能识别，在路径前加了个”.”表示当前路径。<br>path：系统在任何路径下都可以识别java,javac命令。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"jdk环境变量配置\"><a href=\"#jdk环境变量配置\" class=\"headerlink\" title=\"jdk环境变量配置\"></a>jdk环境变量配置</h1><p>jdk环境变量配置<br>进行java开发，首先要安装jdk，安装了jdk后还要进行环境变量配置：<br>1、下载jdk（<a href=\"http://java.sun.com/javase/downloads/index.jsp），我下载的版本是：jdk-6u14-windows-i586.exe\" target=\"_blank\" rel=\"noopener\">http://java.sun.com/javase/downloads/index.jsp），我下载的版本是：jdk-6u14-windows-i586.exe</a><br>2、安装jdk-6u14-windows-i586.exe<br>3、配置环境变量：右击“我的电脑”–&gt;”高级”–&gt;”环境变量”<br>1）在系统变量里新建JAVA_HOME变量，变量值为：C:\\Program Files\\Java\\jdk1.6.0_14（根据自己的安装路径填写）<br>2）新建classpath变量，变量值为：.;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tools.jar<br>3）在path变量（已存在不用新建）添加变量值：%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin（注意变量值之间用“;”隔开）<br>4、“开始”–&gt;“运行”–&gt;输入“javac”–&gt;”Enter”，如果能正常打印用法说明配置成功！<br>补充环境变量的解析:<br>JAVA_HOME:jdk的安装路径<br>classpath:java加载类路径，只有类在classpath中java命令才能识别，在路径前加了个”.”表示当前路径。<br>path：系统在任何路径下都可以识别java,javac命令。</p>\n"},{"title":"固定IP上网方式","date":"2016-09-20T01:43:49.000Z","_content":"#固定IP上网方式#\n\n**1. 修改主机名称：/etc/sysconfig/network**  \nNETWORKING=yes\nHOSTNAME=centos.dm.tsai\n\n**2. 设置网络参数：/etc/sysconfig/network-scripts/ifcfg-eth0**  \n请记得，这个ifcfg-eth0需与文件内的DEVICE名称设置相同，并且，在这个文件内的所有设置，基本上就是bash的变量设置规则\n\n**[root@linux ~]# vi /etc/sysconfig/network-scripts/ifcfg-eth0**   \nDEVICE=eth0                    网卡代号，需要ifcfg-eth0相对应   \nBOOTPROTO=static\t\t\t   开机协议，有dhcp及static,这里是static   \nBROADCAST=192.168.1.255        广播地址  \nHWADDR=00:40:D0:13:C3:46       网卡地址  \nIPADDR=192.168.1.13            IP  \nNETMASK=255.255.255.0          子屏蔽网络  \nNETWORK=192.168.1.0           网段，该网段的第一个IP  \nGATEWAY=192.168.1.2           默认路由  \nONBOOT=yes                  是否开机启动  \nMTU=1500                    最大传输单元的设置值  \nGATEWAYDEV=eth0            主要路由的设备，通常不用设置  \n\n&emsp;&emsp;请注意每个变量（左边的英文）都应该要大写。否则我们的script会误判。关于IP的4个参数（IPADDR、NETMASK、NETWORK、BROADCAST），下面谈谈以下几个重要的设置值.  \n&emsp;&emsp;DEVICE: 这个设置后面接的是设备代号必须与文件名（ifcfg-eht0）的设备代号相同，否则会显示找不到设备名称。\n&emsp;&emsp;BOOTPROTO：启动该网络接口时，使用何种协议？如果是手动设置IP的环境，请输入static或none，如果是自动取得IP的情况，请输入dhcp。  \n&emsp;&emsp;GATEWAY：代表的是整个主机系统的Default Gateway，所以，设置这个项目时，**请特别留意。不要有重复设置的情况发生。**也就是说，当您有ifcfg-eth0、Ifcfg-eht1等多个文件时，只要在其中一个文件里设置GATEWAY即可。  \n&emsp;&emsp;GATEWAYDEV：如果您不是使用固定的IP作为Gateway，而是使用网络设备作为Gateway（通常Route最常有这样的设置），那也可以使用GATEWAYDEV来设置通信网关设备。不过这个设置项目很少使用。  \n&emsp;&emsp;HWADDR：这是网卡的卡号。记得以前常常在讲，如果有两块一模一样的网卡存在，例如在一台主机上安装两张RealTek网卡，由于是相同的芯片，所以/etc/modprobe.conf内无法指定出明确的eth0与eth1的对应（因为模块使用相同），那么哪一个才是eth0?利用HWADDR指定网卡的卡号，就能够清楚定义出不同网卡的代号了。  \n&emsp;&emsp;事实上，如果想了解每个变量的项目意义时，建议参考/sbin/ifup这个script的内容，script很清楚地记录了每个项目的应用。\n\n**3. 启动与关闭网卡：ifup/ifdown**\n启动与关闭网卡的方式有两种，下面分别介绍：\n[root@linux~]#ifup eth0  \n[root@linux~]#ifdown eth0 \n\n上面的做法是针对eth0来进行启动(ifup)与关闭(ifdown)\n[root@linux~]# /etc/init.d/network restart\n\n针对这台主机的所有网络接口(包含lo)与通信闸进行重新启动所以网络会停止再连接\n\n[root@linux~]#service network restart;\n\n**4. 设置DNS的IP： /etc/resolv.conf**\n这个文件会影响到您是否可以查询到主机名称与IP的对应。通常进行如果设置就可以了。\nnameServer 168.95.1.1\n\n","source":"_posts/linux/Linux固定IP上网方式.md","raw":"---\ntitle: 固定IP上网方式\ndate: 2016-09-20 09:43:49\ntags: [linux,网络]\ncategories: [linux,网络]\n---\n#固定IP上网方式#\n\n**1. 修改主机名称：/etc/sysconfig/network**  \nNETWORKING=yes\nHOSTNAME=centos.dm.tsai\n\n**2. 设置网络参数：/etc/sysconfig/network-scripts/ifcfg-eth0**  \n请记得，这个ifcfg-eth0需与文件内的DEVICE名称设置相同，并且，在这个文件内的所有设置，基本上就是bash的变量设置规则\n\n**[root@linux ~]# vi /etc/sysconfig/network-scripts/ifcfg-eth0**   \nDEVICE=eth0                    网卡代号，需要ifcfg-eth0相对应   \nBOOTPROTO=static\t\t\t   开机协议，有dhcp及static,这里是static   \nBROADCAST=192.168.1.255        广播地址  \nHWADDR=00:40:D0:13:C3:46       网卡地址  \nIPADDR=192.168.1.13            IP  \nNETMASK=255.255.255.0          子屏蔽网络  \nNETWORK=192.168.1.0           网段，该网段的第一个IP  \nGATEWAY=192.168.1.2           默认路由  \nONBOOT=yes                  是否开机启动  \nMTU=1500                    最大传输单元的设置值  \nGATEWAYDEV=eth0            主要路由的设备，通常不用设置  \n\n&emsp;&emsp;请注意每个变量（左边的英文）都应该要大写。否则我们的script会误判。关于IP的4个参数（IPADDR、NETMASK、NETWORK、BROADCAST），下面谈谈以下几个重要的设置值.  \n&emsp;&emsp;DEVICE: 这个设置后面接的是设备代号必须与文件名（ifcfg-eht0）的设备代号相同，否则会显示找不到设备名称。\n&emsp;&emsp;BOOTPROTO：启动该网络接口时，使用何种协议？如果是手动设置IP的环境，请输入static或none，如果是自动取得IP的情况，请输入dhcp。  \n&emsp;&emsp;GATEWAY：代表的是整个主机系统的Default Gateway，所以，设置这个项目时，**请特别留意。不要有重复设置的情况发生。**也就是说，当您有ifcfg-eth0、Ifcfg-eht1等多个文件时，只要在其中一个文件里设置GATEWAY即可。  \n&emsp;&emsp;GATEWAYDEV：如果您不是使用固定的IP作为Gateway，而是使用网络设备作为Gateway（通常Route最常有这样的设置），那也可以使用GATEWAYDEV来设置通信网关设备。不过这个设置项目很少使用。  \n&emsp;&emsp;HWADDR：这是网卡的卡号。记得以前常常在讲，如果有两块一模一样的网卡存在，例如在一台主机上安装两张RealTek网卡，由于是相同的芯片，所以/etc/modprobe.conf内无法指定出明确的eth0与eth1的对应（因为模块使用相同），那么哪一个才是eth0?利用HWADDR指定网卡的卡号，就能够清楚定义出不同网卡的代号了。  \n&emsp;&emsp;事实上，如果想了解每个变量的项目意义时，建议参考/sbin/ifup这个script的内容，script很清楚地记录了每个项目的应用。\n\n**3. 启动与关闭网卡：ifup/ifdown**\n启动与关闭网卡的方式有两种，下面分别介绍：\n[root@linux~]#ifup eth0  \n[root@linux~]#ifdown eth0 \n\n上面的做法是针对eth0来进行启动(ifup)与关闭(ifdown)\n[root@linux~]# /etc/init.d/network restart\n\n针对这台主机的所有网络接口(包含lo)与通信闸进行重新启动所以网络会停止再连接\n\n[root@linux~]#service network restart;\n\n**4. 设置DNS的IP： /etc/resolv.conf**\n这个文件会影响到您是否可以查询到主机名称与IP的对应。通常进行如果设置就可以了。\nnameServer 168.95.1.1\n\n","slug":"linux/Linux固定IP上网方式","published":1,"updated":"2017-08-18T01:44:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bjf0014s77r54xzc4ba","content":"<p>#固定IP上网方式#</p>\n<p><strong>1. 修改主机名称：/etc/sysconfig/network</strong><br>NETWORKING=yes<br>HOSTNAME=centos.dm.tsai</p>\n<p><strong>2. 设置网络参数：/etc/sysconfig/network-scripts/ifcfg-eth0</strong><br>请记得，这个ifcfg-eth0需与文件内的DEVICE名称设置相同，并且，在这个文件内的所有设置，基本上就是bash的变量设置规则</p>\n<p><strong>[root@linux ~]# vi /etc/sysconfig/network-scripts/ifcfg-eth0</strong><br>DEVICE=eth0                    网卡代号，需要ifcfg-eth0相对应<br>BOOTPROTO=static               开机协议，有dhcp及static,这里是static<br>BROADCAST=192.168.1.255        广播地址<br>HWADDR=00:40:D0:13:C3:46       网卡地址<br>IPADDR=192.168.1.13            IP<br>NETMASK=255.255.255.0          子屏蔽网络<br>NETWORK=192.168.1.0           网段，该网段的第一个IP<br>GATEWAY=192.168.1.2           默认路由<br>ONBOOT=yes                  是否开机启动<br>MTU=1500                    最大传输单元的设置值<br>GATEWAYDEV=eth0            主要路由的设备，通常不用设置  </p>\n<p>&emsp;&emsp;请注意每个变量（左边的英文）都应该要大写。否则我们的script会误判。关于IP的4个参数（IPADDR、NETMASK、NETWORK、BROADCAST），下面谈谈以下几个重要的设置值.<br>&emsp;&emsp;DEVICE: 这个设置后面接的是设备代号必须与文件名（ifcfg-eht0）的设备代号相同，否则会显示找不到设备名称。<br>&emsp;&emsp;BOOTPROTO：启动该网络接口时，使用何种协议？如果是手动设置IP的环境，请输入static或none，如果是自动取得IP的情况，请输入dhcp。<br>&emsp;&emsp;GATEWAY：代表的是整个主机系统的Default Gateway，所以，设置这个项目时，<strong>请特别留意。不要有重复设置的情况发生。</strong>也就是说，当您有ifcfg-eth0、Ifcfg-eht1等多个文件时，只要在其中一个文件里设置GATEWAY即可。<br>&emsp;&emsp;GATEWAYDEV：如果您不是使用固定的IP作为Gateway，而是使用网络设备作为Gateway（通常Route最常有这样的设置），那也可以使用GATEWAYDEV来设置通信网关设备。不过这个设置项目很少使用。<br>&emsp;&emsp;HWADDR：这是网卡的卡号。记得以前常常在讲，如果有两块一模一样的网卡存在，例如在一台主机上安装两张RealTek网卡，由于是相同的芯片，所以/etc/modprobe.conf内无法指定出明确的eth0与eth1的对应（因为模块使用相同），那么哪一个才是eth0?利用HWADDR指定网卡的卡号，就能够清楚定义出不同网卡的代号了。<br>&emsp;&emsp;事实上，如果想了解每个变量的项目意义时，建议参考/sbin/ifup这个script的内容，script很清楚地记录了每个项目的应用。</p>\n<p><strong>3. 启动与关闭网卡：ifup/ifdown</strong><br>启动与关闭网卡的方式有两种，下面分别介绍：<br>[root@linux~]#ifup eth0<br>[root@linux~]#ifdown eth0 </p>\n<p>上面的做法是针对eth0来进行启动(ifup)与关闭(ifdown)<br>[root@linux~]# /etc/init.d/network restart</p>\n<p>针对这台主机的所有网络接口(包含lo)与通信闸进行重新启动所以网络会停止再连接</p>\n<p>[root@linux~]#service network restart;</p>\n<p><strong>4. 设置DNS的IP： /etc/resolv.conf</strong><br>这个文件会影响到您是否可以查询到主机名称与IP的对应。通常进行如果设置就可以了。<br>nameServer 168.95.1.1</p>\n","site":{"data":{}},"excerpt":"","more":"<p>#固定IP上网方式#</p>\n<p><strong>1. 修改主机名称：/etc/sysconfig/network</strong><br>NETWORKING=yes<br>HOSTNAME=centos.dm.tsai</p>\n<p><strong>2. 设置网络参数：/etc/sysconfig/network-scripts/ifcfg-eth0</strong><br>请记得，这个ifcfg-eth0需与文件内的DEVICE名称设置相同，并且，在这个文件内的所有设置，基本上就是bash的变量设置规则</p>\n<p><strong>[root@linux ~]# vi /etc/sysconfig/network-scripts/ifcfg-eth0</strong><br>DEVICE=eth0                    网卡代号，需要ifcfg-eth0相对应<br>BOOTPROTO=static               开机协议，有dhcp及static,这里是static<br>BROADCAST=192.168.1.255        广播地址<br>HWADDR=00:40:D0:13:C3:46       网卡地址<br>IPADDR=192.168.1.13            IP<br>NETMASK=255.255.255.0          子屏蔽网络<br>NETWORK=192.168.1.0           网段，该网段的第一个IP<br>GATEWAY=192.168.1.2           默认路由<br>ONBOOT=yes                  是否开机启动<br>MTU=1500                    最大传输单元的设置值<br>GATEWAYDEV=eth0            主要路由的设备，通常不用设置  </p>\n<p>&emsp;&emsp;请注意每个变量（左边的英文）都应该要大写。否则我们的script会误判。关于IP的4个参数（IPADDR、NETMASK、NETWORK、BROADCAST），下面谈谈以下几个重要的设置值.<br>&emsp;&emsp;DEVICE: 这个设置后面接的是设备代号必须与文件名（ifcfg-eht0）的设备代号相同，否则会显示找不到设备名称。<br>&emsp;&emsp;BOOTPROTO：启动该网络接口时，使用何种协议？如果是手动设置IP的环境，请输入static或none，如果是自动取得IP的情况，请输入dhcp。<br>&emsp;&emsp;GATEWAY：代表的是整个主机系统的Default Gateway，所以，设置这个项目时，<strong>请特别留意。不要有重复设置的情况发生。</strong>也就是说，当您有ifcfg-eth0、Ifcfg-eht1等多个文件时，只要在其中一个文件里设置GATEWAY即可。<br>&emsp;&emsp;GATEWAYDEV：如果您不是使用固定的IP作为Gateway，而是使用网络设备作为Gateway（通常Route最常有这样的设置），那也可以使用GATEWAYDEV来设置通信网关设备。不过这个设置项目很少使用。<br>&emsp;&emsp;HWADDR：这是网卡的卡号。记得以前常常在讲，如果有两块一模一样的网卡存在，例如在一台主机上安装两张RealTek网卡，由于是相同的芯片，所以/etc/modprobe.conf内无法指定出明确的eth0与eth1的对应（因为模块使用相同），那么哪一个才是eth0?利用HWADDR指定网卡的卡号，就能够清楚定义出不同网卡的代号了。<br>&emsp;&emsp;事实上，如果想了解每个变量的项目意义时，建议参考/sbin/ifup这个script的内容，script很清楚地记录了每个项目的应用。</p>\n<p><strong>3. 启动与关闭网卡：ifup/ifdown</strong><br>启动与关闭网卡的方式有两种，下面分别介绍：<br>[root@linux~]#ifup eth0<br>[root@linux~]#ifdown eth0 </p>\n<p>上面的做法是针对eth0来进行启动(ifup)与关闭(ifdown)<br>[root@linux~]# /etc/init.d/network restart</p>\n<p>针对这台主机的所有网络接口(包含lo)与通信闸进行重新启动所以网络会停止再连接</p>\n<p>[root@linux~]#service network restart;</p>\n<p><strong>4. 设置DNS的IP： /etc/resolv.conf</strong><br>这个文件会影响到您是否可以查询到主机名称与IP的对应。通常进行如果设置就可以了。<br>nameServer 168.95.1.1</p>\n"},{"title":"Linux常用命令及操作","date":"2017-05-02T02:54:00.000Z","_content":"下面整理一些常用的命令，内容来自于网络整合，会把自己常用的收集在这里  \n\n#CURL命令\n下载单个文件，默认将输出打印到标准输出中(STDOUT)中  \ncurl http://www.centos.org  \n通过-o/-O选项保存下载的文件到指定的文件中：  \n-o：将文件保存为命令行中指定的文件名的文件中  \n-O：使用URL中默认的文件名保存文件到本地  \n# 将文件下载到本地并命名为mygettext.html  \ncurl -o mygettext.html http://www.gnu.org/software/gettext/manual/gettext.html  \n# 将文件保存到本地并命名为gettext.html  \ncurl -O http://www.gnu.org/software/gettext/manual/gettext.html  \n同样可以使用转向字符\">\"对输出进行转向输出  \n##同时获取多个文件  \ncurl -O URL1 -O URL2  \n\n\n#ECHO命令\n在终端下打印变量value的时候也是常常用到的, 因此有必要了解下echo的用法  \necho命令的功能是在显示器上显示一段文字，一般起到一个提示的作用。  \n该命令的一般格式为： echo [ -n ] 字符串  \n其中选项n表示输出文字后不换行；字符串能加引号，也能不加引号。用echo命令输出加引号的字符串时，将字符串原样输出；用echo命令输出不加引号的字符串时，将字符串中的各个单词作为字符串输出，各字符串之间用一个空格分割。  \n功能说明：显示文字。  \n语 　 法：echo [-ne][字符串]或 echo [--help][--version]\n补充说明：echo会将输入的字符串送往标准输出。输出的字符串间以空白字符隔开, 并在最后加上换行号。  \n参　　 数：-n 不要在最后自动换行  \n-e 若字符串中出现以下字符，则特别加以处理，而不会将它当成一般  \n文字输出：  \n   \\a 发出警告声；  \n   \\b 删除前一个字符；  \n   \\c 最后不加上换行符号；  \n   \\f 换行但光标仍旧停留在原来的位置；  \n   \\n 换行且光标移至行首；  \n   \\r 光标移至行首，但不换行；  \n   \\t 插入tab；  \n   \\v 与\\f相同；  \n   \\\\ 插入\\字符；  \n   \\nnn 插入nnn（八进制）所代表的ASCII字符；  \n–help 显示帮助  \n–version 显示版本信息  \n  \n##其它功能\nECHO命令是大家都熟悉的DOS批处理命令的一条子命令，但它的一些功能和用法也许你并不是全都知道，不信你瞧：\n1． 作为控制批处理命令在执行时是否显示命令行自身的开关 格式：ECHO [ON|OFF] 如果想关闭“ECHO OFF”命令行自身的显示，则需要在该命令行前加上“@”。  \n2． 显示当前ECHO设置状态 格式：ECHO  \n3． 输出提示信息 格式：ECHO信息内容 上述是ECHO命令常见的三种用法，也是大家熟悉和会用的，但作为DOS命令淘金者你还应该知道下面的技巧：  \n4． 关闭DOS命令提示符 在DOS提示符状态下键入ECHO OFF，能够关闭DOS提示符的显示使屏幕只留下光标，直至键入ECHO ON，提示符才会重新出现。  \n5． 输出空行，即相当于输入一个回车 格式：ECHO． 值得注意的是命令行中的“．”要紧跟在ECHO后面中间不能有空格，否则“．”将被当作提示信息输出到屏幕。另外“．”可以用，：；”／[/]＋等任一符号替代。 在下面的例子中ECHO．输出的回车，经DOS管道转向作为TIME命令的输入，即相当于在TIME命令执行后给出一个回车。所以执行时系统会在显示当前时间后，自动返回到DOS提示符状态： C:〉ECHO.|TIME ECHO命令输出空行的另一个应用实例是：将ECHO．加在自动批处理文件中，使原本在屏幕下方显示的提示画面，出现在屏幕上方。  \n6． 答复命令中的提问 格式：ECHO答复语|命令文件名 上述格式可以用于简化一些需要人机对话的命令（如：CHKDSK／F；FORMAT Drive:；del *.*）的操作，它是通过DOS管道命令把ECHO命令输出的预置答复语作为人机对话命令的输入。下面的例子就相当于在调用的命令出现人机对话时输入“Y”回车： C:〉ECHO Y|CHKDSK/F C:〉ECHO Y|DEL A :*.*  \n7． 建立新文件或增加文件内容 格式：ECHO 文件内容＞文件名 ECHO 文件内容＞＞文件名 例如：C:〉ECHO @ECHO OFF〉AUTOEXEC.BAT建立自动批处理文件 C:〉ECHO C:/CPAV/BOOTSAFE〉〉AUTOEXEC.BAT向自动批处理文件中追加内容 C:TYPE AUTOEXEC.BAT显示该自动批处理文件 @ECHO OFF C:/CPAV/BOOTSAFE\n    可用于设置环境变量，如：  \n    $sudo echo \"export HIVE_HOME=$PWD/hive-0.9.0\" > /etc/profile.d/hive.sh  \n    $sudo echo \"PATH=$PATH:$HIVE_HOME/bin\" >> /etc/profile.d/hive.sh  \n8． 向打印机输出打印内容或打印控制码 格式：ECHO 打印机控制码＞PRN ECHO 打印内容＞PRN 下面的例子是向M－1724打印机输入打印控制码。＜Alt＞156是按住Alt键在小键盘键入156，类似情况依此类推： C:〉ECHO 〈Alt〉+156〈Alt〉+42〈Alt〉+116〉PRN（输入下划线命令FS＊t） C:〉ECHO 〈Alt〉+155@〉PRN（输入初始化命令ESC@） C:〉ECHO.〉PRN（换行）  \n9． 使喇叭鸣响 C:〉ECHO ^G “^G”是用Ctrl＋G或Alt＋007输入，输入多个^G可以产生多声鸣响。使用方法是直接将其加入批处理文件中或做成批处理文件调用。  \n10．执行ESC控制序列修改屏幕和键盘设置 我们知道DOS的设备驱动程序ANSI.SYS提供了一套用来修改屏幕和键盘设置的ESC控制序列。如执行下述内容的批处理程序可以把功能键F12定义为DOS命令“DIR／W”，并把屏幕颜色修改为白色字符蓝色背景。 @ECHO”←[0;134;”DIR/W”;13p @ECHO”←[1;37;44m （注：批处理文件中“←”字符的输入方法是在编辑状态下按Alt中小键盘上的27） DOS命令是接触计算机的人首先要学到的，对许多人来说是太熟悉太简单了，其实不然，在这些命令中蕴藏着丰富的内容，仍有待于我们进一步去理解去开发，如果你是一个有心人就一定会从这些自以为熟知的命令中发现新的闪光点，淘得真金。  \n\n#>和>>的区别,<号使用\nLinux中经常会用到将内容输出到某文件当中，只需要在执行命令后面加上>或者>>号即可进入操作。  \n大于号：将一条命令执行结果（标准输出，或者错误输出，本来都要打印到屏幕上面的）重定向其它输出设备（文件，打开文件操作符，或打印机等等）  \n小于号：命令默认从键盘获得的输入，改成从文件，或者其它打开文件以及设备输入  \n>> 是追加内容  \n> 是覆盖原有内容  \n示例：  \n1. bogon:Desktop wenxuechao$ echo 'abc' > test.txt    \n2. bogon:Desktop wenxuechao$ echo '123' >> test.txt  \n执行效果，第一句命令会在桌面创建个test.txt的文件，并且将abc写到文件中。  \n第二句命令，会在文件下方，再次写入内容。  \n<小于号    \nmysql -u root -p -h test < test.sql 导入数据    \n","source":"_posts/linux/Linux常用命令及操作.md","raw":"---\ntitle: Linux常用命令及操作\ndate: 2017-05-02 10:54:00\ntags: [linux]\ncategories: [linux,linux基本配置]\n---\n下面整理一些常用的命令，内容来自于网络整合，会把自己常用的收集在这里  \n\n#CURL命令\n下载单个文件，默认将输出打印到标准输出中(STDOUT)中  \ncurl http://www.centos.org  \n通过-o/-O选项保存下载的文件到指定的文件中：  \n-o：将文件保存为命令行中指定的文件名的文件中  \n-O：使用URL中默认的文件名保存文件到本地  \n# 将文件下载到本地并命名为mygettext.html  \ncurl -o mygettext.html http://www.gnu.org/software/gettext/manual/gettext.html  \n# 将文件保存到本地并命名为gettext.html  \ncurl -O http://www.gnu.org/software/gettext/manual/gettext.html  \n同样可以使用转向字符\">\"对输出进行转向输出  \n##同时获取多个文件  \ncurl -O URL1 -O URL2  \n\n\n#ECHO命令\n在终端下打印变量value的时候也是常常用到的, 因此有必要了解下echo的用法  \necho命令的功能是在显示器上显示一段文字，一般起到一个提示的作用。  \n该命令的一般格式为： echo [ -n ] 字符串  \n其中选项n表示输出文字后不换行；字符串能加引号，也能不加引号。用echo命令输出加引号的字符串时，将字符串原样输出；用echo命令输出不加引号的字符串时，将字符串中的各个单词作为字符串输出，各字符串之间用一个空格分割。  \n功能说明：显示文字。  \n语 　 法：echo [-ne][字符串]或 echo [--help][--version]\n补充说明：echo会将输入的字符串送往标准输出。输出的字符串间以空白字符隔开, 并在最后加上换行号。  \n参　　 数：-n 不要在最后自动换行  \n-e 若字符串中出现以下字符，则特别加以处理，而不会将它当成一般  \n文字输出：  \n   \\a 发出警告声；  \n   \\b 删除前一个字符；  \n   \\c 最后不加上换行符号；  \n   \\f 换行但光标仍旧停留在原来的位置；  \n   \\n 换行且光标移至行首；  \n   \\r 光标移至行首，但不换行；  \n   \\t 插入tab；  \n   \\v 与\\f相同；  \n   \\\\ 插入\\字符；  \n   \\nnn 插入nnn（八进制）所代表的ASCII字符；  \n–help 显示帮助  \n–version 显示版本信息  \n  \n##其它功能\nECHO命令是大家都熟悉的DOS批处理命令的一条子命令，但它的一些功能和用法也许你并不是全都知道，不信你瞧：\n1． 作为控制批处理命令在执行时是否显示命令行自身的开关 格式：ECHO [ON|OFF] 如果想关闭“ECHO OFF”命令行自身的显示，则需要在该命令行前加上“@”。  \n2． 显示当前ECHO设置状态 格式：ECHO  \n3． 输出提示信息 格式：ECHO信息内容 上述是ECHO命令常见的三种用法，也是大家熟悉和会用的，但作为DOS命令淘金者你还应该知道下面的技巧：  \n4． 关闭DOS命令提示符 在DOS提示符状态下键入ECHO OFF，能够关闭DOS提示符的显示使屏幕只留下光标，直至键入ECHO ON，提示符才会重新出现。  \n5． 输出空行，即相当于输入一个回车 格式：ECHO． 值得注意的是命令行中的“．”要紧跟在ECHO后面中间不能有空格，否则“．”将被当作提示信息输出到屏幕。另外“．”可以用，：；”／[/]＋等任一符号替代。 在下面的例子中ECHO．输出的回车，经DOS管道转向作为TIME命令的输入，即相当于在TIME命令执行后给出一个回车。所以执行时系统会在显示当前时间后，自动返回到DOS提示符状态： C:〉ECHO.|TIME ECHO命令输出空行的另一个应用实例是：将ECHO．加在自动批处理文件中，使原本在屏幕下方显示的提示画面，出现在屏幕上方。  \n6． 答复命令中的提问 格式：ECHO答复语|命令文件名 上述格式可以用于简化一些需要人机对话的命令（如：CHKDSK／F；FORMAT Drive:；del *.*）的操作，它是通过DOS管道命令把ECHO命令输出的预置答复语作为人机对话命令的输入。下面的例子就相当于在调用的命令出现人机对话时输入“Y”回车： C:〉ECHO Y|CHKDSK/F C:〉ECHO Y|DEL A :*.*  \n7． 建立新文件或增加文件内容 格式：ECHO 文件内容＞文件名 ECHO 文件内容＞＞文件名 例如：C:〉ECHO @ECHO OFF〉AUTOEXEC.BAT建立自动批处理文件 C:〉ECHO C:/CPAV/BOOTSAFE〉〉AUTOEXEC.BAT向自动批处理文件中追加内容 C:TYPE AUTOEXEC.BAT显示该自动批处理文件 @ECHO OFF C:/CPAV/BOOTSAFE\n    可用于设置环境变量，如：  \n    $sudo echo \"export HIVE_HOME=$PWD/hive-0.9.0\" > /etc/profile.d/hive.sh  \n    $sudo echo \"PATH=$PATH:$HIVE_HOME/bin\" >> /etc/profile.d/hive.sh  \n8． 向打印机输出打印内容或打印控制码 格式：ECHO 打印机控制码＞PRN ECHO 打印内容＞PRN 下面的例子是向M－1724打印机输入打印控制码。＜Alt＞156是按住Alt键在小键盘键入156，类似情况依此类推： C:〉ECHO 〈Alt〉+156〈Alt〉+42〈Alt〉+116〉PRN（输入下划线命令FS＊t） C:〉ECHO 〈Alt〉+155@〉PRN（输入初始化命令ESC@） C:〉ECHO.〉PRN（换行）  \n9． 使喇叭鸣响 C:〉ECHO ^G “^G”是用Ctrl＋G或Alt＋007输入，输入多个^G可以产生多声鸣响。使用方法是直接将其加入批处理文件中或做成批处理文件调用。  \n10．执行ESC控制序列修改屏幕和键盘设置 我们知道DOS的设备驱动程序ANSI.SYS提供了一套用来修改屏幕和键盘设置的ESC控制序列。如执行下述内容的批处理程序可以把功能键F12定义为DOS命令“DIR／W”，并把屏幕颜色修改为白色字符蓝色背景。 @ECHO”←[0;134;”DIR/W”;13p @ECHO”←[1;37;44m （注：批处理文件中“←”字符的输入方法是在编辑状态下按Alt中小键盘上的27） DOS命令是接触计算机的人首先要学到的，对许多人来说是太熟悉太简单了，其实不然，在这些命令中蕴藏着丰富的内容，仍有待于我们进一步去理解去开发，如果你是一个有心人就一定会从这些自以为熟知的命令中发现新的闪光点，淘得真金。  \n\n#>和>>的区别,<号使用\nLinux中经常会用到将内容输出到某文件当中，只需要在执行命令后面加上>或者>>号即可进入操作。  \n大于号：将一条命令执行结果（标准输出，或者错误输出，本来都要打印到屏幕上面的）重定向其它输出设备（文件，打开文件操作符，或打印机等等）  \n小于号：命令默认从键盘获得的输入，改成从文件，或者其它打开文件以及设备输入  \n>> 是追加内容  \n> 是覆盖原有内容  \n示例：  \n1. bogon:Desktop wenxuechao$ echo 'abc' > test.txt    \n2. bogon:Desktop wenxuechao$ echo '123' >> test.txt  \n执行效果，第一句命令会在桌面创建个test.txt的文件，并且将abc写到文件中。  \n第二句命令，会在文件下方，再次写入内容。  \n<小于号    \nmysql -u root -p -h test < test.sql 导入数据    \n","slug":"linux/Linux常用命令及操作","published":1,"updated":"2017-08-18T01:44:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bjg0018s77r6t0yyrvi","content":"<p>下面整理一些常用的命令，内容来自于网络整合，会把自己常用的收集在这里  </p>\n<p>#CURL命令<br>下载单个文件，默认将输出打印到标准输出中(STDOUT)中<br>curl <a href=\"http://www.centos.org\" target=\"_blank\" rel=\"noopener\">http://www.centos.org</a><br>通过-o/-O选项保存下载的文件到指定的文件中：<br>-o：将文件保存为命令行中指定的文件名的文件中<br>-O：使用URL中默认的文件名保存文件到本地  </p>\n<h1 id=\"将文件下载到本地并命名为mygettext-html\"><a href=\"#将文件下载到本地并命名为mygettext-html\" class=\"headerlink\" title=\"将文件下载到本地并命名为mygettext.html\"></a>将文件下载到本地并命名为mygettext.html</h1><p>curl -o mygettext.html <a href=\"http://www.gnu.org/software/gettext/manual/gettext.html\" target=\"_blank\" rel=\"noopener\">http://www.gnu.org/software/gettext/manual/gettext.html</a>  </p>\n<h1 id=\"将文件保存到本地并命名为gettext-html\"><a href=\"#将文件保存到本地并命名为gettext-html\" class=\"headerlink\" title=\"将文件保存到本地并命名为gettext.html\"></a>将文件保存到本地并命名为gettext.html</h1><p>curl -O <a href=\"http://www.gnu.org/software/gettext/manual/gettext.html\" target=\"_blank\" rel=\"noopener\">http://www.gnu.org/software/gettext/manual/gettext.html</a><br>同样可以使用转向字符”&gt;”对输出进行转向输出  </p>\n<p>##同时获取多个文件<br>curl -O URL1 -O URL2  </p>\n<p>#ECHO命令<br>在终端下打印变量value的时候也是常常用到的, 因此有必要了解下echo的用法<br>echo命令的功能是在显示器上显示一段文字，一般起到一个提示的作用。<br>该命令的一般格式为： echo [ -n ] 字符串<br>其中选项n表示输出文字后不换行；字符串能加引号，也能不加引号。用echo命令输出加引号的字符串时，将字符串原样输出；用echo命令输出不加引号的字符串时，将字符串中的各个单词作为字符串输出，各字符串之间用一个空格分割。<br>功能说明：显示文字。<br>语 　 法：echo [-ne][字符串]或 echo [–help][–version]<br>补充说明：echo会将输入的字符串送往标准输出。输出的字符串间以空白字符隔开, 并在最后加上换行号。<br>参　　 数：-n 不要在最后自动换行<br>-e 若字符串中出现以下字符，则特别加以处理，而不会将它当成一般<br>文字输出：<br>   \\a 发出警告声；<br>   \\b 删除前一个字符；<br>   \\c 最后不加上换行符号；<br>   \\f 换行但光标仍旧停留在原来的位置；<br>   \\n 换行且光标移至行首；<br>   \\r 光标移至行首，但不换行；<br>   \\t 插入tab；<br>   \\v 与\\f相同；<br>   \\ 插入\\字符；<br>   \\nnn 插入nnn（八进制）所代表的ASCII字符；<br>–help 显示帮助<br>–version 显示版本信息  </p>\n<p>##其它功能<br>ECHO命令是大家都熟悉的DOS批处理命令的一条子命令，但它的一些功能和用法也许你并不是全都知道，不信你瞧：<br>1． 作为控制批处理命令在执行时是否显示命令行自身的开关 格式：ECHO [ON|OFF] 如果想关闭“ECHO OFF”命令行自身的显示，则需要在该命令行前加上“@”。<br>2． 显示当前ECHO设置状态 格式：ECHO<br>3． 输出提示信息 格式：ECHO信息内容 上述是ECHO命令常见的三种用法，也是大家熟悉和会用的，但作为DOS命令淘金者你还应该知道下面的技巧：<br>4． 关闭DOS命令提示符 在DOS提示符状态下键入ECHO OFF，能够关闭DOS提示符的显示使屏幕只留下光标，直至键入ECHO ON，提示符才会重新出现。<br>5． 输出空行，即相当于输入一个回车 格式：ECHO． 值得注意的是命令行中的“．”要紧跟在ECHO后面中间不能有空格，否则“．”将被当作提示信息输出到屏幕。另外“．”可以用，：；”／[/]＋等任一符号替代。 在下面的例子中ECHO．输出的回车，经DOS管道转向作为TIME命令的输入，即相当于在TIME命令执行后给出一个回车。所以执行时系统会在显示当前时间后，自动返回到DOS提示符状态： C:〉ECHO.|TIME ECHO命令输出空行的另一个应用实例是：将ECHO．加在自动批处理文件中，使原本在屏幕下方显示的提示画面，出现在屏幕上方。<br>6． 答复命令中的提问 格式：ECHO答复语|命令文件名 上述格式可以用于简化一些需要人机对话的命令（如：CHKDSK／F；FORMAT Drive:；del <em>.</em>）的操作，它是通过DOS管道命令把ECHO命令输出的预置答复语作为人机对话命令的输入。下面的例子就相当于在调用的命令出现人机对话时输入“Y”回车： C:〉ECHO Y|CHKDSK/F C:〉ECHO Y|DEL A :<em>.</em><br>7． 建立新文件或增加文件内容 格式：ECHO 文件内容＞文件名 ECHO 文件内容＞＞文件名 例如：C:〉ECHO @ECHO OFF〉AUTOEXEC.BAT建立自动批处理文件 C:〉ECHO C:/CPAV/BOOTSAFE〉〉AUTOEXEC.BAT向自动批处理文件中追加内容 C:TYPE AUTOEXEC.BAT显示该自动批处理文件 @ECHO OFF C:/CPAV/BOOTSAFE<br>    可用于设置环境变量，如：<br>    $sudo echo “export HIVE_HOME=$PWD/hive-0.9.0” &gt; /etc/profile.d/hive.sh<br>    $sudo echo “PATH=$PATH:$HIVE_HOME/bin” &gt;&gt; /etc/profile.d/hive.sh<br>8． 向打印机输出打印内容或打印控制码 格式：ECHO 打印机控制码＞PRN ECHO 打印内容＞PRN 下面的例子是向M－1724打印机输入打印控制码。＜Alt＞156是按住Alt键在小键盘键入156，类似情况依此类推： C:〉ECHO 〈Alt〉+156〈Alt〉+42〈Alt〉+116〉PRN（输入下划线命令FS＊t） C:〉ECHO 〈Alt〉+155@〉PRN（输入初始化命令ESC@） C:〉ECHO.〉PRN（换行）<br>9． 使喇叭鸣响 C:〉ECHO ^G “^G”是用Ctrl＋G或Alt＋007输入，输入多个^G可以产生多声鸣响。使用方法是直接将其加入批处理文件中或做成批处理文件调用。<br>10．执行ESC控制序列修改屏幕和键盘设置 我们知道DOS的设备驱动程序ANSI.SYS提供了一套用来修改屏幕和键盘设置的ESC控制序列。如执行下述内容的批处理程序可以把功能键F12定义为DOS命令“DIR／W”，并把屏幕颜色修改为白色字符蓝色背景。 @ECHO”←[0;134;”DIR/W”;13p @ECHO”←[1;37;44m （注：批处理文件中“←”字符的输入方法是在编辑状态下按Alt中小键盘上的27） DOS命令是接触计算机的人首先要学到的，对许多人来说是太熟悉太简单了，其实不然，在这些命令中蕴藏着丰富的内容，仍有待于我们进一步去理解去开发，如果你是一个有心人就一定会从这些自以为熟知的命令中发现新的闪光点，淘得真金。  </p>\n<p>#&gt;和&gt;&gt;的区别,&lt;号使用<br>Linux中经常会用到将内容输出到某文件当中，只需要在执行命令后面加上&gt;或者&gt;&gt;号即可进入操作。<br>大于号：将一条命令执行结果（标准输出，或者错误输出，本来都要打印到屏幕上面的）重定向其它输出设备（文件，打开文件操作符，或打印机等等）<br>小于号：命令默认从键盘获得的输入，改成从文件，或者其它打开文件以及设备输入  </p>\n<blockquote>\n<blockquote>\n<p>是追加内容<br>是覆盖原有内容<br>示例：  </p>\n<ol>\n<li>bogon:Desktop wenxuechao$ echo ‘abc’ &gt; test.txt    </li>\n<li>bogon:Desktop wenxuechao$ echo ‘123’ &gt;&gt; test.txt<br>执行效果，第一句命令会在桌面创建个test.txt的文件，并且将abc写到文件中。<br>第二句命令，会在文件下方，再次写入内容。<br>&lt;小于号<br>mysql -u root -p -h test &lt; test.sql 导入数据    </li>\n</ol>\n</blockquote>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>下面整理一些常用的命令，内容来自于网络整合，会把自己常用的收集在这里  </p>\n<p>#CURL命令<br>下载单个文件，默认将输出打印到标准输出中(STDOUT)中<br>curl <a href=\"http://www.centos.org\" target=\"_blank\" rel=\"noopener\">http://www.centos.org</a><br>通过-o/-O选项保存下载的文件到指定的文件中：<br>-o：将文件保存为命令行中指定的文件名的文件中<br>-O：使用URL中默认的文件名保存文件到本地  </p>\n<h1 id=\"将文件下载到本地并命名为mygettext-html\"><a href=\"#将文件下载到本地并命名为mygettext-html\" class=\"headerlink\" title=\"将文件下载到本地并命名为mygettext.html\"></a>将文件下载到本地并命名为mygettext.html</h1><p>curl -o mygettext.html <a href=\"http://www.gnu.org/software/gettext/manual/gettext.html\" target=\"_blank\" rel=\"noopener\">http://www.gnu.org/software/gettext/manual/gettext.html</a>  </p>\n<h1 id=\"将文件保存到本地并命名为gettext-html\"><a href=\"#将文件保存到本地并命名为gettext-html\" class=\"headerlink\" title=\"将文件保存到本地并命名为gettext.html\"></a>将文件保存到本地并命名为gettext.html</h1><p>curl -O <a href=\"http://www.gnu.org/software/gettext/manual/gettext.html\" target=\"_blank\" rel=\"noopener\">http://www.gnu.org/software/gettext/manual/gettext.html</a><br>同样可以使用转向字符”&gt;”对输出进行转向输出  </p>\n<p>##同时获取多个文件<br>curl -O URL1 -O URL2  </p>\n<p>#ECHO命令<br>在终端下打印变量value的时候也是常常用到的, 因此有必要了解下echo的用法<br>echo命令的功能是在显示器上显示一段文字，一般起到一个提示的作用。<br>该命令的一般格式为： echo [ -n ] 字符串<br>其中选项n表示输出文字后不换行；字符串能加引号，也能不加引号。用echo命令输出加引号的字符串时，将字符串原样输出；用echo命令输出不加引号的字符串时，将字符串中的各个单词作为字符串输出，各字符串之间用一个空格分割。<br>功能说明：显示文字。<br>语 　 法：echo [-ne][字符串]或 echo [–help][–version]<br>补充说明：echo会将输入的字符串送往标准输出。输出的字符串间以空白字符隔开, 并在最后加上换行号。<br>参　　 数：-n 不要在最后自动换行<br>-e 若字符串中出现以下字符，则特别加以处理，而不会将它当成一般<br>文字输出：<br>   \\a 发出警告声；<br>   \\b 删除前一个字符；<br>   \\c 最后不加上换行符号；<br>   \\f 换行但光标仍旧停留在原来的位置；<br>   \\n 换行且光标移至行首；<br>   \\r 光标移至行首，但不换行；<br>   \\t 插入tab；<br>   \\v 与\\f相同；<br>   \\ 插入\\字符；<br>   \\nnn 插入nnn（八进制）所代表的ASCII字符；<br>–help 显示帮助<br>–version 显示版本信息  </p>\n<p>##其它功能<br>ECHO命令是大家都熟悉的DOS批处理命令的一条子命令，但它的一些功能和用法也许你并不是全都知道，不信你瞧：<br>1． 作为控制批处理命令在执行时是否显示命令行自身的开关 格式：ECHO [ON|OFF] 如果想关闭“ECHO OFF”命令行自身的显示，则需要在该命令行前加上“@”。<br>2． 显示当前ECHO设置状态 格式：ECHO<br>3． 输出提示信息 格式：ECHO信息内容 上述是ECHO命令常见的三种用法，也是大家熟悉和会用的，但作为DOS命令淘金者你还应该知道下面的技巧：<br>4． 关闭DOS命令提示符 在DOS提示符状态下键入ECHO OFF，能够关闭DOS提示符的显示使屏幕只留下光标，直至键入ECHO ON，提示符才会重新出现。<br>5． 输出空行，即相当于输入一个回车 格式：ECHO． 值得注意的是命令行中的“．”要紧跟在ECHO后面中间不能有空格，否则“．”将被当作提示信息输出到屏幕。另外“．”可以用，：；”／[/]＋等任一符号替代。 在下面的例子中ECHO．输出的回车，经DOS管道转向作为TIME命令的输入，即相当于在TIME命令执行后给出一个回车。所以执行时系统会在显示当前时间后，自动返回到DOS提示符状态： C:〉ECHO.|TIME ECHO命令输出空行的另一个应用实例是：将ECHO．加在自动批处理文件中，使原本在屏幕下方显示的提示画面，出现在屏幕上方。<br>6． 答复命令中的提问 格式：ECHO答复语|命令文件名 上述格式可以用于简化一些需要人机对话的命令（如：CHKDSK／F；FORMAT Drive:；del <em>.</em>）的操作，它是通过DOS管道命令把ECHO命令输出的预置答复语作为人机对话命令的输入。下面的例子就相当于在调用的命令出现人机对话时输入“Y”回车： C:〉ECHO Y|CHKDSK/F C:〉ECHO Y|DEL A :<em>.</em><br>7． 建立新文件或增加文件内容 格式：ECHO 文件内容＞文件名 ECHO 文件内容＞＞文件名 例如：C:〉ECHO @ECHO OFF〉AUTOEXEC.BAT建立自动批处理文件 C:〉ECHO C:/CPAV/BOOTSAFE〉〉AUTOEXEC.BAT向自动批处理文件中追加内容 C:TYPE AUTOEXEC.BAT显示该自动批处理文件 @ECHO OFF C:/CPAV/BOOTSAFE<br>    可用于设置环境变量，如：<br>    $sudo echo “export HIVE_HOME=$PWD/hive-0.9.0” &gt; /etc/profile.d/hive.sh<br>    $sudo echo “PATH=$PATH:$HIVE_HOME/bin” &gt;&gt; /etc/profile.d/hive.sh<br>8． 向打印机输出打印内容或打印控制码 格式：ECHO 打印机控制码＞PRN ECHO 打印内容＞PRN 下面的例子是向M－1724打印机输入打印控制码。＜Alt＞156是按住Alt键在小键盘键入156，类似情况依此类推： C:〉ECHO 〈Alt〉+156〈Alt〉+42〈Alt〉+116〉PRN（输入下划线命令FS＊t） C:〉ECHO 〈Alt〉+155@〉PRN（输入初始化命令ESC@） C:〉ECHO.〉PRN（换行）<br>9． 使喇叭鸣响 C:〉ECHO ^G “^G”是用Ctrl＋G或Alt＋007输入，输入多个^G可以产生多声鸣响。使用方法是直接将其加入批处理文件中或做成批处理文件调用。<br>10．执行ESC控制序列修改屏幕和键盘设置 我们知道DOS的设备驱动程序ANSI.SYS提供了一套用来修改屏幕和键盘设置的ESC控制序列。如执行下述内容的批处理程序可以把功能键F12定义为DOS命令“DIR／W”，并把屏幕颜色修改为白色字符蓝色背景。 @ECHO”←[0;134;”DIR/W”;13p @ECHO”←[1;37;44m （注：批处理文件中“←”字符的输入方法是在编辑状态下按Alt中小键盘上的27） DOS命令是接触计算机的人首先要学到的，对许多人来说是太熟悉太简单了，其实不然，在这些命令中蕴藏着丰富的内容，仍有待于我们进一步去理解去开发，如果你是一个有心人就一定会从这些自以为熟知的命令中发现新的闪光点，淘得真金。  </p>\n<p>#&gt;和&gt;&gt;的区别,&lt;号使用<br>Linux中经常会用到将内容输出到某文件当中，只需要在执行命令后面加上&gt;或者&gt;&gt;号即可进入操作。<br>大于号：将一条命令执行结果（标准输出，或者错误输出，本来都要打印到屏幕上面的）重定向其它输出设备（文件，打开文件操作符，或打印机等等）<br>小于号：命令默认从键盘获得的输入，改成从文件，或者其它打开文件以及设备输入  </p>\n<blockquote>\n<blockquote>\n<p>是追加内容<br>是覆盖原有内容<br>示例：  </p>\n<ol>\n<li>bogon:Desktop wenxuechao$ echo ‘abc’ &gt; test.txt    </li>\n<li>bogon:Desktop wenxuechao$ echo ‘123’ &gt;&gt; test.txt<br>执行效果，第一句命令会在桌面创建个test.txt的文件，并且将abc写到文件中。<br>第二句命令，会在文件下方，再次写入内容。<br>&lt;小于号<br>mysql -u root -p -h test &lt; test.sql 导入数据    </li>\n</ol>\n</blockquote>\n</blockquote>\n"},{"title":"SSH用户等效性配置","date":"2016-05-20T06:43:49.000Z","_content":"#SSH用户等效性配置 #\n以下均以oracle用户执行\nlinuxrac1\n[oracle @linuxrac1 ~]$mkdir ~/.ssh\n[oracle @linuxrac1 ~]$chmod 755 ~/.ssh\n[oracle @linuxrac1 ~]$ssh-keygen -t rsa\nGenerating public/private rsa key pair.\nEnter file in which to save the key (/home/oracle/.ssh/id_rsa):\nEnter passphrase (empty for no passphrase):\nEnter same passphrase again:\nYour identification has been saved in /home/oracle/.ssh/id_rsa.\nYour public key has been saved in /home/oracle/.ssh/id_rsa.pub.\nThe key fingerprint is:\ne9:2b:1a:2b:ac:5f:91:be:0f:84:17:d7:bd:b7:15:d2 oracle@linuxrac1\n[oracle @linuxrac1 ~]$ssh-keygen -t dsa\nGenerating public/private dsa key pair.\nEnter file in which to save the key (/home/oracle/.ssh/id_dsa):\nEnter passphrase (empty for no passphrase):\nEnter same passphrase again:\nYour identification has been saved in /home/oracle/.ssh/id_dsa.\nYour public key has been saved in /home/oracle/.ssh/id_dsa.pub.\nThe key fingerprint is:\nf5:0f:f5:0c:55:37:6a:08:ef:06:07:37:65:25:4a:15 oracle@linuxrac1\n \nlinuxrac2\n[oracle @linuxrac2 ~]$ mkdir ~/.ssh\n[oracle @linuxrac2 ~]$ chmod 755 ~/.ssh\n[oracle @linuxrac2 ~]$ ssh-keygen -t rsa\nGenerating public/private rsa key pair.\nEnter file in which to save the key (/home/oracle/.ssh/id_rsa):\nEnter passphrase (empty for no passphrase):\nEnter same passphrase again:\nYour identification has been saved in /home/oracle/.ssh/id_rsa.\nYour public key has been saved in /home/oracle/.ssh/id_rsa.pub.\nThe key fingerprint is:\n56:47:a0:94:67:44:d9:31:12:57:44:08:9d:84:25:a1 oracle@linuxrac2\n \n[oracle @linuxrac2 ~]$ ssh-keygen -t dsa\nGenerating public/private dsa key pair.\nEnter file in which to save the key (/home/oracle/.ssh/id_dsa):\nEnter passphrase (empty for no passphrase):\nEnter same passphrase again:\nYour identification has been saved in /home/oracle/.ssh/id_dsa.\nYour public key has been saved in /home/oracle/.ssh/id_dsa.pub.\nThe key fingerprint is:\nae:f0:06:77:62:33:86:dc:f4:0d:d9:c6:38:5e:cb:61 oracle@linuxrac2\n \n以上用默认配置,一路回车即可\nlinuxrac1\ncat ~/.ssh/*.pub >> ~/.ssh/authorized_keys\nssh oracle@linuxrac2 cat ~/.ssh/*.pub >> ~/.ssh/authorized_keys\n或\nssh oracle@linuxrac2 cat ~/.ssh/id_rsa.pub >> ~/.ssh/authorized_keys\nssh oracle@linuxrac2 cat ~/.ssh/id_dsa.pub >> ~/.ssh/authorized_keys\n[oracle@linuxrac1 ~]$ cd .ssh\n[oracle@linuxrac1 .ssh]$ ll\ntotal 48\n-rw-r--r-- 1 oracle oinstall 2008 Sep 25 02:20 authorized_keys\n-rw------- 1 oracle oinstall  668 Sep 25 02:09 id_dsa\n-rw-r--r-- 1 oracle oinstall  606 Sep 25 02:09 id_dsa.pub\n-rw------- 1 oracle oinstall 1675 Sep 25 02:09 id_rsa\n-rw-r--r-- 1 oracle oinstall  398 Sep 25 02:09 id_rsa.pub\n-rw-r--r-- 1 oracle oinstall  404 Sep 25 02:20 known_hosts\nlinuxrac2\ncat ~/.ssh/*.pub >> ~/.ssh/authorized_keys\nssh oracle@linuxrac1 cat ~/.ssh/*.pub >> ~/.ssh/authorized_keys\n或\nssh oracle@linuxrac1 cat ~/.ssh/id_rsa.pub >> ~/.ssh/authorized_keys\nssh oracle@linuxrac1 cat ~/.ssh/id_dsa.pub >> ~/.ssh/authorized_keys\n \n\n建立等效性 rac1,rac2双节点执行\n[oracle@linuxrac1 ~]$ exec ssh-agent $SHELL\n[oracle@linuxrac1 ~]$ ssh-add\nIdentity added: /home/oracle/.ssh/id_rsa (/home/oracle/.ssh/id_rsa)\nIdentity added: /home/oracle/.ssh/id_dsa (/home/oracle/.ssh/id_dsa)\n[oracle@linuxrac1 ~]$ ssh linuxrac1 date\n[oracle@linuxrac1 ~]$ ssh linuxrac1-priv date\n[oracle@linuxrac1 ~]$ ssh linuxrac2 date\n[oracle@linuxrac1 ~]$ ssh linuxrac2-priv date\n \n[oracle@linuxrac2 ~]$ exec ssh-agent $SHELL\n[oracle@linuxrac2 ~]$ ssh-add\nIdentity added: /home/oracle/.ssh/id_rsa (/home/oracle/.ssh/id_rsa)\nIdentity added: /home/oracle/.ssh/id_dsa (/home/oracle/.ssh/id_dsa)\n\nThe authenticity of host '<host>' can't be established.  \n解决办法：在连接目标机上执行ssh  -o StrictHostKeyChecking=no  xxxx(机器名)\n\n\n\n","source":"_posts/linux/SSH用户等效性配置.md","raw":"---\ntitle: SSH用户等效性配置\ndate: 2016-05-20 14:43:49\ntags: [linux]\ncategories: [linux,linux基本配置]\n---\n#SSH用户等效性配置 #\n以下均以oracle用户执行\nlinuxrac1\n[oracle @linuxrac1 ~]$mkdir ~/.ssh\n[oracle @linuxrac1 ~]$chmod 755 ~/.ssh\n[oracle @linuxrac1 ~]$ssh-keygen -t rsa\nGenerating public/private rsa key pair.\nEnter file in which to save the key (/home/oracle/.ssh/id_rsa):\nEnter passphrase (empty for no passphrase):\nEnter same passphrase again:\nYour identification has been saved in /home/oracle/.ssh/id_rsa.\nYour public key has been saved in /home/oracle/.ssh/id_rsa.pub.\nThe key fingerprint is:\ne9:2b:1a:2b:ac:5f:91:be:0f:84:17:d7:bd:b7:15:d2 oracle@linuxrac1\n[oracle @linuxrac1 ~]$ssh-keygen -t dsa\nGenerating public/private dsa key pair.\nEnter file in which to save the key (/home/oracle/.ssh/id_dsa):\nEnter passphrase (empty for no passphrase):\nEnter same passphrase again:\nYour identification has been saved in /home/oracle/.ssh/id_dsa.\nYour public key has been saved in /home/oracle/.ssh/id_dsa.pub.\nThe key fingerprint is:\nf5:0f:f5:0c:55:37:6a:08:ef:06:07:37:65:25:4a:15 oracle@linuxrac1\n \nlinuxrac2\n[oracle @linuxrac2 ~]$ mkdir ~/.ssh\n[oracle @linuxrac2 ~]$ chmod 755 ~/.ssh\n[oracle @linuxrac2 ~]$ ssh-keygen -t rsa\nGenerating public/private rsa key pair.\nEnter file in which to save the key (/home/oracle/.ssh/id_rsa):\nEnter passphrase (empty for no passphrase):\nEnter same passphrase again:\nYour identification has been saved in /home/oracle/.ssh/id_rsa.\nYour public key has been saved in /home/oracle/.ssh/id_rsa.pub.\nThe key fingerprint is:\n56:47:a0:94:67:44:d9:31:12:57:44:08:9d:84:25:a1 oracle@linuxrac2\n \n[oracle @linuxrac2 ~]$ ssh-keygen -t dsa\nGenerating public/private dsa key pair.\nEnter file in which to save the key (/home/oracle/.ssh/id_dsa):\nEnter passphrase (empty for no passphrase):\nEnter same passphrase again:\nYour identification has been saved in /home/oracle/.ssh/id_dsa.\nYour public key has been saved in /home/oracle/.ssh/id_dsa.pub.\nThe key fingerprint is:\nae:f0:06:77:62:33:86:dc:f4:0d:d9:c6:38:5e:cb:61 oracle@linuxrac2\n \n以上用默认配置,一路回车即可\nlinuxrac1\ncat ~/.ssh/*.pub >> ~/.ssh/authorized_keys\nssh oracle@linuxrac2 cat ~/.ssh/*.pub >> ~/.ssh/authorized_keys\n或\nssh oracle@linuxrac2 cat ~/.ssh/id_rsa.pub >> ~/.ssh/authorized_keys\nssh oracle@linuxrac2 cat ~/.ssh/id_dsa.pub >> ~/.ssh/authorized_keys\n[oracle@linuxrac1 ~]$ cd .ssh\n[oracle@linuxrac1 .ssh]$ ll\ntotal 48\n-rw-r--r-- 1 oracle oinstall 2008 Sep 25 02:20 authorized_keys\n-rw------- 1 oracle oinstall  668 Sep 25 02:09 id_dsa\n-rw-r--r-- 1 oracle oinstall  606 Sep 25 02:09 id_dsa.pub\n-rw------- 1 oracle oinstall 1675 Sep 25 02:09 id_rsa\n-rw-r--r-- 1 oracle oinstall  398 Sep 25 02:09 id_rsa.pub\n-rw-r--r-- 1 oracle oinstall  404 Sep 25 02:20 known_hosts\nlinuxrac2\ncat ~/.ssh/*.pub >> ~/.ssh/authorized_keys\nssh oracle@linuxrac1 cat ~/.ssh/*.pub >> ~/.ssh/authorized_keys\n或\nssh oracle@linuxrac1 cat ~/.ssh/id_rsa.pub >> ~/.ssh/authorized_keys\nssh oracle@linuxrac1 cat ~/.ssh/id_dsa.pub >> ~/.ssh/authorized_keys\n \n\n建立等效性 rac1,rac2双节点执行\n[oracle@linuxrac1 ~]$ exec ssh-agent $SHELL\n[oracle@linuxrac1 ~]$ ssh-add\nIdentity added: /home/oracle/.ssh/id_rsa (/home/oracle/.ssh/id_rsa)\nIdentity added: /home/oracle/.ssh/id_dsa (/home/oracle/.ssh/id_dsa)\n[oracle@linuxrac1 ~]$ ssh linuxrac1 date\n[oracle@linuxrac1 ~]$ ssh linuxrac1-priv date\n[oracle@linuxrac1 ~]$ ssh linuxrac2 date\n[oracle@linuxrac1 ~]$ ssh linuxrac2-priv date\n \n[oracle@linuxrac2 ~]$ exec ssh-agent $SHELL\n[oracle@linuxrac2 ~]$ ssh-add\nIdentity added: /home/oracle/.ssh/id_rsa (/home/oracle/.ssh/id_rsa)\nIdentity added: /home/oracle/.ssh/id_dsa (/home/oracle/.ssh/id_dsa)\n\nThe authenticity of host '<host>' can't be established.  \n解决办法：在连接目标机上执行ssh  -o StrictHostKeyChecking=no  xxxx(机器名)\n\n\n\n","slug":"linux/SSH用户等效性配置","published":1,"updated":"2017-08-18T01:44:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bji001bs77rnx4mfz0q","content":"<p>#SSH用户等效性配置 #<br>以下均以oracle用户执行<br>linuxrac1<br>[oracle @linuxrac1 ~]$mkdir ~/.ssh<br>[oracle @linuxrac1 ~]$chmod 755 ~/.ssh<br>[oracle @linuxrac1 ~]$ssh-keygen -t rsa<br>Generating public/private rsa key pair.<br>Enter file in which to save the key (/home/oracle/.ssh/id_rsa):<br>Enter passphrase (empty for no passphrase):<br>Enter same passphrase again:<br>Your identification has been saved in /home/oracle/.ssh/id_rsa.<br>Your public key has been saved in /home/oracle/.ssh/id_rsa.pub.<br>The key fingerprint is:<br>e9:2b:1a:2b:ac:5f:91:be:0f:84:17:d7:bd:b7:15:d2 oracle@linuxrac1<br>[oracle @linuxrac1 ~]$ssh-keygen -t dsa<br>Generating public/private dsa key pair.<br>Enter file in which to save the key (/home/oracle/.ssh/id_dsa):<br>Enter passphrase (empty for no passphrase):<br>Enter same passphrase again:<br>Your identification has been saved in /home/oracle/.ssh/id_dsa.<br>Your public key has been saved in /home/oracle/.ssh/id_dsa.pub.<br>The key fingerprint is:<br>f5:0f:f5:0c:55:37:6a:08:ef:06:07:37:65:25:4a:15 oracle@linuxrac1</p>\n<p>linuxrac2<br>[oracle @linuxrac2 ~]$ mkdir ~/.ssh<br>[oracle @linuxrac2 ~]$ chmod 755 ~/.ssh<br>[oracle @linuxrac2 ~]$ ssh-keygen -t rsa<br>Generating public/private rsa key pair.<br>Enter file in which to save the key (/home/oracle/.ssh/id_rsa):<br>Enter passphrase (empty for no passphrase):<br>Enter same passphrase again:<br>Your identification has been saved in /home/oracle/.ssh/id_rsa.<br>Your public key has been saved in /home/oracle/.ssh/id_rsa.pub.<br>The key fingerprint is:<br>56:47:a0:94:67:44:d9:31:12:57:44:08:9d:84:25:a1 oracle@linuxrac2</p>\n<p>[oracle @linuxrac2 ~]$ ssh-keygen -t dsa<br>Generating public/private dsa key pair.<br>Enter file in which to save the key (/home/oracle/.ssh/id_dsa):<br>Enter passphrase (empty for no passphrase):<br>Enter same passphrase again:<br>Your identification has been saved in /home/oracle/.ssh/id_dsa.<br>Your public key has been saved in /home/oracle/.ssh/id_dsa.pub.<br>The key fingerprint is:<br>ae:f0:06:77:62:33:86:dc:f4:0d:d9:c6:38:5e:cb:61 oracle@linuxrac2</p>\n<p>以上用默认配置,一路回车即可<br>linuxrac1<br>cat ~/.ssh/<em>.pub &gt;&gt; ~/.ssh/authorized_keys<br>ssh oracle@linuxrac2 cat ~/.ssh/</em>.pub &gt;&gt; ~/.ssh/authorized_keys<br>或<br>ssh oracle@linuxrac2 cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys<br>ssh oracle@linuxrac2 cat ~/.ssh/id_dsa.pub &gt;&gt; ~/.ssh/authorized_keys<br>[oracle@linuxrac1 ~]$ cd .ssh<br>[oracle@linuxrac1 .ssh]$ ll<br>total 48<br>-rw-r–r– 1 oracle oinstall 2008 Sep 25 02:20 authorized_keys<br>-rw——- 1 oracle oinstall  668 Sep 25 02:09 id_dsa<br>-rw-r–r– 1 oracle oinstall  606 Sep 25 02:09 id_dsa.pub<br>-rw——- 1 oracle oinstall 1675 Sep 25 02:09 id_rsa<br>-rw-r–r– 1 oracle oinstall  398 Sep 25 02:09 id_rsa.pub<br>-rw-r–r– 1 oracle oinstall  404 Sep 25 02:20 known_hosts<br>linuxrac2<br>cat ~/.ssh/<em>.pub &gt;&gt; ~/.ssh/authorized_keys<br>ssh oracle@linuxrac1 cat ~/.ssh/</em>.pub &gt;&gt; ~/.ssh/authorized_keys<br>或<br>ssh oracle@linuxrac1 cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys<br>ssh oracle@linuxrac1 cat ~/.ssh/id_dsa.pub &gt;&gt; ~/.ssh/authorized_keys</p>\n<p>建立等效性 rac1,rac2双节点执行<br>[oracle@linuxrac1 ~]$ exec ssh-agent $SHELL<br>[oracle@linuxrac1 ~]$ ssh-add<br>Identity added: /home/oracle/.ssh/id_rsa (/home/oracle/.ssh/id_rsa)<br>Identity added: /home/oracle/.ssh/id_dsa (/home/oracle/.ssh/id_dsa)<br>[oracle@linuxrac1 ~]$ ssh linuxrac1 date<br>[oracle@linuxrac1 ~]$ ssh linuxrac1-priv date<br>[oracle@linuxrac1 ~]$ ssh linuxrac2 date<br>[oracle@linuxrac1 ~]$ ssh linuxrac2-priv date</p>\n<p>[oracle@linuxrac2 ~]$ exec ssh-agent $SHELL<br>[oracle@linuxrac2 ~]$ ssh-add<br>Identity added: /home/oracle/.ssh/id_rsa (/home/oracle/.ssh/id_rsa)<br>Identity added: /home/oracle/.ssh/id_dsa (/home/oracle/.ssh/id_dsa)</p>\n<p>The authenticity of host ‘<host>‘ can’t be established.<br>解决办法：在连接目标机上执行ssh  -o StrictHostKeyChecking=no  xxxx(机器名)</host></p>\n","site":{"data":{}},"excerpt":"","more":"<p>#SSH用户等效性配置 #<br>以下均以oracle用户执行<br>linuxrac1<br>[oracle @linuxrac1 ~]$mkdir ~/.ssh<br>[oracle @linuxrac1 ~]$chmod 755 ~/.ssh<br>[oracle @linuxrac1 ~]$ssh-keygen -t rsa<br>Generating public/private rsa key pair.<br>Enter file in which to save the key (/home/oracle/.ssh/id_rsa):<br>Enter passphrase (empty for no passphrase):<br>Enter same passphrase again:<br>Your identification has been saved in /home/oracle/.ssh/id_rsa.<br>Your public key has been saved in /home/oracle/.ssh/id_rsa.pub.<br>The key fingerprint is:<br>e9:2b:1a:2b:ac:5f:91:be:0f:84:17:d7:bd:b7:15:d2 oracle@linuxrac1<br>[oracle @linuxrac1 ~]$ssh-keygen -t dsa<br>Generating public/private dsa key pair.<br>Enter file in which to save the key (/home/oracle/.ssh/id_dsa):<br>Enter passphrase (empty for no passphrase):<br>Enter same passphrase again:<br>Your identification has been saved in /home/oracle/.ssh/id_dsa.<br>Your public key has been saved in /home/oracle/.ssh/id_dsa.pub.<br>The key fingerprint is:<br>f5:0f:f5:0c:55:37:6a:08:ef:06:07:37:65:25:4a:15 oracle@linuxrac1</p>\n<p>linuxrac2<br>[oracle @linuxrac2 ~]$ mkdir ~/.ssh<br>[oracle @linuxrac2 ~]$ chmod 755 ~/.ssh<br>[oracle @linuxrac2 ~]$ ssh-keygen -t rsa<br>Generating public/private rsa key pair.<br>Enter file in which to save the key (/home/oracle/.ssh/id_rsa):<br>Enter passphrase (empty for no passphrase):<br>Enter same passphrase again:<br>Your identification has been saved in /home/oracle/.ssh/id_rsa.<br>Your public key has been saved in /home/oracle/.ssh/id_rsa.pub.<br>The key fingerprint is:<br>56:47:a0:94:67:44:d9:31:12:57:44:08:9d:84:25:a1 oracle@linuxrac2</p>\n<p>[oracle @linuxrac2 ~]$ ssh-keygen -t dsa<br>Generating public/private dsa key pair.<br>Enter file in which to save the key (/home/oracle/.ssh/id_dsa):<br>Enter passphrase (empty for no passphrase):<br>Enter same passphrase again:<br>Your identification has been saved in /home/oracle/.ssh/id_dsa.<br>Your public key has been saved in /home/oracle/.ssh/id_dsa.pub.<br>The key fingerprint is:<br>ae:f0:06:77:62:33:86:dc:f4:0d:d9:c6:38:5e:cb:61 oracle@linuxrac2</p>\n<p>以上用默认配置,一路回车即可<br>linuxrac1<br>cat ~/.ssh/<em>.pub &gt;&gt; ~/.ssh/authorized_keys<br>ssh oracle@linuxrac2 cat ~/.ssh/</em>.pub &gt;&gt; ~/.ssh/authorized_keys<br>或<br>ssh oracle@linuxrac2 cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys<br>ssh oracle@linuxrac2 cat ~/.ssh/id_dsa.pub &gt;&gt; ~/.ssh/authorized_keys<br>[oracle@linuxrac1 ~]$ cd .ssh<br>[oracle@linuxrac1 .ssh]$ ll<br>total 48<br>-rw-r–r– 1 oracle oinstall 2008 Sep 25 02:20 authorized_keys<br>-rw——- 1 oracle oinstall  668 Sep 25 02:09 id_dsa<br>-rw-r–r– 1 oracle oinstall  606 Sep 25 02:09 id_dsa.pub<br>-rw——- 1 oracle oinstall 1675 Sep 25 02:09 id_rsa<br>-rw-r–r– 1 oracle oinstall  398 Sep 25 02:09 id_rsa.pub<br>-rw-r–r– 1 oracle oinstall  404 Sep 25 02:20 known_hosts<br>linuxrac2<br>cat ~/.ssh/<em>.pub &gt;&gt; ~/.ssh/authorized_keys<br>ssh oracle@linuxrac1 cat ~/.ssh/</em>.pub &gt;&gt; ~/.ssh/authorized_keys<br>或<br>ssh oracle@linuxrac1 cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys<br>ssh oracle@linuxrac1 cat ~/.ssh/id_dsa.pub &gt;&gt; ~/.ssh/authorized_keys</p>\n<p>建立等效性 rac1,rac2双节点执行<br>[oracle@linuxrac1 ~]$ exec ssh-agent $SHELL<br>[oracle@linuxrac1 ~]$ ssh-add<br>Identity added: /home/oracle/.ssh/id_rsa (/home/oracle/.ssh/id_rsa)<br>Identity added: /home/oracle/.ssh/id_dsa (/home/oracle/.ssh/id_dsa)<br>[oracle@linuxrac1 ~]$ ssh linuxrac1 date<br>[oracle@linuxrac1 ~]$ ssh linuxrac1-priv date<br>[oracle@linuxrac1 ~]$ ssh linuxrac2 date<br>[oracle@linuxrac1 ~]$ ssh linuxrac2-priv date</p>\n<p>[oracle@linuxrac2 ~]$ exec ssh-agent $SHELL<br>[oracle@linuxrac2 ~]$ ssh-add<br>Identity added: /home/oracle/.ssh/id_rsa (/home/oracle/.ssh/id_rsa)<br>Identity added: /home/oracle/.ssh/id_dsa (/home/oracle/.ssh/id_dsa)</p>\n<p>The authenticity of host ‘<host>‘ can’t be established.<br>解决办法：在连接目标机上执行ssh  -o StrictHostKeyChecking=no  xxxx(机器名)</host></p>\n"},{"title":"TODO-Oracle SQL优化","date":"2016-12-31T16:00:00.000Z","_content":"","source":"_posts/oracle/Oracle SQL优化.md","raw":"---\ntitle: TODO-Oracle SQL优化\ndate: 2017-01-01 00:00:00\ntags: [oracle,数据库]\ncategories: [数据库,oracle]\n---\n","slug":"oracle/Oracle SQL优化","published":1,"updated":"2017-08-18T01:44:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bjj001fs77rlm5ukqfo","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"TODO-Oracle数据库系统架构","date":"2016-12-31T16:00:00.000Z","_content":"","source":"_posts/oracle/Oracle数据库系统架构.md","raw":"---\ntitle: TODO-Oracle数据库系统架构\ndate: 2017-01-01 00:00:00\ntags: [oracle,数据库]\ncategories: [数据库,oracle]\n---\n","slug":"oracle/Oracle数据库系统架构","published":1,"updated":"2017-08-18T01:44:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bjk001gs77rdhrcfyhi","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"消息传送基础","date":"2016-05-21T15:43:49.000Z","_content":"\n#二进制串：RAW类型 #\n\n文章摘自《Oracle Database 9i10g11g编程艺术 深入数据库体系结构（第2版）》\n\n    Oracle除了支持文本，还支持二进制数据的存储。前面讨论了CHAR和VARCHAR2类型需要进行字符集转换，而二进制数据不会做这种字符集转换。因此，二进制数据类型不适合存储用户提供的文本，而适于存储加密信息，加密数据不是“文本”，而是原文本的一个二进制表示、包含二进制标记信息的字处理文档，等等。如果数据库不认为某些数据是“文本”(或任意其他基本数据类型，如，数值型、日期型等)，这些数据就应该采用一种二进制数据类型来存储，另外不应该应用字符集转换的数据也要使用二进制数据类型存储。\n\nOracle支持下面3种数据类型来存储二进制数据。\nA.  RAW类型，这是这一节强调的重点，它很适合存储多达2000字节的RAW数据。\nB.  BLOB类型，它支持更大的二进制数据，我们将在12.7节中再做介绍。\nC.  LONG　RAW类型，这是为支持向后兼容性提供的，新应用不应考虑使用这个类型。\n\n二进制RAW类型的语法很简单：\nRAW(<size>)\n例如，以下代码创建了一个每行能存储16字节二进制信息的表：\nSQL> create table t(raw_data raw(16));\nTable created.\nSQL>\nOps$tkyte@ORA11GR2>create table t(raw_data raw(16));\nTable created.\n    从磁盘上的存储来看，RAW类型与VARCHAR2类型很相似。RAW类型是一个变长的二进制串，这说明前面创建的表T可以存储0-16字节的二进制数据。它不会像CHAR类型那样用空格填充。\n    处理RAW数据时，你可能会发现它被隐式地转换为一个VARCHAR2类型，也就是说，诸如SQL*Plus之类的许多工具不会直接显示RAW数据，而是会将其转换为一种十六进制格式来显示，在以下例子中，我们使用SYS_GUID()在表中创建一些二进制数据，SYS_GUID()是一个内置函数，将返回一个全局唯一的16字节RAW串(GUID就代表全局唯一标识符，Globally Unique Identifier)：\n\nSQL> insert into t values(sys_guid());\nRAW_DATA\n--------------------------------\n370798BAA57BEAF0E05001A8653002BE\nSQL>\n\n    在此，你会马上注意到两点。首先，RAW数据看上去就像是一个字符串。SQL*Plus就是以字符串形式获取和打印RAW数据，但是RAW数据在磁盘上并不存储为字符串。SQL*Plus不能在屏幕上打印任意的二进制数据，因为这可能对显示有严重的副作用。要记住，二进制数据可能包含诸如回车或换行等控制字符，还可能是一个Ctrl+G字符，这会导致终端发出”嘟嘟“的叫声。\n    其次，RAW数据看上去远远大于16字节，实际上，在这个例子中，你会看到32个字符。这是因为，每个二进制字节都显示为两个十六进制字符。所存储的RAW数据其实长度就是16字节，可以使用Oracle DUMP函数确认这一点。在此，我转储了这个二进制串的值，并使用了一个可选参数来指定显示各个字节值时应使用哪一种进制。这里使用了基数16，从而能将转储的结果与前面的串进行比较：\n\nSQL> select dump(raw_data,16) from t;\nDUMP(RAW_DATA,16)\n----------------------------------------------\nTyp=23 Len=16: 37,7,98,ba,a5,7b,ea,f0,e0,50,1,a8,65,30,2,be\nSQL>\n\nDUMP显示出，这个二进制串实际上长度为16字节（LEN=16）,另外还逐字节地显示了这个二进制数据。可以看到，这个转储显示与SQL*Plus将RAW数据获取为一个串时所执行的隐式转换是匹配的。\n另一个方向上（插入）也会执行隐式转换：\nSQL> insert into t values( 'abcdef' ); \n1 row created.\n\n    这不会插入串abcdef，而会插入一个3字节的RAW数据，其字节分别是AB、CD、EF，如果用十进制表示则为字节171、205、239。如果试图使用一个包含非法16进制字符的串，就会收到一个错误消息：\n\nSQL> insert into t values( 'abcdefgh' );\ninsert into t values( 'abcdefgh' )\n                            *\nERROR at line 1:\nORA-01465: invalid hex number\nSQL>\n\n    RAW类型可以加索引，还能在谓词中使用，它与其他任何数据类型有同样的功能。不过，必须当心避免不希望的隐式转换，而且必须知道确实会发生隐式转换。\n    在任何情况下我都喜欢使用显式转换，而且推荐这种做法，可以使用以下内置函数来执行这种操作。\nA.  HEXTORAW：将十六进制字符串转换为RAW类型。\nB.  RAWTOHEX：将RAW串转换为十六进制串。\nSQL*Plus将RAW类型获取为一个串时，会隐式地调用RWATOHEX函数，而插入串时会隐式地调用HEXTORAW函数。应该避免隐式转换，而在编写代码时总是使用显式转换，这是一个很好的实践做法。\n所以当前的例子应该写作：\nSQL> select rawtohex(raw_data) from t\nRAWTOHEX(RAW_DATA)\n--------------------------------\n370798BAA57BEAF0E05001A8653002BE\nABCDEF\nSQL> insert into t values( hextoraw('abcdef') );\n1 row created.\n\n","source":"_posts/oracle/RAW类型.md","raw":"---\ntitle: 消息传送基础\ndate: 2016-05-21 23:43:49\ntags: [oracle,数据库]\ncategories: [数据库,oracle]\n---\n\n#二进制串：RAW类型 #\n\n文章摘自《Oracle Database 9i10g11g编程艺术 深入数据库体系结构（第2版）》\n\n    Oracle除了支持文本，还支持二进制数据的存储。前面讨论了CHAR和VARCHAR2类型需要进行字符集转换，而二进制数据不会做这种字符集转换。因此，二进制数据类型不适合存储用户提供的文本，而适于存储加密信息，加密数据不是“文本”，而是原文本的一个二进制表示、包含二进制标记信息的字处理文档，等等。如果数据库不认为某些数据是“文本”(或任意其他基本数据类型，如，数值型、日期型等)，这些数据就应该采用一种二进制数据类型来存储，另外不应该应用字符集转换的数据也要使用二进制数据类型存储。\n\nOracle支持下面3种数据类型来存储二进制数据。\nA.  RAW类型，这是这一节强调的重点，它很适合存储多达2000字节的RAW数据。\nB.  BLOB类型，它支持更大的二进制数据，我们将在12.7节中再做介绍。\nC.  LONG　RAW类型，这是为支持向后兼容性提供的，新应用不应考虑使用这个类型。\n\n二进制RAW类型的语法很简单：\nRAW(<size>)\n例如，以下代码创建了一个每行能存储16字节二进制信息的表：\nSQL> create table t(raw_data raw(16));\nTable created.\nSQL>\nOps$tkyte@ORA11GR2>create table t(raw_data raw(16));\nTable created.\n    从磁盘上的存储来看，RAW类型与VARCHAR2类型很相似。RAW类型是一个变长的二进制串，这说明前面创建的表T可以存储0-16字节的二进制数据。它不会像CHAR类型那样用空格填充。\n    处理RAW数据时，你可能会发现它被隐式地转换为一个VARCHAR2类型，也就是说，诸如SQL*Plus之类的许多工具不会直接显示RAW数据，而是会将其转换为一种十六进制格式来显示，在以下例子中，我们使用SYS_GUID()在表中创建一些二进制数据，SYS_GUID()是一个内置函数，将返回一个全局唯一的16字节RAW串(GUID就代表全局唯一标识符，Globally Unique Identifier)：\n\nSQL> insert into t values(sys_guid());\nRAW_DATA\n--------------------------------\n370798BAA57BEAF0E05001A8653002BE\nSQL>\n\n    在此，你会马上注意到两点。首先，RAW数据看上去就像是一个字符串。SQL*Plus就是以字符串形式获取和打印RAW数据，但是RAW数据在磁盘上并不存储为字符串。SQL*Plus不能在屏幕上打印任意的二进制数据，因为这可能对显示有严重的副作用。要记住，二进制数据可能包含诸如回车或换行等控制字符，还可能是一个Ctrl+G字符，这会导致终端发出”嘟嘟“的叫声。\n    其次，RAW数据看上去远远大于16字节，实际上，在这个例子中，你会看到32个字符。这是因为，每个二进制字节都显示为两个十六进制字符。所存储的RAW数据其实长度就是16字节，可以使用Oracle DUMP函数确认这一点。在此，我转储了这个二进制串的值，并使用了一个可选参数来指定显示各个字节值时应使用哪一种进制。这里使用了基数16，从而能将转储的结果与前面的串进行比较：\n\nSQL> select dump(raw_data,16) from t;\nDUMP(RAW_DATA,16)\n----------------------------------------------\nTyp=23 Len=16: 37,7,98,ba,a5,7b,ea,f0,e0,50,1,a8,65,30,2,be\nSQL>\n\nDUMP显示出，这个二进制串实际上长度为16字节（LEN=16）,另外还逐字节地显示了这个二进制数据。可以看到，这个转储显示与SQL*Plus将RAW数据获取为一个串时所执行的隐式转换是匹配的。\n另一个方向上（插入）也会执行隐式转换：\nSQL> insert into t values( 'abcdef' ); \n1 row created.\n\n    这不会插入串abcdef，而会插入一个3字节的RAW数据，其字节分别是AB、CD、EF，如果用十进制表示则为字节171、205、239。如果试图使用一个包含非法16进制字符的串，就会收到一个错误消息：\n\nSQL> insert into t values( 'abcdefgh' );\ninsert into t values( 'abcdefgh' )\n                            *\nERROR at line 1:\nORA-01465: invalid hex number\nSQL>\n\n    RAW类型可以加索引，还能在谓词中使用，它与其他任何数据类型有同样的功能。不过，必须当心避免不希望的隐式转换，而且必须知道确实会发生隐式转换。\n    在任何情况下我都喜欢使用显式转换，而且推荐这种做法，可以使用以下内置函数来执行这种操作。\nA.  HEXTORAW：将十六进制字符串转换为RAW类型。\nB.  RAWTOHEX：将RAW串转换为十六进制串。\nSQL*Plus将RAW类型获取为一个串时，会隐式地调用RWATOHEX函数，而插入串时会隐式地调用HEXTORAW函数。应该避免隐式转换，而在编写代码时总是使用显式转换，这是一个很好的实践做法。\n所以当前的例子应该写作：\nSQL> select rawtohex(raw_data) from t\nRAWTOHEX(RAW_DATA)\n--------------------------------\n370798BAA57BEAF0E05001A8653002BE\nABCDEF\nSQL> insert into t values( hextoraw('abcdef') );\n1 row created.\n\n","slug":"oracle/RAW类型","published":1,"updated":"2017-08-18T01:44:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bjl001js77roqdxkcs3","content":"<p>#二进制串：RAW类型 #</p>\n<p>文章摘自《Oracle Database 9i10g11g编程艺术 深入数据库体系结构（第2版）》</p>\n<pre><code>Oracle除了支持文本，还支持二进制数据的存储。前面讨论了CHAR和VARCHAR2类型需要进行字符集转换，而二进制数据不会做这种字符集转换。因此，二进制数据类型不适合存储用户提供的文本，而适于存储加密信息，加密数据不是“文本”，而是原文本的一个二进制表示、包含二进制标记信息的字处理文档，等等。如果数据库不认为某些数据是“文本”(或任意其他基本数据类型，如，数值型、日期型等)，这些数据就应该采用一种二进制数据类型来存储，另外不应该应用字符集转换的数据也要使用二进制数据类型存储。\n</code></pre><p>Oracle支持下面3种数据类型来存储二进制数据。<br>A.  RAW类型，这是这一节强调的重点，它很适合存储多达2000字节的RAW数据。<br>B.  BLOB类型，它支持更大的二进制数据，我们将在12.7节中再做介绍。<br>C.  LONG　RAW类型，这是为支持向后兼容性提供的，新应用不应考虑使用这个类型。</p>\n<p>二进制RAW类型的语法很简单：<br>RAW(<size>)<br>例如，以下代码创建了一个每行能存储16字节二进制信息的表：<br>SQL&gt; create table t(raw_data raw(16));<br>Table created.<br>SQL&gt;<br>Ops$tkyte@ORA11GR2&gt;create table t(raw_data raw(16));<br>Table created.<br>    从磁盘上的存储来看，RAW类型与VARCHAR2类型很相似。RAW类型是一个变长的二进制串，这说明前面创建的表T可以存储0-16字节的二进制数据。它不会像CHAR类型那样用空格填充。<br>    处理RAW数据时，你可能会发现它被隐式地转换为一个VARCHAR2类型，也就是说，诸如SQL*Plus之类的许多工具不会直接显示RAW数据，而是会将其转换为一种十六进制格式来显示，在以下例子中，我们使用SYS_GUID()在表中创建一些二进制数据，SYS_GUID()是一个内置函数，将返回一个全局唯一的16字节RAW串(GUID就代表全局唯一标识符，Globally Unique Identifier)：</size></p>\n<p>SQL&gt; insert into t values(sys_guid());</p>\n<h2 id=\"RAW-DATA\"><a href=\"#RAW-DATA\" class=\"headerlink\" title=\"RAW_DATA\"></a>RAW_DATA</h2><p>370798BAA57BEAF0E05001A8653002BE<br>SQL&gt;</p>\n<pre><code>在此，你会马上注意到两点。首先，RAW数据看上去就像是一个字符串。SQL*Plus就是以字符串形式获取和打印RAW数据，但是RAW数据在磁盘上并不存储为字符串。SQL*Plus不能在屏幕上打印任意的二进制数据，因为这可能对显示有严重的副作用。要记住，二进制数据可能包含诸如回车或换行等控制字符，还可能是一个Ctrl+G字符，这会导致终端发出”嘟嘟“的叫声。\n其次，RAW数据看上去远远大于16字节，实际上，在这个例子中，你会看到32个字符。这是因为，每个二进制字节都显示为两个十六进制字符。所存储的RAW数据其实长度就是16字节，可以使用Oracle DUMP函数确认这一点。在此，我转储了这个二进制串的值，并使用了一个可选参数来指定显示各个字节值时应使用哪一种进制。这里使用了基数16，从而能将转储的结果与前面的串进行比较：\n</code></pre><p>SQL&gt; select dump(raw_data,16) from t;</p>\n<h2 id=\"DUMP-RAW-DATA-16\"><a href=\"#DUMP-RAW-DATA-16\" class=\"headerlink\" title=\"DUMP(RAW_DATA,16)\"></a>DUMP(RAW_DATA,16)</h2><p>Typ=23 Len=16: 37,7,98,ba,a5,7b,ea,f0,e0,50,1,a8,65,30,2,be<br>SQL&gt;</p>\n<p>DUMP显示出，这个二进制串实际上长度为16字节（LEN=16）,另外还逐字节地显示了这个二进制数据。可以看到，这个转储显示与SQL*Plus将RAW数据获取为一个串时所执行的隐式转换是匹配的。<br>另一个方向上（插入）也会执行隐式转换：<br>SQL&gt; insert into t values( ‘abcdef’ );<br>1 row created.</p>\n<pre><code>这不会插入串abcdef，而会插入一个3字节的RAW数据，其字节分别是AB、CD、EF，如果用十进制表示则为字节171、205、239。如果试图使用一个包含非法16进制字符的串，就会收到一个错误消息：\n</code></pre><p>SQL&gt; insert into t values( ‘abcdefgh’ );<br>insert into t values( ‘abcdefgh’ )<br>                            *<br>ERROR at line 1:<br>ORA-01465: invalid hex number<br>SQL&gt;</p>\n<pre><code>RAW类型可以加索引，还能在谓词中使用，它与其他任何数据类型有同样的功能。不过，必须当心避免不希望的隐式转换，而且必须知道确实会发生隐式转换。\n在任何情况下我都喜欢使用显式转换，而且推荐这种做法，可以使用以下内置函数来执行这种操作。\n</code></pre><p>A.  HEXTORAW：将十六进制字符串转换为RAW类型。<br>B.  RAWTOHEX：将RAW串转换为十六进制串。<br>SQL*Plus将RAW类型获取为一个串时，会隐式地调用RWATOHEX函数，而插入串时会隐式地调用HEXTORAW函数。应该避免隐式转换，而在编写代码时总是使用显式转换，这是一个很好的实践做法。<br>所以当前的例子应该写作：<br>SQL&gt; select rawtohex(raw_data) from t</p>\n<h2 id=\"RAWTOHEX-RAW-DATA\"><a href=\"#RAWTOHEX-RAW-DATA\" class=\"headerlink\" title=\"RAWTOHEX(RAW_DATA)\"></a>RAWTOHEX(RAW_DATA)</h2><p>370798BAA57BEAF0E05001A8653002BE<br>ABCDEF<br>SQL&gt; insert into t values( hextoraw(‘abcdef’) );<br>1 row created.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>#二进制串：RAW类型 #</p>\n<p>文章摘自《Oracle Database 9i10g11g编程艺术 深入数据库体系结构（第2版）》</p>\n<pre><code>Oracle除了支持文本，还支持二进制数据的存储。前面讨论了CHAR和VARCHAR2类型需要进行字符集转换，而二进制数据不会做这种字符集转换。因此，二进制数据类型不适合存储用户提供的文本，而适于存储加密信息，加密数据不是“文本”，而是原文本的一个二进制表示、包含二进制标记信息的字处理文档，等等。如果数据库不认为某些数据是“文本”(或任意其他基本数据类型，如，数值型、日期型等)，这些数据就应该采用一种二进制数据类型来存储，另外不应该应用字符集转换的数据也要使用二进制数据类型存储。\n</code></pre><p>Oracle支持下面3种数据类型来存储二进制数据。<br>A.  RAW类型，这是这一节强调的重点，它很适合存储多达2000字节的RAW数据。<br>B.  BLOB类型，它支持更大的二进制数据，我们将在12.7节中再做介绍。<br>C.  LONG　RAW类型，这是为支持向后兼容性提供的，新应用不应考虑使用这个类型。</p>\n<p>二进制RAW类型的语法很简单：<br>RAW(<size>)<br>例如，以下代码创建了一个每行能存储16字节二进制信息的表：<br>SQL&gt; create table t(raw_data raw(16));<br>Table created.<br>SQL&gt;<br>Ops$tkyte@ORA11GR2&gt;create table t(raw_data raw(16));<br>Table created.<br>    从磁盘上的存储来看，RAW类型与VARCHAR2类型很相似。RAW类型是一个变长的二进制串，这说明前面创建的表T可以存储0-16字节的二进制数据。它不会像CHAR类型那样用空格填充。<br>    处理RAW数据时，你可能会发现它被隐式地转换为一个VARCHAR2类型，也就是说，诸如SQL*Plus之类的许多工具不会直接显示RAW数据，而是会将其转换为一种十六进制格式来显示，在以下例子中，我们使用SYS_GUID()在表中创建一些二进制数据，SYS_GUID()是一个内置函数，将返回一个全局唯一的16字节RAW串(GUID就代表全局唯一标识符，Globally Unique Identifier)：</size></p>\n<p>SQL&gt; insert into t values(sys_guid());</p>\n<h2 id=\"RAW-DATA\"><a href=\"#RAW-DATA\" class=\"headerlink\" title=\"RAW_DATA\"></a>RAW_DATA</h2><p>370798BAA57BEAF0E05001A8653002BE<br>SQL&gt;</p>\n<pre><code>在此，你会马上注意到两点。首先，RAW数据看上去就像是一个字符串。SQL*Plus就是以字符串形式获取和打印RAW数据，但是RAW数据在磁盘上并不存储为字符串。SQL*Plus不能在屏幕上打印任意的二进制数据，因为这可能对显示有严重的副作用。要记住，二进制数据可能包含诸如回车或换行等控制字符，还可能是一个Ctrl+G字符，这会导致终端发出”嘟嘟“的叫声。\n其次，RAW数据看上去远远大于16字节，实际上，在这个例子中，你会看到32个字符。这是因为，每个二进制字节都显示为两个十六进制字符。所存储的RAW数据其实长度就是16字节，可以使用Oracle DUMP函数确认这一点。在此，我转储了这个二进制串的值，并使用了一个可选参数来指定显示各个字节值时应使用哪一种进制。这里使用了基数16，从而能将转储的结果与前面的串进行比较：\n</code></pre><p>SQL&gt; select dump(raw_data,16) from t;</p>\n<h2 id=\"DUMP-RAW-DATA-16\"><a href=\"#DUMP-RAW-DATA-16\" class=\"headerlink\" title=\"DUMP(RAW_DATA,16)\"></a>DUMP(RAW_DATA,16)</h2><p>Typ=23 Len=16: 37,7,98,ba,a5,7b,ea,f0,e0,50,1,a8,65,30,2,be<br>SQL&gt;</p>\n<p>DUMP显示出，这个二进制串实际上长度为16字节（LEN=16）,另外还逐字节地显示了这个二进制数据。可以看到，这个转储显示与SQL*Plus将RAW数据获取为一个串时所执行的隐式转换是匹配的。<br>另一个方向上（插入）也会执行隐式转换：<br>SQL&gt; insert into t values( ‘abcdef’ );<br>1 row created.</p>\n<pre><code>这不会插入串abcdef，而会插入一个3字节的RAW数据，其字节分别是AB、CD、EF，如果用十进制表示则为字节171、205、239。如果试图使用一个包含非法16进制字符的串，就会收到一个错误消息：\n</code></pre><p>SQL&gt; insert into t values( ‘abcdefgh’ );<br>insert into t values( ‘abcdefgh’ )<br>                            *<br>ERROR at line 1:<br>ORA-01465: invalid hex number<br>SQL&gt;</p>\n<pre><code>RAW类型可以加索引，还能在谓词中使用，它与其他任何数据类型有同样的功能。不过，必须当心避免不希望的隐式转换，而且必须知道确实会发生隐式转换。\n在任何情况下我都喜欢使用显式转换，而且推荐这种做法，可以使用以下内置函数来执行这种操作。\n</code></pre><p>A.  HEXTORAW：将十六进制字符串转换为RAW类型。<br>B.  RAWTOHEX：将RAW串转换为十六进制串。<br>SQL*Plus将RAW类型获取为一个串时，会隐式地调用RWATOHEX函数，而插入串时会隐式地调用HEXTORAW函数。应该避免隐式转换，而在编写代码时总是使用显式转换，这是一个很好的实践做法。<br>所以当前的例子应该写作：<br>SQL&gt; select rawtohex(raw_data) from t</p>\n<h2 id=\"RAWTOHEX-RAW-DATA\"><a href=\"#RAWTOHEX-RAW-DATA\" class=\"headerlink\" title=\"RAWTOHEX(RAW_DATA)\"></a>RAWTOHEX(RAW_DATA)</h2><p>370798BAA57BEAF0E05001A8653002BE<br>ABCDEF<br>SQL&gt; insert into t values( hextoraw(‘abcdef’) );<br>1 row created.</p>\n"},{"title":"Spark体系概述","date":"2017-04-16T15:43:49.000Z","_content":"本文目的是介绍spark框架下的内容，以简要概述方式。\n\n\n\n","source":"_posts/spark/TODO-Spark体系概述.md","raw":"---\ntitle: Spark体系概述\ndate: 2017-04-16 23:43:49\ntags: [大数据,spark]\ncategories: [大数据,spark]\n---\n本文目的是介绍spark框架下的内容，以简要概述方式。\n\n\n\n","slug":"spark/TODO-Spark体系概述","published":1,"updated":"2017-08-18T01:44:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bjm001ls77rz12rblaw","content":"<p>本文目的是介绍spark框架下的内容，以简要概述方式。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文目的是介绍spark框架下的内容，以简要概述方式。</p>\n"},{"title":"Spring源码分析之环境准备","date":"2017-04-18T02:00:00.000Z","_content":"#Spring源码分析之环境准备\n","source":"_posts/spring/Spring源码分析之环境准备.md","raw":"---\ntitle: Spring源码分析之环境准备\ndate: 2017-04-18 10:00:00\ntags: [java,spring]\ncategories: [开源项目,spring]\n---\n#Spring源码分析之环境准备\n","slug":"spring/Spring源码分析之环境准备","published":1,"updated":"2017-08-18T01:44:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bjn001ps77rsmfod9gl","content":"<p>#Spring源码分析之环境准备</p>\n","site":{"data":{}},"excerpt":"","more":"<p>#Spring源码分析之环境准备</p>\n"},{"title":"JasperListener类找不到","date":"2017-08-18T01:59:00.000Z","_content":"#Tomcat java.lang.ClassNotFoundException: org.apache.catalina.core.JasperListener\n##问题描述\nLinux下启动tomcat8.0.45错误，windons下可用。\n\n##原因分析\nClassNotFoundException大致可能有两种情况，一是找不到jar包，二是jar包冲突，不知用哪个。\n\n##解决方案\nJasperListener好像是一个报表支持，目前不需要，可以暂时去掉。\n在tomcat目录 /conf/server.xml里注释如下内容\n<Listener className=\"org.apache.catalina.core.JasperListener\" />   ","source":"_posts/异常/JasperListener类找不到.md","raw":"---\ntitle: JasperListener类找不到\ndate: 2017-08-18 09:59:00\ntags: [异常,tomcat]\ncategories: [异常,tomcat]\n---\n#Tomcat java.lang.ClassNotFoundException: org.apache.catalina.core.JasperListener\n##问题描述\nLinux下启动tomcat8.0.45错误，windons下可用。\n\n##原因分析\nClassNotFoundException大致可能有两种情况，一是找不到jar包，二是jar包冲突，不知用哪个。\n\n##解决方案\nJasperListener好像是一个报表支持，目前不需要，可以暂时去掉。\n在tomcat目录 /conf/server.xml里注释如下内容\n<Listener className=\"org.apache.catalina.core.JasperListener\" />   ","slug":"异常/JasperListener类找不到","published":1,"updated":"2017-08-20T17:36:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bjo001ss77rpwrdzclk","content":"<p>#Tomcat java.lang.ClassNotFoundException: org.apache.catalina.core.JasperListener</p>\n<p>##问题描述<br>Linux下启动tomcat8.0.45错误，windons下可用。</p>\n<p>##原因分析<br>ClassNotFoundException大致可能有两种情况，一是找不到jar包，二是jar包冲突，不知用哪个。</p>\n<p>##解决方案<br>JasperListener好像是一个报表支持，目前不需要，可以暂时去掉。<br>在tomcat目录 /conf/server.xml里注释如下内容</p>\n<listener classname=\"org.apache.catalina.core.JasperListener\">   </listener>","site":{"data":{}},"excerpt":"","more":"<p>#Tomcat java.lang.ClassNotFoundException: org.apache.catalina.core.JasperListener</p>\n<p>##问题描述<br>Linux下启动tomcat8.0.45错误，windons下可用。</p>\n<p>##原因分析<br>ClassNotFoundException大致可能有两种情况，一是找不到jar包，二是jar包冲突，不知用哪个。</p>\n<p>##解决方案<br>JasperListener好像是一个报表支持，目前不需要，可以暂时去掉。<br>在tomcat目录 /conf/server.xml里注释如下内容</p>\n<listener classname=\"org.apache.catalina.core.JasperListener\">   </listener>"},{"title":"Java_heap_space_OutOfMemoryError","date":"2017-08-18T12:30:00.000Z","_content":"#java.lang.OutOfMemoryError: Java heap space\n##问题描述\nTomcat 8.0.45在linux环境下启动错误\n\n##原因分析\nJVM堆是指java程序运行过程中JVM可以调配使用的内存空间,主要用于存放Instance。JVM在启动的时候会自动设置Heap size的值，其初始空间(即-Xms)是物理内存的1/64，最大空间(-Xmx)是物理内存的1/4。可以利用JVM提供的-Xmn -Xms -Xmx等选项可进行设置。Heap size 的大小是Young Generation 和Tenured Generaion 之和。在JVM中如果98％的时间是用于GC且可用的Heap size 不足2％的时候将抛出此异常信息。\n\n##解决方案\n手动设置Heap size\na.如果tomcat是以bat方式启动的，则如下设置：\n修改TOMCAT_HOME/bin/catalina.sh\nJAVA_OPTS=\"-server -Xms1024m -Xmx1024m    -XX:MaxNewSize=256m\"","source":"_posts/异常/Java_heap_space_OutOfMemoryError.md","raw":"---\ntitle: Java_heap_space_OutOfMemoryError\ndate: 2017-08-18 20:30:00\ntags: [异常,tomcat]\ncategories: [异常,tomcat]\n---\n#java.lang.OutOfMemoryError: Java heap space\n##问题描述\nTomcat 8.0.45在linux环境下启动错误\n\n##原因分析\nJVM堆是指java程序运行过程中JVM可以调配使用的内存空间,主要用于存放Instance。JVM在启动的时候会自动设置Heap size的值，其初始空间(即-Xms)是物理内存的1/64，最大空间(-Xmx)是物理内存的1/4。可以利用JVM提供的-Xmn -Xms -Xmx等选项可进行设置。Heap size 的大小是Young Generation 和Tenured Generaion 之和。在JVM中如果98％的时间是用于GC且可用的Heap size 不足2％的时候将抛出此异常信息。\n\n##解决方案\n手动设置Heap size\na.如果tomcat是以bat方式启动的，则如下设置：\n修改TOMCAT_HOME/bin/catalina.sh\nJAVA_OPTS=\"-server -Xms1024m -Xmx1024m    -XX:MaxNewSize=256m\"","slug":"异常/Java_heap_space_OutOfMemoryError","published":1,"updated":"2018-05-15T05:57:06.605Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bjp001us77rlzgl6vwe","content":"<p>#java.lang.OutOfMemoryError: Java heap space</p>\n<p>##问题描述<br>Tomcat 8.0.45在linux环境下启动错误</p>\n<p>##原因分析<br>JVM堆是指java程序运行过程中JVM可以调配使用的内存空间,主要用于存放Instance。JVM在启动的时候会自动设置Heap size的值，其初始空间(即-Xms)是物理内存的1/64，最大空间(-Xmx)是物理内存的1/4。可以利用JVM提供的-Xmn -Xms -Xmx等选项可进行设置。Heap size 的大小是Young Generation 和Tenured Generaion 之和。在JVM中如果98％的时间是用于GC且可用的Heap size 不足2％的时候将抛出此异常信息。</p>\n<p>##解决方案<br>手动设置Heap size<br>a.如果tomcat是以bat方式启动的，则如下设置：<br>修改TOMCAT_HOME/bin/catalina.sh<br>JAVA_OPTS=”-server -Xms1024m -Xmx1024m    -XX:MaxNewSize=256m”</p>\n","site":{"data":{}},"excerpt":"","more":"<p>#java.lang.OutOfMemoryError: Java heap space</p>\n<p>##问题描述<br>Tomcat 8.0.45在linux环境下启动错误</p>\n<p>##原因分析<br>JVM堆是指java程序运行过程中JVM可以调配使用的内存空间,主要用于存放Instance。JVM在启动的时候会自动设置Heap size的值，其初始空间(即-Xms)是物理内存的1/64，最大空间(-Xmx)是物理内存的1/4。可以利用JVM提供的-Xmn -Xms -Xmx等选项可进行设置。Heap size 的大小是Young Generation 和Tenured Generaion 之和。在JVM中如果98％的时间是用于GC且可用的Heap size 不足2％的时候将抛出此异常信息。</p>\n<p>##解决方案<br>手动设置Heap size<br>a.如果tomcat是以bat方式启动的，则如下设置：<br>修改TOMCAT_HOME/bin/catalina.sh<br>JAVA_OPTS=”-server -Xms1024m -Xmx1024m    -XX:MaxNewSize=256m”</p>\n"},{"title":"负载均衡初识","date":"2018-05-22T08:43:49.000Z","_content":"``## 负载均衡的模式\n* ActiveWeight / LeastActive ：低并发度优先， referer 的某时刻的 call 数越小优先级越高。\n* Random ：随机，按权重设置随机概率。在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。\n* RoundRobin ：轮循，按公约后的权重设置轮循比率。存在慢的提供者累积请求问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。\n* LocalFirst ：本地服务优先获取策略。\n* Consistent ：一致性 Hash ，相同参数的请求总是发到同一提供者。当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。\n* ConfigurableWeight ：权重可配置的负载均衡策略。\n\n## 技术对比\n* Motan：支持 ActiveWeight 、Random 、 RoundRobin 、LocalFirst 、 Consistent 、ConfigurableWeight 。\n* Dubbo：支持 Random 、RoundRobin 、ConsistentHash 、 LeastActive。\n* gRPC：提供可插拔负载均衡器的机制。\n\n","source":"_posts/分布式/负载均衡初识.md","raw":"---\ntitle: 负载均衡初识\ndate: 2018-05-22 16:43:49\ntags: [分布式,负载均衡]\ncategories: [分布式,负载均衡]\n---\n``## 负载均衡的模式\n* ActiveWeight / LeastActive ：低并发度优先， referer 的某时刻的 call 数越小优先级越高。\n* Random ：随机，按权重设置随机概率。在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。\n* RoundRobin ：轮循，按公约后的权重设置轮循比率。存在慢的提供者累积请求问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。\n* LocalFirst ：本地服务优先获取策略。\n* Consistent ：一致性 Hash ，相同参数的请求总是发到同一提供者。当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。\n* ConfigurableWeight ：权重可配置的负载均衡策略。\n\n## 技术对比\n* Motan：支持 ActiveWeight 、Random 、 RoundRobin 、LocalFirst 、 Consistent 、ConfigurableWeight 。\n* Dubbo：支持 Random 、RoundRobin 、ConsistentHash 、 LeastActive。\n* gRPC：提供可插拔负载均衡器的机制。\n\n","slug":"分布式/负载均衡初识","published":1,"updated":"2018-07-07T10:08:57.374Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bjr001ws77r0jbev6em","content":"<p><code></code>## 负载均衡的模式</p>\n<ul>\n<li>ActiveWeight / LeastActive ：低并发度优先， referer 的某时刻的 call 数越小优先级越高。</li>\n<li>Random ：随机，按权重设置随机概率。在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</li>\n<li>RoundRobin ：轮循，按公约后的权重设置轮循比率。存在慢的提供者累积请求问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</li>\n<li>LocalFirst ：本地服务优先获取策略。</li>\n<li>Consistent ：一致性 Hash ，相同参数的请求总是发到同一提供者。当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</li>\n<li>ConfigurableWeight ：权重可配置的负载均衡策略。</li>\n</ul>\n<h2 id=\"技术对比\"><a href=\"#技术对比\" class=\"headerlink\" title=\"技术对比\"></a>技术对比</h2><ul>\n<li>Motan：支持 ActiveWeight 、Random 、 RoundRobin 、LocalFirst 、 Consistent 、ConfigurableWeight 。</li>\n<li>Dubbo：支持 Random 、RoundRobin 、ConsistentHash 、 LeastActive。</li>\n<li>gRPC：提供可插拔负载均衡器的机制。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><code></code>## 负载均衡的模式</p>\n<ul>\n<li>ActiveWeight / LeastActive ：低并发度优先， referer 的某时刻的 call 数越小优先级越高。</li>\n<li>Random ：随机，按权重设置随机概率。在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</li>\n<li>RoundRobin ：轮循，按公约后的权重设置轮循比率。存在慢的提供者累积请求问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</li>\n<li>LocalFirst ：本地服务优先获取策略。</li>\n<li>Consistent ：一致性 Hash ，相同参数的请求总是发到同一提供者。当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</li>\n<li>ConfigurableWeight ：权重可配置的负载均衡策略。</li>\n</ul>\n<h2 id=\"技术对比\"><a href=\"#技术对比\" class=\"headerlink\" title=\"技术对比\"></a>技术对比</h2><ul>\n<li>Motan：支持 ActiveWeight 、Random 、 RoundRobin 、LocalFirst 、 Consistent 、ConfigurableWeight 。</li>\n<li>Dubbo：支持 Random 、RoundRobin 、ConsistentHash 、 LeastActive。</li>\n<li>gRPC：提供可插拔负载均衡器的机制。</li>\n</ul>\n"},{"title":"connection_holder_is_null","date":"2017-08-18T01:55:00.000Z","_content":"#java.sql.SQLException: connection holder is null\n##问题描述\n使用druid连接池时出现的间歇性错误，偶尔会出现。\n\n##原因分析\n连接池可能对连接持有时间有限制，一种保护机制，如果某个连接很长时间不释放，其它应用就没有办法使用这个连接。\n\n##解决方案\n###方案一：\n        延长这个超时时间，默认为300秒（推荐）\n        <!--是否自动回收超时连接-->\n   \t\t<property name=\"removeAbandoned\" value=\"true\" />\n   \t\t<!--延长这个所谓的超时时间-->\n   \t\t<property name=\"removeAbandonedTimeout\" value=\"1800\" />\n   \t\t<!--将当前关闭动作记录到日志-->\n   \t\t<property name=\"logAbandoned\" value=\"true\" />        \n###方案二：\n        关闭这个超时保护\n        /*直接关闭这个   自动回收超时连接*/\n        <property name=\"removeAbandoned\" value=\"false\" />\n","source":"_posts/异常/connection_holder_is_null.md","raw":"---\ntitle: connection_holder_is_null\n\ndate: 2017-08-18 09:55:00\ntags: [异常,tomcat]\ncategories: [异常,tomcat]\n---\n#java.sql.SQLException: connection holder is null\n##问题描述\n使用druid连接池时出现的间歇性错误，偶尔会出现。\n\n##原因分析\n连接池可能对连接持有时间有限制，一种保护机制，如果某个连接很长时间不释放，其它应用就没有办法使用这个连接。\n\n##解决方案\n###方案一：\n        延长这个超时时间，默认为300秒（推荐）\n        <!--是否自动回收超时连接-->\n   \t\t<property name=\"removeAbandoned\" value=\"true\" />\n   \t\t<!--延长这个所谓的超时时间-->\n   \t\t<property name=\"removeAbandonedTimeout\" value=\"1800\" />\n   \t\t<!--将当前关闭动作记录到日志-->\n   \t\t<property name=\"logAbandoned\" value=\"true\" />        \n###方案二：\n        关闭这个超时保护\n        /*直接关闭这个   自动回收超时连接*/\n        <property name=\"removeAbandoned\" value=\"false\" />\n","slug":"异常/connection_holder_is_null","published":1,"updated":"2017-08-20T17:36:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bjs001zs77r6iaot0eb","content":"<p>#java.sql.SQLException: connection holder is null</p>\n<p>##问题描述<br>使用druid连接池时出现的间歇性错误，偶尔会出现。</p>\n<p>##原因分析<br>连接池可能对连接持有时间有限制，一种保护机制，如果某个连接很长时间不释放，其它应用就没有办法使用这个连接。</p>\n<p>##解决方案</p>\n<p>###方案一：<br>        延长这个超时时间，默认为300秒（推荐）<br>        <!--是否自动回收超时连接--><br>           <property name=\"removeAbandoned\" value=\"true\"><br>           <!--延长这个所谓的超时时间--><br>           <property name=\"removeAbandonedTimeout\" value=\"1800\"><br>           <!--将当前关闭动作记录到日志--><br>           <property name=\"logAbandoned\" value=\"true\">        </property></property></property></p>\n<p>###方案二：<br>        关闭这个超时保护<br>        /<em>直接关闭这个   自动回收超时连接</em>/<br>        <property name=\"removeAbandoned\" value=\"false\"></property></p>\n","site":{"data":{}},"excerpt":"","more":"<p>#java.sql.SQLException: connection holder is null</p>\n<p>##问题描述<br>使用druid连接池时出现的间歇性错误，偶尔会出现。</p>\n<p>##原因分析<br>连接池可能对连接持有时间有限制，一种保护机制，如果某个连接很长时间不释放，其它应用就没有办法使用这个连接。</p>\n<p>##解决方案</p>\n<p>###方案一：<br>        延长这个超时时间，默认为300秒（推荐）<br>        <!--是否自动回收超时连接--><br>           <property name=\"removeAbandoned\" value=\"true\"><br>           <!--延长这个所谓的超时时间--><br>           <property name=\"removeAbandonedTimeout\" value=\"1800\"><br>           <!--将当前关闭动作记录到日志--><br>           <property name=\"logAbandoned\" value=\"true\">        </property></property></property></p>\n<p>###方案二：<br>        关闭这个超时保护<br>        /<em>直接关闭这个   自动回收超时连接</em>/<br>        <property name=\"removeAbandoned\" value=\"false\"></property></p>\n"},{"title":"通过Hexo找寻自己的Github Pages","date":"2018-10-09T11:00:00.000Z","_content":"# 通过Hexo找寻自己的Github Pages\n## 一、项目初始化\n1、 创建与用户名同名的项目。\n    比如你的github用户名为xxx，即创建项目名为:xxx.github.io的项目。\n    \n2、安装Hexo\n命令行安装hexo服务端和客户端\nnpm install hexo-server —save \nnpm install hexo-cli -g\n\n初始化项目,名称为blog\nhexo init blog\ncd blog\nnpm install\nhexo server\n`\n3.Hexo常用命令\n$hexo clean\n$hexo generate\n$hexo server    这个命令用于测试：http://localhost:4000/\n$hexo deploy\n\n\n## 二、配置主题\n下载主题\n$ cd hexo\n$ git clone https://github.com/theme-next/hexo-theme-next themes/next\n\n## 三、相关配置\n\n## 四、域名绑定\n\n## 五、修改默认分支\n\n## 六、参考\n参考：[Github page 帮助](https://help.github.com/categories/github-pages-basics/) \n\n\n\n\n","source":"_posts/tools/通过Hexo找寻自己的Github Pages.md","raw":"---\ntitle: 通过Hexo找寻自己的Github Pages\ndate: 2018-10-09 19:00:00\ntags: [tools.博客]\ncategories: [tools,博客]\n---\n# 通过Hexo找寻自己的Github Pages\n## 一、项目初始化\n1、 创建与用户名同名的项目。\n    比如你的github用户名为xxx，即创建项目名为:xxx.github.io的项目。\n    \n2、安装Hexo\n命令行安装hexo服务端和客户端\nnpm install hexo-server —save \nnpm install hexo-cli -g\n\n初始化项目,名称为blog\nhexo init blog\ncd blog\nnpm install\nhexo server\n`\n3.Hexo常用命令\n$hexo clean\n$hexo generate\n$hexo server    这个命令用于测试：http://localhost:4000/\n$hexo deploy\n\n\n## 二、配置主题\n下载主题\n$ cd hexo\n$ git clone https://github.com/theme-next/hexo-theme-next themes/next\n\n## 三、相关配置\n\n## 四、域名绑定\n\n## 五、修改默认分支\n\n## 六、参考\n参考：[Github page 帮助](https://help.github.com/categories/github-pages-basics/) \n\n\n\n\n","slug":"tools/通过Hexo找寻自己的Github Pages","published":1,"updated":"2018-10-09T06:47:17.052Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bjt0022s77ruvjd7vwf","content":"<h1 id=\"通过Hexo找寻自己的Github-Pages\"><a href=\"#通过Hexo找寻自己的Github-Pages\" class=\"headerlink\" title=\"通过Hexo找寻自己的Github Pages\"></a>通过Hexo找寻自己的Github Pages</h1><h2 id=\"一、项目初始化\"><a href=\"#一、项目初始化\" class=\"headerlink\" title=\"一、项目初始化\"></a>一、项目初始化</h2><p>1、 创建与用户名同名的项目。<br>    比如你的github用户名为xxx，即创建项目名为:xxx.github.io的项目。</p>\n<p>2、安装Hexo<br>命令行安装hexo服务端和客户端<br>npm install hexo-server —save<br>npm install hexo-cli -g</p>\n<p>初始化项目,名称为blog<br>hexo init blog<br>cd blog<br>npm install<br>hexo server<br>`<br>3.Hexo常用命令<br>$hexo clean<br>$hexo generate<br>$hexo server    这个命令用于测试：<a href=\"http://localhost:4000/\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/</a><br>$hexo deploy</p>\n<h2 id=\"二、配置主题\"><a href=\"#二、配置主题\" class=\"headerlink\" title=\"二、配置主题\"></a>二、配置主题</h2><p>下载主题<br>$ cd hexo<br>$ git clone <a href=\"https://github.com/theme-next/hexo-theme-next\" target=\"_blank\" rel=\"noopener\">https://github.com/theme-next/hexo-theme-next</a> themes/next</p>\n<h2 id=\"三、相关配置\"><a href=\"#三、相关配置\" class=\"headerlink\" title=\"三、相关配置\"></a>三、相关配置</h2><h2 id=\"四、域名绑定\"><a href=\"#四、域名绑定\" class=\"headerlink\" title=\"四、域名绑定\"></a>四、域名绑定</h2><h2 id=\"五、修改默认分支\"><a href=\"#五、修改默认分支\" class=\"headerlink\" title=\"五、修改默认分支\"></a>五、修改默认分支</h2><h2 id=\"六、参考\"><a href=\"#六、参考\" class=\"headerlink\" title=\"六、参考\"></a>六、参考</h2><p>参考：<a href=\"https://help.github.com/categories/github-pages-basics/\" target=\"_blank\" rel=\"noopener\">Github page 帮助</a> </p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"通过Hexo找寻自己的Github-Pages\"><a href=\"#通过Hexo找寻自己的Github-Pages\" class=\"headerlink\" title=\"通过Hexo找寻自己的Github Pages\"></a>通过Hexo找寻自己的Github Pages</h1><h2 id=\"一、项目初始化\"><a href=\"#一、项目初始化\" class=\"headerlink\" title=\"一、项目初始化\"></a>一、项目初始化</h2><p>1、 创建与用户名同名的项目。<br>    比如你的github用户名为xxx，即创建项目名为:xxx.github.io的项目。</p>\n<p>2、安装Hexo<br>命令行安装hexo服务端和客户端<br>npm install hexo-server —save<br>npm install hexo-cli -g</p>\n<p>初始化项目,名称为blog<br>hexo init blog<br>cd blog<br>npm install<br>hexo server<br>`<br>3.Hexo常用命令<br>$hexo clean<br>$hexo generate<br>$hexo server    这个命令用于测试：<a href=\"http://localhost:4000/\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/</a><br>$hexo deploy</p>\n<h2 id=\"二、配置主题\"><a href=\"#二、配置主题\" class=\"headerlink\" title=\"二、配置主题\"></a>二、配置主题</h2><p>下载主题<br>$ cd hexo<br>$ git clone <a href=\"https://github.com/theme-next/hexo-theme-next\" target=\"_blank\" rel=\"noopener\">https://github.com/theme-next/hexo-theme-next</a> themes/next</p>\n<h2 id=\"三、相关配置\"><a href=\"#三、相关配置\" class=\"headerlink\" title=\"三、相关配置\"></a>三、相关配置</h2><h2 id=\"四、域名绑定\"><a href=\"#四、域名绑定\" class=\"headerlink\" title=\"四、域名绑定\"></a>四、域名绑定</h2><h2 id=\"五、修改默认分支\"><a href=\"#五、修改默认分支\" class=\"headerlink\" title=\"五、修改默认分支\"></a>五、修改默认分支</h2><h2 id=\"六、参考\"><a href=\"#六、参考\" class=\"headerlink\" title=\"六、参考\"></a>六、参考</h2><p>参考：<a href=\"https://help.github.com/categories/github-pages-basics/\" target=\"_blank\" rel=\"noopener\">Github page 帮助</a> </p>\n"},{"title":"permGen_space_OutOfMemoryError","date":"2017-08-18T01:55:00.000Z","_content":"#Tomcat java.lang.OutOfMemoryError: PermGen space\n##问题描述\nTomcat 8.0.45在linux环境下启动错误\n\n##原因分析\nPermGen space是指内存的永久保存区域内存溢出。这块内存主要是JVM来来存放Class和Meta信息的，Class在被Load的时候被放入PermGen space区域，它和存放Instance的Heap区域不同,GC(Garbage Collection)不会在主程序运行期对PermGen space进行清理，所以如果你的APP会LOAD很多CLASS的话，就很可能出现PermGen space错误。这种错误常见在web服务器对JSP进行预编译的时候。如果你的WEB APP下都用了大量的第三方jar, 其大小超过了jvm默认的大小(4M)那么就会产生此错误信息了。\n\n##解决方案\n手动设置MaxPermSize大小,修改TOMCAT_HOME/bin/catalina.sh\nJAVA_OPTS=\"-server -XX:PermSize=256M -XX:MaxPermSize=1024m\"   ","source":"_posts/异常/permGen_space_OutOfMemoryError.md","raw":"---\ntitle: permGen_space_OutOfMemoryError\ndate: 2017-08-18 09:55:00\ntags: [异常,tomcat]\ncategories: [异常,tomcat]\n---\n#Tomcat java.lang.OutOfMemoryError: PermGen space\n##问题描述\nTomcat 8.0.45在linux环境下启动错误\n\n##原因分析\nPermGen space是指内存的永久保存区域内存溢出。这块内存主要是JVM来来存放Class和Meta信息的，Class在被Load的时候被放入PermGen space区域，它和存放Instance的Heap区域不同,GC(Garbage Collection)不会在主程序运行期对PermGen space进行清理，所以如果你的APP会LOAD很多CLASS的话，就很可能出现PermGen space错误。这种错误常见在web服务器对JSP进行预编译的时候。如果你的WEB APP下都用了大量的第三方jar, 其大小超过了jvm默认的大小(4M)那么就会产生此错误信息了。\n\n##解决方案\n手动设置MaxPermSize大小,修改TOMCAT_HOME/bin/catalina.sh\nJAVA_OPTS=\"-server -XX:PermSize=256M -XX:MaxPermSize=1024m\"   ","slug":"异常/permGen_space_OutOfMemoryError","published":1,"updated":"2017-08-20T17:36:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bju0025s77r763vfhjn","content":"<p>#Tomcat java.lang.OutOfMemoryError: PermGen space</p>\n<p>##问题描述<br>Tomcat 8.0.45在linux环境下启动错误</p>\n<p>##原因分析<br>PermGen space是指内存的永久保存区域内存溢出。这块内存主要是JVM来来存放Class和Meta信息的，Class在被Load的时候被放入PermGen space区域，它和存放Instance的Heap区域不同,GC(Garbage Collection)不会在主程序运行期对PermGen space进行清理，所以如果你的APP会LOAD很多CLASS的话，就很可能出现PermGen space错误。这种错误常见在web服务器对JSP进行预编译的时候。如果你的WEB APP下都用了大量的第三方jar, 其大小超过了jvm默认的大小(4M)那么就会产生此错误信息了。</p>\n<p>##解决方案<br>手动设置MaxPermSize大小,修改TOMCAT_HOME/bin/catalina.sh<br>JAVA_OPTS=”-server -XX:PermSize=256M -XX:MaxPermSize=1024m”   </p>\n","site":{"data":{}},"excerpt":"","more":"<p>#Tomcat java.lang.OutOfMemoryError: PermGen space</p>\n<p>##问题描述<br>Tomcat 8.0.45在linux环境下启动错误</p>\n<p>##原因分析<br>PermGen space是指内存的永久保存区域内存溢出。这块内存主要是JVM来来存放Class和Meta信息的，Class在被Load的时候被放入PermGen space区域，它和存放Instance的Heap区域不同,GC(Garbage Collection)不会在主程序运行期对PermGen space进行清理，所以如果你的APP会LOAD很多CLASS的话，就很可能出现PermGen space错误。这种错误常见在web服务器对JSP进行预编译的时候。如果你的WEB APP下都用了大量的第三方jar, 其大小超过了jvm默认的大小(4M)那么就会产生此错误信息了。</p>\n<p>##解决方案<br>手动设置MaxPermSize大小,修改TOMCAT_HOME/bin/catalina.sh<br>JAVA_OPTS=”-server -XX:PermSize=256M -XX:MaxPermSize=1024m”   </p>\n"},{"title":"TODO-企业安全组","date":"2016-12-31T16:00:00.000Z","_content":"#工作内容指导\n\n\n#安全小组工作范围\n\n\n#关注的领域\n\n\n#分类","source":"_posts/网络安全/企业安全组.md","raw":"---\ntitle: TODO-企业安全组\ndate: 2017-01-01 00:00:00\ntags: [网络安全,安全小组]\ncategories: [网络安全,安全小组]\n---\n#工作内容指导\n\n\n#安全小组工作范围\n\n\n#关注的领域\n\n\n#分类","slug":"网络安全/企业安全组","published":1,"updated":"2017-08-18T01:44:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bjw0028s77r47a8uy2n","content":"<p>#工作内容指导</p>\n<p>#安全小组工作范围</p>\n<p>#关注的领域</p>\n<p>#分类</p>\n","site":{"data":{}},"excerpt":"","more":"<p>#工作内容指导</p>\n<p>#安全小组工作范围</p>\n<p>#关注的领域</p>\n<p>#分类</p>\n"},{"title":"和田市卫浴安装家具安装","date":"2017-06-09T09:28:00.000Z","_content":"#和田市卫浴安装工人\n朱力  \n电话：139 9943 3811\n介绍：从事家具（厨柜、床）、卫浴等工作20余年，目前在和田专业从事安具、厨卫安装、销售服务。\n\n#和田市卫浴家具安装工人\n朱力  \n电话：139 9943 3811\n介绍：从事家具（厨柜、床）、卫浴等工作20余年，目前在和田专业从事安具、厨卫安装、销售服务。\n\n\n# 可以接收什么类型的工作\n1.家具安装，包含床、柜子、书桌等。  \n2.卫浴安装  \n3.品牌家具销售  \n\n\n\n","source":"_posts/服务/和田市卫浴安装家具安装.md","raw":"---\ntitle: 和田市卫浴安装家具安装 \ndate: 2017-06-09 17:28:00\ntags: [服务]\ncategories: [服务]\n---\n#和田市卫浴安装工人\n朱力  \n电话：139 9943 3811\n介绍：从事家具（厨柜、床）、卫浴等工作20余年，目前在和田专业从事安具、厨卫安装、销售服务。\n\n#和田市卫浴家具安装工人\n朱力  \n电话：139 9943 3811\n介绍：从事家具（厨柜、床）、卫浴等工作20余年，目前在和田专业从事安具、厨卫安装、销售服务。\n\n\n# 可以接收什么类型的工作\n1.家具安装，包含床、柜子、书桌等。  \n2.卫浴安装  \n3.品牌家具销售  \n\n\n\n","slug":"服务/和田市卫浴安装家具安装","published":1,"updated":"2017-08-18T01:44:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bjx002bs77r8yhq8eur","content":"<p>#和田市卫浴安装工人<br>朱力<br>电话：139 9943 3811<br>介绍：从事家具（厨柜、床）、卫浴等工作20余年，目前在和田专业从事安具、厨卫安装、销售服务。</p>\n<p>#和田市卫浴家具安装工人<br>朱力<br>电话：139 9943 3811<br>介绍：从事家具（厨柜、床）、卫浴等工作20余年，目前在和田专业从事安具、厨卫安装、销售服务。</p>\n<h1 id=\"可以接收什么类型的工作\"><a href=\"#可以接收什么类型的工作\" class=\"headerlink\" title=\"可以接收什么类型的工作\"></a>可以接收什么类型的工作</h1><p>1.家具安装，包含床、柜子、书桌等。<br>2.卫浴安装<br>3.品牌家具销售  </p>\n","site":{"data":{}},"excerpt":"","more":"<p>#和田市卫浴安装工人<br>朱力<br>电话：139 9943 3811<br>介绍：从事家具（厨柜、床）、卫浴等工作20余年，目前在和田专业从事安具、厨卫安装、销售服务。</p>\n<p>#和田市卫浴家具安装工人<br>朱力<br>电话：139 9943 3811<br>介绍：从事家具（厨柜、床）、卫浴等工作20余年，目前在和田专业从事安具、厨卫安装、销售服务。</p>\n<h1 id=\"可以接收什么类型的工作\"><a href=\"#可以接收什么类型的工作\" class=\"headerlink\" title=\"可以接收什么类型的工作\"></a>可以接收什么类型的工作</h1><p>1.家具安装，包含床、柜子、书桌等。<br>2.卫浴安装<br>3.品牌家具销售  </p>\n"},{"title":"TODO-常用算法概述","date":"2016-12-31T16:00:00.000Z","_content":"#工作内容指导\n\n\n#安全小组工作范围\n\n\n#关注的领域\n\n\n#分类","source":"_posts/算法/常用算法概述.md","raw":"---\ntitle: TODO-常用算法概述\ndate: 2017-01-01 00:00:00\ntags: [软件工程,算法]\ncategories: [软件工程,算法]\n---\n#工作内容指导\n\n\n#安全小组工作范围\n\n\n#关注的领域\n\n\n#分类","slug":"算法/常用算法概述","published":1,"updated":"2017-08-18T01:44:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bjz002es77rmbvcu4k0","content":"<p>#工作内容指导</p>\n<p>#安全小组工作范围</p>\n<p>#关注的领域</p>\n<p>#分类</p>\n","site":{"data":{}},"excerpt":"","more":"<p>#工作内容指导</p>\n<p>#安全小组工作范围</p>\n<p>#关注的领域</p>\n<p>#分类</p>\n"},{"title":"安全组第一次会议提出的问题整理","date":"2017-05-16T02:30:00.000Z","_content":"创建安全组是个长期的、不断迭代的过程，目前我们公司系统百废末兴之际，各方面的系统也都在创建初期如果安全控制要求高，势必会影响部分工作进度；当然，从开始就严格控制，也会为后期不必要的重构提供有利条件。根据现有情况，可以优先进行投入少，回报多的工作，慢慢渗透。  \n\n# 事前-防范\n1.制定漏洞管理制度  \n为规范生产网和办公网安全漏洞发现、评估及处理，首先应该制定《漏洞管理制度》对漏洞评级，根据评级做不同和响应处理。    \n漏洞处理流程：发现漏洞->评估漏洞->如果是不可接受的风险对业务下线->修补漏洞->测试验收->上线  \n\n2.敏感数据保护  \n\t1) 银行卡可以显示首末4，手机号可以显示首3末4位，电话可以显示区号和末4位，身份证、邮箱、地址等。  \n\t2) 日志文件里的敏感信息  \n\t3) 用户名密码加密  \n\t4) 数据库防篡改签名  \n\t\n3.访问控制管理  \n\t1) 制定信息授权的策略，及访问权限的管理策略；  \n\t2) 规定每个用户或每组用户的访问控制规则和权力；  \n\t\n4.用户帐号及权限安全。  \n\t1) 最小权限原则  \n\t最小权限是指限定系统中每个用户所必须的最小访问权限的原则，设定账号访问权限，控制用户仅能够访问到工作需要的信息。  \n\t2) 职责分离原则  \n\t职责分离主要是防止单个用户利用其所拥有的多重权限进行舞弊、盗窃或其它的非法行为，或对工作错误和违规活动进行掩盖。  \n\t账号权限管理应按照职责分离的原则，确保不存在权限交叉而形成舞弊的可能  \n\t\n5. 产品安全功能设计规范   \n\t需要对产品的安全功能设计，如身份认证基本策略、用户登录失败/超时处理、账户信息输入防护、接口认证。  \n\t\n6.保密管理  \n     对文档、内容做好密级分类，哪些文件是对内，对外，或机密。  \n\n7.测试规范，  \n\t1) 依据《漏洞管理制度》判定漏洞等级，凡存在高危漏洞，除大领导特批外，禁止上线；低危或中危漏洞，可先上线后排期修复。  \n\t任何系统未经过黑盒和白盒测试，禁止上线，特批和紧急情况除外。   \n\t2) 为避免安全测试人员漏测，需定期对生产进行全面安全测试：  \n\t• 半年内至少执行一次全面渗透测试；  \n\t• 每个季度至少需要一次全面的ACL验证，系统底层漏洞检测；  \n\t\n8.研发规范：  \n\t1) 研发流程规范  \n\t2) 代码规范  \n\t3) 对技术的选型，比如组件、中间容器、中间件使用版本统一及安全、架构评审。  \n\t\n# 事中-应急的规定  \n  1) 建议成立应急指挥小组主要是在事故处理过程中进行信息收集、资源调度和沟通反馈信息。  应急处理流程如：信息收集->初步判断->事故处理->信息通报->事后处理-故障报告。  原则：以尽快恢复业务为第一优先。    \n  2) 故障时间之前做相关系统的上线或系统变更备份，在3分钟内无法定位故障原因的，立即执行回滚变更操作。  \n\n# 事后-总结  \n  1) 做好故障记录，主要包括事故、事故发生时间，事故恢复时间、持续时间，等级、影响产品、影响商户、影响交易、事故发现、事故类型、产生原因等   \n  2) 故障报告改进措施跟进 ，主要是改进措施、目前的完成情况，遗留问题  \n\n# 漏洞发现和处理流程  \n1.注册补天、漏洞盒子、乌云等国内外漏洞平台的企业帐号，针对企业贴平台会第一时间推送最新漏洞并进行安全指导。      \n2.可以在补天、漏洞盒子等平台以企业帐号方式创建安全测试平台，对外的白帽子增加奖励，鼓励大众参与众测。  \n\n# 安全网站参考\n安全资讯  \nhttp://www.freebuf.com/  \n\n乌云 (WooYun)(已停服)  \nhttp://wooyun.org/  \n可通过如下查乌云数据：http://wooyun.tangscan.cn/  \n\n补天  \nhttp://loudong.360.cn/  \n\n漏洞盒子  \nhttps://www.vulbox.com/bounties  \n\n阿里SRC  \nhttps://security.alibaba.com/  \n\n腾讯SRC  \nhttps://security.tencent.com/  \n\n\n\n","source":"_posts/网络安全/安全组第一次会议提出的问题整理.md","raw":"---\ntitle: 安全组第一次会议提出的问题整理\ndate: 2017-05-16 10:30:00\ntags: [网络安全,安全小组]\ncategories: [网络安全,安全小组]\n---\n创建安全组是个长期的、不断迭代的过程，目前我们公司系统百废末兴之际，各方面的系统也都在创建初期如果安全控制要求高，势必会影响部分工作进度；当然，从开始就严格控制，也会为后期不必要的重构提供有利条件。根据现有情况，可以优先进行投入少，回报多的工作，慢慢渗透。  \n\n# 事前-防范\n1.制定漏洞管理制度  \n为规范生产网和办公网安全漏洞发现、评估及处理，首先应该制定《漏洞管理制度》对漏洞评级，根据评级做不同和响应处理。    \n漏洞处理流程：发现漏洞->评估漏洞->如果是不可接受的风险对业务下线->修补漏洞->测试验收->上线  \n\n2.敏感数据保护  \n\t1) 银行卡可以显示首末4，手机号可以显示首3末4位，电话可以显示区号和末4位，身份证、邮箱、地址等。  \n\t2) 日志文件里的敏感信息  \n\t3) 用户名密码加密  \n\t4) 数据库防篡改签名  \n\t\n3.访问控制管理  \n\t1) 制定信息授权的策略，及访问权限的管理策略；  \n\t2) 规定每个用户或每组用户的访问控制规则和权力；  \n\t\n4.用户帐号及权限安全。  \n\t1) 最小权限原则  \n\t最小权限是指限定系统中每个用户所必须的最小访问权限的原则，设定账号访问权限，控制用户仅能够访问到工作需要的信息。  \n\t2) 职责分离原则  \n\t职责分离主要是防止单个用户利用其所拥有的多重权限进行舞弊、盗窃或其它的非法行为，或对工作错误和违规活动进行掩盖。  \n\t账号权限管理应按照职责分离的原则，确保不存在权限交叉而形成舞弊的可能  \n\t\n5. 产品安全功能设计规范   \n\t需要对产品的安全功能设计，如身份认证基本策略、用户登录失败/超时处理、账户信息输入防护、接口认证。  \n\t\n6.保密管理  \n     对文档、内容做好密级分类，哪些文件是对内，对外，或机密。  \n\n7.测试规范，  \n\t1) 依据《漏洞管理制度》判定漏洞等级，凡存在高危漏洞，除大领导特批外，禁止上线；低危或中危漏洞，可先上线后排期修复。  \n\t任何系统未经过黑盒和白盒测试，禁止上线，特批和紧急情况除外。   \n\t2) 为避免安全测试人员漏测，需定期对生产进行全面安全测试：  \n\t• 半年内至少执行一次全面渗透测试；  \n\t• 每个季度至少需要一次全面的ACL验证，系统底层漏洞检测；  \n\t\n8.研发规范：  \n\t1) 研发流程规范  \n\t2) 代码规范  \n\t3) 对技术的选型，比如组件、中间容器、中间件使用版本统一及安全、架构评审。  \n\t\n# 事中-应急的规定  \n  1) 建议成立应急指挥小组主要是在事故处理过程中进行信息收集、资源调度和沟通反馈信息。  应急处理流程如：信息收集->初步判断->事故处理->信息通报->事后处理-故障报告。  原则：以尽快恢复业务为第一优先。    \n  2) 故障时间之前做相关系统的上线或系统变更备份，在3分钟内无法定位故障原因的，立即执行回滚变更操作。  \n\n# 事后-总结  \n  1) 做好故障记录，主要包括事故、事故发生时间，事故恢复时间、持续时间，等级、影响产品、影响商户、影响交易、事故发现、事故类型、产生原因等   \n  2) 故障报告改进措施跟进 ，主要是改进措施、目前的完成情况，遗留问题  \n\n# 漏洞发现和处理流程  \n1.注册补天、漏洞盒子、乌云等国内外漏洞平台的企业帐号，针对企业贴平台会第一时间推送最新漏洞并进行安全指导。      \n2.可以在补天、漏洞盒子等平台以企业帐号方式创建安全测试平台，对外的白帽子增加奖励，鼓励大众参与众测。  \n\n# 安全网站参考\n安全资讯  \nhttp://www.freebuf.com/  \n\n乌云 (WooYun)(已停服)  \nhttp://wooyun.org/  \n可通过如下查乌云数据：http://wooyun.tangscan.cn/  \n\n补天  \nhttp://loudong.360.cn/  \n\n漏洞盒子  \nhttps://www.vulbox.com/bounties  \n\n阿里SRC  \nhttps://security.alibaba.com/  \n\n腾讯SRC  \nhttps://security.tencent.com/  \n\n\n\n","slug":"网络安全/安全组第一次会议提出的问题整理","published":1,"updated":"2017-08-18T01:44:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bk0002fs77rx237gfb6","content":"<p>创建安全组是个长期的、不断迭代的过程，目前我们公司系统百废末兴之际，各方面的系统也都在创建初期如果安全控制要求高，势必会影响部分工作进度；当然，从开始就严格控制，也会为后期不必要的重构提供有利条件。根据现有情况，可以优先进行投入少，回报多的工作，慢慢渗透。  </p>\n<h1 id=\"事前-防范\"><a href=\"#事前-防范\" class=\"headerlink\" title=\"事前-防范\"></a>事前-防范</h1><p>1.制定漏洞管理制度<br>为规范生产网和办公网安全漏洞发现、评估及处理，首先应该制定《漏洞管理制度》对漏洞评级，根据评级做不同和响应处理。<br>漏洞处理流程：发现漏洞-&gt;评估漏洞-&gt;如果是不可接受的风险对业务下线-&gt;修补漏洞-&gt;测试验收-&gt;上线  </p>\n<p>2.敏感数据保护<br>    1) 银行卡可以显示首末4，手机号可以显示首3末4位，电话可以显示区号和末4位，身份证、邮箱、地址等。<br>    2) 日志文件里的敏感信息<br>    3) 用户名密码加密<br>    4) 数据库防篡改签名  </p>\n<p>3.访问控制管理<br>    1) 制定信息授权的策略，及访问权限的管理策略；<br>    2) 规定每个用户或每组用户的访问控制规则和权力；  </p>\n<p>4.用户帐号及权限安全。<br>    1) 最小权限原则<br>    最小权限是指限定系统中每个用户所必须的最小访问权限的原则，设定账号访问权限，控制用户仅能够访问到工作需要的信息。<br>    2) 职责分离原则<br>    职责分离主要是防止单个用户利用其所拥有的多重权限进行舞弊、盗窃或其它的非法行为，或对工作错误和违规活动进行掩盖。<br>    账号权限管理应按照职责分离的原则，确保不存在权限交叉而形成舞弊的可能  </p>\n<ol start=\"5\">\n<li>产品安全功能设计规范<br> 需要对产品的安全功能设计，如身份认证基本策略、用户登录失败/超时处理、账户信息输入防护、接口认证。  </li>\n</ol>\n<p>6.保密管理<br>     对文档、内容做好密级分类，哪些文件是对内，对外，或机密。  </p>\n<p>7.测试规范，<br>    1) 依据《漏洞管理制度》判定漏洞等级，凡存在高危漏洞，除大领导特批外，禁止上线；低危或中危漏洞，可先上线后排期修复。<br>    任何系统未经过黑盒和白盒测试，禁止上线，特批和紧急情况除外。<br>    2) 为避免安全测试人员漏测，需定期对生产进行全面安全测试：<br>    • 半年内至少执行一次全面渗透测试；<br>    • 每个季度至少需要一次全面的ACL验证，系统底层漏洞检测；  </p>\n<p>8.研发规范：<br>    1) 研发流程规范<br>    2) 代码规范<br>    3) 对技术的选型，比如组件、中间容器、中间件使用版本统一及安全、架构评审。  </p>\n<h1 id=\"事中-应急的规定\"><a href=\"#事中-应急的规定\" class=\"headerlink\" title=\"事中-应急的规定\"></a>事中-应急的规定</h1><p>  1) 建议成立应急指挥小组主要是在事故处理过程中进行信息收集、资源调度和沟通反馈信息。  应急处理流程如：信息收集-&gt;初步判断-&gt;事故处理-&gt;信息通报-&gt;事后处理-故障报告。  原则：以尽快恢复业务为第一优先。<br>  2) 故障时间之前做相关系统的上线或系统变更备份，在3分钟内无法定位故障原因的，立即执行回滚变更操作。  </p>\n<h1 id=\"事后-总结\"><a href=\"#事后-总结\" class=\"headerlink\" title=\"事后-总结\"></a>事后-总结</h1><p>  1) 做好故障记录，主要包括事故、事故发生时间，事故恢复时间、持续时间，等级、影响产品、影响商户、影响交易、事故发现、事故类型、产生原因等<br>  2) 故障报告改进措施跟进 ，主要是改进措施、目前的完成情况，遗留问题  </p>\n<h1 id=\"漏洞发现和处理流程\"><a href=\"#漏洞发现和处理流程\" class=\"headerlink\" title=\"漏洞发现和处理流程\"></a>漏洞发现和处理流程</h1><p>1.注册补天、漏洞盒子、乌云等国内外漏洞平台的企业帐号，针对企业贴平台会第一时间推送最新漏洞并进行安全指导。<br>2.可以在补天、漏洞盒子等平台以企业帐号方式创建安全测试平台，对外的白帽子增加奖励，鼓励大众参与众测。  </p>\n<h1 id=\"安全网站参考\"><a href=\"#安全网站参考\" class=\"headerlink\" title=\"安全网站参考\"></a>安全网站参考</h1><p>安全资讯<br><a href=\"http://www.freebuf.com/\" target=\"_blank\" rel=\"noopener\">http://www.freebuf.com/</a>  </p>\n<p>乌云 (WooYun)(已停服)<br><a href=\"http://wooyun.org/\" target=\"_blank\" rel=\"noopener\">http://wooyun.org/</a><br>可通过如下查乌云数据：<a href=\"http://wooyun.tangscan.cn/\" target=\"_blank\" rel=\"noopener\">http://wooyun.tangscan.cn/</a>  </p>\n<p>补天<br><a href=\"http://loudong.360.cn/\" target=\"_blank\" rel=\"noopener\">http://loudong.360.cn/</a>  </p>\n<p>漏洞盒子<br><a href=\"https://www.vulbox.com/bounties\" target=\"_blank\" rel=\"noopener\">https://www.vulbox.com/bounties</a>  </p>\n<p>阿里SRC<br><a href=\"https://security.alibaba.com/\" target=\"_blank\" rel=\"noopener\">https://security.alibaba.com/</a>  </p>\n<p>腾讯SRC<br><a href=\"https://security.tencent.com/\" target=\"_blank\" rel=\"noopener\">https://security.tencent.com/</a>  </p>\n","site":{"data":{}},"excerpt":"","more":"<p>创建安全组是个长期的、不断迭代的过程，目前我们公司系统百废末兴之际，各方面的系统也都在创建初期如果安全控制要求高，势必会影响部分工作进度；当然，从开始就严格控制，也会为后期不必要的重构提供有利条件。根据现有情况，可以优先进行投入少，回报多的工作，慢慢渗透。  </p>\n<h1 id=\"事前-防范\"><a href=\"#事前-防范\" class=\"headerlink\" title=\"事前-防范\"></a>事前-防范</h1><p>1.制定漏洞管理制度<br>为规范生产网和办公网安全漏洞发现、评估及处理，首先应该制定《漏洞管理制度》对漏洞评级，根据评级做不同和响应处理。<br>漏洞处理流程：发现漏洞-&gt;评估漏洞-&gt;如果是不可接受的风险对业务下线-&gt;修补漏洞-&gt;测试验收-&gt;上线  </p>\n<p>2.敏感数据保护<br>    1) 银行卡可以显示首末4，手机号可以显示首3末4位，电话可以显示区号和末4位，身份证、邮箱、地址等。<br>    2) 日志文件里的敏感信息<br>    3) 用户名密码加密<br>    4) 数据库防篡改签名  </p>\n<p>3.访问控制管理<br>    1) 制定信息授权的策略，及访问权限的管理策略；<br>    2) 规定每个用户或每组用户的访问控制规则和权力；  </p>\n<p>4.用户帐号及权限安全。<br>    1) 最小权限原则<br>    最小权限是指限定系统中每个用户所必须的最小访问权限的原则，设定账号访问权限，控制用户仅能够访问到工作需要的信息。<br>    2) 职责分离原则<br>    职责分离主要是防止单个用户利用其所拥有的多重权限进行舞弊、盗窃或其它的非法行为，或对工作错误和违规活动进行掩盖。<br>    账号权限管理应按照职责分离的原则，确保不存在权限交叉而形成舞弊的可能  </p>\n<ol start=\"5\">\n<li>产品安全功能设计规范<br> 需要对产品的安全功能设计，如身份认证基本策略、用户登录失败/超时处理、账户信息输入防护、接口认证。  </li>\n</ol>\n<p>6.保密管理<br>     对文档、内容做好密级分类，哪些文件是对内，对外，或机密。  </p>\n<p>7.测试规范，<br>    1) 依据《漏洞管理制度》判定漏洞等级，凡存在高危漏洞，除大领导特批外，禁止上线；低危或中危漏洞，可先上线后排期修复。<br>    任何系统未经过黑盒和白盒测试，禁止上线，特批和紧急情况除外。<br>    2) 为避免安全测试人员漏测，需定期对生产进行全面安全测试：<br>    • 半年内至少执行一次全面渗透测试；<br>    • 每个季度至少需要一次全面的ACL验证，系统底层漏洞检测；  </p>\n<p>8.研发规范：<br>    1) 研发流程规范<br>    2) 代码规范<br>    3) 对技术的选型，比如组件、中间容器、中间件使用版本统一及安全、架构评审。  </p>\n<h1 id=\"事中-应急的规定\"><a href=\"#事中-应急的规定\" class=\"headerlink\" title=\"事中-应急的规定\"></a>事中-应急的规定</h1><p>  1) 建议成立应急指挥小组主要是在事故处理过程中进行信息收集、资源调度和沟通反馈信息。  应急处理流程如：信息收集-&gt;初步判断-&gt;事故处理-&gt;信息通报-&gt;事后处理-故障报告。  原则：以尽快恢复业务为第一优先。<br>  2) 故障时间之前做相关系统的上线或系统变更备份，在3分钟内无法定位故障原因的，立即执行回滚变更操作。  </p>\n<h1 id=\"事后-总结\"><a href=\"#事后-总结\" class=\"headerlink\" title=\"事后-总结\"></a>事后-总结</h1><p>  1) 做好故障记录，主要包括事故、事故发生时间，事故恢复时间、持续时间，等级、影响产品、影响商户、影响交易、事故发现、事故类型、产生原因等<br>  2) 故障报告改进措施跟进 ，主要是改进措施、目前的完成情况，遗留问题  </p>\n<h1 id=\"漏洞发现和处理流程\"><a href=\"#漏洞发现和处理流程\" class=\"headerlink\" title=\"漏洞发现和处理流程\"></a>漏洞发现和处理流程</h1><p>1.注册补天、漏洞盒子、乌云等国内外漏洞平台的企业帐号，针对企业贴平台会第一时间推送最新漏洞并进行安全指导。<br>2.可以在补天、漏洞盒子等平台以企业帐号方式创建安全测试平台，对外的白帽子增加奖励，鼓励大众参与众测。  </p>\n<h1 id=\"安全网站参考\"><a href=\"#安全网站参考\" class=\"headerlink\" title=\"安全网站参考\"></a>安全网站参考</h1><p>安全资讯<br><a href=\"http://www.freebuf.com/\" target=\"_blank\" rel=\"noopener\">http://www.freebuf.com/</a>  </p>\n<p>乌云 (WooYun)(已停服)<br><a href=\"http://wooyun.org/\" target=\"_blank\" rel=\"noopener\">http://wooyun.org/</a><br>可通过如下查乌云数据：<a href=\"http://wooyun.tangscan.cn/\" target=\"_blank\" rel=\"noopener\">http://wooyun.tangscan.cn/</a>  </p>\n<p>补天<br><a href=\"http://loudong.360.cn/\" target=\"_blank\" rel=\"noopener\">http://loudong.360.cn/</a>  </p>\n<p>漏洞盒子<br><a href=\"https://www.vulbox.com/bounties\" target=\"_blank\" rel=\"noopener\">https://www.vulbox.com/bounties</a>  </p>\n<p>阿里SRC<br><a href=\"https://security.alibaba.com/\" target=\"_blank\" rel=\"noopener\">https://security.alibaba.com/</a>  </p>\n<p>腾讯SRC<br><a href=\"https://security.tencent.com/\" target=\"_blank\" rel=\"noopener\">https://security.tencent.com/</a>  </p>\n"},{"title":"TODO-主要设计模式及简要介绍","date":"2017-05-02T05:48:00.000Z","_content":"#java设计模式分类\n\n#设计模式概述","source":"_posts/设计模式/主要设计模式及简要介绍.md","raw":"---\ntitle: TODO-主要设计模式及简要介绍\ndate: 2017-05-02 13:48:00\ntags: [软件工程,设计模式]\ncategories: [软件工程,设计模式]\n---\n#java设计模式分类\n\n#设计模式概述","slug":"设计模式/主要设计模式及简要介绍","published":1,"updated":"2017-08-18T01:44:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bk2002is77r8pw39ofr","content":"<p>#java设计模式分类</p>\n<p>#设计模式概述</p>\n","site":{"data":{}},"excerpt":"","more":"<p>#java设计模式分类</p>\n<p>#设计模式概述</p>\n"},{"title":"数据中台建设杂谈","date":"2018-12-05T01:55:00.000Z","_content":"现状\n公司属于是互联网金融行业，但因为只是中小型企业，技术积累较少，数据部门也是16年未开始组建的。最初只是一个提数小组，为业务部门提供他们需要的数据，直到上层领导有意走数据驱动业务的方式，才创建了数据部，也可能只是为了赶时髦，毕境17年，各种GB、TB已经满天飞。\n\n于是领导就带领着大家搞起了大数据，创建了最初的仓库平台、搭建了报表平台、可视化平台，对业务提供支撑。几乎没有相关技术储备，可以说从０到１，轰轰烈烈，加班加点搞了几个月，初见成效。在做大数据平台的同时，也引入了一些数据应用产品，比如多维分析的saiku，BI工具SuperSet，用于提供报表和提数需求；并且也开发了自己的数据管理平台、统一调度中心，可以小有成就。\n\n18年年初（3月初左右）公司上层决策创建金融事业中心并单独运营，部门负责人被抽离到金融，并带走部分核心人员，再加上离职人员，技术所剩无几，导致后续大数据平台停步不前，没有什么新的产品开发，日常工作即停留在对原有系统的使用上，应对越来越多的提数需求和个性化的业务定制需求，响应乏力。同事们也有心改造，但无奈人员缺乏，技术储备不足等原因，未能见成效。\n\n当然，近1年多的时间同事们也没有闲着，在完成工作的时事，尝试了一些大数据应用的技术和方案，算是做了些相关技能的存储。\n\n### 设想\n2018Q4研发中心架构调整，欲建立去中心化的开发平台，即各业务部门各自管理自己的应用和数据，同时同步到数据中台。各业务部门对其它部门的数据需求，统一走数据中台。所以数据部又一次走到了风口，面临压力，着手改造。\n\n现有的数据仓库架构\n如下图所示，按照业内标准的数据架构，数据采集层、数据计算层、数据服务层、数据应用层进行描述。\n![\"现有的数据仓库架构\"](/images/数据中台/现有的数据仓库架构.jpg)\n\n首先是从各业务部门数据库，通过OGG、Sqoop、DataX、Kettle等工具同步定时同步数据到数据中心存储系统上，包括大数据平台HDFS、关系型数据库。然后提供几种查询平台，如kylin、hive、oracle等，进行数据获取，如通过Kylin建模的方式，离线预处理T-1的离线数据；通过oracle数据库，提数人员写SQL查询等，得到想要的数据，目前只支持离线数据。数据同步完成对，外的的数据服务，目前提供了手工提数工单、数据网关接口、帆软BI报表、帆软可视化等方式对业务部门提供查询。\n\n### 标准数据中台构架\n如下图所示\n![\"标准数据中台构架\"](/images/数据中台/标准数据中台构架.jpg)\n\n\n通用的数据中台架构，即从数据同步->模型抽象->对外应用进行划分，其中操作层作了些同步、清洗、日志采集等收集数据的事情；公共维度对业务数据进行建模，划分度量、维度等对数据进行建模，当然也可以采用其它建模方式；应用数据层是对创建好的数据对外提供服务的方式，包含传输数据的渠道、展示数据的方式等。\n\n从我们现有的架构的数据仓库架构来看，最初也是按照这个架构进行设计的。但从具体的实现去分析实则存在很多的问题，及需要改进的地方。下面对现有架构的问题进行一下分析。\n\n存在的问题\n当前系统架构，对于技术的应用边界、所选技术的性能等问题没有明确的说明。大致列举如下：\n\n1. 数据同步就有OGG、DataX、Sqoop、Kettle，到你在什么情况下使用OGG比较好，在什么情况下应该使用DataX等问题没有明确界线；另外是否需要这么多同步技术支撑，还是说选择1个主流技术和一个补偿机制即可。\n\n现在的大数据平台，只是搭建完成，功能只使用了基础的hdfs／hive，对于其它的技术没用实践；\n\n2. 数据同步离线可以多种方式实现，目前实时同步使用的是OGG数据同步。OGG同步是公司DBA进行管理，这方面的责任是否清晰，如果出问题，他们是否能积极支援。\n\n3. 公共维度模型层目前是使用kylin做离线OLAP计算，内部采用维度建模思想，这些建模示例能否单独抽象出来，应用在其它的查询或提数方式，更有利于扩展。\n\n4.计算引擎单一，目前只有hive方式查询，对于近实时的要求高的应用就不能满足了。应该提供批和流同步支持的查询，针对不同的情况，选择不同的查询引擎。\n\n5.同步与查询模块，能否经受得住后期全业务部门的数据查询需求和高并发、大数据量的考验。需要做哪些改进。\n\n我们能改进的点\n1. 应该针对不同的查询需求，提供不同的数据服务出口。比如规范性强的直接走数据网关；定制化要求高的可以走报表；个性化的数据可以走提数工单，定义好边界。\n\n2. 提供批和流两种查询支持。计算是仓库的大脑，如果速度慢，完全影响体验及数据的反馈。\n\n3. 数据建模。应该统一数据建模，建议规范定义和整理，用于数据提取或自助提数。也可减少与业务人员的理解分歧。\n\n### 理想的仓库\n如图所示。\n![\"理想的仓库\"](/images/数据中台/理想的仓库.jpg)\n\n提供批流两种计算方式、对外针对不同的需求，提供不同的对外数据输出。优化建模，改进同步，增加消息同步补偿。\n\n最后\n个人见解，很多不足，后期再变更吧。另外理想很丰满，现实很骨感，4季度结束再回头看吧。\n\n参考\n阿里巴巴《大数据之路》\n\n","source":"_posts/数据中台/数据中台建设杂谈.md","raw":"---\ntitle: 数据中台建设杂谈\ndate: 2018-12-05 09:55:00\ntags: [模型设计]\ncategories: [数据中台]\n---\n现状\n公司属于是互联网金融行业，但因为只是中小型企业，技术积累较少，数据部门也是16年未开始组建的。最初只是一个提数小组，为业务部门提供他们需要的数据，直到上层领导有意走数据驱动业务的方式，才创建了数据部，也可能只是为了赶时髦，毕境17年，各种GB、TB已经满天飞。\n\n于是领导就带领着大家搞起了大数据，创建了最初的仓库平台、搭建了报表平台、可视化平台，对业务提供支撑。几乎没有相关技术储备，可以说从０到１，轰轰烈烈，加班加点搞了几个月，初见成效。在做大数据平台的同时，也引入了一些数据应用产品，比如多维分析的saiku，BI工具SuperSet，用于提供报表和提数需求；并且也开发了自己的数据管理平台、统一调度中心，可以小有成就。\n\n18年年初（3月初左右）公司上层决策创建金融事业中心并单独运营，部门负责人被抽离到金融，并带走部分核心人员，再加上离职人员，技术所剩无几，导致后续大数据平台停步不前，没有什么新的产品开发，日常工作即停留在对原有系统的使用上，应对越来越多的提数需求和个性化的业务定制需求，响应乏力。同事们也有心改造，但无奈人员缺乏，技术储备不足等原因，未能见成效。\n\n当然，近1年多的时间同事们也没有闲着，在完成工作的时事，尝试了一些大数据应用的技术和方案，算是做了些相关技能的存储。\n\n### 设想\n2018Q4研发中心架构调整，欲建立去中心化的开发平台，即各业务部门各自管理自己的应用和数据，同时同步到数据中台。各业务部门对其它部门的数据需求，统一走数据中台。所以数据部又一次走到了风口，面临压力，着手改造。\n\n现有的数据仓库架构\n如下图所示，按照业内标准的数据架构，数据采集层、数据计算层、数据服务层、数据应用层进行描述。\n![\"现有的数据仓库架构\"](/images/数据中台/现有的数据仓库架构.jpg)\n\n首先是从各业务部门数据库，通过OGG、Sqoop、DataX、Kettle等工具同步定时同步数据到数据中心存储系统上，包括大数据平台HDFS、关系型数据库。然后提供几种查询平台，如kylin、hive、oracle等，进行数据获取，如通过Kylin建模的方式，离线预处理T-1的离线数据；通过oracle数据库，提数人员写SQL查询等，得到想要的数据，目前只支持离线数据。数据同步完成对，外的的数据服务，目前提供了手工提数工单、数据网关接口、帆软BI报表、帆软可视化等方式对业务部门提供查询。\n\n### 标准数据中台构架\n如下图所示\n![\"标准数据中台构架\"](/images/数据中台/标准数据中台构架.jpg)\n\n\n通用的数据中台架构，即从数据同步->模型抽象->对外应用进行划分，其中操作层作了些同步、清洗、日志采集等收集数据的事情；公共维度对业务数据进行建模，划分度量、维度等对数据进行建模，当然也可以采用其它建模方式；应用数据层是对创建好的数据对外提供服务的方式，包含传输数据的渠道、展示数据的方式等。\n\n从我们现有的架构的数据仓库架构来看，最初也是按照这个架构进行设计的。但从具体的实现去分析实则存在很多的问题，及需要改进的地方。下面对现有架构的问题进行一下分析。\n\n存在的问题\n当前系统架构，对于技术的应用边界、所选技术的性能等问题没有明确的说明。大致列举如下：\n\n1. 数据同步就有OGG、DataX、Sqoop、Kettle，到你在什么情况下使用OGG比较好，在什么情况下应该使用DataX等问题没有明确界线；另外是否需要这么多同步技术支撑，还是说选择1个主流技术和一个补偿机制即可。\n\n现在的大数据平台，只是搭建完成，功能只使用了基础的hdfs／hive，对于其它的技术没用实践；\n\n2. 数据同步离线可以多种方式实现，目前实时同步使用的是OGG数据同步。OGG同步是公司DBA进行管理，这方面的责任是否清晰，如果出问题，他们是否能积极支援。\n\n3. 公共维度模型层目前是使用kylin做离线OLAP计算，内部采用维度建模思想，这些建模示例能否单独抽象出来，应用在其它的查询或提数方式，更有利于扩展。\n\n4.计算引擎单一，目前只有hive方式查询，对于近实时的要求高的应用就不能满足了。应该提供批和流同步支持的查询，针对不同的情况，选择不同的查询引擎。\n\n5.同步与查询模块，能否经受得住后期全业务部门的数据查询需求和高并发、大数据量的考验。需要做哪些改进。\n\n我们能改进的点\n1. 应该针对不同的查询需求，提供不同的数据服务出口。比如规范性强的直接走数据网关；定制化要求高的可以走报表；个性化的数据可以走提数工单，定义好边界。\n\n2. 提供批和流两种查询支持。计算是仓库的大脑，如果速度慢，完全影响体验及数据的反馈。\n\n3. 数据建模。应该统一数据建模，建议规范定义和整理，用于数据提取或自助提数。也可减少与业务人员的理解分歧。\n\n### 理想的仓库\n如图所示。\n![\"理想的仓库\"](/images/数据中台/理想的仓库.jpg)\n\n提供批流两种计算方式、对外针对不同的需求，提供不同的对外数据输出。优化建模，改进同步，增加消息同步补偿。\n\n最后\n个人见解，很多不足，后期再变更吧。另外理想很丰满，现实很骨感，4季度结束再回头看吧。\n\n参考\n阿里巴巴《大数据之路》\n\n","slug":"数据中台/数据中台建设杂谈","published":1,"updated":"2019-03-14T02:50:50.663Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bk3002ks77rlo0w2c5r","content":"<p>现状<br>公司属于是互联网金融行业，但因为只是中小型企业，技术积累较少，数据部门也是16年未开始组建的。最初只是一个提数小组，为业务部门提供他们需要的数据，直到上层领导有意走数据驱动业务的方式，才创建了数据部，也可能只是为了赶时髦，毕境17年，各种GB、TB已经满天飞。</p>\n<p>于是领导就带领着大家搞起了大数据，创建了最初的仓库平台、搭建了报表平台、可视化平台，对业务提供支撑。几乎没有相关技术储备，可以说从０到１，轰轰烈烈，加班加点搞了几个月，初见成效。在做大数据平台的同时，也引入了一些数据应用产品，比如多维分析的saiku，BI工具SuperSet，用于提供报表和提数需求；并且也开发了自己的数据管理平台、统一调度中心，可以小有成就。</p>\n<p>18年年初（3月初左右）公司上层决策创建金融事业中心并单独运营，部门负责人被抽离到金融，并带走部分核心人员，再加上离职人员，技术所剩无几，导致后续大数据平台停步不前，没有什么新的产品开发，日常工作即停留在对原有系统的使用上，应对越来越多的提数需求和个性化的业务定制需求，响应乏力。同事们也有心改造，但无奈人员缺乏，技术储备不足等原因，未能见成效。</p>\n<p>当然，近1年多的时间同事们也没有闲着，在完成工作的时事，尝试了一些大数据应用的技术和方案，算是做了些相关技能的存储。</p>\n<h3 id=\"设想\"><a href=\"#设想\" class=\"headerlink\" title=\"设想\"></a>设想</h3><p>2018Q4研发中心架构调整，欲建立去中心化的开发平台，即各业务部门各自管理自己的应用和数据，同时同步到数据中台。各业务部门对其它部门的数据需求，统一走数据中台。所以数据部又一次走到了风口，面临压力，着手改造。</p>\n<p>现有的数据仓库架构<br>如下图所示，按照业内标准的数据架构，数据采集层、数据计算层、数据服务层、数据应用层进行描述。<br><img src=\"/images/数据中台/现有的数据仓库架构.jpg\" alt=\"&quot;现有的数据仓库架构&quot;\"></p>\n<p>首先是从各业务部门数据库，通过OGG、Sqoop、DataX、Kettle等工具同步定时同步数据到数据中心存储系统上，包括大数据平台HDFS、关系型数据库。然后提供几种查询平台，如kylin、hive、oracle等，进行数据获取，如通过Kylin建模的方式，离线预处理T-1的离线数据；通过oracle数据库，提数人员写SQL查询等，得到想要的数据，目前只支持离线数据。数据同步完成对，外的的数据服务，目前提供了手工提数工单、数据网关接口、帆软BI报表、帆软可视化等方式对业务部门提供查询。</p>\n<h3 id=\"标准数据中台构架\"><a href=\"#标准数据中台构架\" class=\"headerlink\" title=\"标准数据中台构架\"></a>标准数据中台构架</h3><p>如下图所示<br><img src=\"/images/数据中台/标准数据中台构架.jpg\" alt=\"&quot;标准数据中台构架&quot;\"></p>\n<p>通用的数据中台架构，即从数据同步-&gt;模型抽象-&gt;对外应用进行划分，其中操作层作了些同步、清洗、日志采集等收集数据的事情；公共维度对业务数据进行建模，划分度量、维度等对数据进行建模，当然也可以采用其它建模方式；应用数据层是对创建好的数据对外提供服务的方式，包含传输数据的渠道、展示数据的方式等。</p>\n<p>从我们现有的架构的数据仓库架构来看，最初也是按照这个架构进行设计的。但从具体的实现去分析实则存在很多的问题，及需要改进的地方。下面对现有架构的问题进行一下分析。</p>\n<p>存在的问题<br>当前系统架构，对于技术的应用边界、所选技术的性能等问题没有明确的说明。大致列举如下：</p>\n<ol>\n<li>数据同步就有OGG、DataX、Sqoop、Kettle，到你在什么情况下使用OGG比较好，在什么情况下应该使用DataX等问题没有明确界线；另外是否需要这么多同步技术支撑，还是说选择1个主流技术和一个补偿机制即可。</li>\n</ol>\n<p>现在的大数据平台，只是搭建完成，功能只使用了基础的hdfs／hive，对于其它的技术没用实践；</p>\n<ol start=\"2\">\n<li><p>数据同步离线可以多种方式实现，目前实时同步使用的是OGG数据同步。OGG同步是公司DBA进行管理，这方面的责任是否清晰，如果出问题，他们是否能积极支援。</p>\n</li>\n<li><p>公共维度模型层目前是使用kylin做离线OLAP计算，内部采用维度建模思想，这些建模示例能否单独抽象出来，应用在其它的查询或提数方式，更有利于扩展。</p>\n</li>\n</ol>\n<p>4.计算引擎单一，目前只有hive方式查询，对于近实时的要求高的应用就不能满足了。应该提供批和流同步支持的查询，针对不同的情况，选择不同的查询引擎。</p>\n<p>5.同步与查询模块，能否经受得住后期全业务部门的数据查询需求和高并发、大数据量的考验。需要做哪些改进。</p>\n<p>我们能改进的点</p>\n<ol>\n<li><p>应该针对不同的查询需求，提供不同的数据服务出口。比如规范性强的直接走数据网关；定制化要求高的可以走报表；个性化的数据可以走提数工单，定义好边界。</p>\n</li>\n<li><p>提供批和流两种查询支持。计算是仓库的大脑，如果速度慢，完全影响体验及数据的反馈。</p>\n</li>\n<li><p>数据建模。应该统一数据建模，建议规范定义和整理，用于数据提取或自助提数。也可减少与业务人员的理解分歧。</p>\n</li>\n</ol>\n<h3 id=\"理想的仓库\"><a href=\"#理想的仓库\" class=\"headerlink\" title=\"理想的仓库\"></a>理想的仓库</h3><p>如图所示。<br><img src=\"/images/数据中台/理想的仓库.jpg\" alt=\"&quot;理想的仓库&quot;\"></p>\n<p>提供批流两种计算方式、对外针对不同的需求，提供不同的对外数据输出。优化建模，改进同步，增加消息同步补偿。</p>\n<p>最后<br>个人见解，很多不足，后期再变更吧。另外理想很丰满，现实很骨感，4季度结束再回头看吧。</p>\n<p>参考<br>阿里巴巴《大数据之路》</p>\n","site":{"data":{}},"excerpt":"","more":"<p>现状<br>公司属于是互联网金融行业，但因为只是中小型企业，技术积累较少，数据部门也是16年未开始组建的。最初只是一个提数小组，为业务部门提供他们需要的数据，直到上层领导有意走数据驱动业务的方式，才创建了数据部，也可能只是为了赶时髦，毕境17年，各种GB、TB已经满天飞。</p>\n<p>于是领导就带领着大家搞起了大数据，创建了最初的仓库平台、搭建了报表平台、可视化平台，对业务提供支撑。几乎没有相关技术储备，可以说从０到１，轰轰烈烈，加班加点搞了几个月，初见成效。在做大数据平台的同时，也引入了一些数据应用产品，比如多维分析的saiku，BI工具SuperSet，用于提供报表和提数需求；并且也开发了自己的数据管理平台、统一调度中心，可以小有成就。</p>\n<p>18年年初（3月初左右）公司上层决策创建金融事业中心并单独运营，部门负责人被抽离到金融，并带走部分核心人员，再加上离职人员，技术所剩无几，导致后续大数据平台停步不前，没有什么新的产品开发，日常工作即停留在对原有系统的使用上，应对越来越多的提数需求和个性化的业务定制需求，响应乏力。同事们也有心改造，但无奈人员缺乏，技术储备不足等原因，未能见成效。</p>\n<p>当然，近1年多的时间同事们也没有闲着，在完成工作的时事，尝试了一些大数据应用的技术和方案，算是做了些相关技能的存储。</p>\n<h3 id=\"设想\"><a href=\"#设想\" class=\"headerlink\" title=\"设想\"></a>设想</h3><p>2018Q4研发中心架构调整，欲建立去中心化的开发平台，即各业务部门各自管理自己的应用和数据，同时同步到数据中台。各业务部门对其它部门的数据需求，统一走数据中台。所以数据部又一次走到了风口，面临压力，着手改造。</p>\n<p>现有的数据仓库架构<br>如下图所示，按照业内标准的数据架构，数据采集层、数据计算层、数据服务层、数据应用层进行描述。<br><img src=\"/images/数据中台/现有的数据仓库架构.jpg\" alt=\"&quot;现有的数据仓库架构&quot;\"></p>\n<p>首先是从各业务部门数据库，通过OGG、Sqoop、DataX、Kettle等工具同步定时同步数据到数据中心存储系统上，包括大数据平台HDFS、关系型数据库。然后提供几种查询平台，如kylin、hive、oracle等，进行数据获取，如通过Kylin建模的方式，离线预处理T-1的离线数据；通过oracle数据库，提数人员写SQL查询等，得到想要的数据，目前只支持离线数据。数据同步完成对，外的的数据服务，目前提供了手工提数工单、数据网关接口、帆软BI报表、帆软可视化等方式对业务部门提供查询。</p>\n<h3 id=\"标准数据中台构架\"><a href=\"#标准数据中台构架\" class=\"headerlink\" title=\"标准数据中台构架\"></a>标准数据中台构架</h3><p>如下图所示<br><img src=\"/images/数据中台/标准数据中台构架.jpg\" alt=\"&quot;标准数据中台构架&quot;\"></p>\n<p>通用的数据中台架构，即从数据同步-&gt;模型抽象-&gt;对外应用进行划分，其中操作层作了些同步、清洗、日志采集等收集数据的事情；公共维度对业务数据进行建模，划分度量、维度等对数据进行建模，当然也可以采用其它建模方式；应用数据层是对创建好的数据对外提供服务的方式，包含传输数据的渠道、展示数据的方式等。</p>\n<p>从我们现有的架构的数据仓库架构来看，最初也是按照这个架构进行设计的。但从具体的实现去分析实则存在很多的问题，及需要改进的地方。下面对现有架构的问题进行一下分析。</p>\n<p>存在的问题<br>当前系统架构，对于技术的应用边界、所选技术的性能等问题没有明确的说明。大致列举如下：</p>\n<ol>\n<li>数据同步就有OGG、DataX、Sqoop、Kettle，到你在什么情况下使用OGG比较好，在什么情况下应该使用DataX等问题没有明确界线；另外是否需要这么多同步技术支撑，还是说选择1个主流技术和一个补偿机制即可。</li>\n</ol>\n<p>现在的大数据平台，只是搭建完成，功能只使用了基础的hdfs／hive，对于其它的技术没用实践；</p>\n<ol start=\"2\">\n<li><p>数据同步离线可以多种方式实现，目前实时同步使用的是OGG数据同步。OGG同步是公司DBA进行管理，这方面的责任是否清晰，如果出问题，他们是否能积极支援。</p>\n</li>\n<li><p>公共维度模型层目前是使用kylin做离线OLAP计算，内部采用维度建模思想，这些建模示例能否单独抽象出来，应用在其它的查询或提数方式，更有利于扩展。</p>\n</li>\n</ol>\n<p>4.计算引擎单一，目前只有hive方式查询，对于近实时的要求高的应用就不能满足了。应该提供批和流同步支持的查询，针对不同的情况，选择不同的查询引擎。</p>\n<p>5.同步与查询模块，能否经受得住后期全业务部门的数据查询需求和高并发、大数据量的考验。需要做哪些改进。</p>\n<p>我们能改进的点</p>\n<ol>\n<li><p>应该针对不同的查询需求，提供不同的数据服务出口。比如规范性强的直接走数据网关；定制化要求高的可以走报表；个性化的数据可以走提数工单，定义好边界。</p>\n</li>\n<li><p>提供批和流两种查询支持。计算是仓库的大脑，如果速度慢，完全影响体验及数据的反馈。</p>\n</li>\n<li><p>数据建模。应该统一数据建模，建议规范定义和整理，用于数据提取或自助提数。也可减少与业务人员的理解分歧。</p>\n</li>\n</ol>\n<h3 id=\"理想的仓库\"><a href=\"#理想的仓库\" class=\"headerlink\" title=\"理想的仓库\"></a>理想的仓库</h3><p>如图所示。<br><img src=\"/images/数据中台/理想的仓库.jpg\" alt=\"&quot;理想的仓库&quot;\"></p>\n<p>提供批流两种计算方式、对外针对不同的需求，提供不同的对外数据输出。优化建模，改进同步，增加消息同步补偿。</p>\n<p>最后<br>个人见解，很多不足，后期再变更吧。另外理想很丰满，现实很骨感，4季度结束再回头看吧。</p>\n<p>参考<br>阿里巴巴《大数据之路》</p>\n"},{"title":"数据建模-维度","date":"2019-01-18T01:55:00.000Z","_content":"\n### 维度的基本概念\n维度是维度建模的基础和灵魂。在维度建模中，将度量称为“事实”将环境描述为“维度”，维度是用于分析事实所需要的多样环境。例如，在分析交易过程时，可以通过买家、卖家、商品和时间等维度描述交易发生的环境。\n    维度所包含的表示维度的列，称为维度属性。**维度属性是查询约束条件、分组和报表标签生成的基本来源，是数据易用性的关键。**例如，在查询请求中，获取某类目的商品、正常状态的商品等，是通过约束商品类目属性和商品状态属性来实现的；统计淘宝不同商品类目的每日成交金额，是通过商品维度的类目属性进行分组的；我们在报表中看到的类目、BC类型（B指天猫、C指集市）等，都是维度属性。**所以维度的作用一般是查询约束、分类汇总及排序等。**\n    \n#### 如何获取维度或维度属性？\n如上面所提到的，一方面，可以在报表中获取；另一方面，可以在和业务人员的交谈中发现维度或维度属性。因为它们经常出现在查询或报表请求中的“按照”（by）语句内。例如，用户要“按照”月份和产品来查询销售情况，那么用来描述其业务的自然方法应该作为维度或维度属性包括在维度模型中。\n\n维度使用主键标识其唯一性，主键也是确保与之相连的任何事实表之间存储引用完整性的基础。主键有两种：代理键和自然键，它们都是用于标识某维度的具体值。但代理键是不具有业务含义的键，一般用于处理缓慢变化维；自然键是具有业务含义的键。比如商品，在ETL过程中，对于商品维表的每一行，可以生成一个唯一的代理键与之对应；商品本身的自然键可能是商品id等。其实对于前台应用系统来说，商品ID是代理键；而对于数据仓库系统来说，商品Id则属于自然键。\n\n### 维度的基本设计方法\n维度的设计过程就是确定维度属性的过程，如何生成维度属性，以及所生成的维度属性的优劣，决定了维度使用的方便性，成为数据仓库易用性的关键。正如Kimball所说的，数**据仓库的能力直接与维度属性的质量和深度成正比。**\n\n下面以淘宝的商品维度为例对维度设计方法进行详细说明。\n第一步：选择维度和新建维度。作为维度建模的核心，在企业级数据仓库中必须保证维度的唯一性。以淘宝商品维度为例，有且只允许有一个维度定义。\n第二步：确定主维表。此处的主维表一般是ODS表，直接与业务系统同步。以淘宝商品维度为例，s_auction_auctions是与前台商品中心系统同步的商品表，此表即是主维表。\n第三步：确定相关维表。数据仓库是业务源系统的数据整合，不同业务系统或者同一业务系统中的表之间存在关联性。根据对业务的梳理，确定哪些表和主维表存在关联关系，并选择其中的某些表用于生成 维度属性。以淘宝商品维度为例，根据对业务逻辑的梳理，可以得到商品与类目、SPU、店铺等维度存在关联关系。\n第四步：确定维度属性。本步骤主要包括两个阶段，其中第一个阶段是从主维表中选择维度属性或生成新的维度属性；第二阶段是从相关维表中选择维度属性或生成新的维度属性。以淘宝商品维度为例，从主维表（s_auction_auctions）和类目、SPU、卖家、店铺等相关维表中选择维度属性或生成 新的维度属性。\n\n\n### 参考\n阿里巴巴《大数据之路》","source":"_posts/数据中台/数据建模-维度.md","raw":"---\ntitle: 数据建模-维度\ndate: 2019-01-18 09:55:00\ntags: [模型设计]\ncategories: [数据中台,模型设计]\n---\n\n### 维度的基本概念\n维度是维度建模的基础和灵魂。在维度建模中，将度量称为“事实”将环境描述为“维度”，维度是用于分析事实所需要的多样环境。例如，在分析交易过程时，可以通过买家、卖家、商品和时间等维度描述交易发生的环境。\n    维度所包含的表示维度的列，称为维度属性。**维度属性是查询约束条件、分组和报表标签生成的基本来源，是数据易用性的关键。**例如，在查询请求中，获取某类目的商品、正常状态的商品等，是通过约束商品类目属性和商品状态属性来实现的；统计淘宝不同商品类目的每日成交金额，是通过商品维度的类目属性进行分组的；我们在报表中看到的类目、BC类型（B指天猫、C指集市）等，都是维度属性。**所以维度的作用一般是查询约束、分类汇总及排序等。**\n    \n#### 如何获取维度或维度属性？\n如上面所提到的，一方面，可以在报表中获取；另一方面，可以在和业务人员的交谈中发现维度或维度属性。因为它们经常出现在查询或报表请求中的“按照”（by）语句内。例如，用户要“按照”月份和产品来查询销售情况，那么用来描述其业务的自然方法应该作为维度或维度属性包括在维度模型中。\n\n维度使用主键标识其唯一性，主键也是确保与之相连的任何事实表之间存储引用完整性的基础。主键有两种：代理键和自然键，它们都是用于标识某维度的具体值。但代理键是不具有业务含义的键，一般用于处理缓慢变化维；自然键是具有业务含义的键。比如商品，在ETL过程中，对于商品维表的每一行，可以生成一个唯一的代理键与之对应；商品本身的自然键可能是商品id等。其实对于前台应用系统来说，商品ID是代理键；而对于数据仓库系统来说，商品Id则属于自然键。\n\n### 维度的基本设计方法\n维度的设计过程就是确定维度属性的过程，如何生成维度属性，以及所生成的维度属性的优劣，决定了维度使用的方便性，成为数据仓库易用性的关键。正如Kimball所说的，数**据仓库的能力直接与维度属性的质量和深度成正比。**\n\n下面以淘宝的商品维度为例对维度设计方法进行详细说明。\n第一步：选择维度和新建维度。作为维度建模的核心，在企业级数据仓库中必须保证维度的唯一性。以淘宝商品维度为例，有且只允许有一个维度定义。\n第二步：确定主维表。此处的主维表一般是ODS表，直接与业务系统同步。以淘宝商品维度为例，s_auction_auctions是与前台商品中心系统同步的商品表，此表即是主维表。\n第三步：确定相关维表。数据仓库是业务源系统的数据整合，不同业务系统或者同一业务系统中的表之间存在关联性。根据对业务的梳理，确定哪些表和主维表存在关联关系，并选择其中的某些表用于生成 维度属性。以淘宝商品维度为例，根据对业务逻辑的梳理，可以得到商品与类目、SPU、店铺等维度存在关联关系。\n第四步：确定维度属性。本步骤主要包括两个阶段，其中第一个阶段是从主维表中选择维度属性或生成新的维度属性；第二阶段是从相关维表中选择维度属性或生成新的维度属性。以淘宝商品维度为例，从主维表（s_auction_auctions）和类目、SPU、卖家、店铺等相关维表中选择维度属性或生成 新的维度属性。\n\n\n### 参考\n阿里巴巴《大数据之路》","slug":"数据中台/数据建模-维度","published":1,"updated":"2019-03-13T09:58:30.046Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bk5002ps77rqwfrkanj","content":"<h3 id=\"维度的基本概念\"><a href=\"#维度的基本概念\" class=\"headerlink\" title=\"维度的基本概念\"></a>维度的基本概念</h3><p>维度是维度建模的基础和灵魂。在维度建模中，将度量称为“事实”将环境描述为“维度”，维度是用于分析事实所需要的多样环境。例如，在分析交易过程时，可以通过买家、卖家、商品和时间等维度描述交易发生的环境。<br>    维度所包含的表示维度的列，称为维度属性。<strong>维度属性是查询约束条件、分组和报表标签生成的基本来源，是数据易用性的关键。</strong>例如，在查询请求中，获取某类目的商品、正常状态的商品等，是通过约束商品类目属性和商品状态属性来实现的；统计淘宝不同商品类目的每日成交金额，是通过商品维度的类目属性进行分组的；我们在报表中看到的类目、BC类型（B指天猫、C指集市）等，都是维度属性。<strong>所以维度的作用一般是查询约束、分类汇总及排序等。</strong></p>\n<h4 id=\"如何获取维度或维度属性？\"><a href=\"#如何获取维度或维度属性？\" class=\"headerlink\" title=\"如何获取维度或维度属性？\"></a>如何获取维度或维度属性？</h4><p>如上面所提到的，一方面，可以在报表中获取；另一方面，可以在和业务人员的交谈中发现维度或维度属性。因为它们经常出现在查询或报表请求中的“按照”（by）语句内。例如，用户要“按照”月份和产品来查询销售情况，那么用来描述其业务的自然方法应该作为维度或维度属性包括在维度模型中。</p>\n<p>维度使用主键标识其唯一性，主键也是确保与之相连的任何事实表之间存储引用完整性的基础。主键有两种：代理键和自然键，它们都是用于标识某维度的具体值。但代理键是不具有业务含义的键，一般用于处理缓慢变化维；自然键是具有业务含义的键。比如商品，在ETL过程中，对于商品维表的每一行，可以生成一个唯一的代理键与之对应；商品本身的自然键可能是商品id等。其实对于前台应用系统来说，商品ID是代理键；而对于数据仓库系统来说，商品Id则属于自然键。</p>\n<h3 id=\"维度的基本设计方法\"><a href=\"#维度的基本设计方法\" class=\"headerlink\" title=\"维度的基本设计方法\"></a>维度的基本设计方法</h3><p>维度的设计过程就是确定维度属性的过程，如何生成维度属性，以及所生成的维度属性的优劣，决定了维度使用的方便性，成为数据仓库易用性的关键。正如Kimball所说的，数<strong>据仓库的能力直接与维度属性的质量和深度成正比。</strong></p>\n<p>下面以淘宝的商品维度为例对维度设计方法进行详细说明。<br>第一步：选择维度和新建维度。作为维度建模的核心，在企业级数据仓库中必须保证维度的唯一性。以淘宝商品维度为例，有且只允许有一个维度定义。<br>第二步：确定主维表。此处的主维表一般是ODS表，直接与业务系统同步。以淘宝商品维度为例，s_auction_auctions是与前台商品中心系统同步的商品表，此表即是主维表。<br>第三步：确定相关维表。数据仓库是业务源系统的数据整合，不同业务系统或者同一业务系统中的表之间存在关联性。根据对业务的梳理，确定哪些表和主维表存在关联关系，并选择其中的某些表用于生成 维度属性。以淘宝商品维度为例，根据对业务逻辑的梳理，可以得到商品与类目、SPU、店铺等维度存在关联关系。<br>第四步：确定维度属性。本步骤主要包括两个阶段，其中第一个阶段是从主维表中选择维度属性或生成新的维度属性；第二阶段是从相关维表中选择维度属性或生成新的维度属性。以淘宝商品维度为例，从主维表（s_auction_auctions）和类目、SPU、卖家、店铺等相关维表中选择维度属性或生成 新的维度属性。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p>阿里巴巴《大数据之路》</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"维度的基本概念\"><a href=\"#维度的基本概念\" class=\"headerlink\" title=\"维度的基本概念\"></a>维度的基本概念</h3><p>维度是维度建模的基础和灵魂。在维度建模中，将度量称为“事实”将环境描述为“维度”，维度是用于分析事实所需要的多样环境。例如，在分析交易过程时，可以通过买家、卖家、商品和时间等维度描述交易发生的环境。<br>    维度所包含的表示维度的列，称为维度属性。<strong>维度属性是查询约束条件、分组和报表标签生成的基本来源，是数据易用性的关键。</strong>例如，在查询请求中，获取某类目的商品、正常状态的商品等，是通过约束商品类目属性和商品状态属性来实现的；统计淘宝不同商品类目的每日成交金额，是通过商品维度的类目属性进行分组的；我们在报表中看到的类目、BC类型（B指天猫、C指集市）等，都是维度属性。<strong>所以维度的作用一般是查询约束、分类汇总及排序等。</strong></p>\n<h4 id=\"如何获取维度或维度属性？\"><a href=\"#如何获取维度或维度属性？\" class=\"headerlink\" title=\"如何获取维度或维度属性？\"></a>如何获取维度或维度属性？</h4><p>如上面所提到的，一方面，可以在报表中获取；另一方面，可以在和业务人员的交谈中发现维度或维度属性。因为它们经常出现在查询或报表请求中的“按照”（by）语句内。例如，用户要“按照”月份和产品来查询销售情况，那么用来描述其业务的自然方法应该作为维度或维度属性包括在维度模型中。</p>\n<p>维度使用主键标识其唯一性，主键也是确保与之相连的任何事实表之间存储引用完整性的基础。主键有两种：代理键和自然键，它们都是用于标识某维度的具体值。但代理键是不具有业务含义的键，一般用于处理缓慢变化维；自然键是具有业务含义的键。比如商品，在ETL过程中，对于商品维表的每一行，可以生成一个唯一的代理键与之对应；商品本身的自然键可能是商品id等。其实对于前台应用系统来说，商品ID是代理键；而对于数据仓库系统来说，商品Id则属于自然键。</p>\n<h3 id=\"维度的基本设计方法\"><a href=\"#维度的基本设计方法\" class=\"headerlink\" title=\"维度的基本设计方法\"></a>维度的基本设计方法</h3><p>维度的设计过程就是确定维度属性的过程，如何生成维度属性，以及所生成的维度属性的优劣，决定了维度使用的方便性，成为数据仓库易用性的关键。正如Kimball所说的，数<strong>据仓库的能力直接与维度属性的质量和深度成正比。</strong></p>\n<p>下面以淘宝的商品维度为例对维度设计方法进行详细说明。<br>第一步：选择维度和新建维度。作为维度建模的核心，在企业级数据仓库中必须保证维度的唯一性。以淘宝商品维度为例，有且只允许有一个维度定义。<br>第二步：确定主维表。此处的主维表一般是ODS表，直接与业务系统同步。以淘宝商品维度为例，s_auction_auctions是与前台商品中心系统同步的商品表，此表即是主维表。<br>第三步：确定相关维表。数据仓库是业务源系统的数据整合，不同业务系统或者同一业务系统中的表之间存在关联性。根据对业务的梳理，确定哪些表和主维表存在关联关系，并选择其中的某些表用于生成 维度属性。以淘宝商品维度为例，根据对业务逻辑的梳理，可以得到商品与类目、SPU、店铺等维度存在关联关系。<br>第四步：确定维度属性。本步骤主要包括两个阶段，其中第一个阶段是从主维表中选择维度属性或生成新的维度属性；第二阶段是从相关维表中选择维度属性或生成新的维度属性。以淘宝商品维度为例，从主维表（s_auction_auctions）和类目、SPU、卖家、店铺等相关维表中选择维度属性或生成 新的维度属性。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p>阿里巴巴《大数据之路》</p>\n"},{"title":"数据建模-事实表","date":"2019-02-01T01:55:00.000Z","_content":"\n## 事实表基础\n### 事实表特性\n事实表作为数据仓库维度建模的核心，紧紧围绕着业务过程来设计，通过获取描述业务过程的度量来表达业务过程，包含了引用的维度和业务过程有关的度量。\n\n#### 粒度\n事实表中一条记录所表达的业务细节程度被称为粒度。通常粒度可以通过两种方式来表达；一种是维度属性组合所表示的细节程度；一种是所表示的具体业务含义。\n作为度量业务过程的事实，一般为整形或浮点型的十进制数值，有可加性、半可加性和不可加性三种类型。可加性事实是指可以按照与事实表关联的做任意维度进行汇总。半可加性事实只能按照特定维度汇总，不能对所有维度汇总，比如库存可以按照地点和商品进行汇总，而按时间维度把一年中每个月的库存累加起来则毫无意义。还有一种度量完成不具备可加性，比如比率型事实。对于不可加性事实可分解为可加的组件来实现聚焦。\n\n#### 退化维度\n维表属性也可以存储到事实表中，这种存储到事实表中的维度列被称为“退化维度”。与其他存储在维表中的维度一样，退化维度也可以用来进行事实表的过滤查询、实现聚合操作等。\n\n#### 三种类型\n事实表有三种类型：事务事实表、周期快照事实表和累积快照事实表，\n事务事实表用来描述业务过程，跟踪空间或时间上某点的度量事件，保存的是最原子的数据，也称为“原子事实表”。周期快照事实表以具有规律性的、可预见的时间间隔记录事实，时间间隔如每天、每月、每年等。累积快照事实表用来表述过程开始和结束之间的关键步骤事件，覆盖过程的整个生命周期，通常具有多个日期字段来记录关键时间占，当过程随着生命周期不断变化时，记录也会随着过程的变化而被修改。\n\n### 参考\n阿里巴巴《大数据之路》","source":"_posts/数据中台/数据建模-事实表.md","raw":"---\ntitle: 数据建模-事实表\ndate: 2019-02-01 09:55:00\ntags: [模型设计]\ncategories: [数据中台,模型设计]\n---\n\n## 事实表基础\n### 事实表特性\n事实表作为数据仓库维度建模的核心，紧紧围绕着业务过程来设计，通过获取描述业务过程的度量来表达业务过程，包含了引用的维度和业务过程有关的度量。\n\n#### 粒度\n事实表中一条记录所表达的业务细节程度被称为粒度。通常粒度可以通过两种方式来表达；一种是维度属性组合所表示的细节程度；一种是所表示的具体业务含义。\n作为度量业务过程的事实，一般为整形或浮点型的十进制数值，有可加性、半可加性和不可加性三种类型。可加性事实是指可以按照与事实表关联的做任意维度进行汇总。半可加性事实只能按照特定维度汇总，不能对所有维度汇总，比如库存可以按照地点和商品进行汇总，而按时间维度把一年中每个月的库存累加起来则毫无意义。还有一种度量完成不具备可加性，比如比率型事实。对于不可加性事实可分解为可加的组件来实现聚焦。\n\n#### 退化维度\n维表属性也可以存储到事实表中，这种存储到事实表中的维度列被称为“退化维度”。与其他存储在维表中的维度一样，退化维度也可以用来进行事实表的过滤查询、实现聚合操作等。\n\n#### 三种类型\n事实表有三种类型：事务事实表、周期快照事实表和累积快照事实表，\n事务事实表用来描述业务过程，跟踪空间或时间上某点的度量事件，保存的是最原子的数据，也称为“原子事实表”。周期快照事实表以具有规律性的、可预见的时间间隔记录事实，时间间隔如每天、每月、每年等。累积快照事实表用来表述过程开始和结束之间的关键步骤事件，覆盖过程的整个生命周期，通常具有多个日期字段来记录关键时间占，当过程随着生命周期不断变化时，记录也会随着过程的变化而被修改。\n\n### 参考\n阿里巴巴《大数据之路》","slug":"数据中台/数据建模-事实表","published":1,"updated":"2019-03-13T09:59:23.527Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bkb002rs77rytq00fq1","content":"<h2 id=\"事实表基础\"><a href=\"#事实表基础\" class=\"headerlink\" title=\"事实表基础\"></a>事实表基础</h2><h3 id=\"事实表特性\"><a href=\"#事实表特性\" class=\"headerlink\" title=\"事实表特性\"></a>事实表特性</h3><p>事实表作为数据仓库维度建模的核心，紧紧围绕着业务过程来设计，通过获取描述业务过程的度量来表达业务过程，包含了引用的维度和业务过程有关的度量。</p>\n<h4 id=\"粒度\"><a href=\"#粒度\" class=\"headerlink\" title=\"粒度\"></a>粒度</h4><p>事实表中一条记录所表达的业务细节程度被称为粒度。通常粒度可以通过两种方式来表达；一种是维度属性组合所表示的细节程度；一种是所表示的具体业务含义。<br>作为度量业务过程的事实，一般为整形或浮点型的十进制数值，有可加性、半可加性和不可加性三种类型。可加性事实是指可以按照与事实表关联的做任意维度进行汇总。半可加性事实只能按照特定维度汇总，不能对所有维度汇总，比如库存可以按照地点和商品进行汇总，而按时间维度把一年中每个月的库存累加起来则毫无意义。还有一种度量完成不具备可加性，比如比率型事实。对于不可加性事实可分解为可加的组件来实现聚焦。</p>\n<h4 id=\"退化维度\"><a href=\"#退化维度\" class=\"headerlink\" title=\"退化维度\"></a>退化维度</h4><p>维表属性也可以存储到事实表中，这种存储到事实表中的维度列被称为“退化维度”。与其他存储在维表中的维度一样，退化维度也可以用来进行事实表的过滤查询、实现聚合操作等。</p>\n<h4 id=\"三种类型\"><a href=\"#三种类型\" class=\"headerlink\" title=\"三种类型\"></a>三种类型</h4><p>事实表有三种类型：事务事实表、周期快照事实表和累积快照事实表，<br>事务事实表用来描述业务过程，跟踪空间或时间上某点的度量事件，保存的是最原子的数据，也称为“原子事实表”。周期快照事实表以具有规律性的、可预见的时间间隔记录事实，时间间隔如每天、每月、每年等。累积快照事实表用来表述过程开始和结束之间的关键步骤事件，覆盖过程的整个生命周期，通常具有多个日期字段来记录关键时间占，当过程随着生命周期不断变化时，记录也会随着过程的变化而被修改。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p>阿里巴巴《大数据之路》</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"事实表基础\"><a href=\"#事实表基础\" class=\"headerlink\" title=\"事实表基础\"></a>事实表基础</h2><h3 id=\"事实表特性\"><a href=\"#事实表特性\" class=\"headerlink\" title=\"事实表特性\"></a>事实表特性</h3><p>事实表作为数据仓库维度建模的核心，紧紧围绕着业务过程来设计，通过获取描述业务过程的度量来表达业务过程，包含了引用的维度和业务过程有关的度量。</p>\n<h4 id=\"粒度\"><a href=\"#粒度\" class=\"headerlink\" title=\"粒度\"></a>粒度</h4><p>事实表中一条记录所表达的业务细节程度被称为粒度。通常粒度可以通过两种方式来表达；一种是维度属性组合所表示的细节程度；一种是所表示的具体业务含义。<br>作为度量业务过程的事实，一般为整形或浮点型的十进制数值，有可加性、半可加性和不可加性三种类型。可加性事实是指可以按照与事实表关联的做任意维度进行汇总。半可加性事实只能按照特定维度汇总，不能对所有维度汇总，比如库存可以按照地点和商品进行汇总，而按时间维度把一年中每个月的库存累加起来则毫无意义。还有一种度量完成不具备可加性，比如比率型事实。对于不可加性事实可分解为可加的组件来实现聚焦。</p>\n<h4 id=\"退化维度\"><a href=\"#退化维度\" class=\"headerlink\" title=\"退化维度\"></a>退化维度</h4><p>维表属性也可以存储到事实表中，这种存储到事实表中的维度列被称为“退化维度”。与其他存储在维表中的维度一样，退化维度也可以用来进行事实表的过滤查询、实现聚合操作等。</p>\n<h4 id=\"三种类型\"><a href=\"#三种类型\" class=\"headerlink\" title=\"三种类型\"></a>三种类型</h4><p>事实表有三种类型：事务事实表、周期快照事实表和累积快照事实表，<br>事务事实表用来描述业务过程，跟踪空间或时间上某点的度量事件，保存的是最原子的数据，也称为“原子事实表”。周期快照事实表以具有规律性的、可预见的时间间隔记录事实，时间间隔如每天、每月、每年等。累积快照事实表用来表述过程开始和结束之间的关键步骤事件，覆盖过程的整个生命周期，通常具有多个日期字段来记录关键时间占，当过程随着生命周期不断变化时，记录也会随着过程的变化而被修改。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p>阿里巴巴《大数据之路》</p>\n"},{"title":"数据建模方法论","date":"2019-02-05T01:55:00.000Z","_content":"传统的数据仓库一般是搭建在关系型数据库上，数据建模大多基于ER模型；现代互联网公司一般是搭建在大数据环境(cdh、hadoop)上，数据建模大多基于维度模型建设的。这些建模有什么不同？数据仓库又为需要需要数据建模呢？下面就从近期的学习学到的内容予以讲述。\n\n## 为什么需要数据建模\n随着大数据时代互联网的到来，数据增长速度以爆发式发展，如何将这些数据进行有序、有结果地分类组织和存储是我们面临的一个挑战。\n如果把数据看作图书馆里的书，我们希望看到它们在快回上分门别类地放置；如果把数据看作城市的建筑，我们希望城市规划布局合理；如果把数据看作电脑文件和文件夹，我们希望按照自己的习惯有很好的文件夹组织方式，而不是糟糕混乱的桌面，经常为找一个文件而不知所措。\n数据模型就是数据组织和存储方法，它强调从业务、数据存取和使用角度合理存储数据。\n\n### 建模的好处\n大数据就能获得以下好处。\n* 性能：良好的数据模型能帮助我们快速查询所需要的数据，减少数据的I/O吞吐。\n* 成本：良好的数据模型能极大减少不必要的数据冗余，也能实现计算结果复用，极大地降低大数据系统中的存储和计算成本 。\n* 效率：良好的数据模型能极大地改善用户使用数据的体验，提高使用数据的效率。\n* 质量：良好的数据模型能改善数据统计口径的不一致性，减少数据计算错误的可能性。\n因此，毋庸置疑，大数据系统需要数据模型方法来帮助更好地组织和存储数据，以便在性能、成本、效率和质量之间取得最佳平衡。\n\n\n## 数据仓库建模方法论\n### ER模型\n是从企业的高级设计一个3NF模型，用实体关系（Entity Relationship，ER）模型描述企业业务，在范式上符合3NF。\n数据仓库中的3NF与OLTP系统中的3NF的区别在于，它是站在企业角度面向主题的抽象，而不是针对某个具体业务流程的实体对象关系的抽象。其具有以下几个特点：\n1.需要全面了解企业业务和数据。\n2.实施周期非常长。\n3.对建模人员的能力要求非常高。\n采用ER模型建设数据仓库模型的出发点是整合数据，将各个系统中的数据以整个企业角度按主题进行相似性组合和合并，并进行一致性处理，为数据分析决策服务，但是并不能直接用于分析决策。\n其建模步骤分为三个阶段：\n* 高层模型：一个高度抽象的模型，描述主要的主题以及主题间的关系，用于描述企业的业务总和概况。\n* 中层模型：在高层模型的基础上，细化主题的数据项。\n* 物理模型（也叫底层模型）：在中层模型的基础上，考虑物理存储，同时基于性能和平台特点进行物理属性的设计，也可能做一些表的合并、分区的设计等。\n\n\n### 维度模型\n维度模型是当前最流行的建模方法类。维度建模从分析决策的需要出发构建模型，为分析需要服务，因此它重点关注用户如何更快速地完成需求分析，同时具有较好的大规模复杂查询的响应性能。其典型的代表是星形模型，以及在一些特殊场景下使用的雪花模型。其设计分为以下几个步骤。\n1.选择需要进行分析决策的业务过程。业务过程可以是单个业务事件，比如交易的支付、退款等；也可以是某个事件的状态，比如当前的账户余额等；还可以是一系列相关业务事件组成的业务流程，具体需要看我们分析的是某些事件发生的情况，还是当前状态或是事件流转效率。\n2.选择粒度。在事件分析中，我们要预判所有分析需要细分的程度，从而决定选择的粒度。粒度是维度的一个组合。\n3.识别维表。选择好粒度之后，就需要基于此粒度设计维表，包括维度属性，用于分析时进行分组和筛选。\n4.选择事实。确定分析需要衡量的指标。\n\n### Data Vault模型\nDV模型是ER模型的衍生，其设计的出发点也是为了实现数据的整合，但不能直接用于数据分析决策。它强调建立一个可审计的基础数据层，也就是强调数据的历史性、可追溯性和原子性，而不要求对数据进行过度的一致性处理和整合；同时它基于主题概念将企业数据进行结构化组织，并引入了更进一步的范式处理来优化模型，以应对源系统变更的扩展性。Data Vault模型由以下几部分组成。\n1.Hub：是企业的核心业务实体，由实体key、数据仓库序列代理键、装载时间、数据来源组成。\n2.Link：代表Hub之间的关系。这里与ER模型最大的区别是将关系作为一个独立的单元抽象，可以提升模型的扩展性。它可以直接描述1:1、1:n和n:N的关系，而不需要做任何变更。它由Hub的代理键、装载时间、数据来源组成。\n3.Satellite:是Hub的详细描述内容，一个Hub可以有多个Satellite。它由Hub的代理键、装载时间、来源类型、详细的Hub描述信息组成。\nData Vault模型比ER模型更容易设计和产出。它的ETL加工可实现配置化。通过Dan Linstedt的比喻更能理解Data Vault的核心思想：Hub可以想象成人的骨架，那么Link就是连接骨架的韧带，而Satellite就是骨架上面的血肉。\n\n### Anchor模型\nAnchor模型是Data Vault模型的进一步规范化，核心思想是所有的扩展只是添加而不会修改，因此将模型规范到6NF，基本变成了k-v结构化模型。\n我们看一下Anchor模型的组成。\n1.Anchors：类型于Data Vault的Hub，代表业务实体，且只有主键。\n2.Attributes：功能类型于Data Vault的Satellite，但是它更加规范化，将其全部k-v结构化，一个表只有一个Anchors的属性描述。\n3.Ties：就是Anchors之间的关系，单独用表来描述，类似于Data Vault的Link，可以提升整体模型关系的扩展能力。\n4.Knots：代表那些可能会在多个Anchors中公用的属性的提炼，比如性别、状态等这种枚举类型且被公用的属性。\n\n## 参考\n阿里巴巴《大数据之路》","source":"_posts/数据中台/数据建模方法论.md","raw":"---\ntitle: 数据建模方法论\ndate: 2019-02-05 09:55:00\ntags: [模型设计]\ncategories: [数据中台,模型设计]\n---\n传统的数据仓库一般是搭建在关系型数据库上，数据建模大多基于ER模型；现代互联网公司一般是搭建在大数据环境(cdh、hadoop)上，数据建模大多基于维度模型建设的。这些建模有什么不同？数据仓库又为需要需要数据建模呢？下面就从近期的学习学到的内容予以讲述。\n\n## 为什么需要数据建模\n随着大数据时代互联网的到来，数据增长速度以爆发式发展，如何将这些数据进行有序、有结果地分类组织和存储是我们面临的一个挑战。\n如果把数据看作图书馆里的书，我们希望看到它们在快回上分门别类地放置；如果把数据看作城市的建筑，我们希望城市规划布局合理；如果把数据看作电脑文件和文件夹，我们希望按照自己的习惯有很好的文件夹组织方式，而不是糟糕混乱的桌面，经常为找一个文件而不知所措。\n数据模型就是数据组织和存储方法，它强调从业务、数据存取和使用角度合理存储数据。\n\n### 建模的好处\n大数据就能获得以下好处。\n* 性能：良好的数据模型能帮助我们快速查询所需要的数据，减少数据的I/O吞吐。\n* 成本：良好的数据模型能极大减少不必要的数据冗余，也能实现计算结果复用，极大地降低大数据系统中的存储和计算成本 。\n* 效率：良好的数据模型能极大地改善用户使用数据的体验，提高使用数据的效率。\n* 质量：良好的数据模型能改善数据统计口径的不一致性，减少数据计算错误的可能性。\n因此，毋庸置疑，大数据系统需要数据模型方法来帮助更好地组织和存储数据，以便在性能、成本、效率和质量之间取得最佳平衡。\n\n\n## 数据仓库建模方法论\n### ER模型\n是从企业的高级设计一个3NF模型，用实体关系（Entity Relationship，ER）模型描述企业业务，在范式上符合3NF。\n数据仓库中的3NF与OLTP系统中的3NF的区别在于，它是站在企业角度面向主题的抽象，而不是针对某个具体业务流程的实体对象关系的抽象。其具有以下几个特点：\n1.需要全面了解企业业务和数据。\n2.实施周期非常长。\n3.对建模人员的能力要求非常高。\n采用ER模型建设数据仓库模型的出发点是整合数据，将各个系统中的数据以整个企业角度按主题进行相似性组合和合并，并进行一致性处理，为数据分析决策服务，但是并不能直接用于分析决策。\n其建模步骤分为三个阶段：\n* 高层模型：一个高度抽象的模型，描述主要的主题以及主题间的关系，用于描述企业的业务总和概况。\n* 中层模型：在高层模型的基础上，细化主题的数据项。\n* 物理模型（也叫底层模型）：在中层模型的基础上，考虑物理存储，同时基于性能和平台特点进行物理属性的设计，也可能做一些表的合并、分区的设计等。\n\n\n### 维度模型\n维度模型是当前最流行的建模方法类。维度建模从分析决策的需要出发构建模型，为分析需要服务，因此它重点关注用户如何更快速地完成需求分析，同时具有较好的大规模复杂查询的响应性能。其典型的代表是星形模型，以及在一些特殊场景下使用的雪花模型。其设计分为以下几个步骤。\n1.选择需要进行分析决策的业务过程。业务过程可以是单个业务事件，比如交易的支付、退款等；也可以是某个事件的状态，比如当前的账户余额等；还可以是一系列相关业务事件组成的业务流程，具体需要看我们分析的是某些事件发生的情况，还是当前状态或是事件流转效率。\n2.选择粒度。在事件分析中，我们要预判所有分析需要细分的程度，从而决定选择的粒度。粒度是维度的一个组合。\n3.识别维表。选择好粒度之后，就需要基于此粒度设计维表，包括维度属性，用于分析时进行分组和筛选。\n4.选择事实。确定分析需要衡量的指标。\n\n### Data Vault模型\nDV模型是ER模型的衍生，其设计的出发点也是为了实现数据的整合，但不能直接用于数据分析决策。它强调建立一个可审计的基础数据层，也就是强调数据的历史性、可追溯性和原子性，而不要求对数据进行过度的一致性处理和整合；同时它基于主题概念将企业数据进行结构化组织，并引入了更进一步的范式处理来优化模型，以应对源系统变更的扩展性。Data Vault模型由以下几部分组成。\n1.Hub：是企业的核心业务实体，由实体key、数据仓库序列代理键、装载时间、数据来源组成。\n2.Link：代表Hub之间的关系。这里与ER模型最大的区别是将关系作为一个独立的单元抽象，可以提升模型的扩展性。它可以直接描述1:1、1:n和n:N的关系，而不需要做任何变更。它由Hub的代理键、装载时间、数据来源组成。\n3.Satellite:是Hub的详细描述内容，一个Hub可以有多个Satellite。它由Hub的代理键、装载时间、来源类型、详细的Hub描述信息组成。\nData Vault模型比ER模型更容易设计和产出。它的ETL加工可实现配置化。通过Dan Linstedt的比喻更能理解Data Vault的核心思想：Hub可以想象成人的骨架，那么Link就是连接骨架的韧带，而Satellite就是骨架上面的血肉。\n\n### Anchor模型\nAnchor模型是Data Vault模型的进一步规范化，核心思想是所有的扩展只是添加而不会修改，因此将模型规范到6NF，基本变成了k-v结构化模型。\n我们看一下Anchor模型的组成。\n1.Anchors：类型于Data Vault的Hub，代表业务实体，且只有主键。\n2.Attributes：功能类型于Data Vault的Satellite，但是它更加规范化，将其全部k-v结构化，一个表只有一个Anchors的属性描述。\n3.Ties：就是Anchors之间的关系，单独用表来描述，类似于Data Vault的Link，可以提升整体模型关系的扩展能力。\n4.Knots：代表那些可能会在多个Anchors中公用的属性的提炼，比如性别、状态等这种枚举类型且被公用的属性。\n\n## 参考\n阿里巴巴《大数据之路》","slug":"数据中台/数据建模方法论","published":1,"updated":"2019-03-13T10:01:13.482Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bkf002ts77r4ip1i3k4","content":"<p>传统的数据仓库一般是搭建在关系型数据库上，数据建模大多基于ER模型；现代互联网公司一般是搭建在大数据环境(cdh、hadoop)上，数据建模大多基于维度模型建设的。这些建模有什么不同？数据仓库又为需要需要数据建模呢？下面就从近期的学习学到的内容予以讲述。</p>\n<h2 id=\"为什么需要数据建模\"><a href=\"#为什么需要数据建模\" class=\"headerlink\" title=\"为什么需要数据建模\"></a>为什么需要数据建模</h2><p>随着大数据时代互联网的到来，数据增长速度以爆发式发展，如何将这些数据进行有序、有结果地分类组织和存储是我们面临的一个挑战。<br>如果把数据看作图书馆里的书，我们希望看到它们在快回上分门别类地放置；如果把数据看作城市的建筑，我们希望城市规划布局合理；如果把数据看作电脑文件和文件夹，我们希望按照自己的习惯有很好的文件夹组织方式，而不是糟糕混乱的桌面，经常为找一个文件而不知所措。<br>数据模型就是数据组织和存储方法，它强调从业务、数据存取和使用角度合理存储数据。</p>\n<h3 id=\"建模的好处\"><a href=\"#建模的好处\" class=\"headerlink\" title=\"建模的好处\"></a>建模的好处</h3><p>大数据就能获得以下好处。</p>\n<ul>\n<li>性能：良好的数据模型能帮助我们快速查询所需要的数据，减少数据的I/O吞吐。</li>\n<li>成本：良好的数据模型能极大减少不必要的数据冗余，也能实现计算结果复用，极大地降低大数据系统中的存储和计算成本 。</li>\n<li>效率：良好的数据模型能极大地改善用户使用数据的体验，提高使用数据的效率。</li>\n<li>质量：良好的数据模型能改善数据统计口径的不一致性，减少数据计算错误的可能性。<br>因此，毋庸置疑，大数据系统需要数据模型方法来帮助更好地组织和存储数据，以便在性能、成本、效率和质量之间取得最佳平衡。</li>\n</ul>\n<h2 id=\"数据仓库建模方法论\"><a href=\"#数据仓库建模方法论\" class=\"headerlink\" title=\"数据仓库建模方法论\"></a>数据仓库建模方法论</h2><h3 id=\"ER模型\"><a href=\"#ER模型\" class=\"headerlink\" title=\"ER模型\"></a>ER模型</h3><p>是从企业的高级设计一个3NF模型，用实体关系（Entity Relationship，ER）模型描述企业业务，在范式上符合3NF。<br>数据仓库中的3NF与OLTP系统中的3NF的区别在于，它是站在企业角度面向主题的抽象，而不是针对某个具体业务流程的实体对象关系的抽象。其具有以下几个特点：<br>1.需要全面了解企业业务和数据。<br>2.实施周期非常长。<br>3.对建模人员的能力要求非常高。<br>采用ER模型建设数据仓库模型的出发点是整合数据，将各个系统中的数据以整个企业角度按主题进行相似性组合和合并，并进行一致性处理，为数据分析决策服务，但是并不能直接用于分析决策。<br>其建模步骤分为三个阶段：</p>\n<ul>\n<li>高层模型：一个高度抽象的模型，描述主要的主题以及主题间的关系，用于描述企业的业务总和概况。</li>\n<li>中层模型：在高层模型的基础上，细化主题的数据项。</li>\n<li>物理模型（也叫底层模型）：在中层模型的基础上，考虑物理存储，同时基于性能和平台特点进行物理属性的设计，也可能做一些表的合并、分区的设计等。</li>\n</ul>\n<h3 id=\"维度模型\"><a href=\"#维度模型\" class=\"headerlink\" title=\"维度模型\"></a>维度模型</h3><p>维度模型是当前最流行的建模方法类。维度建模从分析决策的需要出发构建模型，为分析需要服务，因此它重点关注用户如何更快速地完成需求分析，同时具有较好的大规模复杂查询的响应性能。其典型的代表是星形模型，以及在一些特殊场景下使用的雪花模型。其设计分为以下几个步骤。<br>1.选择需要进行分析决策的业务过程。业务过程可以是单个业务事件，比如交易的支付、退款等；也可以是某个事件的状态，比如当前的账户余额等；还可以是一系列相关业务事件组成的业务流程，具体需要看我们分析的是某些事件发生的情况，还是当前状态或是事件流转效率。<br>2.选择粒度。在事件分析中，我们要预判所有分析需要细分的程度，从而决定选择的粒度。粒度是维度的一个组合。<br>3.识别维表。选择好粒度之后，就需要基于此粒度设计维表，包括维度属性，用于分析时进行分组和筛选。<br>4.选择事实。确定分析需要衡量的指标。</p>\n<h3 id=\"Data-Vault模型\"><a href=\"#Data-Vault模型\" class=\"headerlink\" title=\"Data Vault模型\"></a>Data Vault模型</h3><p>DV模型是ER模型的衍生，其设计的出发点也是为了实现数据的整合，但不能直接用于数据分析决策。它强调建立一个可审计的基础数据层，也就是强调数据的历史性、可追溯性和原子性，而不要求对数据进行过度的一致性处理和整合；同时它基于主题概念将企业数据进行结构化组织，并引入了更进一步的范式处理来优化模型，以应对源系统变更的扩展性。Data Vault模型由以下几部分组成。<br>1.Hub：是企业的核心业务实体，由实体key、数据仓库序列代理键、装载时间、数据来源组成。<br>2.Link：代表Hub之间的关系。这里与ER模型最大的区别是将关系作为一个独立的单元抽象，可以提升模型的扩展性。它可以直接描述1:1、1:n和n:N的关系，而不需要做任何变更。它由Hub的代理键、装载时间、数据来源组成。<br>3.Satellite:是Hub的详细描述内容，一个Hub可以有多个Satellite。它由Hub的代理键、装载时间、来源类型、详细的Hub描述信息组成。<br>Data Vault模型比ER模型更容易设计和产出。它的ETL加工可实现配置化。通过Dan Linstedt的比喻更能理解Data Vault的核心思想：Hub可以想象成人的骨架，那么Link就是连接骨架的韧带，而Satellite就是骨架上面的血肉。</p>\n<h3 id=\"Anchor模型\"><a href=\"#Anchor模型\" class=\"headerlink\" title=\"Anchor模型\"></a>Anchor模型</h3><p>Anchor模型是Data Vault模型的进一步规范化，核心思想是所有的扩展只是添加而不会修改，因此将模型规范到6NF，基本变成了k-v结构化模型。<br>我们看一下Anchor模型的组成。<br>1.Anchors：类型于Data Vault的Hub，代表业务实体，且只有主键。<br>2.Attributes：功能类型于Data Vault的Satellite，但是它更加规范化，将其全部k-v结构化，一个表只有一个Anchors的属性描述。<br>3.Ties：就是Anchors之间的关系，单独用表来描述，类似于Data Vault的Link，可以提升整体模型关系的扩展能力。<br>4.Knots：代表那些可能会在多个Anchors中公用的属性的提炼，比如性别、状态等这种枚举类型且被公用的属性。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>阿里巴巴《大数据之路》</p>\n","site":{"data":{}},"excerpt":"","more":"<p>传统的数据仓库一般是搭建在关系型数据库上，数据建模大多基于ER模型；现代互联网公司一般是搭建在大数据环境(cdh、hadoop)上，数据建模大多基于维度模型建设的。这些建模有什么不同？数据仓库又为需要需要数据建模呢？下面就从近期的学习学到的内容予以讲述。</p>\n<h2 id=\"为什么需要数据建模\"><a href=\"#为什么需要数据建模\" class=\"headerlink\" title=\"为什么需要数据建模\"></a>为什么需要数据建模</h2><p>随着大数据时代互联网的到来，数据增长速度以爆发式发展，如何将这些数据进行有序、有结果地分类组织和存储是我们面临的一个挑战。<br>如果把数据看作图书馆里的书，我们希望看到它们在快回上分门别类地放置；如果把数据看作城市的建筑，我们希望城市规划布局合理；如果把数据看作电脑文件和文件夹，我们希望按照自己的习惯有很好的文件夹组织方式，而不是糟糕混乱的桌面，经常为找一个文件而不知所措。<br>数据模型就是数据组织和存储方法，它强调从业务、数据存取和使用角度合理存储数据。</p>\n<h3 id=\"建模的好处\"><a href=\"#建模的好处\" class=\"headerlink\" title=\"建模的好处\"></a>建模的好处</h3><p>大数据就能获得以下好处。</p>\n<ul>\n<li>性能：良好的数据模型能帮助我们快速查询所需要的数据，减少数据的I/O吞吐。</li>\n<li>成本：良好的数据模型能极大减少不必要的数据冗余，也能实现计算结果复用，极大地降低大数据系统中的存储和计算成本 。</li>\n<li>效率：良好的数据模型能极大地改善用户使用数据的体验，提高使用数据的效率。</li>\n<li>质量：良好的数据模型能改善数据统计口径的不一致性，减少数据计算错误的可能性。<br>因此，毋庸置疑，大数据系统需要数据模型方法来帮助更好地组织和存储数据，以便在性能、成本、效率和质量之间取得最佳平衡。</li>\n</ul>\n<h2 id=\"数据仓库建模方法论\"><a href=\"#数据仓库建模方法论\" class=\"headerlink\" title=\"数据仓库建模方法论\"></a>数据仓库建模方法论</h2><h3 id=\"ER模型\"><a href=\"#ER模型\" class=\"headerlink\" title=\"ER模型\"></a>ER模型</h3><p>是从企业的高级设计一个3NF模型，用实体关系（Entity Relationship，ER）模型描述企业业务，在范式上符合3NF。<br>数据仓库中的3NF与OLTP系统中的3NF的区别在于，它是站在企业角度面向主题的抽象，而不是针对某个具体业务流程的实体对象关系的抽象。其具有以下几个特点：<br>1.需要全面了解企业业务和数据。<br>2.实施周期非常长。<br>3.对建模人员的能力要求非常高。<br>采用ER模型建设数据仓库模型的出发点是整合数据，将各个系统中的数据以整个企业角度按主题进行相似性组合和合并，并进行一致性处理，为数据分析决策服务，但是并不能直接用于分析决策。<br>其建模步骤分为三个阶段：</p>\n<ul>\n<li>高层模型：一个高度抽象的模型，描述主要的主题以及主题间的关系，用于描述企业的业务总和概况。</li>\n<li>中层模型：在高层模型的基础上，细化主题的数据项。</li>\n<li>物理模型（也叫底层模型）：在中层模型的基础上，考虑物理存储，同时基于性能和平台特点进行物理属性的设计，也可能做一些表的合并、分区的设计等。</li>\n</ul>\n<h3 id=\"维度模型\"><a href=\"#维度模型\" class=\"headerlink\" title=\"维度模型\"></a>维度模型</h3><p>维度模型是当前最流行的建模方法类。维度建模从分析决策的需要出发构建模型，为分析需要服务，因此它重点关注用户如何更快速地完成需求分析，同时具有较好的大规模复杂查询的响应性能。其典型的代表是星形模型，以及在一些特殊场景下使用的雪花模型。其设计分为以下几个步骤。<br>1.选择需要进行分析决策的业务过程。业务过程可以是单个业务事件，比如交易的支付、退款等；也可以是某个事件的状态，比如当前的账户余额等；还可以是一系列相关业务事件组成的业务流程，具体需要看我们分析的是某些事件发生的情况，还是当前状态或是事件流转效率。<br>2.选择粒度。在事件分析中，我们要预判所有分析需要细分的程度，从而决定选择的粒度。粒度是维度的一个组合。<br>3.识别维表。选择好粒度之后，就需要基于此粒度设计维表，包括维度属性，用于分析时进行分组和筛选。<br>4.选择事实。确定分析需要衡量的指标。</p>\n<h3 id=\"Data-Vault模型\"><a href=\"#Data-Vault模型\" class=\"headerlink\" title=\"Data Vault模型\"></a>Data Vault模型</h3><p>DV模型是ER模型的衍生，其设计的出发点也是为了实现数据的整合，但不能直接用于数据分析决策。它强调建立一个可审计的基础数据层，也就是强调数据的历史性、可追溯性和原子性，而不要求对数据进行过度的一致性处理和整合；同时它基于主题概念将企业数据进行结构化组织，并引入了更进一步的范式处理来优化模型，以应对源系统变更的扩展性。Data Vault模型由以下几部分组成。<br>1.Hub：是企业的核心业务实体，由实体key、数据仓库序列代理键、装载时间、数据来源组成。<br>2.Link：代表Hub之间的关系。这里与ER模型最大的区别是将关系作为一个独立的单元抽象，可以提升模型的扩展性。它可以直接描述1:1、1:n和n:N的关系，而不需要做任何变更。它由Hub的代理键、装载时间、数据来源组成。<br>3.Satellite:是Hub的详细描述内容，一个Hub可以有多个Satellite。它由Hub的代理键、装载时间、来源类型、详细的Hub描述信息组成。<br>Data Vault模型比ER模型更容易设计和产出。它的ETL加工可实现配置化。通过Dan Linstedt的比喻更能理解Data Vault的核心思想：Hub可以想象成人的骨架，那么Link就是连接骨架的韧带，而Satellite就是骨架上面的血肉。</p>\n<h3 id=\"Anchor模型\"><a href=\"#Anchor模型\" class=\"headerlink\" title=\"Anchor模型\"></a>Anchor模型</h3><p>Anchor模型是Data Vault模型的进一步规范化，核心思想是所有的扩展只是添加而不会修改，因此将模型规范到6NF，基本变成了k-v结构化模型。<br>我们看一下Anchor模型的组成。<br>1.Anchors：类型于Data Vault的Hub，代表业务实体，且只有主键。<br>2.Attributes：功能类型于Data Vault的Satellite，但是它更加规范化，将其全部k-v结构化，一个表只有一个Anchors的属性描述。<br>3.Ties：就是Anchors之间的关系，单独用表来描述，类似于Data Vault的Link，可以提升整体模型关系的扩展能力。<br>4.Knots：代表那些可能会在多个Anchors中公用的属性的提炼，比如性别、状态等这种枚举类型且被公用的属性。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>阿里巴巴《大数据之路》</p>\n"},{"title":"数据建模-元数据","date":"2019-02-05T01:55:00.000Z","_content":"### 元数据定义\n按照传统的定义，元数据（Metadata）是关于数据的数据。元数据**打通了源数据、数据仓库、数据应用**。记录了数据从产生到消费的全过程。元数据主要记录数据仓库中模型的定义、各层次间的映射关系、监控数据仓库的数据状态及ETL的任务运行状态。在数据仓库系统中，元数据可以帮助数据仓库管理员和开发人员非常方便地找到他们所关心的数据，用于指导其进行数据管理和开发工作，提高工作效率。\n\n将元数据按用途的不同分为两类：技术元数据（Technical Metadata）和业务元数据（Business Metadata）。\n技术元数据是存储关于数据仓库系统技术细节的数据，是用于开发和管理数据仓库使用的数据。阿里巴巴常用的技术元数据有：\nA. 分布式计算系统存储元数据，如MaxCompute表、列、分区等信息。记录了表的表名。分区信息、责任人信息、文件大小、表类型，生命周期，以及列的字段名、字段类型、字段备注、是否是分区字段等信息。\nB. 分布式计算系统运行元数据，如MaxCompute上所有作业运行等信息；类似于Hive的Job日志，包括作业类型、实例名称、输入输出、SQL、运行参数、执行时间、最细粒度的Fuxi Instance（MaxCompute中MR执行的最小单元）执行信息等。\nC. 数据开发平台中的数据同步、计算任务、任务调度等信息，包括数据同步的输出输出表和字段，以及同步任务本身的节点信息；计算任务主要有输入输出、任务本身的节点信息；任务调度主要有任务的依赖类型、依赖关系等，以及不同类型调度任务的运行日志等。\nD. 数据质量和运维相关元数据，如任务监控、运维报警、数据质量、故障等信息，包括任务监控运行日志、告警配置及运行日志、故障信息等。\n \n业务元数据从业务角度描述了数据仓库中的数据，它提供了介于使用者和实际系统之间的语义层，使得不懂计算机技术的业务人员也能够“读懂”数据仓库串的数据。阿里巴巴常用的业务元数据有：\n1.OneData元数据，如维度及属性，业务过程、指标等的规范化定义，用于更好地管理和使用数据。\n2.数据应用元数据，如数据报表、数据产品等的配置和运行元数据。\n\n### 元数据的价值\n元数据有重要的应用价值，是数据管理、数据内容、数据应用的基础，在数据管理方面为集团数据提供在计算、存储、成本、质量、安全、模型等治理领域上的数据支持。例如在计算上可以利用元数据查找超长运行节点，对这些节点进行专项治理，保障基线产出时间。在数据内容方面为集团数据进行数据域、数据主题、业务属性等的提取和分析提供数据素材。例如可以利用元数据构建知识图谱，给数据打标签，清楚地知道现在哪些数据。在数据应用方面打通产品及应用链路，保护产品数据准确、及时产出。例如打通MaxCompute和应用数据，明确数据资产等级，更有效地保障产品数据。\n     \n### 参考\n阿里巴巴《大数据之路》","source":"_posts/数据中台/数据建模-元数据.md","raw":"---\ntitle: 数据建模-元数据\ndate: 2019-02-05 09:55:00\ntags: [模型设计]\ncategories: [数据中台,模型设计]\n---\n### 元数据定义\n按照传统的定义，元数据（Metadata）是关于数据的数据。元数据**打通了源数据、数据仓库、数据应用**。记录了数据从产生到消费的全过程。元数据主要记录数据仓库中模型的定义、各层次间的映射关系、监控数据仓库的数据状态及ETL的任务运行状态。在数据仓库系统中，元数据可以帮助数据仓库管理员和开发人员非常方便地找到他们所关心的数据，用于指导其进行数据管理和开发工作，提高工作效率。\n\n将元数据按用途的不同分为两类：技术元数据（Technical Metadata）和业务元数据（Business Metadata）。\n技术元数据是存储关于数据仓库系统技术细节的数据，是用于开发和管理数据仓库使用的数据。阿里巴巴常用的技术元数据有：\nA. 分布式计算系统存储元数据，如MaxCompute表、列、分区等信息。记录了表的表名。分区信息、责任人信息、文件大小、表类型，生命周期，以及列的字段名、字段类型、字段备注、是否是分区字段等信息。\nB. 分布式计算系统运行元数据，如MaxCompute上所有作业运行等信息；类似于Hive的Job日志，包括作业类型、实例名称、输入输出、SQL、运行参数、执行时间、最细粒度的Fuxi Instance（MaxCompute中MR执行的最小单元）执行信息等。\nC. 数据开发平台中的数据同步、计算任务、任务调度等信息，包括数据同步的输出输出表和字段，以及同步任务本身的节点信息；计算任务主要有输入输出、任务本身的节点信息；任务调度主要有任务的依赖类型、依赖关系等，以及不同类型调度任务的运行日志等。\nD. 数据质量和运维相关元数据，如任务监控、运维报警、数据质量、故障等信息，包括任务监控运行日志、告警配置及运行日志、故障信息等。\n \n业务元数据从业务角度描述了数据仓库中的数据，它提供了介于使用者和实际系统之间的语义层，使得不懂计算机技术的业务人员也能够“读懂”数据仓库串的数据。阿里巴巴常用的业务元数据有：\n1.OneData元数据，如维度及属性，业务过程、指标等的规范化定义，用于更好地管理和使用数据。\n2.数据应用元数据，如数据报表、数据产品等的配置和运行元数据。\n\n### 元数据的价值\n元数据有重要的应用价值，是数据管理、数据内容、数据应用的基础，在数据管理方面为集团数据提供在计算、存储、成本、质量、安全、模型等治理领域上的数据支持。例如在计算上可以利用元数据查找超长运行节点，对这些节点进行专项治理，保障基线产出时间。在数据内容方面为集团数据进行数据域、数据主题、业务属性等的提取和分析提供数据素材。例如可以利用元数据构建知识图谱，给数据打标签，清楚地知道现在哪些数据。在数据应用方面打通产品及应用链路，保护产品数据准确、及时产出。例如打通MaxCompute和应用数据，明确数据资产等级，更有效地保障产品数据。\n     \n### 参考\n阿里巴巴《大数据之路》","slug":"数据中台/数据建模-元数据","published":1,"updated":"2019-03-19T09:06:50.949Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bkh002ws77ry6n8aybp","content":"<h3 id=\"元数据定义\"><a href=\"#元数据定义\" class=\"headerlink\" title=\"元数据定义\"></a>元数据定义</h3><p>按照传统的定义，元数据（Metadata）是关于数据的数据。元数据<strong>打通了源数据、数据仓库、数据应用</strong>。记录了数据从产生到消费的全过程。元数据主要记录数据仓库中模型的定义、各层次间的映射关系、监控数据仓库的数据状态及ETL的任务运行状态。在数据仓库系统中，元数据可以帮助数据仓库管理员和开发人员非常方便地找到他们所关心的数据，用于指导其进行数据管理和开发工作，提高工作效率。</p>\n<p>将元数据按用途的不同分为两类：技术元数据（Technical Metadata）和业务元数据（Business Metadata）。<br>技术元数据是存储关于数据仓库系统技术细节的数据，是用于开发和管理数据仓库使用的数据。阿里巴巴常用的技术元数据有：<br>A. 分布式计算系统存储元数据，如MaxCompute表、列、分区等信息。记录了表的表名。分区信息、责任人信息、文件大小、表类型，生命周期，以及列的字段名、字段类型、字段备注、是否是分区字段等信息。<br>B. 分布式计算系统运行元数据，如MaxCompute上所有作业运行等信息；类似于Hive的Job日志，包括作业类型、实例名称、输入输出、SQL、运行参数、执行时间、最细粒度的Fuxi Instance（MaxCompute中MR执行的最小单元）执行信息等。<br>C. 数据开发平台中的数据同步、计算任务、任务调度等信息，包括数据同步的输出输出表和字段，以及同步任务本身的节点信息；计算任务主要有输入输出、任务本身的节点信息；任务调度主要有任务的依赖类型、依赖关系等，以及不同类型调度任务的运行日志等。<br>D. 数据质量和运维相关元数据，如任务监控、运维报警、数据质量、故障等信息，包括任务监控运行日志、告警配置及运行日志、故障信息等。</p>\n<p>业务元数据从业务角度描述了数据仓库中的数据，它提供了介于使用者和实际系统之间的语义层，使得不懂计算机技术的业务人员也能够“读懂”数据仓库串的数据。阿里巴巴常用的业务元数据有：<br>1.OneData元数据，如维度及属性，业务过程、指标等的规范化定义，用于更好地管理和使用数据。<br>2.数据应用元数据，如数据报表、数据产品等的配置和运行元数据。</p>\n<h3 id=\"元数据的价值\"><a href=\"#元数据的价值\" class=\"headerlink\" title=\"元数据的价值\"></a>元数据的价值</h3><p>元数据有重要的应用价值，是数据管理、数据内容、数据应用的基础，在数据管理方面为集团数据提供在计算、存储、成本、质量、安全、模型等治理领域上的数据支持。例如在计算上可以利用元数据查找超长运行节点，对这些节点进行专项治理，保障基线产出时间。在数据内容方面为集团数据进行数据域、数据主题、业务属性等的提取和分析提供数据素材。例如可以利用元数据构建知识图谱，给数据打标签，清楚地知道现在哪些数据。在数据应用方面打通产品及应用链路，保护产品数据准确、及时产出。例如打通MaxCompute和应用数据，明确数据资产等级，更有效地保障产品数据。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p>阿里巴巴《大数据之路》</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"元数据定义\"><a href=\"#元数据定义\" class=\"headerlink\" title=\"元数据定义\"></a>元数据定义</h3><p>按照传统的定义，元数据（Metadata）是关于数据的数据。元数据<strong>打通了源数据、数据仓库、数据应用</strong>。记录了数据从产生到消费的全过程。元数据主要记录数据仓库中模型的定义、各层次间的映射关系、监控数据仓库的数据状态及ETL的任务运行状态。在数据仓库系统中，元数据可以帮助数据仓库管理员和开发人员非常方便地找到他们所关心的数据，用于指导其进行数据管理和开发工作，提高工作效率。</p>\n<p>将元数据按用途的不同分为两类：技术元数据（Technical Metadata）和业务元数据（Business Metadata）。<br>技术元数据是存储关于数据仓库系统技术细节的数据，是用于开发和管理数据仓库使用的数据。阿里巴巴常用的技术元数据有：<br>A. 分布式计算系统存储元数据，如MaxCompute表、列、分区等信息。记录了表的表名。分区信息、责任人信息、文件大小、表类型，生命周期，以及列的字段名、字段类型、字段备注、是否是分区字段等信息。<br>B. 分布式计算系统运行元数据，如MaxCompute上所有作业运行等信息；类似于Hive的Job日志，包括作业类型、实例名称、输入输出、SQL、运行参数、执行时间、最细粒度的Fuxi Instance（MaxCompute中MR执行的最小单元）执行信息等。<br>C. 数据开发平台中的数据同步、计算任务、任务调度等信息，包括数据同步的输出输出表和字段，以及同步任务本身的节点信息；计算任务主要有输入输出、任务本身的节点信息；任务调度主要有任务的依赖类型、依赖关系等，以及不同类型调度任务的运行日志等。<br>D. 数据质量和运维相关元数据，如任务监控、运维报警、数据质量、故障等信息，包括任务监控运行日志、告警配置及运行日志、故障信息等。</p>\n<p>业务元数据从业务角度描述了数据仓库中的数据，它提供了介于使用者和实际系统之间的语义层，使得不懂计算机技术的业务人员也能够“读懂”数据仓库串的数据。阿里巴巴常用的业务元数据有：<br>1.OneData元数据，如维度及属性，业务过程、指标等的规范化定义，用于更好地管理和使用数据。<br>2.数据应用元数据，如数据报表、数据产品等的配置和运行元数据。</p>\n<h3 id=\"元数据的价值\"><a href=\"#元数据的价值\" class=\"headerlink\" title=\"元数据的价值\"></a>元数据的价值</h3><p>元数据有重要的应用价值，是数据管理、数据内容、数据应用的基础，在数据管理方面为集团数据提供在计算、存储、成本、质量、安全、模型等治理领域上的数据支持。例如在计算上可以利用元数据查找超长运行节点，对这些节点进行专项治理，保障基线产出时间。在数据内容方面为集团数据进行数据域、数据主题、业务属性等的提取和分析提供数据素材。例如可以利用元数据构建知识图谱，给数据打标签，清楚地知道现在哪些数据。在数据应用方面打通产品及应用链路，保护产品数据准确、及时产出。例如打通MaxCompute和应用数据，明确数据资产等级，更有效地保障产品数据。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p>阿里巴巴《大数据之路》</p>\n"},{"title":"文章格式","date":"2018-10-09T07:00:00.000Z","_content":"# 文章格式\n作者 像玉的石头 \n来源 图书《秘书工作手记——办公室老江湖的职场心法》\n\n《党政机关公文处理工作条例》《党政机关公文格式》之类的条例和标准，可以参考，养成习惯，必有所收获。另关作者关键提出如下几点。\n    \n### 标题\n并非越大越好，千万别用黑体！一般用2号小标实体字；在顶端或红色分隔线下空二行位置；分一行或多行居中排布；回行时，要做到词意完整，排列对称， 长短适宜， 间距恰当； 标题排列应当使用梯形或菱形， 工字型简直丑得不能看！ 若有副标题， 破折号之后则是三号楷体。 \n\t关于标题的摆布还有一个值得注意的小问题， 那就是排版的时候尽量要把每一部分的标题和其下的内容安排在同一页纸上。 很多人在排版时不注意这一点， 标题放在第一页最后一行， 内容却从第二页第一行开始， 明明是同一部分的内容， 作为旗帜的标题和作为支撑的内容却被硬生生拆散了， 这样容易给读者阅读、 理解该部分的内容造成不便。 正确的做法应是敲下回车， 把标题安排在第二页的起始， 这样标题和内容就“ 无缝衔接” 了， 阅读时感觉会顺畅许多。 \n\n### 正文\n仿宋！ 仿宋！ 仿宋！ 不是仿宋自己打屁股， 最基本的都不懂。 一般用3号仿宋体字； 每个自然段左空二字， 回行顶格。 \n\n### 序号\n这个很多人乱整， 完全随心所欲， 还有不少人公文序号用圈一的， 土包子！ 按照规范， 文中结构层次序数依次可以用“ 一、”“（ 一）”“ 1.”“（ 1）” 标注； 一般第一层用黑体字、 第二层用楷体字、 第三层和第四层用仿宋体字标注； 都是三号， 都不加粗！ \n\n### 行距\n你可知道行距也是有要求的？ 整个行距40是几个意思？ 凑字数吗？ 规范要求的是排版每面排22行， 每行排28个字， 并撑满版心。 在Word里如何达到呢？ 一是调页面设置， 页边距上3.3， 下3.3， 左2.9， 右2.6， 页脚边距2.9； 二是调行高， 固定值29磅。 注意， 这些数值并非一成不变， 可以根据稿件的实际微调。 \n    做到这四点， 一眼看上去， 公文的格式就基本规范了。 当然， 其他关于附件、 署名、 日期等都有相应要求， 这个就不再赘述， 请大家自行在《 党政机关公文格式》吧。 \n总之， 公文写完了， 先别急着发邮件、 交领导， 花五分钟， 把格式认认真真调一遍， 石头敢说， 即使一字不改， 这篇文章在别人眼里的水准， 也至少翻了一番。\n\n\n\n","source":"_posts/读书/文章格式 .md","raw":"---\ntitle: 文章格式\ndate: 2018-10-09 15:00:00\ntags: [写作]\ncategories: [写作]\n---\n# 文章格式\n作者 像玉的石头 \n来源 图书《秘书工作手记——办公室老江湖的职场心法》\n\n《党政机关公文处理工作条例》《党政机关公文格式》之类的条例和标准，可以参考，养成习惯，必有所收获。另关作者关键提出如下几点。\n    \n### 标题\n并非越大越好，千万别用黑体！一般用2号小标实体字；在顶端或红色分隔线下空二行位置；分一行或多行居中排布；回行时，要做到词意完整，排列对称， 长短适宜， 间距恰当； 标题排列应当使用梯形或菱形， 工字型简直丑得不能看！ 若有副标题， 破折号之后则是三号楷体。 \n\t关于标题的摆布还有一个值得注意的小问题， 那就是排版的时候尽量要把每一部分的标题和其下的内容安排在同一页纸上。 很多人在排版时不注意这一点， 标题放在第一页最后一行， 内容却从第二页第一行开始， 明明是同一部分的内容， 作为旗帜的标题和作为支撑的内容却被硬生生拆散了， 这样容易给读者阅读、 理解该部分的内容造成不便。 正确的做法应是敲下回车， 把标题安排在第二页的起始， 这样标题和内容就“ 无缝衔接” 了， 阅读时感觉会顺畅许多。 \n\n### 正文\n仿宋！ 仿宋！ 仿宋！ 不是仿宋自己打屁股， 最基本的都不懂。 一般用3号仿宋体字； 每个自然段左空二字， 回行顶格。 \n\n### 序号\n这个很多人乱整， 完全随心所欲， 还有不少人公文序号用圈一的， 土包子！ 按照规范， 文中结构层次序数依次可以用“ 一、”“（ 一）”“ 1.”“（ 1）” 标注； 一般第一层用黑体字、 第二层用楷体字、 第三层和第四层用仿宋体字标注； 都是三号， 都不加粗！ \n\n### 行距\n你可知道行距也是有要求的？ 整个行距40是几个意思？ 凑字数吗？ 规范要求的是排版每面排22行， 每行排28个字， 并撑满版心。 在Word里如何达到呢？ 一是调页面设置， 页边距上3.3， 下3.3， 左2.9， 右2.6， 页脚边距2.9； 二是调行高， 固定值29磅。 注意， 这些数值并非一成不变， 可以根据稿件的实际微调。 \n    做到这四点， 一眼看上去， 公文的格式就基本规范了。 当然， 其他关于附件、 署名、 日期等都有相应要求， 这个就不再赘述， 请大家自行在《 党政机关公文格式》吧。 \n总之， 公文写完了， 先别急着发邮件、 交领导， 花五分钟， 把格式认认真真调一遍， 石头敢说， 即使一字不改， 这篇文章在别人眼里的水准， 也至少翻了一番。\n\n\n\n","slug":"读书/文章格式 ","published":1,"updated":"2018-10-09T08:26:10.825Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bkj002zs77r09jgoote","content":"<h1 id=\"文章格式\"><a href=\"#文章格式\" class=\"headerlink\" title=\"文章格式\"></a>文章格式</h1><p>作者 像玉的石头<br>来源 图书《秘书工作手记——办公室老江湖的职场心法》</p>\n<p>《党政机关公文处理工作条例》《党政机关公文格式》之类的条例和标准，可以参考，养成习惯，必有所收获。另关作者关键提出如下几点。</p>\n<h3 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h3><p>并非越大越好，千万别用黑体！一般用2号小标实体字；在顶端或红色分隔线下空二行位置；分一行或多行居中排布；回行时，要做到词意完整，排列对称， 长短适宜， 间距恰当； 标题排列应当使用梯形或菱形， 工字型简直丑得不能看！ 若有副标题， 破折号之后则是三号楷体。<br>    关于标题的摆布还有一个值得注意的小问题， 那就是排版的时候尽量要把每一部分的标题和其下的内容安排在同一页纸上。 很多人在排版时不注意这一点， 标题放在第一页最后一行， 内容却从第二页第一行开始， 明明是同一部分的内容， 作为旗帜的标题和作为支撑的内容却被硬生生拆散了， 这样容易给读者阅读、 理解该部分的内容造成不便。 正确的做法应是敲下回车， 把标题安排在第二页的起始， 这样标题和内容就“ 无缝衔接” 了， 阅读时感觉会顺畅许多。 </p>\n<h3 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h3><p>仿宋！ 仿宋！ 仿宋！ 不是仿宋自己打屁股， 最基本的都不懂。 一般用3号仿宋体字； 每个自然段左空二字， 回行顶格。 </p>\n<h3 id=\"序号\"><a href=\"#序号\" class=\"headerlink\" title=\"序号\"></a>序号</h3><p>这个很多人乱整， 完全随心所欲， 还有不少人公文序号用圈一的， 土包子！ 按照规范， 文中结构层次序数依次可以用“ 一、”“（ 一）”“ 1.”“（ 1）” 标注； 一般第一层用黑体字、 第二层用楷体字、 第三层和第四层用仿宋体字标注； 都是三号， 都不加粗！ </p>\n<h3 id=\"行距\"><a href=\"#行距\" class=\"headerlink\" title=\"行距\"></a>行距</h3><p>你可知道行距也是有要求的？ 整个行距40是几个意思？ 凑字数吗？ 规范要求的是排版每面排22行， 每行排28个字， 并撑满版心。 在Word里如何达到呢？ 一是调页面设置， 页边距上3.3， 下3.3， 左2.9， 右2.6， 页脚边距2.9； 二是调行高， 固定值29磅。 注意， 这些数值并非一成不变， 可以根据稿件的实际微调。<br>    做到这四点， 一眼看上去， 公文的格式就基本规范了。 当然， 其他关于附件、 署名、 日期等都有相应要求， 这个就不再赘述， 请大家自行在《 党政机关公文格式》吧。<br>总之， 公文写完了， 先别急着发邮件、 交领导， 花五分钟， 把格式认认真真调一遍， 石头敢说， 即使一字不改， 这篇文章在别人眼里的水准， 也至少翻了一番。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"文章格式\"><a href=\"#文章格式\" class=\"headerlink\" title=\"文章格式\"></a>文章格式</h1><p>作者 像玉的石头<br>来源 图书《秘书工作手记——办公室老江湖的职场心法》</p>\n<p>《党政机关公文处理工作条例》《党政机关公文格式》之类的条例和标准，可以参考，养成习惯，必有所收获。另关作者关键提出如下几点。</p>\n<h3 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h3><p>并非越大越好，千万别用黑体！一般用2号小标实体字；在顶端或红色分隔线下空二行位置；分一行或多行居中排布；回行时，要做到词意完整，排列对称， 长短适宜， 间距恰当； 标题排列应当使用梯形或菱形， 工字型简直丑得不能看！ 若有副标题， 破折号之后则是三号楷体。<br>    关于标题的摆布还有一个值得注意的小问题， 那就是排版的时候尽量要把每一部分的标题和其下的内容安排在同一页纸上。 很多人在排版时不注意这一点， 标题放在第一页最后一行， 内容却从第二页第一行开始， 明明是同一部分的内容， 作为旗帜的标题和作为支撑的内容却被硬生生拆散了， 这样容易给读者阅读、 理解该部分的内容造成不便。 正确的做法应是敲下回车， 把标题安排在第二页的起始， 这样标题和内容就“ 无缝衔接” 了， 阅读时感觉会顺畅许多。 </p>\n<h3 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h3><p>仿宋！ 仿宋！ 仿宋！ 不是仿宋自己打屁股， 最基本的都不懂。 一般用3号仿宋体字； 每个自然段左空二字， 回行顶格。 </p>\n<h3 id=\"序号\"><a href=\"#序号\" class=\"headerlink\" title=\"序号\"></a>序号</h3><p>这个很多人乱整， 完全随心所欲， 还有不少人公文序号用圈一的， 土包子！ 按照规范， 文中结构层次序数依次可以用“ 一、”“（ 一）”“ 1.”“（ 1）” 标注； 一般第一层用黑体字、 第二层用楷体字、 第三层和第四层用仿宋体字标注； 都是三号， 都不加粗！ </p>\n<h3 id=\"行距\"><a href=\"#行距\" class=\"headerlink\" title=\"行距\"></a>行距</h3><p>你可知道行距也是有要求的？ 整个行距40是几个意思？ 凑字数吗？ 规范要求的是排版每面排22行， 每行排28个字， 并撑满版心。 在Word里如何达到呢？ 一是调页面设置， 页边距上3.3， 下3.3， 左2.9， 右2.6， 页脚边距2.9； 二是调行高， 固定值29磅。 注意， 这些数值并非一成不变， 可以根据稿件的实际微调。<br>    做到这四点， 一眼看上去， 公文的格式就基本规范了。 当然， 其他关于附件、 署名、 日期等都有相应要求， 这个就不再赘述， 请大家自行在《 党政机关公文格式》吧。<br>总之， 公文写完了， 先别急着发邮件、 交领导， 花五分钟， 把格式认认真真调一遍， 石头敢说， 即使一字不改， 这篇文章在别人眼里的水准， 也至少翻了一番。</p>\n"},{"title":"微小店","date":"2019-01-19T22:00:00.000Z","_content":"\n#微小店\n微小店正在建设中，敬请期待！！！","source":"_posts/广告/微小店.md","raw":"---\ntitle: 微小店\ndate: 2019-01-20 06:00:00\ntags: [广告]\ncategories: [广告]\n---\n\n#微小店\n微小店正在建设中，敬请期待！！！","slug":"广告/微小店","published":1,"updated":"2019-01-20T15:27:54.214Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bkk0031s77rpumgp7cy","content":"<p>#微小店<br>微小店正在建设中，敬请期待！！！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>#微小店<br>微小店正在建设中，敬请期待！！！</p>\n"},{"title":"确定目标|方法论-SMART原则","date":"2018-07-18T03:03:41.000Z","_content":"SMART本义是聪明的意思，作为目标梳理的原则，其实是5个字母的组合。\n## SMART原则\nS代表具体（Specific）：目标必须是明确的、具体的、不模糊的。 要切中特定的工作指标，不能笼统;\nM代表可度量（Measurable）：目标必须是可衡量的，也就是目标有没有达成要有一个清晰的界限；可数量化或者行为化的，验证这些目标的数据或者信息是可以获得的;\nA代表可实现（Achievable）：目标必须是可达到的， 即目标必须是“跳一下才够得着的目标”。含有两层意思，其一，目标不能太高，否则会让人望而却步；其二，目标不能没有挑战性，否则目标失去意义，难以给人动力。\nR代表相关性（Realistic）：目标要基于现实；目标需要和其他目标具有相关性，可以被证明和观察的，这样才切合实际，才好执行。目标是与工作的其它目标是相关联的;目标是与本职工作相关联的;\nT（Timed）：目标必须有明确的截止期限；\n## 举例说明\n   S--具体 ：比如明天的英语计划，你想看一个番茄的follow me ，那么怎么样做到具体呢? 你可以写上“follow me 看一个视频”，或者写上“follow me 看完第三个视频” 这些具体的计划能够让我们的计划更加的准确，再拿计算机项目来说，列学生系统的项目时，可以写上9:00-9:30是敲完第三个模块的第2个窗体，这样让自己更加严格要求自己，自己的目标也会更加的清晰，完成时也会很有劲头。\n   M--可度量性：这个就是你的目标要设置的更加的清晰，有意义，可管理，不能说你列个计划 “今天要敲机房” 这样的目标还不如不列，没什么实实在在的用处，自己的思路也不会很清晰，还是不能很好的完成计划，你说你今天也弄机房了，也没有完成机房，那你是算完成计划了呢，还是没完成？\n   A--可实现的：就是给自己设置的目标不要太高，比如我每天给自己设置的每个类别，包括“自考看两章，学生优化两个方面，英语看两集着迷英语900”就是自己跳起来能够实现的目标，目标太高的话自己不能实现，太低没有效率，都是计划的不完美。\n   R--相关性：我们设置的各个小目标都应该是有关联的，这样才能更加有效的实行计划，比如我们学英语是为了更好的理解代码，敲代码也是为了更好的实践我们的自考学习，我们的大部分计划都是相互关联的。开学的时候学习专业课，给自己制定计划复习专业课的书本同样也是与我们的学习如何学习想关联，都是串联在一起的，这样我们能够更加高效的学习！\n   T--有时限： 我们的每个计划都要有很准确的开始时间结束时间，让我们能够严格的要求自己，比如我是严格按照番茄学习法来学习的，每次的小目标都是半个小时半个小时的来完成的，但是我做的不足的一点是，每天列计划主线的时候没有固定更加准确的时间，比如学生优化每天一共有多少小时，以后对于这点要做的更好才行！\n\n参考摘要：\n[如何更好的做计划-SMART原则](https://blog.csdn.net/hdy14/article/details/77394608?foxhandler=RssReadRenderProcessHandler)\n[目标设立的SMART原则](https://www.douban.com/group/topic/45198723/)\n\n","source":"_posts/读书/确定目标|方法论-SMART原则.md","raw":"---\ntitle: 确定目标|方法论-SMART原则\ndate: 2018-07-18 11:03:41\ntags: [方法论]\ncategories: [方法论]\n---\nSMART本义是聪明的意思，作为目标梳理的原则，其实是5个字母的组合。\n## SMART原则\nS代表具体（Specific）：目标必须是明确的、具体的、不模糊的。 要切中特定的工作指标，不能笼统;\nM代表可度量（Measurable）：目标必须是可衡量的，也就是目标有没有达成要有一个清晰的界限；可数量化或者行为化的，验证这些目标的数据或者信息是可以获得的;\nA代表可实现（Achievable）：目标必须是可达到的， 即目标必须是“跳一下才够得着的目标”。含有两层意思，其一，目标不能太高，否则会让人望而却步；其二，目标不能没有挑战性，否则目标失去意义，难以给人动力。\nR代表相关性（Realistic）：目标要基于现实；目标需要和其他目标具有相关性，可以被证明和观察的，这样才切合实际，才好执行。目标是与工作的其它目标是相关联的;目标是与本职工作相关联的;\nT（Timed）：目标必须有明确的截止期限；\n## 举例说明\n   S--具体 ：比如明天的英语计划，你想看一个番茄的follow me ，那么怎么样做到具体呢? 你可以写上“follow me 看一个视频”，或者写上“follow me 看完第三个视频” 这些具体的计划能够让我们的计划更加的准确，再拿计算机项目来说，列学生系统的项目时，可以写上9:00-9:30是敲完第三个模块的第2个窗体，这样让自己更加严格要求自己，自己的目标也会更加的清晰，完成时也会很有劲头。\n   M--可度量性：这个就是你的目标要设置的更加的清晰，有意义，可管理，不能说你列个计划 “今天要敲机房” 这样的目标还不如不列，没什么实实在在的用处，自己的思路也不会很清晰，还是不能很好的完成计划，你说你今天也弄机房了，也没有完成机房，那你是算完成计划了呢，还是没完成？\n   A--可实现的：就是给自己设置的目标不要太高，比如我每天给自己设置的每个类别，包括“自考看两章，学生优化两个方面，英语看两集着迷英语900”就是自己跳起来能够实现的目标，目标太高的话自己不能实现，太低没有效率，都是计划的不完美。\n   R--相关性：我们设置的各个小目标都应该是有关联的，这样才能更加有效的实行计划，比如我们学英语是为了更好的理解代码，敲代码也是为了更好的实践我们的自考学习，我们的大部分计划都是相互关联的。开学的时候学习专业课，给自己制定计划复习专业课的书本同样也是与我们的学习如何学习想关联，都是串联在一起的，这样我们能够更加高效的学习！\n   T--有时限： 我们的每个计划都要有很准确的开始时间结束时间，让我们能够严格的要求自己，比如我是严格按照番茄学习法来学习的，每次的小目标都是半个小时半个小时的来完成的，但是我做的不足的一点是，每天列计划主线的时候没有固定更加准确的时间，比如学生优化每天一共有多少小时，以后对于这点要做的更好才行！\n\n参考摘要：\n[如何更好的做计划-SMART原则](https://blog.csdn.net/hdy14/article/details/77394608?foxhandler=RssReadRenderProcessHandler)\n[目标设立的SMART原则](https://www.douban.com/group/topic/45198723/)\n\n","slug":"读书/确定目标|方法论-SMART原则","published":1,"updated":"2018-07-18T03:10:46.238Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bkl0033s77rc1cm98m9","content":"<p>SMART本义是聪明的意思，作为目标梳理的原则，其实是5个字母的组合。</p>\n<h2 id=\"SMART原则\"><a href=\"#SMART原则\" class=\"headerlink\" title=\"SMART原则\"></a>SMART原则</h2><p>S代表具体（Specific）：目标必须是明确的、具体的、不模糊的。 要切中特定的工作指标，不能笼统;<br>M代表可度量（Measurable）：目标必须是可衡量的，也就是目标有没有达成要有一个清晰的界限；可数量化或者行为化的，验证这些目标的数据或者信息是可以获得的;<br>A代表可实现（Achievable）：目标必须是可达到的， 即目标必须是“跳一下才够得着的目标”。含有两层意思，其一，目标不能太高，否则会让人望而却步；其二，目标不能没有挑战性，否则目标失去意义，难以给人动力。<br>R代表相关性（Realistic）：目标要基于现实；目标需要和其他目标具有相关性，可以被证明和观察的，这样才切合实际，才好执行。目标是与工作的其它目标是相关联的;目标是与本职工作相关联的;<br>T（Timed）：目标必须有明确的截止期限；</p>\n<h2 id=\"举例说明\"><a href=\"#举例说明\" class=\"headerlink\" title=\"举例说明\"></a>举例说明</h2><p>   S–具体 ：比如明天的英语计划，你想看一个番茄的follow me ，那么怎么样做到具体呢? 你可以写上“follow me 看一个视频”，或者写上“follow me 看完第三个视频” 这些具体的计划能够让我们的计划更加的准确，再拿计算机项目来说，列学生系统的项目时，可以写上9:00-9:30是敲完第三个模块的第2个窗体，这样让自己更加严格要求自己，自己的目标也会更加的清晰，完成时也会很有劲头。<br>   M–可度量性：这个就是你的目标要设置的更加的清晰，有意义，可管理，不能说你列个计划 “今天要敲机房” 这样的目标还不如不列，没什么实实在在的用处，自己的思路也不会很清晰，还是不能很好的完成计划，你说你今天也弄机房了，也没有完成机房，那你是算完成计划了呢，还是没完成？<br>   A–可实现的：就是给自己设置的目标不要太高，比如我每天给自己设置的每个类别，包括“自考看两章，学生优化两个方面，英语看两集着迷英语900”就是自己跳起来能够实现的目标，目标太高的话自己不能实现，太低没有效率，都是计划的不完美。<br>   R–相关性：我们设置的各个小目标都应该是有关联的，这样才能更加有效的实行计划，比如我们学英语是为了更好的理解代码，敲代码也是为了更好的实践我们的自考学习，我们的大部分计划都是相互关联的。开学的时候学习专业课，给自己制定计划复习专业课的书本同样也是与我们的学习如何学习想关联，都是串联在一起的，这样我们能够更加高效的学习！<br>   T–有时限： 我们的每个计划都要有很准确的开始时间结束时间，让我们能够严格的要求自己，比如我是严格按照番茄学习法来学习的，每次的小目标都是半个小时半个小时的来完成的，但是我做的不足的一点是，每天列计划主线的时候没有固定更加准确的时间，比如学生优化每天一共有多少小时，以后对于这点要做的更好才行！</p>\n<p>参考摘要：<br><a href=\"https://blog.csdn.net/hdy14/article/details/77394608?foxhandler=RssReadRenderProcessHandler\" target=\"_blank\" rel=\"noopener\">如何更好的做计划-SMART原则</a><br><a href=\"https://www.douban.com/group/topic/45198723/\" target=\"_blank\" rel=\"noopener\">目标设立的SMART原则</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>SMART本义是聪明的意思，作为目标梳理的原则，其实是5个字母的组合。</p>\n<h2 id=\"SMART原则\"><a href=\"#SMART原则\" class=\"headerlink\" title=\"SMART原则\"></a>SMART原则</h2><p>S代表具体（Specific）：目标必须是明确的、具体的、不模糊的。 要切中特定的工作指标，不能笼统;<br>M代表可度量（Measurable）：目标必须是可衡量的，也就是目标有没有达成要有一个清晰的界限；可数量化或者行为化的，验证这些目标的数据或者信息是可以获得的;<br>A代表可实现（Achievable）：目标必须是可达到的， 即目标必须是“跳一下才够得着的目标”。含有两层意思，其一，目标不能太高，否则会让人望而却步；其二，目标不能没有挑战性，否则目标失去意义，难以给人动力。<br>R代表相关性（Realistic）：目标要基于现实；目标需要和其他目标具有相关性，可以被证明和观察的，这样才切合实际，才好执行。目标是与工作的其它目标是相关联的;目标是与本职工作相关联的;<br>T（Timed）：目标必须有明确的截止期限；</p>\n<h2 id=\"举例说明\"><a href=\"#举例说明\" class=\"headerlink\" title=\"举例说明\"></a>举例说明</h2><p>   S–具体 ：比如明天的英语计划，你想看一个番茄的follow me ，那么怎么样做到具体呢? 你可以写上“follow me 看一个视频”，或者写上“follow me 看完第三个视频” 这些具体的计划能够让我们的计划更加的准确，再拿计算机项目来说，列学生系统的项目时，可以写上9:00-9:30是敲完第三个模块的第2个窗体，这样让自己更加严格要求自己，自己的目标也会更加的清晰，完成时也会很有劲头。<br>   M–可度量性：这个就是你的目标要设置的更加的清晰，有意义，可管理，不能说你列个计划 “今天要敲机房” 这样的目标还不如不列，没什么实实在在的用处，自己的思路也不会很清晰，还是不能很好的完成计划，你说你今天也弄机房了，也没有完成机房，那你是算完成计划了呢，还是没完成？<br>   A–可实现的：就是给自己设置的目标不要太高，比如我每天给自己设置的每个类别，包括“自考看两章，学生优化两个方面，英语看两集着迷英语900”就是自己跳起来能够实现的目标，目标太高的话自己不能实现，太低没有效率，都是计划的不完美。<br>   R–相关性：我们设置的各个小目标都应该是有关联的，这样才能更加有效的实行计划，比如我们学英语是为了更好的理解代码，敲代码也是为了更好的实践我们的自考学习，我们的大部分计划都是相互关联的。开学的时候学习专业课，给自己制定计划复习专业课的书本同样也是与我们的学习如何学习想关联，都是串联在一起的，这样我们能够更加高效的学习！<br>   T–有时限： 我们的每个计划都要有很准确的开始时间结束时间，让我们能够严格的要求自己，比如我是严格按照番茄学习法来学习的，每次的小目标都是半个小时半个小时的来完成的，但是我做的不足的一点是，每天列计划主线的时候没有固定更加准确的时间，比如学生优化每天一共有多少小时，以后对于这点要做的更好才行！</p>\n<p>参考摘要：<br><a href=\"https://blog.csdn.net/hdy14/article/details/77394608?foxhandler=RssReadRenderProcessHandler\" target=\"_blank\" rel=\"noopener\">如何更好的做计划-SMART原则</a><br><a href=\"https://www.douban.com/group/topic/45198723/\" target=\"_blank\" rel=\"noopener\">目标设立的SMART原则</a></p>\n"},{"title":"综合分析|方法论-SOWT分析法","date":"2018-07-18T03:03:41.000Z","_content":"## 什么是SOWT\nSWOT是用于分析企业内外环境的模型，由四部分组成，分别为优势(Strengths)、劣势(Weaknesses)、机会(Opportunities)、威胁(Threats)。其中优势与劣势用于内部环境分析，机会和威胁用于外部环境分析。\n\n## 意义\n帮您清晰地把握全局，分析自己在资源方面的优势与劣势，把握环境提供的机会，防范可能存在的风险与威胁，对我们的成功有非常重要的意义。\n\n## 如何利用Swot去分析\n优势(S)：你的优势是什么？有哪些特长。\n劣势(W)：劣势是什么？有哪些不足。\n机会(O)：身边有哪些机会？外部因素哪些对你有利？\n威胁(T)：有哪些阻碍？外部因素有哪些对你不利？有哪些敌人？\n\n\n## 面临的问题\n1,如何利用优势(S)抓住机会(O)；\n2.如何利用优势(S)解决威胁(T)；\n3.如何改善劣势(W)来抓住机会(O)；\n4,如何改善劣势(W)来应对威胁(T)。\n\n当优势(S)与机会(O)同在时，我们要抓住机会充分发挥；当劣势(W)与机会(O)同在时，我们要懂得趋利避害；\n当劣势(W)与威胁(T)随之而来时，我们要静下心来进行自我修炼；当优势(S)与威胁(T)并存时，我们要发挥优势(S)，扬长避短。\n\n引用参考：\n[信贷圈：手把手教你最实用的工具：SWOT分析法！](http://www.sohu.com/a/125604696_493484)\n[知乎用户@荔枝的回答](https://www.zhihu.com/question/22765290)\n\n","source":"_posts/读书/综合分析|方法论-SOWT分析法.md","raw":"---\ntitle: 综合分析|方法论-SOWT分析法\ndate: 2018-07-18 11:03:41\ntags: [方法论]\ncategories: [方法论]\n---\n## 什么是SOWT\nSWOT是用于分析企业内外环境的模型，由四部分组成，分别为优势(Strengths)、劣势(Weaknesses)、机会(Opportunities)、威胁(Threats)。其中优势与劣势用于内部环境分析，机会和威胁用于外部环境分析。\n\n## 意义\n帮您清晰地把握全局，分析自己在资源方面的优势与劣势，把握环境提供的机会，防范可能存在的风险与威胁，对我们的成功有非常重要的意义。\n\n## 如何利用Swot去分析\n优势(S)：你的优势是什么？有哪些特长。\n劣势(W)：劣势是什么？有哪些不足。\n机会(O)：身边有哪些机会？外部因素哪些对你有利？\n威胁(T)：有哪些阻碍？外部因素有哪些对你不利？有哪些敌人？\n\n\n## 面临的问题\n1,如何利用优势(S)抓住机会(O)；\n2.如何利用优势(S)解决威胁(T)；\n3.如何改善劣势(W)来抓住机会(O)；\n4,如何改善劣势(W)来应对威胁(T)。\n\n当优势(S)与机会(O)同在时，我们要抓住机会充分发挥；当劣势(W)与机会(O)同在时，我们要懂得趋利避害；\n当劣势(W)与威胁(T)随之而来时，我们要静下心来进行自我修炼；当优势(S)与威胁(T)并存时，我们要发挥优势(S)，扬长避短。\n\n引用参考：\n[信贷圈：手把手教你最实用的工具：SWOT分析法！](http://www.sohu.com/a/125604696_493484)\n[知乎用户@荔枝的回答](https://www.zhihu.com/question/22765290)\n\n","slug":"读书/综合分析|方法论-SOWT分析法","published":1,"updated":"2018-07-18T03:11:27.220Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bkm0035s77rv7g2xvyu","content":"<h2 id=\"什么是SOWT\"><a href=\"#什么是SOWT\" class=\"headerlink\" title=\"什么是SOWT\"></a>什么是SOWT</h2><p>SWOT是用于分析企业内外环境的模型，由四部分组成，分别为优势(Strengths)、劣势(Weaknesses)、机会(Opportunities)、威胁(Threats)。其中优势与劣势用于内部环境分析，机会和威胁用于外部环境分析。</p>\n<h2 id=\"意义\"><a href=\"#意义\" class=\"headerlink\" title=\"意义\"></a>意义</h2><p>帮您清晰地把握全局，分析自己在资源方面的优势与劣势，把握环境提供的机会，防范可能存在的风险与威胁，对我们的成功有非常重要的意义。</p>\n<h2 id=\"如何利用Swot去分析\"><a href=\"#如何利用Swot去分析\" class=\"headerlink\" title=\"如何利用Swot去分析\"></a>如何利用Swot去分析</h2><p>优势(S)：你的优势是什么？有哪些特长。<br>劣势(W)：劣势是什么？有哪些不足。<br>机会(O)：身边有哪些机会？外部因素哪些对你有利？<br>威胁(T)：有哪些阻碍？外部因素有哪些对你不利？有哪些敌人？</p>\n<h2 id=\"面临的问题\"><a href=\"#面临的问题\" class=\"headerlink\" title=\"面临的问题\"></a>面临的问题</h2><p>1,如何利用优势(S)抓住机会(O)；<br>2.如何利用优势(S)解决威胁(T)；<br>3.如何改善劣势(W)来抓住机会(O)；<br>4,如何改善劣势(W)来应对威胁(T)。</p>\n<p>当优势(S)与机会(O)同在时，我们要抓住机会充分发挥；当劣势(W)与机会(O)同在时，我们要懂得趋利避害；<br>当劣势(W)与威胁(T)随之而来时，我们要静下心来进行自我修炼；当优势(S)与威胁(T)并存时，我们要发挥优势(S)，扬长避短。</p>\n<p>引用参考：<br><a href=\"http://www.sohu.com/a/125604696_493484\" target=\"_blank\" rel=\"noopener\">信贷圈：手把手教你最实用的工具：SWOT分析法！</a><br><a href=\"https://www.zhihu.com/question/22765290\" target=\"_blank\" rel=\"noopener\">知乎用户@荔枝的回答</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"什么是SOWT\"><a href=\"#什么是SOWT\" class=\"headerlink\" title=\"什么是SOWT\"></a>什么是SOWT</h2><p>SWOT是用于分析企业内外环境的模型，由四部分组成，分别为优势(Strengths)、劣势(Weaknesses)、机会(Opportunities)、威胁(Threats)。其中优势与劣势用于内部环境分析，机会和威胁用于外部环境分析。</p>\n<h2 id=\"意义\"><a href=\"#意义\" class=\"headerlink\" title=\"意义\"></a>意义</h2><p>帮您清晰地把握全局，分析自己在资源方面的优势与劣势，把握环境提供的机会，防范可能存在的风险与威胁，对我们的成功有非常重要的意义。</p>\n<h2 id=\"如何利用Swot去分析\"><a href=\"#如何利用Swot去分析\" class=\"headerlink\" title=\"如何利用Swot去分析\"></a>如何利用Swot去分析</h2><p>优势(S)：你的优势是什么？有哪些特长。<br>劣势(W)：劣势是什么？有哪些不足。<br>机会(O)：身边有哪些机会？外部因素哪些对你有利？<br>威胁(T)：有哪些阻碍？外部因素有哪些对你不利？有哪些敌人？</p>\n<h2 id=\"面临的问题\"><a href=\"#面临的问题\" class=\"headerlink\" title=\"面临的问题\"></a>面临的问题</h2><p>1,如何利用优势(S)抓住机会(O)；<br>2.如何利用优势(S)解决威胁(T)；<br>3.如何改善劣势(W)来抓住机会(O)；<br>4,如何改善劣势(W)来应对威胁(T)。</p>\n<p>当优势(S)与机会(O)同在时，我们要抓住机会充分发挥；当劣势(W)与机会(O)同在时，我们要懂得趋利避害；<br>当劣势(W)与威胁(T)随之而来时，我们要静下心来进行自我修炼；当优势(S)与威胁(T)并存时，我们要发挥优势(S)，扬长避短。</p>\n<p>引用参考：<br><a href=\"http://www.sohu.com/a/125604696_493484\" target=\"_blank\" rel=\"noopener\">信贷圈：手把手教你最实用的工具：SWOT分析法！</a><br><a href=\"https://www.zhihu.com/question/22765290\" target=\"_blank\" rel=\"noopener\">知乎用户@荔枝的回答</a></p>\n"},{"title":"Apache Spark与Apache Hadoop的关系","date":"2017-04-16T15:43:49.000Z","_content":"数据采集\n本文主要是讲外部系统与Hadoop之间的数据传递，包括从外部系统采集数据导入到hadoop，以及从Hadoop中提取数据导入外部系统中。\n\n#数据采集考量\n虽然Hadoop提出了文件客户端，便于在Hadoop中和Hadoop外复制文件，但是大多数据 Hadoop应用需要从不同来源导入数据，而且对不同的导入频率也提出了要求，Hadoop常用的数据来源包括以下：\n1.传统数据管理系统，如果关系型数据库与主机\n2.日志、机器生成的数据，以及其他类型的事件数据。\n3.从现有的企业数据存储中输入的文件。\n\n将数据从不同的系统输入Hadoop时需要考虑很多因素。如下：\n1.数据采集的时效性与可访问性\n需要采集数据在采集频率方面有哪些要求？下游的处理要求数据多长时间准备完毕？\n\n2.增量更新\n如何添加新数据？需要将数据添加到现有数据库吗？需要重写现有数据吗？\n\n3.数据访问和处理\n数据会用于处理过程吗？如果会，数据会用于批处理任务吗？需要的数据是不是随机获取的？\n\n4.数据分区及数据分片\n数据采集后应该如何分区？需要将数据导入到多个目录系统（如HDFS与HBase）吗？\n\n5.数据存储格式\n数据存储的格式是哪一种？\n\n6.数据变换\n需要变换尚未落地的数据吗？\n\n下面简单列举一下这几点考量？\n\n##1.数据采集的时效性\n这里的时效性是指可进行数据采集的时间与Hadoop中工具可访问数据的时间之间的间隔。采集架构的时间分类会对存储媒介和采集方法造成很大的影响。一般来说数据采集构架，可以使用以下分类中的一个\na.大型批处理\n通常指15分钟到数据小时的任务，有时可能指时间跨度达到一天的任务\n\nb.小型批处理\n通常指大约2分钟发送一次任务，但是总的来说不会超过15分钟\n\nc.近实时决策支持\n指接受信息后“立即作出反应”，并在2秒到2分钟内发送数据\n\nd.近实时事件处理\n指在2秒内处理任务，速度可达到100毫秒\n\ne.实时\n这里指不超过100毫秒\n\n可以注意到随着实现时间到达实时，实现的复杂度和成本会大大增加。从批处理出发（比如使用简单文件传输）通常是个不错的选择。HDFS对时效性的要求比较宽松，所以可能更加适合成为主要存储位置。而一个简单文件传输或Sqoop任务则适合作为采集数据的工具。比如，执行hadoop fs -put命令将复制一个文件，并进行全面的校验，以确定正确地复制数据。\n使用hadoop fs -put命令与Sqoop时，你需要明白一点：HDFS上的数据存储格式可能并不适合数据的长期存储和处理。因此，在使用这些工具的时候，可能需要通过额外的批处理操作，以将数据存储为需要的格式。\n当用户需要从简单的批处理转向更高频率的更新时，就应该考虑Flume或kafka之类的工具了。这里时间要求不起过2分钟，所以Sqoop与文件转换器不适用。而且，因为要求时间不起过2分钟，所以存储层可能需要变成HBase或Solr，这样插入与读取操作会获得更细的粒度。当要求到实时水平时，我们首先需要考虑内存，然后是永久性存储。全世界所有的平行化处理都不会有助于将反应要求控制在500毫秒以内，只要硬盘驱动器保持处理操作的状态。基于这一点，我们开始进入流处理领域，采用Storm或Spark Streaming之类的工具。这里需要强调的是，这些工具应该真正用于大数据处理，而不是像Flume或Sqoop那样用于数据采集。\n\n##2.增量更新\n新的数据是要添加到已有数据集中，还是要修改已有数据集。如果仅要求添加数据，那么HDFS对于大部分实现都很适用。HDFS能够并行 化多个驱动器的I/O操作，所以读写性能很高。HDFS的缺点是无法添加或者随机写入创建后的文件。\n\n#数据采集的选择\n##1.文件传输\n将数据导入导出到Hadoop最简单的方法就是文件传输，就是hadoop fs -put与hadoop fs -get命令。这有时也是最快的方法，所以在设计Hadoop新的数据处理流水线时，首先应该考虑选择文件传输。\n\n下面列一下文件传输的特点：\na.这是一种all-or-nothing批处理方法，所以如果文件传输过程中出现错误，则不会写入或读取任何数据。这种方法与Flume、Kafka之类的采集方法不同，后者提供一定程度的错误处理功能，并且有传输保障。\nb.文件传输默认为单线程，不能并行 文件传输。\nc.文件传输将文件从传统的文件系统导入HDFS\nd.不支持数据转换，数据按原样导入HDFS。数据导入HDFS后才能进行处理，这一点与传输过程中的数据转换截然相反。类似于Flume的系统支持传输过程中的数据转换。\ne.这种加载是逐字进行的，所以能传输任何类型的文件（文件、二进制、图书等）\n\n##文件传输与其他采集方法的考量\n简单文件传输在某些情况下是适用的，尤其是在需要将已存在 的一系列文件输入到HDFS中，而且可以接受保持源文件格式的情况下。否则，在决定是否可以接受文件传输或者是否使用类似于Flume的工具时，需要考虑以下因素。\na.需要将数据采集到多个位置吗？比如，是需要将数据同时输入HDFS和Solr，还是需要将数据同时输入HDFS和HBase？这种情况下，如果使用文件传输，那么在文件采集完成之后将需要额外的工作，因些采用Flume更合适。\nb.对可靠性的要求高不高？如果高，那么一旦传输时出现错误，文件传输就必须重新开始，这时，Fluem同样是更好的选择。\ne.数据采集之前需要转换操作吗？如果需要Flume无疑是适合的工具。\n如果需要采集文件，可以考虑使用Flume Spooling  Directory源。采用这种方法，用户将文件放置到磁盘特定的目录就可以采集文件。这种采集文件的方法简单可靠，而且需要时能够实现传输过程中的数据转换。\n\n##Sqoop：Hadoop与关系数据库的批量传输\nSqoop是一种工具，能批量地将数据从关系型数据管理系统导出到Hadoop中，也能批量地将数据从Hadoop导出至关系型数据库中。\n\nFlume:基于事件的数据收集及处理\nFlume是一种分布式的可靠开源系统，用于流数据的高效收集、聚焦和移动。Flume通常用于移动日志数据，但是也能移动大量事件数据，如社交媒体订阅、消息队列事件或网络流量数据。\n\n##Kafka\nApache Kafka是一种发布订单消息的分布式系统，能够将消息归类为不同主题。应用程序能在Kafka上发布信息，或订阅主题进而接受特定主要下发布的消息。Producer发布消息，而Consumer收集并处理消息。作为分布式系统，Kafka在集群中运行，每个节点被称为Broker。\nKafka维护每个主题的分区日志。消息会发布到相应的主题中，每个分区都是一个有序的消息子集。同一个主题的多个分区能够通过集群中的多个Broker传送，这种方法提高了主题的容量与吞吐量，使其超越了单一机器所能提供的容量与吞吐量。消息在分区内被有序排列，每个消息都包含一个特定的偏移量。Kafka中消息可以通过一个包含主题、分区以及偏移量的组合来确定。Producer能够根据消息的主键选择消息应该写入哪一个分区，也能够简单地用循环的方式，让消息分布在各分区之间。\nConsumer会在Consumer组中注册，每个组包括一个或多个Consumer，每个Consumer读取一个或多个主题分区。每组中的每条消息只能传送给一个Consumer。但是，如果多个组订阅了同一个主题，那么每个组都将得到所有的消息。一个组中包含多个Consumer有助于获得加载平衡（可以支持高于单个Consumer处理能力的吞吐量）与高可用性（如果一个Consumer出现错误，它所读取的分区将重新分配给组中其它Consumer）。\n前面提到，对于应用层面的数据分类，主要单位是主题。一个Consumer或Consumer组将读取其订阅主题的所有数据，所以如果一个应用只关注一个数据子集，那么就应该将该数据子集与其他数据放在两个不同的主题中。如果多个信息集总是一起读取和处理，那么应该将它们归在同一个主题中。\n\n#数据导出\n数据导出的思路与导入类似。\n\n\n\n\n\n\n","source":"_posts/hadoop/Apache Spark与Apache Hadoop的关系.md","raw":"---\ntitle:  Apache Spark与Apache Hadoop的关系\ndate: 2017-04-16 23:43:49\ntags: [大数据,spark,hadoop]\ncategories: [大数据,hadoop]\n---\n数据采集\n本文主要是讲外部系统与Hadoop之间的数据传递，包括从外部系统采集数据导入到hadoop，以及从Hadoop中提取数据导入外部系统中。\n\n#数据采集考量\n虽然Hadoop提出了文件客户端，便于在Hadoop中和Hadoop外复制文件，但是大多数据 Hadoop应用需要从不同来源导入数据，而且对不同的导入频率也提出了要求，Hadoop常用的数据来源包括以下：\n1.传统数据管理系统，如果关系型数据库与主机\n2.日志、机器生成的数据，以及其他类型的事件数据。\n3.从现有的企业数据存储中输入的文件。\n\n将数据从不同的系统输入Hadoop时需要考虑很多因素。如下：\n1.数据采集的时效性与可访问性\n需要采集数据在采集频率方面有哪些要求？下游的处理要求数据多长时间准备完毕？\n\n2.增量更新\n如何添加新数据？需要将数据添加到现有数据库吗？需要重写现有数据吗？\n\n3.数据访问和处理\n数据会用于处理过程吗？如果会，数据会用于批处理任务吗？需要的数据是不是随机获取的？\n\n4.数据分区及数据分片\n数据采集后应该如何分区？需要将数据导入到多个目录系统（如HDFS与HBase）吗？\n\n5.数据存储格式\n数据存储的格式是哪一种？\n\n6.数据变换\n需要变换尚未落地的数据吗？\n\n下面简单列举一下这几点考量？\n\n##1.数据采集的时效性\n这里的时效性是指可进行数据采集的时间与Hadoop中工具可访问数据的时间之间的间隔。采集架构的时间分类会对存储媒介和采集方法造成很大的影响。一般来说数据采集构架，可以使用以下分类中的一个\na.大型批处理\n通常指15分钟到数据小时的任务，有时可能指时间跨度达到一天的任务\n\nb.小型批处理\n通常指大约2分钟发送一次任务，但是总的来说不会超过15分钟\n\nc.近实时决策支持\n指接受信息后“立即作出反应”，并在2秒到2分钟内发送数据\n\nd.近实时事件处理\n指在2秒内处理任务，速度可达到100毫秒\n\ne.实时\n这里指不超过100毫秒\n\n可以注意到随着实现时间到达实时，实现的复杂度和成本会大大增加。从批处理出发（比如使用简单文件传输）通常是个不错的选择。HDFS对时效性的要求比较宽松，所以可能更加适合成为主要存储位置。而一个简单文件传输或Sqoop任务则适合作为采集数据的工具。比如，执行hadoop fs -put命令将复制一个文件，并进行全面的校验，以确定正确地复制数据。\n使用hadoop fs -put命令与Sqoop时，你需要明白一点：HDFS上的数据存储格式可能并不适合数据的长期存储和处理。因此，在使用这些工具的时候，可能需要通过额外的批处理操作，以将数据存储为需要的格式。\n当用户需要从简单的批处理转向更高频率的更新时，就应该考虑Flume或kafka之类的工具了。这里时间要求不起过2分钟，所以Sqoop与文件转换器不适用。而且，因为要求时间不起过2分钟，所以存储层可能需要变成HBase或Solr，这样插入与读取操作会获得更细的粒度。当要求到实时水平时，我们首先需要考虑内存，然后是永久性存储。全世界所有的平行化处理都不会有助于将反应要求控制在500毫秒以内，只要硬盘驱动器保持处理操作的状态。基于这一点，我们开始进入流处理领域，采用Storm或Spark Streaming之类的工具。这里需要强调的是，这些工具应该真正用于大数据处理，而不是像Flume或Sqoop那样用于数据采集。\n\n##2.增量更新\n新的数据是要添加到已有数据集中，还是要修改已有数据集。如果仅要求添加数据，那么HDFS对于大部分实现都很适用。HDFS能够并行 化多个驱动器的I/O操作，所以读写性能很高。HDFS的缺点是无法添加或者随机写入创建后的文件。\n\n#数据采集的选择\n##1.文件传输\n将数据导入导出到Hadoop最简单的方法就是文件传输，就是hadoop fs -put与hadoop fs -get命令。这有时也是最快的方法，所以在设计Hadoop新的数据处理流水线时，首先应该考虑选择文件传输。\n\n下面列一下文件传输的特点：\na.这是一种all-or-nothing批处理方法，所以如果文件传输过程中出现错误，则不会写入或读取任何数据。这种方法与Flume、Kafka之类的采集方法不同，后者提供一定程度的错误处理功能，并且有传输保障。\nb.文件传输默认为单线程，不能并行 文件传输。\nc.文件传输将文件从传统的文件系统导入HDFS\nd.不支持数据转换，数据按原样导入HDFS。数据导入HDFS后才能进行处理，这一点与传输过程中的数据转换截然相反。类似于Flume的系统支持传输过程中的数据转换。\ne.这种加载是逐字进行的，所以能传输任何类型的文件（文件、二进制、图书等）\n\n##文件传输与其他采集方法的考量\n简单文件传输在某些情况下是适用的，尤其是在需要将已存在 的一系列文件输入到HDFS中，而且可以接受保持源文件格式的情况下。否则，在决定是否可以接受文件传输或者是否使用类似于Flume的工具时，需要考虑以下因素。\na.需要将数据采集到多个位置吗？比如，是需要将数据同时输入HDFS和Solr，还是需要将数据同时输入HDFS和HBase？这种情况下，如果使用文件传输，那么在文件采集完成之后将需要额外的工作，因些采用Flume更合适。\nb.对可靠性的要求高不高？如果高，那么一旦传输时出现错误，文件传输就必须重新开始，这时，Fluem同样是更好的选择。\ne.数据采集之前需要转换操作吗？如果需要Flume无疑是适合的工具。\n如果需要采集文件，可以考虑使用Flume Spooling  Directory源。采用这种方法，用户将文件放置到磁盘特定的目录就可以采集文件。这种采集文件的方法简单可靠，而且需要时能够实现传输过程中的数据转换。\n\n##Sqoop：Hadoop与关系数据库的批量传输\nSqoop是一种工具，能批量地将数据从关系型数据管理系统导出到Hadoop中，也能批量地将数据从Hadoop导出至关系型数据库中。\n\nFlume:基于事件的数据收集及处理\nFlume是一种分布式的可靠开源系统，用于流数据的高效收集、聚焦和移动。Flume通常用于移动日志数据，但是也能移动大量事件数据，如社交媒体订阅、消息队列事件或网络流量数据。\n\n##Kafka\nApache Kafka是一种发布订单消息的分布式系统，能够将消息归类为不同主题。应用程序能在Kafka上发布信息，或订阅主题进而接受特定主要下发布的消息。Producer发布消息，而Consumer收集并处理消息。作为分布式系统，Kafka在集群中运行，每个节点被称为Broker。\nKafka维护每个主题的分区日志。消息会发布到相应的主题中，每个分区都是一个有序的消息子集。同一个主题的多个分区能够通过集群中的多个Broker传送，这种方法提高了主题的容量与吞吐量，使其超越了单一机器所能提供的容量与吞吐量。消息在分区内被有序排列，每个消息都包含一个特定的偏移量。Kafka中消息可以通过一个包含主题、分区以及偏移量的组合来确定。Producer能够根据消息的主键选择消息应该写入哪一个分区，也能够简单地用循环的方式，让消息分布在各分区之间。\nConsumer会在Consumer组中注册，每个组包括一个或多个Consumer，每个Consumer读取一个或多个主题分区。每组中的每条消息只能传送给一个Consumer。但是，如果多个组订阅了同一个主题，那么每个组都将得到所有的消息。一个组中包含多个Consumer有助于获得加载平衡（可以支持高于单个Consumer处理能力的吞吐量）与高可用性（如果一个Consumer出现错误，它所读取的分区将重新分配给组中其它Consumer）。\n前面提到，对于应用层面的数据分类，主要单位是主题。一个Consumer或Consumer组将读取其订阅主题的所有数据，所以如果一个应用只关注一个数据子集，那么就应该将该数据子集与其他数据放在两个不同的主题中。如果多个信息集总是一起读取和处理，那么应该将它们归在同一个主题中。\n\n#数据导出\n数据导出的思路与导入类似。\n\n\n\n\n\n\n","slug":"hadoop/Apache Spark与Apache Hadoop的关系","published":1,"updated":"2017-08-18T01:44:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bm6009hs77rytufx3f6","content":"<p>数据采集<br>本文主要是讲外部系统与Hadoop之间的数据传递，包括从外部系统采集数据导入到hadoop，以及从Hadoop中提取数据导入外部系统中。</p>\n<p>#数据采集考量<br>虽然Hadoop提出了文件客户端，便于在Hadoop中和Hadoop外复制文件，但是大多数据 Hadoop应用需要从不同来源导入数据，而且对不同的导入频率也提出了要求，Hadoop常用的数据来源包括以下：<br>1.传统数据管理系统，如果关系型数据库与主机<br>2.日志、机器生成的数据，以及其他类型的事件数据。<br>3.从现有的企业数据存储中输入的文件。</p>\n<p>将数据从不同的系统输入Hadoop时需要考虑很多因素。如下：<br>1.数据采集的时效性与可访问性<br>需要采集数据在采集频率方面有哪些要求？下游的处理要求数据多长时间准备完毕？</p>\n<p>2.增量更新<br>如何添加新数据？需要将数据添加到现有数据库吗？需要重写现有数据吗？</p>\n<p>3.数据访问和处理<br>数据会用于处理过程吗？如果会，数据会用于批处理任务吗？需要的数据是不是随机获取的？</p>\n<p>4.数据分区及数据分片<br>数据采集后应该如何分区？需要将数据导入到多个目录系统（如HDFS与HBase）吗？</p>\n<p>5.数据存储格式<br>数据存储的格式是哪一种？</p>\n<p>6.数据变换<br>需要变换尚未落地的数据吗？</p>\n<p>下面简单列举一下这几点考量？</p>\n<p>##1.数据采集的时效性<br>这里的时效性是指可进行数据采集的时间与Hadoop中工具可访问数据的时间之间的间隔。采集架构的时间分类会对存储媒介和采集方法造成很大的影响。一般来说数据采集构架，可以使用以下分类中的一个<br>a.大型批处理<br>通常指15分钟到数据小时的任务，有时可能指时间跨度达到一天的任务</p>\n<p>b.小型批处理<br>通常指大约2分钟发送一次任务，但是总的来说不会超过15分钟</p>\n<p>c.近实时决策支持<br>指接受信息后“立即作出反应”，并在2秒到2分钟内发送数据</p>\n<p>d.近实时事件处理<br>指在2秒内处理任务，速度可达到100毫秒</p>\n<p>e.实时<br>这里指不超过100毫秒</p>\n<p>可以注意到随着实现时间到达实时，实现的复杂度和成本会大大增加。从批处理出发（比如使用简单文件传输）通常是个不错的选择。HDFS对时效性的要求比较宽松，所以可能更加适合成为主要存储位置。而一个简单文件传输或Sqoop任务则适合作为采集数据的工具。比如，执行hadoop fs -put命令将复制一个文件，并进行全面的校验，以确定正确地复制数据。<br>使用hadoop fs -put命令与Sqoop时，你需要明白一点：HDFS上的数据存储格式可能并不适合数据的长期存储和处理。因此，在使用这些工具的时候，可能需要通过额外的批处理操作，以将数据存储为需要的格式。<br>当用户需要从简单的批处理转向更高频率的更新时，就应该考虑Flume或kafka之类的工具了。这里时间要求不起过2分钟，所以Sqoop与文件转换器不适用。而且，因为要求时间不起过2分钟，所以存储层可能需要变成HBase或Solr，这样插入与读取操作会获得更细的粒度。当要求到实时水平时，我们首先需要考虑内存，然后是永久性存储。全世界所有的平行化处理都不会有助于将反应要求控制在500毫秒以内，只要硬盘驱动器保持处理操作的状态。基于这一点，我们开始进入流处理领域，采用Storm或Spark Streaming之类的工具。这里需要强调的是，这些工具应该真正用于大数据处理，而不是像Flume或Sqoop那样用于数据采集。</p>\n<p>##2.增量更新<br>新的数据是要添加到已有数据集中，还是要修改已有数据集。如果仅要求添加数据，那么HDFS对于大部分实现都很适用。HDFS能够并行 化多个驱动器的I/O操作，所以读写性能很高。HDFS的缺点是无法添加或者随机写入创建后的文件。</p>\n<p>#数据采集的选择</p>\n<p>##1.文件传输<br>将数据导入导出到Hadoop最简单的方法就是文件传输，就是hadoop fs -put与hadoop fs -get命令。这有时也是最快的方法，所以在设计Hadoop新的数据处理流水线时，首先应该考虑选择文件传输。</p>\n<p>下面列一下文件传输的特点：<br>a.这是一种all-or-nothing批处理方法，所以如果文件传输过程中出现错误，则不会写入或读取任何数据。这种方法与Flume、Kafka之类的采集方法不同，后者提供一定程度的错误处理功能，并且有传输保障。<br>b.文件传输默认为单线程，不能并行 文件传输。<br>c.文件传输将文件从传统的文件系统导入HDFS<br>d.不支持数据转换，数据按原样导入HDFS。数据导入HDFS后才能进行处理，这一点与传输过程中的数据转换截然相反。类似于Flume的系统支持传输过程中的数据转换。<br>e.这种加载是逐字进行的，所以能传输任何类型的文件（文件、二进制、图书等）</p>\n<p>##文件传输与其他采集方法的考量<br>简单文件传输在某些情况下是适用的，尤其是在需要将已存在 的一系列文件输入到HDFS中，而且可以接受保持源文件格式的情况下。否则，在决定是否可以接受文件传输或者是否使用类似于Flume的工具时，需要考虑以下因素。<br>a.需要将数据采集到多个位置吗？比如，是需要将数据同时输入HDFS和Solr，还是需要将数据同时输入HDFS和HBase？这种情况下，如果使用文件传输，那么在文件采集完成之后将需要额外的工作，因些采用Flume更合适。<br>b.对可靠性的要求高不高？如果高，那么一旦传输时出现错误，文件传输就必须重新开始，这时，Fluem同样是更好的选择。<br>e.数据采集之前需要转换操作吗？如果需要Flume无疑是适合的工具。<br>如果需要采集文件，可以考虑使用Flume Spooling  Directory源。采用这种方法，用户将文件放置到磁盘特定的目录就可以采集文件。这种采集文件的方法简单可靠，而且需要时能够实现传输过程中的数据转换。</p>\n<p>##Sqoop：Hadoop与关系数据库的批量传输<br>Sqoop是一种工具，能批量地将数据从关系型数据管理系统导出到Hadoop中，也能批量地将数据从Hadoop导出至关系型数据库中。</p>\n<p>Flume:基于事件的数据收集及处理<br>Flume是一种分布式的可靠开源系统，用于流数据的高效收集、聚焦和移动。Flume通常用于移动日志数据，但是也能移动大量事件数据，如社交媒体订阅、消息队列事件或网络流量数据。</p>\n<p>##Kafka<br>Apache Kafka是一种发布订单消息的分布式系统，能够将消息归类为不同主题。应用程序能在Kafka上发布信息，或订阅主题进而接受特定主要下发布的消息。Producer发布消息，而Consumer收集并处理消息。作为分布式系统，Kafka在集群中运行，每个节点被称为Broker。<br>Kafka维护每个主题的分区日志。消息会发布到相应的主题中，每个分区都是一个有序的消息子集。同一个主题的多个分区能够通过集群中的多个Broker传送，这种方法提高了主题的容量与吞吐量，使其超越了单一机器所能提供的容量与吞吐量。消息在分区内被有序排列，每个消息都包含一个特定的偏移量。Kafka中消息可以通过一个包含主题、分区以及偏移量的组合来确定。Producer能够根据消息的主键选择消息应该写入哪一个分区，也能够简单地用循环的方式，让消息分布在各分区之间。<br>Consumer会在Consumer组中注册，每个组包括一个或多个Consumer，每个Consumer读取一个或多个主题分区。每组中的每条消息只能传送给一个Consumer。但是，如果多个组订阅了同一个主题，那么每个组都将得到所有的消息。一个组中包含多个Consumer有助于获得加载平衡（可以支持高于单个Consumer处理能力的吞吐量）与高可用性（如果一个Consumer出现错误，它所读取的分区将重新分配给组中其它Consumer）。<br>前面提到，对于应用层面的数据分类，主要单位是主题。一个Consumer或Consumer组将读取其订阅主题的所有数据，所以如果一个应用只关注一个数据子集，那么就应该将该数据子集与其他数据放在两个不同的主题中。如果多个信息集总是一起读取和处理，那么应该将它们归在同一个主题中。</p>\n<p>#数据导出<br>数据导出的思路与导入类似。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>数据采集<br>本文主要是讲外部系统与Hadoop之间的数据传递，包括从外部系统采集数据导入到hadoop，以及从Hadoop中提取数据导入外部系统中。</p>\n<p>#数据采集考量<br>虽然Hadoop提出了文件客户端，便于在Hadoop中和Hadoop外复制文件，但是大多数据 Hadoop应用需要从不同来源导入数据，而且对不同的导入频率也提出了要求，Hadoop常用的数据来源包括以下：<br>1.传统数据管理系统，如果关系型数据库与主机<br>2.日志、机器生成的数据，以及其他类型的事件数据。<br>3.从现有的企业数据存储中输入的文件。</p>\n<p>将数据从不同的系统输入Hadoop时需要考虑很多因素。如下：<br>1.数据采集的时效性与可访问性<br>需要采集数据在采集频率方面有哪些要求？下游的处理要求数据多长时间准备完毕？</p>\n<p>2.增量更新<br>如何添加新数据？需要将数据添加到现有数据库吗？需要重写现有数据吗？</p>\n<p>3.数据访问和处理<br>数据会用于处理过程吗？如果会，数据会用于批处理任务吗？需要的数据是不是随机获取的？</p>\n<p>4.数据分区及数据分片<br>数据采集后应该如何分区？需要将数据导入到多个目录系统（如HDFS与HBase）吗？</p>\n<p>5.数据存储格式<br>数据存储的格式是哪一种？</p>\n<p>6.数据变换<br>需要变换尚未落地的数据吗？</p>\n<p>下面简单列举一下这几点考量？</p>\n<p>##1.数据采集的时效性<br>这里的时效性是指可进行数据采集的时间与Hadoop中工具可访问数据的时间之间的间隔。采集架构的时间分类会对存储媒介和采集方法造成很大的影响。一般来说数据采集构架，可以使用以下分类中的一个<br>a.大型批处理<br>通常指15分钟到数据小时的任务，有时可能指时间跨度达到一天的任务</p>\n<p>b.小型批处理<br>通常指大约2分钟发送一次任务，但是总的来说不会超过15分钟</p>\n<p>c.近实时决策支持<br>指接受信息后“立即作出反应”，并在2秒到2分钟内发送数据</p>\n<p>d.近实时事件处理<br>指在2秒内处理任务，速度可达到100毫秒</p>\n<p>e.实时<br>这里指不超过100毫秒</p>\n<p>可以注意到随着实现时间到达实时，实现的复杂度和成本会大大增加。从批处理出发（比如使用简单文件传输）通常是个不错的选择。HDFS对时效性的要求比较宽松，所以可能更加适合成为主要存储位置。而一个简单文件传输或Sqoop任务则适合作为采集数据的工具。比如，执行hadoop fs -put命令将复制一个文件，并进行全面的校验，以确定正确地复制数据。<br>使用hadoop fs -put命令与Sqoop时，你需要明白一点：HDFS上的数据存储格式可能并不适合数据的长期存储和处理。因此，在使用这些工具的时候，可能需要通过额外的批处理操作，以将数据存储为需要的格式。<br>当用户需要从简单的批处理转向更高频率的更新时，就应该考虑Flume或kafka之类的工具了。这里时间要求不起过2分钟，所以Sqoop与文件转换器不适用。而且，因为要求时间不起过2分钟，所以存储层可能需要变成HBase或Solr，这样插入与读取操作会获得更细的粒度。当要求到实时水平时，我们首先需要考虑内存，然后是永久性存储。全世界所有的平行化处理都不会有助于将反应要求控制在500毫秒以内，只要硬盘驱动器保持处理操作的状态。基于这一点，我们开始进入流处理领域，采用Storm或Spark Streaming之类的工具。这里需要强调的是，这些工具应该真正用于大数据处理，而不是像Flume或Sqoop那样用于数据采集。</p>\n<p>##2.增量更新<br>新的数据是要添加到已有数据集中，还是要修改已有数据集。如果仅要求添加数据，那么HDFS对于大部分实现都很适用。HDFS能够并行 化多个驱动器的I/O操作，所以读写性能很高。HDFS的缺点是无法添加或者随机写入创建后的文件。</p>\n<p>#数据采集的选择</p>\n<p>##1.文件传输<br>将数据导入导出到Hadoop最简单的方法就是文件传输，就是hadoop fs -put与hadoop fs -get命令。这有时也是最快的方法，所以在设计Hadoop新的数据处理流水线时，首先应该考虑选择文件传输。</p>\n<p>下面列一下文件传输的特点：<br>a.这是一种all-or-nothing批处理方法，所以如果文件传输过程中出现错误，则不会写入或读取任何数据。这种方法与Flume、Kafka之类的采集方法不同，后者提供一定程度的错误处理功能，并且有传输保障。<br>b.文件传输默认为单线程，不能并行 文件传输。<br>c.文件传输将文件从传统的文件系统导入HDFS<br>d.不支持数据转换，数据按原样导入HDFS。数据导入HDFS后才能进行处理，这一点与传输过程中的数据转换截然相反。类似于Flume的系统支持传输过程中的数据转换。<br>e.这种加载是逐字进行的，所以能传输任何类型的文件（文件、二进制、图书等）</p>\n<p>##文件传输与其他采集方法的考量<br>简单文件传输在某些情况下是适用的，尤其是在需要将已存在 的一系列文件输入到HDFS中，而且可以接受保持源文件格式的情况下。否则，在决定是否可以接受文件传输或者是否使用类似于Flume的工具时，需要考虑以下因素。<br>a.需要将数据采集到多个位置吗？比如，是需要将数据同时输入HDFS和Solr，还是需要将数据同时输入HDFS和HBase？这种情况下，如果使用文件传输，那么在文件采集完成之后将需要额外的工作，因些采用Flume更合适。<br>b.对可靠性的要求高不高？如果高，那么一旦传输时出现错误，文件传输就必须重新开始，这时，Fluem同样是更好的选择。<br>e.数据采集之前需要转换操作吗？如果需要Flume无疑是适合的工具。<br>如果需要采集文件，可以考虑使用Flume Spooling  Directory源。采用这种方法，用户将文件放置到磁盘特定的目录就可以采集文件。这种采集文件的方法简单可靠，而且需要时能够实现传输过程中的数据转换。</p>\n<p>##Sqoop：Hadoop与关系数据库的批量传输<br>Sqoop是一种工具，能批量地将数据从关系型数据管理系统导出到Hadoop中，也能批量地将数据从Hadoop导出至关系型数据库中。</p>\n<p>Flume:基于事件的数据收集及处理<br>Flume是一种分布式的可靠开源系统，用于流数据的高效收集、聚焦和移动。Flume通常用于移动日志数据，但是也能移动大量事件数据，如社交媒体订阅、消息队列事件或网络流量数据。</p>\n<p>##Kafka<br>Apache Kafka是一种发布订单消息的分布式系统，能够将消息归类为不同主题。应用程序能在Kafka上发布信息，或订阅主题进而接受特定主要下发布的消息。Producer发布消息，而Consumer收集并处理消息。作为分布式系统，Kafka在集群中运行，每个节点被称为Broker。<br>Kafka维护每个主题的分区日志。消息会发布到相应的主题中，每个分区都是一个有序的消息子集。同一个主题的多个分区能够通过集群中的多个Broker传送，这种方法提高了主题的容量与吞吐量，使其超越了单一机器所能提供的容量与吞吐量。消息在分区内被有序排列，每个消息都包含一个特定的偏移量。Kafka中消息可以通过一个包含主题、分区以及偏移量的组合来确定。Producer能够根据消息的主键选择消息应该写入哪一个分区，也能够简单地用循环的方式，让消息分布在各分区之间。<br>Consumer会在Consumer组中注册，每个组包括一个或多个Consumer，每个Consumer读取一个或多个主题分区。每组中的每条消息只能传送给一个Consumer。但是，如果多个组订阅了同一个主题，那么每个组都将得到所有的消息。一个组中包含多个Consumer有助于获得加载平衡（可以支持高于单个Consumer处理能力的吞吐量）与高可用性（如果一个Consumer出现错误，它所读取的分区将重新分配给组中其它Consumer）。<br>前面提到，对于应用层面的数据分类，主要单位是主题。一个Consumer或Consumer组将读取其订阅主题的所有数据，所以如果一个应用只关注一个数据子集，那么就应该将该数据子集与其他数据放在两个不同的主题中。如果多个信息集总是一起读取和处理，那么应该将它们归在同一个主题中。</p>\n<p>#数据导出<br>数据导出的思路与导入类似。</p>\n"},{"title":"分布式计算","date":"2017-04-16T15:43:49.000Z","_content":"#MapRecue\n在过去的20年里，互联网产生了大量的数据，比如爬虫文档、Web讲求日志等；也包括了计算各种类型的派生数据，比如，倒排索引、Web文档的图结构的各种表示、每台主机页面数量概要、每天被请求数量最多的集合，等等。很多这样的计算在概念上很容易理解的。然而，当输入的数据量很大时，这些计算必须要被分割到成百上千的机器上才有可能在可以接受的时间内完成。怎样来实现并行计算？如何分发数据？如何进行错误处理？所有这些问题综合在一起，使得原来很简洁的计算，因为要大量的复杂代码来处理这些问题，而变得让人难以处理。 Google公司为了应对大数据的处理，内部已经实现了数据以百计的为专门目的而写的计算程序，其中MapRecue就是其著名的计算框架之王，与GFS、Bigtable一起被称为Google技术的“三宝”。 \n\n##MapRecue简介 \nMapRecue是一个编程模型，用于大规模数据集（TB级）的并行运算。有关MapRecue的论文介绍，最早可以追溯到由Google的Jeffrey Dean和Sanjay Ghemawat发表在2004年OSDI（USENIX Symposium on Operationg Systems Design and Implementation）的《MapRecue：Simplified Data Processing on LargeClusters》。这篇文章描述了Google如何分割、处理、整合他们令人难以置信的大数据集。读者有兴趣可以在线阅读该论文https://www.usenix.org/legacy/events/osdi04/tech/full_papers/dean/dean.pdf。 随后，开源软件先驱Doug Cutting等人受到该论文的启发，开始尝试实现MapRecue计算框架，并将它与NDFS（Nutch Distributed File System）结合，用以支持Nutch引擎的主要算法。由于NDFS与MapRecue在Nutch引擎中有着良好的应用，所以它们于2006年2月被分离出来，成为一套完整而独立的软件，并命名为Hadoop。 MapRecue程序模型应用成功要归功于以下几个方面。首先，由于该模型隐藏了并行、容错、本地优化以及负载平衡的细节，所以即便是那些没有并行和分布式系统经验的程序员也易于使用该模型。其次MapRecue计算可以很容易地表达大数据的各种问题。比如，MapRecue用于为Google的网页搜索服务生成数据，用于排序，用于数据挖掘，用于机器学习以及其他许多系统。再次，MapRecue的实现符合“由数千机器组成的大集群”的尺度，有效地利用了机器资源，所以非常适合解决大型计算问题。 \n\n##MapRecue的编程模型\nMapRecue是一个用于大规模数据集（TB级）并行运算的编程模型，其基本原理就是将大的数据分成小块逐个分析，最后再将提取出来的数据汇总分析，最终获得我们想要的内容。从名字可以看出，“Map(映射)”和“Reduce（归纳）”是MapRecue模型的核心，其灵感来源于函数式语言（比如Lisp）中的内置函数map和reduce：用户通过定义一个Map函数，处理key/value（键值对）以生成一个中间key/value集合，MapRecue库将所有拥有相同的key(key I)的中间状态key合并起来传递到Redure职数；一个叫作Reduce的函数用以合并所有先前Map过后的有相同key（Key I）的中间量。map(k1,v1) -> list<k2,v2)reduce(k2,list(v2)) -> list(k3,v3)但上面的定义显然还是过于抽象。现实世界中的许多任务在这个模型中得到了很好的表达。Shekhar Gulati就在他的博客里《How I explained MapReduce to my Wife?》举了一个辣椒酱制作过程的例子，来形象地描述MapRecue的原理，如下所述。1.MapRecue制作辣椒酱的过程辣椒酱制作的过程是这样的，先取一个洋葱，把它切碎，然后拌入盐和水，最后放进混合研磨机研磨。这样就能得到洋葱辣椒酱了。 现在，假设你想用薄荷、洋葱、番茄、辣椒、大蒜弄一瓶混合辣椒酱。你会怎么做呢？你会取薄荷叶一撮，洋葱一个，番茄一个，辣椒一根，大蒜一根，切碎后加入适量的盐和水，再放入混合研磨机里研磨，这样你就可以得到一瓶混合辣椒酱了。 现在把MapRecue的概念应用到食谱上，Map和Reduce其实就是两种操作。 Map：把洋葱、番茄、辣椒和大蒜切磋，是各自作用在这些物体上的一个Map操作。所以你给Map一个洋葱，Map就会把洋葱切碎。同样地，你把辣椒、大蒜和番茄一一地拿给Map，你也会得到各种碎块。所以，当你在切像洋葱这样的蔬菜时，你执行的就是一个Map操作。Map操作适用于每一种蔬菜，它会相应地生产出一种或多种碎块，在我们的例子中生产的是蔬菜块。在Map操作中可能会出现有个洋葱坏掉了的情况，你只要把洋葱丢了就行了。所以，如果出现坏洋葱了，Map操作就会过滤掉这个坏洋葱而不会生产出任何的坏洋葱块。 Reduce：在这一阶段，你将各种蔬菜都放入研磨机时在进行研磨，你就可以得到一瓶辣椒酱了。这意味要制成一瓶辣椒酱，你得研磨所有的原料。因此，研磨机通常将Map操作的蔬菜聚焦在了一起。 当然上面内容只是MapRecue的一部分，MapRecue的强大在于分布式计算。假设你每天需要生产10000瓶辣椒酱，你会怎么办？这个时候你就不得不雇佣更多的人和研磨机来完成这项工作了，你需要几个人一起切蔬菜。每个人都要处理满满一袋子的蔬菜，而每一个人都相当于在执行一个简单的Map操作。每一个人都将不断地从袋子里拿出蔬菜来，并且每次只对一种蔬菜进行处理，也就是将它们切碎，直到袋子空了为止。这样，当所有的工人都切完以后，工作台（每个人工作的地方）上就有了洋葱块、番茄块和蒜蓉，等等。 MapRecue将所有输出的蔬菜都搅拌在了一起，这些蔬菜都在以key为基础的Map操作下产生的。搅拌将自动完成，你可以假设key是一种原料的名字，你像洋葱一样。所以全部的洋葱key都搅拌在一起，并转移到研磨洋葱的研磨器里。这样，你就能得到洋葱辣椒酱了。同样地，所有的番茄也会被转移地标记着番茄的研磨器里，并制造出番茄辣椒酱。 \n\n\n\n#Apache Hadoop\nApache Hadoop是一个由Apache基金会开发的分布式系统基础架构，它可以让用户在不了解分布式底层细节的情况下，开发出可靠、可扩展的分布式计算应用。\nApache Hadoop框架允许用户使用简单的编程模型来实现计算机集群的大型数据集的分布式处理。它的目的是支持从单一服务器到上千台机器的扩展，充分利用了每台机器所提供本地计算和存储，而不是依靠硬件来提高高可用性。其本身被设计成在应用层检测和处理故障的库，对于计算机集群来说，其中每台机器的顶层都被设计成可以容错的，以便提供一个高可用的服务。\nApache Hadoop的框架最核心的设计就是HDFS和MapRecue。HDFS为海量的数据提供了存储，而MapRecue则为海量的数据提供了计算。\n\n##Apache Hadoop核心组件\nApache Hadoop包含以下模块：\nHadoop Common---常见实用工具，用来支持其他hadoop模块。\nHadoop Distributed File System（HDFS）---分布式文件系统，它提供对应用程序数据的高吞吐量访问\nHadoop YARN----一个作业调度和集群资源管理框架\nHadoop MapRecue--基于YARN的大型数据集的并行处理系统\n\n###其它Apache Hadoop 相关的项目包括：\nAmbari----一个基于Web的工具，用于配置、管理和监控的Apache Hadoop 集群，其中包括支持Hadoop  HDFS、Hadoop  MapRecue、Hive、HCatalog、HBase、ZooKeeperOozie、Pig和Sqoop。Ambari还提供了仪表盘用于查看集群的健康，如热图，并能够以用户友好的方式来查看MapRecue、Pig和Hive应用，方便诊断其性能。\nAvro--数据序列化系统\nCassandra--可扩展的、无单点故障的多主数据库\nChukwa--数据采集系统，用于管理大型分布式系统。\nHbase--一个可扩展的分布式数据库，支持结构化数据的大表存储\nHive--数据仓库基础设施，提供数据汇总以及特定的查询\nMahout---一种可扩展的机器学习和数据挖掘库\nPig--一个高层次的数据流并行计算语言和执行框架\nSpark---Hadoop数据的快速和通用计算引擎。Spark提供了简单和强大的编程模型用于支持广泛的应用，其中包括ETL、机器学习、流处理和图形处理。\nTEZ--通用的数据流编程框架，建立在Hadoop YARN之上。它提供了一个强大而灵活的引擎来执行任意DAG任务，以实现批量和交互式数据的处理。TEZ正在被Hive、Pig和Hadoop生态系统中的其他框架所采用，也可以通过其他商业软件（例如，ETL工具），以取代hadoop mapreduce作为底层执行引擎。\nZooKeeper--一个高性能的分布式应用程序协调服务。\n\n\n##Apache Spark\nSpark是一个快速和通用的集群计算系统。特别：\n1. 快速 Spack具有支持循环数据流和内存计算的先进的DAG执行引擎，所以比Hadoop MapRecue在内存计算上快100倍，在硬盘计算上快10倍。\n2. 易于使用 Spark提供了Java，Scala，Python和R等语言的高级API，可以用于快速开发相关语言应用。Spark提供了超过80个高级的操作，可以轻松构建并行应用程序。\n3. 全面 Spark提供了Spark SQL，机器学习的MLlib，进行图形处理的GraphX，以及Spark Streaming等库。你可以在同一应用程序无缝地合并这些库。\n4. 到处运行 可以standalone cluster mode运行EC2、Hadoop YARN、或者Apache Mesos中。可以访问HDFS、Cassandra、HBase、Hive、Tachyon，以及任意的Hadoop数据源。\n\n\n\n##Apache Mesos\n在传统上，物理机和虚拟机是数据中心的典型的计算单元。当应用部署后，这些机器需要安装各种配置工具来管理这些应用。机器通常被组织成集群，提供独立的服务，而系统管理员则监督其日常的日常动作。当这些集群达到其最大容量时，需要多机联网来处理负载，这就是集群的扩展带来了挑战。\n在2010年，UC Berkeley大学就对上述问题提出了解决方案，这就是现在的Apache Mesos，Mesos抽象了CPU、内存、硬盘资源，让数据中心的功能对外就像是一个大的机器。Mesos创建一个单独的底层集群来提供应用程序所需要的资源，而不会超出虚拟机和操作系统性能限制。\n\n###Apache Mesos简介\nMesos是Apache下的开源分布式资源管理框架，它被称为分布式系统的内核，使用内置Linux内核相同的原理，只是在不同的抽象层次。该 Mesos内核运行在每个机器上，在整个数据中心和云环境内应用程序（例如Hadoop、Spark、Kafka、Elaborate等）提供资源管理和资源负载的API接口。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/hadoop/Hadoop之分布式计算 .md","raw":"---\ntitle: 分布式计算 \ndate: 2017-04-16 23:43:49\ntags: [分布式,分布式计算]\ncategories: [分布式,分布式计算]\n---\n#MapRecue\n在过去的20年里，互联网产生了大量的数据，比如爬虫文档、Web讲求日志等；也包括了计算各种类型的派生数据，比如，倒排索引、Web文档的图结构的各种表示、每台主机页面数量概要、每天被请求数量最多的集合，等等。很多这样的计算在概念上很容易理解的。然而，当输入的数据量很大时，这些计算必须要被分割到成百上千的机器上才有可能在可以接受的时间内完成。怎样来实现并行计算？如何分发数据？如何进行错误处理？所有这些问题综合在一起，使得原来很简洁的计算，因为要大量的复杂代码来处理这些问题，而变得让人难以处理。 Google公司为了应对大数据的处理，内部已经实现了数据以百计的为专门目的而写的计算程序，其中MapRecue就是其著名的计算框架之王，与GFS、Bigtable一起被称为Google技术的“三宝”。 \n\n##MapRecue简介 \nMapRecue是一个编程模型，用于大规模数据集（TB级）的并行运算。有关MapRecue的论文介绍，最早可以追溯到由Google的Jeffrey Dean和Sanjay Ghemawat发表在2004年OSDI（USENIX Symposium on Operationg Systems Design and Implementation）的《MapRecue：Simplified Data Processing on LargeClusters》。这篇文章描述了Google如何分割、处理、整合他们令人难以置信的大数据集。读者有兴趣可以在线阅读该论文https://www.usenix.org/legacy/events/osdi04/tech/full_papers/dean/dean.pdf。 随后，开源软件先驱Doug Cutting等人受到该论文的启发，开始尝试实现MapRecue计算框架，并将它与NDFS（Nutch Distributed File System）结合，用以支持Nutch引擎的主要算法。由于NDFS与MapRecue在Nutch引擎中有着良好的应用，所以它们于2006年2月被分离出来，成为一套完整而独立的软件，并命名为Hadoop。 MapRecue程序模型应用成功要归功于以下几个方面。首先，由于该模型隐藏了并行、容错、本地优化以及负载平衡的细节，所以即便是那些没有并行和分布式系统经验的程序员也易于使用该模型。其次MapRecue计算可以很容易地表达大数据的各种问题。比如，MapRecue用于为Google的网页搜索服务生成数据，用于排序，用于数据挖掘，用于机器学习以及其他许多系统。再次，MapRecue的实现符合“由数千机器组成的大集群”的尺度，有效地利用了机器资源，所以非常适合解决大型计算问题。 \n\n##MapRecue的编程模型\nMapRecue是一个用于大规模数据集（TB级）并行运算的编程模型，其基本原理就是将大的数据分成小块逐个分析，最后再将提取出来的数据汇总分析，最终获得我们想要的内容。从名字可以看出，“Map(映射)”和“Reduce（归纳）”是MapRecue模型的核心，其灵感来源于函数式语言（比如Lisp）中的内置函数map和reduce：用户通过定义一个Map函数，处理key/value（键值对）以生成一个中间key/value集合，MapRecue库将所有拥有相同的key(key I)的中间状态key合并起来传递到Redure职数；一个叫作Reduce的函数用以合并所有先前Map过后的有相同key（Key I）的中间量。map(k1,v1) -> list<k2,v2)reduce(k2,list(v2)) -> list(k3,v3)但上面的定义显然还是过于抽象。现实世界中的许多任务在这个模型中得到了很好的表达。Shekhar Gulati就在他的博客里《How I explained MapReduce to my Wife?》举了一个辣椒酱制作过程的例子，来形象地描述MapRecue的原理，如下所述。1.MapRecue制作辣椒酱的过程辣椒酱制作的过程是这样的，先取一个洋葱，把它切碎，然后拌入盐和水，最后放进混合研磨机研磨。这样就能得到洋葱辣椒酱了。 现在，假设你想用薄荷、洋葱、番茄、辣椒、大蒜弄一瓶混合辣椒酱。你会怎么做呢？你会取薄荷叶一撮，洋葱一个，番茄一个，辣椒一根，大蒜一根，切碎后加入适量的盐和水，再放入混合研磨机里研磨，这样你就可以得到一瓶混合辣椒酱了。 现在把MapRecue的概念应用到食谱上，Map和Reduce其实就是两种操作。 Map：把洋葱、番茄、辣椒和大蒜切磋，是各自作用在这些物体上的一个Map操作。所以你给Map一个洋葱，Map就会把洋葱切碎。同样地，你把辣椒、大蒜和番茄一一地拿给Map，你也会得到各种碎块。所以，当你在切像洋葱这样的蔬菜时，你执行的就是一个Map操作。Map操作适用于每一种蔬菜，它会相应地生产出一种或多种碎块，在我们的例子中生产的是蔬菜块。在Map操作中可能会出现有个洋葱坏掉了的情况，你只要把洋葱丢了就行了。所以，如果出现坏洋葱了，Map操作就会过滤掉这个坏洋葱而不会生产出任何的坏洋葱块。 Reduce：在这一阶段，你将各种蔬菜都放入研磨机时在进行研磨，你就可以得到一瓶辣椒酱了。这意味要制成一瓶辣椒酱，你得研磨所有的原料。因此，研磨机通常将Map操作的蔬菜聚焦在了一起。 当然上面内容只是MapRecue的一部分，MapRecue的强大在于分布式计算。假设你每天需要生产10000瓶辣椒酱，你会怎么办？这个时候你就不得不雇佣更多的人和研磨机来完成这项工作了，你需要几个人一起切蔬菜。每个人都要处理满满一袋子的蔬菜，而每一个人都相当于在执行一个简单的Map操作。每一个人都将不断地从袋子里拿出蔬菜来，并且每次只对一种蔬菜进行处理，也就是将它们切碎，直到袋子空了为止。这样，当所有的工人都切完以后，工作台（每个人工作的地方）上就有了洋葱块、番茄块和蒜蓉，等等。 MapRecue将所有输出的蔬菜都搅拌在了一起，这些蔬菜都在以key为基础的Map操作下产生的。搅拌将自动完成，你可以假设key是一种原料的名字，你像洋葱一样。所以全部的洋葱key都搅拌在一起，并转移到研磨洋葱的研磨器里。这样，你就能得到洋葱辣椒酱了。同样地，所有的番茄也会被转移地标记着番茄的研磨器里，并制造出番茄辣椒酱。 \n\n\n\n#Apache Hadoop\nApache Hadoop是一个由Apache基金会开发的分布式系统基础架构，它可以让用户在不了解分布式底层细节的情况下，开发出可靠、可扩展的分布式计算应用。\nApache Hadoop框架允许用户使用简单的编程模型来实现计算机集群的大型数据集的分布式处理。它的目的是支持从单一服务器到上千台机器的扩展，充分利用了每台机器所提供本地计算和存储，而不是依靠硬件来提高高可用性。其本身被设计成在应用层检测和处理故障的库，对于计算机集群来说，其中每台机器的顶层都被设计成可以容错的，以便提供一个高可用的服务。\nApache Hadoop的框架最核心的设计就是HDFS和MapRecue。HDFS为海量的数据提供了存储，而MapRecue则为海量的数据提供了计算。\n\n##Apache Hadoop核心组件\nApache Hadoop包含以下模块：\nHadoop Common---常见实用工具，用来支持其他hadoop模块。\nHadoop Distributed File System（HDFS）---分布式文件系统，它提供对应用程序数据的高吞吐量访问\nHadoop YARN----一个作业调度和集群资源管理框架\nHadoop MapRecue--基于YARN的大型数据集的并行处理系统\n\n###其它Apache Hadoop 相关的项目包括：\nAmbari----一个基于Web的工具，用于配置、管理和监控的Apache Hadoop 集群，其中包括支持Hadoop  HDFS、Hadoop  MapRecue、Hive、HCatalog、HBase、ZooKeeperOozie、Pig和Sqoop。Ambari还提供了仪表盘用于查看集群的健康，如热图，并能够以用户友好的方式来查看MapRecue、Pig和Hive应用，方便诊断其性能。\nAvro--数据序列化系统\nCassandra--可扩展的、无单点故障的多主数据库\nChukwa--数据采集系统，用于管理大型分布式系统。\nHbase--一个可扩展的分布式数据库，支持结构化数据的大表存储\nHive--数据仓库基础设施，提供数据汇总以及特定的查询\nMahout---一种可扩展的机器学习和数据挖掘库\nPig--一个高层次的数据流并行计算语言和执行框架\nSpark---Hadoop数据的快速和通用计算引擎。Spark提供了简单和强大的编程模型用于支持广泛的应用，其中包括ETL、机器学习、流处理和图形处理。\nTEZ--通用的数据流编程框架，建立在Hadoop YARN之上。它提供了一个强大而灵活的引擎来执行任意DAG任务，以实现批量和交互式数据的处理。TEZ正在被Hive、Pig和Hadoop生态系统中的其他框架所采用，也可以通过其他商业软件（例如，ETL工具），以取代hadoop mapreduce作为底层执行引擎。\nZooKeeper--一个高性能的分布式应用程序协调服务。\n\n\n##Apache Spark\nSpark是一个快速和通用的集群计算系统。特别：\n1. 快速 Spack具有支持循环数据流和内存计算的先进的DAG执行引擎，所以比Hadoop MapRecue在内存计算上快100倍，在硬盘计算上快10倍。\n2. 易于使用 Spark提供了Java，Scala，Python和R等语言的高级API，可以用于快速开发相关语言应用。Spark提供了超过80个高级的操作，可以轻松构建并行应用程序。\n3. 全面 Spark提供了Spark SQL，机器学习的MLlib，进行图形处理的GraphX，以及Spark Streaming等库。你可以在同一应用程序无缝地合并这些库。\n4. 到处运行 可以standalone cluster mode运行EC2、Hadoop YARN、或者Apache Mesos中。可以访问HDFS、Cassandra、HBase、Hive、Tachyon，以及任意的Hadoop数据源。\n\n\n\n##Apache Mesos\n在传统上，物理机和虚拟机是数据中心的典型的计算单元。当应用部署后，这些机器需要安装各种配置工具来管理这些应用。机器通常被组织成集群，提供独立的服务，而系统管理员则监督其日常的日常动作。当这些集群达到其最大容量时，需要多机联网来处理负载，这就是集群的扩展带来了挑战。\n在2010年，UC Berkeley大学就对上述问题提出了解决方案，这就是现在的Apache Mesos，Mesos抽象了CPU、内存、硬盘资源，让数据中心的功能对外就像是一个大的机器。Mesos创建一个单独的底层集群来提供应用程序所需要的资源，而不会超出虚拟机和操作系统性能限制。\n\n###Apache Mesos简介\nMesos是Apache下的开源分布式资源管理框架，它被称为分布式系统的内核，使用内置Linux内核相同的原理，只是在不同的抽象层次。该 Mesos内核运行在每个机器上，在整个数据中心和云环境内应用程序（例如Hadoop、Spark、Kafka、Elaborate等）提供资源管理和资源负载的API接口。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"hadoop/Hadoop之分布式计算 ","published":1,"updated":"2017-08-18T01:44:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bma009is77r040esuhr","content":"<p>#MapRecue<br>在过去的20年里，互联网产生了大量的数据，比如爬虫文档、Web讲求日志等；也包括了计算各种类型的派生数据，比如，倒排索引、Web文档的图结构的各种表示、每台主机页面数量概要、每天被请求数量最多的集合，等等。很多这样的计算在概念上很容易理解的。然而，当输入的数据量很大时，这些计算必须要被分割到成百上千的机器上才有可能在可以接受的时间内完成。怎样来实现并行计算？如何分发数据？如何进行错误处理？所有这些问题综合在一起，使得原来很简洁的计算，因为要大量的复杂代码来处理这些问题，而变得让人难以处理。 Google公司为了应对大数据的处理，内部已经实现了数据以百计的为专门目的而写的计算程序，其中MapRecue就是其著名的计算框架之王，与GFS、Bigtable一起被称为Google技术的“三宝”。 </p>\n<p>##MapRecue简介<br>MapRecue是一个编程模型，用于大规模数据集（TB级）的并行运算。有关MapRecue的论文介绍，最早可以追溯到由Google的Jeffrey Dean和Sanjay Ghemawat发表在2004年OSDI（USENIX Symposium on Operationg Systems Design and Implementation）的《MapRecue：Simplified Data Processing on LargeClusters》。这篇文章描述了Google如何分割、处理、整合他们令人难以置信的大数据集。读者有兴趣可以在线阅读该论文<a href=\"https://www.usenix.org/legacy/events/osdi04/tech/full_papers/dean/dean.pdf。\" target=\"_blank\" rel=\"noopener\">https://www.usenix.org/legacy/events/osdi04/tech/full_papers/dean/dean.pdf。</a> 随后，开源软件先驱Doug Cutting等人受到该论文的启发，开始尝试实现MapRecue计算框架，并将它与NDFS（Nutch Distributed File System）结合，用以支持Nutch引擎的主要算法。由于NDFS与MapRecue在Nutch引擎中有着良好的应用，所以它们于2006年2月被分离出来，成为一套完整而独立的软件，并命名为Hadoop。 MapRecue程序模型应用成功要归功于以下几个方面。首先，由于该模型隐藏了并行、容错、本地优化以及负载平衡的细节，所以即便是那些没有并行和分布式系统经验的程序员也易于使用该模型。其次MapRecue计算可以很容易地表达大数据的各种问题。比如，MapRecue用于为Google的网页搜索服务生成数据，用于排序，用于数据挖掘，用于机器学习以及其他许多系统。再次，MapRecue的实现符合“由数千机器组成的大集群”的尺度，有效地利用了机器资源，所以非常适合解决大型计算问题。 </p>\n<p>##MapRecue的编程模型<br>MapRecue是一个用于大规模数据集（TB级）并行运算的编程模型，其基本原理就是将大的数据分成小块逐个分析，最后再将提取出来的数据汇总分析，最终获得我们想要的内容。从名字可以看出，“Map(映射)”和“Reduce（归纳）”是MapRecue模型的核心，其灵感来源于函数式语言（比如Lisp）中的内置函数map和reduce：用户通过定义一个Map函数，处理key/value（键值对）以生成一个中间key/value集合，MapRecue库将所有拥有相同的key(key I)的中间状态key合并起来传递到Redure职数；一个叫作Reduce的函数用以合并所有先前Map过后的有相同key（Key I）的中间量。map(k1,v1) -&gt; list&lt;k2,v2)reduce(k2,list(v2)) -&gt; list(k3,v3)但上面的定义显然还是过于抽象。现实世界中的许多任务在这个模型中得到了很好的表达。Shekhar Gulati就在他的博客里《How I explained MapReduce to my Wife?》举了一个辣椒酱制作过程的例子，来形象地描述MapRecue的原理，如下所述。1.MapRecue制作辣椒酱的过程辣椒酱制作的过程是这样的，先取一个洋葱，把它切碎，然后拌入盐和水，最后放进混合研磨机研磨。这样就能得到洋葱辣椒酱了。 现在，假设你想用薄荷、洋葱、番茄、辣椒、大蒜弄一瓶混合辣椒酱。你会怎么做呢？你会取薄荷叶一撮，洋葱一个，番茄一个，辣椒一根，大蒜一根，切碎后加入适量的盐和水，再放入混合研磨机里研磨，这样你就可以得到一瓶混合辣椒酱了。 现在把MapRecue的概念应用到食谱上，Map和Reduce其实就是两种操作。 Map：把洋葱、番茄、辣椒和大蒜切磋，是各自作用在这些物体上的一个Map操作。所以你给Map一个洋葱，Map就会把洋葱切碎。同样地，你把辣椒、大蒜和番茄一一地拿给Map，你也会得到各种碎块。所以，当你在切像洋葱这样的蔬菜时，你执行的就是一个Map操作。Map操作适用于每一种蔬菜，它会相应地生产出一种或多种碎块，在我们的例子中生产的是蔬菜块。在Map操作中可能会出现有个洋葱坏掉了的情况，你只要把洋葱丢了就行了。所以，如果出现坏洋葱了，Map操作就会过滤掉这个坏洋葱而不会生产出任何的坏洋葱块。 Reduce：在这一阶段，你将各种蔬菜都放入研磨机时在进行研磨，你就可以得到一瓶辣椒酱了。这意味要制成一瓶辣椒酱，你得研磨所有的原料。因此，研磨机通常将Map操作的蔬菜聚焦在了一起。 当然上面内容只是MapRecue的一部分，MapRecue的强大在于分布式计算。假设你每天需要生产10000瓶辣椒酱，你会怎么办？这个时候你就不得不雇佣更多的人和研磨机来完成这项工作了，你需要几个人一起切蔬菜。每个人都要处理满满一袋子的蔬菜，而每一个人都相当于在执行一个简单的Map操作。每一个人都将不断地从袋子里拿出蔬菜来，并且每次只对一种蔬菜进行处理，也就是将它们切碎，直到袋子空了为止。这样，当所有的工人都切完以后，工作台（每个人工作的地方）上就有了洋葱块、番茄块和蒜蓉，等等。 MapRecue将所有输出的蔬菜都搅拌在了一起，这些蔬菜都在以key为基础的Map操作下产生的。搅拌将自动完成，你可以假设key是一种原料的名字，你像洋葱一样。所以全部的洋葱key都搅拌在一起，并转移到研磨洋葱的研磨器里。这样，你就能得到洋葱辣椒酱了。同样地，所有的番茄也会被转移地标记着番茄的研磨器里，并制造出番茄辣椒酱。 </p>\n<p>#Apache Hadoop<br>Apache Hadoop是一个由Apache基金会开发的分布式系统基础架构，它可以让用户在不了解分布式底层细节的情况下，开发出可靠、可扩展的分布式计算应用。<br>Apache Hadoop框架允许用户使用简单的编程模型来实现计算机集群的大型数据集的分布式处理。它的目的是支持从单一服务器到上千台机器的扩展，充分利用了每台机器所提供本地计算和存储，而不是依靠硬件来提高高可用性。其本身被设计成在应用层检测和处理故障的库，对于计算机集群来说，其中每台机器的顶层都被设计成可以容错的，以便提供一个高可用的服务。<br>Apache Hadoop的框架最核心的设计就是HDFS和MapRecue。HDFS为海量的数据提供了存储，而MapRecue则为海量的数据提供了计算。</p>\n<p>##Apache Hadoop核心组件<br>Apache Hadoop包含以下模块：<br>Hadoop Common—常见实用工具，用来支持其他hadoop模块。<br>Hadoop Distributed File System（HDFS）—分布式文件系统，它提供对应用程序数据的高吞吐量访问<br>Hadoop YARN—-一个作业调度和集群资源管理框架<br>Hadoop MapRecue–基于YARN的大型数据集的并行处理系统</p>\n<p>###其它Apache Hadoop 相关的项目包括：<br>Ambari—-一个基于Web的工具，用于配置、管理和监控的Apache Hadoop 集群，其中包括支持Hadoop  HDFS、Hadoop  MapRecue、Hive、HCatalog、HBase、ZooKeeperOozie、Pig和Sqoop。Ambari还提供了仪表盘用于查看集群的健康，如热图，并能够以用户友好的方式来查看MapRecue、Pig和Hive应用，方便诊断其性能。<br>Avro–数据序列化系统<br>Cassandra–可扩展的、无单点故障的多主数据库<br>Chukwa–数据采集系统，用于管理大型分布式系统。<br>Hbase–一个可扩展的分布式数据库，支持结构化数据的大表存储<br>Hive–数据仓库基础设施，提供数据汇总以及特定的查询<br>Mahout—一种可扩展的机器学习和数据挖掘库<br>Pig–一个高层次的数据流并行计算语言和执行框架<br>Spark—Hadoop数据的快速和通用计算引擎。Spark提供了简单和强大的编程模型用于支持广泛的应用，其中包括ETL、机器学习、流处理和图形处理。<br>TEZ–通用的数据流编程框架，建立在Hadoop YARN之上。它提供了一个强大而灵活的引擎来执行任意DAG任务，以实现批量和交互式数据的处理。TEZ正在被Hive、Pig和Hadoop生态系统中的其他框架所采用，也可以通过其他商业软件（例如，ETL工具），以取代hadoop mapreduce作为底层执行引擎。<br>ZooKeeper–一个高性能的分布式应用程序协调服务。</p>\n<p>##Apache Spark<br>Spark是一个快速和通用的集群计算系统。特别：</p>\n<ol>\n<li>快速 Spack具有支持循环数据流和内存计算的先进的DAG执行引擎，所以比Hadoop MapRecue在内存计算上快100倍，在硬盘计算上快10倍。</li>\n<li>易于使用 Spark提供了Java，Scala，Python和R等语言的高级API，可以用于快速开发相关语言应用。Spark提供了超过80个高级的操作，可以轻松构建并行应用程序。</li>\n<li>全面 Spark提供了Spark SQL，机器学习的MLlib，进行图形处理的GraphX，以及Spark Streaming等库。你可以在同一应用程序无缝地合并这些库。</li>\n<li>到处运行 可以standalone cluster mode运行EC2、Hadoop YARN、或者Apache Mesos中。可以访问HDFS、Cassandra、HBase、Hive、Tachyon，以及任意的Hadoop数据源。</li>\n</ol>\n<p>##Apache Mesos<br>在传统上，物理机和虚拟机是数据中心的典型的计算单元。当应用部署后，这些机器需要安装各种配置工具来管理这些应用。机器通常被组织成集群，提供独立的服务，而系统管理员则监督其日常的日常动作。当这些集群达到其最大容量时，需要多机联网来处理负载，这就是集群的扩展带来了挑战。<br>在2010年，UC Berkeley大学就对上述问题提出了解决方案，这就是现在的Apache Mesos，Mesos抽象了CPU、内存、硬盘资源，让数据中心的功能对外就像是一个大的机器。Mesos创建一个单独的底层集群来提供应用程序所需要的资源，而不会超出虚拟机和操作系统性能限制。</p>\n<p>###Apache Mesos简介<br>Mesos是Apache下的开源分布式资源管理框架，它被称为分布式系统的内核，使用内置Linux内核相同的原理，只是在不同的抽象层次。该 Mesos内核运行在每个机器上，在整个数据中心和云环境内应用程序（例如Hadoop、Spark、Kafka、Elaborate等）提供资源管理和资源负载的API接口。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>#MapRecue<br>在过去的20年里，互联网产生了大量的数据，比如爬虫文档、Web讲求日志等；也包括了计算各种类型的派生数据，比如，倒排索引、Web文档的图结构的各种表示、每台主机页面数量概要、每天被请求数量最多的集合，等等。很多这样的计算在概念上很容易理解的。然而，当输入的数据量很大时，这些计算必须要被分割到成百上千的机器上才有可能在可以接受的时间内完成。怎样来实现并行计算？如何分发数据？如何进行错误处理？所有这些问题综合在一起，使得原来很简洁的计算，因为要大量的复杂代码来处理这些问题，而变得让人难以处理。 Google公司为了应对大数据的处理，内部已经实现了数据以百计的为专门目的而写的计算程序，其中MapRecue就是其著名的计算框架之王，与GFS、Bigtable一起被称为Google技术的“三宝”。 </p>\n<p>##MapRecue简介<br>MapRecue是一个编程模型，用于大规模数据集（TB级）的并行运算。有关MapRecue的论文介绍，最早可以追溯到由Google的Jeffrey Dean和Sanjay Ghemawat发表在2004年OSDI（USENIX Symposium on Operationg Systems Design and Implementation）的《MapRecue：Simplified Data Processing on LargeClusters》。这篇文章描述了Google如何分割、处理、整合他们令人难以置信的大数据集。读者有兴趣可以在线阅读该论文<a href=\"https://www.usenix.org/legacy/events/osdi04/tech/full_papers/dean/dean.pdf。\" target=\"_blank\" rel=\"noopener\">https://www.usenix.org/legacy/events/osdi04/tech/full_papers/dean/dean.pdf。</a> 随后，开源软件先驱Doug Cutting等人受到该论文的启发，开始尝试实现MapRecue计算框架，并将它与NDFS（Nutch Distributed File System）结合，用以支持Nutch引擎的主要算法。由于NDFS与MapRecue在Nutch引擎中有着良好的应用，所以它们于2006年2月被分离出来，成为一套完整而独立的软件，并命名为Hadoop。 MapRecue程序模型应用成功要归功于以下几个方面。首先，由于该模型隐藏了并行、容错、本地优化以及负载平衡的细节，所以即便是那些没有并行和分布式系统经验的程序员也易于使用该模型。其次MapRecue计算可以很容易地表达大数据的各种问题。比如，MapRecue用于为Google的网页搜索服务生成数据，用于排序，用于数据挖掘，用于机器学习以及其他许多系统。再次，MapRecue的实现符合“由数千机器组成的大集群”的尺度，有效地利用了机器资源，所以非常适合解决大型计算问题。 </p>\n<p>##MapRecue的编程模型<br>MapRecue是一个用于大规模数据集（TB级）并行运算的编程模型，其基本原理就是将大的数据分成小块逐个分析，最后再将提取出来的数据汇总分析，最终获得我们想要的内容。从名字可以看出，“Map(映射)”和“Reduce（归纳）”是MapRecue模型的核心，其灵感来源于函数式语言（比如Lisp）中的内置函数map和reduce：用户通过定义一个Map函数，处理key/value（键值对）以生成一个中间key/value集合，MapRecue库将所有拥有相同的key(key I)的中间状态key合并起来传递到Redure职数；一个叫作Reduce的函数用以合并所有先前Map过后的有相同key（Key I）的中间量。map(k1,v1) -&gt; list&lt;k2,v2)reduce(k2,list(v2)) -&gt; list(k3,v3)但上面的定义显然还是过于抽象。现实世界中的许多任务在这个模型中得到了很好的表达。Shekhar Gulati就在他的博客里《How I explained MapReduce to my Wife?》举了一个辣椒酱制作过程的例子，来形象地描述MapRecue的原理，如下所述。1.MapRecue制作辣椒酱的过程辣椒酱制作的过程是这样的，先取一个洋葱，把它切碎，然后拌入盐和水，最后放进混合研磨机研磨。这样就能得到洋葱辣椒酱了。 现在，假设你想用薄荷、洋葱、番茄、辣椒、大蒜弄一瓶混合辣椒酱。你会怎么做呢？你会取薄荷叶一撮，洋葱一个，番茄一个，辣椒一根，大蒜一根，切碎后加入适量的盐和水，再放入混合研磨机里研磨，这样你就可以得到一瓶混合辣椒酱了。 现在把MapRecue的概念应用到食谱上，Map和Reduce其实就是两种操作。 Map：把洋葱、番茄、辣椒和大蒜切磋，是各自作用在这些物体上的一个Map操作。所以你给Map一个洋葱，Map就会把洋葱切碎。同样地，你把辣椒、大蒜和番茄一一地拿给Map，你也会得到各种碎块。所以，当你在切像洋葱这样的蔬菜时，你执行的就是一个Map操作。Map操作适用于每一种蔬菜，它会相应地生产出一种或多种碎块，在我们的例子中生产的是蔬菜块。在Map操作中可能会出现有个洋葱坏掉了的情况，你只要把洋葱丢了就行了。所以，如果出现坏洋葱了，Map操作就会过滤掉这个坏洋葱而不会生产出任何的坏洋葱块。 Reduce：在这一阶段，你将各种蔬菜都放入研磨机时在进行研磨，你就可以得到一瓶辣椒酱了。这意味要制成一瓶辣椒酱，你得研磨所有的原料。因此，研磨机通常将Map操作的蔬菜聚焦在了一起。 当然上面内容只是MapRecue的一部分，MapRecue的强大在于分布式计算。假设你每天需要生产10000瓶辣椒酱，你会怎么办？这个时候你就不得不雇佣更多的人和研磨机来完成这项工作了，你需要几个人一起切蔬菜。每个人都要处理满满一袋子的蔬菜，而每一个人都相当于在执行一个简单的Map操作。每一个人都将不断地从袋子里拿出蔬菜来，并且每次只对一种蔬菜进行处理，也就是将它们切碎，直到袋子空了为止。这样，当所有的工人都切完以后，工作台（每个人工作的地方）上就有了洋葱块、番茄块和蒜蓉，等等。 MapRecue将所有输出的蔬菜都搅拌在了一起，这些蔬菜都在以key为基础的Map操作下产生的。搅拌将自动完成，你可以假设key是一种原料的名字，你像洋葱一样。所以全部的洋葱key都搅拌在一起，并转移到研磨洋葱的研磨器里。这样，你就能得到洋葱辣椒酱了。同样地，所有的番茄也会被转移地标记着番茄的研磨器里，并制造出番茄辣椒酱。 </p>\n<p>#Apache Hadoop<br>Apache Hadoop是一个由Apache基金会开发的分布式系统基础架构，它可以让用户在不了解分布式底层细节的情况下，开发出可靠、可扩展的分布式计算应用。<br>Apache Hadoop框架允许用户使用简单的编程模型来实现计算机集群的大型数据集的分布式处理。它的目的是支持从单一服务器到上千台机器的扩展，充分利用了每台机器所提供本地计算和存储，而不是依靠硬件来提高高可用性。其本身被设计成在应用层检测和处理故障的库，对于计算机集群来说，其中每台机器的顶层都被设计成可以容错的，以便提供一个高可用的服务。<br>Apache Hadoop的框架最核心的设计就是HDFS和MapRecue。HDFS为海量的数据提供了存储，而MapRecue则为海量的数据提供了计算。</p>\n<p>##Apache Hadoop核心组件<br>Apache Hadoop包含以下模块：<br>Hadoop Common—常见实用工具，用来支持其他hadoop模块。<br>Hadoop Distributed File System（HDFS）—分布式文件系统，它提供对应用程序数据的高吞吐量访问<br>Hadoop YARN—-一个作业调度和集群资源管理框架<br>Hadoop MapRecue–基于YARN的大型数据集的并行处理系统</p>\n<p>###其它Apache Hadoop 相关的项目包括：<br>Ambari—-一个基于Web的工具，用于配置、管理和监控的Apache Hadoop 集群，其中包括支持Hadoop  HDFS、Hadoop  MapRecue、Hive、HCatalog、HBase、ZooKeeperOozie、Pig和Sqoop。Ambari还提供了仪表盘用于查看集群的健康，如热图，并能够以用户友好的方式来查看MapRecue、Pig和Hive应用，方便诊断其性能。<br>Avro–数据序列化系统<br>Cassandra–可扩展的、无单点故障的多主数据库<br>Chukwa–数据采集系统，用于管理大型分布式系统。<br>Hbase–一个可扩展的分布式数据库，支持结构化数据的大表存储<br>Hive–数据仓库基础设施，提供数据汇总以及特定的查询<br>Mahout—一种可扩展的机器学习和数据挖掘库<br>Pig–一个高层次的数据流并行计算语言和执行框架<br>Spark—Hadoop数据的快速和通用计算引擎。Spark提供了简单和强大的编程模型用于支持广泛的应用，其中包括ETL、机器学习、流处理和图形处理。<br>TEZ–通用的数据流编程框架，建立在Hadoop YARN之上。它提供了一个强大而灵活的引擎来执行任意DAG任务，以实现批量和交互式数据的处理。TEZ正在被Hive、Pig和Hadoop生态系统中的其他框架所采用，也可以通过其他商业软件（例如，ETL工具），以取代hadoop mapreduce作为底层执行引擎。<br>ZooKeeper–一个高性能的分布式应用程序协调服务。</p>\n<p>##Apache Spark<br>Spark是一个快速和通用的集群计算系统。特别：</p>\n<ol>\n<li>快速 Spack具有支持循环数据流和内存计算的先进的DAG执行引擎，所以比Hadoop MapRecue在内存计算上快100倍，在硬盘计算上快10倍。</li>\n<li>易于使用 Spark提供了Java，Scala，Python和R等语言的高级API，可以用于快速开发相关语言应用。Spark提供了超过80个高级的操作，可以轻松构建并行应用程序。</li>\n<li>全面 Spark提供了Spark SQL，机器学习的MLlib，进行图形处理的GraphX，以及Spark Streaming等库。你可以在同一应用程序无缝地合并这些库。</li>\n<li>到处运行 可以standalone cluster mode运行EC2、Hadoop YARN、或者Apache Mesos中。可以访问HDFS、Cassandra、HBase、Hive、Tachyon，以及任意的Hadoop数据源。</li>\n</ol>\n<p>##Apache Mesos<br>在传统上，物理机和虚拟机是数据中心的典型的计算单元。当应用部署后，这些机器需要安装各种配置工具来管理这些应用。机器通常被组织成集群，提供独立的服务，而系统管理员则监督其日常的日常动作。当这些集群达到其最大容量时，需要多机联网来处理负载，这就是集群的扩展带来了挑战。<br>在2010年，UC Berkeley大学就对上述问题提出了解决方案，这就是现在的Apache Mesos，Mesos抽象了CPU、内存、硬盘资源，让数据中心的功能对外就像是一个大的机器。Mesos创建一个单独的底层集群来提供应用程序所需要的资源，而不会超出虚拟机和操作系统性能限制。</p>\n<p>###Apache Mesos简介<br>Mesos是Apache下的开源分布式资源管理框架，它被称为分布式系统的内核，使用内置Linux内核相同的原理，只是在不同的抽象层次。该 Mesos内核运行在每个机器上，在整个数据中心和云环境内应用程序（例如Hadoop、Spark、Kafka、Elaborate等）提供资源管理和资源负载的API接口。</p>\n"},{"title":"Hadoop数据移动","date":"2017-04-16T15:43:49.000Z","_content":"数据采集\n本文主要是讲外部系统与Hadoop之间的数据传递，包括从外部系统采集数据导入到hadoop，以及从Hadoop中提取数据导入外部系统中。\n\n#数据采集考量\n虽然Hadoop提出了文件客户端，便于在Hadoop中和Hadoop外复制文件，但是大多数据 Hadoop应用需要从不同来源导入数据，而且对不同的导入频率也提出了要求，Hadoop常用的数据来源包括以下：\n1.传统数据管理系统，如果关系型数据库与主机\n2.日志、机器生成的数据，以及其他类型的事件数据。\n3.从现有的企业数据存储中输入的文件。\n\n将数据从不同的系统输入Hadoop时需要考虑很多因素。如下：\n1.数据采集的时效性与可访问性\n需要采集数据在采集频率方面有哪些要求？下游的处理要求数据多长时间准备完毕？\n\n2.增量更新\n如何添加新数据？需要将数据添加到现有数据库吗？需要重写现有数据吗？\n\n3.数据访问和处理\n数据会用于处理过程吗？如果会，数据会用于批处理任务吗？需要的数据是不是随机获取的？\n\n4.数据分区及数据分片\n数据采集后应该如何分区？需要将数据导入到多个目录系统（如HDFS与HBase）吗？\n\n5.数据存储格式\n数据存储的格式是哪一种？\n\n6.数据变换\n需要变换尚未落地的数据吗？\n\n下面简单列举一下这几点考量？\n\n##1.数据采集的时效性\n这里的时效性是指可进行数据采集的时间与Hadoop中工具可访问数据的时间之间的间隔。采集架构的时间分类会对存储媒介和采集方法造成很大的影响。一般来说数据采集构架，可以使用以下分类中的一个\na.大型批处理\n通常指15分钟到数据小时的任务，有时可能指时间跨度达到一天的任务\n\nb.小型批处理\n通常指大约2分钟发送一次任务，但是总的来说不会超过15分钟\n\nc.近实时决策支持\n指接受信息后“立即作出反应”，并在2秒到2分钟内发送数据\n\nd.近实时事件处理\n指在2秒内处理任务，速度可达到100毫秒\n\ne.实时\n这里指不超过100毫秒\n\n可以注意到随着实现时间到达实时，实现的复杂度和成本会大大增加。从批处理出发（比如使用简单文件传输）通常是个不错的选择。HDFS对时效性的要求比较宽松，所以可能更加适合成为主要存储位置。而一个简单文件传输或Sqoop任务则适合作为采集数据的工具。比如，执行hadoop fs -put命令将复制一个文件，并进行全面的校验，以确定正确地复制数据。\n使用hadoop fs -put命令与Sqoop时，你需要明白一点：HDFS上的数据存储格式可能并不适合数据的长期存储和处理。因此，在使用这些工具的时候，可能需要通过额外的批处理操作，以将数据存储为需要的格式。\n当用户需要从简单的批处理转向更高频率的更新时，就应该考虑Flume或kafka之类的工具了。这里时间要求不起过2分钟，所以Sqoop与文件转换器不适用。而且，因为要求时间不起过2分钟，所以存储层可能需要变成HBase或Solr，这样插入与读取操作会获得更细的粒度。当要求到实时水平时，我们首先需要考虑内存，然后是永久性存储。全世界所有的平行化处理都不会有助于将反应要求控制在500毫秒以内，只要硬盘驱动器保持处理操作的状态。基于这一点，我们开始进入流处理领域，采用Storm或Spark Streaming之类的工具。这里需要强调的是，这些工具应该真正用于大数据处理，而不是像Flume或Sqoop那样用于数据采集。\n\n##2.增量更新\n新的数据是要添加到已有数据集中，还是要修改已有数据集。如果仅要求添加数据，那么HDFS对于大部分实现都很适用。HDFS能够并行 化多个驱动器的I/O操作，所以读写性能很高。HDFS的缺点是无法添加或者随机写入创建后的文件。\n\n#数据采集的选择\n##1.文件传输\n将数据导入导出到Hadoop最简单的方法就是文件传输，就是hadoop fs -put与hadoop fs -get命令。这有时也是最快的方法，所以在设计Hadoop新的数据处理流水线时，首先应该考虑选择文件传输。\n\n下面列一下文件传输的特点：\na.这是一种all-or-nothing批处理方法，所以如果文件传输过程中出现错误，则不会写入或读取任何数据。这种方法与Flume、Kafka之类的采集方法不同，后者提供一定程度的错误处理功能，并且有传输保障。\nb.文件传输默认为单线程，不能并行 文件传输。\nc.文件传输将文件从传统的文件系统导入HDFS\nd.不支持数据转换，数据按原样导入HDFS。数据导入HDFS后才能进行处理，这一点与传输过程中的数据转换截然相反。类似于Flume的系统支持传输过程中的数据转换。\ne.这种加载是逐字进行的，所以能传输任何类型的文件（文件、二进制、图书等）\n\n##文件传输与其他采集方法的考量\n简单文件传输在某些情况下是适用的，尤其是在需要将已存在 的一系列文件输入到HDFS中，而且可以接受保持源文件格式的情况下。否则，在决定是否可以接受文件传输或者是否使用类似于Flume的工具时，需要考虑以下因素。\na.需要将数据采集到多个位置吗？比如，是需要将数据同时输入HDFS和Solr，还是需要将数据同时输入HDFS和HBase？这种情况下，如果使用文件传输，那么在文件采集完成之后将需要额外的工作，因些采用Flume更合适。\nb.对可靠性的要求高不高？如果高，那么一旦传输时出现错误，文件传输就必须重新开始，这时，Fluem同样是更好的选择。\ne.数据采集之前需要转换操作吗？如果需要Flume无疑是适合的工具。\n如果需要采集文件，可以考虑使用Flume Spooling  Directory源。采用这种方法，用户将文件放置到磁盘特定的目录就可以采集文件。这种采集文件的方法简单可靠，而且需要时能够实现传输过程中的数据转换。\n\n##Sqoop：Hadoop与关系数据库的批量传输\nSqoop是一种工具，能批量地将数据从关系型数据管理系统导出到Hadoop中，也能批量地将数据从Hadoop导出至关系型数据库中。\n\nFlume:基于事件的数据收集及处理\nFlume是一种分布式的可靠开源系统，用于流数据的高效收集、聚焦和移动。Flume通常用于移动日志数据，但是也能移动大量事件数据，如社交媒体订阅、消息队列事件或网络流量数据。\n\n##Kafka\nApache Kafka是一种发布订单消息的分布式系统，能够将消息归类为不同主题。应用程序能在Kafka上发布信息，或订阅主题进而接受特定主要下发布的消息。Producer发布消息，而Consumer收集并处理消息。作为分布式系统，Kafka在集群中运行，每个节点被称为Broker。\nKafka维护每个主题的分区日志。消息会发布到相应的主题中，每个分区都是一个有序的消息子集。同一个主题的多个分区能够通过集群中的多个Broker传送，这种方法提高了主题的容量与吞吐量，使其超越了单一机器所能提供的容量与吞吐量。消息在分区内被有序排列，每个消息都包含一个特定的偏移量。Kafka中消息可以通过一个包含主题、分区以及偏移量的组合来确定。Producer能够根据消息的主键选择消息应该写入哪一个分区，也能够简单地用循环的方式，让消息分布在各分区之间。\nConsumer会在Consumer组中注册，每个组包括一个或多个Consumer，每个Consumer读取一个或多个主题分区。每组中的每条消息只能传送给一个Consumer。但是，如果多个组订阅了同一个主题，那么每个组都将得到所有的消息。一个组中包含多个Consumer有助于获得加载平衡（可以支持高于单个Consumer处理能力的吞吐量）与高可用性（如果一个Consumer出现错误，它所读取的分区将重新分配给组中其它Consumer）。\n前面提到，对于应用层面的数据分类，主要单位是主题。一个Consumer或Consumer组将读取其订阅主题的所有数据，所以如果一个应用只关注一个数据子集，那么就应该将该数据子集与其他数据放在两个不同的主题中。如果多个信息集总是一起读取和处理，那么应该将它们归在同一个主题中。\n\n#数据导出\n数据导出的思路与导入类似。\n\n\n\n\n\n\n","source":"_posts/hadoop/Hadoop之数据采集.md","raw":"---\ntitle: Hadoop数据移动\ndate: 2017-04-16 23:43:49\ntags: [大数据,数据仓库,数据采集]\ncategories: [大数据,数据仓库]\n---\n数据采集\n本文主要是讲外部系统与Hadoop之间的数据传递，包括从外部系统采集数据导入到hadoop，以及从Hadoop中提取数据导入外部系统中。\n\n#数据采集考量\n虽然Hadoop提出了文件客户端，便于在Hadoop中和Hadoop外复制文件，但是大多数据 Hadoop应用需要从不同来源导入数据，而且对不同的导入频率也提出了要求，Hadoop常用的数据来源包括以下：\n1.传统数据管理系统，如果关系型数据库与主机\n2.日志、机器生成的数据，以及其他类型的事件数据。\n3.从现有的企业数据存储中输入的文件。\n\n将数据从不同的系统输入Hadoop时需要考虑很多因素。如下：\n1.数据采集的时效性与可访问性\n需要采集数据在采集频率方面有哪些要求？下游的处理要求数据多长时间准备完毕？\n\n2.增量更新\n如何添加新数据？需要将数据添加到现有数据库吗？需要重写现有数据吗？\n\n3.数据访问和处理\n数据会用于处理过程吗？如果会，数据会用于批处理任务吗？需要的数据是不是随机获取的？\n\n4.数据分区及数据分片\n数据采集后应该如何分区？需要将数据导入到多个目录系统（如HDFS与HBase）吗？\n\n5.数据存储格式\n数据存储的格式是哪一种？\n\n6.数据变换\n需要变换尚未落地的数据吗？\n\n下面简单列举一下这几点考量？\n\n##1.数据采集的时效性\n这里的时效性是指可进行数据采集的时间与Hadoop中工具可访问数据的时间之间的间隔。采集架构的时间分类会对存储媒介和采集方法造成很大的影响。一般来说数据采集构架，可以使用以下分类中的一个\na.大型批处理\n通常指15分钟到数据小时的任务，有时可能指时间跨度达到一天的任务\n\nb.小型批处理\n通常指大约2分钟发送一次任务，但是总的来说不会超过15分钟\n\nc.近实时决策支持\n指接受信息后“立即作出反应”，并在2秒到2分钟内发送数据\n\nd.近实时事件处理\n指在2秒内处理任务，速度可达到100毫秒\n\ne.实时\n这里指不超过100毫秒\n\n可以注意到随着实现时间到达实时，实现的复杂度和成本会大大增加。从批处理出发（比如使用简单文件传输）通常是个不错的选择。HDFS对时效性的要求比较宽松，所以可能更加适合成为主要存储位置。而一个简单文件传输或Sqoop任务则适合作为采集数据的工具。比如，执行hadoop fs -put命令将复制一个文件，并进行全面的校验，以确定正确地复制数据。\n使用hadoop fs -put命令与Sqoop时，你需要明白一点：HDFS上的数据存储格式可能并不适合数据的长期存储和处理。因此，在使用这些工具的时候，可能需要通过额外的批处理操作，以将数据存储为需要的格式。\n当用户需要从简单的批处理转向更高频率的更新时，就应该考虑Flume或kafka之类的工具了。这里时间要求不起过2分钟，所以Sqoop与文件转换器不适用。而且，因为要求时间不起过2分钟，所以存储层可能需要变成HBase或Solr，这样插入与读取操作会获得更细的粒度。当要求到实时水平时，我们首先需要考虑内存，然后是永久性存储。全世界所有的平行化处理都不会有助于将反应要求控制在500毫秒以内，只要硬盘驱动器保持处理操作的状态。基于这一点，我们开始进入流处理领域，采用Storm或Spark Streaming之类的工具。这里需要强调的是，这些工具应该真正用于大数据处理，而不是像Flume或Sqoop那样用于数据采集。\n\n##2.增量更新\n新的数据是要添加到已有数据集中，还是要修改已有数据集。如果仅要求添加数据，那么HDFS对于大部分实现都很适用。HDFS能够并行 化多个驱动器的I/O操作，所以读写性能很高。HDFS的缺点是无法添加或者随机写入创建后的文件。\n\n#数据采集的选择\n##1.文件传输\n将数据导入导出到Hadoop最简单的方法就是文件传输，就是hadoop fs -put与hadoop fs -get命令。这有时也是最快的方法，所以在设计Hadoop新的数据处理流水线时，首先应该考虑选择文件传输。\n\n下面列一下文件传输的特点：\na.这是一种all-or-nothing批处理方法，所以如果文件传输过程中出现错误，则不会写入或读取任何数据。这种方法与Flume、Kafka之类的采集方法不同，后者提供一定程度的错误处理功能，并且有传输保障。\nb.文件传输默认为单线程，不能并行 文件传输。\nc.文件传输将文件从传统的文件系统导入HDFS\nd.不支持数据转换，数据按原样导入HDFS。数据导入HDFS后才能进行处理，这一点与传输过程中的数据转换截然相反。类似于Flume的系统支持传输过程中的数据转换。\ne.这种加载是逐字进行的，所以能传输任何类型的文件（文件、二进制、图书等）\n\n##文件传输与其他采集方法的考量\n简单文件传输在某些情况下是适用的，尤其是在需要将已存在 的一系列文件输入到HDFS中，而且可以接受保持源文件格式的情况下。否则，在决定是否可以接受文件传输或者是否使用类似于Flume的工具时，需要考虑以下因素。\na.需要将数据采集到多个位置吗？比如，是需要将数据同时输入HDFS和Solr，还是需要将数据同时输入HDFS和HBase？这种情况下，如果使用文件传输，那么在文件采集完成之后将需要额外的工作，因些采用Flume更合适。\nb.对可靠性的要求高不高？如果高，那么一旦传输时出现错误，文件传输就必须重新开始，这时，Fluem同样是更好的选择。\ne.数据采集之前需要转换操作吗？如果需要Flume无疑是适合的工具。\n如果需要采集文件，可以考虑使用Flume Spooling  Directory源。采用这种方法，用户将文件放置到磁盘特定的目录就可以采集文件。这种采集文件的方法简单可靠，而且需要时能够实现传输过程中的数据转换。\n\n##Sqoop：Hadoop与关系数据库的批量传输\nSqoop是一种工具，能批量地将数据从关系型数据管理系统导出到Hadoop中，也能批量地将数据从Hadoop导出至关系型数据库中。\n\nFlume:基于事件的数据收集及处理\nFlume是一种分布式的可靠开源系统，用于流数据的高效收集、聚焦和移动。Flume通常用于移动日志数据，但是也能移动大量事件数据，如社交媒体订阅、消息队列事件或网络流量数据。\n\n##Kafka\nApache Kafka是一种发布订单消息的分布式系统，能够将消息归类为不同主题。应用程序能在Kafka上发布信息，或订阅主题进而接受特定主要下发布的消息。Producer发布消息，而Consumer收集并处理消息。作为分布式系统，Kafka在集群中运行，每个节点被称为Broker。\nKafka维护每个主题的分区日志。消息会发布到相应的主题中，每个分区都是一个有序的消息子集。同一个主题的多个分区能够通过集群中的多个Broker传送，这种方法提高了主题的容量与吞吐量，使其超越了单一机器所能提供的容量与吞吐量。消息在分区内被有序排列，每个消息都包含一个特定的偏移量。Kafka中消息可以通过一个包含主题、分区以及偏移量的组合来确定。Producer能够根据消息的主键选择消息应该写入哪一个分区，也能够简单地用循环的方式，让消息分布在各分区之间。\nConsumer会在Consumer组中注册，每个组包括一个或多个Consumer，每个Consumer读取一个或多个主题分区。每组中的每条消息只能传送给一个Consumer。但是，如果多个组订阅了同一个主题，那么每个组都将得到所有的消息。一个组中包含多个Consumer有助于获得加载平衡（可以支持高于单个Consumer处理能力的吞吐量）与高可用性（如果一个Consumer出现错误，它所读取的分区将重新分配给组中其它Consumer）。\n前面提到，对于应用层面的数据分类，主要单位是主题。一个Consumer或Consumer组将读取其订阅主题的所有数据，所以如果一个应用只关注一个数据子集，那么就应该将该数据子集与其他数据放在两个不同的主题中。如果多个信息集总是一起读取和处理，那么应该将它们归在同一个主题中。\n\n#数据导出\n数据导出的思路与导入类似。\n\n\n\n\n\n\n","slug":"hadoop/Hadoop之数据采集","published":1,"updated":"2017-08-18T01:44:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bmb009ks77r79n0kln0","content":"<p>数据采集<br>本文主要是讲外部系统与Hadoop之间的数据传递，包括从外部系统采集数据导入到hadoop，以及从Hadoop中提取数据导入外部系统中。</p>\n<p>#数据采集考量<br>虽然Hadoop提出了文件客户端，便于在Hadoop中和Hadoop外复制文件，但是大多数据 Hadoop应用需要从不同来源导入数据，而且对不同的导入频率也提出了要求，Hadoop常用的数据来源包括以下：<br>1.传统数据管理系统，如果关系型数据库与主机<br>2.日志、机器生成的数据，以及其他类型的事件数据。<br>3.从现有的企业数据存储中输入的文件。</p>\n<p>将数据从不同的系统输入Hadoop时需要考虑很多因素。如下：<br>1.数据采集的时效性与可访问性<br>需要采集数据在采集频率方面有哪些要求？下游的处理要求数据多长时间准备完毕？</p>\n<p>2.增量更新<br>如何添加新数据？需要将数据添加到现有数据库吗？需要重写现有数据吗？</p>\n<p>3.数据访问和处理<br>数据会用于处理过程吗？如果会，数据会用于批处理任务吗？需要的数据是不是随机获取的？</p>\n<p>4.数据分区及数据分片<br>数据采集后应该如何分区？需要将数据导入到多个目录系统（如HDFS与HBase）吗？</p>\n<p>5.数据存储格式<br>数据存储的格式是哪一种？</p>\n<p>6.数据变换<br>需要变换尚未落地的数据吗？</p>\n<p>下面简单列举一下这几点考量？</p>\n<p>##1.数据采集的时效性<br>这里的时效性是指可进行数据采集的时间与Hadoop中工具可访问数据的时间之间的间隔。采集架构的时间分类会对存储媒介和采集方法造成很大的影响。一般来说数据采集构架，可以使用以下分类中的一个<br>a.大型批处理<br>通常指15分钟到数据小时的任务，有时可能指时间跨度达到一天的任务</p>\n<p>b.小型批处理<br>通常指大约2分钟发送一次任务，但是总的来说不会超过15分钟</p>\n<p>c.近实时决策支持<br>指接受信息后“立即作出反应”，并在2秒到2分钟内发送数据</p>\n<p>d.近实时事件处理<br>指在2秒内处理任务，速度可达到100毫秒</p>\n<p>e.实时<br>这里指不超过100毫秒</p>\n<p>可以注意到随着实现时间到达实时，实现的复杂度和成本会大大增加。从批处理出发（比如使用简单文件传输）通常是个不错的选择。HDFS对时效性的要求比较宽松，所以可能更加适合成为主要存储位置。而一个简单文件传输或Sqoop任务则适合作为采集数据的工具。比如，执行hadoop fs -put命令将复制一个文件，并进行全面的校验，以确定正确地复制数据。<br>使用hadoop fs -put命令与Sqoop时，你需要明白一点：HDFS上的数据存储格式可能并不适合数据的长期存储和处理。因此，在使用这些工具的时候，可能需要通过额外的批处理操作，以将数据存储为需要的格式。<br>当用户需要从简单的批处理转向更高频率的更新时，就应该考虑Flume或kafka之类的工具了。这里时间要求不起过2分钟，所以Sqoop与文件转换器不适用。而且，因为要求时间不起过2分钟，所以存储层可能需要变成HBase或Solr，这样插入与读取操作会获得更细的粒度。当要求到实时水平时，我们首先需要考虑内存，然后是永久性存储。全世界所有的平行化处理都不会有助于将反应要求控制在500毫秒以内，只要硬盘驱动器保持处理操作的状态。基于这一点，我们开始进入流处理领域，采用Storm或Spark Streaming之类的工具。这里需要强调的是，这些工具应该真正用于大数据处理，而不是像Flume或Sqoop那样用于数据采集。</p>\n<p>##2.增量更新<br>新的数据是要添加到已有数据集中，还是要修改已有数据集。如果仅要求添加数据，那么HDFS对于大部分实现都很适用。HDFS能够并行 化多个驱动器的I/O操作，所以读写性能很高。HDFS的缺点是无法添加或者随机写入创建后的文件。</p>\n<p>#数据采集的选择</p>\n<p>##1.文件传输<br>将数据导入导出到Hadoop最简单的方法就是文件传输，就是hadoop fs -put与hadoop fs -get命令。这有时也是最快的方法，所以在设计Hadoop新的数据处理流水线时，首先应该考虑选择文件传输。</p>\n<p>下面列一下文件传输的特点：<br>a.这是一种all-or-nothing批处理方法，所以如果文件传输过程中出现错误，则不会写入或读取任何数据。这种方法与Flume、Kafka之类的采集方法不同，后者提供一定程度的错误处理功能，并且有传输保障。<br>b.文件传输默认为单线程，不能并行 文件传输。<br>c.文件传输将文件从传统的文件系统导入HDFS<br>d.不支持数据转换，数据按原样导入HDFS。数据导入HDFS后才能进行处理，这一点与传输过程中的数据转换截然相反。类似于Flume的系统支持传输过程中的数据转换。<br>e.这种加载是逐字进行的，所以能传输任何类型的文件（文件、二进制、图书等）</p>\n<p>##文件传输与其他采集方法的考量<br>简单文件传输在某些情况下是适用的，尤其是在需要将已存在 的一系列文件输入到HDFS中，而且可以接受保持源文件格式的情况下。否则，在决定是否可以接受文件传输或者是否使用类似于Flume的工具时，需要考虑以下因素。<br>a.需要将数据采集到多个位置吗？比如，是需要将数据同时输入HDFS和Solr，还是需要将数据同时输入HDFS和HBase？这种情况下，如果使用文件传输，那么在文件采集完成之后将需要额外的工作，因些采用Flume更合适。<br>b.对可靠性的要求高不高？如果高，那么一旦传输时出现错误，文件传输就必须重新开始，这时，Fluem同样是更好的选择。<br>e.数据采集之前需要转换操作吗？如果需要Flume无疑是适合的工具。<br>如果需要采集文件，可以考虑使用Flume Spooling  Directory源。采用这种方法，用户将文件放置到磁盘特定的目录就可以采集文件。这种采集文件的方法简单可靠，而且需要时能够实现传输过程中的数据转换。</p>\n<p>##Sqoop：Hadoop与关系数据库的批量传输<br>Sqoop是一种工具，能批量地将数据从关系型数据管理系统导出到Hadoop中，也能批量地将数据从Hadoop导出至关系型数据库中。</p>\n<p>Flume:基于事件的数据收集及处理<br>Flume是一种分布式的可靠开源系统，用于流数据的高效收集、聚焦和移动。Flume通常用于移动日志数据，但是也能移动大量事件数据，如社交媒体订阅、消息队列事件或网络流量数据。</p>\n<p>##Kafka<br>Apache Kafka是一种发布订单消息的分布式系统，能够将消息归类为不同主题。应用程序能在Kafka上发布信息，或订阅主题进而接受特定主要下发布的消息。Producer发布消息，而Consumer收集并处理消息。作为分布式系统，Kafka在集群中运行，每个节点被称为Broker。<br>Kafka维护每个主题的分区日志。消息会发布到相应的主题中，每个分区都是一个有序的消息子集。同一个主题的多个分区能够通过集群中的多个Broker传送，这种方法提高了主题的容量与吞吐量，使其超越了单一机器所能提供的容量与吞吐量。消息在分区内被有序排列，每个消息都包含一个特定的偏移量。Kafka中消息可以通过一个包含主题、分区以及偏移量的组合来确定。Producer能够根据消息的主键选择消息应该写入哪一个分区，也能够简单地用循环的方式，让消息分布在各分区之间。<br>Consumer会在Consumer组中注册，每个组包括一个或多个Consumer，每个Consumer读取一个或多个主题分区。每组中的每条消息只能传送给一个Consumer。但是，如果多个组订阅了同一个主题，那么每个组都将得到所有的消息。一个组中包含多个Consumer有助于获得加载平衡（可以支持高于单个Consumer处理能力的吞吐量）与高可用性（如果一个Consumer出现错误，它所读取的分区将重新分配给组中其它Consumer）。<br>前面提到，对于应用层面的数据分类，主要单位是主题。一个Consumer或Consumer组将读取其订阅主题的所有数据，所以如果一个应用只关注一个数据子集，那么就应该将该数据子集与其他数据放在两个不同的主题中。如果多个信息集总是一起读取和处理，那么应该将它们归在同一个主题中。</p>\n<p>#数据导出<br>数据导出的思路与导入类似。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>数据采集<br>本文主要是讲外部系统与Hadoop之间的数据传递，包括从外部系统采集数据导入到hadoop，以及从Hadoop中提取数据导入外部系统中。</p>\n<p>#数据采集考量<br>虽然Hadoop提出了文件客户端，便于在Hadoop中和Hadoop外复制文件，但是大多数据 Hadoop应用需要从不同来源导入数据，而且对不同的导入频率也提出了要求，Hadoop常用的数据来源包括以下：<br>1.传统数据管理系统，如果关系型数据库与主机<br>2.日志、机器生成的数据，以及其他类型的事件数据。<br>3.从现有的企业数据存储中输入的文件。</p>\n<p>将数据从不同的系统输入Hadoop时需要考虑很多因素。如下：<br>1.数据采集的时效性与可访问性<br>需要采集数据在采集频率方面有哪些要求？下游的处理要求数据多长时间准备完毕？</p>\n<p>2.增量更新<br>如何添加新数据？需要将数据添加到现有数据库吗？需要重写现有数据吗？</p>\n<p>3.数据访问和处理<br>数据会用于处理过程吗？如果会，数据会用于批处理任务吗？需要的数据是不是随机获取的？</p>\n<p>4.数据分区及数据分片<br>数据采集后应该如何分区？需要将数据导入到多个目录系统（如HDFS与HBase）吗？</p>\n<p>5.数据存储格式<br>数据存储的格式是哪一种？</p>\n<p>6.数据变换<br>需要变换尚未落地的数据吗？</p>\n<p>下面简单列举一下这几点考量？</p>\n<p>##1.数据采集的时效性<br>这里的时效性是指可进行数据采集的时间与Hadoop中工具可访问数据的时间之间的间隔。采集架构的时间分类会对存储媒介和采集方法造成很大的影响。一般来说数据采集构架，可以使用以下分类中的一个<br>a.大型批处理<br>通常指15分钟到数据小时的任务，有时可能指时间跨度达到一天的任务</p>\n<p>b.小型批处理<br>通常指大约2分钟发送一次任务，但是总的来说不会超过15分钟</p>\n<p>c.近实时决策支持<br>指接受信息后“立即作出反应”，并在2秒到2分钟内发送数据</p>\n<p>d.近实时事件处理<br>指在2秒内处理任务，速度可达到100毫秒</p>\n<p>e.实时<br>这里指不超过100毫秒</p>\n<p>可以注意到随着实现时间到达实时，实现的复杂度和成本会大大增加。从批处理出发（比如使用简单文件传输）通常是个不错的选择。HDFS对时效性的要求比较宽松，所以可能更加适合成为主要存储位置。而一个简单文件传输或Sqoop任务则适合作为采集数据的工具。比如，执行hadoop fs -put命令将复制一个文件，并进行全面的校验，以确定正确地复制数据。<br>使用hadoop fs -put命令与Sqoop时，你需要明白一点：HDFS上的数据存储格式可能并不适合数据的长期存储和处理。因此，在使用这些工具的时候，可能需要通过额外的批处理操作，以将数据存储为需要的格式。<br>当用户需要从简单的批处理转向更高频率的更新时，就应该考虑Flume或kafka之类的工具了。这里时间要求不起过2分钟，所以Sqoop与文件转换器不适用。而且，因为要求时间不起过2分钟，所以存储层可能需要变成HBase或Solr，这样插入与读取操作会获得更细的粒度。当要求到实时水平时，我们首先需要考虑内存，然后是永久性存储。全世界所有的平行化处理都不会有助于将反应要求控制在500毫秒以内，只要硬盘驱动器保持处理操作的状态。基于这一点，我们开始进入流处理领域，采用Storm或Spark Streaming之类的工具。这里需要强调的是，这些工具应该真正用于大数据处理，而不是像Flume或Sqoop那样用于数据采集。</p>\n<p>##2.增量更新<br>新的数据是要添加到已有数据集中，还是要修改已有数据集。如果仅要求添加数据，那么HDFS对于大部分实现都很适用。HDFS能够并行 化多个驱动器的I/O操作，所以读写性能很高。HDFS的缺点是无法添加或者随机写入创建后的文件。</p>\n<p>#数据采集的选择</p>\n<p>##1.文件传输<br>将数据导入导出到Hadoop最简单的方法就是文件传输，就是hadoop fs -put与hadoop fs -get命令。这有时也是最快的方法，所以在设计Hadoop新的数据处理流水线时，首先应该考虑选择文件传输。</p>\n<p>下面列一下文件传输的特点：<br>a.这是一种all-or-nothing批处理方法，所以如果文件传输过程中出现错误，则不会写入或读取任何数据。这种方法与Flume、Kafka之类的采集方法不同，后者提供一定程度的错误处理功能，并且有传输保障。<br>b.文件传输默认为单线程，不能并行 文件传输。<br>c.文件传输将文件从传统的文件系统导入HDFS<br>d.不支持数据转换，数据按原样导入HDFS。数据导入HDFS后才能进行处理，这一点与传输过程中的数据转换截然相反。类似于Flume的系统支持传输过程中的数据转换。<br>e.这种加载是逐字进行的，所以能传输任何类型的文件（文件、二进制、图书等）</p>\n<p>##文件传输与其他采集方法的考量<br>简单文件传输在某些情况下是适用的，尤其是在需要将已存在 的一系列文件输入到HDFS中，而且可以接受保持源文件格式的情况下。否则，在决定是否可以接受文件传输或者是否使用类似于Flume的工具时，需要考虑以下因素。<br>a.需要将数据采集到多个位置吗？比如，是需要将数据同时输入HDFS和Solr，还是需要将数据同时输入HDFS和HBase？这种情况下，如果使用文件传输，那么在文件采集完成之后将需要额外的工作，因些采用Flume更合适。<br>b.对可靠性的要求高不高？如果高，那么一旦传输时出现错误，文件传输就必须重新开始，这时，Fluem同样是更好的选择。<br>e.数据采集之前需要转换操作吗？如果需要Flume无疑是适合的工具。<br>如果需要采集文件，可以考虑使用Flume Spooling  Directory源。采用这种方法，用户将文件放置到磁盘特定的目录就可以采集文件。这种采集文件的方法简单可靠，而且需要时能够实现传输过程中的数据转换。</p>\n<p>##Sqoop：Hadoop与关系数据库的批量传输<br>Sqoop是一种工具，能批量地将数据从关系型数据管理系统导出到Hadoop中，也能批量地将数据从Hadoop导出至关系型数据库中。</p>\n<p>Flume:基于事件的数据收集及处理<br>Flume是一种分布式的可靠开源系统，用于流数据的高效收集、聚焦和移动。Flume通常用于移动日志数据，但是也能移动大量事件数据，如社交媒体订阅、消息队列事件或网络流量数据。</p>\n<p>##Kafka<br>Apache Kafka是一种发布订单消息的分布式系统，能够将消息归类为不同主题。应用程序能在Kafka上发布信息，或订阅主题进而接受特定主要下发布的消息。Producer发布消息，而Consumer收集并处理消息。作为分布式系统，Kafka在集群中运行，每个节点被称为Broker。<br>Kafka维护每个主题的分区日志。消息会发布到相应的主题中，每个分区都是一个有序的消息子集。同一个主题的多个分区能够通过集群中的多个Broker传送，这种方法提高了主题的容量与吞吐量，使其超越了单一机器所能提供的容量与吞吐量。消息在分区内被有序排列，每个消息都包含一个特定的偏移量。Kafka中消息可以通过一个包含主题、分区以及偏移量的组合来确定。Producer能够根据消息的主键选择消息应该写入哪一个分区，也能够简单地用循环的方式，让消息分布在各分区之间。<br>Consumer会在Consumer组中注册，每个组包括一个或多个Consumer，每个Consumer读取一个或多个主题分区。每组中的每条消息只能传送给一个Consumer。但是，如果多个组订阅了同一个主题，那么每个组都将得到所有的消息。一个组中包含多个Consumer有助于获得加载平衡（可以支持高于单个Consumer处理能力的吞吐量）与高可用性（如果一个Consumer出现错误，它所读取的分区将重新分配给组中其它Consumer）。<br>前面提到，对于应用层面的数据分类，主要单位是主题。一个Consumer或Consumer组将读取其订阅主题的所有数据，所以如果一个应用只关注一个数据子集，那么就应该将该数据子集与其他数据放在两个不同的主题中。如果多个信息集总是一起读取和处理，那么应该将它们归在同一个主题中。</p>\n<p>#数据导出<br>数据导出的思路与导入类似。</p>\n"},{"title":"Hadoop知识点","date":"2017-05-08T15:43:49.000Z","_content":"#Hadoop数据管理\n主要包括Hadoop的分布式文件系统HDFS、分布式数据库HBase和数据仓库工具Hive\n\n##HDFS的数据管理\nHDFS是分布式计算的存储基石，Hadoop分布式文件系统和其它文件系统有很多类似的特性；  \n1）对于整个集群有单一的命名空间；  \n2）具有数据一致性，都适合一次写入多次读取的模型，客户端在文件没有被成功创建之前是无法看到文件存在的。  \n3）文件会被分割成多个文件块，每个文件块被分配存储到数据节点上，而且会根据配置由复制文件块来保证数据的安全性。  \nHDFS有三个重要的角色来进行文件系统的管理：NameNode、DataNode和Client。NameNode可以看做是分布式文件系统的管理者，主要负责管理文件系统的命名空间、集群配置信息和存储块的复制等。NameNode会将文件系统的Metadata存储在内存中，这些信息主要包括文件信息、每一个文件对应的文件块的信息和每一个文件块在DataNode中的信息等。DataNode是文件存储的基本单元，它将文件块（Block）存储在本地文件系统中，保存了所有Block的Metadata，同时周期性地将所有存在的Block信息发送给NameNode。Client就是需要获取分布式文件系统文件的应用程序。接下来三个具体的操作来说明HDFS对数据的管理。  \n（1）文件写入\n1）Client向NameNode发起文件写入的请求。  \n2）NameNode根据文件的大小和文件块配置情况，返回给Client所管理的DataNode的信息。  \n3）Client将文件划分为多个Block，根据DataNode的地址信息，按顺序将其写入到每一个DataNode块中。  \n（2）文件读取  \n1）Client向NameNode发起文件读取的请求。  \n2）NameNode返回文件存储的DataNode信息。  \n3）Client读取文件信息。  \n（3）文件块（Block）复制  \n1）NameNode发现部分文件的Block不符合最小复制数这一要求或部分DataNode失效。  \n2）通知DataNode相互复制Block。  \n3）DataNode开始直接相互复制。  \n\n作为分布式文件系统，HDFS在数据管理方面还有值得借鉴的几个功能：  \na.文件块（Block）的放置：一个Block会有三份备份，一份放在NameNode指定的DataNode上，另一份放在与指定DataNode不在同一机器上的DataNode上，最后一份放在与指定DataNode同一Rack的DataNode上。备份的目的是为了数据安全，采用这种配置方式主要是考虑同一Rack失败的情况，以及不同Rack之间进行数据复制会带来的性能问题。  \nb.心跳检测：用心跳检测DataNode的健康状况，如果发现问题就采取数据备份的方式来保证数据的安全性。  \nc.数据复制（场景为DataNode失败、需要平衡DataNode的存储利用率和平衡DataNode数据交互压力等情况）；使用Hadoop时可以用HDFS的balancer命令配置Threshold来平衡每一个DataNode的磁盘利用率。假设设置了Threshold为10%，那么执行balancer命令时，首先会统计所有的DataNode的磁盘利用率的平均值，然后判断如果某一个DataNode的磁盘利用率超过这个平均值，那么将会把这个DataNode的Block转移到磁盘利用率低的DataNode上，这对于新的节点为加入十分有用。  \nd.数据校验：采用CRC32做数据校验。在写入文件块的时候，除了会写入数据外还会写入校验信息，在读取的时候则需要先校验后读入。  \ne.数据管道性的写入：当客户端要写入文件到DataNode上时，首先会读取一个Block，然后将其写到每一个DataNode上，接着由第一个DataNode将其传递到备份的DataNode上，直到所有需要写入这个Block的DataNode都成功写入后，客户端才会开始写下一个Block。  \nf.安全模型：分布式文件系统启动时会进入安全模式（系统运行期间也可以通过命令进入安全模式），当分布式文件处于安全模式时，文件系统中的内容不允许修改也不允许删除，直到安DataNode上数据块的有效性，同时根据策略进行必要的复制或删除部分数据块。在实际操作过程中，如果在系统启动时修改和删除文件会出现安全模式不允许修改的错误提示，只需要等待一会即可。  \n\n\n##HBase的数据管理\nHBase是一个类似Bigtable的分布式数据库，它的大部分特性和Bigtable一样，是一个稀疏的、长期存储的（存在硬盘上）、多维度的排序映射表，这张表的索引是行关键字、列关键字和时间戳。表中的每个值是一个纯字符数组，数据都是字符串，没有类型，所以同一张表中的每一行数据都可以有截然不同的列。列名字的格式是“<family>:<label>\"，它是由字符串组成的，每一张表有一个family集合，这个集合是固定不变的，相当于表的结构，只能通过改变表结构来改变表的family集合。但是label值相对于每一行来说都是可以改变的。  \nHBase把同一个family中的数据存储在同一个目录下，而HB的写操作是锁行的。每一行都是一个原子元素，都可以加锁。所有数据库的更新都有一个时间戳标记，每次更新都会生成一个新的版本，而HBase会保留一定数量的版本，这个值是可以设定的。客户端可以选择获取距离某个时间点最近的版本，或者一次获取所有版本。  \n\n以上从微观上介绍了HBase的一些数据管理措施，那么HBase作为分布式数据为顺整体上从集群出发又是如何管理数据的呢？  \nHBase在分布式集群上主要依赖于HRegion、HMaster、HClient组成的体系结构从整体上管理数据。  \nHBase体系结构有三大重要组成部分：  \na.HBaseMaster：HBase主服务器，与Bigtable的主服务器类似。  \nb.HRegionServer：HBase域服务器，与Bigtable的Tablet服务器类似。  \nc.Hbase Client：HBase客户端是由org.apache.hadoop.Hbase.client.HTable定义的。  \n下面将对这三个组件进行详细的介绍。  \n（1）HBaseMaster  \n一个HBase只部署一台主服务器，它通过领导选举算法确保只有唯一的主服务器是活跃的，ZooKeeper保存主服务器的服务器地址信息。如果主服务器瘫痪，可以通过领导选举算法从备用服务器中选择新的主服务器。  \n主服务器承担着初始化集群的任务。当主服务器每一次启动时，会试图从HDFS获取根或根域目录，如果获取失败则创建根或根域目录，以及第一个元域目录。在下次启动时，主服务器就可以获取集群和集群中所有域 的信息了。同时主服务器还负责集群中域的分配、域服务器运行状态的监控、表格的管理等工作。  \n\n\n（2）HRegionServer  \nHBase域服务器的主要职责有服务于主服务器分配的域、处理端的读写请求、本地缓冲回写、本地数据压缩和分割域等功能。  \n每个域只能由一台域服务器来提供服务。当它开始服务于某域时，它会从HDFS文件系统中读取该域的日志和所有存储文件，同时还会管理操作HDFS文件的持久性存储工作。客户端通过与主服务器通信获取域或域服务器的列表信息后，就可以直接向域服务器发送域读写请求，来完成操作。  \n\n（3）HBaseClient  \n HBase客户端负责查找用户域所在的域服务器地址。HBase客户端会与HBase主机交换消息以查找根域的位置，这是两者之间唯一的交流。  \n定位根域后，客户端连接根域所在的服务器，并扫描根域获取元域信息。元域信息中包含所需用户域的域服务器地址。客户端再连接元域所在的服务器，扫描元域以获取所需用户域所在的域服务器地址。客户端再连接元域所在的域服务器，扫描元域以获取所需用户域所有的域服务器地址。定位用户域后，客户端连接用户域所在的域服务器并发出读写请求。用户域的地址将在客户端被缓存，后续的请求无须重复上述过程。  \n\n综上所述，HBase的体系结构中，HBase主要由主服务器、域服务器和客户端三部分组成。主服务器作为HBase的中心，管理整个集群中的所有域，监控每台域服务器的运行情况等；域服务器接收来自服务器的分配域，处理管理端的域读写请求并回写映射文件等；客户端主要用来查找用户域所在的域服务器地址信息。  \n\n\n##Hive的数据管理  \nHive是建立在Hadoop上的数据仓库基础架构。它提供了一系列的工具，用来进行数据提取、转化、加载，这是一种可以存储、查询和分析存储在Hadoop中的大规模数据的机制。Hive定义了简单的类SQL的查询语言，称为HiveQL，它允许熟悉SQL的用户用SQL语言查询数据。作为一个数据仓库，Hive的数据管理按照使用层次可以从元数据存储、数据存储和数据交换三方面来介绍。  \n（1）元数据存储  \nHive将元数据存储在RDBMS中，有三种模式可以连接到数据库。  \n1）Single User Mode:此模式连接到一个In-memory的数据库Derby，一般用于Unit Test。  \n2）Multi User Mode：通过网络连接到一个数据库中，这是最常用的模式。  \n3）Remote Server Mode：用于非Java客户端访问元数据，在服务器端启动一个MetaStoreServer，客户端利用Thrift协议通过MetaStoreServer来访问元数据库。  \n（2）数据存储  \n首先，Hive没有专门的数据存储格式，也没有为数据建立索引，用户可以非常自由地组织Hive中的表，只需要在创建表的时候告诉Hive数据中的列分隔符和行分隔符，它就可以解析数据了。  \n其次，Hive中所有的数据都存储在HDFS中，Hive中包含4种数据模型：Table、External Table、Partition和Bucket。  \nHive中的Table和数据库中的Table在概念上是类似的，每一个Table在Hive中都有一个相应的目录来存储数据。例如，一个表pvs，它在HDFS中的路径为:/wh/pvs，其中wh是在hive-site.xml中由${hive.metastore.warehouse.dir}指定的数据仓库的目录，所有的Table数据（不包括External Table）都保存在这个目录中。  \n（3）数据交换\n数据交换主要分为以下部分，如图：\n\n\n\na）用户接口：包括客户端、Web界面和数据库接口。  \nb)元数据存储：通常存在在关系型数据库中，如MYSQL、Derby中。  \nc)解释器、编译器、优化器、执行器。  \nd)Hadoop：利用HDFS进行存储，利用MapRecue进行计算。  \n用户接口主要有三个：客户端、数据库接口和Web界面，其中最常用的是客户端。Client是Hive的客户端，当启动Client模式时，用户会想要连接Hive Server，这时需要指出Hive Server所在的节点，并且在该节点启动HiveServer。Web界面是通过浏览器访问Hive的。  \nHive元数据存储在数据库中，如MYSQL、Derby中。Hive中的元数据包括表的名字、表的列、表的分区、表分区的属性、表的属性、表的数据所在目录等。    \n解释器、编译器、优化器完成HiveQL查询语句从记法分析、语法分析、编译、优化到查询计划的生成。生成的查询计划存储在HDFS中，并且随后由MapRecue调用执行。  \nHive的数据存储在HDFS中，大部分的查询由MapRecue完成（包括*的查询不会生成MapRecue任务，比如select * from tbl).  \n\n\n\n\n#安装并运行Hadoop\n介绍Hadoop安装之前，先介绍一下Hadoop对各个节点的角色定义。\nHadoop分别从三个角度将主机划分为两种角色。第一，最基本的划分为Master和Slave，即主人和奴隶；第二，从HDFS的角度，将主机划分为NameNode和DataNode（在分布式文件系统中，目录的管理很重要，管理目录相当于主人，而NameNode就是目录管理者）；第三，从MapRecue的角度，将主机划分为JobTracker和TaskTracker（一个Job经常被划分为多个Task，从这个角度不难理解它们之间的关系）。\n","source":"_posts/hadoop/Hadoop知识点.md","raw":"---\ntitle: Hadoop知识点\ndate: 2017-05-08 23:43:49\ntags: [大数据,hadoop]\ncategories: [大数据,hadoop]\n---\n#Hadoop数据管理\n主要包括Hadoop的分布式文件系统HDFS、分布式数据库HBase和数据仓库工具Hive\n\n##HDFS的数据管理\nHDFS是分布式计算的存储基石，Hadoop分布式文件系统和其它文件系统有很多类似的特性；  \n1）对于整个集群有单一的命名空间；  \n2）具有数据一致性，都适合一次写入多次读取的模型，客户端在文件没有被成功创建之前是无法看到文件存在的。  \n3）文件会被分割成多个文件块，每个文件块被分配存储到数据节点上，而且会根据配置由复制文件块来保证数据的安全性。  \nHDFS有三个重要的角色来进行文件系统的管理：NameNode、DataNode和Client。NameNode可以看做是分布式文件系统的管理者，主要负责管理文件系统的命名空间、集群配置信息和存储块的复制等。NameNode会将文件系统的Metadata存储在内存中，这些信息主要包括文件信息、每一个文件对应的文件块的信息和每一个文件块在DataNode中的信息等。DataNode是文件存储的基本单元，它将文件块（Block）存储在本地文件系统中，保存了所有Block的Metadata，同时周期性地将所有存在的Block信息发送给NameNode。Client就是需要获取分布式文件系统文件的应用程序。接下来三个具体的操作来说明HDFS对数据的管理。  \n（1）文件写入\n1）Client向NameNode发起文件写入的请求。  \n2）NameNode根据文件的大小和文件块配置情况，返回给Client所管理的DataNode的信息。  \n3）Client将文件划分为多个Block，根据DataNode的地址信息，按顺序将其写入到每一个DataNode块中。  \n（2）文件读取  \n1）Client向NameNode发起文件读取的请求。  \n2）NameNode返回文件存储的DataNode信息。  \n3）Client读取文件信息。  \n（3）文件块（Block）复制  \n1）NameNode发现部分文件的Block不符合最小复制数这一要求或部分DataNode失效。  \n2）通知DataNode相互复制Block。  \n3）DataNode开始直接相互复制。  \n\n作为分布式文件系统，HDFS在数据管理方面还有值得借鉴的几个功能：  \na.文件块（Block）的放置：一个Block会有三份备份，一份放在NameNode指定的DataNode上，另一份放在与指定DataNode不在同一机器上的DataNode上，最后一份放在与指定DataNode同一Rack的DataNode上。备份的目的是为了数据安全，采用这种配置方式主要是考虑同一Rack失败的情况，以及不同Rack之间进行数据复制会带来的性能问题。  \nb.心跳检测：用心跳检测DataNode的健康状况，如果发现问题就采取数据备份的方式来保证数据的安全性。  \nc.数据复制（场景为DataNode失败、需要平衡DataNode的存储利用率和平衡DataNode数据交互压力等情况）；使用Hadoop时可以用HDFS的balancer命令配置Threshold来平衡每一个DataNode的磁盘利用率。假设设置了Threshold为10%，那么执行balancer命令时，首先会统计所有的DataNode的磁盘利用率的平均值，然后判断如果某一个DataNode的磁盘利用率超过这个平均值，那么将会把这个DataNode的Block转移到磁盘利用率低的DataNode上，这对于新的节点为加入十分有用。  \nd.数据校验：采用CRC32做数据校验。在写入文件块的时候，除了会写入数据外还会写入校验信息，在读取的时候则需要先校验后读入。  \ne.数据管道性的写入：当客户端要写入文件到DataNode上时，首先会读取一个Block，然后将其写到每一个DataNode上，接着由第一个DataNode将其传递到备份的DataNode上，直到所有需要写入这个Block的DataNode都成功写入后，客户端才会开始写下一个Block。  \nf.安全模型：分布式文件系统启动时会进入安全模式（系统运行期间也可以通过命令进入安全模式），当分布式文件处于安全模式时，文件系统中的内容不允许修改也不允许删除，直到安DataNode上数据块的有效性，同时根据策略进行必要的复制或删除部分数据块。在实际操作过程中，如果在系统启动时修改和删除文件会出现安全模式不允许修改的错误提示，只需要等待一会即可。  \n\n\n##HBase的数据管理\nHBase是一个类似Bigtable的分布式数据库，它的大部分特性和Bigtable一样，是一个稀疏的、长期存储的（存在硬盘上）、多维度的排序映射表，这张表的索引是行关键字、列关键字和时间戳。表中的每个值是一个纯字符数组，数据都是字符串，没有类型，所以同一张表中的每一行数据都可以有截然不同的列。列名字的格式是“<family>:<label>\"，它是由字符串组成的，每一张表有一个family集合，这个集合是固定不变的，相当于表的结构，只能通过改变表结构来改变表的family集合。但是label值相对于每一行来说都是可以改变的。  \nHBase把同一个family中的数据存储在同一个目录下，而HB的写操作是锁行的。每一行都是一个原子元素，都可以加锁。所有数据库的更新都有一个时间戳标记，每次更新都会生成一个新的版本，而HBase会保留一定数量的版本，这个值是可以设定的。客户端可以选择获取距离某个时间点最近的版本，或者一次获取所有版本。  \n\n以上从微观上介绍了HBase的一些数据管理措施，那么HBase作为分布式数据为顺整体上从集群出发又是如何管理数据的呢？  \nHBase在分布式集群上主要依赖于HRegion、HMaster、HClient组成的体系结构从整体上管理数据。  \nHBase体系结构有三大重要组成部分：  \na.HBaseMaster：HBase主服务器，与Bigtable的主服务器类似。  \nb.HRegionServer：HBase域服务器，与Bigtable的Tablet服务器类似。  \nc.Hbase Client：HBase客户端是由org.apache.hadoop.Hbase.client.HTable定义的。  \n下面将对这三个组件进行详细的介绍。  \n（1）HBaseMaster  \n一个HBase只部署一台主服务器，它通过领导选举算法确保只有唯一的主服务器是活跃的，ZooKeeper保存主服务器的服务器地址信息。如果主服务器瘫痪，可以通过领导选举算法从备用服务器中选择新的主服务器。  \n主服务器承担着初始化集群的任务。当主服务器每一次启动时，会试图从HDFS获取根或根域目录，如果获取失败则创建根或根域目录，以及第一个元域目录。在下次启动时，主服务器就可以获取集群和集群中所有域 的信息了。同时主服务器还负责集群中域的分配、域服务器运行状态的监控、表格的管理等工作。  \n\n\n（2）HRegionServer  \nHBase域服务器的主要职责有服务于主服务器分配的域、处理端的读写请求、本地缓冲回写、本地数据压缩和分割域等功能。  \n每个域只能由一台域服务器来提供服务。当它开始服务于某域时，它会从HDFS文件系统中读取该域的日志和所有存储文件，同时还会管理操作HDFS文件的持久性存储工作。客户端通过与主服务器通信获取域或域服务器的列表信息后，就可以直接向域服务器发送域读写请求，来完成操作。  \n\n（3）HBaseClient  \n HBase客户端负责查找用户域所在的域服务器地址。HBase客户端会与HBase主机交换消息以查找根域的位置，这是两者之间唯一的交流。  \n定位根域后，客户端连接根域所在的服务器，并扫描根域获取元域信息。元域信息中包含所需用户域的域服务器地址。客户端再连接元域所在的服务器，扫描元域以获取所需用户域所在的域服务器地址。客户端再连接元域所在的域服务器，扫描元域以获取所需用户域所有的域服务器地址。定位用户域后，客户端连接用户域所在的域服务器并发出读写请求。用户域的地址将在客户端被缓存，后续的请求无须重复上述过程。  \n\n综上所述，HBase的体系结构中，HBase主要由主服务器、域服务器和客户端三部分组成。主服务器作为HBase的中心，管理整个集群中的所有域，监控每台域服务器的运行情况等；域服务器接收来自服务器的分配域，处理管理端的域读写请求并回写映射文件等；客户端主要用来查找用户域所在的域服务器地址信息。  \n\n\n##Hive的数据管理  \nHive是建立在Hadoop上的数据仓库基础架构。它提供了一系列的工具，用来进行数据提取、转化、加载，这是一种可以存储、查询和分析存储在Hadoop中的大规模数据的机制。Hive定义了简单的类SQL的查询语言，称为HiveQL，它允许熟悉SQL的用户用SQL语言查询数据。作为一个数据仓库，Hive的数据管理按照使用层次可以从元数据存储、数据存储和数据交换三方面来介绍。  \n（1）元数据存储  \nHive将元数据存储在RDBMS中，有三种模式可以连接到数据库。  \n1）Single User Mode:此模式连接到一个In-memory的数据库Derby，一般用于Unit Test。  \n2）Multi User Mode：通过网络连接到一个数据库中，这是最常用的模式。  \n3）Remote Server Mode：用于非Java客户端访问元数据，在服务器端启动一个MetaStoreServer，客户端利用Thrift协议通过MetaStoreServer来访问元数据库。  \n（2）数据存储  \n首先，Hive没有专门的数据存储格式，也没有为数据建立索引，用户可以非常自由地组织Hive中的表，只需要在创建表的时候告诉Hive数据中的列分隔符和行分隔符，它就可以解析数据了。  \n其次，Hive中所有的数据都存储在HDFS中，Hive中包含4种数据模型：Table、External Table、Partition和Bucket。  \nHive中的Table和数据库中的Table在概念上是类似的，每一个Table在Hive中都有一个相应的目录来存储数据。例如，一个表pvs，它在HDFS中的路径为:/wh/pvs，其中wh是在hive-site.xml中由${hive.metastore.warehouse.dir}指定的数据仓库的目录，所有的Table数据（不包括External Table）都保存在这个目录中。  \n（3）数据交换\n数据交换主要分为以下部分，如图：\n\n\n\na）用户接口：包括客户端、Web界面和数据库接口。  \nb)元数据存储：通常存在在关系型数据库中，如MYSQL、Derby中。  \nc)解释器、编译器、优化器、执行器。  \nd)Hadoop：利用HDFS进行存储，利用MapRecue进行计算。  \n用户接口主要有三个：客户端、数据库接口和Web界面，其中最常用的是客户端。Client是Hive的客户端，当启动Client模式时，用户会想要连接Hive Server，这时需要指出Hive Server所在的节点，并且在该节点启动HiveServer。Web界面是通过浏览器访问Hive的。  \nHive元数据存储在数据库中，如MYSQL、Derby中。Hive中的元数据包括表的名字、表的列、表的分区、表分区的属性、表的属性、表的数据所在目录等。    \n解释器、编译器、优化器完成HiveQL查询语句从记法分析、语法分析、编译、优化到查询计划的生成。生成的查询计划存储在HDFS中，并且随后由MapRecue调用执行。  \nHive的数据存储在HDFS中，大部分的查询由MapRecue完成（包括*的查询不会生成MapRecue任务，比如select * from tbl).  \n\n\n\n\n#安装并运行Hadoop\n介绍Hadoop安装之前，先介绍一下Hadoop对各个节点的角色定义。\nHadoop分别从三个角度将主机划分为两种角色。第一，最基本的划分为Master和Slave，即主人和奴隶；第二，从HDFS的角度，将主机划分为NameNode和DataNode（在分布式文件系统中，目录的管理很重要，管理目录相当于主人，而NameNode就是目录管理者）；第三，从MapRecue的角度，将主机划分为JobTracker和TaskTracker（一个Job经常被划分为多个Task，从这个角度不难理解它们之间的关系）。\n","slug":"hadoop/Hadoop知识点","published":1,"updated":"2017-08-18T01:44:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bme009os77rlxs865e7","content":"<p>#Hadoop数据管理<br>主要包括Hadoop的分布式文件系统HDFS、分布式数据库HBase和数据仓库工具Hive</p>\n<p>##HDFS的数据管理<br>HDFS是分布式计算的存储基石，Hadoop分布式文件系统和其它文件系统有很多类似的特性；<br>1）对于整个集群有单一的命名空间；<br>2）具有数据一致性，都适合一次写入多次读取的模型，客户端在文件没有被成功创建之前是无法看到文件存在的。<br>3）文件会被分割成多个文件块，每个文件块被分配存储到数据节点上，而且会根据配置由复制文件块来保证数据的安全性。<br>HDFS有三个重要的角色来进行文件系统的管理：NameNode、DataNode和Client。NameNode可以看做是分布式文件系统的管理者，主要负责管理文件系统的命名空间、集群配置信息和存储块的复制等。NameNode会将文件系统的Metadata存储在内存中，这些信息主要包括文件信息、每一个文件对应的文件块的信息和每一个文件块在DataNode中的信息等。DataNode是文件存储的基本单元，它将文件块（Block）存储在本地文件系统中，保存了所有Block的Metadata，同时周期性地将所有存在的Block信息发送给NameNode。Client就是需要获取分布式文件系统文件的应用程序。接下来三个具体的操作来说明HDFS对数据的管理。<br>（1）文件写入<br>1）Client向NameNode发起文件写入的请求。<br>2）NameNode根据文件的大小和文件块配置情况，返回给Client所管理的DataNode的信息。<br>3）Client将文件划分为多个Block，根据DataNode的地址信息，按顺序将其写入到每一个DataNode块中。<br>（2）文件读取<br>1）Client向NameNode发起文件读取的请求。<br>2）NameNode返回文件存储的DataNode信息。<br>3）Client读取文件信息。<br>（3）文件块（Block）复制<br>1）NameNode发现部分文件的Block不符合最小复制数这一要求或部分DataNode失效。<br>2）通知DataNode相互复制Block。<br>3）DataNode开始直接相互复制。  </p>\n<p>作为分布式文件系统，HDFS在数据管理方面还有值得借鉴的几个功能：<br>a.文件块（Block）的放置：一个Block会有三份备份，一份放在NameNode指定的DataNode上，另一份放在与指定DataNode不在同一机器上的DataNode上，最后一份放在与指定DataNode同一Rack的DataNode上。备份的目的是为了数据安全，采用这种配置方式主要是考虑同一Rack失败的情况，以及不同Rack之间进行数据复制会带来的性能问题。<br>b.心跳检测：用心跳检测DataNode的健康状况，如果发现问题就采取数据备份的方式来保证数据的安全性。<br>c.数据复制（场景为DataNode失败、需要平衡DataNode的存储利用率和平衡DataNode数据交互压力等情况）；使用Hadoop时可以用HDFS的balancer命令配置Threshold来平衡每一个DataNode的磁盘利用率。假设设置了Threshold为10%，那么执行balancer命令时，首先会统计所有的DataNode的磁盘利用率的平均值，然后判断如果某一个DataNode的磁盘利用率超过这个平均值，那么将会把这个DataNode的Block转移到磁盘利用率低的DataNode上，这对于新的节点为加入十分有用。<br>d.数据校验：采用CRC32做数据校验。在写入文件块的时候，除了会写入数据外还会写入校验信息，在读取的时候则需要先校验后读入。<br>e.数据管道性的写入：当客户端要写入文件到DataNode上时，首先会读取一个Block，然后将其写到每一个DataNode上，接着由第一个DataNode将其传递到备份的DataNode上，直到所有需要写入这个Block的DataNode都成功写入后，客户端才会开始写下一个Block。<br>f.安全模型：分布式文件系统启动时会进入安全模式（系统运行期间也可以通过命令进入安全模式），当分布式文件处于安全模式时，文件系统中的内容不允许修改也不允许删除，直到安DataNode上数据块的有效性，同时根据策略进行必要的复制或删除部分数据块。在实际操作过程中，如果在系统启动时修改和删除文件会出现安全模式不允许修改的错误提示，只需要等待一会即可。  </p>\n<p>##HBase的数据管理<br>HBase是一个类似Bigtable的分布式数据库，它的大部分特性和Bigtable一样，是一个稀疏的、长期存储的（存在硬盘上）、多维度的排序映射表，这张表的索引是行关键字、列关键字和时间戳。表中的每个值是一个纯字符数组，数据都是字符串，没有类型，所以同一张表中的每一行数据都可以有截然不同的列。列名字的格式是“<family>:<label>“，它是由字符串组成的，每一张表有一个family集合，这个集合是固定不变的，相当于表的结构，只能通过改变表结构来改变表的family集合。但是label值相对于每一行来说都是可以改变的。<br>HBase把同一个family中的数据存储在同一个目录下，而HB的写操作是锁行的。每一行都是一个原子元素，都可以加锁。所有数据库的更新都有一个时间戳标记，每次更新都会生成一个新的版本，而HBase会保留一定数量的版本，这个值是可以设定的。客户端可以选择获取距离某个时间点最近的版本，或者一次获取所有版本。  </label></family></p>\n<p>以上从微观上介绍了HBase的一些数据管理措施，那么HBase作为分布式数据为顺整体上从集群出发又是如何管理数据的呢？<br>HBase在分布式集群上主要依赖于HRegion、HMaster、HClient组成的体系结构从整体上管理数据。<br>HBase体系结构有三大重要组成部分：<br>a.HBaseMaster：HBase主服务器，与Bigtable的主服务器类似。<br>b.HRegionServer：HBase域服务器，与Bigtable的Tablet服务器类似。<br>c.Hbase Client：HBase客户端是由org.apache.hadoop.Hbase.client.HTable定义的。<br>下面将对这三个组件进行详细的介绍。<br>（1）HBaseMaster<br>一个HBase只部署一台主服务器，它通过领导选举算法确保只有唯一的主服务器是活跃的，ZooKeeper保存主服务器的服务器地址信息。如果主服务器瘫痪，可以通过领导选举算法从备用服务器中选择新的主服务器。<br>主服务器承担着初始化集群的任务。当主服务器每一次启动时，会试图从HDFS获取根或根域目录，如果获取失败则创建根或根域目录，以及第一个元域目录。在下次启动时，主服务器就可以获取集群和集群中所有域 的信息了。同时主服务器还负责集群中域的分配、域服务器运行状态的监控、表格的管理等工作。  </p>\n<p>（2）HRegionServer<br>HBase域服务器的主要职责有服务于主服务器分配的域、处理端的读写请求、本地缓冲回写、本地数据压缩和分割域等功能。<br>每个域只能由一台域服务器来提供服务。当它开始服务于某域时，它会从HDFS文件系统中读取该域的日志和所有存储文件，同时还会管理操作HDFS文件的持久性存储工作。客户端通过与主服务器通信获取域或域服务器的列表信息后，就可以直接向域服务器发送域读写请求，来完成操作。  </p>\n<p>（3）HBaseClient<br> HBase客户端负责查找用户域所在的域服务器地址。HBase客户端会与HBase主机交换消息以查找根域的位置，这是两者之间唯一的交流。<br>定位根域后，客户端连接根域所在的服务器，并扫描根域获取元域信息。元域信息中包含所需用户域的域服务器地址。客户端再连接元域所在的服务器，扫描元域以获取所需用户域所在的域服务器地址。客户端再连接元域所在的域服务器，扫描元域以获取所需用户域所有的域服务器地址。定位用户域后，客户端连接用户域所在的域服务器并发出读写请求。用户域的地址将在客户端被缓存，后续的请求无须重复上述过程。  </p>\n<p>综上所述，HBase的体系结构中，HBase主要由主服务器、域服务器和客户端三部分组成。主服务器作为HBase的中心，管理整个集群中的所有域，监控每台域服务器的运行情况等；域服务器接收来自服务器的分配域，处理管理端的域读写请求并回写映射文件等；客户端主要用来查找用户域所在的域服务器地址信息。  </p>\n<p>##Hive的数据管理<br>Hive是建立在Hadoop上的数据仓库基础架构。它提供了一系列的工具，用来进行数据提取、转化、加载，这是一种可以存储、查询和分析存储在Hadoop中的大规模数据的机制。Hive定义了简单的类SQL的查询语言，称为HiveQL，它允许熟悉SQL的用户用SQL语言查询数据。作为一个数据仓库，Hive的数据管理按照使用层次可以从元数据存储、数据存储和数据交换三方面来介绍。<br>（1）元数据存储<br>Hive将元数据存储在RDBMS中，有三种模式可以连接到数据库。<br>1）Single User Mode:此模式连接到一个In-memory的数据库Derby，一般用于Unit Test。<br>2）Multi User Mode：通过网络连接到一个数据库中，这是最常用的模式。<br>3）Remote Server Mode：用于非Java客户端访问元数据，在服务器端启动一个MetaStoreServer，客户端利用Thrift协议通过MetaStoreServer来访问元数据库。<br>（2）数据存储<br>首先，Hive没有专门的数据存储格式，也没有为数据建立索引，用户可以非常自由地组织Hive中的表，只需要在创建表的时候告诉Hive数据中的列分隔符和行分隔符，它就可以解析数据了。<br>其次，Hive中所有的数据都存储在HDFS中，Hive中包含4种数据模型：Table、External Table、Partition和Bucket。<br>Hive中的Table和数据库中的Table在概念上是类似的，每一个Table在Hive中都有一个相应的目录来存储数据。例如，一个表pvs，它在HDFS中的路径为:/wh/pvs，其中wh是在hive-site.xml中由${hive.metastore.warehouse.dir}指定的数据仓库的目录，所有的Table数据（不包括External Table）都保存在这个目录中。<br>（3）数据交换<br>数据交换主要分为以下部分，如图：</p>\n<p>a）用户接口：包括客户端、Web界面和数据库接口。<br>b)元数据存储：通常存在在关系型数据库中，如MYSQL、Derby中。<br>c)解释器、编译器、优化器、执行器。<br>d)Hadoop：利用HDFS进行存储，利用MapRecue进行计算。<br>用户接口主要有三个：客户端、数据库接口和Web界面，其中最常用的是客户端。Client是Hive的客户端，当启动Client模式时，用户会想要连接Hive Server，这时需要指出Hive Server所在的节点，并且在该节点启动HiveServer。Web界面是通过浏览器访问Hive的。<br>Hive元数据存储在数据库中，如MYSQL、Derby中。Hive中的元数据包括表的名字、表的列、表的分区、表分区的属性、表的属性、表的数据所在目录等。<br>解释器、编译器、优化器完成HiveQL查询语句从记法分析、语法分析、编译、优化到查询计划的生成。生成的查询计划存储在HDFS中，并且随后由MapRecue调用执行。<br>Hive的数据存储在HDFS中，大部分的查询由MapRecue完成（包括<em>的查询不会生成MapRecue任务，比如select </em> from tbl).  </p>\n<p>#安装并运行Hadoop<br>介绍Hadoop安装之前，先介绍一下Hadoop对各个节点的角色定义。<br>Hadoop分别从三个角度将主机划分为两种角色。第一，最基本的划分为Master和Slave，即主人和奴隶；第二，从HDFS的角度，将主机划分为NameNode和DataNode（在分布式文件系统中，目录的管理很重要，管理目录相当于主人，而NameNode就是目录管理者）；第三，从MapRecue的角度，将主机划分为JobTracker和TaskTracker（一个Job经常被划分为多个Task，从这个角度不难理解它们之间的关系）。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>#Hadoop数据管理<br>主要包括Hadoop的分布式文件系统HDFS、分布式数据库HBase和数据仓库工具Hive</p>\n<p>##HDFS的数据管理<br>HDFS是分布式计算的存储基石，Hadoop分布式文件系统和其它文件系统有很多类似的特性；<br>1）对于整个集群有单一的命名空间；<br>2）具有数据一致性，都适合一次写入多次读取的模型，客户端在文件没有被成功创建之前是无法看到文件存在的。<br>3）文件会被分割成多个文件块，每个文件块被分配存储到数据节点上，而且会根据配置由复制文件块来保证数据的安全性。<br>HDFS有三个重要的角色来进行文件系统的管理：NameNode、DataNode和Client。NameNode可以看做是分布式文件系统的管理者，主要负责管理文件系统的命名空间、集群配置信息和存储块的复制等。NameNode会将文件系统的Metadata存储在内存中，这些信息主要包括文件信息、每一个文件对应的文件块的信息和每一个文件块在DataNode中的信息等。DataNode是文件存储的基本单元，它将文件块（Block）存储在本地文件系统中，保存了所有Block的Metadata，同时周期性地将所有存在的Block信息发送给NameNode。Client就是需要获取分布式文件系统文件的应用程序。接下来三个具体的操作来说明HDFS对数据的管理。<br>（1）文件写入<br>1）Client向NameNode发起文件写入的请求。<br>2）NameNode根据文件的大小和文件块配置情况，返回给Client所管理的DataNode的信息。<br>3）Client将文件划分为多个Block，根据DataNode的地址信息，按顺序将其写入到每一个DataNode块中。<br>（2）文件读取<br>1）Client向NameNode发起文件读取的请求。<br>2）NameNode返回文件存储的DataNode信息。<br>3）Client读取文件信息。<br>（3）文件块（Block）复制<br>1）NameNode发现部分文件的Block不符合最小复制数这一要求或部分DataNode失效。<br>2）通知DataNode相互复制Block。<br>3）DataNode开始直接相互复制。  </p>\n<p>作为分布式文件系统，HDFS在数据管理方面还有值得借鉴的几个功能：<br>a.文件块（Block）的放置：一个Block会有三份备份，一份放在NameNode指定的DataNode上，另一份放在与指定DataNode不在同一机器上的DataNode上，最后一份放在与指定DataNode同一Rack的DataNode上。备份的目的是为了数据安全，采用这种配置方式主要是考虑同一Rack失败的情况，以及不同Rack之间进行数据复制会带来的性能问题。<br>b.心跳检测：用心跳检测DataNode的健康状况，如果发现问题就采取数据备份的方式来保证数据的安全性。<br>c.数据复制（场景为DataNode失败、需要平衡DataNode的存储利用率和平衡DataNode数据交互压力等情况）；使用Hadoop时可以用HDFS的balancer命令配置Threshold来平衡每一个DataNode的磁盘利用率。假设设置了Threshold为10%，那么执行balancer命令时，首先会统计所有的DataNode的磁盘利用率的平均值，然后判断如果某一个DataNode的磁盘利用率超过这个平均值，那么将会把这个DataNode的Block转移到磁盘利用率低的DataNode上，这对于新的节点为加入十分有用。<br>d.数据校验：采用CRC32做数据校验。在写入文件块的时候，除了会写入数据外还会写入校验信息，在读取的时候则需要先校验后读入。<br>e.数据管道性的写入：当客户端要写入文件到DataNode上时，首先会读取一个Block，然后将其写到每一个DataNode上，接着由第一个DataNode将其传递到备份的DataNode上，直到所有需要写入这个Block的DataNode都成功写入后，客户端才会开始写下一个Block。<br>f.安全模型：分布式文件系统启动时会进入安全模式（系统运行期间也可以通过命令进入安全模式），当分布式文件处于安全模式时，文件系统中的内容不允许修改也不允许删除，直到安DataNode上数据块的有效性，同时根据策略进行必要的复制或删除部分数据块。在实际操作过程中，如果在系统启动时修改和删除文件会出现安全模式不允许修改的错误提示，只需要等待一会即可。  </p>\n<p>##HBase的数据管理<br>HBase是一个类似Bigtable的分布式数据库，它的大部分特性和Bigtable一样，是一个稀疏的、长期存储的（存在硬盘上）、多维度的排序映射表，这张表的索引是行关键字、列关键字和时间戳。表中的每个值是一个纯字符数组，数据都是字符串，没有类型，所以同一张表中的每一行数据都可以有截然不同的列。列名字的格式是“<family>:<label>“，它是由字符串组成的，每一张表有一个family集合，这个集合是固定不变的，相当于表的结构，只能通过改变表结构来改变表的family集合。但是label值相对于每一行来说都是可以改变的。<br>HBase把同一个family中的数据存储在同一个目录下，而HB的写操作是锁行的。每一行都是一个原子元素，都可以加锁。所有数据库的更新都有一个时间戳标记，每次更新都会生成一个新的版本，而HBase会保留一定数量的版本，这个值是可以设定的。客户端可以选择获取距离某个时间点最近的版本，或者一次获取所有版本。  </label></family></p>\n<p>以上从微观上介绍了HBase的一些数据管理措施，那么HBase作为分布式数据为顺整体上从集群出发又是如何管理数据的呢？<br>HBase在分布式集群上主要依赖于HRegion、HMaster、HClient组成的体系结构从整体上管理数据。<br>HBase体系结构有三大重要组成部分：<br>a.HBaseMaster：HBase主服务器，与Bigtable的主服务器类似。<br>b.HRegionServer：HBase域服务器，与Bigtable的Tablet服务器类似。<br>c.Hbase Client：HBase客户端是由org.apache.hadoop.Hbase.client.HTable定义的。<br>下面将对这三个组件进行详细的介绍。<br>（1）HBaseMaster<br>一个HBase只部署一台主服务器，它通过领导选举算法确保只有唯一的主服务器是活跃的，ZooKeeper保存主服务器的服务器地址信息。如果主服务器瘫痪，可以通过领导选举算法从备用服务器中选择新的主服务器。<br>主服务器承担着初始化集群的任务。当主服务器每一次启动时，会试图从HDFS获取根或根域目录，如果获取失败则创建根或根域目录，以及第一个元域目录。在下次启动时，主服务器就可以获取集群和集群中所有域 的信息了。同时主服务器还负责集群中域的分配、域服务器运行状态的监控、表格的管理等工作。  </p>\n<p>（2）HRegionServer<br>HBase域服务器的主要职责有服务于主服务器分配的域、处理端的读写请求、本地缓冲回写、本地数据压缩和分割域等功能。<br>每个域只能由一台域服务器来提供服务。当它开始服务于某域时，它会从HDFS文件系统中读取该域的日志和所有存储文件，同时还会管理操作HDFS文件的持久性存储工作。客户端通过与主服务器通信获取域或域服务器的列表信息后，就可以直接向域服务器发送域读写请求，来完成操作。  </p>\n<p>（3）HBaseClient<br> HBase客户端负责查找用户域所在的域服务器地址。HBase客户端会与HBase主机交换消息以查找根域的位置，这是两者之间唯一的交流。<br>定位根域后，客户端连接根域所在的服务器，并扫描根域获取元域信息。元域信息中包含所需用户域的域服务器地址。客户端再连接元域所在的服务器，扫描元域以获取所需用户域所在的域服务器地址。客户端再连接元域所在的域服务器，扫描元域以获取所需用户域所有的域服务器地址。定位用户域后，客户端连接用户域所在的域服务器并发出读写请求。用户域的地址将在客户端被缓存，后续的请求无须重复上述过程。  </p>\n<p>综上所述，HBase的体系结构中，HBase主要由主服务器、域服务器和客户端三部分组成。主服务器作为HBase的中心，管理整个集群中的所有域，监控每台域服务器的运行情况等；域服务器接收来自服务器的分配域，处理管理端的域读写请求并回写映射文件等；客户端主要用来查找用户域所在的域服务器地址信息。  </p>\n<p>##Hive的数据管理<br>Hive是建立在Hadoop上的数据仓库基础架构。它提供了一系列的工具，用来进行数据提取、转化、加载，这是一种可以存储、查询和分析存储在Hadoop中的大规模数据的机制。Hive定义了简单的类SQL的查询语言，称为HiveQL，它允许熟悉SQL的用户用SQL语言查询数据。作为一个数据仓库，Hive的数据管理按照使用层次可以从元数据存储、数据存储和数据交换三方面来介绍。<br>（1）元数据存储<br>Hive将元数据存储在RDBMS中，有三种模式可以连接到数据库。<br>1）Single User Mode:此模式连接到一个In-memory的数据库Derby，一般用于Unit Test。<br>2）Multi User Mode：通过网络连接到一个数据库中，这是最常用的模式。<br>3）Remote Server Mode：用于非Java客户端访问元数据，在服务器端启动一个MetaStoreServer，客户端利用Thrift协议通过MetaStoreServer来访问元数据库。<br>（2）数据存储<br>首先，Hive没有专门的数据存储格式，也没有为数据建立索引，用户可以非常自由地组织Hive中的表，只需要在创建表的时候告诉Hive数据中的列分隔符和行分隔符，它就可以解析数据了。<br>其次，Hive中所有的数据都存储在HDFS中，Hive中包含4种数据模型：Table、External Table、Partition和Bucket。<br>Hive中的Table和数据库中的Table在概念上是类似的，每一个Table在Hive中都有一个相应的目录来存储数据。例如，一个表pvs，它在HDFS中的路径为:/wh/pvs，其中wh是在hive-site.xml中由${hive.metastore.warehouse.dir}指定的数据仓库的目录，所有的Table数据（不包括External Table）都保存在这个目录中。<br>（3）数据交换<br>数据交换主要分为以下部分，如图：</p>\n<p>a）用户接口：包括客户端、Web界面和数据库接口。<br>b)元数据存储：通常存在在关系型数据库中，如MYSQL、Derby中。<br>c)解释器、编译器、优化器、执行器。<br>d)Hadoop：利用HDFS进行存储，利用MapRecue进行计算。<br>用户接口主要有三个：客户端、数据库接口和Web界面，其中最常用的是客户端。Client是Hive的客户端，当启动Client模式时，用户会想要连接Hive Server，这时需要指出Hive Server所在的节点，并且在该节点启动HiveServer。Web界面是通过浏览器访问Hive的。<br>Hive元数据存储在数据库中，如MYSQL、Derby中。Hive中的元数据包括表的名字、表的列、表的分区、表分区的属性、表的属性、表的数据所在目录等。<br>解释器、编译器、优化器完成HiveQL查询语句从记法分析、语法分析、编译、优化到查询计划的生成。生成的查询计划存储在HDFS中，并且随后由MapRecue调用执行。<br>Hive的数据存储在HDFS中，大部分的查询由MapRecue完成（包括<em>的查询不会生成MapRecue任务，比如select </em> from tbl).  </p>\n<p>#安装并运行Hadoop<br>介绍Hadoop安装之前，先介绍一下Hadoop对各个节点的角色定义。<br>Hadoop分别从三个角度将主机划分为两种角色。第一，最基本的划分为Master和Slave，即主人和奴隶；第二，从HDFS的角度，将主机划分为NameNode和DataNode（在分布式文件系统中，目录的管理很重要，管理目录相当于主人，而NameNode就是目录管理者）；第三，从MapRecue的角度，将主机划分为JobTracker和TaskTracker（一个Job经常被划分为多个Task，从这个角度不难理解它们之间的关系）。</p>\n"},{"title":"消息传送基础","date":"2016-05-21T15:43:49.000Z","_content":"# 消息传送基础\n\n## 消息传送模型\n\tJMS支持两种消息传送模型：点对点模型和发布/订阅模型。有时候，又称这些消息传送模型为消息传送域。点对点消息传送模型和发布/订阅消息传送模型经常分别缩写为p2p和Pub/Sub。\n\n\t从JMS的视角来看，消息传送客户端称为JMS客户端(JMS Client)，而消息传送系统则称为JMS提供者（JMS provider）。一个JMS应用程序是由多个JMS客户端和（通常是）一个JMS提供者所组成的业务系统。\n\t此外，生产消息的JMS客户端称为消息生产者（message produceer），而接收消息的JMS客户端则称为消息消费者(message consumer)。一个JMS客户端可以既是消息生产者又是消息消费者。\n### 点对点模型\n\t点对点消息传送模型允许JMS客户端通过队列（queue）这个虚拟通道来同步和异步发送、接收消息。在点对点模型中，消息生产者称为发送者（Sender），而消息消费者则称为接收者（receiver）。传统上，点对点模型是一个基于拉取(Pull)或基于轮询(polling)的消息传送模型，这种模型从队列中请求消息，而不是自动地将消息推送到客户端。点对点消息传递模型的一个突出特点就是：发送到队列的消息被一个而且仅仅一个接收者所接收，即使可能有多个接收者在一个队列中侦听同一消息时，也是如此。\n\t点对点消息传送模型既支持异步“即发即弃（fire and forget）”消息传送方式，又支持同步请求/应答消息传送方式。点对点消息传送模型比发布订阅模型具有更强的耦合性，发磅者通常会知道消息初如何使用，而且也会知道谁将接收该消息。举例来说，发送者可能会向一个队列发送一个证券交易订单并等待响应，响应中应包含一个交易确认码。这样一来，消息发送者就会知道消息接收者将来处理交易订单。另一个例子就是一个生成长时间运行报告的异步请求。发送者发出报告请求，而当该报告准备就绪时，就会给发送者发送一条通知消息。在这种情况下，发送者就会知道消息接收者将要处理该消息并创建报告。\n\t点对点模型支持负载均衡，它允许多个接收者侦听同一个队列，并以此来分配负载。JMS规范没有规定在多个接收者中间分发消息的规则，尽管某些JMS厂商已经选择实现些规则来提升负载均衡能力。点对点模型还具有其他优点，比如说，队列浏览器允许客户端在消费龅牙消息之前查看队列内容—--在发布订阅模型中，并没有这样浏览器的概念。\n### 发布/订阅模型\n\t在发布订阅模型中，消息会被发布到一个名为主题（topic）的虚拟通道中。消息生产者称为发布者(publisher)，而消息消费者则称为订阅者（subscriber）。与点对点模型不同，使用发布订阅模型发布一个主题的消息，能够由多个订阅者所接收。有时候，也称这项技术为广播(broadcasting)消息。每个订阅者都会接收到每条消息的一个副本。总地来说，发布订阅消息传送模型基本上是一个基于推送(push)的模型，其中消息自动地向消费者广播，它们无须请求或轮询主题来获得新消息。\n\t发布订阅模型的去耦能力要比p2p模型更强，消息发布者通常不会意识到有多少订阅者或那些订阅者如何处理这些消息。举例来说，假定每次在Java应用程序发生异常时，向一个主题发布一条消息。发布者的责任仅仅是广播发生了一个异常。该发布者不会知道或者说通常也不关心如何使用该消息。例如，有可能是订阅者根据该异常向开发人员或支持人员发送一封电子邮件，也有可能是订阅者收集不同类型的异常数目用于生成报告，甚至是订阅者根据异常的类型，使用这个信息来通知随叫随到(on-call)的技术人员。\n\t在发布订阅消息传送模型内部，有多种不同类型的订阅者。非持久订阅者是临时订阅类型，它们只是在主动侦听主题时才接收消息。而另一方面，持久订阅者将接收发布的每条消息的一个副本，即便在发布消息，它们处于“离线’状态时也是如此。另外还有动态持久订阅者和受管的持久订阅者等类型。\n\n## Rpc和异步消息传送\n\tRPC(Remote Procedure Call，远程过程调用)是通常用于描述分布式计算模型的术语。现在Java和.Net这两种平台都在使用这个术语。基于组件的体系结构，比如企业级JavaBean（Enterprise JavaBeans，EJB），就是建立在这个模型基础之上的。对于许多应用程序来说，基于RPC的技术已经是，并且将继续是切实可行的解决方案。不过，企业消息传送模型在特定类型的分布式应用程序中表现更为出色。在本节中，我们将讨论每种模型的优缺点。\n### 紧密耦合的rpc\n\t紧密耦合的RPC模型最为成功的一个领域就是构建3层或n层应用程序。在这个模型中，表示层（第1层）使用RPC和中间层（第2层）的业务逻辑进行通信，访问位于后端（第3层）的数据。Sun Microsystems公司的J2EE平台和Microsoft公司的.NET平台是这种体系结构最为先进的范例。\n\t使用J2EE、JSP和Servlet技术的表示层，而企业级JavaBean（EJB）则是中间层。抛开平台不论，这些系统使用的核心技术是基于成为定义通信范例的RPC的中间件。\n\tRPC试图模仿在一个进程中运行的某个系统的行为。在调用一个远程过程时，调用者将被阻塞，直到该过程完成并将控制权返回给调用者。从开发者的角度看，这种同步模型使得该系统就好像运行在一个进程当中。这些工作会依次完成，同时确保以顺序完成。RPC同步的本质特性，将客户端（进行调用的软件）和服务器（为该调用服务的软件）二者紧密耦合在一起。因为客户端已被阻塞，所以它无法继续进行工作。直到服务器做出响应为止。\n\tRPC紧密耦合的本质特性导致出现了相互高度依赖的系统，其中一个系统的失效会对其它系统产生立竿见影的弱化影响。例如，在J2EE中，如果期望使用企业级bean的servlet顺利工作，EJB服务器就必须正常地发挥功能。\n\t虽然RPC在许多场景中表现优秀，但是在系统对系统的处理过程当中，它的同步、紧密耦合等本质却是一个严重的缺陷，因为”系统对系统“有很多垂直的应用程序集成在一起。在系统对系统场景中，垂直系统之间的通信线程不仅数量众多、而且方向也是错综复杂，如下图：\n \n\t让我们设想一下使用紧密救命的RPC机制实现这种基础设施所面临的挑战。这些系统之间的连接管理是多对多的问题。当您身混合系统中加入另一个应用程序时，您不得不回过头来让其余所有的系统都知道它，而且，这些系统也会崩溃(crash)。它们仍然需要预定停工时间，而且对象的接口也需要升级。\n\t当该系统的一部分中断运行时，一切都停步。当您向一个订单输入系统添加订单时，它要对其他系统逐个进行同步调用。这会导致订单输入系统发生阻塞，并一直等待，直到每个系统都处理完成订单时为止。\n\t\n\t正是的PC系统的同步、紧密耦合、相互依赖等本质特性，便得子系统中出现的故障最终会导致整个系统的失效。就像在”系统对系统“场景中那样，当RPC紧密耦合的本质特性不再适用时，消息传送机制为此提供了另一种选择方案。\n### 企业消息传送\n\t各个子系统在可用性方面存在的问题，并不是使用面向消息的中间件所事业来的后果。消息传送机制的一个基本思想就是：规定应用程序之间的通信应该采用异步方式。将各部分连接在一些的代码会假定这是一条单身消息，它不需要立即从另一个应用程序那里得到响应。换句话说，它不必等待对这条消息的响应。这是RPC和异步消息传送之间的主要区别，而且，它对于 理解消息传送系统的优点来说至关重要。\n\t在一个异步消息传送系统当中，每个子系统（收款、存货等）都不存在和其他系统的耦合。它们通过消息传送服务顺进行通信，因此，某个子系统出现故障，并不会妨碍其他子系统的运行。如下图：\n\n\t在网络化系统中会出现局部故障，这是一个不可避免的事实。其中的一个系统，可能会在其连接运行期间的某个时刻，发生不可预测的故障，或者需要停机。这种现象可能会由于内部系统和合作系统地理上的分散而被进一步放大。考虑到这个因素，JMS提供了保证传送（guaranteed delivery）方式，它可以确保即便发生了局部故障，预定消费者最终也会接收到这条消息。\n\t保证传送使用的是一种”保存并转发（store-and-forward）”的机制，这就意味着，如果预定消费者当前并不可用，底层消息服务器就会将输入的消息写到一个持久存储器（persistent store）之中。随后，当该接收应用程序变为可用时，“保存并转发”机制会把预定消费者在不可用时错过的所有消息传送给它们。\n\n\t概括来说，JMS不仅仅是另外一种事件服务。它的设计涵盖了范围极广的企业应用程序，包括EAI、B2B和摄像头模型等。通过异步处理、“保存并转发”及“保证传送”机制，它为保持业务应用程序连续运行并实现不间断服务提供了很高的可用性。它还通过发布订阅功能和点对点功能，提供了集成灵活性。通过位置透明和管理控制，它提供了一种健壮的、基于服务的体系结构。而且，最重要的是，它非常易于学习和使用。\n","source":"_posts/java/消息传送基础.md","raw":"---\ntitle: 消息传送基础\ndate: 2016-05-21 23:43:49\ntags: [java,jms]\ncategories: [java,jms]\n---\n# 消息传送基础\n\n## 消息传送模型\n\tJMS支持两种消息传送模型：点对点模型和发布/订阅模型。有时候，又称这些消息传送模型为消息传送域。点对点消息传送模型和发布/订阅消息传送模型经常分别缩写为p2p和Pub/Sub。\n\n\t从JMS的视角来看，消息传送客户端称为JMS客户端(JMS Client)，而消息传送系统则称为JMS提供者（JMS provider）。一个JMS应用程序是由多个JMS客户端和（通常是）一个JMS提供者所组成的业务系统。\n\t此外，生产消息的JMS客户端称为消息生产者（message produceer），而接收消息的JMS客户端则称为消息消费者(message consumer)。一个JMS客户端可以既是消息生产者又是消息消费者。\n### 点对点模型\n\t点对点消息传送模型允许JMS客户端通过队列（queue）这个虚拟通道来同步和异步发送、接收消息。在点对点模型中，消息生产者称为发送者（Sender），而消息消费者则称为接收者（receiver）。传统上，点对点模型是一个基于拉取(Pull)或基于轮询(polling)的消息传送模型，这种模型从队列中请求消息，而不是自动地将消息推送到客户端。点对点消息传递模型的一个突出特点就是：发送到队列的消息被一个而且仅仅一个接收者所接收，即使可能有多个接收者在一个队列中侦听同一消息时，也是如此。\n\t点对点消息传送模型既支持异步“即发即弃（fire and forget）”消息传送方式，又支持同步请求/应答消息传送方式。点对点消息传送模型比发布订阅模型具有更强的耦合性，发磅者通常会知道消息初如何使用，而且也会知道谁将接收该消息。举例来说，发送者可能会向一个队列发送一个证券交易订单并等待响应，响应中应包含一个交易确认码。这样一来，消息发送者就会知道消息接收者将来处理交易订单。另一个例子就是一个生成长时间运行报告的异步请求。发送者发出报告请求，而当该报告准备就绪时，就会给发送者发送一条通知消息。在这种情况下，发送者就会知道消息接收者将要处理该消息并创建报告。\n\t点对点模型支持负载均衡，它允许多个接收者侦听同一个队列，并以此来分配负载。JMS规范没有规定在多个接收者中间分发消息的规则，尽管某些JMS厂商已经选择实现些规则来提升负载均衡能力。点对点模型还具有其他优点，比如说，队列浏览器允许客户端在消费龅牙消息之前查看队列内容—--在发布订阅模型中，并没有这样浏览器的概念。\n### 发布/订阅模型\n\t在发布订阅模型中，消息会被发布到一个名为主题（topic）的虚拟通道中。消息生产者称为发布者(publisher)，而消息消费者则称为订阅者（subscriber）。与点对点模型不同，使用发布订阅模型发布一个主题的消息，能够由多个订阅者所接收。有时候，也称这项技术为广播(broadcasting)消息。每个订阅者都会接收到每条消息的一个副本。总地来说，发布订阅消息传送模型基本上是一个基于推送(push)的模型，其中消息自动地向消费者广播，它们无须请求或轮询主题来获得新消息。\n\t发布订阅模型的去耦能力要比p2p模型更强，消息发布者通常不会意识到有多少订阅者或那些订阅者如何处理这些消息。举例来说，假定每次在Java应用程序发生异常时，向一个主题发布一条消息。发布者的责任仅仅是广播发生了一个异常。该发布者不会知道或者说通常也不关心如何使用该消息。例如，有可能是订阅者根据该异常向开发人员或支持人员发送一封电子邮件，也有可能是订阅者收集不同类型的异常数目用于生成报告，甚至是订阅者根据异常的类型，使用这个信息来通知随叫随到(on-call)的技术人员。\n\t在发布订阅消息传送模型内部，有多种不同类型的订阅者。非持久订阅者是临时订阅类型，它们只是在主动侦听主题时才接收消息。而另一方面，持久订阅者将接收发布的每条消息的一个副本，即便在发布消息，它们处于“离线’状态时也是如此。另外还有动态持久订阅者和受管的持久订阅者等类型。\n\n## Rpc和异步消息传送\n\tRPC(Remote Procedure Call，远程过程调用)是通常用于描述分布式计算模型的术语。现在Java和.Net这两种平台都在使用这个术语。基于组件的体系结构，比如企业级JavaBean（Enterprise JavaBeans，EJB），就是建立在这个模型基础之上的。对于许多应用程序来说，基于RPC的技术已经是，并且将继续是切实可行的解决方案。不过，企业消息传送模型在特定类型的分布式应用程序中表现更为出色。在本节中，我们将讨论每种模型的优缺点。\n### 紧密耦合的rpc\n\t紧密耦合的RPC模型最为成功的一个领域就是构建3层或n层应用程序。在这个模型中，表示层（第1层）使用RPC和中间层（第2层）的业务逻辑进行通信，访问位于后端（第3层）的数据。Sun Microsystems公司的J2EE平台和Microsoft公司的.NET平台是这种体系结构最为先进的范例。\n\t使用J2EE、JSP和Servlet技术的表示层，而企业级JavaBean（EJB）则是中间层。抛开平台不论，这些系统使用的核心技术是基于成为定义通信范例的RPC的中间件。\n\tRPC试图模仿在一个进程中运行的某个系统的行为。在调用一个远程过程时，调用者将被阻塞，直到该过程完成并将控制权返回给调用者。从开发者的角度看，这种同步模型使得该系统就好像运行在一个进程当中。这些工作会依次完成，同时确保以顺序完成。RPC同步的本质特性，将客户端（进行调用的软件）和服务器（为该调用服务的软件）二者紧密耦合在一起。因为客户端已被阻塞，所以它无法继续进行工作。直到服务器做出响应为止。\n\tRPC紧密耦合的本质特性导致出现了相互高度依赖的系统，其中一个系统的失效会对其它系统产生立竿见影的弱化影响。例如，在J2EE中，如果期望使用企业级bean的servlet顺利工作，EJB服务器就必须正常地发挥功能。\n\t虽然RPC在许多场景中表现优秀，但是在系统对系统的处理过程当中，它的同步、紧密耦合等本质却是一个严重的缺陷，因为”系统对系统“有很多垂直的应用程序集成在一起。在系统对系统场景中，垂直系统之间的通信线程不仅数量众多、而且方向也是错综复杂，如下图：\n \n\t让我们设想一下使用紧密救命的RPC机制实现这种基础设施所面临的挑战。这些系统之间的连接管理是多对多的问题。当您身混合系统中加入另一个应用程序时，您不得不回过头来让其余所有的系统都知道它，而且，这些系统也会崩溃(crash)。它们仍然需要预定停工时间，而且对象的接口也需要升级。\n\t当该系统的一部分中断运行时，一切都停步。当您向一个订单输入系统添加订单时，它要对其他系统逐个进行同步调用。这会导致订单输入系统发生阻塞，并一直等待，直到每个系统都处理完成订单时为止。\n\t\n\t正是的PC系统的同步、紧密耦合、相互依赖等本质特性，便得子系统中出现的故障最终会导致整个系统的失效。就像在”系统对系统“场景中那样，当RPC紧密耦合的本质特性不再适用时，消息传送机制为此提供了另一种选择方案。\n### 企业消息传送\n\t各个子系统在可用性方面存在的问题，并不是使用面向消息的中间件所事业来的后果。消息传送机制的一个基本思想就是：规定应用程序之间的通信应该采用异步方式。将各部分连接在一些的代码会假定这是一条单身消息，它不需要立即从另一个应用程序那里得到响应。换句话说，它不必等待对这条消息的响应。这是RPC和异步消息传送之间的主要区别，而且，它对于 理解消息传送系统的优点来说至关重要。\n\t在一个异步消息传送系统当中，每个子系统（收款、存货等）都不存在和其他系统的耦合。它们通过消息传送服务顺进行通信，因此，某个子系统出现故障，并不会妨碍其他子系统的运行。如下图：\n\n\t在网络化系统中会出现局部故障，这是一个不可避免的事实。其中的一个系统，可能会在其连接运行期间的某个时刻，发生不可预测的故障，或者需要停机。这种现象可能会由于内部系统和合作系统地理上的分散而被进一步放大。考虑到这个因素，JMS提供了保证传送（guaranteed delivery）方式，它可以确保即便发生了局部故障，预定消费者最终也会接收到这条消息。\n\t保证传送使用的是一种”保存并转发（store-and-forward）”的机制，这就意味着，如果预定消费者当前并不可用，底层消息服务器就会将输入的消息写到一个持久存储器（persistent store）之中。随后，当该接收应用程序变为可用时，“保存并转发”机制会把预定消费者在不可用时错过的所有消息传送给它们。\n\n\t概括来说，JMS不仅仅是另外一种事件服务。它的设计涵盖了范围极广的企业应用程序，包括EAI、B2B和摄像头模型等。通过异步处理、“保存并转发”及“保证传送”机制，它为保持业务应用程序连续运行并实现不间断服务提供了很高的可用性。它还通过发布订阅功能和点对点功能，提供了集成灵活性。通过位置透明和管理控制，它提供了一种健壮的、基于服务的体系结构。而且，最重要的是，它非常易于学习和使用。\n","slug":"java/消息传送基础","published":1,"updated":"2017-08-18T01:44:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bmf009qs77ruqtqk9sl","content":"<h1 id=\"消息传送基础\"><a href=\"#消息传送基础\" class=\"headerlink\" title=\"消息传送基础\"></a>消息传送基础</h1><h2 id=\"消息传送模型\"><a href=\"#消息传送模型\" class=\"headerlink\" title=\"消息传送模型\"></a>消息传送模型</h2><pre><code>JMS支持两种消息传送模型：点对点模型和发布/订阅模型。有时候，又称这些消息传送模型为消息传送域。点对点消息传送模型和发布/订阅消息传送模型经常分别缩写为p2p和Pub/Sub。\n\n从JMS的视角来看，消息传送客户端称为JMS客户端(JMS Client)，而消息传送系统则称为JMS提供者（JMS provider）。一个JMS应用程序是由多个JMS客户端和（通常是）一个JMS提供者所组成的业务系统。\n此外，生产消息的JMS客户端称为消息生产者（message produceer），而接收消息的JMS客户端则称为消息消费者(message consumer)。一个JMS客户端可以既是消息生产者又是消息消费者。\n</code></pre><h3 id=\"点对点模型\"><a href=\"#点对点模型\" class=\"headerlink\" title=\"点对点模型\"></a>点对点模型</h3><pre><code>点对点消息传送模型允许JMS客户端通过队列（queue）这个虚拟通道来同步和异步发送、接收消息。在点对点模型中，消息生产者称为发送者（Sender），而消息消费者则称为接收者（receiver）。传统上，点对点模型是一个基于拉取(Pull)或基于轮询(polling)的消息传送模型，这种模型从队列中请求消息，而不是自动地将消息推送到客户端。点对点消息传递模型的一个突出特点就是：发送到队列的消息被一个而且仅仅一个接收者所接收，即使可能有多个接收者在一个队列中侦听同一消息时，也是如此。\n点对点消息传送模型既支持异步“即发即弃（fire and forget）”消息传送方式，又支持同步请求/应答消息传送方式。点对点消息传送模型比发布订阅模型具有更强的耦合性，发磅者通常会知道消息初如何使用，而且也会知道谁将接收该消息。举例来说，发送者可能会向一个队列发送一个证券交易订单并等待响应，响应中应包含一个交易确认码。这样一来，消息发送者就会知道消息接收者将来处理交易订单。另一个例子就是一个生成长时间运行报告的异步请求。发送者发出报告请求，而当该报告准备就绪时，就会给发送者发送一条通知消息。在这种情况下，发送者就会知道消息接收者将要处理该消息并创建报告。\n点对点模型支持负载均衡，它允许多个接收者侦听同一个队列，并以此来分配负载。JMS规范没有规定在多个接收者中间分发消息的规则，尽管某些JMS厂商已经选择实现些规则来提升负载均衡能力。点对点模型还具有其他优点，比如说，队列浏览器允许客户端在消费龅牙消息之前查看队列内容—--在发布订阅模型中，并没有这样浏览器的概念。\n</code></pre><h3 id=\"发布-订阅模型\"><a href=\"#发布-订阅模型\" class=\"headerlink\" title=\"发布/订阅模型\"></a>发布/订阅模型</h3><pre><code>在发布订阅模型中，消息会被发布到一个名为主题（topic）的虚拟通道中。消息生产者称为发布者(publisher)，而消息消费者则称为订阅者（subscriber）。与点对点模型不同，使用发布订阅模型发布一个主题的消息，能够由多个订阅者所接收。有时候，也称这项技术为广播(broadcasting)消息。每个订阅者都会接收到每条消息的一个副本。总地来说，发布订阅消息传送模型基本上是一个基于推送(push)的模型，其中消息自动地向消费者广播，它们无须请求或轮询主题来获得新消息。\n发布订阅模型的去耦能力要比p2p模型更强，消息发布者通常不会意识到有多少订阅者或那些订阅者如何处理这些消息。举例来说，假定每次在Java应用程序发生异常时，向一个主题发布一条消息。发布者的责任仅仅是广播发生了一个异常。该发布者不会知道或者说通常也不关心如何使用该消息。例如，有可能是订阅者根据该异常向开发人员或支持人员发送一封电子邮件，也有可能是订阅者收集不同类型的异常数目用于生成报告，甚至是订阅者根据异常的类型，使用这个信息来通知随叫随到(on-call)的技术人员。\n在发布订阅消息传送模型内部，有多种不同类型的订阅者。非持久订阅者是临时订阅类型，它们只是在主动侦听主题时才接收消息。而另一方面，持久订阅者将接收发布的每条消息的一个副本，即便在发布消息，它们处于“离线’状态时也是如此。另外还有动态持久订阅者和受管的持久订阅者等类型。\n</code></pre><h2 id=\"Rpc和异步消息传送\"><a href=\"#Rpc和异步消息传送\" class=\"headerlink\" title=\"Rpc和异步消息传送\"></a>Rpc和异步消息传送</h2><pre><code>RPC(Remote Procedure Call，远程过程调用)是通常用于描述分布式计算模型的术语。现在Java和.Net这两种平台都在使用这个术语。基于组件的体系结构，比如企业级JavaBean（Enterprise JavaBeans，EJB），就是建立在这个模型基础之上的。对于许多应用程序来说，基于RPC的技术已经是，并且将继续是切实可行的解决方案。不过，企业消息传送模型在特定类型的分布式应用程序中表现更为出色。在本节中，我们将讨论每种模型的优缺点。\n</code></pre><h3 id=\"紧密耦合的rpc\"><a href=\"#紧密耦合的rpc\" class=\"headerlink\" title=\"紧密耦合的rpc\"></a>紧密耦合的rpc</h3><pre><code>紧密耦合的RPC模型最为成功的一个领域就是构建3层或n层应用程序。在这个模型中，表示层（第1层）使用RPC和中间层（第2层）的业务逻辑进行通信，访问位于后端（第3层）的数据。Sun Microsystems公司的J2EE平台和Microsoft公司的.NET平台是这种体系结构最为先进的范例。\n使用J2EE、JSP和Servlet技术的表示层，而企业级JavaBean（EJB）则是中间层。抛开平台不论，这些系统使用的核心技术是基于成为定义通信范例的RPC的中间件。\nRPC试图模仿在一个进程中运行的某个系统的行为。在调用一个远程过程时，调用者将被阻塞，直到该过程完成并将控制权返回给调用者。从开发者的角度看，这种同步模型使得该系统就好像运行在一个进程当中。这些工作会依次完成，同时确保以顺序完成。RPC同步的本质特性，将客户端（进行调用的软件）和服务器（为该调用服务的软件）二者紧密耦合在一起。因为客户端已被阻塞，所以它无法继续进行工作。直到服务器做出响应为止。\nRPC紧密耦合的本质特性导致出现了相互高度依赖的系统，其中一个系统的失效会对其它系统产生立竿见影的弱化影响。例如，在J2EE中，如果期望使用企业级bean的servlet顺利工作，EJB服务器就必须正常地发挥功能。\n虽然RPC在许多场景中表现优秀，但是在系统对系统的处理过程当中，它的同步、紧密耦合等本质却是一个严重的缺陷，因为”系统对系统“有很多垂直的应用程序集成在一起。在系统对系统场景中，垂直系统之间的通信线程不仅数量众多、而且方向也是错综复杂，如下图：\n\n让我们设想一下使用紧密救命的RPC机制实现这种基础设施所面临的挑战。这些系统之间的连接管理是多对多的问题。当您身混合系统中加入另一个应用程序时，您不得不回过头来让其余所有的系统都知道它，而且，这些系统也会崩溃(crash)。它们仍然需要预定停工时间，而且对象的接口也需要升级。\n当该系统的一部分中断运行时，一切都停步。当您向一个订单输入系统添加订单时，它要对其他系统逐个进行同步调用。这会导致订单输入系统发生阻塞，并一直等待，直到每个系统都处理完成订单时为止。\n\n正是的PC系统的同步、紧密耦合、相互依赖等本质特性，便得子系统中出现的故障最终会导致整个系统的失效。就像在”系统对系统“场景中那样，当RPC紧密耦合的本质特性不再适用时，消息传送机制为此提供了另一种选择方案。\n</code></pre><h3 id=\"企业消息传送\"><a href=\"#企业消息传送\" class=\"headerlink\" title=\"企业消息传送\"></a>企业消息传送</h3><pre><code>各个子系统在可用性方面存在的问题，并不是使用面向消息的中间件所事业来的后果。消息传送机制的一个基本思想就是：规定应用程序之间的通信应该采用异步方式。将各部分连接在一些的代码会假定这是一条单身消息，它不需要立即从另一个应用程序那里得到响应。换句话说，它不必等待对这条消息的响应。这是RPC和异步消息传送之间的主要区别，而且，它对于 理解消息传送系统的优点来说至关重要。\n在一个异步消息传送系统当中，每个子系统（收款、存货等）都不存在和其他系统的耦合。它们通过消息传送服务顺进行通信，因此，某个子系统出现故障，并不会妨碍其他子系统的运行。如下图：\n\n在网络化系统中会出现局部故障，这是一个不可避免的事实。其中的一个系统，可能会在其连接运行期间的某个时刻，发生不可预测的故障，或者需要停机。这种现象可能会由于内部系统和合作系统地理上的分散而被进一步放大。考虑到这个因素，JMS提供了保证传送（guaranteed delivery）方式，它可以确保即便发生了局部故障，预定消费者最终也会接收到这条消息。\n保证传送使用的是一种”保存并转发（store-and-forward）”的机制，这就意味着，如果预定消费者当前并不可用，底层消息服务器就会将输入的消息写到一个持久存储器（persistent store）之中。随后，当该接收应用程序变为可用时，“保存并转发”机制会把预定消费者在不可用时错过的所有消息传送给它们。\n\n概括来说，JMS不仅仅是另外一种事件服务。它的设计涵盖了范围极广的企业应用程序，包括EAI、B2B和摄像头模型等。通过异步处理、“保存并转发”及“保证传送”机制，它为保持业务应用程序连续运行并实现不间断服务提供了很高的可用性。它还通过发布订阅功能和点对点功能，提供了集成灵活性。通过位置透明和管理控制，它提供了一种健壮的、基于服务的体系结构。而且，最重要的是，它非常易于学习和使用。\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"消息传送基础\"><a href=\"#消息传送基础\" class=\"headerlink\" title=\"消息传送基础\"></a>消息传送基础</h1><h2 id=\"消息传送模型\"><a href=\"#消息传送模型\" class=\"headerlink\" title=\"消息传送模型\"></a>消息传送模型</h2><pre><code>JMS支持两种消息传送模型：点对点模型和发布/订阅模型。有时候，又称这些消息传送模型为消息传送域。点对点消息传送模型和发布/订阅消息传送模型经常分别缩写为p2p和Pub/Sub。\n\n从JMS的视角来看，消息传送客户端称为JMS客户端(JMS Client)，而消息传送系统则称为JMS提供者（JMS provider）。一个JMS应用程序是由多个JMS客户端和（通常是）一个JMS提供者所组成的业务系统。\n此外，生产消息的JMS客户端称为消息生产者（message produceer），而接收消息的JMS客户端则称为消息消费者(message consumer)。一个JMS客户端可以既是消息生产者又是消息消费者。\n</code></pre><h3 id=\"点对点模型\"><a href=\"#点对点模型\" class=\"headerlink\" title=\"点对点模型\"></a>点对点模型</h3><pre><code>点对点消息传送模型允许JMS客户端通过队列（queue）这个虚拟通道来同步和异步发送、接收消息。在点对点模型中，消息生产者称为发送者（Sender），而消息消费者则称为接收者（receiver）。传统上，点对点模型是一个基于拉取(Pull)或基于轮询(polling)的消息传送模型，这种模型从队列中请求消息，而不是自动地将消息推送到客户端。点对点消息传递模型的一个突出特点就是：发送到队列的消息被一个而且仅仅一个接收者所接收，即使可能有多个接收者在一个队列中侦听同一消息时，也是如此。\n点对点消息传送模型既支持异步“即发即弃（fire and forget）”消息传送方式，又支持同步请求/应答消息传送方式。点对点消息传送模型比发布订阅模型具有更强的耦合性，发磅者通常会知道消息初如何使用，而且也会知道谁将接收该消息。举例来说，发送者可能会向一个队列发送一个证券交易订单并等待响应，响应中应包含一个交易确认码。这样一来，消息发送者就会知道消息接收者将来处理交易订单。另一个例子就是一个生成长时间运行报告的异步请求。发送者发出报告请求，而当该报告准备就绪时，就会给发送者发送一条通知消息。在这种情况下，发送者就会知道消息接收者将要处理该消息并创建报告。\n点对点模型支持负载均衡，它允许多个接收者侦听同一个队列，并以此来分配负载。JMS规范没有规定在多个接收者中间分发消息的规则，尽管某些JMS厂商已经选择实现些规则来提升负载均衡能力。点对点模型还具有其他优点，比如说，队列浏览器允许客户端在消费龅牙消息之前查看队列内容—--在发布订阅模型中，并没有这样浏览器的概念。\n</code></pre><h3 id=\"发布-订阅模型\"><a href=\"#发布-订阅模型\" class=\"headerlink\" title=\"发布/订阅模型\"></a>发布/订阅模型</h3><pre><code>在发布订阅模型中，消息会被发布到一个名为主题（topic）的虚拟通道中。消息生产者称为发布者(publisher)，而消息消费者则称为订阅者（subscriber）。与点对点模型不同，使用发布订阅模型发布一个主题的消息，能够由多个订阅者所接收。有时候，也称这项技术为广播(broadcasting)消息。每个订阅者都会接收到每条消息的一个副本。总地来说，发布订阅消息传送模型基本上是一个基于推送(push)的模型，其中消息自动地向消费者广播，它们无须请求或轮询主题来获得新消息。\n发布订阅模型的去耦能力要比p2p模型更强，消息发布者通常不会意识到有多少订阅者或那些订阅者如何处理这些消息。举例来说，假定每次在Java应用程序发生异常时，向一个主题发布一条消息。发布者的责任仅仅是广播发生了一个异常。该发布者不会知道或者说通常也不关心如何使用该消息。例如，有可能是订阅者根据该异常向开发人员或支持人员发送一封电子邮件，也有可能是订阅者收集不同类型的异常数目用于生成报告，甚至是订阅者根据异常的类型，使用这个信息来通知随叫随到(on-call)的技术人员。\n在发布订阅消息传送模型内部，有多种不同类型的订阅者。非持久订阅者是临时订阅类型，它们只是在主动侦听主题时才接收消息。而另一方面，持久订阅者将接收发布的每条消息的一个副本，即便在发布消息，它们处于“离线’状态时也是如此。另外还有动态持久订阅者和受管的持久订阅者等类型。\n</code></pre><h2 id=\"Rpc和异步消息传送\"><a href=\"#Rpc和异步消息传送\" class=\"headerlink\" title=\"Rpc和异步消息传送\"></a>Rpc和异步消息传送</h2><pre><code>RPC(Remote Procedure Call，远程过程调用)是通常用于描述分布式计算模型的术语。现在Java和.Net这两种平台都在使用这个术语。基于组件的体系结构，比如企业级JavaBean（Enterprise JavaBeans，EJB），就是建立在这个模型基础之上的。对于许多应用程序来说，基于RPC的技术已经是，并且将继续是切实可行的解决方案。不过，企业消息传送模型在特定类型的分布式应用程序中表现更为出色。在本节中，我们将讨论每种模型的优缺点。\n</code></pre><h3 id=\"紧密耦合的rpc\"><a href=\"#紧密耦合的rpc\" class=\"headerlink\" title=\"紧密耦合的rpc\"></a>紧密耦合的rpc</h3><pre><code>紧密耦合的RPC模型最为成功的一个领域就是构建3层或n层应用程序。在这个模型中，表示层（第1层）使用RPC和中间层（第2层）的业务逻辑进行通信，访问位于后端（第3层）的数据。Sun Microsystems公司的J2EE平台和Microsoft公司的.NET平台是这种体系结构最为先进的范例。\n使用J2EE、JSP和Servlet技术的表示层，而企业级JavaBean（EJB）则是中间层。抛开平台不论，这些系统使用的核心技术是基于成为定义通信范例的RPC的中间件。\nRPC试图模仿在一个进程中运行的某个系统的行为。在调用一个远程过程时，调用者将被阻塞，直到该过程完成并将控制权返回给调用者。从开发者的角度看，这种同步模型使得该系统就好像运行在一个进程当中。这些工作会依次完成，同时确保以顺序完成。RPC同步的本质特性，将客户端（进行调用的软件）和服务器（为该调用服务的软件）二者紧密耦合在一起。因为客户端已被阻塞，所以它无法继续进行工作。直到服务器做出响应为止。\nRPC紧密耦合的本质特性导致出现了相互高度依赖的系统，其中一个系统的失效会对其它系统产生立竿见影的弱化影响。例如，在J2EE中，如果期望使用企业级bean的servlet顺利工作，EJB服务器就必须正常地发挥功能。\n虽然RPC在许多场景中表现优秀，但是在系统对系统的处理过程当中，它的同步、紧密耦合等本质却是一个严重的缺陷，因为”系统对系统“有很多垂直的应用程序集成在一起。在系统对系统场景中，垂直系统之间的通信线程不仅数量众多、而且方向也是错综复杂，如下图：\n\n让我们设想一下使用紧密救命的RPC机制实现这种基础设施所面临的挑战。这些系统之间的连接管理是多对多的问题。当您身混合系统中加入另一个应用程序时，您不得不回过头来让其余所有的系统都知道它，而且，这些系统也会崩溃(crash)。它们仍然需要预定停工时间，而且对象的接口也需要升级。\n当该系统的一部分中断运行时，一切都停步。当您向一个订单输入系统添加订单时，它要对其他系统逐个进行同步调用。这会导致订单输入系统发生阻塞，并一直等待，直到每个系统都处理完成订单时为止。\n\n正是的PC系统的同步、紧密耦合、相互依赖等本质特性，便得子系统中出现的故障最终会导致整个系统的失效。就像在”系统对系统“场景中那样，当RPC紧密耦合的本质特性不再适用时，消息传送机制为此提供了另一种选择方案。\n</code></pre><h3 id=\"企业消息传送\"><a href=\"#企业消息传送\" class=\"headerlink\" title=\"企业消息传送\"></a>企业消息传送</h3><pre><code>各个子系统在可用性方面存在的问题，并不是使用面向消息的中间件所事业来的后果。消息传送机制的一个基本思想就是：规定应用程序之间的通信应该采用异步方式。将各部分连接在一些的代码会假定这是一条单身消息，它不需要立即从另一个应用程序那里得到响应。换句话说，它不必等待对这条消息的响应。这是RPC和异步消息传送之间的主要区别，而且，它对于 理解消息传送系统的优点来说至关重要。\n在一个异步消息传送系统当中，每个子系统（收款、存货等）都不存在和其他系统的耦合。它们通过消息传送服务顺进行通信，因此，某个子系统出现故障，并不会妨碍其他子系统的运行。如下图：\n\n在网络化系统中会出现局部故障，这是一个不可避免的事实。其中的一个系统，可能会在其连接运行期间的某个时刻，发生不可预测的故障，或者需要停机。这种现象可能会由于内部系统和合作系统地理上的分散而被进一步放大。考虑到这个因素，JMS提供了保证传送（guaranteed delivery）方式，它可以确保即便发生了局部故障，预定消费者最终也会接收到这条消息。\n保证传送使用的是一种”保存并转发（store-and-forward）”的机制，这就意味着，如果预定消费者当前并不可用，底层消息服务器就会将输入的消息写到一个持久存储器（persistent store）之中。随后，当该接收应用程序变为可用时，“保存并转发”机制会把预定消费者在不可用时错过的所有消息传送给它们。\n\n概括来说，JMS不仅仅是另外一种事件服务。它的设计涵盖了范围极广的企业应用程序，包括EAI、B2B和摄像头模型等。通过异步处理、“保存并转发”及“保证传送”机制，它为保持业务应用程序连续运行并实现不间断服务提供了很高的可用性。它还通过发布订阅功能和点对点功能，提供了集成灵活性。通过位置透明和管理控制，它提供了一种健壮的、基于服务的体系结构。而且，最重要的是，它非常易于学习和使用。\n</code></pre>"},{"title":"指标体系规划与管理驾驶舱设计","date":"2019-03-13T01:55:00.000Z","_content":"\n    企业开展数据化运营，需要指标来驱动业务，但企业内部指标间纷繁复杂，如何拨开云雾，统一指标口径，将指标管理得井井有条，并指导管理驾驶舱建设    企业开展数据化运营，需要指标来驱动业务，但企业内部指标间纷繁复杂，如何拨开云雾，统一指标口径，将指标管理得井井有条，并指导管理驾驶舱建设x    企业开展数据化运营，需要指标来驱动业务，但企业内部指标间纷繁复杂，如何拨开云雾，统一指标口径，将指标管理得井井有条，并指导管理驾驶舱建设    企业开展数据化运营，需要指标来驱动业务，但企业内部指标间纷繁复杂，如何拨开云雾，统一指标口径，将指标管理得井井有条，并指导管理驾驶舱建设x引用。\n    结合国际数据领域的方法论和国内企业的最佳实践，通过主题划分、自上而下和自下而上相结合的指标梳理，形成整个企业的分析主题和指标体系框架。通过模拟领导决策过程，开展管理驾驶舱的页面流设计和页面跳转设计，形成流畅的仪表板故事线，并根据发现的问题随时开展更深入的分析，是开展数据化运营，实现业务增长的重点。\n    \n   \n ## 指标体系规划\n ### 什么是企业指标体系\n 在传统的企业管理环境下，指标通常是指绩效指标或者业务指标，通常用于KPI考核。随着商务智能和大数据的发展，除了考核以外，指标还用于追踪、用来把握整体变化趋势，关注异常波动；指标也可以用于监测，对超出特定范围的指标异动，用红、黄、绿色交通灯等图标开展预警。\n 企业的指标通常分散在各个业务流程当中，并且在流程的各个环节当中 由不同部门所计算和采纳。当各个部门应用的指标越来越多时，指标口径不一致，数据重复报送、重复统计等问题也会不断地涌现出来。\n    企业指标体系规划就是在企业指标体系混乱、指标口径不统一的背景下应运而生的。因此需要对指标体系进行梳理、划分主题、规划蓝图，并通过管理驾驶舱来实施，通过企业数据治理来对指标体系提供数据质量保障。\n    \n ### 如何开展指标体系管理？\n 要想开展指标的数据管理，首先应当对指标进行划分。有许多指标分散在多个IT系统当中，并且跨多个流程和多个部门，并由多个级别的员工使用。因此传统方法很难做到完全穷尽、没有遗漏地对指标进行划分、以便指定指标的归口部门。为了清晰地对企业指标进行划分，业界的最佳实践是按照“主题”对指标进行划分，“主题”是相关性较强的内容的一个聚类。目前国际上已经给出较为通用的指标体系主题划分的框架，如SMART战略板。\n    指标体系主题划分，主要是从企业管理报表的设计方和创建方的角度出发的。而报表和指标的实际使用过程，通常需要从决策者的需求方的角度出发。这两个角度通常并不一致，SMART战略板的主题划分方法，通常经过一定程度的抽象，因此相对而言比较稳定。在具体的BI实施落地时，通常分为两层结构：一层是相对稳定的指标主题划分，以报表页面流的方式对指标体系进行组织，需要对主题层层细化，最终形成具有层次和次序的页面流；另一层是相对比较灵活易构的磁贴式的仪表板，可以按需进行灵活布局组合，并建立起页面跳转关系，可以进一步查看详情页面并开展交互式分析。通过对企业的指标数据划分主题，形成相对互斥并且完备（MECE)的指标体系、形成页面流，并进一步在此基础之上，增加包含更多跨主题的综合指标的仪表板，如ROE，并建立起同关联密切的页面之间的跳转关系。\n    \n ### 3.如何规划指标体系？\n指标体系的规划，通常有两种方式：自上而下和自下而上。在实践过程中通常是自上而下和自下而上两种方式结合。\n自上而下的方式，通常就是从数据的顶层设计入手，在数据蓝图的基础上，关注整个企业的价值链条，能够并从中分析出整个价值链上的关键环节，形成层次；按照决策者的通用分析思路进一步细分，形成次序；如此直到第五、第六级主题，作为页面流设计的基础。\n\n自下而上方式的出必点，通常是企业现有的管理报表体系。通过对企业的管理报表进行梳理，从中提炼出常见的维度、指标度量值，并且进一步明确指标的数据来源，所在系统、统计频率、指标定义、指标口径、分析模式等，通过将维度、度量值进行多维交叉、能够设计出更多指标。\n \n### 4.指标体系规划的常用工具\n#### （1）SMART框架\nSMART战略板很早之前就已经普遍应用于数据战略规划当中，其本质在于将企业的指标划分为5-7类分析主题。\n#### （2）战略地图/平衡计分卡\n        战略地图/平衡计分卡更多强调的是财务非财务、局部与全局、近期与远期之间的平衡。通过该方法可以帮助我们在对分析主题细化时，快速得到一些重要并且综合全面的实用指标。\n#### （3）KPI价值树\nKPI价值树更加强调重点核心指标。这些指标更加适合高管在管理驾驶舱中以仪表板的形式查看，通常这些指标会对应多个分析主题 。\n#### （4）全面预算管理\n全面预算管理中有效地将业务量指标和财务指标衔接到一起，涵盖企业经营的各个方面。\n#### （5）现有管理报表\n这可以从现有的管理报表中抽取关键的维度和关键的度量指标作为我们建立整个指标体系的基础 。\n\n通过以上工具，在蓝图的基础上对子主题进行细化，形成树状的多级主题划分，最终的子主题（如第六级）通常仅包含1个关键指标度量值，或者多个但不超过10个指标。并且对于每个指标：\n（1）明确指标名称、定义、计算公式、单位。这对于企业统计指标口径，划分指标的归口部门而言非常重要。\n（2）明确指标需求方。最终指标的使用部门，或者是哪些部门关心现有体系中的指标，需要进一步识别。不同层次的领导有不同的关注点。高层领导可能关心利润、收入、成本，他们都只是站在比较宏观的角度去关心与参考。\n（3）指标寻源。指标进行寻源是指计算指标所需的基础明细数据和原始来源。指标的归口部门要对指标进行逻辑拆分，通常可拆分为维度和度量两部分，并可以识别出特定的分析模式和计算公式。\n（4）指标分析模式。对于整个管理驾驶舱中的各项指标，要能体现出具体的分析模式，这些分析模式包括同比、环比、结构占比、完成率分析等。\n（5）指标分析的时间/机构维度。所谓时间维度是指报表或指标的具体统计频率、可按年、月、周来统计。所谓机构维度是指整个集团级别的还是某个二级单位级别的。\n（6）图表的可视化展现方式。另外还要考虑不同的图表展现方式。饼图、条形图、柱形图、拆线图是最常用最直观的图表类型。另外，热力图、面积图、标签云、漏斗图、瀑布图以及各类组合图表在特定场合下也能形成很好的展现效果。\n这些指标的分类和次序，成为下一步管理驾驶舱的页面流设计的基础框架，形成带有层次和次序的页面流，每个页面中包含了一个或多个指标，并且通过识别的分析模式和可视化展现方式，能为管理驾驶舱的详细设计提供良好的指导 。\n\n\n## 管理驾驶舱的设计\n### 什么是管理驾驶舱？\n \n 管理驾驶舱，是通过统计分析工具和图表工具来创建的仪表板，各个仪表板之间通过整个的故事线链接起来。仪表板中融合了许多的关键指标，这些指标可以一目了然地把我们的各个数据和指标之间错综复杂的关系用最直观的方式为公司的领导和各级员工表现出来，为他们提供决策支持。\n\n管理驾驶舱的设计，承接了我们整个的指标体系中的度量指标、维度和分析方法，并遵循特定的展现方式，形成了数百页的管理驾驶舱的设计方案，以体现出整体的分析思路和分析步骤的设计。\n\n#### 1.分析展现页面的设计\n分析展现页面的设计通常有两种手段：一种是通过PPT或者低保真草图绘制工具来设计BI展现页面的需求，一种是通过敏捷BI工具和模拟数据创建并实现分析原型。PPT是报表页面和仪表板页面设计的主要工具通过PPT图表来模拟整个管理驾驶舱中的图表展现和控件，通过PPT中的页面和按钮来模拟管理驾驶舱中的页面流和页面跳转，通过这种方式和领导确认需求，并交由IT团队开发。敏捷BI工具和可视化分析工具，如Tableau、Qlik View等，可用于快速创建原型。此外还有我们熟悉的Excel和Power BI，通过快速原型来创建仪表板开展分析，并进一步交给团队在生产环境中进行部署。\n\n#### 2.页面流设计\n基于指标体系规划文档，按照指标的树形结构的主题，来确定页面的层次和次序从而形成逻辑一致的页面流。\n![\"管理驾驶舱设计-页面流设计\"](/images/数据中台/管理驾驶舱设计-页面流设计.jpg)\n\n#### 3.页面跳转设计\n通常在使用高度综合的指标体系，如“杜邦分析”时，需要对页面跳转进行设计。典型的杜邦分析是以价值树的结构进行展现的。\n![\"管理驾驶舱设计-页面跳转设计\"](/images/数据中台/管理驾驶舱设计-页面跳转设计.jpg)\n\n作用\n刘凯，美国注册管理会计师，管理学硕士，曾就职于奥美互动、新华信、毕博、戴尔等公司。","source":"_posts/数据中台/指标体系规划与管理驾驶舱设计.md","raw":"---\ntitle: 指标体系规划与管理驾驶舱设计\ndate: 2019-03-13 09:55:00\ntags: [管理驾驶舱设计]\ncategories: [数据中台,管理驾驶舱设计]\n---\n\n    企业开展数据化运营，需要指标来驱动业务，但企业内部指标间纷繁复杂，如何拨开云雾，统一指标口径，将指标管理得井井有条，并指导管理驾驶舱建设    企业开展数据化运营，需要指标来驱动业务，但企业内部指标间纷繁复杂，如何拨开云雾，统一指标口径，将指标管理得井井有条，并指导管理驾驶舱建设x    企业开展数据化运营，需要指标来驱动业务，但企业内部指标间纷繁复杂，如何拨开云雾，统一指标口径，将指标管理得井井有条，并指导管理驾驶舱建设    企业开展数据化运营，需要指标来驱动业务，但企业内部指标间纷繁复杂，如何拨开云雾，统一指标口径，将指标管理得井井有条，并指导管理驾驶舱建设x引用。\n    结合国际数据领域的方法论和国内企业的最佳实践，通过主题划分、自上而下和自下而上相结合的指标梳理，形成整个企业的分析主题和指标体系框架。通过模拟领导决策过程，开展管理驾驶舱的页面流设计和页面跳转设计，形成流畅的仪表板故事线，并根据发现的问题随时开展更深入的分析，是开展数据化运营，实现业务增长的重点。\n    \n   \n ## 指标体系规划\n ### 什么是企业指标体系\n 在传统的企业管理环境下，指标通常是指绩效指标或者业务指标，通常用于KPI考核。随着商务智能和大数据的发展，除了考核以外，指标还用于追踪、用来把握整体变化趋势，关注异常波动；指标也可以用于监测，对超出特定范围的指标异动，用红、黄、绿色交通灯等图标开展预警。\n 企业的指标通常分散在各个业务流程当中，并且在流程的各个环节当中 由不同部门所计算和采纳。当各个部门应用的指标越来越多时，指标口径不一致，数据重复报送、重复统计等问题也会不断地涌现出来。\n    企业指标体系规划就是在企业指标体系混乱、指标口径不统一的背景下应运而生的。因此需要对指标体系进行梳理、划分主题、规划蓝图，并通过管理驾驶舱来实施，通过企业数据治理来对指标体系提供数据质量保障。\n    \n ### 如何开展指标体系管理？\n 要想开展指标的数据管理，首先应当对指标进行划分。有许多指标分散在多个IT系统当中，并且跨多个流程和多个部门，并由多个级别的员工使用。因此传统方法很难做到完全穷尽、没有遗漏地对指标进行划分、以便指定指标的归口部门。为了清晰地对企业指标进行划分，业界的最佳实践是按照“主题”对指标进行划分，“主题”是相关性较强的内容的一个聚类。目前国际上已经给出较为通用的指标体系主题划分的框架，如SMART战略板。\n    指标体系主题划分，主要是从企业管理报表的设计方和创建方的角度出发的。而报表和指标的实际使用过程，通常需要从决策者的需求方的角度出发。这两个角度通常并不一致，SMART战略板的主题划分方法，通常经过一定程度的抽象，因此相对而言比较稳定。在具体的BI实施落地时，通常分为两层结构：一层是相对稳定的指标主题划分，以报表页面流的方式对指标体系进行组织，需要对主题层层细化，最终形成具有层次和次序的页面流；另一层是相对比较灵活易构的磁贴式的仪表板，可以按需进行灵活布局组合，并建立起页面跳转关系，可以进一步查看详情页面并开展交互式分析。通过对企业的指标数据划分主题，形成相对互斥并且完备（MECE)的指标体系、形成页面流，并进一步在此基础之上，增加包含更多跨主题的综合指标的仪表板，如ROE，并建立起同关联密切的页面之间的跳转关系。\n    \n ### 3.如何规划指标体系？\n指标体系的规划，通常有两种方式：自上而下和自下而上。在实践过程中通常是自上而下和自下而上两种方式结合。\n自上而下的方式，通常就是从数据的顶层设计入手，在数据蓝图的基础上，关注整个企业的价值链条，能够并从中分析出整个价值链上的关键环节，形成层次；按照决策者的通用分析思路进一步细分，形成次序；如此直到第五、第六级主题，作为页面流设计的基础。\n\n自下而上方式的出必点，通常是企业现有的管理报表体系。通过对企业的管理报表进行梳理，从中提炼出常见的维度、指标度量值，并且进一步明确指标的数据来源，所在系统、统计频率、指标定义、指标口径、分析模式等，通过将维度、度量值进行多维交叉、能够设计出更多指标。\n \n### 4.指标体系规划的常用工具\n#### （1）SMART框架\nSMART战略板很早之前就已经普遍应用于数据战略规划当中，其本质在于将企业的指标划分为5-7类分析主题。\n#### （2）战略地图/平衡计分卡\n        战略地图/平衡计分卡更多强调的是财务非财务、局部与全局、近期与远期之间的平衡。通过该方法可以帮助我们在对分析主题细化时，快速得到一些重要并且综合全面的实用指标。\n#### （3）KPI价值树\nKPI价值树更加强调重点核心指标。这些指标更加适合高管在管理驾驶舱中以仪表板的形式查看，通常这些指标会对应多个分析主题 。\n#### （4）全面预算管理\n全面预算管理中有效地将业务量指标和财务指标衔接到一起，涵盖企业经营的各个方面。\n#### （5）现有管理报表\n这可以从现有的管理报表中抽取关键的维度和关键的度量指标作为我们建立整个指标体系的基础 。\n\n通过以上工具，在蓝图的基础上对子主题进行细化，形成树状的多级主题划分，最终的子主题（如第六级）通常仅包含1个关键指标度量值，或者多个但不超过10个指标。并且对于每个指标：\n（1）明确指标名称、定义、计算公式、单位。这对于企业统计指标口径，划分指标的归口部门而言非常重要。\n（2）明确指标需求方。最终指标的使用部门，或者是哪些部门关心现有体系中的指标，需要进一步识别。不同层次的领导有不同的关注点。高层领导可能关心利润、收入、成本，他们都只是站在比较宏观的角度去关心与参考。\n（3）指标寻源。指标进行寻源是指计算指标所需的基础明细数据和原始来源。指标的归口部门要对指标进行逻辑拆分，通常可拆分为维度和度量两部分，并可以识别出特定的分析模式和计算公式。\n（4）指标分析模式。对于整个管理驾驶舱中的各项指标，要能体现出具体的分析模式，这些分析模式包括同比、环比、结构占比、完成率分析等。\n（5）指标分析的时间/机构维度。所谓时间维度是指报表或指标的具体统计频率、可按年、月、周来统计。所谓机构维度是指整个集团级别的还是某个二级单位级别的。\n（6）图表的可视化展现方式。另外还要考虑不同的图表展现方式。饼图、条形图、柱形图、拆线图是最常用最直观的图表类型。另外，热力图、面积图、标签云、漏斗图、瀑布图以及各类组合图表在特定场合下也能形成很好的展现效果。\n这些指标的分类和次序，成为下一步管理驾驶舱的页面流设计的基础框架，形成带有层次和次序的页面流，每个页面中包含了一个或多个指标，并且通过识别的分析模式和可视化展现方式，能为管理驾驶舱的详细设计提供良好的指导 。\n\n\n## 管理驾驶舱的设计\n### 什么是管理驾驶舱？\n \n 管理驾驶舱，是通过统计分析工具和图表工具来创建的仪表板，各个仪表板之间通过整个的故事线链接起来。仪表板中融合了许多的关键指标，这些指标可以一目了然地把我们的各个数据和指标之间错综复杂的关系用最直观的方式为公司的领导和各级员工表现出来，为他们提供决策支持。\n\n管理驾驶舱的设计，承接了我们整个的指标体系中的度量指标、维度和分析方法，并遵循特定的展现方式，形成了数百页的管理驾驶舱的设计方案，以体现出整体的分析思路和分析步骤的设计。\n\n#### 1.分析展现页面的设计\n分析展现页面的设计通常有两种手段：一种是通过PPT或者低保真草图绘制工具来设计BI展现页面的需求，一种是通过敏捷BI工具和模拟数据创建并实现分析原型。PPT是报表页面和仪表板页面设计的主要工具通过PPT图表来模拟整个管理驾驶舱中的图表展现和控件，通过PPT中的页面和按钮来模拟管理驾驶舱中的页面流和页面跳转，通过这种方式和领导确认需求，并交由IT团队开发。敏捷BI工具和可视化分析工具，如Tableau、Qlik View等，可用于快速创建原型。此外还有我们熟悉的Excel和Power BI，通过快速原型来创建仪表板开展分析，并进一步交给团队在生产环境中进行部署。\n\n#### 2.页面流设计\n基于指标体系规划文档，按照指标的树形结构的主题，来确定页面的层次和次序从而形成逻辑一致的页面流。\n![\"管理驾驶舱设计-页面流设计\"](/images/数据中台/管理驾驶舱设计-页面流设计.jpg)\n\n#### 3.页面跳转设计\n通常在使用高度综合的指标体系，如“杜邦分析”时，需要对页面跳转进行设计。典型的杜邦分析是以价值树的结构进行展现的。\n![\"管理驾驶舱设计-页面跳转设计\"](/images/数据中台/管理驾驶舱设计-页面跳转设计.jpg)\n\n作用\n刘凯，美国注册管理会计师，管理学硕士，曾就职于奥美互动、新华信、毕博、戴尔等公司。","slug":"数据中台/指标体系规划与管理驾驶舱设计","published":1,"updated":"2019-03-14T02:49:10.334Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bmh009ts77rvlmigf6i","content":"<pre><code>企业开展数据化运营，需要指标来驱动业务，但企业内部指标间纷繁复杂，如何拨开云雾，统一指标口径，将指标管理得井井有条，并指导管理驾驶舱建设    企业开展数据化运营，需要指标来驱动业务，但企业内部指标间纷繁复杂，如何拨开云雾，统一指标口径，将指标管理得井井有条，并指导管理驾驶舱建设x    企业开展数据化运营，需要指标来驱动业务，但企业内部指标间纷繁复杂，如何拨开云雾，统一指标口径，将指标管理得井井有条，并指导管理驾驶舱建设    企业开展数据化运营，需要指标来驱动业务，但企业内部指标间纷繁复杂，如何拨开云雾，统一指标口径，将指标管理得井井有条，并指导管理驾驶舱建设x引用。\n结合国际数据领域的方法论和国内企业的最佳实践，通过主题划分、自上而下和自下而上相结合的指标梳理，形成整个企业的分析主题和指标体系框架。通过模拟领导决策过程，开展管理驾驶舱的页面流设计和页面跳转设计，形成流畅的仪表板故事线，并根据发现的问题随时开展更深入的分析，是开展数据化运营，实现业务增长的重点。\n</code></pre><h2 id=\"指标体系规划\"><a href=\"#指标体系规划\" class=\"headerlink\" title=\"指标体系规划\"></a>指标体系规划</h2><h3 id=\"什么是企业指标体系\"><a href=\"#什么是企业指标体系\" class=\"headerlink\" title=\"什么是企业指标体系\"></a>什么是企业指标体系</h3><p> 在传统的企业管理环境下，指标通常是指绩效指标或者业务指标，通常用于KPI考核。随着商务智能和大数据的发展，除了考核以外，指标还用于追踪、用来把握整体变化趋势，关注异常波动；指标也可以用于监测，对超出特定范围的指标异动，用红、黄、绿色交通灯等图标开展预警。<br> 企业的指标通常分散在各个业务流程当中，并且在流程的各个环节当中 由不同部门所计算和采纳。当各个部门应用的指标越来越多时，指标口径不一致，数据重复报送、重复统计等问题也会不断地涌现出来。<br>    企业指标体系规划就是在企业指标体系混乱、指标口径不统一的背景下应运而生的。因此需要对指标体系进行梳理、划分主题、规划蓝图，并通过管理驾驶舱来实施，通过企业数据治理来对指标体系提供数据质量保障。</p>\n<h3 id=\"如何开展指标体系管理？\"><a href=\"#如何开展指标体系管理？\" class=\"headerlink\" title=\"如何开展指标体系管理？\"></a>如何开展指标体系管理？</h3><p> 要想开展指标的数据管理，首先应当对指标进行划分。有许多指标分散在多个IT系统当中，并且跨多个流程和多个部门，并由多个级别的员工使用。因此传统方法很难做到完全穷尽、没有遗漏地对指标进行划分、以便指定指标的归口部门。为了清晰地对企业指标进行划分，业界的最佳实践是按照“主题”对指标进行划分，“主题”是相关性较强的内容的一个聚类。目前国际上已经给出较为通用的指标体系主题划分的框架，如SMART战略板。<br>    指标体系主题划分，主要是从企业管理报表的设计方和创建方的角度出发的。而报表和指标的实际使用过程，通常需要从决策者的需求方的角度出发。这两个角度通常并不一致，SMART战略板的主题划分方法，通常经过一定程度的抽象，因此相对而言比较稳定。在具体的BI实施落地时，通常分为两层结构：一层是相对稳定的指标主题划分，以报表页面流的方式对指标体系进行组织，需要对主题层层细化，最终形成具有层次和次序的页面流；另一层是相对比较灵活易构的磁贴式的仪表板，可以按需进行灵活布局组合，并建立起页面跳转关系，可以进一步查看详情页面并开展交互式分析。通过对企业的指标数据划分主题，形成相对互斥并且完备（MECE)的指标体系、形成页面流，并进一步在此基础之上，增加包含更多跨主题的综合指标的仪表板，如ROE，并建立起同关联密切的页面之间的跳转关系。</p>\n<h3 id=\"3-如何规划指标体系？\"><a href=\"#3-如何规划指标体系？\" class=\"headerlink\" title=\"3.如何规划指标体系？\"></a>3.如何规划指标体系？</h3><p>指标体系的规划，通常有两种方式：自上而下和自下而上。在实践过程中通常是自上而下和自下而上两种方式结合。<br>自上而下的方式，通常就是从数据的顶层设计入手，在数据蓝图的基础上，关注整个企业的价值链条，能够并从中分析出整个价值链上的关键环节，形成层次；按照决策者的通用分析思路进一步细分，形成次序；如此直到第五、第六级主题，作为页面流设计的基础。</p>\n<p>自下而上方式的出必点，通常是企业现有的管理报表体系。通过对企业的管理报表进行梳理，从中提炼出常见的维度、指标度量值，并且进一步明确指标的数据来源，所在系统、统计频率、指标定义、指标口径、分析模式等，通过将维度、度量值进行多维交叉、能够设计出更多指标。</p>\n<h3 id=\"4-指标体系规划的常用工具\"><a href=\"#4-指标体系规划的常用工具\" class=\"headerlink\" title=\"4.指标体系规划的常用工具\"></a>4.指标体系规划的常用工具</h3><h4 id=\"（1）SMART框架\"><a href=\"#（1）SMART框架\" class=\"headerlink\" title=\"（1）SMART框架\"></a>（1）SMART框架</h4><p>SMART战略板很早之前就已经普遍应用于数据战略规划当中，其本质在于将企业的指标划分为5-7类分析主题。</p>\n<h4 id=\"（2）战略地图-平衡计分卡\"><a href=\"#（2）战略地图-平衡计分卡\" class=\"headerlink\" title=\"（2）战略地图/平衡计分卡\"></a>（2）战略地图/平衡计分卡</h4><pre><code>战略地图/平衡计分卡更多强调的是财务非财务、局部与全局、近期与远期之间的平衡。通过该方法可以帮助我们在对分析主题细化时，快速得到一些重要并且综合全面的实用指标。\n</code></pre><h4 id=\"（3）KPI价值树\"><a href=\"#（3）KPI价值树\" class=\"headerlink\" title=\"（3）KPI价值树\"></a>（3）KPI价值树</h4><p>KPI价值树更加强调重点核心指标。这些指标更加适合高管在管理驾驶舱中以仪表板的形式查看，通常这些指标会对应多个分析主题 。</p>\n<h4 id=\"（4）全面预算管理\"><a href=\"#（4）全面预算管理\" class=\"headerlink\" title=\"（4）全面预算管理\"></a>（4）全面预算管理</h4><p>全面预算管理中有效地将业务量指标和财务指标衔接到一起，涵盖企业经营的各个方面。</p>\n<h4 id=\"（5）现有管理报表\"><a href=\"#（5）现有管理报表\" class=\"headerlink\" title=\"（5）现有管理报表\"></a>（5）现有管理报表</h4><p>这可以从现有的管理报表中抽取关键的维度和关键的度量指标作为我们建立整个指标体系的基础 。</p>\n<p>通过以上工具，在蓝图的基础上对子主题进行细化，形成树状的多级主题划分，最终的子主题（如第六级）通常仅包含1个关键指标度量值，或者多个但不超过10个指标。并且对于每个指标：<br>（1）明确指标名称、定义、计算公式、单位。这对于企业统计指标口径，划分指标的归口部门而言非常重要。<br>（2）明确指标需求方。最终指标的使用部门，或者是哪些部门关心现有体系中的指标，需要进一步识别。不同层次的领导有不同的关注点。高层领导可能关心利润、收入、成本，他们都只是站在比较宏观的角度去关心与参考。<br>（3）指标寻源。指标进行寻源是指计算指标所需的基础明细数据和原始来源。指标的归口部门要对指标进行逻辑拆分，通常可拆分为维度和度量两部分，并可以识别出特定的分析模式和计算公式。<br>（4）指标分析模式。对于整个管理驾驶舱中的各项指标，要能体现出具体的分析模式，这些分析模式包括同比、环比、结构占比、完成率分析等。<br>（5）指标分析的时间/机构维度。所谓时间维度是指报表或指标的具体统计频率、可按年、月、周来统计。所谓机构维度是指整个集团级别的还是某个二级单位级别的。<br>（6）图表的可视化展现方式。另外还要考虑不同的图表展现方式。饼图、条形图、柱形图、拆线图是最常用最直观的图表类型。另外，热力图、面积图、标签云、漏斗图、瀑布图以及各类组合图表在特定场合下也能形成很好的展现效果。<br>这些指标的分类和次序，成为下一步管理驾驶舱的页面流设计的基础框架，形成带有层次和次序的页面流，每个页面中包含了一个或多个指标，并且通过识别的分析模式和可视化展现方式，能为管理驾驶舱的详细设计提供良好的指导 。</p>\n<h2 id=\"管理驾驶舱的设计\"><a href=\"#管理驾驶舱的设计\" class=\"headerlink\" title=\"管理驾驶舱的设计\"></a>管理驾驶舱的设计</h2><h3 id=\"什么是管理驾驶舱？\"><a href=\"#什么是管理驾驶舱？\" class=\"headerlink\" title=\"什么是管理驾驶舱？\"></a>什么是管理驾驶舱？</h3><p> 管理驾驶舱，是通过统计分析工具和图表工具来创建的仪表板，各个仪表板之间通过整个的故事线链接起来。仪表板中融合了许多的关键指标，这些指标可以一目了然地把我们的各个数据和指标之间错综复杂的关系用最直观的方式为公司的领导和各级员工表现出来，为他们提供决策支持。</p>\n<p>管理驾驶舱的设计，承接了我们整个的指标体系中的度量指标、维度和分析方法，并遵循特定的展现方式，形成了数百页的管理驾驶舱的设计方案，以体现出整体的分析思路和分析步骤的设计。</p>\n<h4 id=\"1-分析展现页面的设计\"><a href=\"#1-分析展现页面的设计\" class=\"headerlink\" title=\"1.分析展现页面的设计\"></a>1.分析展现页面的设计</h4><p>分析展现页面的设计通常有两种手段：一种是通过PPT或者低保真草图绘制工具来设计BI展现页面的需求，一种是通过敏捷BI工具和模拟数据创建并实现分析原型。PPT是报表页面和仪表板页面设计的主要工具通过PPT图表来模拟整个管理驾驶舱中的图表展现和控件，通过PPT中的页面和按钮来模拟管理驾驶舱中的页面流和页面跳转，通过这种方式和领导确认需求，并交由IT团队开发。敏捷BI工具和可视化分析工具，如Tableau、Qlik View等，可用于快速创建原型。此外还有我们熟悉的Excel和Power BI，通过快速原型来创建仪表板开展分析，并进一步交给团队在生产环境中进行部署。</p>\n<h4 id=\"2-页面流设计\"><a href=\"#2-页面流设计\" class=\"headerlink\" title=\"2.页面流设计\"></a>2.页面流设计</h4><p>基于指标体系规划文档，按照指标的树形结构的主题，来确定页面的层次和次序从而形成逻辑一致的页面流。<br><img src=\"/images/数据中台/管理驾驶舱设计-页面流设计.jpg\" alt=\"&quot;管理驾驶舱设计-页面流设计&quot;\"></p>\n<h4 id=\"3-页面跳转设计\"><a href=\"#3-页面跳转设计\" class=\"headerlink\" title=\"3.页面跳转设计\"></a>3.页面跳转设计</h4><p>通常在使用高度综合的指标体系，如“杜邦分析”时，需要对页面跳转进行设计。典型的杜邦分析是以价值树的结构进行展现的。<br><img src=\"/images/数据中台/管理驾驶舱设计-页面跳转设计.jpg\" alt=\"&quot;管理驾驶舱设计-页面跳转设计&quot;\"></p>\n<p>作用<br>刘凯，美国注册管理会计师，管理学硕士，曾就职于奥美互动、新华信、毕博、戴尔等公司。</p>\n","site":{"data":{}},"excerpt":"","more":"<pre><code>企业开展数据化运营，需要指标来驱动业务，但企业内部指标间纷繁复杂，如何拨开云雾，统一指标口径，将指标管理得井井有条，并指导管理驾驶舱建设    企业开展数据化运营，需要指标来驱动业务，但企业内部指标间纷繁复杂，如何拨开云雾，统一指标口径，将指标管理得井井有条，并指导管理驾驶舱建设x    企业开展数据化运营，需要指标来驱动业务，但企业内部指标间纷繁复杂，如何拨开云雾，统一指标口径，将指标管理得井井有条，并指导管理驾驶舱建设    企业开展数据化运营，需要指标来驱动业务，但企业内部指标间纷繁复杂，如何拨开云雾，统一指标口径，将指标管理得井井有条，并指导管理驾驶舱建设x引用。\n结合国际数据领域的方法论和国内企业的最佳实践，通过主题划分、自上而下和自下而上相结合的指标梳理，形成整个企业的分析主题和指标体系框架。通过模拟领导决策过程，开展管理驾驶舱的页面流设计和页面跳转设计，形成流畅的仪表板故事线，并根据发现的问题随时开展更深入的分析，是开展数据化运营，实现业务增长的重点。\n</code></pre><h2 id=\"指标体系规划\"><a href=\"#指标体系规划\" class=\"headerlink\" title=\"指标体系规划\"></a>指标体系规划</h2><h3 id=\"什么是企业指标体系\"><a href=\"#什么是企业指标体系\" class=\"headerlink\" title=\"什么是企业指标体系\"></a>什么是企业指标体系</h3><p> 在传统的企业管理环境下，指标通常是指绩效指标或者业务指标，通常用于KPI考核。随着商务智能和大数据的发展，除了考核以外，指标还用于追踪、用来把握整体变化趋势，关注异常波动；指标也可以用于监测，对超出特定范围的指标异动，用红、黄、绿色交通灯等图标开展预警。<br> 企业的指标通常分散在各个业务流程当中，并且在流程的各个环节当中 由不同部门所计算和采纳。当各个部门应用的指标越来越多时，指标口径不一致，数据重复报送、重复统计等问题也会不断地涌现出来。<br>    企业指标体系规划就是在企业指标体系混乱、指标口径不统一的背景下应运而生的。因此需要对指标体系进行梳理、划分主题、规划蓝图，并通过管理驾驶舱来实施，通过企业数据治理来对指标体系提供数据质量保障。</p>\n<h3 id=\"如何开展指标体系管理？\"><a href=\"#如何开展指标体系管理？\" class=\"headerlink\" title=\"如何开展指标体系管理？\"></a>如何开展指标体系管理？</h3><p> 要想开展指标的数据管理，首先应当对指标进行划分。有许多指标分散在多个IT系统当中，并且跨多个流程和多个部门，并由多个级别的员工使用。因此传统方法很难做到完全穷尽、没有遗漏地对指标进行划分、以便指定指标的归口部门。为了清晰地对企业指标进行划分，业界的最佳实践是按照“主题”对指标进行划分，“主题”是相关性较强的内容的一个聚类。目前国际上已经给出较为通用的指标体系主题划分的框架，如SMART战略板。<br>    指标体系主题划分，主要是从企业管理报表的设计方和创建方的角度出发的。而报表和指标的实际使用过程，通常需要从决策者的需求方的角度出发。这两个角度通常并不一致，SMART战略板的主题划分方法，通常经过一定程度的抽象，因此相对而言比较稳定。在具体的BI实施落地时，通常分为两层结构：一层是相对稳定的指标主题划分，以报表页面流的方式对指标体系进行组织，需要对主题层层细化，最终形成具有层次和次序的页面流；另一层是相对比较灵活易构的磁贴式的仪表板，可以按需进行灵活布局组合，并建立起页面跳转关系，可以进一步查看详情页面并开展交互式分析。通过对企业的指标数据划分主题，形成相对互斥并且完备（MECE)的指标体系、形成页面流，并进一步在此基础之上，增加包含更多跨主题的综合指标的仪表板，如ROE，并建立起同关联密切的页面之间的跳转关系。</p>\n<h3 id=\"3-如何规划指标体系？\"><a href=\"#3-如何规划指标体系？\" class=\"headerlink\" title=\"3.如何规划指标体系？\"></a>3.如何规划指标体系？</h3><p>指标体系的规划，通常有两种方式：自上而下和自下而上。在实践过程中通常是自上而下和自下而上两种方式结合。<br>自上而下的方式，通常就是从数据的顶层设计入手，在数据蓝图的基础上，关注整个企业的价值链条，能够并从中分析出整个价值链上的关键环节，形成层次；按照决策者的通用分析思路进一步细分，形成次序；如此直到第五、第六级主题，作为页面流设计的基础。</p>\n<p>自下而上方式的出必点，通常是企业现有的管理报表体系。通过对企业的管理报表进行梳理，从中提炼出常见的维度、指标度量值，并且进一步明确指标的数据来源，所在系统、统计频率、指标定义、指标口径、分析模式等，通过将维度、度量值进行多维交叉、能够设计出更多指标。</p>\n<h3 id=\"4-指标体系规划的常用工具\"><a href=\"#4-指标体系规划的常用工具\" class=\"headerlink\" title=\"4.指标体系规划的常用工具\"></a>4.指标体系规划的常用工具</h3><h4 id=\"（1）SMART框架\"><a href=\"#（1）SMART框架\" class=\"headerlink\" title=\"（1）SMART框架\"></a>（1）SMART框架</h4><p>SMART战略板很早之前就已经普遍应用于数据战略规划当中，其本质在于将企业的指标划分为5-7类分析主题。</p>\n<h4 id=\"（2）战略地图-平衡计分卡\"><a href=\"#（2）战略地图-平衡计分卡\" class=\"headerlink\" title=\"（2）战略地图/平衡计分卡\"></a>（2）战略地图/平衡计分卡</h4><pre><code>战略地图/平衡计分卡更多强调的是财务非财务、局部与全局、近期与远期之间的平衡。通过该方法可以帮助我们在对分析主题细化时，快速得到一些重要并且综合全面的实用指标。\n</code></pre><h4 id=\"（3）KPI价值树\"><a href=\"#（3）KPI价值树\" class=\"headerlink\" title=\"（3）KPI价值树\"></a>（3）KPI价值树</h4><p>KPI价值树更加强调重点核心指标。这些指标更加适合高管在管理驾驶舱中以仪表板的形式查看，通常这些指标会对应多个分析主题 。</p>\n<h4 id=\"（4）全面预算管理\"><a href=\"#（4）全面预算管理\" class=\"headerlink\" title=\"（4）全面预算管理\"></a>（4）全面预算管理</h4><p>全面预算管理中有效地将业务量指标和财务指标衔接到一起，涵盖企业经营的各个方面。</p>\n<h4 id=\"（5）现有管理报表\"><a href=\"#（5）现有管理报表\" class=\"headerlink\" title=\"（5）现有管理报表\"></a>（5）现有管理报表</h4><p>这可以从现有的管理报表中抽取关键的维度和关键的度量指标作为我们建立整个指标体系的基础 。</p>\n<p>通过以上工具，在蓝图的基础上对子主题进行细化，形成树状的多级主题划分，最终的子主题（如第六级）通常仅包含1个关键指标度量值，或者多个但不超过10个指标。并且对于每个指标：<br>（1）明确指标名称、定义、计算公式、单位。这对于企业统计指标口径，划分指标的归口部门而言非常重要。<br>（2）明确指标需求方。最终指标的使用部门，或者是哪些部门关心现有体系中的指标，需要进一步识别。不同层次的领导有不同的关注点。高层领导可能关心利润、收入、成本，他们都只是站在比较宏观的角度去关心与参考。<br>（3）指标寻源。指标进行寻源是指计算指标所需的基础明细数据和原始来源。指标的归口部门要对指标进行逻辑拆分，通常可拆分为维度和度量两部分，并可以识别出特定的分析模式和计算公式。<br>（4）指标分析模式。对于整个管理驾驶舱中的各项指标，要能体现出具体的分析模式，这些分析模式包括同比、环比、结构占比、完成率分析等。<br>（5）指标分析的时间/机构维度。所谓时间维度是指报表或指标的具体统计频率、可按年、月、周来统计。所谓机构维度是指整个集团级别的还是某个二级单位级别的。<br>（6）图表的可视化展现方式。另外还要考虑不同的图表展现方式。饼图、条形图、柱形图、拆线图是最常用最直观的图表类型。另外，热力图、面积图、标签云、漏斗图、瀑布图以及各类组合图表在特定场合下也能形成很好的展现效果。<br>这些指标的分类和次序，成为下一步管理驾驶舱的页面流设计的基础框架，形成带有层次和次序的页面流，每个页面中包含了一个或多个指标，并且通过识别的分析模式和可视化展现方式，能为管理驾驶舱的详细设计提供良好的指导 。</p>\n<h2 id=\"管理驾驶舱的设计\"><a href=\"#管理驾驶舱的设计\" class=\"headerlink\" title=\"管理驾驶舱的设计\"></a>管理驾驶舱的设计</h2><h3 id=\"什么是管理驾驶舱？\"><a href=\"#什么是管理驾驶舱？\" class=\"headerlink\" title=\"什么是管理驾驶舱？\"></a>什么是管理驾驶舱？</h3><p> 管理驾驶舱，是通过统计分析工具和图表工具来创建的仪表板，各个仪表板之间通过整个的故事线链接起来。仪表板中融合了许多的关键指标，这些指标可以一目了然地把我们的各个数据和指标之间错综复杂的关系用最直观的方式为公司的领导和各级员工表现出来，为他们提供决策支持。</p>\n<p>管理驾驶舱的设计，承接了我们整个的指标体系中的度量指标、维度和分析方法，并遵循特定的展现方式，形成了数百页的管理驾驶舱的设计方案，以体现出整体的分析思路和分析步骤的设计。</p>\n<h4 id=\"1-分析展现页面的设计\"><a href=\"#1-分析展现页面的设计\" class=\"headerlink\" title=\"1.分析展现页面的设计\"></a>1.分析展现页面的设计</h4><p>分析展现页面的设计通常有两种手段：一种是通过PPT或者低保真草图绘制工具来设计BI展现页面的需求，一种是通过敏捷BI工具和模拟数据创建并实现分析原型。PPT是报表页面和仪表板页面设计的主要工具通过PPT图表来模拟整个管理驾驶舱中的图表展现和控件，通过PPT中的页面和按钮来模拟管理驾驶舱中的页面流和页面跳转，通过这种方式和领导确认需求，并交由IT团队开发。敏捷BI工具和可视化分析工具，如Tableau、Qlik View等，可用于快速创建原型。此外还有我们熟悉的Excel和Power BI，通过快速原型来创建仪表板开展分析，并进一步交给团队在生产环境中进行部署。</p>\n<h4 id=\"2-页面流设计\"><a href=\"#2-页面流设计\" class=\"headerlink\" title=\"2.页面流设计\"></a>2.页面流设计</h4><p>基于指标体系规划文档，按照指标的树形结构的主题，来确定页面的层次和次序从而形成逻辑一致的页面流。<br><img src=\"/images/数据中台/管理驾驶舱设计-页面流设计.jpg\" alt=\"&quot;管理驾驶舱设计-页面流设计&quot;\"></p>\n<h4 id=\"3-页面跳转设计\"><a href=\"#3-页面跳转设计\" class=\"headerlink\" title=\"3.页面跳转设计\"></a>3.页面跳转设计</h4><p>通常在使用高度综合的指标体系，如“杜邦分析”时，需要对页面跳转进行设计。典型的杜邦分析是以价值树的结构进行展现的。<br><img src=\"/images/数据中台/管理驾驶舱设计-页面跳转设计.jpg\" alt=\"&quot;管理驾驶舱设计-页面跳转设计&quot;\"></p>\n<p>作用<br>刘凯，美国注册管理会计师，管理学硕士，曾就职于奥美互动、新华信、毕博、戴尔等公司。</p>\n"},{"title":"Oracle网络和数据库连接","date":"2017-04-01T07:30:00.000Z","_content":"内容来自《Oracle Database 11g 数据库管理艺术》\n# 网络概念：Oracle网络如何工作\n在希望从客户机（不管是传统客户机还是基于浏览器的客户机）打开数据库会话时，需要通过网络连接到数据库。假如要将台式电脑通过现有网络连接到UNIX服务器上的一个Oracle数据库，则需要在电脑和Oracle数据库（它使用专门的软件）之间构造一个连接方法。需要某种界面来处理会话（在此例子中为SQL*Plus），并且需要某种与业内标准的网络协议（如TCP/IP）通信的方法。  \n为方便配置和管理网络连接，Oracle提供了Oracle Net Services，它是一套在分布式异构计算环境中提供连接方案的组件。Oracle Net Services由Oracle Net、Oracle Net Listener、Oracle Connection Manager、Oracle Net Configuration Assistant和Oracle Net Manager组成。Oracle Net Services软件是在Oracle Database Server或Oracle Client软件安装的过程中自动安装的。  \nOracle Net是一个初始化、建立及维护客户机和服务器之间的连接的组件。这就是为什么必须在客户机和服务器上都安装Oracle Net的原因。Oracle Net主要由两个组件构成。  \nOracle Network Foundation Layer：负责建立和维护客户机应用程序与服务器之间的连接，以及它们之间的交换信息。  \nOracle Protocol Support： 负责映射Transparent Net Substrate（TNS）功能到连接使用的业内标准协议。\n驻留Oracle数据库的所有服务器还运行一个名为Oracle Net Listener（通常也称为监听器）的服务，其主要功能是监听来自客户机服务登录Oracle数据库的请求。监听器在保证客户机服务具有与数据库匹配的信息（协议、端口和实例名）后，将客户机请求传递到数据库。假如用户名和密码通过认证，则数据库将允许客户机登录。一旦监听器把用户请求交付给数据库，客户机和数据库将直接连接，不再需要监听器的帮助。\nOracle提供了基于GUI的大量的实用程序，以帮助配置数据库的网络连接。这些实用程序包括Oracle Connection Manager、Oracle Net Manager和Oracle Net Configuragion Assistant等。这些工具帮助处理所有网络需求。在结束本章学习后，可单击这些程序的图标，开始测试连接的实验。  \n# Web应用如何连接到Oracle数据库\n为了构造Oracle数据库的一个Internet连接，客户机上的Web浏览器要与Web服务器通信并使用HTTP进行连接请求。Web服务器将此请求传递给一个应用，该应用处理收到的请求并用Oracle Net（配置在数据库服务器和客户机上）与Oracle数据库服务器通信  \n\t下面介绍Oracle网络中几个关键的术语  \n## 数据库实例名\n正如所知，Oracle实例由SGA和一组Oracle进程组成。数据库实例名在初始化文件（init.ora）中作为INSTANCE_NAME参数给出。在谈到Oracle SID（System identifier，系统标识符）时，指的是Oracle实例。  \n\t通常，每个数据库只有一个与其关联的实例。但在Oracle RAC配置中，单个数据库可关联到多个实例。  \n## 全局数据库名\n全局数据库名唯一地标识一个Oracle数据库，其格式为database_name.database_domain，如sales.us.acme.com。在这个全局数据库中，sales为数据库名，us.acme.com为数据库域。因为相同的域中两个数据库不会有相同的数据库名，所以每个全局数据库名都是唯一的。  \n## 数据库服务名\n对于客户机，数据库在逻辑上简单地表现为一个服务。在服务和数据库之间存在一个多对多的关系，因为一个数据库可被一个或多个服务所代表，每个服务都专用于一组不同的客户机，而一个服务可覆盖不止一个数据库实例。我们在自己的系统中用每个数据库的服务名来标识它，用初始化参数SERVICE_NAMES来指定数据库的服务名。服务名参数值默认为全局数据库名。  \n请注意，一个数据库可由多个服务名来访问。如果希望不同的客户机组访问适合于它们的特定需求的不同数据库，应该这样做。例如，可对相同数据库创建如下两个服务名：  \nSales.us.acme.com  \nFinance.us.acme.com  \n销售人员使用sales.us.acme.com服务名，而财务人员则使用finance.us.acme.com服务名。  \n## 连接描述符\n为了将电脑连接到世界上的任何数据库服务，需要提供两个信息：  \n\t数据库服务名；  \n\t地址。   \nOracle使用术语连接描述符(connect descriptor)来表示数据库连接的两个必需的部分：数据库服务名和地址。连接描述符的地址部分包含三个部分，分别是：连接使用的通信协议、主机名和端口号。  \n了解通信协议有助于保证使用合适的网络协议，以便建立连接。标准的协议为TCP/IP或带SSL（Secure Sockets Layer，安全套接层）的TCP/IP。UNIX服务器上的Oracle连接的标准端口为1521或1526.Windows机器上的默认端口为1521.因为任何主机上的数据库具有唯一服务名，所以一个Oracle数据库服务名和一个主机名将唯一地标识任何数据库。下面是一个典型的连接描述符的例子：  \n(DESCRIPTION\n(ADDRESS=(PROTOCOL=tcp)(HOST=sales-server)(PORT=1521))\n(CONNECT_DATA=\n(SERVICE_NAME=sales.us.acme.com)))  \n在此连接描述符中，ADDRESS行指出网络通信将使用TCP协议。HOST指定UNIX（或Windows）服务器，服务器上的Oracle监听器正监听来自端口1521的连接请求。连接描述符的ADDRESS部分也称为协议地址(protocol address)。\n希望连接数据库的客户机首先连接到Oracle监听器进程。监听器接收到达的请求并把它们交给数据库服务器。一旦客户机和数据库服务器通过监听器的引导连接上，它们就直接通信，在此客户机连接的通信过程中不再需要监听器。  \n## 连接标识符\n连接标识符（connect identifier）与连接描述符紧密关联。可把连接描述符作为连接标识符，或者可简单地映射一个数据库服务名为一个连接描述符。例如，可以把一个服务名(如sales)映射为11.2.5节所看到的连接描述符。下面是说明映射sales连接标识符的例子。  \nSales=\n(DESCRIPTION\n(ADDRESS=(PROTOCOL=tcp)(HOST=sales-server)(PORT=1521))\n(CONNECT_DATA=\n(SERVICE_NAME=sales.us.acme.com)))  \n## 连接串 \n通过提供一个连接串(connect string)连接到数据库。连接串包含用户名/密码组合及一个连接标识符。最常见的连接标识符之一是节点服务名，它是一个数据库服务的名字。  \n下面的例子给出一个连接串，它把一个完整的连接描述符作为连接标识符  \n\tCONNECT scott/tiger@(DESCRIPTION=\n\t(ADDRESS=(PROTOCOL=tcp)\n\t(HOST=sales-server)\n\t(PORT=1521))\n\t(CONNECT_DATA=\n\t(SERVICE_NAME=sales.us.acme.com)))\n下面是一个更简单的连接到相同数据库的方法，它使用连接标识符sales：  \n\tCONNECT scott/tiger@sales  \n上面两个例子都能连接到sales数据库，但显然第二个连接串（使用sales连接标识符）简单得多。  \n \n## 使用Oracle网络服务工具\nOracle Net提供了配置客户机与数据库服务之间的连接的几个GUI和命令行工具。最常用的命令行工具是isnrctl实用程序，它帮助管理Oracle监听器服务。下面是帮助管理Oracle Net Servcies的重要GUI工具。  \nOracle NCA（Net Configuration Assistant，Oracle网络配置助手）。此工具主要用于在安装中配置网络组件，它允许在配置客户机连接的几个选项（本章稍后介绍这些选项）中进行选择。其便于使用的GUI界面使你能在所选择的任何命名方法下快速配置客户机连接。在UNIX/Linux系统上，可通过从$ORACLE_HOME/bin目录执行netca来启动NCA。在Window系统上，选择Start|Programs|Oracle-HOME_NAME|Configuration and Migration Tools|Net ConfigurationAssistant。  \nOracle网络配置管理器（Oracle Net Manager）。Oracle Net Manager可在客户机和服务器上运行，它允许配置各种命名方法和监听器。利用此工具，可在本地tnsnames.ora文件或在集中式的OID中配置连接描述符，而且可以方便地增加和修改连接方法。  \n为了从Oracle企业管理器控制台启动Oracle Net Manager，选择Tools|Service Management|Oracle Net Manager。为了在Unix上作为独立的应用启动Oracle Net Manager，在ORACLE_HOME/bin目录执行netmgr。在windown上，选择Start|Programs|Oracle-HOME_NAME|Configuration and Migration Tools|NetManager。  \nOracle企业管理器（Oracle Enterprise Manager）。Oracle Database 11g中的OEM可以完成Oracle Net Manager能完成的所有任务，但不能跨多个文件系统管理多个Oracle主目录。此外，使用OEM可导出目录命名项到tnsnames.ora文件。  \nOracle目录管理器（Oracle Directory Manager）。这个功能强大的工具允许创建使用OID必需的各种域和环境。用此工具还可以执行密码策略管理及完成许多Oracle高级安全任务。在UNIX/LINUX系统上，可从$ORACLE_HOME/bin目录执行oidadmin来启动OID。在Window系统上，选择Start|Programs|Oracle-HOME_NAME|Integrated Manager Tools|Oracle Directory Manager。  \n# 即时客户机\n之前说过Oracle客户机安装需要经历常规的Oracle数据库服务器软件安排的所有预备步骤。幸而为连接到Oracle数据库并不总是需要安装完整的Oracle客户机软件。Oracle的新Instant Client（即时客户机）软件允许执行应用程序而不必安装标准的Oracle客户机也不必具有ORACLE_HOME。不需要为访问Oracle数据库的每台机器安装Oracle客户机软件。所有现有的OCI、ODBC和JDBC应用程序都可以使用Instan Client。如果愿意，甚至可以用Instant Client使用SQL*Plus。  \n\t相对于完整的Oracle客户机，Instant Clients提供以下好处：  \nA. 它是免费的；  \nB. 战胜磁盘空间较少  \nC. 安装更快（5分钟左右）  \nD. 不需要CD  \nE. 它具有Oracle客户机的所有特性，如果有必要甚至包括使用SQL*Plus。  \n\n# 安装Instant Client\n以下是安装新Instant Client软件并快速连接到Oracle数据库的步骤。  \n(1) 从OTN Web站点下载Instant Client软件。你必须安装基本的客户机程序包，还可以包括其他高级可选的程序包。此程序包含以下内容：    \n\ta) Basic：运行OCI、OCCI和JDBC-OCI应用程序所需的文件。  \n\tb) SQL*Plus：为用Instant Client运行SQL*Plus需要的库和可执行文件。  \n\tc) JDBC Supplement：另外支持XA、国际化及JDBC下的RowSet操作。  \n\td) ODBC Supplement：启用带Instant Client的ODBC应用的另外的库（仅对Windows）。  \n\te) SDK：用于Instant Client开发Oracle应用程序所需的其他文件。  \n(2) 将选择的程序包解压到某个目录，将些目录命名为instantclient或其它类似的名称。  \n(3) 在UNIX和Linux系统中，将环境变量LD_LIBRARY_PATH设置为instantclient（从而保证此参数的设置与程序包所有所在的目录名匹配）。在Winddows系统上，将环境变量PATH设置为instantclient。  \n(4) 测试对Oracle服务器的连接。  \n# 监听器和连接\nOracle监听器是一个只运行在服务器上并监听连接请求的服务。Oracle提供一个名为lsnrctl的实用程序来管理监听器进程。以下是监听器如何配合Oracle网络的概述。  \na. 数据库用监听器记录关于服务、实例及服务处理器的信息  \nb. 客户机与监听器进行初步连接  \nc. 监听器接收和验证客户机连接请求并把此请求交给数据库服务的服务处理器。一旦交付了客户机请求，监听器在该连接中不再起作用。  \nListener.ora文件默认位置在UNIX系统上为$ORACLE_HOME/network/admin目录，在Windows系统上为$ORACLE_HOME\\network\\admin目录，它包含监听器的配置信息。因为监听器服务只运行在服务器上，因此在客户机上没有listener.ora文件。代码清单11-1给出了一个典型的listener.ora文件。  \nListener中的所有配置参数都具有默认值，不需要手动配置监听器服务。在服务器上创建了第一个数据库后，监听器服务自动启动，并且将监听器配置文件listener.ora放于默认目录中。新数据库创建后，数据库的网络和服务信息自动添加到监听器的配置文件中。实例启动后，数据库自动向监听器注册，并且监听器开始监听对此数据库的连接请求。  \n代码清单11-1 典型的监听器配置文件  \n代码清单11-1 典型的监听器配置文件   \n\t#LISTENRE.ORA Network Configuration file \n\t/u01/app/oracle/product/11.1.0.6.0/db_1/network/admin/listener.ora\n\tSID_LIST_LISTENER = \n\t(DESCRIPTION_LIST =\n\t\t(DESCRIPTION = \n\t\t\t  (ADDRESS_LIST = \n\t\t\t\t(ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC4))\n\t\t\t)\n\t\t\t(ADDRESS_LIST = \n\t\t\t\t(ADDRESS = (PROTOCOL = TCP)(HOST = NTL-ALAPATISAM)(PORT = 1521))\n\t\t\t)\n\t\t)\n\t)\n\tSID_LIST_LISTENER = \n\t\t(SID_LIST = \n\t\t(SID_DESC = \n\t\t\t(SID_NAME = PLSExtProc)\n\t\t\t(ORACLE_HOME = /u01/app/oracle/product/11.1.0/db_1)\n\t\t\t(PROGRAM = extproc)\n\t\t)\n\t\t(SID_DESC = \n\t\t\t(GLOBAL_DBNAME = remorse.world)\n\t\t\t(ORACLE_HOME = /u01/app/oracle/product/11.1.0/db_1)\n\t\t\t(SID_NAME = remorse)\n\t\t)\n\t\t(SID_DESC = \n\t\t\t(GLOBAL_DBNAME = finance.world)\n\t\t\t(ORACLE_HOME = /u01/app/oracle/product/11.1.0/db_1)\n\t\t\t(SID_NAME = finance)\n\t\t)\n\t)\n\t \n## 自动服务注册\nOracle PMON进程负责向监听器动态服务注册新Oracle数据库服务名，也就是说，在创建新Oracle数据库时，它们将自动向监听器服务注册。PMON进程将在每个新数据库在服务器上创建之后更新listener.ora文件。\n为自动服务注册，ini.ora文件或SPFILE应该包含如下参数：  \na. SERVICE_NAMES(如sales.us.oracle.com)  \nb. INSTANCE_NAME(如sales)  \n如果不指定SERVICE_NAMES参数的值，它默认为全局数据库名，全局数据库名是DB_NAME和DB_DOMAIN参数的组合。INSTANCE_NAME参数的默认值为Oracle安装或数据库创建时输入的SID。  \n可使用lsnrctl实用程序查看服务器上监听器的状态，如代码清单11-2所示。相应的输出说明监听器启动了多长时间，监听器服务的配置文件位于何处。它还给出监听器为连接请求而监听的数据库的名称。  \n代码清单11-2 使用lsnrctl实用程序查看监听器的状态  \n$ lsnrctl status  \n\t \n在代码清单11-2的Services Summary部分，相应的状态可具有如下的某个值。  \na. READY：此实例可接受连接  \nb. BLOCKED：此实例不能接受连接  \nc. UNKNOWN：此实例在listener.ora文件中注册而不是通过动态服务注册，因而不知道其状态  \n## 监听器命令\n在调用lsnrctl实用程序后，除了status命令外还可以执行其他一些重要的命令。例如，service命令允许查看监听器正为连接请求而监控的是什么服务。  \n注解：还可以从Oracle企业管理器的Net Services Administration页面查看监听器服务的状态。  \n代码清单11-2 使用lsnrctl help列出lsnrctl命令  \n$lsnrctl help  \n可以调用lsnrctl实用程序后，使用start命令启动监听器，使用stop命令停业监听器。如果希望从操作系统命令行发布这些命令，可使用lsnrctl start和lsnrctl stop命令执行这两个任务。  \n如果对listener.ora文件做了更改，为使更改起作用的一种方法是重启监听器。另一种安全的方法是重新装载监听信息，包括对监听器配置文件所做的最新更改。Lsnrctl reload命令允许在运行中重新装载监听器，而不用重新启动它。在监听器重装载（甚至是重启）的过程中，当前连接的客户机将继续保持连接，因为监听器已经将连接“交付”给数据库，在客户和数据库服务之间不起作用。  \n注意：我的忠告是，如非绝对有必要，不要修改listener.ora文件，而且对于动态自动服务注册，几乎没有必要修改此文件。不过，有时可能需要修改监听器文件的某些部分，此文件由监听器监控连接请求的所有服务的网络配置信息组成。  \n## 命名和连接\n在前面连接描述符和连接标识符的例子中，使用sales连接标识符来连接sales服务。连接标识符可以是连接描述符本身，也可以是一个能解析为连接描述符的简单名字(如sales)。一般使用的简单连接标识符称为net service name(网络服务名)。因此前面例子中的sales连接标识符就是一个net service name。  \n因为每次进行连接时都需要提供一下完整的连接描述符非常令人厌烦，使用网络服务名是明智的。但这需要维护网络服务名和连接描述信息之间所有映射的一个中心信息库(central repository)，以便Oracle验证这些网络服务名。因此，在一个用户使用网络服务名sales启动连接进程时，Oracle将搜索中心信息库查找sales的连接描述符。找到连接描述符后，Oracle Net会为指定服务器上的数据库初始化一个连接。  \nOracle允许几种类型的命名信息库，可用下列4种命名方法访问存储在这些位置中的映射信息。  \na. 本地命令(local naming )：使用存储在每个客户机上的名为tnsnames.ora的文件连接到数据库服务器。  \nb. 简易连接命名(easy connect naming)：允许连接而无需任何服务名配置。  \nc. 外部命名(external naming)：使用第三方命名服务来解析服务名。  \nd. 目录命令(directory naming)：使用一个集中式的符合LDAP的目录服务器来解析服务名。  \n\t不管使用何种命名方法，名字解析过程都是相同的。每种命名法都遵循以下步骤将连接描述符解析为网络服务名：\ni. 选择命令方法—本地、简易连接、外部命名或目录服务命名  \nii. 映射连接描述符到服务名；  \niii. 配置客户机以使用步骤1中选择的命名方法  \n## 本地命名方法\n本地命令是建立Oracle连接最简单、最容易的方法。使用这种方法，在名为tnsnames.ora的本地化配置文件中存储服务名及其连接描述符。此文件默认存储在$ORACLE_HOME/network/admin目录中。  \n","source":"_posts/oracle/Oracle网络和数据库连接.md","raw":"---\ntitle: Oracle网络和数据库连接\ndate: 2017-04-01 15:30:00\ntags: [oracle,数据库]\ncategories: [数据库,oracle]\n---\n内容来自《Oracle Database 11g 数据库管理艺术》\n# 网络概念：Oracle网络如何工作\n在希望从客户机（不管是传统客户机还是基于浏览器的客户机）打开数据库会话时，需要通过网络连接到数据库。假如要将台式电脑通过现有网络连接到UNIX服务器上的一个Oracle数据库，则需要在电脑和Oracle数据库（它使用专门的软件）之间构造一个连接方法。需要某种界面来处理会话（在此例子中为SQL*Plus），并且需要某种与业内标准的网络协议（如TCP/IP）通信的方法。  \n为方便配置和管理网络连接，Oracle提供了Oracle Net Services，它是一套在分布式异构计算环境中提供连接方案的组件。Oracle Net Services由Oracle Net、Oracle Net Listener、Oracle Connection Manager、Oracle Net Configuration Assistant和Oracle Net Manager组成。Oracle Net Services软件是在Oracle Database Server或Oracle Client软件安装的过程中自动安装的。  \nOracle Net是一个初始化、建立及维护客户机和服务器之间的连接的组件。这就是为什么必须在客户机和服务器上都安装Oracle Net的原因。Oracle Net主要由两个组件构成。  \nOracle Network Foundation Layer：负责建立和维护客户机应用程序与服务器之间的连接，以及它们之间的交换信息。  \nOracle Protocol Support： 负责映射Transparent Net Substrate（TNS）功能到连接使用的业内标准协议。\n驻留Oracle数据库的所有服务器还运行一个名为Oracle Net Listener（通常也称为监听器）的服务，其主要功能是监听来自客户机服务登录Oracle数据库的请求。监听器在保证客户机服务具有与数据库匹配的信息（协议、端口和实例名）后，将客户机请求传递到数据库。假如用户名和密码通过认证，则数据库将允许客户机登录。一旦监听器把用户请求交付给数据库，客户机和数据库将直接连接，不再需要监听器的帮助。\nOracle提供了基于GUI的大量的实用程序，以帮助配置数据库的网络连接。这些实用程序包括Oracle Connection Manager、Oracle Net Manager和Oracle Net Configuragion Assistant等。这些工具帮助处理所有网络需求。在结束本章学习后，可单击这些程序的图标，开始测试连接的实验。  \n# Web应用如何连接到Oracle数据库\n为了构造Oracle数据库的一个Internet连接，客户机上的Web浏览器要与Web服务器通信并使用HTTP进行连接请求。Web服务器将此请求传递给一个应用，该应用处理收到的请求并用Oracle Net（配置在数据库服务器和客户机上）与Oracle数据库服务器通信  \n\t下面介绍Oracle网络中几个关键的术语  \n## 数据库实例名\n正如所知，Oracle实例由SGA和一组Oracle进程组成。数据库实例名在初始化文件（init.ora）中作为INSTANCE_NAME参数给出。在谈到Oracle SID（System identifier，系统标识符）时，指的是Oracle实例。  \n\t通常，每个数据库只有一个与其关联的实例。但在Oracle RAC配置中，单个数据库可关联到多个实例。  \n## 全局数据库名\n全局数据库名唯一地标识一个Oracle数据库，其格式为database_name.database_domain，如sales.us.acme.com。在这个全局数据库中，sales为数据库名，us.acme.com为数据库域。因为相同的域中两个数据库不会有相同的数据库名，所以每个全局数据库名都是唯一的。  \n## 数据库服务名\n对于客户机，数据库在逻辑上简单地表现为一个服务。在服务和数据库之间存在一个多对多的关系，因为一个数据库可被一个或多个服务所代表，每个服务都专用于一组不同的客户机，而一个服务可覆盖不止一个数据库实例。我们在自己的系统中用每个数据库的服务名来标识它，用初始化参数SERVICE_NAMES来指定数据库的服务名。服务名参数值默认为全局数据库名。  \n请注意，一个数据库可由多个服务名来访问。如果希望不同的客户机组访问适合于它们的特定需求的不同数据库，应该这样做。例如，可对相同数据库创建如下两个服务名：  \nSales.us.acme.com  \nFinance.us.acme.com  \n销售人员使用sales.us.acme.com服务名，而财务人员则使用finance.us.acme.com服务名。  \n## 连接描述符\n为了将电脑连接到世界上的任何数据库服务，需要提供两个信息：  \n\t数据库服务名；  \n\t地址。   \nOracle使用术语连接描述符(connect descriptor)来表示数据库连接的两个必需的部分：数据库服务名和地址。连接描述符的地址部分包含三个部分，分别是：连接使用的通信协议、主机名和端口号。  \n了解通信协议有助于保证使用合适的网络协议，以便建立连接。标准的协议为TCP/IP或带SSL（Secure Sockets Layer，安全套接层）的TCP/IP。UNIX服务器上的Oracle连接的标准端口为1521或1526.Windows机器上的默认端口为1521.因为任何主机上的数据库具有唯一服务名，所以一个Oracle数据库服务名和一个主机名将唯一地标识任何数据库。下面是一个典型的连接描述符的例子：  \n(DESCRIPTION\n(ADDRESS=(PROTOCOL=tcp)(HOST=sales-server)(PORT=1521))\n(CONNECT_DATA=\n(SERVICE_NAME=sales.us.acme.com)))  \n在此连接描述符中，ADDRESS行指出网络通信将使用TCP协议。HOST指定UNIX（或Windows）服务器，服务器上的Oracle监听器正监听来自端口1521的连接请求。连接描述符的ADDRESS部分也称为协议地址(protocol address)。\n希望连接数据库的客户机首先连接到Oracle监听器进程。监听器接收到达的请求并把它们交给数据库服务器。一旦客户机和数据库服务器通过监听器的引导连接上，它们就直接通信，在此客户机连接的通信过程中不再需要监听器。  \n## 连接标识符\n连接标识符（connect identifier）与连接描述符紧密关联。可把连接描述符作为连接标识符，或者可简单地映射一个数据库服务名为一个连接描述符。例如，可以把一个服务名(如sales)映射为11.2.5节所看到的连接描述符。下面是说明映射sales连接标识符的例子。  \nSales=\n(DESCRIPTION\n(ADDRESS=(PROTOCOL=tcp)(HOST=sales-server)(PORT=1521))\n(CONNECT_DATA=\n(SERVICE_NAME=sales.us.acme.com)))  \n## 连接串 \n通过提供一个连接串(connect string)连接到数据库。连接串包含用户名/密码组合及一个连接标识符。最常见的连接标识符之一是节点服务名，它是一个数据库服务的名字。  \n下面的例子给出一个连接串，它把一个完整的连接描述符作为连接标识符  \n\tCONNECT scott/tiger@(DESCRIPTION=\n\t(ADDRESS=(PROTOCOL=tcp)\n\t(HOST=sales-server)\n\t(PORT=1521))\n\t(CONNECT_DATA=\n\t(SERVICE_NAME=sales.us.acme.com)))\n下面是一个更简单的连接到相同数据库的方法，它使用连接标识符sales：  \n\tCONNECT scott/tiger@sales  \n上面两个例子都能连接到sales数据库，但显然第二个连接串（使用sales连接标识符）简单得多。  \n \n## 使用Oracle网络服务工具\nOracle Net提供了配置客户机与数据库服务之间的连接的几个GUI和命令行工具。最常用的命令行工具是isnrctl实用程序，它帮助管理Oracle监听器服务。下面是帮助管理Oracle Net Servcies的重要GUI工具。  \nOracle NCA（Net Configuration Assistant，Oracle网络配置助手）。此工具主要用于在安装中配置网络组件，它允许在配置客户机连接的几个选项（本章稍后介绍这些选项）中进行选择。其便于使用的GUI界面使你能在所选择的任何命名方法下快速配置客户机连接。在UNIX/Linux系统上，可通过从$ORACLE_HOME/bin目录执行netca来启动NCA。在Window系统上，选择Start|Programs|Oracle-HOME_NAME|Configuration and Migration Tools|Net ConfigurationAssistant。  \nOracle网络配置管理器（Oracle Net Manager）。Oracle Net Manager可在客户机和服务器上运行，它允许配置各种命名方法和监听器。利用此工具，可在本地tnsnames.ora文件或在集中式的OID中配置连接描述符，而且可以方便地增加和修改连接方法。  \n为了从Oracle企业管理器控制台启动Oracle Net Manager，选择Tools|Service Management|Oracle Net Manager。为了在Unix上作为独立的应用启动Oracle Net Manager，在ORACLE_HOME/bin目录执行netmgr。在windown上，选择Start|Programs|Oracle-HOME_NAME|Configuration and Migration Tools|NetManager。  \nOracle企业管理器（Oracle Enterprise Manager）。Oracle Database 11g中的OEM可以完成Oracle Net Manager能完成的所有任务，但不能跨多个文件系统管理多个Oracle主目录。此外，使用OEM可导出目录命名项到tnsnames.ora文件。  \nOracle目录管理器（Oracle Directory Manager）。这个功能强大的工具允许创建使用OID必需的各种域和环境。用此工具还可以执行密码策略管理及完成许多Oracle高级安全任务。在UNIX/LINUX系统上，可从$ORACLE_HOME/bin目录执行oidadmin来启动OID。在Window系统上，选择Start|Programs|Oracle-HOME_NAME|Integrated Manager Tools|Oracle Directory Manager。  \n# 即时客户机\n之前说过Oracle客户机安装需要经历常规的Oracle数据库服务器软件安排的所有预备步骤。幸而为连接到Oracle数据库并不总是需要安装完整的Oracle客户机软件。Oracle的新Instant Client（即时客户机）软件允许执行应用程序而不必安装标准的Oracle客户机也不必具有ORACLE_HOME。不需要为访问Oracle数据库的每台机器安装Oracle客户机软件。所有现有的OCI、ODBC和JDBC应用程序都可以使用Instan Client。如果愿意，甚至可以用Instant Client使用SQL*Plus。  \n\t相对于完整的Oracle客户机，Instant Clients提供以下好处：  \nA. 它是免费的；  \nB. 战胜磁盘空间较少  \nC. 安装更快（5分钟左右）  \nD. 不需要CD  \nE. 它具有Oracle客户机的所有特性，如果有必要甚至包括使用SQL*Plus。  \n\n# 安装Instant Client\n以下是安装新Instant Client软件并快速连接到Oracle数据库的步骤。  \n(1) 从OTN Web站点下载Instant Client软件。你必须安装基本的客户机程序包，还可以包括其他高级可选的程序包。此程序包含以下内容：    \n\ta) Basic：运行OCI、OCCI和JDBC-OCI应用程序所需的文件。  \n\tb) SQL*Plus：为用Instant Client运行SQL*Plus需要的库和可执行文件。  \n\tc) JDBC Supplement：另外支持XA、国际化及JDBC下的RowSet操作。  \n\td) ODBC Supplement：启用带Instant Client的ODBC应用的另外的库（仅对Windows）。  \n\te) SDK：用于Instant Client开发Oracle应用程序所需的其他文件。  \n(2) 将选择的程序包解压到某个目录，将些目录命名为instantclient或其它类似的名称。  \n(3) 在UNIX和Linux系统中，将环境变量LD_LIBRARY_PATH设置为instantclient（从而保证此参数的设置与程序包所有所在的目录名匹配）。在Winddows系统上，将环境变量PATH设置为instantclient。  \n(4) 测试对Oracle服务器的连接。  \n# 监听器和连接\nOracle监听器是一个只运行在服务器上并监听连接请求的服务。Oracle提供一个名为lsnrctl的实用程序来管理监听器进程。以下是监听器如何配合Oracle网络的概述。  \na. 数据库用监听器记录关于服务、实例及服务处理器的信息  \nb. 客户机与监听器进行初步连接  \nc. 监听器接收和验证客户机连接请求并把此请求交给数据库服务的服务处理器。一旦交付了客户机请求，监听器在该连接中不再起作用。  \nListener.ora文件默认位置在UNIX系统上为$ORACLE_HOME/network/admin目录，在Windows系统上为$ORACLE_HOME\\network\\admin目录，它包含监听器的配置信息。因为监听器服务只运行在服务器上，因此在客户机上没有listener.ora文件。代码清单11-1给出了一个典型的listener.ora文件。  \nListener中的所有配置参数都具有默认值，不需要手动配置监听器服务。在服务器上创建了第一个数据库后，监听器服务自动启动，并且将监听器配置文件listener.ora放于默认目录中。新数据库创建后，数据库的网络和服务信息自动添加到监听器的配置文件中。实例启动后，数据库自动向监听器注册，并且监听器开始监听对此数据库的连接请求。  \n代码清单11-1 典型的监听器配置文件  \n代码清单11-1 典型的监听器配置文件   \n\t#LISTENRE.ORA Network Configuration file \n\t/u01/app/oracle/product/11.1.0.6.0/db_1/network/admin/listener.ora\n\tSID_LIST_LISTENER = \n\t(DESCRIPTION_LIST =\n\t\t(DESCRIPTION = \n\t\t\t  (ADDRESS_LIST = \n\t\t\t\t(ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC4))\n\t\t\t)\n\t\t\t(ADDRESS_LIST = \n\t\t\t\t(ADDRESS = (PROTOCOL = TCP)(HOST = NTL-ALAPATISAM)(PORT = 1521))\n\t\t\t)\n\t\t)\n\t)\n\tSID_LIST_LISTENER = \n\t\t(SID_LIST = \n\t\t(SID_DESC = \n\t\t\t(SID_NAME = PLSExtProc)\n\t\t\t(ORACLE_HOME = /u01/app/oracle/product/11.1.0/db_1)\n\t\t\t(PROGRAM = extproc)\n\t\t)\n\t\t(SID_DESC = \n\t\t\t(GLOBAL_DBNAME = remorse.world)\n\t\t\t(ORACLE_HOME = /u01/app/oracle/product/11.1.0/db_1)\n\t\t\t(SID_NAME = remorse)\n\t\t)\n\t\t(SID_DESC = \n\t\t\t(GLOBAL_DBNAME = finance.world)\n\t\t\t(ORACLE_HOME = /u01/app/oracle/product/11.1.0/db_1)\n\t\t\t(SID_NAME = finance)\n\t\t)\n\t)\n\t \n## 自动服务注册\nOracle PMON进程负责向监听器动态服务注册新Oracle数据库服务名，也就是说，在创建新Oracle数据库时，它们将自动向监听器服务注册。PMON进程将在每个新数据库在服务器上创建之后更新listener.ora文件。\n为自动服务注册，ini.ora文件或SPFILE应该包含如下参数：  \na. SERVICE_NAMES(如sales.us.oracle.com)  \nb. INSTANCE_NAME(如sales)  \n如果不指定SERVICE_NAMES参数的值，它默认为全局数据库名，全局数据库名是DB_NAME和DB_DOMAIN参数的组合。INSTANCE_NAME参数的默认值为Oracle安装或数据库创建时输入的SID。  \n可使用lsnrctl实用程序查看服务器上监听器的状态，如代码清单11-2所示。相应的输出说明监听器启动了多长时间，监听器服务的配置文件位于何处。它还给出监听器为连接请求而监听的数据库的名称。  \n代码清单11-2 使用lsnrctl实用程序查看监听器的状态  \n$ lsnrctl status  \n\t \n在代码清单11-2的Services Summary部分，相应的状态可具有如下的某个值。  \na. READY：此实例可接受连接  \nb. BLOCKED：此实例不能接受连接  \nc. UNKNOWN：此实例在listener.ora文件中注册而不是通过动态服务注册，因而不知道其状态  \n## 监听器命令\n在调用lsnrctl实用程序后，除了status命令外还可以执行其他一些重要的命令。例如，service命令允许查看监听器正为连接请求而监控的是什么服务。  \n注解：还可以从Oracle企业管理器的Net Services Administration页面查看监听器服务的状态。  \n代码清单11-2 使用lsnrctl help列出lsnrctl命令  \n$lsnrctl help  \n可以调用lsnrctl实用程序后，使用start命令启动监听器，使用stop命令停业监听器。如果希望从操作系统命令行发布这些命令，可使用lsnrctl start和lsnrctl stop命令执行这两个任务。  \n如果对listener.ora文件做了更改，为使更改起作用的一种方法是重启监听器。另一种安全的方法是重新装载监听信息，包括对监听器配置文件所做的最新更改。Lsnrctl reload命令允许在运行中重新装载监听器，而不用重新启动它。在监听器重装载（甚至是重启）的过程中，当前连接的客户机将继续保持连接，因为监听器已经将连接“交付”给数据库，在客户和数据库服务之间不起作用。  \n注意：我的忠告是，如非绝对有必要，不要修改listener.ora文件，而且对于动态自动服务注册，几乎没有必要修改此文件。不过，有时可能需要修改监听器文件的某些部分，此文件由监听器监控连接请求的所有服务的网络配置信息组成。  \n## 命名和连接\n在前面连接描述符和连接标识符的例子中，使用sales连接标识符来连接sales服务。连接标识符可以是连接描述符本身，也可以是一个能解析为连接描述符的简单名字(如sales)。一般使用的简单连接标识符称为net service name(网络服务名)。因此前面例子中的sales连接标识符就是一个net service name。  \n因为每次进行连接时都需要提供一下完整的连接描述符非常令人厌烦，使用网络服务名是明智的。但这需要维护网络服务名和连接描述信息之间所有映射的一个中心信息库(central repository)，以便Oracle验证这些网络服务名。因此，在一个用户使用网络服务名sales启动连接进程时，Oracle将搜索中心信息库查找sales的连接描述符。找到连接描述符后，Oracle Net会为指定服务器上的数据库初始化一个连接。  \nOracle允许几种类型的命名信息库，可用下列4种命名方法访问存储在这些位置中的映射信息。  \na. 本地命令(local naming )：使用存储在每个客户机上的名为tnsnames.ora的文件连接到数据库服务器。  \nb. 简易连接命名(easy connect naming)：允许连接而无需任何服务名配置。  \nc. 外部命名(external naming)：使用第三方命名服务来解析服务名。  \nd. 目录命令(directory naming)：使用一个集中式的符合LDAP的目录服务器来解析服务名。  \n\t不管使用何种命名方法，名字解析过程都是相同的。每种命名法都遵循以下步骤将连接描述符解析为网络服务名：\ni. 选择命令方法—本地、简易连接、外部命名或目录服务命名  \nii. 映射连接描述符到服务名；  \niii. 配置客户机以使用步骤1中选择的命名方法  \n## 本地命名方法\n本地命令是建立Oracle连接最简单、最容易的方法。使用这种方法，在名为tnsnames.ora的本地化配置文件中存储服务名及其连接描述符。此文件默认存储在$ORACLE_HOME/network/admin目录中。  \n","slug":"oracle/Oracle网络和数据库连接","published":1,"updated":"2017-08-18T01:44:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bou00ams77r6d7001aq","content":"<p>内容来自《Oracle Database 11g 数据库管理艺术》</p>\n<h1 id=\"网络概念：Oracle网络如何工作\"><a href=\"#网络概念：Oracle网络如何工作\" class=\"headerlink\" title=\"网络概念：Oracle网络如何工作\"></a>网络概念：Oracle网络如何工作</h1><p>在希望从客户机（不管是传统客户机还是基于浏览器的客户机）打开数据库会话时，需要通过网络连接到数据库。假如要将台式电脑通过现有网络连接到UNIX服务器上的一个Oracle数据库，则需要在电脑和Oracle数据库（它使用专门的软件）之间构造一个连接方法。需要某种界面来处理会话（在此例子中为SQL*Plus），并且需要某种与业内标准的网络协议（如TCP/IP）通信的方法。<br>为方便配置和管理网络连接，Oracle提供了Oracle Net Services，它是一套在分布式异构计算环境中提供连接方案的组件。Oracle Net Services由Oracle Net、Oracle Net Listener、Oracle Connection Manager、Oracle Net Configuration Assistant和Oracle Net Manager组成。Oracle Net Services软件是在Oracle Database Server或Oracle Client软件安装的过程中自动安装的。<br>Oracle Net是一个初始化、建立及维护客户机和服务器之间的连接的组件。这就是为什么必须在客户机和服务器上都安装Oracle Net的原因。Oracle Net主要由两个组件构成。<br>Oracle Network Foundation Layer：负责建立和维护客户机应用程序与服务器之间的连接，以及它们之间的交换信息。<br>Oracle Protocol Support： 负责映射Transparent Net Substrate（TNS）功能到连接使用的业内标准协议。<br>驻留Oracle数据库的所有服务器还运行一个名为Oracle Net Listener（通常也称为监听器）的服务，其主要功能是监听来自客户机服务登录Oracle数据库的请求。监听器在保证客户机服务具有与数据库匹配的信息（协议、端口和实例名）后，将客户机请求传递到数据库。假如用户名和密码通过认证，则数据库将允许客户机登录。一旦监听器把用户请求交付给数据库，客户机和数据库将直接连接，不再需要监听器的帮助。<br>Oracle提供了基于GUI的大量的实用程序，以帮助配置数据库的网络连接。这些实用程序包括Oracle Connection Manager、Oracle Net Manager和Oracle Net Configuragion Assistant等。这些工具帮助处理所有网络需求。在结束本章学习后，可单击这些程序的图标，开始测试连接的实验。  </p>\n<h1 id=\"Web应用如何连接到Oracle数据库\"><a href=\"#Web应用如何连接到Oracle数据库\" class=\"headerlink\" title=\"Web应用如何连接到Oracle数据库\"></a>Web应用如何连接到Oracle数据库</h1><p>为了构造Oracle数据库的一个Internet连接，客户机上的Web浏览器要与Web服务器通信并使用HTTP进行连接请求。Web服务器将此请求传递给一个应用，该应用处理收到的请求并用Oracle Net（配置在数据库服务器和客户机上）与Oracle数据库服务器通信<br>    下面介绍Oracle网络中几个关键的术语  </p>\n<h2 id=\"数据库实例名\"><a href=\"#数据库实例名\" class=\"headerlink\" title=\"数据库实例名\"></a>数据库实例名</h2><p>正如所知，Oracle实例由SGA和一组Oracle进程组成。数据库实例名在初始化文件（init.ora）中作为INSTANCE_NAME参数给出。在谈到Oracle SID（System identifier，系统标识符）时，指的是Oracle实例。<br>    通常，每个数据库只有一个与其关联的实例。但在Oracle RAC配置中，单个数据库可关联到多个实例。  </p>\n<h2 id=\"全局数据库名\"><a href=\"#全局数据库名\" class=\"headerlink\" title=\"全局数据库名\"></a>全局数据库名</h2><p>全局数据库名唯一地标识一个Oracle数据库，其格式为database_name.database_domain，如sales.us.acme.com。在这个全局数据库中，sales为数据库名，us.acme.com为数据库域。因为相同的域中两个数据库不会有相同的数据库名，所以每个全局数据库名都是唯一的。  </p>\n<h2 id=\"数据库服务名\"><a href=\"#数据库服务名\" class=\"headerlink\" title=\"数据库服务名\"></a>数据库服务名</h2><p>对于客户机，数据库在逻辑上简单地表现为一个服务。在服务和数据库之间存在一个多对多的关系，因为一个数据库可被一个或多个服务所代表，每个服务都专用于一组不同的客户机，而一个服务可覆盖不止一个数据库实例。我们在自己的系统中用每个数据库的服务名来标识它，用初始化参数SERVICE_NAMES来指定数据库的服务名。服务名参数值默认为全局数据库名。<br>请注意，一个数据库可由多个服务名来访问。如果希望不同的客户机组访问适合于它们的特定需求的不同数据库，应该这样做。例如，可对相同数据库创建如下两个服务名：<br>Sales.us.acme.com<br>Finance.us.acme.com<br>销售人员使用sales.us.acme.com服务名，而财务人员则使用finance.us.acme.com服务名。  </p>\n<h2 id=\"连接描述符\"><a href=\"#连接描述符\" class=\"headerlink\" title=\"连接描述符\"></a>连接描述符</h2><p>为了将电脑连接到世界上的任何数据库服务，需要提供两个信息：<br>    数据库服务名；<br>    地址。<br>Oracle使用术语连接描述符(connect descriptor)来表示数据库连接的两个必需的部分：数据库服务名和地址。连接描述符的地址部分包含三个部分，分别是：连接使用的通信协议、主机名和端口号。<br>了解通信协议有助于保证使用合适的网络协议，以便建立连接。标准的协议为TCP/IP或带SSL（Secure Sockets Layer，安全套接层）的TCP/IP。UNIX服务器上的Oracle连接的标准端口为1521或1526.Windows机器上的默认端口为1521.因为任何主机上的数据库具有唯一服务名，所以一个Oracle数据库服务名和一个主机名将唯一地标识任何数据库。下面是一个典型的连接描述符的例子：<br>(DESCRIPTION<br>(ADDRESS=(PROTOCOL=tcp)(HOST=sales-server)(PORT=1521))<br>(CONNECT_DATA=<br>(SERVICE_NAME=sales.us.acme.com)))<br>在此连接描述符中，ADDRESS行指出网络通信将使用TCP协议。HOST指定UNIX（或Windows）服务器，服务器上的Oracle监听器正监听来自端口1521的连接请求。连接描述符的ADDRESS部分也称为协议地址(protocol address)。<br>希望连接数据库的客户机首先连接到Oracle监听器进程。监听器接收到达的请求并把它们交给数据库服务器。一旦客户机和数据库服务器通过监听器的引导连接上，它们就直接通信，在此客户机连接的通信过程中不再需要监听器。  </p>\n<h2 id=\"连接标识符\"><a href=\"#连接标识符\" class=\"headerlink\" title=\"连接标识符\"></a>连接标识符</h2><p>连接标识符（connect identifier）与连接描述符紧密关联。可把连接描述符作为连接标识符，或者可简单地映射一个数据库服务名为一个连接描述符。例如，可以把一个服务名(如sales)映射为11.2.5节所看到的连接描述符。下面是说明映射sales连接标识符的例子。<br>Sales=<br>(DESCRIPTION<br>(ADDRESS=(PROTOCOL=tcp)(HOST=sales-server)(PORT=1521))<br>(CONNECT_DATA=<br>(SERVICE_NAME=sales.us.acme.com)))  </p>\n<h2 id=\"连接串\"><a href=\"#连接串\" class=\"headerlink\" title=\"连接串\"></a>连接串</h2><p>通过提供一个连接串(connect string)连接到数据库。连接串包含用户名/密码组合及一个连接标识符。最常见的连接标识符之一是节点服务名，它是一个数据库服务的名字。<br>下面的例子给出一个连接串，它把一个完整的连接描述符作为连接标识符<br>    CONNECT scott/tiger@(DESCRIPTION=<br>    (ADDRESS=(PROTOCOL=tcp)<br>    (HOST=sales-server)<br>    (PORT=1521))<br>    (CONNECT_DATA=<br>    (SERVICE_NAME=sales.us.acme.com)))<br>下面是一个更简单的连接到相同数据库的方法，它使用连接标识符sales：<br>    CONNECT scott/tiger@sales<br>上面两个例子都能连接到sales数据库，但显然第二个连接串（使用sales连接标识符）简单得多。  </p>\n<h2 id=\"使用Oracle网络服务工具\"><a href=\"#使用Oracle网络服务工具\" class=\"headerlink\" title=\"使用Oracle网络服务工具\"></a>使用Oracle网络服务工具</h2><p>Oracle Net提供了配置客户机与数据库服务之间的连接的几个GUI和命令行工具。最常用的命令行工具是isnrctl实用程序，它帮助管理Oracle监听器服务。下面是帮助管理Oracle Net Servcies的重要GUI工具。<br>Oracle NCA（Net Configuration Assistant，Oracle网络配置助手）。此工具主要用于在安装中配置网络组件，它允许在配置客户机连接的几个选项（本章稍后介绍这些选项）中进行选择。其便于使用的GUI界面使你能在所选择的任何命名方法下快速配置客户机连接。在UNIX/Linux系统上，可通过从$ORACLE_HOME/bin目录执行netca来启动NCA。在Window系统上，选择Start|Programs|Oracle-HOME_NAME|Configuration and Migration Tools|Net ConfigurationAssistant。<br>Oracle网络配置管理器（Oracle Net Manager）。Oracle Net Manager可在客户机和服务器上运行，它允许配置各种命名方法和监听器。利用此工具，可在本地tnsnames.ora文件或在集中式的OID中配置连接描述符，而且可以方便地增加和修改连接方法。<br>为了从Oracle企业管理器控制台启动Oracle Net Manager，选择Tools|Service Management|Oracle Net Manager。为了在Unix上作为独立的应用启动Oracle Net Manager，在ORACLE_HOME/bin目录执行netmgr。在windown上，选择Start|Programs|Oracle-HOME_NAME|Configuration and Migration Tools|NetManager。<br>Oracle企业管理器（Oracle Enterprise Manager）。Oracle Database 11g中的OEM可以完成Oracle Net Manager能完成的所有任务，但不能跨多个文件系统管理多个Oracle主目录。此外，使用OEM可导出目录命名项到tnsnames.ora文件。<br>Oracle目录管理器（Oracle Directory Manager）。这个功能强大的工具允许创建使用OID必需的各种域和环境。用此工具还可以执行密码策略管理及完成许多Oracle高级安全任务。在UNIX/LINUX系统上，可从$ORACLE_HOME/bin目录执行oidadmin来启动OID。在Window系统上，选择Start|Programs|Oracle-HOME_NAME|Integrated Manager Tools|Oracle Directory Manager。  </p>\n<h1 id=\"即时客户机\"><a href=\"#即时客户机\" class=\"headerlink\" title=\"即时客户机\"></a>即时客户机</h1><p>之前说过Oracle客户机安装需要经历常规的Oracle数据库服务器软件安排的所有预备步骤。幸而为连接到Oracle数据库并不总是需要安装完整的Oracle客户机软件。Oracle的新Instant Client（即时客户机）软件允许执行应用程序而不必安装标准的Oracle客户机也不必具有ORACLE_HOME。不需要为访问Oracle数据库的每台机器安装Oracle客户机软件。所有现有的OCI、ODBC和JDBC应用程序都可以使用Instan Client。如果愿意，甚至可以用Instant Client使用SQL<em>Plus。<br>    相对于完整的Oracle客户机，Instant Clients提供以下好处：<br>A. 它是免费的；<br>B. 战胜磁盘空间较少<br>C. 安装更快（5分钟左右）<br>D. 不需要CD<br>E. 它具有Oracle客户机的所有特性，如果有必要甚至包括使用SQL</em>Plus。  </p>\n<h1 id=\"安装Instant-Client\"><a href=\"#安装Instant-Client\" class=\"headerlink\" title=\"安装Instant Client\"></a>安装Instant Client</h1><p>以下是安装新Instant Client软件并快速连接到Oracle数据库的步骤。<br>(1) 从OTN Web站点下载Instant Client软件。你必须安装基本的客户机程序包，还可以包括其他高级可选的程序包。此程序包含以下内容：<br>    a) Basic：运行OCI、OCCI和JDBC-OCI应用程序所需的文件。<br>    b) SQL<em>Plus：为用Instant Client运行SQL</em>Plus需要的库和可执行文件。<br>    c) JDBC Supplement：另外支持XA、国际化及JDBC下的RowSet操作。<br>    d) ODBC Supplement：启用带Instant Client的ODBC应用的另外的库（仅对Windows）。<br>    e) SDK：用于Instant Client开发Oracle应用程序所需的其他文件。<br>(2) 将选择的程序包解压到某个目录，将些目录命名为instantclient或其它类似的名称。<br>(3) 在UNIX和Linux系统中，将环境变量LD_LIBRARY_PATH设置为instantclient（从而保证此参数的设置与程序包所有所在的目录名匹配）。在Winddows系统上，将环境变量PATH设置为instantclient。<br>(4) 测试对Oracle服务器的连接。  </p>\n<h1 id=\"监听器和连接\"><a href=\"#监听器和连接\" class=\"headerlink\" title=\"监听器和连接\"></a>监听器和连接</h1><p>Oracle监听器是一个只运行在服务器上并监听连接请求的服务。Oracle提供一个名为lsnrctl的实用程序来管理监听器进程。以下是监听器如何配合Oracle网络的概述。<br>a. 数据库用监听器记录关于服务、实例及服务处理器的信息<br>b. 客户机与监听器进行初步连接<br>c. 监听器接收和验证客户机连接请求并把此请求交给数据库服务的服务处理器。一旦交付了客户机请求，监听器在该连接中不再起作用。<br>Listener.ora文件默认位置在UNIX系统上为$ORACLE_HOME/network/admin目录，在Windows系统上为$ORACLE_HOME\\network\\admin目录，它包含监听器的配置信息。因为监听器服务只运行在服务器上，因此在客户机上没有listener.ora文件。代码清单11-1给出了一个典型的listener.ora文件。<br>Listener中的所有配置参数都具有默认值，不需要手动配置监听器服务。在服务器上创建了第一个数据库后，监听器服务自动启动，并且将监听器配置文件listener.ora放于默认目录中。新数据库创建后，数据库的网络和服务信息自动添加到监听器的配置文件中。实例启动后，数据库自动向监听器注册，并且监听器开始监听对此数据库的连接请求。<br>代码清单11-1 典型的监听器配置文件<br>代码清单11-1 典型的监听器配置文件   </p>\n<pre><code>#LISTENRE.ORA Network Configuration file \n/u01/app/oracle/product/11.1.0.6.0/db_1/network/admin/listener.ora\nSID_LIST_LISTENER = \n(DESCRIPTION_LIST =\n    (DESCRIPTION = \n          (ADDRESS_LIST = \n            (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC4))\n        )\n        (ADDRESS_LIST = \n            (ADDRESS = (PROTOCOL = TCP)(HOST = NTL-ALAPATISAM)(PORT = 1521))\n        )\n    )\n)\nSID_LIST_LISTENER = \n    (SID_LIST = \n    (SID_DESC = \n        (SID_NAME = PLSExtProc)\n        (ORACLE_HOME = /u01/app/oracle/product/11.1.0/db_1)\n        (PROGRAM = extproc)\n    )\n    (SID_DESC = \n        (GLOBAL_DBNAME = remorse.world)\n        (ORACLE_HOME = /u01/app/oracle/product/11.1.0/db_1)\n        (SID_NAME = remorse)\n    )\n    (SID_DESC = \n        (GLOBAL_DBNAME = finance.world)\n        (ORACLE_HOME = /u01/app/oracle/product/11.1.0/db_1)\n        (SID_NAME = finance)\n    )\n)\n</code></pre><h2 id=\"自动服务注册\"><a href=\"#自动服务注册\" class=\"headerlink\" title=\"自动服务注册\"></a>自动服务注册</h2><p>Oracle PMON进程负责向监听器动态服务注册新Oracle数据库服务名，也就是说，在创建新Oracle数据库时，它们将自动向监听器服务注册。PMON进程将在每个新数据库在服务器上创建之后更新listener.ora文件。<br>为自动服务注册，ini.ora文件或SPFILE应该包含如下参数：<br>a. SERVICE_NAMES(如sales.us.oracle.com)<br>b. INSTANCE_NAME(如sales)<br>如果不指定SERVICE_NAMES参数的值，它默认为全局数据库名，全局数据库名是DB_NAME和DB_DOMAIN参数的组合。INSTANCE_NAME参数的默认值为Oracle安装或数据库创建时输入的SID。<br>可使用lsnrctl实用程序查看服务器上监听器的状态，如代码清单11-2所示。相应的输出说明监听器启动了多长时间，监听器服务的配置文件位于何处。它还给出监听器为连接请求而监听的数据库的名称。<br>代码清单11-2 使用lsnrctl实用程序查看监听器的状态<br>$ lsnrctl status  </p>\n<p>在代码清单11-2的Services Summary部分，相应的状态可具有如下的某个值。<br>a. READY：此实例可接受连接<br>b. BLOCKED：此实例不能接受连接<br>c. UNKNOWN：此实例在listener.ora文件中注册而不是通过动态服务注册，因而不知道其状态  </p>\n<h2 id=\"监听器命令\"><a href=\"#监听器命令\" class=\"headerlink\" title=\"监听器命令\"></a>监听器命令</h2><p>在调用lsnrctl实用程序后，除了status命令外还可以执行其他一些重要的命令。例如，service命令允许查看监听器正为连接请求而监控的是什么服务。<br>注解：还可以从Oracle企业管理器的Net Services Administration页面查看监听器服务的状态。<br>代码清单11-2 使用lsnrctl help列出lsnrctl命令<br>$lsnrctl help<br>可以调用lsnrctl实用程序后，使用start命令启动监听器，使用stop命令停业监听器。如果希望从操作系统命令行发布这些命令，可使用lsnrctl start和lsnrctl stop命令执行这两个任务。<br>如果对listener.ora文件做了更改，为使更改起作用的一种方法是重启监听器。另一种安全的方法是重新装载监听信息，包括对监听器配置文件所做的最新更改。Lsnrctl reload命令允许在运行中重新装载监听器，而不用重新启动它。在监听器重装载（甚至是重启）的过程中，当前连接的客户机将继续保持连接，因为监听器已经将连接“交付”给数据库，在客户和数据库服务之间不起作用。<br>注意：我的忠告是，如非绝对有必要，不要修改listener.ora文件，而且对于动态自动服务注册，几乎没有必要修改此文件。不过，有时可能需要修改监听器文件的某些部分，此文件由监听器监控连接请求的所有服务的网络配置信息组成。  </p>\n<h2 id=\"命名和连接\"><a href=\"#命名和连接\" class=\"headerlink\" title=\"命名和连接\"></a>命名和连接</h2><p>在前面连接描述符和连接标识符的例子中，使用sales连接标识符来连接sales服务。连接标识符可以是连接描述符本身，也可以是一个能解析为连接描述符的简单名字(如sales)。一般使用的简单连接标识符称为net service name(网络服务名)。因此前面例子中的sales连接标识符就是一个net service name。<br>因为每次进行连接时都需要提供一下完整的连接描述符非常令人厌烦，使用网络服务名是明智的。但这需要维护网络服务名和连接描述信息之间所有映射的一个中心信息库(central repository)，以便Oracle验证这些网络服务名。因此，在一个用户使用网络服务名sales启动连接进程时，Oracle将搜索中心信息库查找sales的连接描述符。找到连接描述符后，Oracle Net会为指定服务器上的数据库初始化一个连接。<br>Oracle允许几种类型的命名信息库，可用下列4种命名方法访问存储在这些位置中的映射信息。<br>a. 本地命令(local naming )：使用存储在每个客户机上的名为tnsnames.ora的文件连接到数据库服务器。<br>b. 简易连接命名(easy connect naming)：允许连接而无需任何服务名配置。<br>c. 外部命名(external naming)：使用第三方命名服务来解析服务名。<br>d. 目录命令(directory naming)：使用一个集中式的符合LDAP的目录服务器来解析服务名。<br>    不管使用何种命名方法，名字解析过程都是相同的。每种命名法都遵循以下步骤将连接描述符解析为网络服务名：<br>i. 选择命令方法—本地、简易连接、外部命名或目录服务命名<br>ii. 映射连接描述符到服务名；<br>iii. 配置客户机以使用步骤1中选择的命名方法  </p>\n<h2 id=\"本地命名方法\"><a href=\"#本地命名方法\" class=\"headerlink\" title=\"本地命名方法\"></a>本地命名方法</h2><p>本地命令是建立Oracle连接最简单、最容易的方法。使用这种方法，在名为tnsnames.ora的本地化配置文件中存储服务名及其连接描述符。此文件默认存储在$ORACLE_HOME/network/admin目录中。  </p>\n","site":{"data":{}},"excerpt":"","more":"<p>内容来自《Oracle Database 11g 数据库管理艺术》</p>\n<h1 id=\"网络概念：Oracle网络如何工作\"><a href=\"#网络概念：Oracle网络如何工作\" class=\"headerlink\" title=\"网络概念：Oracle网络如何工作\"></a>网络概念：Oracle网络如何工作</h1><p>在希望从客户机（不管是传统客户机还是基于浏览器的客户机）打开数据库会话时，需要通过网络连接到数据库。假如要将台式电脑通过现有网络连接到UNIX服务器上的一个Oracle数据库，则需要在电脑和Oracle数据库（它使用专门的软件）之间构造一个连接方法。需要某种界面来处理会话（在此例子中为SQL*Plus），并且需要某种与业内标准的网络协议（如TCP/IP）通信的方法。<br>为方便配置和管理网络连接，Oracle提供了Oracle Net Services，它是一套在分布式异构计算环境中提供连接方案的组件。Oracle Net Services由Oracle Net、Oracle Net Listener、Oracle Connection Manager、Oracle Net Configuration Assistant和Oracle Net Manager组成。Oracle Net Services软件是在Oracle Database Server或Oracle Client软件安装的过程中自动安装的。<br>Oracle Net是一个初始化、建立及维护客户机和服务器之间的连接的组件。这就是为什么必须在客户机和服务器上都安装Oracle Net的原因。Oracle Net主要由两个组件构成。<br>Oracle Network Foundation Layer：负责建立和维护客户机应用程序与服务器之间的连接，以及它们之间的交换信息。<br>Oracle Protocol Support： 负责映射Transparent Net Substrate（TNS）功能到连接使用的业内标准协议。<br>驻留Oracle数据库的所有服务器还运行一个名为Oracle Net Listener（通常也称为监听器）的服务，其主要功能是监听来自客户机服务登录Oracle数据库的请求。监听器在保证客户机服务具有与数据库匹配的信息（协议、端口和实例名）后，将客户机请求传递到数据库。假如用户名和密码通过认证，则数据库将允许客户机登录。一旦监听器把用户请求交付给数据库，客户机和数据库将直接连接，不再需要监听器的帮助。<br>Oracle提供了基于GUI的大量的实用程序，以帮助配置数据库的网络连接。这些实用程序包括Oracle Connection Manager、Oracle Net Manager和Oracle Net Configuragion Assistant等。这些工具帮助处理所有网络需求。在结束本章学习后，可单击这些程序的图标，开始测试连接的实验。  </p>\n<h1 id=\"Web应用如何连接到Oracle数据库\"><a href=\"#Web应用如何连接到Oracle数据库\" class=\"headerlink\" title=\"Web应用如何连接到Oracle数据库\"></a>Web应用如何连接到Oracle数据库</h1><p>为了构造Oracle数据库的一个Internet连接，客户机上的Web浏览器要与Web服务器通信并使用HTTP进行连接请求。Web服务器将此请求传递给一个应用，该应用处理收到的请求并用Oracle Net（配置在数据库服务器和客户机上）与Oracle数据库服务器通信<br>    下面介绍Oracle网络中几个关键的术语  </p>\n<h2 id=\"数据库实例名\"><a href=\"#数据库实例名\" class=\"headerlink\" title=\"数据库实例名\"></a>数据库实例名</h2><p>正如所知，Oracle实例由SGA和一组Oracle进程组成。数据库实例名在初始化文件（init.ora）中作为INSTANCE_NAME参数给出。在谈到Oracle SID（System identifier，系统标识符）时，指的是Oracle实例。<br>    通常，每个数据库只有一个与其关联的实例。但在Oracle RAC配置中，单个数据库可关联到多个实例。  </p>\n<h2 id=\"全局数据库名\"><a href=\"#全局数据库名\" class=\"headerlink\" title=\"全局数据库名\"></a>全局数据库名</h2><p>全局数据库名唯一地标识一个Oracle数据库，其格式为database_name.database_domain，如sales.us.acme.com。在这个全局数据库中，sales为数据库名，us.acme.com为数据库域。因为相同的域中两个数据库不会有相同的数据库名，所以每个全局数据库名都是唯一的。  </p>\n<h2 id=\"数据库服务名\"><a href=\"#数据库服务名\" class=\"headerlink\" title=\"数据库服务名\"></a>数据库服务名</h2><p>对于客户机，数据库在逻辑上简单地表现为一个服务。在服务和数据库之间存在一个多对多的关系，因为一个数据库可被一个或多个服务所代表，每个服务都专用于一组不同的客户机，而一个服务可覆盖不止一个数据库实例。我们在自己的系统中用每个数据库的服务名来标识它，用初始化参数SERVICE_NAMES来指定数据库的服务名。服务名参数值默认为全局数据库名。<br>请注意，一个数据库可由多个服务名来访问。如果希望不同的客户机组访问适合于它们的特定需求的不同数据库，应该这样做。例如，可对相同数据库创建如下两个服务名：<br>Sales.us.acme.com<br>Finance.us.acme.com<br>销售人员使用sales.us.acme.com服务名，而财务人员则使用finance.us.acme.com服务名。  </p>\n<h2 id=\"连接描述符\"><a href=\"#连接描述符\" class=\"headerlink\" title=\"连接描述符\"></a>连接描述符</h2><p>为了将电脑连接到世界上的任何数据库服务，需要提供两个信息：<br>    数据库服务名；<br>    地址。<br>Oracle使用术语连接描述符(connect descriptor)来表示数据库连接的两个必需的部分：数据库服务名和地址。连接描述符的地址部分包含三个部分，分别是：连接使用的通信协议、主机名和端口号。<br>了解通信协议有助于保证使用合适的网络协议，以便建立连接。标准的协议为TCP/IP或带SSL（Secure Sockets Layer，安全套接层）的TCP/IP。UNIX服务器上的Oracle连接的标准端口为1521或1526.Windows机器上的默认端口为1521.因为任何主机上的数据库具有唯一服务名，所以一个Oracle数据库服务名和一个主机名将唯一地标识任何数据库。下面是一个典型的连接描述符的例子：<br>(DESCRIPTION<br>(ADDRESS=(PROTOCOL=tcp)(HOST=sales-server)(PORT=1521))<br>(CONNECT_DATA=<br>(SERVICE_NAME=sales.us.acme.com)))<br>在此连接描述符中，ADDRESS行指出网络通信将使用TCP协议。HOST指定UNIX（或Windows）服务器，服务器上的Oracle监听器正监听来自端口1521的连接请求。连接描述符的ADDRESS部分也称为协议地址(protocol address)。<br>希望连接数据库的客户机首先连接到Oracle监听器进程。监听器接收到达的请求并把它们交给数据库服务器。一旦客户机和数据库服务器通过监听器的引导连接上，它们就直接通信，在此客户机连接的通信过程中不再需要监听器。  </p>\n<h2 id=\"连接标识符\"><a href=\"#连接标识符\" class=\"headerlink\" title=\"连接标识符\"></a>连接标识符</h2><p>连接标识符（connect identifier）与连接描述符紧密关联。可把连接描述符作为连接标识符，或者可简单地映射一个数据库服务名为一个连接描述符。例如，可以把一个服务名(如sales)映射为11.2.5节所看到的连接描述符。下面是说明映射sales连接标识符的例子。<br>Sales=<br>(DESCRIPTION<br>(ADDRESS=(PROTOCOL=tcp)(HOST=sales-server)(PORT=1521))<br>(CONNECT_DATA=<br>(SERVICE_NAME=sales.us.acme.com)))  </p>\n<h2 id=\"连接串\"><a href=\"#连接串\" class=\"headerlink\" title=\"连接串\"></a>连接串</h2><p>通过提供一个连接串(connect string)连接到数据库。连接串包含用户名/密码组合及一个连接标识符。最常见的连接标识符之一是节点服务名，它是一个数据库服务的名字。<br>下面的例子给出一个连接串，它把一个完整的连接描述符作为连接标识符<br>    CONNECT scott/tiger@(DESCRIPTION=<br>    (ADDRESS=(PROTOCOL=tcp)<br>    (HOST=sales-server)<br>    (PORT=1521))<br>    (CONNECT_DATA=<br>    (SERVICE_NAME=sales.us.acme.com)))<br>下面是一个更简单的连接到相同数据库的方法，它使用连接标识符sales：<br>    CONNECT scott/tiger@sales<br>上面两个例子都能连接到sales数据库，但显然第二个连接串（使用sales连接标识符）简单得多。  </p>\n<h2 id=\"使用Oracle网络服务工具\"><a href=\"#使用Oracle网络服务工具\" class=\"headerlink\" title=\"使用Oracle网络服务工具\"></a>使用Oracle网络服务工具</h2><p>Oracle Net提供了配置客户机与数据库服务之间的连接的几个GUI和命令行工具。最常用的命令行工具是isnrctl实用程序，它帮助管理Oracle监听器服务。下面是帮助管理Oracle Net Servcies的重要GUI工具。<br>Oracle NCA（Net Configuration Assistant，Oracle网络配置助手）。此工具主要用于在安装中配置网络组件，它允许在配置客户机连接的几个选项（本章稍后介绍这些选项）中进行选择。其便于使用的GUI界面使你能在所选择的任何命名方法下快速配置客户机连接。在UNIX/Linux系统上，可通过从$ORACLE_HOME/bin目录执行netca来启动NCA。在Window系统上，选择Start|Programs|Oracle-HOME_NAME|Configuration and Migration Tools|Net ConfigurationAssistant。<br>Oracle网络配置管理器（Oracle Net Manager）。Oracle Net Manager可在客户机和服务器上运行，它允许配置各种命名方法和监听器。利用此工具，可在本地tnsnames.ora文件或在集中式的OID中配置连接描述符，而且可以方便地增加和修改连接方法。<br>为了从Oracle企业管理器控制台启动Oracle Net Manager，选择Tools|Service Management|Oracle Net Manager。为了在Unix上作为独立的应用启动Oracle Net Manager，在ORACLE_HOME/bin目录执行netmgr。在windown上，选择Start|Programs|Oracle-HOME_NAME|Configuration and Migration Tools|NetManager。<br>Oracle企业管理器（Oracle Enterprise Manager）。Oracle Database 11g中的OEM可以完成Oracle Net Manager能完成的所有任务，但不能跨多个文件系统管理多个Oracle主目录。此外，使用OEM可导出目录命名项到tnsnames.ora文件。<br>Oracle目录管理器（Oracle Directory Manager）。这个功能强大的工具允许创建使用OID必需的各种域和环境。用此工具还可以执行密码策略管理及完成许多Oracle高级安全任务。在UNIX/LINUX系统上，可从$ORACLE_HOME/bin目录执行oidadmin来启动OID。在Window系统上，选择Start|Programs|Oracle-HOME_NAME|Integrated Manager Tools|Oracle Directory Manager。  </p>\n<h1 id=\"即时客户机\"><a href=\"#即时客户机\" class=\"headerlink\" title=\"即时客户机\"></a>即时客户机</h1><p>之前说过Oracle客户机安装需要经历常规的Oracle数据库服务器软件安排的所有预备步骤。幸而为连接到Oracle数据库并不总是需要安装完整的Oracle客户机软件。Oracle的新Instant Client（即时客户机）软件允许执行应用程序而不必安装标准的Oracle客户机也不必具有ORACLE_HOME。不需要为访问Oracle数据库的每台机器安装Oracle客户机软件。所有现有的OCI、ODBC和JDBC应用程序都可以使用Instan Client。如果愿意，甚至可以用Instant Client使用SQL<em>Plus。<br>    相对于完整的Oracle客户机，Instant Clients提供以下好处：<br>A. 它是免费的；<br>B. 战胜磁盘空间较少<br>C. 安装更快（5分钟左右）<br>D. 不需要CD<br>E. 它具有Oracle客户机的所有特性，如果有必要甚至包括使用SQL</em>Plus。  </p>\n<h1 id=\"安装Instant-Client\"><a href=\"#安装Instant-Client\" class=\"headerlink\" title=\"安装Instant Client\"></a>安装Instant Client</h1><p>以下是安装新Instant Client软件并快速连接到Oracle数据库的步骤。<br>(1) 从OTN Web站点下载Instant Client软件。你必须安装基本的客户机程序包，还可以包括其他高级可选的程序包。此程序包含以下内容：<br>    a) Basic：运行OCI、OCCI和JDBC-OCI应用程序所需的文件。<br>    b) SQL<em>Plus：为用Instant Client运行SQL</em>Plus需要的库和可执行文件。<br>    c) JDBC Supplement：另外支持XA、国际化及JDBC下的RowSet操作。<br>    d) ODBC Supplement：启用带Instant Client的ODBC应用的另外的库（仅对Windows）。<br>    e) SDK：用于Instant Client开发Oracle应用程序所需的其他文件。<br>(2) 将选择的程序包解压到某个目录，将些目录命名为instantclient或其它类似的名称。<br>(3) 在UNIX和Linux系统中，将环境变量LD_LIBRARY_PATH设置为instantclient（从而保证此参数的设置与程序包所有所在的目录名匹配）。在Winddows系统上，将环境变量PATH设置为instantclient。<br>(4) 测试对Oracle服务器的连接。  </p>\n<h1 id=\"监听器和连接\"><a href=\"#监听器和连接\" class=\"headerlink\" title=\"监听器和连接\"></a>监听器和连接</h1><p>Oracle监听器是一个只运行在服务器上并监听连接请求的服务。Oracle提供一个名为lsnrctl的实用程序来管理监听器进程。以下是监听器如何配合Oracle网络的概述。<br>a. 数据库用监听器记录关于服务、实例及服务处理器的信息<br>b. 客户机与监听器进行初步连接<br>c. 监听器接收和验证客户机连接请求并把此请求交给数据库服务的服务处理器。一旦交付了客户机请求，监听器在该连接中不再起作用。<br>Listener.ora文件默认位置在UNIX系统上为$ORACLE_HOME/network/admin目录，在Windows系统上为$ORACLE_HOME\\network\\admin目录，它包含监听器的配置信息。因为监听器服务只运行在服务器上，因此在客户机上没有listener.ora文件。代码清单11-1给出了一个典型的listener.ora文件。<br>Listener中的所有配置参数都具有默认值，不需要手动配置监听器服务。在服务器上创建了第一个数据库后，监听器服务自动启动，并且将监听器配置文件listener.ora放于默认目录中。新数据库创建后，数据库的网络和服务信息自动添加到监听器的配置文件中。实例启动后，数据库自动向监听器注册，并且监听器开始监听对此数据库的连接请求。<br>代码清单11-1 典型的监听器配置文件<br>代码清单11-1 典型的监听器配置文件   </p>\n<pre><code>#LISTENRE.ORA Network Configuration file \n/u01/app/oracle/product/11.1.0.6.0/db_1/network/admin/listener.ora\nSID_LIST_LISTENER = \n(DESCRIPTION_LIST =\n    (DESCRIPTION = \n          (ADDRESS_LIST = \n            (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC4))\n        )\n        (ADDRESS_LIST = \n            (ADDRESS = (PROTOCOL = TCP)(HOST = NTL-ALAPATISAM)(PORT = 1521))\n        )\n    )\n)\nSID_LIST_LISTENER = \n    (SID_LIST = \n    (SID_DESC = \n        (SID_NAME = PLSExtProc)\n        (ORACLE_HOME = /u01/app/oracle/product/11.1.0/db_1)\n        (PROGRAM = extproc)\n    )\n    (SID_DESC = \n        (GLOBAL_DBNAME = remorse.world)\n        (ORACLE_HOME = /u01/app/oracle/product/11.1.0/db_1)\n        (SID_NAME = remorse)\n    )\n    (SID_DESC = \n        (GLOBAL_DBNAME = finance.world)\n        (ORACLE_HOME = /u01/app/oracle/product/11.1.0/db_1)\n        (SID_NAME = finance)\n    )\n)\n</code></pre><h2 id=\"自动服务注册\"><a href=\"#自动服务注册\" class=\"headerlink\" title=\"自动服务注册\"></a>自动服务注册</h2><p>Oracle PMON进程负责向监听器动态服务注册新Oracle数据库服务名，也就是说，在创建新Oracle数据库时，它们将自动向监听器服务注册。PMON进程将在每个新数据库在服务器上创建之后更新listener.ora文件。<br>为自动服务注册，ini.ora文件或SPFILE应该包含如下参数：<br>a. SERVICE_NAMES(如sales.us.oracle.com)<br>b. INSTANCE_NAME(如sales)<br>如果不指定SERVICE_NAMES参数的值，它默认为全局数据库名，全局数据库名是DB_NAME和DB_DOMAIN参数的组合。INSTANCE_NAME参数的默认值为Oracle安装或数据库创建时输入的SID。<br>可使用lsnrctl实用程序查看服务器上监听器的状态，如代码清单11-2所示。相应的输出说明监听器启动了多长时间，监听器服务的配置文件位于何处。它还给出监听器为连接请求而监听的数据库的名称。<br>代码清单11-2 使用lsnrctl实用程序查看监听器的状态<br>$ lsnrctl status  </p>\n<p>在代码清单11-2的Services Summary部分，相应的状态可具有如下的某个值。<br>a. READY：此实例可接受连接<br>b. BLOCKED：此实例不能接受连接<br>c. UNKNOWN：此实例在listener.ora文件中注册而不是通过动态服务注册，因而不知道其状态  </p>\n<h2 id=\"监听器命令\"><a href=\"#监听器命令\" class=\"headerlink\" title=\"监听器命令\"></a>监听器命令</h2><p>在调用lsnrctl实用程序后，除了status命令外还可以执行其他一些重要的命令。例如，service命令允许查看监听器正为连接请求而监控的是什么服务。<br>注解：还可以从Oracle企业管理器的Net Services Administration页面查看监听器服务的状态。<br>代码清单11-2 使用lsnrctl help列出lsnrctl命令<br>$lsnrctl help<br>可以调用lsnrctl实用程序后，使用start命令启动监听器，使用stop命令停业监听器。如果希望从操作系统命令行发布这些命令，可使用lsnrctl start和lsnrctl stop命令执行这两个任务。<br>如果对listener.ora文件做了更改，为使更改起作用的一种方法是重启监听器。另一种安全的方法是重新装载监听信息，包括对监听器配置文件所做的最新更改。Lsnrctl reload命令允许在运行中重新装载监听器，而不用重新启动它。在监听器重装载（甚至是重启）的过程中，当前连接的客户机将继续保持连接，因为监听器已经将连接“交付”给数据库，在客户和数据库服务之间不起作用。<br>注意：我的忠告是，如非绝对有必要，不要修改listener.ora文件，而且对于动态自动服务注册，几乎没有必要修改此文件。不过，有时可能需要修改监听器文件的某些部分，此文件由监听器监控连接请求的所有服务的网络配置信息组成。  </p>\n<h2 id=\"命名和连接\"><a href=\"#命名和连接\" class=\"headerlink\" title=\"命名和连接\"></a>命名和连接</h2><p>在前面连接描述符和连接标识符的例子中，使用sales连接标识符来连接sales服务。连接标识符可以是连接描述符本身，也可以是一个能解析为连接描述符的简单名字(如sales)。一般使用的简单连接标识符称为net service name(网络服务名)。因此前面例子中的sales连接标识符就是一个net service name。<br>因为每次进行连接时都需要提供一下完整的连接描述符非常令人厌烦，使用网络服务名是明智的。但这需要维护网络服务名和连接描述信息之间所有映射的一个中心信息库(central repository)，以便Oracle验证这些网络服务名。因此，在一个用户使用网络服务名sales启动连接进程时，Oracle将搜索中心信息库查找sales的连接描述符。找到连接描述符后，Oracle Net会为指定服务器上的数据库初始化一个连接。<br>Oracle允许几种类型的命名信息库，可用下列4种命名方法访问存储在这些位置中的映射信息。<br>a. 本地命令(local naming )：使用存储在每个客户机上的名为tnsnames.ora的文件连接到数据库服务器。<br>b. 简易连接命名(easy connect naming)：允许连接而无需任何服务名配置。<br>c. 外部命名(external naming)：使用第三方命名服务来解析服务名。<br>d. 目录命令(directory naming)：使用一个集中式的符合LDAP的目录服务器来解析服务名。<br>    不管使用何种命名方法，名字解析过程都是相同的。每种命名法都遵循以下步骤将连接描述符解析为网络服务名：<br>i. 选择命令方法—本地、简易连接、外部命名或目录服务命名<br>ii. 映射连接描述符到服务名；<br>iii. 配置客户机以使用步骤1中选择的命名方法  </p>\n<h2 id=\"本地命名方法\"><a href=\"#本地命名方法\" class=\"headerlink\" title=\"本地命名方法\"></a>本地命名方法</h2><p>本地命令是建立Oracle连接最简单、最容易的方法。使用这种方法，在名为tnsnames.ora的本地化配置文件中存储服务名及其连接描述符。此文件默认存储在$ORACLE_HOME/network/admin目录中。  </p>\n"},{"title":"分布式SQL查询引擎-Presto","date":"2019-02-01T01:55:00.000Z","_content":"\nPresto是一个开源的，基于内存的分布式实时计算框架，它出自Facebook，国内大厂现在已有很多应用案例，如：京东、美团、携程等。\n\n## PRESTO应用场景\n\nPresto在大数据量的查询上有很好的性能，并且数据源具有完成解耦、高性能，以及对SQL的支持等特性，使其有很多的应用场景，如ETL、Ad-Hoc查询等。\n\n### ETL\n\n由于Presto支持多种数据源且支持数据源定制化的开发，所以使其在ETL方式有其应用场景，如下。\n![Presto应用场景-ETL.jpg](https://upload-images.jianshu.io/upload_images/3109530-96f1cfbdf4a8018e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n通过azkaban定时调度Presto从不同数据源同步数据到HDFS，然后通过Hive提供批量的查询，Presto提供实时的查询需要。\n\n### Ad-Hoc查询\n\nAd-Hoc查询就是即席查询，即席查询允许用户根据自己的需求随时调整和选择查询条件，计算平台或者系统能够根据用户的查询条件返回查询结果或者生成相应的报表。\n某公司使用Presto完成Ad-Hoc查询，实际的Ad-Hoc使用场景包括以下两种。\n（1）使用BI工具进行报表展现。\nBI工具通过ODBC驱动连接至Presto集群，BI工程师使用BI工具进行不同维度的报表设计和展现。\n\n（2）使用Cli客户端进行数据分析\nPresto使用Hive作为数据源，对Hive中的数据进行查询和分析。众所周知，hive使用Map-Reduce框架进行计算，由于Map-Reduce的优势在于进行大数据量的批运算和提供强大的集群计算吞吐量，但是对稍小数据量的计算和分析会花费相当长的时间，因此在进行GB-TB级别数据量的计算和分析时，Hive并不能满足实时性要求。\nPresto是专门针对基于Ad-Hoc的实时查询和计算进行设计的，其平均性能是Hive的10倍，因此presto更适合于稍小数据量的计算和差异性分析等Ad-Hoc查询。\n\n## 核心概念\n\n### Presto服务进程\n\nPresto集群中一共有两种服务器进程：Coordinator服务进程和Worker服务进程，其中Coordinator服务进程的主要作用是：接收查询请求、解析查询语句、生成查询执行计划、任务调度和Worker管理。而Worker服务进程则执行被分解后的查询执行任务:Task。\n\n1.Coordinator\nCoordinator服务进程部署于集群中一个单独的节点上，是整个Presto集群的管理节点。Coordinator服务进程主要用于接收客户端提交的查询，查询语句解析，生成查询执行计划、Stage和Task并对生成的Task进行调度。除此之外，Coordinator还对集群中的所有Worker进行管理。Coordinator进程是整个Presto集群的Master进程，该进程即与Worker进程通信从而获得最新的Worker信息，又与Client进行通信，从而接受查询请求，而所有的这些工作都是通过Coordinator上的StatementResource类提供的RESTful服务来完成的。\n\n2.Worker\n在一个Prestor集群中，存在一个Coordinator节点和多个Worker节点。Coordinator节点是管理节点，而Worker节点就是工作节点。在每个Worker节点上都会存在一个Worker服务进程，该服务进程主要进行数据的处理以及Task的执行。Worker服务进程每隔一定的时间都会向Coordinator上的RESTful服务发关心跳，从而告知Coordinator：我还活着，并接收你的调度。当客户端提交一个查询的时候，Coordinator则会从当前存活的Worker列表中选择出合适的Worker节点去运行Task。而Worker在执行每个Task的时候又会进一步对当前Task读入的每个Spli进行一系列的操作和处理。\n\n### Presto模型\n\nPresto可以通过多种不同类型的Connector访问多种数据源，目前支持的Connector包括：Hive、JMX、MySQL、Cassandra、PostgreSQL以及Kafka。下面介绍Presto是如何访问不同类型的数据源的，并对Presto中的模型和概念进行描述。\n\n1.Connector\nPresto是通过多种多样的Connector来访问多种不同的数据源的。你可以将Connector当作Presto访问各种不同数据源的驱动程序。一般情况下，Presto针对每种数据源都有与之对应的Connector。每种Connector都实现了Presto中标准的SPI接口，因此只要你实现Presto中的标准的SPI接口，就可以轻易地实现使用适合自己特定需求的Connector来访问特定的数据源。Presto目前支持的Connector 有Hive、JMX、MySQL、Cassandra、PostgreSQL等，都有其对应的Build-In Connector(内置的Connector)。\n当你需要使用某种Connector访问特定的数据源时，需要在$PRESTO_HOME/etc/catalog、中创建一个配置文件：example.properties）（文件名字限制，但是其后缀名必须为.properties），在该配置文件中必须要设置一个属性:connector.name，该属性是必须设置的。Presto中Connector Manager就是通过该配置属性来决定使用哪个Connector去访问相应的数据源的。例如，你现在需要访问一个hive数据源，那么你在配置文件中就需要将属性connect.name设置为Hive-cdh5或者Hive-cdh4，这样Presto就会使用内置的Hive connector去访问Hive数据仓库中相应的数据。\n\n2.Catalog\nPresto中的Catalog类型于Mysql中的数据库实例。而Schema就类似于Mysql中的一个Database。通过使用特定的Connector访问Catalog中指定的数据源，一个Catalog中可以包含多个Schema。那么怎么定义一个Catalog呢？其实你不需要特意去指定Catalog。正如之前说的，假设你想访问Hive中的数据，则需要在$PRESTO_HOME/etc/catalog中创建一个配置文件：example.properties。该配置文件中定义了诸如Hive store的URI等访问Hive中的数据所需要的所有配置项，并且配置文件的名字就是Catalog名字:example。从这里可以看出Presto中配置文件的名字（不带.properties）就是Catalog的名字。\n当你访问Catalog中的某个表时，该表的全名总是以Catalog的名字开始。例如名字为example.schema1.tables1的表，指的是表table1位于名为schema1的schema中，而schema1又位于名为example的Catalog中。\n\n3.Schema\nPresto中的Schema就类似于Mysql中的Database。一个Catalog名称和一个Schema名称唯一确定了可以查询的一系列表的集合。当通过Presto去查询Hive或者Mysql中的数据时，你会发现Presto中的Schema与Hive或者Mysql中的Database是相对应的。\n\n4.Table\nPresto中的Table与传统数据库中的Table的含义是一样的。\n\n### Preto查询执行模型\n\nPreto在执行SQL语句时，将这些SQL语句解析为相应的查询，并在分布式集群中执行这些查询。\n\n1.Statement\nStatement语句。其实就是指我们输入的SQL语句。Presto支持需要ANSI标准的SQL语句。这种语句由子句(Clause)、表达式（Expression）和断言(Predicate)组成。\n\nPresto为什么将语句(Statement)和查询(Query)的概念分开呢？\n因为在Presto中，语句和查询本身就是不同的概念。语句指的是终端用户输入的用文字表示的SQL语句；当Presto执行输入的SQL语句时，会根据SQL语句生成查询执行计划，进而生成可以执行的查询(Query)，而查询代表的是分布到所有的Worker之间执行的实际查询操作。\n\n2.Query\nQuery即查询执行。当Presto接收一个SQL语句并执行时，会解析该SQL语句，将其转变成一个查询执行和相关的查询执行计划。一个查询执行代表可以在Presto集群中运行的查询，是由运行在各个Worker上且各自之间相互关联的阶段（Stage）组成的。\n\n那么SQL语句与查询执行之间有什么不同呢？\n其实很简单，你可以认为SQL语句就是提交给Presto的用文字表示的SQL执行语句。而查询执行则是为了完成SQL语句所表述的查询而实例化的配置信息、组件、查询执行计划和优化信息等。一个查询执行由Stage、Task、Driver、Split、Operator和DataSource组成。这些组件之间通过内部联系共同组成了一个查询执行，从而得到SQL语句表述的查询，并得到相应的结果集。\n\n3.Stage\nStage即查询执行阶段。当Presto运行Query时，Presto会将一个Query拆分成具有层级关系的多个Stage，一个Stage就代表查询执计划的一部分。例如，当我们执行一个查询，从Hive的一张具有1亿条记录的表中查询数据并进行聚合操作时，Presto会创建一个Root Stage（后面会介绍，该Stage就是Single Stage），该Stage聚合其上游Stage的输出数据，然后将结果输出给Coordinator，并由Coordinator将结果输出给终端用户。\n通常情况下Stage之间是树状的层次结构。每个Query都有一个Root Stage。该Stage用于聚集所有其他Stage的输出数据，并将最终的数据反馈给终端用户。需要注意的是，Stage并不会在集群中实际执行，它只是Coordinator用于对查询计划进行管理和建模的逻辑概念。每个Stage（除了Single Stage和Source Stage）都会有输入和输出，都会从上游Stage读取数据，然后将产生结果输出给下游Stage。需要注意的是；Source Stage没有上游，它从Connector获取数据，Single Stage没有下游，它的结果直接输出给Coordinator，它由Coordinator输出给终端用户。\nPresto中的Stage共有4种，具体介绍如下：\nCoordinator_Only：这种类型的Stage用于执行DDL或者DML语句中最终的表结构创建或者更改。\nSingle：这种类型的Stage用于聚合子Stage的输出，并将结果数据输出给终端用户。\nFixed：这种类型的Stage用于接受其子Stage产生的数据并在集群中对这些数据进行分布式的聚合或者分组计算。\nSource：这种类型的Stage用于直接连接数据源，从数据源读取数据，在读取数据的同时，该阶段也会根据Presto对查询执行计划的优化完成相关的断言下发(Predicate PushDown)\n和条件过滤等。\n\n说明：一个SQL查询可以被分解 多个前后关联的Stage,在这里我们约定：按照数据的流向，越靠近数据源的Stage越处于上游，越远离数据源的Stage越处于下游。\n\n4.Exchange\nExchange的字面意思就是“交换”。Presto的Stage是通过Exchange来连接另一个Stage的。Exchange用于完成有上下游关系的Stage之间的数据交换。在Presto中有两种Exchange：Output Buffer和Exchange Client。生产数据的Stage通过名为Output Buffer的Exchange将数据传送给其下游的Stage。消费数据的Stage通过名为Exchange从上游Stage读取数据。\n如果当前Stage是Surce类型的Stage，那么该Stage则是直接通过相应的Connector从数据源读取数据的。而该Stage则是通过名为Source Operator的Operator与Connector进行交互的，例如，一个Source Stage直接从HDFS获取数据，那么这种操作不是通过Exchange Client来完成的，而是通过运行于Driver中的Source Operator来完成的。\n\n5.Task\n从前面的介绍中可以知道，Stage并不会在Presto集群中实际运行，它仅代表针对于一个SQL语句查询执行计划中的一部分查询的执行过程，只是用来对查询执行计划进行管理和建模。Stage在逻辑上又被分为一系列的Task，这些Task则是需要实际运行在Presto的各个Worker节点上的。\n在Presto集群中，一个查询执行被分解成具有层次关系的一系列的Stage，一个Stage又被拆分为一系列的Task。每个Task处理一个或者多个Split。每个Task都有对应的输入和输入。一个Stage被分解为多个Task，从而可以并行地执行一个Stage。Task也采用了相应的机制：一个Task也可以被分解为一个或者多个Driver，从而并行地执行一个Task。\n\n6.Driver\n一个Task包含一个或者多个Driver。一个Driver其实就是作用于一个Split的一系列Operator的集合。因此一个Driver用于处理一个Split，并且生成相应的输出，这些输出由Task收集并且传送给下游Stage中的Task。一个Driver拥有一个输入和一个输出。\n\n7.Operator\n一个Operator代表对一个Spit的一种操作，例如过滤、加权、转换等。一个Operator依次读取一个Split中的数据，将Operator所代表的计算和操作作用于Split的数据上，并产生输出。每个Operator均会以Page为最小处理单元分别读取输入数据和产生输出数据。Operator每次只会读取一个Page对象，相应地，每次也只会产生一个Page对象。\n\n8.Split\nSplit即分片，一个分片其实就是一个大的数据集中的一个小的子集。而Driver则是作用于一个分片上的一系列操作的集合，而每个节点上运行的Task，又包含多个Driver,从而一个Task可以处理多个Split。其中每一种操作均由一个Operator表示。分布式查询执行计划的源Stage(Source Stage)通过Connector从数据源获取多个分片。Source Stage对Split处理完毕之后，会将输出传递给其下游Stage（通常其下游Stage的类型为Fixed或者Single）。\n当Presto执行一个查询的时候，首先会从Coordinator得到一个表对应的所有Split。然后Presto就会根据查询执行计划，选择合适的节点运行相应的Task处理Split。\n\n9.Page\nPage是Presto中处理的最小数据单元。一个Page对象包含多个Block对象，而每个Block对象是一个字节数组，存储一个字段的若干行。多个Block横切的一行是真实的一行数据。一个Page最大为1MB，最多16*1024行数据。\n\n## 安装与部署\n\nPresto目前只能部署在Linux中。以集群模式部署进行说明 。\n\n### 环境说明\n\n需要3台服务器，1台作为Coordinator，2台作为Worker。\n\n### 准备工作\n\n#### 建立SSH\n\nCoordinator到各个Worker节点的ssh信任关系，以方便后续的Presto集群的管理和维护。\n\n#### Hive\n\n默认hive已经创建好。如果没有可自行安装。\n\n#### 源码编译\n\n下载官方编译好的安装包：https://github.com/prestodb/presto/archive/0.107.tar.gz。\n执行mvn -T2C install -DskipTests\n-T2C:说明一个CPU核心启动两个线程进行编译，可以加快源码编译的速度。\ninstall：将编译完成的Jar包直接安装到Maven库中。\n-DskipTests：跳过测试工程和测试类。\n\n#### 服务部署\n\n首先将二进制压缩包同步到各个节点上并解压，然后在各个节点上修改相应的配置项，最后启动Presto集群。\n\n##### 修改配置\n\n（1）config.properties\n\n（2） jvm.config\n\n（3）log.properties\n\n（4）node.properties\n\n### 启动和停止服务\n\nsh /opt/presto/presto-server/bin/launcher start\nsh /opt/presto/presto-server/bin/launcher stop\n\n### 查询\n\n```\npackage com.jd.PrestoJDBCClient;\n\nimport com.facebook.presto.jdbc.PrestoConnection;\nimport com.facebook.presto.jdbc.PrestoStatement;\n\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.TimeZone;\n\npublic class PrestoJDBCTestClient {\n    public static void printRow(ResultSet rs, int[] types) throws SQLException {\n        for (int i = 0; i < types.length; i++) {\n            System.out.print(\" \");\n            System.out.print(rs.getObject(i + 1));\n        }\n        System.out.println(\"\");\n\n    }\n\n    public static void connect() throws SQLException {\n        //设置时区，这里必须设置\n        TimeZone.setDefault(TimeZone.getTimeZone(\"Asia/Shanghai\"));\n        try {\n            //加载Presto JDBC驱动类\n            Class.forName(\"com.facebook.presto.jdbc.PrestoDriver\");\n\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n\n        PrestoConnection connection = null;\n        try {\n            //Presto连接串，在连接串中指定了默认的catalog为：system,默认的schema为:runtime，使用的用户名为：guest1，这个用户名根据实际业务自己设定，用来标识执行SQL的用户，虽然不会通过用户名进行身份认证，但是必须要写。密码直接指定为null，或者可以随便指定一个做生意密码，Presto是不会对密码进行验证的。\n            connection = (PrestoConnection) DriverManager.getConnection(\"jdbc:presto://172.16.154.38:8001/system/runtime\", \"guest1\", null);\n\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n\n        PrestoStatement statement = null;\n        try {\n            statement = (PrestoStatement) connection.createStatement();\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n\n        String query = \"select * from nodes\";\n        ResultSet rs = null;\n        try {\n            rs = statement.executeQuery(query);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n\n        int cn = rs.getMetaData().getColumnCount();\n        int[] types = new int[cn];\n        for (int i = 1; i < cn; i++) {\n            types[i - 1] = rs.getMetaData().getColumnType(i);\n        }\n\n        try {\n            while (rs.next()) {\n                printRow(rs, types);\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) throws ClassNotFoundException, SQLException {\n        connect();\n    }\n\n}\n\n```\n\n## 参考\n\n《Presto技术内幕》由京东研发团队出版。\n\n中文社区：http://prestodb-china.com/\nPresto 官网： http://prestodb.io/\nPresto Github 主页： https://github.com/facebook/presto\n京东修改版（推荐）： https://github.com/CHINA-JD/presto\nPresto 文档： http://prestodb-china.com/docs/current/\n","source":"_posts/数据中台/分布式SQL查询引擎-Presto.md","raw":"---\ntitle: 分布式SQL查询引擎-Presto\ndate: 2019-02-01 09:55:00\ntags: [Presto]\ncategories: [大数据技术,Presto]\n---\n\nPresto是一个开源的，基于内存的分布式实时计算框架，它出自Facebook，国内大厂现在已有很多应用案例，如：京东、美团、携程等。\n\n## PRESTO应用场景\n\nPresto在大数据量的查询上有很好的性能，并且数据源具有完成解耦、高性能，以及对SQL的支持等特性，使其有很多的应用场景，如ETL、Ad-Hoc查询等。\n\n### ETL\n\n由于Presto支持多种数据源且支持数据源定制化的开发，所以使其在ETL方式有其应用场景，如下。\n![Presto应用场景-ETL.jpg](https://upload-images.jianshu.io/upload_images/3109530-96f1cfbdf4a8018e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n通过azkaban定时调度Presto从不同数据源同步数据到HDFS，然后通过Hive提供批量的查询，Presto提供实时的查询需要。\n\n### Ad-Hoc查询\n\nAd-Hoc查询就是即席查询，即席查询允许用户根据自己的需求随时调整和选择查询条件，计算平台或者系统能够根据用户的查询条件返回查询结果或者生成相应的报表。\n某公司使用Presto完成Ad-Hoc查询，实际的Ad-Hoc使用场景包括以下两种。\n（1）使用BI工具进行报表展现。\nBI工具通过ODBC驱动连接至Presto集群，BI工程师使用BI工具进行不同维度的报表设计和展现。\n\n（2）使用Cli客户端进行数据分析\nPresto使用Hive作为数据源，对Hive中的数据进行查询和分析。众所周知，hive使用Map-Reduce框架进行计算，由于Map-Reduce的优势在于进行大数据量的批运算和提供强大的集群计算吞吐量，但是对稍小数据量的计算和分析会花费相当长的时间，因此在进行GB-TB级别数据量的计算和分析时，Hive并不能满足实时性要求。\nPresto是专门针对基于Ad-Hoc的实时查询和计算进行设计的，其平均性能是Hive的10倍，因此presto更适合于稍小数据量的计算和差异性分析等Ad-Hoc查询。\n\n## 核心概念\n\n### Presto服务进程\n\nPresto集群中一共有两种服务器进程：Coordinator服务进程和Worker服务进程，其中Coordinator服务进程的主要作用是：接收查询请求、解析查询语句、生成查询执行计划、任务调度和Worker管理。而Worker服务进程则执行被分解后的查询执行任务:Task。\n\n1.Coordinator\nCoordinator服务进程部署于集群中一个单独的节点上，是整个Presto集群的管理节点。Coordinator服务进程主要用于接收客户端提交的查询，查询语句解析，生成查询执行计划、Stage和Task并对生成的Task进行调度。除此之外，Coordinator还对集群中的所有Worker进行管理。Coordinator进程是整个Presto集群的Master进程，该进程即与Worker进程通信从而获得最新的Worker信息，又与Client进行通信，从而接受查询请求，而所有的这些工作都是通过Coordinator上的StatementResource类提供的RESTful服务来完成的。\n\n2.Worker\n在一个Prestor集群中，存在一个Coordinator节点和多个Worker节点。Coordinator节点是管理节点，而Worker节点就是工作节点。在每个Worker节点上都会存在一个Worker服务进程，该服务进程主要进行数据的处理以及Task的执行。Worker服务进程每隔一定的时间都会向Coordinator上的RESTful服务发关心跳，从而告知Coordinator：我还活着，并接收你的调度。当客户端提交一个查询的时候，Coordinator则会从当前存活的Worker列表中选择出合适的Worker节点去运行Task。而Worker在执行每个Task的时候又会进一步对当前Task读入的每个Spli进行一系列的操作和处理。\n\n### Presto模型\n\nPresto可以通过多种不同类型的Connector访问多种数据源，目前支持的Connector包括：Hive、JMX、MySQL、Cassandra、PostgreSQL以及Kafka。下面介绍Presto是如何访问不同类型的数据源的，并对Presto中的模型和概念进行描述。\n\n1.Connector\nPresto是通过多种多样的Connector来访问多种不同的数据源的。你可以将Connector当作Presto访问各种不同数据源的驱动程序。一般情况下，Presto针对每种数据源都有与之对应的Connector。每种Connector都实现了Presto中标准的SPI接口，因此只要你实现Presto中的标准的SPI接口，就可以轻易地实现使用适合自己特定需求的Connector来访问特定的数据源。Presto目前支持的Connector 有Hive、JMX、MySQL、Cassandra、PostgreSQL等，都有其对应的Build-In Connector(内置的Connector)。\n当你需要使用某种Connector访问特定的数据源时，需要在$PRESTO_HOME/etc/catalog、中创建一个配置文件：example.properties）（文件名字限制，但是其后缀名必须为.properties），在该配置文件中必须要设置一个属性:connector.name，该属性是必须设置的。Presto中Connector Manager就是通过该配置属性来决定使用哪个Connector去访问相应的数据源的。例如，你现在需要访问一个hive数据源，那么你在配置文件中就需要将属性connect.name设置为Hive-cdh5或者Hive-cdh4，这样Presto就会使用内置的Hive connector去访问Hive数据仓库中相应的数据。\n\n2.Catalog\nPresto中的Catalog类型于Mysql中的数据库实例。而Schema就类似于Mysql中的一个Database。通过使用特定的Connector访问Catalog中指定的数据源，一个Catalog中可以包含多个Schema。那么怎么定义一个Catalog呢？其实你不需要特意去指定Catalog。正如之前说的，假设你想访问Hive中的数据，则需要在$PRESTO_HOME/etc/catalog中创建一个配置文件：example.properties。该配置文件中定义了诸如Hive store的URI等访问Hive中的数据所需要的所有配置项，并且配置文件的名字就是Catalog名字:example。从这里可以看出Presto中配置文件的名字（不带.properties）就是Catalog的名字。\n当你访问Catalog中的某个表时，该表的全名总是以Catalog的名字开始。例如名字为example.schema1.tables1的表，指的是表table1位于名为schema1的schema中，而schema1又位于名为example的Catalog中。\n\n3.Schema\nPresto中的Schema就类似于Mysql中的Database。一个Catalog名称和一个Schema名称唯一确定了可以查询的一系列表的集合。当通过Presto去查询Hive或者Mysql中的数据时，你会发现Presto中的Schema与Hive或者Mysql中的Database是相对应的。\n\n4.Table\nPresto中的Table与传统数据库中的Table的含义是一样的。\n\n### Preto查询执行模型\n\nPreto在执行SQL语句时，将这些SQL语句解析为相应的查询，并在分布式集群中执行这些查询。\n\n1.Statement\nStatement语句。其实就是指我们输入的SQL语句。Presto支持需要ANSI标准的SQL语句。这种语句由子句(Clause)、表达式（Expression）和断言(Predicate)组成。\n\nPresto为什么将语句(Statement)和查询(Query)的概念分开呢？\n因为在Presto中，语句和查询本身就是不同的概念。语句指的是终端用户输入的用文字表示的SQL语句；当Presto执行输入的SQL语句时，会根据SQL语句生成查询执行计划，进而生成可以执行的查询(Query)，而查询代表的是分布到所有的Worker之间执行的实际查询操作。\n\n2.Query\nQuery即查询执行。当Presto接收一个SQL语句并执行时，会解析该SQL语句，将其转变成一个查询执行和相关的查询执行计划。一个查询执行代表可以在Presto集群中运行的查询，是由运行在各个Worker上且各自之间相互关联的阶段（Stage）组成的。\n\n那么SQL语句与查询执行之间有什么不同呢？\n其实很简单，你可以认为SQL语句就是提交给Presto的用文字表示的SQL执行语句。而查询执行则是为了完成SQL语句所表述的查询而实例化的配置信息、组件、查询执行计划和优化信息等。一个查询执行由Stage、Task、Driver、Split、Operator和DataSource组成。这些组件之间通过内部联系共同组成了一个查询执行，从而得到SQL语句表述的查询，并得到相应的结果集。\n\n3.Stage\nStage即查询执行阶段。当Presto运行Query时，Presto会将一个Query拆分成具有层级关系的多个Stage，一个Stage就代表查询执计划的一部分。例如，当我们执行一个查询，从Hive的一张具有1亿条记录的表中查询数据并进行聚合操作时，Presto会创建一个Root Stage（后面会介绍，该Stage就是Single Stage），该Stage聚合其上游Stage的输出数据，然后将结果输出给Coordinator，并由Coordinator将结果输出给终端用户。\n通常情况下Stage之间是树状的层次结构。每个Query都有一个Root Stage。该Stage用于聚集所有其他Stage的输出数据，并将最终的数据反馈给终端用户。需要注意的是，Stage并不会在集群中实际执行，它只是Coordinator用于对查询计划进行管理和建模的逻辑概念。每个Stage（除了Single Stage和Source Stage）都会有输入和输出，都会从上游Stage读取数据，然后将产生结果输出给下游Stage。需要注意的是；Source Stage没有上游，它从Connector获取数据，Single Stage没有下游，它的结果直接输出给Coordinator，它由Coordinator输出给终端用户。\nPresto中的Stage共有4种，具体介绍如下：\nCoordinator_Only：这种类型的Stage用于执行DDL或者DML语句中最终的表结构创建或者更改。\nSingle：这种类型的Stage用于聚合子Stage的输出，并将结果数据输出给终端用户。\nFixed：这种类型的Stage用于接受其子Stage产生的数据并在集群中对这些数据进行分布式的聚合或者分组计算。\nSource：这种类型的Stage用于直接连接数据源，从数据源读取数据，在读取数据的同时，该阶段也会根据Presto对查询执行计划的优化完成相关的断言下发(Predicate PushDown)\n和条件过滤等。\n\n说明：一个SQL查询可以被分解 多个前后关联的Stage,在这里我们约定：按照数据的流向，越靠近数据源的Stage越处于上游，越远离数据源的Stage越处于下游。\n\n4.Exchange\nExchange的字面意思就是“交换”。Presto的Stage是通过Exchange来连接另一个Stage的。Exchange用于完成有上下游关系的Stage之间的数据交换。在Presto中有两种Exchange：Output Buffer和Exchange Client。生产数据的Stage通过名为Output Buffer的Exchange将数据传送给其下游的Stage。消费数据的Stage通过名为Exchange从上游Stage读取数据。\n如果当前Stage是Surce类型的Stage，那么该Stage则是直接通过相应的Connector从数据源读取数据的。而该Stage则是通过名为Source Operator的Operator与Connector进行交互的，例如，一个Source Stage直接从HDFS获取数据，那么这种操作不是通过Exchange Client来完成的，而是通过运行于Driver中的Source Operator来完成的。\n\n5.Task\n从前面的介绍中可以知道，Stage并不会在Presto集群中实际运行，它仅代表针对于一个SQL语句查询执行计划中的一部分查询的执行过程，只是用来对查询执行计划进行管理和建模。Stage在逻辑上又被分为一系列的Task，这些Task则是需要实际运行在Presto的各个Worker节点上的。\n在Presto集群中，一个查询执行被分解成具有层次关系的一系列的Stage，一个Stage又被拆分为一系列的Task。每个Task处理一个或者多个Split。每个Task都有对应的输入和输入。一个Stage被分解为多个Task，从而可以并行地执行一个Stage。Task也采用了相应的机制：一个Task也可以被分解为一个或者多个Driver，从而并行地执行一个Task。\n\n6.Driver\n一个Task包含一个或者多个Driver。一个Driver其实就是作用于一个Split的一系列Operator的集合。因此一个Driver用于处理一个Split，并且生成相应的输出，这些输出由Task收集并且传送给下游Stage中的Task。一个Driver拥有一个输入和一个输出。\n\n7.Operator\n一个Operator代表对一个Spit的一种操作，例如过滤、加权、转换等。一个Operator依次读取一个Split中的数据，将Operator所代表的计算和操作作用于Split的数据上，并产生输出。每个Operator均会以Page为最小处理单元分别读取输入数据和产生输出数据。Operator每次只会读取一个Page对象，相应地，每次也只会产生一个Page对象。\n\n8.Split\nSplit即分片，一个分片其实就是一个大的数据集中的一个小的子集。而Driver则是作用于一个分片上的一系列操作的集合，而每个节点上运行的Task，又包含多个Driver,从而一个Task可以处理多个Split。其中每一种操作均由一个Operator表示。分布式查询执行计划的源Stage(Source Stage)通过Connector从数据源获取多个分片。Source Stage对Split处理完毕之后，会将输出传递给其下游Stage（通常其下游Stage的类型为Fixed或者Single）。\n当Presto执行一个查询的时候，首先会从Coordinator得到一个表对应的所有Split。然后Presto就会根据查询执行计划，选择合适的节点运行相应的Task处理Split。\n\n9.Page\nPage是Presto中处理的最小数据单元。一个Page对象包含多个Block对象，而每个Block对象是一个字节数组，存储一个字段的若干行。多个Block横切的一行是真实的一行数据。一个Page最大为1MB，最多16*1024行数据。\n\n## 安装与部署\n\nPresto目前只能部署在Linux中。以集群模式部署进行说明 。\n\n### 环境说明\n\n需要3台服务器，1台作为Coordinator，2台作为Worker。\n\n### 准备工作\n\n#### 建立SSH\n\nCoordinator到各个Worker节点的ssh信任关系，以方便后续的Presto集群的管理和维护。\n\n#### Hive\n\n默认hive已经创建好。如果没有可自行安装。\n\n#### 源码编译\n\n下载官方编译好的安装包：https://github.com/prestodb/presto/archive/0.107.tar.gz。\n执行mvn -T2C install -DskipTests\n-T2C:说明一个CPU核心启动两个线程进行编译，可以加快源码编译的速度。\ninstall：将编译完成的Jar包直接安装到Maven库中。\n-DskipTests：跳过测试工程和测试类。\n\n#### 服务部署\n\n首先将二进制压缩包同步到各个节点上并解压，然后在各个节点上修改相应的配置项，最后启动Presto集群。\n\n##### 修改配置\n\n（1）config.properties\n\n（2） jvm.config\n\n（3）log.properties\n\n（4）node.properties\n\n### 启动和停止服务\n\nsh /opt/presto/presto-server/bin/launcher start\nsh /opt/presto/presto-server/bin/launcher stop\n\n### 查询\n\n```\npackage com.jd.PrestoJDBCClient;\n\nimport com.facebook.presto.jdbc.PrestoConnection;\nimport com.facebook.presto.jdbc.PrestoStatement;\n\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.TimeZone;\n\npublic class PrestoJDBCTestClient {\n    public static void printRow(ResultSet rs, int[] types) throws SQLException {\n        for (int i = 0; i < types.length; i++) {\n            System.out.print(\" \");\n            System.out.print(rs.getObject(i + 1));\n        }\n        System.out.println(\"\");\n\n    }\n\n    public static void connect() throws SQLException {\n        //设置时区，这里必须设置\n        TimeZone.setDefault(TimeZone.getTimeZone(\"Asia/Shanghai\"));\n        try {\n            //加载Presto JDBC驱动类\n            Class.forName(\"com.facebook.presto.jdbc.PrestoDriver\");\n\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n\n        PrestoConnection connection = null;\n        try {\n            //Presto连接串，在连接串中指定了默认的catalog为：system,默认的schema为:runtime，使用的用户名为：guest1，这个用户名根据实际业务自己设定，用来标识执行SQL的用户，虽然不会通过用户名进行身份认证，但是必须要写。密码直接指定为null，或者可以随便指定一个做生意密码，Presto是不会对密码进行验证的。\n            connection = (PrestoConnection) DriverManager.getConnection(\"jdbc:presto://172.16.154.38:8001/system/runtime\", \"guest1\", null);\n\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n\n        PrestoStatement statement = null;\n        try {\n            statement = (PrestoStatement) connection.createStatement();\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n\n        String query = \"select * from nodes\";\n        ResultSet rs = null;\n        try {\n            rs = statement.executeQuery(query);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n\n        int cn = rs.getMetaData().getColumnCount();\n        int[] types = new int[cn];\n        for (int i = 1; i < cn; i++) {\n            types[i - 1] = rs.getMetaData().getColumnType(i);\n        }\n\n        try {\n            while (rs.next()) {\n                printRow(rs, types);\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) throws ClassNotFoundException, SQLException {\n        connect();\n    }\n\n}\n\n```\n\n## 参考\n\n《Presto技术内幕》由京东研发团队出版。\n\n中文社区：http://prestodb-china.com/\nPresto 官网： http://prestodb.io/\nPresto Github 主页： https://github.com/facebook/presto\n京东修改版（推荐）： https://github.com/CHINA-JD/presto\nPresto 文档： http://prestodb-china.com/docs/current/\n","slug":"数据中台/分布式SQL查询引擎-Presto","published":1,"updated":"2019-03-13T10:11:15.326Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bov00ans77reenqr2jt","content":"<p>Presto是一个开源的，基于内存的分布式实时计算框架，它出自Facebook，国内大厂现在已有很多应用案例，如：京东、美团、携程等。</p>\n<h2 id=\"PRESTO应用场景\"><a href=\"#PRESTO应用场景\" class=\"headerlink\" title=\"PRESTO应用场景\"></a>PRESTO应用场景</h2><p>Presto在大数据量的查询上有很好的性能，并且数据源具有完成解耦、高性能，以及对SQL的支持等特性，使其有很多的应用场景，如ETL、Ad-Hoc查询等。</p>\n<h3 id=\"ETL\"><a href=\"#ETL\" class=\"headerlink\" title=\"ETL\"></a>ETL</h3><p>由于Presto支持多种数据源且支持数据源定制化的开发，所以使其在ETL方式有其应用场景，如下。<br><img src=\"https://upload-images.jianshu.io/upload_images/3109530-96f1cfbdf4a8018e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Presto应用场景-ETL.jpg\"></p>\n<p>通过azkaban定时调度Presto从不同数据源同步数据到HDFS，然后通过Hive提供批量的查询，Presto提供实时的查询需要。</p>\n<h3 id=\"Ad-Hoc查询\"><a href=\"#Ad-Hoc查询\" class=\"headerlink\" title=\"Ad-Hoc查询\"></a>Ad-Hoc查询</h3><p>Ad-Hoc查询就是即席查询，即席查询允许用户根据自己的需求随时调整和选择查询条件，计算平台或者系统能够根据用户的查询条件返回查询结果或者生成相应的报表。<br>某公司使用Presto完成Ad-Hoc查询，实际的Ad-Hoc使用场景包括以下两种。<br>（1）使用BI工具进行报表展现。<br>BI工具通过ODBC驱动连接至Presto集群，BI工程师使用BI工具进行不同维度的报表设计和展现。</p>\n<p>（2）使用Cli客户端进行数据分析<br>Presto使用Hive作为数据源，对Hive中的数据进行查询和分析。众所周知，hive使用Map-Reduce框架进行计算，由于Map-Reduce的优势在于进行大数据量的批运算和提供强大的集群计算吞吐量，但是对稍小数据量的计算和分析会花费相当长的时间，因此在进行GB-TB级别数据量的计算和分析时，Hive并不能满足实时性要求。<br>Presto是专门针对基于Ad-Hoc的实时查询和计算进行设计的，其平均性能是Hive的10倍，因此presto更适合于稍小数据量的计算和差异性分析等Ad-Hoc查询。</p>\n<h2 id=\"核心概念\"><a href=\"#核心概念\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h2><h3 id=\"Presto服务进程\"><a href=\"#Presto服务进程\" class=\"headerlink\" title=\"Presto服务进程\"></a>Presto服务进程</h3><p>Presto集群中一共有两种服务器进程：Coordinator服务进程和Worker服务进程，其中Coordinator服务进程的主要作用是：接收查询请求、解析查询语句、生成查询执行计划、任务调度和Worker管理。而Worker服务进程则执行被分解后的查询执行任务:Task。</p>\n<p>1.Coordinator<br>Coordinator服务进程部署于集群中一个单独的节点上，是整个Presto集群的管理节点。Coordinator服务进程主要用于接收客户端提交的查询，查询语句解析，生成查询执行计划、Stage和Task并对生成的Task进行调度。除此之外，Coordinator还对集群中的所有Worker进行管理。Coordinator进程是整个Presto集群的Master进程，该进程即与Worker进程通信从而获得最新的Worker信息，又与Client进行通信，从而接受查询请求，而所有的这些工作都是通过Coordinator上的StatementResource类提供的RESTful服务来完成的。</p>\n<p>2.Worker<br>在一个Prestor集群中，存在一个Coordinator节点和多个Worker节点。Coordinator节点是管理节点，而Worker节点就是工作节点。在每个Worker节点上都会存在一个Worker服务进程，该服务进程主要进行数据的处理以及Task的执行。Worker服务进程每隔一定的时间都会向Coordinator上的RESTful服务发关心跳，从而告知Coordinator：我还活着，并接收你的调度。当客户端提交一个查询的时候，Coordinator则会从当前存活的Worker列表中选择出合适的Worker节点去运行Task。而Worker在执行每个Task的时候又会进一步对当前Task读入的每个Spli进行一系列的操作和处理。</p>\n<h3 id=\"Presto模型\"><a href=\"#Presto模型\" class=\"headerlink\" title=\"Presto模型\"></a>Presto模型</h3><p>Presto可以通过多种不同类型的Connector访问多种数据源，目前支持的Connector包括：Hive、JMX、MySQL、Cassandra、PostgreSQL以及Kafka。下面介绍Presto是如何访问不同类型的数据源的，并对Presto中的模型和概念进行描述。</p>\n<p>1.Connector<br>Presto是通过多种多样的Connector来访问多种不同的数据源的。你可以将Connector当作Presto访问各种不同数据源的驱动程序。一般情况下，Presto针对每种数据源都有与之对应的Connector。每种Connector都实现了Presto中标准的SPI接口，因此只要你实现Presto中的标准的SPI接口，就可以轻易地实现使用适合自己特定需求的Connector来访问特定的数据源。Presto目前支持的Connector 有Hive、JMX、MySQL、Cassandra、PostgreSQL等，都有其对应的Build-In Connector(内置的Connector)。<br>当你需要使用某种Connector访问特定的数据源时，需要在$PRESTO_HOME/etc/catalog、中创建一个配置文件：example.properties）（文件名字限制，但是其后缀名必须为.properties），在该配置文件中必须要设置一个属性:connector.name，该属性是必须设置的。Presto中Connector Manager就是通过该配置属性来决定使用哪个Connector去访问相应的数据源的。例如，你现在需要访问一个hive数据源，那么你在配置文件中就需要将属性connect.name设置为Hive-cdh5或者Hive-cdh4，这样Presto就会使用内置的Hive connector去访问Hive数据仓库中相应的数据。</p>\n<p>2.Catalog<br>Presto中的Catalog类型于Mysql中的数据库实例。而Schema就类似于Mysql中的一个Database。通过使用特定的Connector访问Catalog中指定的数据源，一个Catalog中可以包含多个Schema。那么怎么定义一个Catalog呢？其实你不需要特意去指定Catalog。正如之前说的，假设你想访问Hive中的数据，则需要在$PRESTO_HOME/etc/catalog中创建一个配置文件：example.properties。该配置文件中定义了诸如Hive store的URI等访问Hive中的数据所需要的所有配置项，并且配置文件的名字就是Catalog名字:example。从这里可以看出Presto中配置文件的名字（不带.properties）就是Catalog的名字。<br>当你访问Catalog中的某个表时，该表的全名总是以Catalog的名字开始。例如名字为example.schema1.tables1的表，指的是表table1位于名为schema1的schema中，而schema1又位于名为example的Catalog中。</p>\n<p>3.Schema<br>Presto中的Schema就类似于Mysql中的Database。一个Catalog名称和一个Schema名称唯一确定了可以查询的一系列表的集合。当通过Presto去查询Hive或者Mysql中的数据时，你会发现Presto中的Schema与Hive或者Mysql中的Database是相对应的。</p>\n<p>4.Table<br>Presto中的Table与传统数据库中的Table的含义是一样的。</p>\n<h3 id=\"Preto查询执行模型\"><a href=\"#Preto查询执行模型\" class=\"headerlink\" title=\"Preto查询执行模型\"></a>Preto查询执行模型</h3><p>Preto在执行SQL语句时，将这些SQL语句解析为相应的查询，并在分布式集群中执行这些查询。</p>\n<p>1.Statement<br>Statement语句。其实就是指我们输入的SQL语句。Presto支持需要ANSI标准的SQL语句。这种语句由子句(Clause)、表达式（Expression）和断言(Predicate)组成。</p>\n<p>Presto为什么将语句(Statement)和查询(Query)的概念分开呢？<br>因为在Presto中，语句和查询本身就是不同的概念。语句指的是终端用户输入的用文字表示的SQL语句；当Presto执行输入的SQL语句时，会根据SQL语句生成查询执行计划，进而生成可以执行的查询(Query)，而查询代表的是分布到所有的Worker之间执行的实际查询操作。</p>\n<p>2.Query<br>Query即查询执行。当Presto接收一个SQL语句并执行时，会解析该SQL语句，将其转变成一个查询执行和相关的查询执行计划。一个查询执行代表可以在Presto集群中运行的查询，是由运行在各个Worker上且各自之间相互关联的阶段（Stage）组成的。</p>\n<p>那么SQL语句与查询执行之间有什么不同呢？<br>其实很简单，你可以认为SQL语句就是提交给Presto的用文字表示的SQL执行语句。而查询执行则是为了完成SQL语句所表述的查询而实例化的配置信息、组件、查询执行计划和优化信息等。一个查询执行由Stage、Task、Driver、Split、Operator和DataSource组成。这些组件之间通过内部联系共同组成了一个查询执行，从而得到SQL语句表述的查询，并得到相应的结果集。</p>\n<p>3.Stage<br>Stage即查询执行阶段。当Presto运行Query时，Presto会将一个Query拆分成具有层级关系的多个Stage，一个Stage就代表查询执计划的一部分。例如，当我们执行一个查询，从Hive的一张具有1亿条记录的表中查询数据并进行聚合操作时，Presto会创建一个Root Stage（后面会介绍，该Stage就是Single Stage），该Stage聚合其上游Stage的输出数据，然后将结果输出给Coordinator，并由Coordinator将结果输出给终端用户。<br>通常情况下Stage之间是树状的层次结构。每个Query都有一个Root Stage。该Stage用于聚集所有其他Stage的输出数据，并将最终的数据反馈给终端用户。需要注意的是，Stage并不会在集群中实际执行，它只是Coordinator用于对查询计划进行管理和建模的逻辑概念。每个Stage（除了Single Stage和Source Stage）都会有输入和输出，都会从上游Stage读取数据，然后将产生结果输出给下游Stage。需要注意的是；Source Stage没有上游，它从Connector获取数据，Single Stage没有下游，它的结果直接输出给Coordinator，它由Coordinator输出给终端用户。<br>Presto中的Stage共有4种，具体介绍如下：<br>Coordinator_Only：这种类型的Stage用于执行DDL或者DML语句中最终的表结构创建或者更改。<br>Single：这种类型的Stage用于聚合子Stage的输出，并将结果数据输出给终端用户。<br>Fixed：这种类型的Stage用于接受其子Stage产生的数据并在集群中对这些数据进行分布式的聚合或者分组计算。<br>Source：这种类型的Stage用于直接连接数据源，从数据源读取数据，在读取数据的同时，该阶段也会根据Presto对查询执行计划的优化完成相关的断言下发(Predicate PushDown)<br>和条件过滤等。</p>\n<p>说明：一个SQL查询可以被分解 多个前后关联的Stage,在这里我们约定：按照数据的流向，越靠近数据源的Stage越处于上游，越远离数据源的Stage越处于下游。</p>\n<p>4.Exchange<br>Exchange的字面意思就是“交换”。Presto的Stage是通过Exchange来连接另一个Stage的。Exchange用于完成有上下游关系的Stage之间的数据交换。在Presto中有两种Exchange：Output Buffer和Exchange Client。生产数据的Stage通过名为Output Buffer的Exchange将数据传送给其下游的Stage。消费数据的Stage通过名为Exchange从上游Stage读取数据。<br>如果当前Stage是Surce类型的Stage，那么该Stage则是直接通过相应的Connector从数据源读取数据的。而该Stage则是通过名为Source Operator的Operator与Connector进行交互的，例如，一个Source Stage直接从HDFS获取数据，那么这种操作不是通过Exchange Client来完成的，而是通过运行于Driver中的Source Operator来完成的。</p>\n<p>5.Task<br>从前面的介绍中可以知道，Stage并不会在Presto集群中实际运行，它仅代表针对于一个SQL语句查询执行计划中的一部分查询的执行过程，只是用来对查询执行计划进行管理和建模。Stage在逻辑上又被分为一系列的Task，这些Task则是需要实际运行在Presto的各个Worker节点上的。<br>在Presto集群中，一个查询执行被分解成具有层次关系的一系列的Stage，一个Stage又被拆分为一系列的Task。每个Task处理一个或者多个Split。每个Task都有对应的输入和输入。一个Stage被分解为多个Task，从而可以并行地执行一个Stage。Task也采用了相应的机制：一个Task也可以被分解为一个或者多个Driver，从而并行地执行一个Task。</p>\n<p>6.Driver<br>一个Task包含一个或者多个Driver。一个Driver其实就是作用于一个Split的一系列Operator的集合。因此一个Driver用于处理一个Split，并且生成相应的输出，这些输出由Task收集并且传送给下游Stage中的Task。一个Driver拥有一个输入和一个输出。</p>\n<p>7.Operator<br>一个Operator代表对一个Spit的一种操作，例如过滤、加权、转换等。一个Operator依次读取一个Split中的数据，将Operator所代表的计算和操作作用于Split的数据上，并产生输出。每个Operator均会以Page为最小处理单元分别读取输入数据和产生输出数据。Operator每次只会读取一个Page对象，相应地，每次也只会产生一个Page对象。</p>\n<p>8.Split<br>Split即分片，一个分片其实就是一个大的数据集中的一个小的子集。而Driver则是作用于一个分片上的一系列操作的集合，而每个节点上运行的Task，又包含多个Driver,从而一个Task可以处理多个Split。其中每一种操作均由一个Operator表示。分布式查询执行计划的源Stage(Source Stage)通过Connector从数据源获取多个分片。Source Stage对Split处理完毕之后，会将输出传递给其下游Stage（通常其下游Stage的类型为Fixed或者Single）。<br>当Presto执行一个查询的时候，首先会从Coordinator得到一个表对应的所有Split。然后Presto就会根据查询执行计划，选择合适的节点运行相应的Task处理Split。</p>\n<p>9.Page<br>Page是Presto中处理的最小数据单元。一个Page对象包含多个Block对象，而每个Block对象是一个字节数组，存储一个字段的若干行。多个Block横切的一行是真实的一行数据。一个Page最大为1MB，最多16*1024行数据。</p>\n<h2 id=\"安装与部署\"><a href=\"#安装与部署\" class=\"headerlink\" title=\"安装与部署\"></a>安装与部署</h2><p>Presto目前只能部署在Linux中。以集群模式部署进行说明 。</p>\n<h3 id=\"环境说明\"><a href=\"#环境说明\" class=\"headerlink\" title=\"环境说明\"></a>环境说明</h3><p>需要3台服务器，1台作为Coordinator，2台作为Worker。</p>\n<h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><h4 id=\"建立SSH\"><a href=\"#建立SSH\" class=\"headerlink\" title=\"建立SSH\"></a>建立SSH</h4><p>Coordinator到各个Worker节点的ssh信任关系，以方便后续的Presto集群的管理和维护。</p>\n<h4 id=\"Hive\"><a href=\"#Hive\" class=\"headerlink\" title=\"Hive\"></a>Hive</h4><p>默认hive已经创建好。如果没有可自行安装。</p>\n<h4 id=\"源码编译\"><a href=\"#源码编译\" class=\"headerlink\" title=\"源码编译\"></a>源码编译</h4><p>下载官方编译好的安装包：<a href=\"https://github.com/prestodb/presto/archive/0.107.tar.gz。\" target=\"_blank\" rel=\"noopener\">https://github.com/prestodb/presto/archive/0.107.tar.gz。</a><br>执行mvn -T2C install -DskipTests<br>-T2C:说明一个CPU核心启动两个线程进行编译，可以加快源码编译的速度。<br>install：将编译完成的Jar包直接安装到Maven库中。<br>-DskipTests：跳过测试工程和测试类。</p>\n<h4 id=\"服务部署\"><a href=\"#服务部署\" class=\"headerlink\" title=\"服务部署\"></a>服务部署</h4><p>首先将二进制压缩包同步到各个节点上并解压，然后在各个节点上修改相应的配置项，最后启动Presto集群。</p>\n<h5 id=\"修改配置\"><a href=\"#修改配置\" class=\"headerlink\" title=\"修改配置\"></a>修改配置</h5><p>（1）config.properties</p>\n<p>（2） jvm.config</p>\n<p>（3）log.properties</p>\n<p>（4）node.properties</p>\n<h3 id=\"启动和停止服务\"><a href=\"#启动和停止服务\" class=\"headerlink\" title=\"启动和停止服务\"></a>启动和停止服务</h3><p>sh /opt/presto/presto-server/bin/launcher start<br>sh /opt/presto/presto-server/bin/launcher stop</p>\n<h3 id=\"查询\"><a href=\"#查询\" class=\"headerlink\" title=\"查询\"></a>查询</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.jd.PrestoJDBCClient;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.facebook.presto.jdbc.PrestoConnection;</span><br><span class=\"line\">import com.facebook.presto.jdbc.PrestoStatement;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.sql.DriverManager;</span><br><span class=\"line\">import java.sql.ResultSet;</span><br><span class=\"line\">import java.sql.SQLException;</span><br><span class=\"line\">import java.util.TimeZone;</span><br><span class=\"line\"></span><br><span class=\"line\">public class PrestoJDBCTestClient &#123;</span><br><span class=\"line\">    public static void printRow(ResultSet rs, int[] types) throws SQLException &#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; types.length; i++) &#123;</span><br><span class=\"line\">            System.out.print(&quot; &quot;);</span><br><span class=\"line\">            System.out.print(rs.getObject(i + 1));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(&quot;&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void connect() throws SQLException &#123;</span><br><span class=\"line\">        //设置时区，这里必须设置</span><br><span class=\"line\">        TimeZone.setDefault(TimeZone.getTimeZone(&quot;Asia/Shanghai&quot;));</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            //加载Presto JDBC驱动类</span><br><span class=\"line\">            Class.forName(&quot;com.facebook.presto.jdbc.PrestoDriver&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        PrestoConnection connection = null;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            //Presto连接串，在连接串中指定了默认的catalog为：system,默认的schema为:runtime，使用的用户名为：guest1，这个用户名根据实际业务自己设定，用来标识执行SQL的用户，虽然不会通过用户名进行身份认证，但是必须要写。密码直接指定为null，或者可以随便指定一个做生意密码，Presto是不会对密码进行验证的。</span><br><span class=\"line\">            connection = (PrestoConnection) DriverManager.getConnection(&quot;jdbc:presto://172.16.154.38:8001/system/runtime&quot;, &quot;guest1&quot;, null);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; catch (SQLException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        PrestoStatement statement = null;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            statement = (PrestoStatement) connection.createStatement();</span><br><span class=\"line\">        &#125; catch (SQLException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        String query = &quot;select * from nodes&quot;;</span><br><span class=\"line\">        ResultSet rs = null;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            rs = statement.executeQuery(query);</span><br><span class=\"line\">        &#125; catch (SQLException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        int cn = rs.getMetaData().getColumnCount();</span><br><span class=\"line\">        int[] types = new int[cn];</span><br><span class=\"line\">        for (int i = 1; i &lt; cn; i++) &#123;</span><br><span class=\"line\">            types[i - 1] = rs.getMetaData().getColumnType(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            while (rs.next()) &#123;</span><br><span class=\"line\">                printRow(rs, types);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; catch (SQLException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) throws ClassNotFoundException, SQLException &#123;</span><br><span class=\"line\">        connect();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>《Presto技术内幕》由京东研发团队出版。</p>\n<p>中文社区：<a href=\"http://prestodb-china.com/\" target=\"_blank\" rel=\"noopener\">http://prestodb-china.com/</a><br>Presto 官网： <a href=\"http://prestodb.io/\" target=\"_blank\" rel=\"noopener\">http://prestodb.io/</a><br>Presto Github 主页： <a href=\"https://github.com/facebook/presto\" target=\"_blank\" rel=\"noopener\">https://github.com/facebook/presto</a><br>京东修改版（推荐）： <a href=\"https://github.com/CHINA-JD/presto\" target=\"_blank\" rel=\"noopener\">https://github.com/CHINA-JD/presto</a><br>Presto 文档： <a href=\"http://prestodb-china.com/docs/current/\" target=\"_blank\" rel=\"noopener\">http://prestodb-china.com/docs/current/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Presto是一个开源的，基于内存的分布式实时计算框架，它出自Facebook，国内大厂现在已有很多应用案例，如：京东、美团、携程等。</p>\n<h2 id=\"PRESTO应用场景\"><a href=\"#PRESTO应用场景\" class=\"headerlink\" title=\"PRESTO应用场景\"></a>PRESTO应用场景</h2><p>Presto在大数据量的查询上有很好的性能，并且数据源具有完成解耦、高性能，以及对SQL的支持等特性，使其有很多的应用场景，如ETL、Ad-Hoc查询等。</p>\n<h3 id=\"ETL\"><a href=\"#ETL\" class=\"headerlink\" title=\"ETL\"></a>ETL</h3><p>由于Presto支持多种数据源且支持数据源定制化的开发，所以使其在ETL方式有其应用场景，如下。<br><img src=\"https://upload-images.jianshu.io/upload_images/3109530-96f1cfbdf4a8018e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Presto应用场景-ETL.jpg\"></p>\n<p>通过azkaban定时调度Presto从不同数据源同步数据到HDFS，然后通过Hive提供批量的查询，Presto提供实时的查询需要。</p>\n<h3 id=\"Ad-Hoc查询\"><a href=\"#Ad-Hoc查询\" class=\"headerlink\" title=\"Ad-Hoc查询\"></a>Ad-Hoc查询</h3><p>Ad-Hoc查询就是即席查询，即席查询允许用户根据自己的需求随时调整和选择查询条件，计算平台或者系统能够根据用户的查询条件返回查询结果或者生成相应的报表。<br>某公司使用Presto完成Ad-Hoc查询，实际的Ad-Hoc使用场景包括以下两种。<br>（1）使用BI工具进行报表展现。<br>BI工具通过ODBC驱动连接至Presto集群，BI工程师使用BI工具进行不同维度的报表设计和展现。</p>\n<p>（2）使用Cli客户端进行数据分析<br>Presto使用Hive作为数据源，对Hive中的数据进行查询和分析。众所周知，hive使用Map-Reduce框架进行计算，由于Map-Reduce的优势在于进行大数据量的批运算和提供强大的集群计算吞吐量，但是对稍小数据量的计算和分析会花费相当长的时间，因此在进行GB-TB级别数据量的计算和分析时，Hive并不能满足实时性要求。<br>Presto是专门针对基于Ad-Hoc的实时查询和计算进行设计的，其平均性能是Hive的10倍，因此presto更适合于稍小数据量的计算和差异性分析等Ad-Hoc查询。</p>\n<h2 id=\"核心概念\"><a href=\"#核心概念\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h2><h3 id=\"Presto服务进程\"><a href=\"#Presto服务进程\" class=\"headerlink\" title=\"Presto服务进程\"></a>Presto服务进程</h3><p>Presto集群中一共有两种服务器进程：Coordinator服务进程和Worker服务进程，其中Coordinator服务进程的主要作用是：接收查询请求、解析查询语句、生成查询执行计划、任务调度和Worker管理。而Worker服务进程则执行被分解后的查询执行任务:Task。</p>\n<p>1.Coordinator<br>Coordinator服务进程部署于集群中一个单独的节点上，是整个Presto集群的管理节点。Coordinator服务进程主要用于接收客户端提交的查询，查询语句解析，生成查询执行计划、Stage和Task并对生成的Task进行调度。除此之外，Coordinator还对集群中的所有Worker进行管理。Coordinator进程是整个Presto集群的Master进程，该进程即与Worker进程通信从而获得最新的Worker信息，又与Client进行通信，从而接受查询请求，而所有的这些工作都是通过Coordinator上的StatementResource类提供的RESTful服务来完成的。</p>\n<p>2.Worker<br>在一个Prestor集群中，存在一个Coordinator节点和多个Worker节点。Coordinator节点是管理节点，而Worker节点就是工作节点。在每个Worker节点上都会存在一个Worker服务进程，该服务进程主要进行数据的处理以及Task的执行。Worker服务进程每隔一定的时间都会向Coordinator上的RESTful服务发关心跳，从而告知Coordinator：我还活着，并接收你的调度。当客户端提交一个查询的时候，Coordinator则会从当前存活的Worker列表中选择出合适的Worker节点去运行Task。而Worker在执行每个Task的时候又会进一步对当前Task读入的每个Spli进行一系列的操作和处理。</p>\n<h3 id=\"Presto模型\"><a href=\"#Presto模型\" class=\"headerlink\" title=\"Presto模型\"></a>Presto模型</h3><p>Presto可以通过多种不同类型的Connector访问多种数据源，目前支持的Connector包括：Hive、JMX、MySQL、Cassandra、PostgreSQL以及Kafka。下面介绍Presto是如何访问不同类型的数据源的，并对Presto中的模型和概念进行描述。</p>\n<p>1.Connector<br>Presto是通过多种多样的Connector来访问多种不同的数据源的。你可以将Connector当作Presto访问各种不同数据源的驱动程序。一般情况下，Presto针对每种数据源都有与之对应的Connector。每种Connector都实现了Presto中标准的SPI接口，因此只要你实现Presto中的标准的SPI接口，就可以轻易地实现使用适合自己特定需求的Connector来访问特定的数据源。Presto目前支持的Connector 有Hive、JMX、MySQL、Cassandra、PostgreSQL等，都有其对应的Build-In Connector(内置的Connector)。<br>当你需要使用某种Connector访问特定的数据源时，需要在$PRESTO_HOME/etc/catalog、中创建一个配置文件：example.properties）（文件名字限制，但是其后缀名必须为.properties），在该配置文件中必须要设置一个属性:connector.name，该属性是必须设置的。Presto中Connector Manager就是通过该配置属性来决定使用哪个Connector去访问相应的数据源的。例如，你现在需要访问一个hive数据源，那么你在配置文件中就需要将属性connect.name设置为Hive-cdh5或者Hive-cdh4，这样Presto就会使用内置的Hive connector去访问Hive数据仓库中相应的数据。</p>\n<p>2.Catalog<br>Presto中的Catalog类型于Mysql中的数据库实例。而Schema就类似于Mysql中的一个Database。通过使用特定的Connector访问Catalog中指定的数据源，一个Catalog中可以包含多个Schema。那么怎么定义一个Catalog呢？其实你不需要特意去指定Catalog。正如之前说的，假设你想访问Hive中的数据，则需要在$PRESTO_HOME/etc/catalog中创建一个配置文件：example.properties。该配置文件中定义了诸如Hive store的URI等访问Hive中的数据所需要的所有配置项，并且配置文件的名字就是Catalog名字:example。从这里可以看出Presto中配置文件的名字（不带.properties）就是Catalog的名字。<br>当你访问Catalog中的某个表时，该表的全名总是以Catalog的名字开始。例如名字为example.schema1.tables1的表，指的是表table1位于名为schema1的schema中，而schema1又位于名为example的Catalog中。</p>\n<p>3.Schema<br>Presto中的Schema就类似于Mysql中的Database。一个Catalog名称和一个Schema名称唯一确定了可以查询的一系列表的集合。当通过Presto去查询Hive或者Mysql中的数据时，你会发现Presto中的Schema与Hive或者Mysql中的Database是相对应的。</p>\n<p>4.Table<br>Presto中的Table与传统数据库中的Table的含义是一样的。</p>\n<h3 id=\"Preto查询执行模型\"><a href=\"#Preto查询执行模型\" class=\"headerlink\" title=\"Preto查询执行模型\"></a>Preto查询执行模型</h3><p>Preto在执行SQL语句时，将这些SQL语句解析为相应的查询，并在分布式集群中执行这些查询。</p>\n<p>1.Statement<br>Statement语句。其实就是指我们输入的SQL语句。Presto支持需要ANSI标准的SQL语句。这种语句由子句(Clause)、表达式（Expression）和断言(Predicate)组成。</p>\n<p>Presto为什么将语句(Statement)和查询(Query)的概念分开呢？<br>因为在Presto中，语句和查询本身就是不同的概念。语句指的是终端用户输入的用文字表示的SQL语句；当Presto执行输入的SQL语句时，会根据SQL语句生成查询执行计划，进而生成可以执行的查询(Query)，而查询代表的是分布到所有的Worker之间执行的实际查询操作。</p>\n<p>2.Query<br>Query即查询执行。当Presto接收一个SQL语句并执行时，会解析该SQL语句，将其转变成一个查询执行和相关的查询执行计划。一个查询执行代表可以在Presto集群中运行的查询，是由运行在各个Worker上且各自之间相互关联的阶段（Stage）组成的。</p>\n<p>那么SQL语句与查询执行之间有什么不同呢？<br>其实很简单，你可以认为SQL语句就是提交给Presto的用文字表示的SQL执行语句。而查询执行则是为了完成SQL语句所表述的查询而实例化的配置信息、组件、查询执行计划和优化信息等。一个查询执行由Stage、Task、Driver、Split、Operator和DataSource组成。这些组件之间通过内部联系共同组成了一个查询执行，从而得到SQL语句表述的查询，并得到相应的结果集。</p>\n<p>3.Stage<br>Stage即查询执行阶段。当Presto运行Query时，Presto会将一个Query拆分成具有层级关系的多个Stage，一个Stage就代表查询执计划的一部分。例如，当我们执行一个查询，从Hive的一张具有1亿条记录的表中查询数据并进行聚合操作时，Presto会创建一个Root Stage（后面会介绍，该Stage就是Single Stage），该Stage聚合其上游Stage的输出数据，然后将结果输出给Coordinator，并由Coordinator将结果输出给终端用户。<br>通常情况下Stage之间是树状的层次结构。每个Query都有一个Root Stage。该Stage用于聚集所有其他Stage的输出数据，并将最终的数据反馈给终端用户。需要注意的是，Stage并不会在集群中实际执行，它只是Coordinator用于对查询计划进行管理和建模的逻辑概念。每个Stage（除了Single Stage和Source Stage）都会有输入和输出，都会从上游Stage读取数据，然后将产生结果输出给下游Stage。需要注意的是；Source Stage没有上游，它从Connector获取数据，Single Stage没有下游，它的结果直接输出给Coordinator，它由Coordinator输出给终端用户。<br>Presto中的Stage共有4种，具体介绍如下：<br>Coordinator_Only：这种类型的Stage用于执行DDL或者DML语句中最终的表结构创建或者更改。<br>Single：这种类型的Stage用于聚合子Stage的输出，并将结果数据输出给终端用户。<br>Fixed：这种类型的Stage用于接受其子Stage产生的数据并在集群中对这些数据进行分布式的聚合或者分组计算。<br>Source：这种类型的Stage用于直接连接数据源，从数据源读取数据，在读取数据的同时，该阶段也会根据Presto对查询执行计划的优化完成相关的断言下发(Predicate PushDown)<br>和条件过滤等。</p>\n<p>说明：一个SQL查询可以被分解 多个前后关联的Stage,在这里我们约定：按照数据的流向，越靠近数据源的Stage越处于上游，越远离数据源的Stage越处于下游。</p>\n<p>4.Exchange<br>Exchange的字面意思就是“交换”。Presto的Stage是通过Exchange来连接另一个Stage的。Exchange用于完成有上下游关系的Stage之间的数据交换。在Presto中有两种Exchange：Output Buffer和Exchange Client。生产数据的Stage通过名为Output Buffer的Exchange将数据传送给其下游的Stage。消费数据的Stage通过名为Exchange从上游Stage读取数据。<br>如果当前Stage是Surce类型的Stage，那么该Stage则是直接通过相应的Connector从数据源读取数据的。而该Stage则是通过名为Source Operator的Operator与Connector进行交互的，例如，一个Source Stage直接从HDFS获取数据，那么这种操作不是通过Exchange Client来完成的，而是通过运行于Driver中的Source Operator来完成的。</p>\n<p>5.Task<br>从前面的介绍中可以知道，Stage并不会在Presto集群中实际运行，它仅代表针对于一个SQL语句查询执行计划中的一部分查询的执行过程，只是用来对查询执行计划进行管理和建模。Stage在逻辑上又被分为一系列的Task，这些Task则是需要实际运行在Presto的各个Worker节点上的。<br>在Presto集群中，一个查询执行被分解成具有层次关系的一系列的Stage，一个Stage又被拆分为一系列的Task。每个Task处理一个或者多个Split。每个Task都有对应的输入和输入。一个Stage被分解为多个Task，从而可以并行地执行一个Stage。Task也采用了相应的机制：一个Task也可以被分解为一个或者多个Driver，从而并行地执行一个Task。</p>\n<p>6.Driver<br>一个Task包含一个或者多个Driver。一个Driver其实就是作用于一个Split的一系列Operator的集合。因此一个Driver用于处理一个Split，并且生成相应的输出，这些输出由Task收集并且传送给下游Stage中的Task。一个Driver拥有一个输入和一个输出。</p>\n<p>7.Operator<br>一个Operator代表对一个Spit的一种操作，例如过滤、加权、转换等。一个Operator依次读取一个Split中的数据，将Operator所代表的计算和操作作用于Split的数据上，并产生输出。每个Operator均会以Page为最小处理单元分别读取输入数据和产生输出数据。Operator每次只会读取一个Page对象，相应地，每次也只会产生一个Page对象。</p>\n<p>8.Split<br>Split即分片，一个分片其实就是一个大的数据集中的一个小的子集。而Driver则是作用于一个分片上的一系列操作的集合，而每个节点上运行的Task，又包含多个Driver,从而一个Task可以处理多个Split。其中每一种操作均由一个Operator表示。分布式查询执行计划的源Stage(Source Stage)通过Connector从数据源获取多个分片。Source Stage对Split处理完毕之后，会将输出传递给其下游Stage（通常其下游Stage的类型为Fixed或者Single）。<br>当Presto执行一个查询的时候，首先会从Coordinator得到一个表对应的所有Split。然后Presto就会根据查询执行计划，选择合适的节点运行相应的Task处理Split。</p>\n<p>9.Page<br>Page是Presto中处理的最小数据单元。一个Page对象包含多个Block对象，而每个Block对象是一个字节数组，存储一个字段的若干行。多个Block横切的一行是真实的一行数据。一个Page最大为1MB，最多16*1024行数据。</p>\n<h2 id=\"安装与部署\"><a href=\"#安装与部署\" class=\"headerlink\" title=\"安装与部署\"></a>安装与部署</h2><p>Presto目前只能部署在Linux中。以集群模式部署进行说明 。</p>\n<h3 id=\"环境说明\"><a href=\"#环境说明\" class=\"headerlink\" title=\"环境说明\"></a>环境说明</h3><p>需要3台服务器，1台作为Coordinator，2台作为Worker。</p>\n<h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><h4 id=\"建立SSH\"><a href=\"#建立SSH\" class=\"headerlink\" title=\"建立SSH\"></a>建立SSH</h4><p>Coordinator到各个Worker节点的ssh信任关系，以方便后续的Presto集群的管理和维护。</p>\n<h4 id=\"Hive\"><a href=\"#Hive\" class=\"headerlink\" title=\"Hive\"></a>Hive</h4><p>默认hive已经创建好。如果没有可自行安装。</p>\n<h4 id=\"源码编译\"><a href=\"#源码编译\" class=\"headerlink\" title=\"源码编译\"></a>源码编译</h4><p>下载官方编译好的安装包：<a href=\"https://github.com/prestodb/presto/archive/0.107.tar.gz。\" target=\"_blank\" rel=\"noopener\">https://github.com/prestodb/presto/archive/0.107.tar.gz。</a><br>执行mvn -T2C install -DskipTests<br>-T2C:说明一个CPU核心启动两个线程进行编译，可以加快源码编译的速度。<br>install：将编译完成的Jar包直接安装到Maven库中。<br>-DskipTests：跳过测试工程和测试类。</p>\n<h4 id=\"服务部署\"><a href=\"#服务部署\" class=\"headerlink\" title=\"服务部署\"></a>服务部署</h4><p>首先将二进制压缩包同步到各个节点上并解压，然后在各个节点上修改相应的配置项，最后启动Presto集群。</p>\n<h5 id=\"修改配置\"><a href=\"#修改配置\" class=\"headerlink\" title=\"修改配置\"></a>修改配置</h5><p>（1）config.properties</p>\n<p>（2） jvm.config</p>\n<p>（3）log.properties</p>\n<p>（4）node.properties</p>\n<h3 id=\"启动和停止服务\"><a href=\"#启动和停止服务\" class=\"headerlink\" title=\"启动和停止服务\"></a>启动和停止服务</h3><p>sh /opt/presto/presto-server/bin/launcher start<br>sh /opt/presto/presto-server/bin/launcher stop</p>\n<h3 id=\"查询\"><a href=\"#查询\" class=\"headerlink\" title=\"查询\"></a>查询</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package com.jd.PrestoJDBCClient;</span><br><span class=\"line\"></span><br><span class=\"line\">import com.facebook.presto.jdbc.PrestoConnection;</span><br><span class=\"line\">import com.facebook.presto.jdbc.PrestoStatement;</span><br><span class=\"line\"></span><br><span class=\"line\">import java.sql.DriverManager;</span><br><span class=\"line\">import java.sql.ResultSet;</span><br><span class=\"line\">import java.sql.SQLException;</span><br><span class=\"line\">import java.util.TimeZone;</span><br><span class=\"line\"></span><br><span class=\"line\">public class PrestoJDBCTestClient &#123;</span><br><span class=\"line\">    public static void printRow(ResultSet rs, int[] types) throws SQLException &#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; types.length; i++) &#123;</span><br><span class=\"line\">            System.out.print(&quot; &quot;);</span><br><span class=\"line\">            System.out.print(rs.getObject(i + 1));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(&quot;&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void connect() throws SQLException &#123;</span><br><span class=\"line\">        //设置时区，这里必须设置</span><br><span class=\"line\">        TimeZone.setDefault(TimeZone.getTimeZone(&quot;Asia/Shanghai&quot;));</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            //加载Presto JDBC驱动类</span><br><span class=\"line\">            Class.forName(&quot;com.facebook.presto.jdbc.PrestoDriver&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        PrestoConnection connection = null;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            //Presto连接串，在连接串中指定了默认的catalog为：system,默认的schema为:runtime，使用的用户名为：guest1，这个用户名根据实际业务自己设定，用来标识执行SQL的用户，虽然不会通过用户名进行身份认证，但是必须要写。密码直接指定为null，或者可以随便指定一个做生意密码，Presto是不会对密码进行验证的。</span><br><span class=\"line\">            connection = (PrestoConnection) DriverManager.getConnection(&quot;jdbc:presto://172.16.154.38:8001/system/runtime&quot;, &quot;guest1&quot;, null);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; catch (SQLException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        PrestoStatement statement = null;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            statement = (PrestoStatement) connection.createStatement();</span><br><span class=\"line\">        &#125; catch (SQLException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        String query = &quot;select * from nodes&quot;;</span><br><span class=\"line\">        ResultSet rs = null;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            rs = statement.executeQuery(query);</span><br><span class=\"line\">        &#125; catch (SQLException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        int cn = rs.getMetaData().getColumnCount();</span><br><span class=\"line\">        int[] types = new int[cn];</span><br><span class=\"line\">        for (int i = 1; i &lt; cn; i++) &#123;</span><br><span class=\"line\">            types[i - 1] = rs.getMetaData().getColumnType(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            while (rs.next()) &#123;</span><br><span class=\"line\">                printRow(rs, types);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; catch (SQLException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public static void main(String[] args) throws ClassNotFoundException, SQLException &#123;</span><br><span class=\"line\">        connect();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p>《Presto技术内幕》由京东研发团队出版。</p>\n<p>中文社区：<a href=\"http://prestodb-china.com/\" target=\"_blank\" rel=\"noopener\">http://prestodb-china.com/</a><br>Presto 官网： <a href=\"http://prestodb.io/\" target=\"_blank\" rel=\"noopener\">http://prestodb.io/</a><br>Presto Github 主页： <a href=\"https://github.com/facebook/presto\" target=\"_blank\" rel=\"noopener\">https://github.com/facebook/presto</a><br>京东修改版（推荐）： <a href=\"https://github.com/CHINA-JD/presto\" target=\"_blank\" rel=\"noopener\">https://github.com/CHINA-JD/presto</a><br>Presto 文档： <a href=\"http://prestodb-china.com/docs/current/\" target=\"_blank\" rel=\"noopener\">http://prestodb-china.com/docs/current/</a></p>\n"},{"title":"emacs入门","date":"2017-05-04T08:00:00.000Z","_content":"#入门实践\n\n\n","source":"_posts/tools/emacs/TODO-emacs入门.md","raw":"---\ntitle: emacs入门\ndate: 2017-05-04 16:00:00\ntags: [tools.emacs]\ncategories: [tools,emacs]\n---\n#入门实践\n\n\n","slug":"tools/emacs/TODO-emacs入门","published":1,"updated":"2017-08-18T01:44:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bow00aps77rq879jtqx","content":"<p>#入门实践</p>\n","site":{"data":{}},"excerpt":"","more":"<p>#入门实践</p>\n"},{"title":"vim入门实践","date":"2017-05-04T08:00:00.000Z","_content":"#入门实践\n\n\n","source":"_posts/tools/vim/TODO-vim入门实践.md","raw":"---\ntitle: vim入门实践\ndate: 2017-05-04 16:00:00\ntags: [tools.vim]\ncategories: [tools,vim]\n---\n#入门实践\n\n\n","slug":"tools/vim/TODO-vim入门实践","published":1,"updated":"2017-08-18T01:44:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3boz00ats77r26vmy9le","content":"<p>#入门实践</p>\n","site":{"data":{}},"excerpt":"","more":"<p>#入门实践</p>\n"},{"title":"angular.js入门之HelloWorld","date":"2017-04-27T07:00:00.000Z","_content":"\n\n\n","source":"_posts/前端/angular.js/TODO-angular.js入门之HelloWorld.md","raw":"---\ntitle: angular.js入门之HelloWorld\ndate: 2017-04-27 15:00:00\ntags: [angular.js]\ncategories: [前端,angular.js]\n---\n\n\n\n","slug":"前端/angular.js/TODO-angular.js入门之HelloWorld","published":1,"updated":"2017-08-18T01:44:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bp100avs77r3251nccy","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"react.js入门之HelloWorld","date":"2017-04-27T07:00:00.000Z","_content":"\n\n\n","source":"_posts/前端/react.js/TODO-react.js入门之HelloWorld.md","raw":"---\ntitle: react.js入门之HelloWorld\ndate: 2017-04-27 15:00:00\ntags: [react.js]\ncategories: [前端,react.js]\n---\n\n\n\n","slug":"前端/react.js/TODO-react.js入门之HelloWorld","published":1,"updated":"2017-08-18T01:44:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bp200axs77rd2uwwwa1","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"vue.js入门之HelloWorld","date":"2017-04-27T07:00:00.000Z","_content":"\n\n\n","source":"_posts/前端/vue.js/TODO-vue.js入门之HelloWorld.md","raw":"---\ntitle: vue.js入门之HelloWorld\ndate: 2017-04-27 15:00:00\ntags: [angular.js]\ncategories: [前端,angular.js]\n---\n\n\n\n","slug":"前端/vue.js/TODO-vue.js入门之HelloWorld","published":1,"updated":"2017-08-18T01:44:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bp500b1s77rmvb6z1hi","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Kylin入门概念","date":"2017-04-16T15:43:49.000Z","_content":"\n#Apache Kylin的工作原理\nApache Kylin的工作原理本质上是MOLAP（Multidimensional　Online　Analytical　Processing）Cube，也就是多维　立方体分析。这是数据分析中相当经典的理论，在关系数据库年代就已经有了广泛的应用，下面将其做简要的介绍。  \n\n##维度和度量\n简单来讲，维度就是观察数据的角度。比如电商的销售数据，可以从时间的维度来观察，也可以进一步细化，从时间和地区的维度来观察。维度一般是一组离散的值，比如时间维度上的每一个独立的日期，或者商品维度上的每一件独立的商品。因此统计时可以把维度值 相同的记录聚合在一起，然后应用聚合函数做累加、平均、去重计数等聚合计算。  ![\"维度和度量的例子\"](/images/hadoop/kylin/维度和度量的例子.jpg)\n    \n度量就是被聚合的统计值，也是聚合运算的结果，它一般是连续的值，如图1-2中的销售额，抑或是销售商品的总件数据 。通过比较和测量试题，分析师可以对数据进行评估，比如今年的销售额相比去年有多大的增长，增长的速度是否达到预期，不同商品类别的增长比例是否合理等。  \n\n##Cube和Cuboid\n有了维度和度量，一个数据表或数据模型上的所有字段就可以分类了，它们要么是维度，要么是度量（可以被聚合）。于是就有了根据维度和度量来做预计算的Cube理论。  \n给定一个数据模型，我们可以对其上的所有维度进行组合。对于N个维度来说，组合的所有可能共2的n次方种。对于每一种维度的组合，将度量做聚合运算，然后将运算的结果保存为一个物化视图，称为Cuboid。所有维度组合的Coboid作为一个整体，被称为Cube。所以简单来说一个Cube就是许多按维度聚合的物化视图的集合。  \n下面来举一个具体的例子。假定有一个电商的销售数据集，其中维度包括时间（Time）、商品（Item）、地点（Location）和供应商（Supplier），度量为销售额（GMV）。那么所有维度的组合就有2的4次方=16种，比如一维度（ID）的组合有[Time]、[Item]、[Location]、[Supplier]4种；二维度（3D）的组合有[Time,Item]、[Time，Location]、[Time,Supplier]、[Item,Location]、[Item,Supplier]、[Location,Supplier]6种；三维度（3D）的组合也有4种；最后零维度（0D）和四维度（4D）的组合各有1种，总共有16种组合。\n![\"一个四维Cube的例子\"](/images/hadoop/kylin/一个四维Cube的例子.jpg)\n\t\t\n计算Cuboid，即按维度来聚合销售额。如果用SQL语句来表达计算Cuboid[Time,Location]，那么SQL语句如下：  \nSelect Time,Location,Sum(GMV) as GMV from Sales group by Time,Location.  \n将计算的结果保存为物化视图，所有Cuboid物化视图的总称是Cube。\n\n##工作原理\nApache Kylin的工作原理就是对数据模型做Cube预计算，并利用计算的结果加速查询，具体工作过程如下：\n1）指定数据模型，定义维度和度量\n2）预计算Cube，计算所有Cuboid并保存为物化视图。\n3）执行查询时，读取Cuboid，运算，产生查询结果。\n由于Kylin的查询过程不会扫描原始记录，而是通过预计算预先完成表的关联、聚合等复杂运算，并利用预计算的结果来执行查询，因此相比非预计算的查询技术，其速度一般要快一到两个数据级，并且这点在超磊的数据集上优势更加明显。当数据集达到千亿及至万亿级别时，Kylin的速度甚至可以超越其他非预计算技术1000倍以上。\n\n#技术架构\nApache Kylin系统可以分为在线查询和离线构建两部分，技术架构如下图所示，在线查询的模块主要处于上半区，而离线构建则处于下半区。\n![\"Kylin的技术架构\"](/images/hadoop/kylin/Kylin的技术架构.jpg)\t\n\n我们首先看看离线构建的部分。从图1-4可以看出，数据源在左侧，目前主要是Hadoop Hive，保存着待分析的用户数据。根据元数据的字义，下方构建引擎从数据源抽取数据，并构建Cube。数据以关系表的形式输入，且必须符合星形模型（Star Schema）（更复杂的雪花模型在成文时还不支持，可以通过视图将雪花模型转化为星形模型，再使用Kylin）。MapRecue是当前主要的构建技术。构建后的Cube保存在右侧的存储引擎中，一般选用HBase作为存储。  \n完成了离线构建之后，用户可以从上方查询系统发送SQL进行查询分析。Kylin提供了各种Rest　API、ＪＤＢＣ／ＯＤＢＣ接口。无论从哪个接口进入，SQL最终都会来到Rest服务层，再转交给查询引擎进行处理。这里需要注意的是，SQL语句是基于数据源的关系模型书写的，而不是Cube。Kylin在设计时刻意对查询用户屏蔽了Cube的概念，分析师只需要理解简单的关系模型就可以使用Kylin，没有额外的学习门槛，传统的SQL应用也很容易迁移。查询引擎解析SQL，生成基于关系表的逻辑执行计划，然后将其转义为基于Cube的物理执行计划，最后查询预计算生成的Cube并产生结果。整个过程不会访问原始数据源。  \n\n\n**注意**：对于查询引擎下方的路由选择，在最初设计时曾考虑过将Kylin不能执行查询引导去Hive中继续执行，但在实践后发现Hive与Kylin的速度差异过大，导致用户无法对查询的速度有一致的期望，很可能大多数据查询几秒内就返回结果了，而有些查询则要等几分钟到几十分钟，因此体验非常糟糕。最后这个路由功能在发行版中默认关闭。\n\n\nApache Kylin 1.5版本引入了“可扩展架构”的概念。在图1-4中显示为三个粗虚框，表示的抽象层。可扩展指Kylin可以对其主要依赖的三个模块做任意的扩展和替换。Kylin的三大依赖模型分别是数据源、构建引擎和存储引擎。在设计之初，作为Hadoop家族 一员，这三者分别是Hive、MapRecue和HBase。但随着推广和使用的深入，渐渐有用户发现它们均存在不足之处。比如，实时分析可能会希望从Kafka导入数据而不是Hive；而Spark的迅速崛起，又使我们不得不考虑将MapRecue替换为Spark，以期大幅提高Cube的构建速度；至于HBase，它的读性能可能还不如Cassandra或Kudu等 。可见，是否可以将一种技术替换为另一种技术已成为一个常见的问题。于在1.5版本的系统架构进行了重构，将数据源、构建引擎、存储引擎三大依赖抽象为接口，而Hive、MapRecue、HBase只是默认实现。深度用户可以根据自己的需要做二次开发，将其中的一个或多个替换为更适合的技术。  \n\n#核心概念\n##数据仓库\n数据仓库（Data Warehouse）是一种系统的资料储存理论，此理论强调的是利用某些特殊的资料储存方式，让所包含的资料特别有利于分析和处理，从而产生有价值的资讯，并可依此做出决策。\n利用数据仓库的方式存放资料，具有一旦存入，便不会随时间发生变动的特性，此外，存入的资料必定包含时间属性，通常一个数据仓库中会含有大量的历史性资料，并且它可利用特定的分析方式，从其中发掘特定的资讯。\n\n##OLAP\nOLAP（Online Analytical Process），联机分析处理，以多维度的方式分析数据，而且能够弹性地提供上卷（Roll-up）、下钻（Drill-down）和透视分析（Pivot）等操作，它呈现集成性决策信息的方法，多用于决策支持系统、商务智能或数据仓库。其主要的功能在于方便大规模数据分析及统计计算，可对决策提供参考和支持。与之相区别的是取机交易处理（OLTP），联机交易处理，更侧重于基本的、日常的事务处理，包括数据的增删改查。\nOLAP需要以大量历史数据为基础，再配合时间点的差异，对多维度及汇整型的信息进行复杂的分析。\nOLAP需要用户有主观的信息需求定义，因此系统效率较佳。\nOLAP的概念，在实际应用中存在广义和狭义两种不同的理解方式。广义上的理解与字面上的意义相同，泛指一切不会对数据进行更新的分析处理。但更多的情况下OLAP被理解为其狭义上的含义，即与多维分析相关，基于立方体（Cube）计算而进行的分析。\n\n##BI\nBI（Business Intelligence），即商务智能，指现代数据仓库技术、在线分析技术、数据挖掘和数据展现技术进行数据分析以实现商业价值。\n\n\n##维度和度量\n维度和度量是数据分析中的两个基本的概念\n**维度**是指审视数据的角度，它通常是数据记录的一个属性，例如时间、地点等。  \n**度量**是基于数据所计算出来的考量值；它通常是一个数值，如总销售额、不同的用户数等。分析人员往往要结合若干个维度来审查度量值，以便在其中找到变化规律。在一个SQL查询中，Group By的属性通常就是维度，而所计算的值则是度量。如下面的示例：  \n    select part_dt,lstg_iste_id,sum(price) as total_selled,count(distinct seller_id) as sellers from kylin_sales group by part_dt,lstg_site_id\n\n##事实表和维度表\n**事实表**（Fact Table）是指存储有事实记录的表，如系统日志、销售记录等；事实表的记录在不断地动态增长，所以它的体积通常远大于其他表。\n\n**维度表**（Dimension Table）或维表，有时也称查找表（Lookup Table），是与事实表相对应的一种表；它保存了维度的属性值，可以跟事实表做关联；相当于将事实表上经常重复出现的属性抽取、规范出来用一张表进行管理。常见的维度表有：日期表（存储与日期对应的周、月、季度等属性）、地点表（包含国家、省、城市等属性）。使用维度表有诸多好处，具体如下：\na.缩小了事实表的大小\nb.便于维度的管理和维护，增加、删除和修改维度的属性，不必对事实表的大量记录进行改动。\nc.维度表可以为多个事实表重用，以减少重复工作。\n\n##Cube、Cuboid和Cube Segment\n###Cube\nCube（或Data Cube），即数据立方体，是一种常用于数据分析与索引的技术；它可以对原始数据建立多维度索引。通过Cube对数据进行分析，可以大大加快数据的查询效率。\n\n###Cuboid\nCuboid在Kylin中特指在某一种维度组合下所计算的数据。\n\n##Cube Segment\nCube Segment是指针对源数据中的某一片段，计算出来的Cube数据。通常数据仓库中的数据数量会随着时间的增长而增长，而Cube Segment也是按时间顺序来构建的。\n\n\n\n#在Hive中准备数据\n这里介绍准备Hive数据的一些注意事项。需要被分析的数据必须先保存为Hive表的形式，然后Kylin才能从Hive中导入数据，创建Cube。\nHive是一个基于Hadoop的数据仓库工具，可以将结构化的数据文件映射为数据库表，并可以将SQL语句转换为MapRecue或Tez任务进行运行，从而让用户以类SQL（HiveQL，也称HQL）的方式管理和查询Hadoop上的海量数据。\n此外，Hive还提供了多种方式（如命令行、API和Web服务等）可供第三方方便地获取和使用元数据并进行查询。今天，Hive已经成为Hadoop数据仓库的首选，是Hadoop上不可或缺的一个重要组件，很多项目都已兼容或集成了Hive。基于此情况，Kylin选择Hive作为原始数据的主要来源。\n在Hive中准备待分析的数据是使用Kylin的前提；将数据导入到Hive表中的方法有很多，用户管理数据的技术和工具也各式各样，因此具体步骤不在本书的讨论范围之内。\n\n##星形模型\n数据挖掘有几种常见的多维数据模型，如星形模型（Star Schema）、雪花模型（Snowf lake Schema）、事实星座模型（Fact Constellation）等。  \n星形模型中有一张事实表，以及零个或多个维度表；事实表与维度表通过主键外键相关联，维度表之间没有关联，就像很多星星围绕在一个恒星周围，帮取名为星形模型。\n如果将星形模型中某些维度的表再做规范，抽取成更细的维度表，然后让维度表之间也进行关联，那么这种模型称为雪花模型。\n星形模型是更复杂的模型，其中包含了多个事实表，而维度表是公用的，可以共享。\n不过，Kylin只支持星形模型的数据集，这是基于以下考虑的。  \n\n- 星形模型是最简单，也是最常用的模型  \n- 由于星形模型只有一张大表，因此它相比于其它模型更适合于大数据处理  \n- 其他模型可以通过一定的转换，变成星形模型。  \n\n##维度表的设计\n除了数据模型以外，Kylin还对维度表有一定的要求，具体要求如下。  \n\n\n- 要具有数据一致性，主键值必须是唯一的；Kylin会进行检查，如果有两行的主键值相同则会报错。\n- 维度越小越好，因为Kylin会将维度表加载到内存中供查询；过大的表不适合作为维度表，默认的阈值是300MB。  \n- 改变频率低，Kylin会在每次构建中试图重用维度表的快照，如果维度表经常改变的话，重用就会失效，这就会导致要经常对维度表创建快照。\n- 维度表最好不要是Hive视图（View），虽然在Kylin1.5.3中加入了对维度表是视图这种情况的支持，但每次都需要将视图进行物化，从而导致额外的时间开销。\n\n##Hive表分区\nHive支持多分区（Partition）。简单来说，一个分区就是一个文件目录，存储了特定的数据文件。当有新的数据生成的时候，可以将数据加载到指定的分区，读取数据的时候也可以指定分区。对于 SQL查询，如果查询中指定了分区列的属性条件，则Hive会智能地选择特定分区（也就是目录），从而避免全量数据的扫描，减少读写操作对集群的压力。\n下面举的一组SQL演示了如何使用分区：  \n\nHie>create table invites(id int,name string) partitioned by(ds string) row format delimited fields terminated by 't' stroed as textfile;  \nHive>load data local inpath '/user/hadoop/data.txt' overwrite into table invites partition (ds='2016-08-16');  \nHive>select * from invites where ds = '2016-08-16';  \nKylin支持增量的Cube构建，通常是按时间属性来增量地从Hive表中抽取数据。如果Hive表正好是按此时间属性做分区的话，那么就可以利用到Hive分区的好处，每次在Hive构建的时候都可以直接跳过不相干的日期的数据，节省Cube构建的时间。这样的列在Kylin里也称为分割时间列（Partition Time Column），通常它应该也是Hive表的分区列。\n\n\n##了解维度的基数\n维度的基数（Cardinality）指的是该维度在数据集中出现的不同值的个数；例如“国家”是一个维度，如果有200个不同的值，那么此维度的基数就是200.通常一个维度的基数会从几十到几万个不等，个别维度如“用户ID”的基数会超过百万甚至千万。基数超过一百万的维度通常称为超高维度（Ulta Hight Cardinality，UHC），需要引起设计者的注意。  \nCube中所有维度的基数都可以体现Cube的复杂度，如果一个Cube中有好几个超高基数维度，那么这个Cube膨胀就会很高。在创建Cube前需要对所有维度的基数做一个了解，这样就可以帮助设计合理的Cube。计算基数有多种途径，最简单的方法就是让Hive执行一个count distinct的SQL查询；Kylin也提供计算基数的方法，在导入Hive表定义后可以看到每一个列的基数，参数名为Cardinality\n\n##Sample Data\n如果需要快速体验Kylin，可以用Kylin自带的Sample Data。运行${KYLIN_HOME}/bin/sample.sh来导入Sample Data，然后就能按照下面的流程来创建模型和Cube。  \n具体请执行下面命令，将Sample Data导入到Hive数据库。  \ncd ${KYLIN_HOME}  \nbin/sample.sh  \nSample Data测试的样例数据集总共仅1M左右，共计3张表，其中事实表有10000条数据。数据集是一个规范的星形模型结构，它总包含3个数据表：    \nKYLIN_SALES是事实表，保存了销售订单的明细信息。各列分别保存着卖家、商品、分类、订单金额、商品数据等信息，每一行对应着一笔交易订单。  \nKYLIN_CATEGORY_GROUPINGS是维表，保存了商品分类的详细介绍，例如商品分类名称等。  \nKYLIN_CAL_DT也是维表，保存了时间的扩展信息。如单个日期所在的年始、月始、周始、年份、月份等。  \n这3张表一起构成了整个星形模型。  \n\n#设计Cube\n如果数据已经在Hive中准备好了，就可以开始创建Cube了。\n##导入Hive表定义\n登陆Kylin的Web界面，创建新的或选择一个已有的项目之后，需要做的就是将Hive表的定义导入到Kylin中。  \n单击Web界面的Model->Data Source下的”Local Hive Table“图标，然后输入表的名称（可以一次导入多个表，以逗号分隔表名），单击按钮”Sync“，Kylin就会使用Hive的API从Hive中获取表的属性信息。  \n导入成功后，表的结构信息会以树状的形式显示在页面的左侧，可以单击展开或收缩。\n\n同时Kylin会在后台触发一个MapRecue任务，计算此表的每个列的基数。通常稍过几分钟后再刷新页面，就会看到显示出来 的基数信息Cardinality\n\n需要注意的是，这里Kylin对基数的计算方法采用的是HyperLogLog的近似算法，与精确值略有误差，只做参考值。\n\n##创建数据模型\n有了表信息之后，就可以开始创建数据模型（Data Model）了。数据模型是Cube的基础，它主要用于描述一个星形模型。有了数据模型以后，定义Cube的时候就可以直接从此模型定义的表和列中进行选择了，省去重复指定连接（join）条件的步骤。基于一个数据模型还可以创建多个Cube，以方便减少用户的重复性工作。  \n在Kylin界面中”Models“页面中单击”New\"->\"New Model\"，开始创建数据模型。\n\n\n接下来选择用作维度和度量的列。这里只是选择一个范围，不代表这些列将来一定要用作Cube 的维度或度量，你可以把所有可能会用到表都选进来，后续创建Cube的时候，将只能从这些列中进行选择。   \n\n选择维度列时，维度可以来自事实表或维度表  \n选择度量列时，度量只能来自事实表  \n最后一步，是为模型补充侵害时间列信息和过滤条件。如果此模型中的事实表记录是按时间增长的，那么可以指定一个日期/时间列作为模型的分割时间列，从而可以让Cube按此列做增量构建。\n\n过滤（Filter）条件是指，如果想把一些记录忽略掉，那么这里可以设置一个过滤条件。Kylin在向Hive请求源数据的时候，会带上此过滤条件。\n\n随后“Save”后，出现在“Model”的列表中。\n\n\n##创建Cube\n单击“New”，选择“New Cube”，会开启一个包含若干步骤的向导。\n\n第一页，选择要使用的数据模型，并为此Cube输入一个唯一的名称（必需的）和描述（可选的）；这里还可以输入一个邮件通知列表，用于在构建完成或出错时收到通知。如果不想接收处于某些状态的通知，那么可以从“Notification Events”中将其去掉。\n\n第二页，选择Cube的维度。可以通过以下两个按钮来添加维度。   \n**“Add Mimension”**：逐个添加维度，可以是普通维度也可以是衍生（Derived）维度。\n**“Auto Generator”：**批量选择并添加，让Kylin自动完成其它信息。  \n使用第一种方法的时候需要为每个维度起个名字，然后选择表和列。  \n如果是衍生维度的话，则必须是来自于某个维度表，一次可以选择多个列；由于这些列值都可以从该维度表的主键值中衍生出来，所以实际上只有主键列会被Cube加入计算。而在Kylin 的具体实现中，往往采用事实表上的外键替代主键进行计算和存储。但是在逻辑上可以认为衍生列来自于维度表的主键。  \n使用第二种方法，Kylin会用一个树状结构呈现出所有的列，用户只需要勾选所需要的列即可，Kylin会自动补充其他信息，从而方便用户的操作。请注意，在这里Kylin会把维度表上的列都创建成衍生维度，这也许不是最合适的，在这种情况下请使用第一种方法。\n\n\n第三页，创建度量。Kylin默认会创建一个Count(1)的度量。可以单击“+Measure\"按钮来添加新度量。Kylin支持的度量有：SUM、MIN、MAX、COUNT、COUNT　DISTINCT、ＴＯＰ＿Ｎ、RAW等。请选择需要的度量类型，然后再选择适当的参数（通常为列名）\n\n重复上面的步骤，创建所需要的度量。Kylin可以支持在一个Cube中添加多达上百个度量；添加完成所有度量之后，单击“Next”。\n\n第四页，是关于Cube数据刷新的设置。在这里可以设置自动合并的阈值、数据保留的最短时间，以及第一个Segment的起点时间（如果Cube有分割时间列的话）。\n\n第五页，高级设置。在此页面上可以设置聚合组和Rowkey\nKylin默认会把所有的维度都放在同一个聚合中；如果维度数据较多（例如>10），那么建议用户根据查询的习惯和模式，单击“New Aggregation Group+”，将维度分为多个聚合组。通过使用多个聚合组，可以大大降低Cube中的Cuboid数量。下面来举例说明，如果一个Cube有（M+N)个维度，那么默认它会有2的m+n次方个Cuboid；如果把这些维度分为两个不相交的聚合组，那么Cuboid的数量将被减少为2的m次方+2的n次方。  \n在单个聚合组中，可以对维度设置高级属性，例如Mandatory、Hierarchy、Joint等。这几个属性都是为了优化Cube的计算而设计的，了解这些属性的含义对日后更好地使用Cube至关重要。  \nMandatory维度指的是那些总是会出现在where条件或Group By语句里的维度；通过将某个维度指定为Mandatory，Kylin就可以不用预计算那些不包含此维度的Cuboid，从而减少计算量。  \nHierarchy是一组有层级关系的维度，例如：“国家”“省”“市”，这里的“国家”是高级的维度，“省”“市”依次是低级的维度。用户会按高级别维度进行查询，也会按低级别维度进行查询，但在查询低级别维度时，往往都会带上高级别维度的条件，而不会孤立地审视低级别维度的数据。例如，用户单击“国家”作为维度来查询汇总数据，也可能单击“国家”+“省”或者“国家”+“省”+“市”来查询，但是不会跨越国家直接Group By“省”或“市”。通过指定Hierarchy，Kylin可以省略不满足此模式的cuboid。  \nJoint是将多个维度组合成一个维度，其通常适用于如下两种情况。\n1.总是会在一起查询的维度。  \n2.基数很低的维度  \nKylin以Key-Value的方式将Cube存在到HBase中。HBase的key，也就是Rowkey，是由各维度的值拼接而成的；为了更高效地存储这些值，Kylin会对它们进行编码和压缩；每个维度均可以选择合适的编码（Encoding）方式，默认采用的是字典（Dictionary）编码技术；除了字典以外，还有整数（Int）和固定长度（Fixed Length）的编码。  \n字典编码是将此维度下所有值构建成一个从string到int的映射表；Kylin会将字典序列化保存，在Cube中存储int值，从而大大减小存储的大小。另外，字典是保持顺序的，即如果字符串A比字符串B大的话，那么A的编码后的int值也会比B编码后的值大；这样可以使得在HBase中进行比较查询的时候，依然使用编码后的值，而无需解码。\n\n字典非常适合于非固定长度的string类型值的维度，而且用户无需指定编码后的长度；但是由于使用字典需要维护一张映射表，因些如果此维度的基数很高，那么字典的大小就非常可观，从而不适合于加载到内存中，在这种情况下就要选择其他的编码方式了。Kylin中字典编码允许的基数上限默认是500万（由参数\"kylin.dictioinary.max.cardinality\"配置）。  \n整数（int）编码适合于对int或bigint类型的值进行编码，它无需额外存储，同时还可以支持很大的基数。用户需要根据值域选择编码的长度。例如有一个手机号码的维度，它是一个11位的数字，如13800138000，我们知道它大于2的31次方，但是小于2的39次方减1，那么使用int(5)即可满足要求，每个值占用5字节，比按字符存储（11字节）要少占一半以上的空间。  \n\n当上面几种编码方式都不适合的时候，就使用固定长度的编码了；此编码方式其实只是将原始值截断或补充成相同长度的一组字节，没有额外的转换，所以空间效率较差，通常只是作为一种权宜手段。  \n各维度在Rowkeys中的顺序，对于 查询的性能会产生较明显的影响。在这里用户可以根据查询的模式和习惯，通过拖拽的方式调整各个维度在Rowkeys上的顺序。通常的原则是，将过滤频率较高的列放置在过滤频率较低的列之前，将基数高的列放置在基数低的列之前。这样做的好处是，充分利用过滤条件来缩小在HBase中扫描的范围，从而提高查询的效率。  \n第五页，为Cube配置参数。和其他Hadoop工具一样，Kylin使用了很多配置参数以提高录活性，用户可以根据具体的环境、场景等配置不同的参数进行调优。Kylin全局的参数值可在conf/kylin.properties文件中进行配置；如果Cube需要覆盖全局设置的话，则需要在此页面中指定。单击“+Property”按钮，然后输入参数名和参数值。例如“kylin.hbase.region.cut=1\",这样此Cube在存储的时候，Kylin将会为每个HTbase Region分配1GB来创建一个HTbase Region。\n\n\n\n\n#构建Cube\n新创建的Cube只有定义，而没有计算的数据，它的状态是”DISABLED“，是不会被查询引擎挑中的。要想让Cube有数据，还需要对它进行构建。Cube的构建方式通常有两种：全量构建和增量构建；两者的构建步骤是完全一样的，区别只在于构建时读取的数据源是全集还是子集。  \nCube的构建包含如下步骤，由任务引擎来调度执行。  \n1）创建临时的Hive平表（从Hive读取数据）  \n2）计算各维度的不同值，并收集各Cuboid的统计数据。  \n3）创建并保存字典。  \n4）保存Cuboid统计信息。  \n5）创建HTable。  \n6）计算Cube（一轮或若干轮MapRecue）。  \n7）将Cube的计算结果转成HFile。  \n8）加载HFile到HBase。  \n9）更新Cube元数据。  \n10）垃圾回收。  \n以上步骤中，前5步是计算Cube而做的准备工作，例如遍历维度值来创建字典，对数据做统计秋估算以创建HTable等；第6）步是真正的Cube计算，取决于所使用的Cube算法，它可能是一轮MapRecue任务，也可能是N（在没有优化的情况下，N可以被视作是维度数）轮迭代的MapRecue。由于Cube运算的中间结果是以SequenceFile的格式存储在HDFS上的，所以为了导入到HBase中，还需要第7）步将这些结果转换成HFile（HBase文件存储格式）。第8）步通过使用HBase BulkLoad工具，将HFile导入到HBase集群，这一步完成之后，HTable就可以查询到数据了。第9）步更新Cube的数据，将此次构建 Segment的状态从”NEW“更新为”ＲＥＡＤＹ＂，表示已经可借查询了。最后一步，清理构建过程中生成的临时文件等垃圾，释放集群资源。　　\nMonitor页面会显示当前项目下近期的构建任务。　　\n\n\n\n##全量构建和增量构建\n\n###全量构建\n\n\n###增量构建\n\n\n\n##历史数据刷新\n\n\n##合并\n\n#查询Cube\n\n\n","source":"_posts/hadoop/Kylin入门概念.md","raw":"---\ntitle: Kylin入门概念\ndate: 2017-04-16 23:43:49\ntags: [大数据,kylin]\ncategories: [大数据,kylin]\n---\n\n#Apache Kylin的工作原理\nApache Kylin的工作原理本质上是MOLAP（Multidimensional　Online　Analytical　Processing）Cube，也就是多维　立方体分析。这是数据分析中相当经典的理论，在关系数据库年代就已经有了广泛的应用，下面将其做简要的介绍。  \n\n##维度和度量\n简单来讲，维度就是观察数据的角度。比如电商的销售数据，可以从时间的维度来观察，也可以进一步细化，从时间和地区的维度来观察。维度一般是一组离散的值，比如时间维度上的每一个独立的日期，或者商品维度上的每一件独立的商品。因此统计时可以把维度值 相同的记录聚合在一起，然后应用聚合函数做累加、平均、去重计数等聚合计算。  ![\"维度和度量的例子\"](/images/hadoop/kylin/维度和度量的例子.jpg)\n    \n度量就是被聚合的统计值，也是聚合运算的结果，它一般是连续的值，如图1-2中的销售额，抑或是销售商品的总件数据 。通过比较和测量试题，分析师可以对数据进行评估，比如今年的销售额相比去年有多大的增长，增长的速度是否达到预期，不同商品类别的增长比例是否合理等。  \n\n##Cube和Cuboid\n有了维度和度量，一个数据表或数据模型上的所有字段就可以分类了，它们要么是维度，要么是度量（可以被聚合）。于是就有了根据维度和度量来做预计算的Cube理论。  \n给定一个数据模型，我们可以对其上的所有维度进行组合。对于N个维度来说，组合的所有可能共2的n次方种。对于每一种维度的组合，将度量做聚合运算，然后将运算的结果保存为一个物化视图，称为Cuboid。所有维度组合的Coboid作为一个整体，被称为Cube。所以简单来说一个Cube就是许多按维度聚合的物化视图的集合。  \n下面来举一个具体的例子。假定有一个电商的销售数据集，其中维度包括时间（Time）、商品（Item）、地点（Location）和供应商（Supplier），度量为销售额（GMV）。那么所有维度的组合就有2的4次方=16种，比如一维度（ID）的组合有[Time]、[Item]、[Location]、[Supplier]4种；二维度（3D）的组合有[Time,Item]、[Time，Location]、[Time,Supplier]、[Item,Location]、[Item,Supplier]、[Location,Supplier]6种；三维度（3D）的组合也有4种；最后零维度（0D）和四维度（4D）的组合各有1种，总共有16种组合。\n![\"一个四维Cube的例子\"](/images/hadoop/kylin/一个四维Cube的例子.jpg)\n\t\t\n计算Cuboid，即按维度来聚合销售额。如果用SQL语句来表达计算Cuboid[Time,Location]，那么SQL语句如下：  \nSelect Time,Location,Sum(GMV) as GMV from Sales group by Time,Location.  \n将计算的结果保存为物化视图，所有Cuboid物化视图的总称是Cube。\n\n##工作原理\nApache Kylin的工作原理就是对数据模型做Cube预计算，并利用计算的结果加速查询，具体工作过程如下：\n1）指定数据模型，定义维度和度量\n2）预计算Cube，计算所有Cuboid并保存为物化视图。\n3）执行查询时，读取Cuboid，运算，产生查询结果。\n由于Kylin的查询过程不会扫描原始记录，而是通过预计算预先完成表的关联、聚合等复杂运算，并利用预计算的结果来执行查询，因此相比非预计算的查询技术，其速度一般要快一到两个数据级，并且这点在超磊的数据集上优势更加明显。当数据集达到千亿及至万亿级别时，Kylin的速度甚至可以超越其他非预计算技术1000倍以上。\n\n#技术架构\nApache Kylin系统可以分为在线查询和离线构建两部分，技术架构如下图所示，在线查询的模块主要处于上半区，而离线构建则处于下半区。\n![\"Kylin的技术架构\"](/images/hadoop/kylin/Kylin的技术架构.jpg)\t\n\n我们首先看看离线构建的部分。从图1-4可以看出，数据源在左侧，目前主要是Hadoop Hive，保存着待分析的用户数据。根据元数据的字义，下方构建引擎从数据源抽取数据，并构建Cube。数据以关系表的形式输入，且必须符合星形模型（Star Schema）（更复杂的雪花模型在成文时还不支持，可以通过视图将雪花模型转化为星形模型，再使用Kylin）。MapRecue是当前主要的构建技术。构建后的Cube保存在右侧的存储引擎中，一般选用HBase作为存储。  \n完成了离线构建之后，用户可以从上方查询系统发送SQL进行查询分析。Kylin提供了各种Rest　API、ＪＤＢＣ／ＯＤＢＣ接口。无论从哪个接口进入，SQL最终都会来到Rest服务层，再转交给查询引擎进行处理。这里需要注意的是，SQL语句是基于数据源的关系模型书写的，而不是Cube。Kylin在设计时刻意对查询用户屏蔽了Cube的概念，分析师只需要理解简单的关系模型就可以使用Kylin，没有额外的学习门槛，传统的SQL应用也很容易迁移。查询引擎解析SQL，生成基于关系表的逻辑执行计划，然后将其转义为基于Cube的物理执行计划，最后查询预计算生成的Cube并产生结果。整个过程不会访问原始数据源。  \n\n\n**注意**：对于查询引擎下方的路由选择，在最初设计时曾考虑过将Kylin不能执行查询引导去Hive中继续执行，但在实践后发现Hive与Kylin的速度差异过大，导致用户无法对查询的速度有一致的期望，很可能大多数据查询几秒内就返回结果了，而有些查询则要等几分钟到几十分钟，因此体验非常糟糕。最后这个路由功能在发行版中默认关闭。\n\n\nApache Kylin 1.5版本引入了“可扩展架构”的概念。在图1-4中显示为三个粗虚框，表示的抽象层。可扩展指Kylin可以对其主要依赖的三个模块做任意的扩展和替换。Kylin的三大依赖模型分别是数据源、构建引擎和存储引擎。在设计之初，作为Hadoop家族 一员，这三者分别是Hive、MapRecue和HBase。但随着推广和使用的深入，渐渐有用户发现它们均存在不足之处。比如，实时分析可能会希望从Kafka导入数据而不是Hive；而Spark的迅速崛起，又使我们不得不考虑将MapRecue替换为Spark，以期大幅提高Cube的构建速度；至于HBase，它的读性能可能还不如Cassandra或Kudu等 。可见，是否可以将一种技术替换为另一种技术已成为一个常见的问题。于在1.5版本的系统架构进行了重构，将数据源、构建引擎、存储引擎三大依赖抽象为接口，而Hive、MapRecue、HBase只是默认实现。深度用户可以根据自己的需要做二次开发，将其中的一个或多个替换为更适合的技术。  \n\n#核心概念\n##数据仓库\n数据仓库（Data Warehouse）是一种系统的资料储存理论，此理论强调的是利用某些特殊的资料储存方式，让所包含的资料特别有利于分析和处理，从而产生有价值的资讯，并可依此做出决策。\n利用数据仓库的方式存放资料，具有一旦存入，便不会随时间发生变动的特性，此外，存入的资料必定包含时间属性，通常一个数据仓库中会含有大量的历史性资料，并且它可利用特定的分析方式，从其中发掘特定的资讯。\n\n##OLAP\nOLAP（Online Analytical Process），联机分析处理，以多维度的方式分析数据，而且能够弹性地提供上卷（Roll-up）、下钻（Drill-down）和透视分析（Pivot）等操作，它呈现集成性决策信息的方法，多用于决策支持系统、商务智能或数据仓库。其主要的功能在于方便大规模数据分析及统计计算，可对决策提供参考和支持。与之相区别的是取机交易处理（OLTP），联机交易处理，更侧重于基本的、日常的事务处理，包括数据的增删改查。\nOLAP需要以大量历史数据为基础，再配合时间点的差异，对多维度及汇整型的信息进行复杂的分析。\nOLAP需要用户有主观的信息需求定义，因此系统效率较佳。\nOLAP的概念，在实际应用中存在广义和狭义两种不同的理解方式。广义上的理解与字面上的意义相同，泛指一切不会对数据进行更新的分析处理。但更多的情况下OLAP被理解为其狭义上的含义，即与多维分析相关，基于立方体（Cube）计算而进行的分析。\n\n##BI\nBI（Business Intelligence），即商务智能，指现代数据仓库技术、在线分析技术、数据挖掘和数据展现技术进行数据分析以实现商业价值。\n\n\n##维度和度量\n维度和度量是数据分析中的两个基本的概念\n**维度**是指审视数据的角度，它通常是数据记录的一个属性，例如时间、地点等。  \n**度量**是基于数据所计算出来的考量值；它通常是一个数值，如总销售额、不同的用户数等。分析人员往往要结合若干个维度来审查度量值，以便在其中找到变化规律。在一个SQL查询中，Group By的属性通常就是维度，而所计算的值则是度量。如下面的示例：  \n    select part_dt,lstg_iste_id,sum(price) as total_selled,count(distinct seller_id) as sellers from kylin_sales group by part_dt,lstg_site_id\n\n##事实表和维度表\n**事实表**（Fact Table）是指存储有事实记录的表，如系统日志、销售记录等；事实表的记录在不断地动态增长，所以它的体积通常远大于其他表。\n\n**维度表**（Dimension Table）或维表，有时也称查找表（Lookup Table），是与事实表相对应的一种表；它保存了维度的属性值，可以跟事实表做关联；相当于将事实表上经常重复出现的属性抽取、规范出来用一张表进行管理。常见的维度表有：日期表（存储与日期对应的周、月、季度等属性）、地点表（包含国家、省、城市等属性）。使用维度表有诸多好处，具体如下：\na.缩小了事实表的大小\nb.便于维度的管理和维护，增加、删除和修改维度的属性，不必对事实表的大量记录进行改动。\nc.维度表可以为多个事实表重用，以减少重复工作。\n\n##Cube、Cuboid和Cube Segment\n###Cube\nCube（或Data Cube），即数据立方体，是一种常用于数据分析与索引的技术；它可以对原始数据建立多维度索引。通过Cube对数据进行分析，可以大大加快数据的查询效率。\n\n###Cuboid\nCuboid在Kylin中特指在某一种维度组合下所计算的数据。\n\n##Cube Segment\nCube Segment是指针对源数据中的某一片段，计算出来的Cube数据。通常数据仓库中的数据数量会随着时间的增长而增长，而Cube Segment也是按时间顺序来构建的。\n\n\n\n#在Hive中准备数据\n这里介绍准备Hive数据的一些注意事项。需要被分析的数据必须先保存为Hive表的形式，然后Kylin才能从Hive中导入数据，创建Cube。\nHive是一个基于Hadoop的数据仓库工具，可以将结构化的数据文件映射为数据库表，并可以将SQL语句转换为MapRecue或Tez任务进行运行，从而让用户以类SQL（HiveQL，也称HQL）的方式管理和查询Hadoop上的海量数据。\n此外，Hive还提供了多种方式（如命令行、API和Web服务等）可供第三方方便地获取和使用元数据并进行查询。今天，Hive已经成为Hadoop数据仓库的首选，是Hadoop上不可或缺的一个重要组件，很多项目都已兼容或集成了Hive。基于此情况，Kylin选择Hive作为原始数据的主要来源。\n在Hive中准备待分析的数据是使用Kylin的前提；将数据导入到Hive表中的方法有很多，用户管理数据的技术和工具也各式各样，因此具体步骤不在本书的讨论范围之内。\n\n##星形模型\n数据挖掘有几种常见的多维数据模型，如星形模型（Star Schema）、雪花模型（Snowf lake Schema）、事实星座模型（Fact Constellation）等。  \n星形模型中有一张事实表，以及零个或多个维度表；事实表与维度表通过主键外键相关联，维度表之间没有关联，就像很多星星围绕在一个恒星周围，帮取名为星形模型。\n如果将星形模型中某些维度的表再做规范，抽取成更细的维度表，然后让维度表之间也进行关联，那么这种模型称为雪花模型。\n星形模型是更复杂的模型，其中包含了多个事实表，而维度表是公用的，可以共享。\n不过，Kylin只支持星形模型的数据集，这是基于以下考虑的。  \n\n- 星形模型是最简单，也是最常用的模型  \n- 由于星形模型只有一张大表，因此它相比于其它模型更适合于大数据处理  \n- 其他模型可以通过一定的转换，变成星形模型。  \n\n##维度表的设计\n除了数据模型以外，Kylin还对维度表有一定的要求，具体要求如下。  \n\n\n- 要具有数据一致性，主键值必须是唯一的；Kylin会进行检查，如果有两行的主键值相同则会报错。\n- 维度越小越好，因为Kylin会将维度表加载到内存中供查询；过大的表不适合作为维度表，默认的阈值是300MB。  \n- 改变频率低，Kylin会在每次构建中试图重用维度表的快照，如果维度表经常改变的话，重用就会失效，这就会导致要经常对维度表创建快照。\n- 维度表最好不要是Hive视图（View），虽然在Kylin1.5.3中加入了对维度表是视图这种情况的支持，但每次都需要将视图进行物化，从而导致额外的时间开销。\n\n##Hive表分区\nHive支持多分区（Partition）。简单来说，一个分区就是一个文件目录，存储了特定的数据文件。当有新的数据生成的时候，可以将数据加载到指定的分区，读取数据的时候也可以指定分区。对于 SQL查询，如果查询中指定了分区列的属性条件，则Hive会智能地选择特定分区（也就是目录），从而避免全量数据的扫描，减少读写操作对集群的压力。\n下面举的一组SQL演示了如何使用分区：  \n\nHie>create table invites(id int,name string) partitioned by(ds string) row format delimited fields terminated by 't' stroed as textfile;  \nHive>load data local inpath '/user/hadoop/data.txt' overwrite into table invites partition (ds='2016-08-16');  \nHive>select * from invites where ds = '2016-08-16';  \nKylin支持增量的Cube构建，通常是按时间属性来增量地从Hive表中抽取数据。如果Hive表正好是按此时间属性做分区的话，那么就可以利用到Hive分区的好处，每次在Hive构建的时候都可以直接跳过不相干的日期的数据，节省Cube构建的时间。这样的列在Kylin里也称为分割时间列（Partition Time Column），通常它应该也是Hive表的分区列。\n\n\n##了解维度的基数\n维度的基数（Cardinality）指的是该维度在数据集中出现的不同值的个数；例如“国家”是一个维度，如果有200个不同的值，那么此维度的基数就是200.通常一个维度的基数会从几十到几万个不等，个别维度如“用户ID”的基数会超过百万甚至千万。基数超过一百万的维度通常称为超高维度（Ulta Hight Cardinality，UHC），需要引起设计者的注意。  \nCube中所有维度的基数都可以体现Cube的复杂度，如果一个Cube中有好几个超高基数维度，那么这个Cube膨胀就会很高。在创建Cube前需要对所有维度的基数做一个了解，这样就可以帮助设计合理的Cube。计算基数有多种途径，最简单的方法就是让Hive执行一个count distinct的SQL查询；Kylin也提供计算基数的方法，在导入Hive表定义后可以看到每一个列的基数，参数名为Cardinality\n\n##Sample Data\n如果需要快速体验Kylin，可以用Kylin自带的Sample Data。运行${KYLIN_HOME}/bin/sample.sh来导入Sample Data，然后就能按照下面的流程来创建模型和Cube。  \n具体请执行下面命令，将Sample Data导入到Hive数据库。  \ncd ${KYLIN_HOME}  \nbin/sample.sh  \nSample Data测试的样例数据集总共仅1M左右，共计3张表，其中事实表有10000条数据。数据集是一个规范的星形模型结构，它总包含3个数据表：    \nKYLIN_SALES是事实表，保存了销售订单的明细信息。各列分别保存着卖家、商品、分类、订单金额、商品数据等信息，每一行对应着一笔交易订单。  \nKYLIN_CATEGORY_GROUPINGS是维表，保存了商品分类的详细介绍，例如商品分类名称等。  \nKYLIN_CAL_DT也是维表，保存了时间的扩展信息。如单个日期所在的年始、月始、周始、年份、月份等。  \n这3张表一起构成了整个星形模型。  \n\n#设计Cube\n如果数据已经在Hive中准备好了，就可以开始创建Cube了。\n##导入Hive表定义\n登陆Kylin的Web界面，创建新的或选择一个已有的项目之后，需要做的就是将Hive表的定义导入到Kylin中。  \n单击Web界面的Model->Data Source下的”Local Hive Table“图标，然后输入表的名称（可以一次导入多个表，以逗号分隔表名），单击按钮”Sync“，Kylin就会使用Hive的API从Hive中获取表的属性信息。  \n导入成功后，表的结构信息会以树状的形式显示在页面的左侧，可以单击展开或收缩。\n\n同时Kylin会在后台触发一个MapRecue任务，计算此表的每个列的基数。通常稍过几分钟后再刷新页面，就会看到显示出来 的基数信息Cardinality\n\n需要注意的是，这里Kylin对基数的计算方法采用的是HyperLogLog的近似算法，与精确值略有误差，只做参考值。\n\n##创建数据模型\n有了表信息之后，就可以开始创建数据模型（Data Model）了。数据模型是Cube的基础，它主要用于描述一个星形模型。有了数据模型以后，定义Cube的时候就可以直接从此模型定义的表和列中进行选择了，省去重复指定连接（join）条件的步骤。基于一个数据模型还可以创建多个Cube，以方便减少用户的重复性工作。  \n在Kylin界面中”Models“页面中单击”New\"->\"New Model\"，开始创建数据模型。\n\n\n接下来选择用作维度和度量的列。这里只是选择一个范围，不代表这些列将来一定要用作Cube 的维度或度量，你可以把所有可能会用到表都选进来，后续创建Cube的时候，将只能从这些列中进行选择。   \n\n选择维度列时，维度可以来自事实表或维度表  \n选择度量列时，度量只能来自事实表  \n最后一步，是为模型补充侵害时间列信息和过滤条件。如果此模型中的事实表记录是按时间增长的，那么可以指定一个日期/时间列作为模型的分割时间列，从而可以让Cube按此列做增量构建。\n\n过滤（Filter）条件是指，如果想把一些记录忽略掉，那么这里可以设置一个过滤条件。Kylin在向Hive请求源数据的时候，会带上此过滤条件。\n\n随后“Save”后，出现在“Model”的列表中。\n\n\n##创建Cube\n单击“New”，选择“New Cube”，会开启一个包含若干步骤的向导。\n\n第一页，选择要使用的数据模型，并为此Cube输入一个唯一的名称（必需的）和描述（可选的）；这里还可以输入一个邮件通知列表，用于在构建完成或出错时收到通知。如果不想接收处于某些状态的通知，那么可以从“Notification Events”中将其去掉。\n\n第二页，选择Cube的维度。可以通过以下两个按钮来添加维度。   \n**“Add Mimension”**：逐个添加维度，可以是普通维度也可以是衍生（Derived）维度。\n**“Auto Generator”：**批量选择并添加，让Kylin自动完成其它信息。  \n使用第一种方法的时候需要为每个维度起个名字，然后选择表和列。  \n如果是衍生维度的话，则必须是来自于某个维度表，一次可以选择多个列；由于这些列值都可以从该维度表的主键值中衍生出来，所以实际上只有主键列会被Cube加入计算。而在Kylin 的具体实现中，往往采用事实表上的外键替代主键进行计算和存储。但是在逻辑上可以认为衍生列来自于维度表的主键。  \n使用第二种方法，Kylin会用一个树状结构呈现出所有的列，用户只需要勾选所需要的列即可，Kylin会自动补充其他信息，从而方便用户的操作。请注意，在这里Kylin会把维度表上的列都创建成衍生维度，这也许不是最合适的，在这种情况下请使用第一种方法。\n\n\n第三页，创建度量。Kylin默认会创建一个Count(1)的度量。可以单击“+Measure\"按钮来添加新度量。Kylin支持的度量有：SUM、MIN、MAX、COUNT、COUNT　DISTINCT、ＴＯＰ＿Ｎ、RAW等。请选择需要的度量类型，然后再选择适当的参数（通常为列名）\n\n重复上面的步骤，创建所需要的度量。Kylin可以支持在一个Cube中添加多达上百个度量；添加完成所有度量之后，单击“Next”。\n\n第四页，是关于Cube数据刷新的设置。在这里可以设置自动合并的阈值、数据保留的最短时间，以及第一个Segment的起点时间（如果Cube有分割时间列的话）。\n\n第五页，高级设置。在此页面上可以设置聚合组和Rowkey\nKylin默认会把所有的维度都放在同一个聚合中；如果维度数据较多（例如>10），那么建议用户根据查询的习惯和模式，单击“New Aggregation Group+”，将维度分为多个聚合组。通过使用多个聚合组，可以大大降低Cube中的Cuboid数量。下面来举例说明，如果一个Cube有（M+N)个维度，那么默认它会有2的m+n次方个Cuboid；如果把这些维度分为两个不相交的聚合组，那么Cuboid的数量将被减少为2的m次方+2的n次方。  \n在单个聚合组中，可以对维度设置高级属性，例如Mandatory、Hierarchy、Joint等。这几个属性都是为了优化Cube的计算而设计的，了解这些属性的含义对日后更好地使用Cube至关重要。  \nMandatory维度指的是那些总是会出现在where条件或Group By语句里的维度；通过将某个维度指定为Mandatory，Kylin就可以不用预计算那些不包含此维度的Cuboid，从而减少计算量。  \nHierarchy是一组有层级关系的维度，例如：“国家”“省”“市”，这里的“国家”是高级的维度，“省”“市”依次是低级的维度。用户会按高级别维度进行查询，也会按低级别维度进行查询，但在查询低级别维度时，往往都会带上高级别维度的条件，而不会孤立地审视低级别维度的数据。例如，用户单击“国家”作为维度来查询汇总数据，也可能单击“国家”+“省”或者“国家”+“省”+“市”来查询，但是不会跨越国家直接Group By“省”或“市”。通过指定Hierarchy，Kylin可以省略不满足此模式的cuboid。  \nJoint是将多个维度组合成一个维度，其通常适用于如下两种情况。\n1.总是会在一起查询的维度。  \n2.基数很低的维度  \nKylin以Key-Value的方式将Cube存在到HBase中。HBase的key，也就是Rowkey，是由各维度的值拼接而成的；为了更高效地存储这些值，Kylin会对它们进行编码和压缩；每个维度均可以选择合适的编码（Encoding）方式，默认采用的是字典（Dictionary）编码技术；除了字典以外，还有整数（Int）和固定长度（Fixed Length）的编码。  \n字典编码是将此维度下所有值构建成一个从string到int的映射表；Kylin会将字典序列化保存，在Cube中存储int值，从而大大减小存储的大小。另外，字典是保持顺序的，即如果字符串A比字符串B大的话，那么A的编码后的int值也会比B编码后的值大；这样可以使得在HBase中进行比较查询的时候，依然使用编码后的值，而无需解码。\n\n字典非常适合于非固定长度的string类型值的维度，而且用户无需指定编码后的长度；但是由于使用字典需要维护一张映射表，因些如果此维度的基数很高，那么字典的大小就非常可观，从而不适合于加载到内存中，在这种情况下就要选择其他的编码方式了。Kylin中字典编码允许的基数上限默认是500万（由参数\"kylin.dictioinary.max.cardinality\"配置）。  \n整数（int）编码适合于对int或bigint类型的值进行编码，它无需额外存储，同时还可以支持很大的基数。用户需要根据值域选择编码的长度。例如有一个手机号码的维度，它是一个11位的数字，如13800138000，我们知道它大于2的31次方，但是小于2的39次方减1，那么使用int(5)即可满足要求，每个值占用5字节，比按字符存储（11字节）要少占一半以上的空间。  \n\n当上面几种编码方式都不适合的时候，就使用固定长度的编码了；此编码方式其实只是将原始值截断或补充成相同长度的一组字节，没有额外的转换，所以空间效率较差，通常只是作为一种权宜手段。  \n各维度在Rowkeys中的顺序，对于 查询的性能会产生较明显的影响。在这里用户可以根据查询的模式和习惯，通过拖拽的方式调整各个维度在Rowkeys上的顺序。通常的原则是，将过滤频率较高的列放置在过滤频率较低的列之前，将基数高的列放置在基数低的列之前。这样做的好处是，充分利用过滤条件来缩小在HBase中扫描的范围，从而提高查询的效率。  \n第五页，为Cube配置参数。和其他Hadoop工具一样，Kylin使用了很多配置参数以提高录活性，用户可以根据具体的环境、场景等配置不同的参数进行调优。Kylin全局的参数值可在conf/kylin.properties文件中进行配置；如果Cube需要覆盖全局设置的话，则需要在此页面中指定。单击“+Property”按钮，然后输入参数名和参数值。例如“kylin.hbase.region.cut=1\",这样此Cube在存储的时候，Kylin将会为每个HTbase Region分配1GB来创建一个HTbase Region。\n\n\n\n\n#构建Cube\n新创建的Cube只有定义，而没有计算的数据，它的状态是”DISABLED“，是不会被查询引擎挑中的。要想让Cube有数据，还需要对它进行构建。Cube的构建方式通常有两种：全量构建和增量构建；两者的构建步骤是完全一样的，区别只在于构建时读取的数据源是全集还是子集。  \nCube的构建包含如下步骤，由任务引擎来调度执行。  \n1）创建临时的Hive平表（从Hive读取数据）  \n2）计算各维度的不同值，并收集各Cuboid的统计数据。  \n3）创建并保存字典。  \n4）保存Cuboid统计信息。  \n5）创建HTable。  \n6）计算Cube（一轮或若干轮MapRecue）。  \n7）将Cube的计算结果转成HFile。  \n8）加载HFile到HBase。  \n9）更新Cube元数据。  \n10）垃圾回收。  \n以上步骤中，前5步是计算Cube而做的准备工作，例如遍历维度值来创建字典，对数据做统计秋估算以创建HTable等；第6）步是真正的Cube计算，取决于所使用的Cube算法，它可能是一轮MapRecue任务，也可能是N（在没有优化的情况下，N可以被视作是维度数）轮迭代的MapRecue。由于Cube运算的中间结果是以SequenceFile的格式存储在HDFS上的，所以为了导入到HBase中，还需要第7）步将这些结果转换成HFile（HBase文件存储格式）。第8）步通过使用HBase BulkLoad工具，将HFile导入到HBase集群，这一步完成之后，HTable就可以查询到数据了。第9）步更新Cube的数据，将此次构建 Segment的状态从”NEW“更新为”ＲＥＡＤＹ＂，表示已经可借查询了。最后一步，清理构建过程中生成的临时文件等垃圾，释放集群资源。　　\nMonitor页面会显示当前项目下近期的构建任务。　　\n\n\n\n##全量构建和增量构建\n\n###全量构建\n\n\n###增量构建\n\n\n\n##历史数据刷新\n\n\n##合并\n\n#查询Cube\n\n\n","slug":"hadoop/Kylin入门概念","published":1,"updated":"2017-08-18T01:44:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bpn00bvs77rjrywdfn6","content":"<p>#Apache Kylin的工作原理<br>Apache Kylin的工作原理本质上是MOLAP（Multidimensional　Online　Analytical　Processing）Cube，也就是多维　立方体分析。这是数据分析中相当经典的理论，在关系数据库年代就已经有了广泛的应用，下面将其做简要的介绍。  </p>\n<p>##维度和度量<br>简单来讲，维度就是观察数据的角度。比如电商的销售数据，可以从时间的维度来观察，也可以进一步细化，从时间和地区的维度来观察。维度一般是一组离散的值，比如时间维度上的每一个独立的日期，或者商品维度上的每一件独立的商品。因此统计时可以把维度值 相同的记录聚合在一起，然后应用聚合函数做累加、平均、去重计数等聚合计算。  <img src=\"/images/hadoop/kylin/维度和度量的例子.jpg\" alt=\"&quot;维度和度量的例子&quot;\"></p>\n<p>度量就是被聚合的统计值，也是聚合运算的结果，它一般是连续的值，如图1-2中的销售额，抑或是销售商品的总件数据 。通过比较和测量试题，分析师可以对数据进行评估，比如今年的销售额相比去年有多大的增长，增长的速度是否达到预期，不同商品类别的增长比例是否合理等。  </p>\n<p>##Cube和Cuboid<br>有了维度和度量，一个数据表或数据模型上的所有字段就可以分类了，它们要么是维度，要么是度量（可以被聚合）。于是就有了根据维度和度量来做预计算的Cube理论。<br>给定一个数据模型，我们可以对其上的所有维度进行组合。对于N个维度来说，组合的所有可能共2的n次方种。对于每一种维度的组合，将度量做聚合运算，然后将运算的结果保存为一个物化视图，称为Cuboid。所有维度组合的Coboid作为一个整体，被称为Cube。所以简单来说一个Cube就是许多按维度聚合的物化视图的集合。<br>下面来举一个具体的例子。假定有一个电商的销售数据集，其中维度包括时间（Time）、商品（Item）、地点（Location）和供应商（Supplier），度量为销售额（GMV）。那么所有维度的组合就有2的4次方=16种，比如一维度（ID）的组合有[Time]、[Item]、[Location]、[Supplier]4种；二维度（3D）的组合有[Time,Item]、[Time，Location]、[Time,Supplier]、[Item,Location]、[Item,Supplier]、[Location,Supplier]6种；三维度（3D）的组合也有4种；最后零维度（0D）和四维度（4D）的组合各有1种，总共有16种组合。<br><img src=\"/images/hadoop/kylin/一个四维Cube的例子.jpg\" alt=\"&quot;一个四维Cube的例子&quot;\"></p>\n<p>计算Cuboid，即按维度来聚合销售额。如果用SQL语句来表达计算Cuboid[Time,Location]，那么SQL语句如下：<br>Select Time,Location,Sum(GMV) as GMV from Sales group by Time,Location.<br>将计算的结果保存为物化视图，所有Cuboid物化视图的总称是Cube。</p>\n<p>##工作原理<br>Apache Kylin的工作原理就是对数据模型做Cube预计算，并利用计算的结果加速查询，具体工作过程如下：<br>1）指定数据模型，定义维度和度量<br>2）预计算Cube，计算所有Cuboid并保存为物化视图。<br>3）执行查询时，读取Cuboid，运算，产生查询结果。<br>由于Kylin的查询过程不会扫描原始记录，而是通过预计算预先完成表的关联、聚合等复杂运算，并利用预计算的结果来执行查询，因此相比非预计算的查询技术，其速度一般要快一到两个数据级，并且这点在超磊的数据集上优势更加明显。当数据集达到千亿及至万亿级别时，Kylin的速度甚至可以超越其他非预计算技术1000倍以上。</p>\n<p>#技术架构<br>Apache Kylin系统可以分为在线查询和离线构建两部分，技术架构如下图所示，在线查询的模块主要处于上半区，而离线构建则处于下半区。<br><img src=\"/images/hadoop/kylin/Kylin的技术架构.jpg\" alt=\"&quot;Kylin的技术架构&quot;\">    </p>\n<p>我们首先看看离线构建的部分。从图1-4可以看出，数据源在左侧，目前主要是Hadoop Hive，保存着待分析的用户数据。根据元数据的字义，下方构建引擎从数据源抽取数据，并构建Cube。数据以关系表的形式输入，且必须符合星形模型（Star Schema）（更复杂的雪花模型在成文时还不支持，可以通过视图将雪花模型转化为星形模型，再使用Kylin）。MapRecue是当前主要的构建技术。构建后的Cube保存在右侧的存储引擎中，一般选用HBase作为存储。<br>完成了离线构建之后，用户可以从上方查询系统发送SQL进行查询分析。Kylin提供了各种Rest　API、ＪＤＢＣ／ＯＤＢＣ接口。无论从哪个接口进入，SQL最终都会来到Rest服务层，再转交给查询引擎进行处理。这里需要注意的是，SQL语句是基于数据源的关系模型书写的，而不是Cube。Kylin在设计时刻意对查询用户屏蔽了Cube的概念，分析师只需要理解简单的关系模型就可以使用Kylin，没有额外的学习门槛，传统的SQL应用也很容易迁移。查询引擎解析SQL，生成基于关系表的逻辑执行计划，然后将其转义为基于Cube的物理执行计划，最后查询预计算生成的Cube并产生结果。整个过程不会访问原始数据源。  </p>\n<p><strong>注意</strong>：对于查询引擎下方的路由选择，在最初设计时曾考虑过将Kylin不能执行查询引导去Hive中继续执行，但在实践后发现Hive与Kylin的速度差异过大，导致用户无法对查询的速度有一致的期望，很可能大多数据查询几秒内就返回结果了，而有些查询则要等几分钟到几十分钟，因此体验非常糟糕。最后这个路由功能在发行版中默认关闭。</p>\n<p>Apache Kylin 1.5版本引入了“可扩展架构”的概念。在图1-4中显示为三个粗虚框，表示的抽象层。可扩展指Kylin可以对其主要依赖的三个模块做任意的扩展和替换。Kylin的三大依赖模型分别是数据源、构建引擎和存储引擎。在设计之初，作为Hadoop家族 一员，这三者分别是Hive、MapRecue和HBase。但随着推广和使用的深入，渐渐有用户发现它们均存在不足之处。比如，实时分析可能会希望从Kafka导入数据而不是Hive；而Spark的迅速崛起，又使我们不得不考虑将MapRecue替换为Spark，以期大幅提高Cube的构建速度；至于HBase，它的读性能可能还不如Cassandra或Kudu等 。可见，是否可以将一种技术替换为另一种技术已成为一个常见的问题。于在1.5版本的系统架构进行了重构，将数据源、构建引擎、存储引擎三大依赖抽象为接口，而Hive、MapRecue、HBase只是默认实现。深度用户可以根据自己的需要做二次开发，将其中的一个或多个替换为更适合的技术。  </p>\n<p>#核心概念</p>\n<p>##数据仓库<br>数据仓库（Data Warehouse）是一种系统的资料储存理论，此理论强调的是利用某些特殊的资料储存方式，让所包含的资料特别有利于分析和处理，从而产生有价值的资讯，并可依此做出决策。<br>利用数据仓库的方式存放资料，具有一旦存入，便不会随时间发生变动的特性，此外，存入的资料必定包含时间属性，通常一个数据仓库中会含有大量的历史性资料，并且它可利用特定的分析方式，从其中发掘特定的资讯。</p>\n<p>##OLAP<br>OLAP（Online Analytical Process），联机分析处理，以多维度的方式分析数据，而且能够弹性地提供上卷（Roll-up）、下钻（Drill-down）和透视分析（Pivot）等操作，它呈现集成性决策信息的方法，多用于决策支持系统、商务智能或数据仓库。其主要的功能在于方便大规模数据分析及统计计算，可对决策提供参考和支持。与之相区别的是取机交易处理（OLTP），联机交易处理，更侧重于基本的、日常的事务处理，包括数据的增删改查。<br>OLAP需要以大量历史数据为基础，再配合时间点的差异，对多维度及汇整型的信息进行复杂的分析。<br>OLAP需要用户有主观的信息需求定义，因此系统效率较佳。<br>OLAP的概念，在实际应用中存在广义和狭义两种不同的理解方式。广义上的理解与字面上的意义相同，泛指一切不会对数据进行更新的分析处理。但更多的情况下OLAP被理解为其狭义上的含义，即与多维分析相关，基于立方体（Cube）计算而进行的分析。</p>\n<p>##BI<br>BI（Business Intelligence），即商务智能，指现代数据仓库技术、在线分析技术、数据挖掘和数据展现技术进行数据分析以实现商业价值。</p>\n<p>##维度和度量<br>维度和度量是数据分析中的两个基本的概念<br><strong>维度</strong>是指审视数据的角度，它通常是数据记录的一个属性，例如时间、地点等。<br><strong>度量</strong>是基于数据所计算出来的考量值；它通常是一个数值，如总销售额、不同的用户数等。分析人员往往要结合若干个维度来审查度量值，以便在其中找到变化规律。在一个SQL查询中，Group By的属性通常就是维度，而所计算的值则是度量。如下面的示例：<br>    select part_dt,lstg_iste_id,sum(price) as total_selled,count(distinct seller_id) as sellers from kylin_sales group by part_dt,lstg_site_id</p>\n<p>##事实表和维度表<br><strong>事实表</strong>（Fact Table）是指存储有事实记录的表，如系统日志、销售记录等；事实表的记录在不断地动态增长，所以它的体积通常远大于其他表。</p>\n<p><strong>维度表</strong>（Dimension Table）或维表，有时也称查找表（Lookup Table），是与事实表相对应的一种表；它保存了维度的属性值，可以跟事实表做关联；相当于将事实表上经常重复出现的属性抽取、规范出来用一张表进行管理。常见的维度表有：日期表（存储与日期对应的周、月、季度等属性）、地点表（包含国家、省、城市等属性）。使用维度表有诸多好处，具体如下：<br>a.缩小了事实表的大小<br>b.便于维度的管理和维护，增加、删除和修改维度的属性，不必对事实表的大量记录进行改动。<br>c.维度表可以为多个事实表重用，以减少重复工作。</p>\n<p>##Cube、Cuboid和Cube Segment</p>\n<p>###Cube<br>Cube（或Data Cube），即数据立方体，是一种常用于数据分析与索引的技术；它可以对原始数据建立多维度索引。通过Cube对数据进行分析，可以大大加快数据的查询效率。</p>\n<p>###Cuboid<br>Cuboid在Kylin中特指在某一种维度组合下所计算的数据。</p>\n<p>##Cube Segment<br>Cube Segment是指针对源数据中的某一片段，计算出来的Cube数据。通常数据仓库中的数据数量会随着时间的增长而增长，而Cube Segment也是按时间顺序来构建的。</p>\n<p>#在Hive中准备数据<br>这里介绍准备Hive数据的一些注意事项。需要被分析的数据必须先保存为Hive表的形式，然后Kylin才能从Hive中导入数据，创建Cube。<br>Hive是一个基于Hadoop的数据仓库工具，可以将结构化的数据文件映射为数据库表，并可以将SQL语句转换为MapRecue或Tez任务进行运行，从而让用户以类SQL（HiveQL，也称HQL）的方式管理和查询Hadoop上的海量数据。<br>此外，Hive还提供了多种方式（如命令行、API和Web服务等）可供第三方方便地获取和使用元数据并进行查询。今天，Hive已经成为Hadoop数据仓库的首选，是Hadoop上不可或缺的一个重要组件，很多项目都已兼容或集成了Hive。基于此情况，Kylin选择Hive作为原始数据的主要来源。<br>在Hive中准备待分析的数据是使用Kylin的前提；将数据导入到Hive表中的方法有很多，用户管理数据的技术和工具也各式各样，因此具体步骤不在本书的讨论范围之内。</p>\n<p>##星形模型<br>数据挖掘有几种常见的多维数据模型，如星形模型（Star Schema）、雪花模型（Snowf lake Schema）、事实星座模型（Fact Constellation）等。<br>星形模型中有一张事实表，以及零个或多个维度表；事实表与维度表通过主键外键相关联，维度表之间没有关联，就像很多星星围绕在一个恒星周围，帮取名为星形模型。<br>如果将星形模型中某些维度的表再做规范，抽取成更细的维度表，然后让维度表之间也进行关联，那么这种模型称为雪花模型。<br>星形模型是更复杂的模型，其中包含了多个事实表，而维度表是公用的，可以共享。<br>不过，Kylin只支持星形模型的数据集，这是基于以下考虑的。  </p>\n<ul>\n<li>星形模型是最简单，也是最常用的模型  </li>\n<li>由于星形模型只有一张大表，因此它相比于其它模型更适合于大数据处理  </li>\n<li>其他模型可以通过一定的转换，变成星形模型。  </li>\n</ul>\n<p>##维度表的设计<br>除了数据模型以外，Kylin还对维度表有一定的要求，具体要求如下。  </p>\n<ul>\n<li>要具有数据一致性，主键值必须是唯一的；Kylin会进行检查，如果有两行的主键值相同则会报错。</li>\n<li>维度越小越好，因为Kylin会将维度表加载到内存中供查询；过大的表不适合作为维度表，默认的阈值是300MB。  </li>\n<li>改变频率低，Kylin会在每次构建中试图重用维度表的快照，如果维度表经常改变的话，重用就会失效，这就会导致要经常对维度表创建快照。</li>\n<li>维度表最好不要是Hive视图（View），虽然在Kylin1.5.3中加入了对维度表是视图这种情况的支持，但每次都需要将视图进行物化，从而导致额外的时间开销。</li>\n</ul>\n<p>##Hive表分区<br>Hive支持多分区（Partition）。简单来说，一个分区就是一个文件目录，存储了特定的数据文件。当有新的数据生成的时候，可以将数据加载到指定的分区，读取数据的时候也可以指定分区。对于 SQL查询，如果查询中指定了分区列的属性条件，则Hive会智能地选择特定分区（也就是目录），从而避免全量数据的扫描，减少读写操作对集群的压力。<br>下面举的一组SQL演示了如何使用分区：  </p>\n<p>Hie&gt;create table invites(id int,name string) partitioned by(ds string) row format delimited fields terminated by ‘t’ stroed as textfile;<br>Hive&gt;load data local inpath ‘/user/hadoop/data.txt’ overwrite into table invites partition (ds=’2016-08-16’);<br>Hive&gt;select * from invites where ds = ‘2016-08-16’;<br>Kylin支持增量的Cube构建，通常是按时间属性来增量地从Hive表中抽取数据。如果Hive表正好是按此时间属性做分区的话，那么就可以利用到Hive分区的好处，每次在Hive构建的时候都可以直接跳过不相干的日期的数据，节省Cube构建的时间。这样的列在Kylin里也称为分割时间列（Partition Time Column），通常它应该也是Hive表的分区列。</p>\n<p>##了解维度的基数<br>维度的基数（Cardinality）指的是该维度在数据集中出现的不同值的个数；例如“国家”是一个维度，如果有200个不同的值，那么此维度的基数就是200.通常一个维度的基数会从几十到几万个不等，个别维度如“用户ID”的基数会超过百万甚至千万。基数超过一百万的维度通常称为超高维度（Ulta Hight Cardinality，UHC），需要引起设计者的注意。<br>Cube中所有维度的基数都可以体现Cube的复杂度，如果一个Cube中有好几个超高基数维度，那么这个Cube膨胀就会很高。在创建Cube前需要对所有维度的基数做一个了解，这样就可以帮助设计合理的Cube。计算基数有多种途径，最简单的方法就是让Hive执行一个count distinct的SQL查询；Kylin也提供计算基数的方法，在导入Hive表定义后可以看到每一个列的基数，参数名为Cardinality</p>\n<p>##Sample Data<br>如果需要快速体验Kylin，可以用Kylin自带的Sample Data。运行${KYLIN_HOME}/bin/sample.sh来导入Sample Data，然后就能按照下面的流程来创建模型和Cube。<br>具体请执行下面命令，将Sample Data导入到Hive数据库。<br>cd ${KYLIN_HOME}<br>bin/sample.sh<br>Sample Data测试的样例数据集总共仅1M左右，共计3张表，其中事实表有10000条数据。数据集是一个规范的星形模型结构，它总包含3个数据表：<br>KYLIN_SALES是事实表，保存了销售订单的明细信息。各列分别保存着卖家、商品、分类、订单金额、商品数据等信息，每一行对应着一笔交易订单。<br>KYLIN_CATEGORY_GROUPINGS是维表，保存了商品分类的详细介绍，例如商品分类名称等。<br>KYLIN_CAL_DT也是维表，保存了时间的扩展信息。如单个日期所在的年始、月始、周始、年份、月份等。<br>这3张表一起构成了整个星形模型。  </p>\n<p>#设计Cube<br>如果数据已经在Hive中准备好了，就可以开始创建Cube了。</p>\n<p>##导入Hive表定义<br>登陆Kylin的Web界面，创建新的或选择一个已有的项目之后，需要做的就是将Hive表的定义导入到Kylin中。<br>单击Web界面的Model-&gt;Data Source下的”Local Hive Table“图标，然后输入表的名称（可以一次导入多个表，以逗号分隔表名），单击按钮”Sync“，Kylin就会使用Hive的API从Hive中获取表的属性信息。<br>导入成功后，表的结构信息会以树状的形式显示在页面的左侧，可以单击展开或收缩。</p>\n<p>同时Kylin会在后台触发一个MapRecue任务，计算此表的每个列的基数。通常稍过几分钟后再刷新页面，就会看到显示出来 的基数信息Cardinality</p>\n<p>需要注意的是，这里Kylin对基数的计算方法采用的是HyperLogLog的近似算法，与精确值略有误差，只做参考值。</p>\n<p>##创建数据模型<br>有了表信息之后，就可以开始创建数据模型（Data Model）了。数据模型是Cube的基础，它主要用于描述一个星形模型。有了数据模型以后，定义Cube的时候就可以直接从此模型定义的表和列中进行选择了，省去重复指定连接（join）条件的步骤。基于一个数据模型还可以创建多个Cube，以方便减少用户的重复性工作。<br>在Kylin界面中”Models“页面中单击”New”-&gt;”New Model”，开始创建数据模型。</p>\n<p>接下来选择用作维度和度量的列。这里只是选择一个范围，不代表这些列将来一定要用作Cube 的维度或度量，你可以把所有可能会用到表都选进来，后续创建Cube的时候，将只能从这些列中进行选择。   </p>\n<p>选择维度列时，维度可以来自事实表或维度表<br>选择度量列时，度量只能来自事实表<br>最后一步，是为模型补充侵害时间列信息和过滤条件。如果此模型中的事实表记录是按时间增长的，那么可以指定一个日期/时间列作为模型的分割时间列，从而可以让Cube按此列做增量构建。</p>\n<p>过滤（Filter）条件是指，如果想把一些记录忽略掉，那么这里可以设置一个过滤条件。Kylin在向Hive请求源数据的时候，会带上此过滤条件。</p>\n<p>随后“Save”后，出现在“Model”的列表中。</p>\n<p>##创建Cube<br>单击“New”，选择“New Cube”，会开启一个包含若干步骤的向导。</p>\n<p>第一页，选择要使用的数据模型，并为此Cube输入一个唯一的名称（必需的）和描述（可选的）；这里还可以输入一个邮件通知列表，用于在构建完成或出错时收到通知。如果不想接收处于某些状态的通知，那么可以从“Notification Events”中将其去掉。</p>\n<p>第二页，选择Cube的维度。可以通过以下两个按钮来添加维度。<br><strong>“Add Mimension”</strong>：逐个添加维度，可以是普通维度也可以是衍生（Derived）维度。<br><strong>“Auto Generator”：</strong>批量选择并添加，让Kylin自动完成其它信息。<br>使用第一种方法的时候需要为每个维度起个名字，然后选择表和列。<br>如果是衍生维度的话，则必须是来自于某个维度表，一次可以选择多个列；由于这些列值都可以从该维度表的主键值中衍生出来，所以实际上只有主键列会被Cube加入计算。而在Kylin 的具体实现中，往往采用事实表上的外键替代主键进行计算和存储。但是在逻辑上可以认为衍生列来自于维度表的主键。<br>使用第二种方法，Kylin会用一个树状结构呈现出所有的列，用户只需要勾选所需要的列即可，Kylin会自动补充其他信息，从而方便用户的操作。请注意，在这里Kylin会把维度表上的列都创建成衍生维度，这也许不是最合适的，在这种情况下请使用第一种方法。</p>\n<p>第三页，创建度量。Kylin默认会创建一个Count(1)的度量。可以单击“+Measure”按钮来添加新度量。Kylin支持的度量有：SUM、MIN、MAX、COUNT、COUNT　DISTINCT、ＴＯＰ＿Ｎ、RAW等。请选择需要的度量类型，然后再选择适当的参数（通常为列名）</p>\n<p>重复上面的步骤，创建所需要的度量。Kylin可以支持在一个Cube中添加多达上百个度量；添加完成所有度量之后，单击“Next”。</p>\n<p>第四页，是关于Cube数据刷新的设置。在这里可以设置自动合并的阈值、数据保留的最短时间，以及第一个Segment的起点时间（如果Cube有分割时间列的话）。</p>\n<p>第五页，高级设置。在此页面上可以设置聚合组和Rowkey<br>Kylin默认会把所有的维度都放在同一个聚合中；如果维度数据较多（例如&gt;10），那么建议用户根据查询的习惯和模式，单击“New Aggregation Group+”，将维度分为多个聚合组。通过使用多个聚合组，可以大大降低Cube中的Cuboid数量。下面来举例说明，如果一个Cube有（M+N)个维度，那么默认它会有2的m+n次方个Cuboid；如果把这些维度分为两个不相交的聚合组，那么Cuboid的数量将被减少为2的m次方+2的n次方。<br>在单个聚合组中，可以对维度设置高级属性，例如Mandatory、Hierarchy、Joint等。这几个属性都是为了优化Cube的计算而设计的，了解这些属性的含义对日后更好地使用Cube至关重要。<br>Mandatory维度指的是那些总是会出现在where条件或Group By语句里的维度；通过将某个维度指定为Mandatory，Kylin就可以不用预计算那些不包含此维度的Cuboid，从而减少计算量。<br>Hierarchy是一组有层级关系的维度，例如：“国家”“省”“市”，这里的“国家”是高级的维度，“省”“市”依次是低级的维度。用户会按高级别维度进行查询，也会按低级别维度进行查询，但在查询低级别维度时，往往都会带上高级别维度的条件，而不会孤立地审视低级别维度的数据。例如，用户单击“国家”作为维度来查询汇总数据，也可能单击“国家”+“省”或者“国家”+“省”+“市”来查询，但是不会跨越国家直接Group By“省”或“市”。通过指定Hierarchy，Kylin可以省略不满足此模式的cuboid。<br>Joint是将多个维度组合成一个维度，其通常适用于如下两种情况。<br>1.总是会在一起查询的维度。<br>2.基数很低的维度<br>Kylin以Key-Value的方式将Cube存在到HBase中。HBase的key，也就是Rowkey，是由各维度的值拼接而成的；为了更高效地存储这些值，Kylin会对它们进行编码和压缩；每个维度均可以选择合适的编码（Encoding）方式，默认采用的是字典（Dictionary）编码技术；除了字典以外，还有整数（Int）和固定长度（Fixed Length）的编码。<br>字典编码是将此维度下所有值构建成一个从string到int的映射表；Kylin会将字典序列化保存，在Cube中存储int值，从而大大减小存储的大小。另外，字典是保持顺序的，即如果字符串A比字符串B大的话，那么A的编码后的int值也会比B编码后的值大；这样可以使得在HBase中进行比较查询的时候，依然使用编码后的值，而无需解码。</p>\n<p>字典非常适合于非固定长度的string类型值的维度，而且用户无需指定编码后的长度；但是由于使用字典需要维护一张映射表，因些如果此维度的基数很高，那么字典的大小就非常可观，从而不适合于加载到内存中，在这种情况下就要选择其他的编码方式了。Kylin中字典编码允许的基数上限默认是500万（由参数”kylin.dictioinary.max.cardinality”配置）。<br>整数（int）编码适合于对int或bigint类型的值进行编码，它无需额外存储，同时还可以支持很大的基数。用户需要根据值域选择编码的长度。例如有一个手机号码的维度，它是一个11位的数字，如13800138000，我们知道它大于2的31次方，但是小于2的39次方减1，那么使用int(5)即可满足要求，每个值占用5字节，比按字符存储（11字节）要少占一半以上的空间。  </p>\n<p>当上面几种编码方式都不适合的时候，就使用固定长度的编码了；此编码方式其实只是将原始值截断或补充成相同长度的一组字节，没有额外的转换，所以空间效率较差，通常只是作为一种权宜手段。<br>各维度在Rowkeys中的顺序，对于 查询的性能会产生较明显的影响。在这里用户可以根据查询的模式和习惯，通过拖拽的方式调整各个维度在Rowkeys上的顺序。通常的原则是，将过滤频率较高的列放置在过滤频率较低的列之前，将基数高的列放置在基数低的列之前。这样做的好处是，充分利用过滤条件来缩小在HBase中扫描的范围，从而提高查询的效率。<br>第五页，为Cube配置参数。和其他Hadoop工具一样，Kylin使用了很多配置参数以提高录活性，用户可以根据具体的环境、场景等配置不同的参数进行调优。Kylin全局的参数值可在conf/kylin.properties文件中进行配置；如果Cube需要覆盖全局设置的话，则需要在此页面中指定。单击“+Property”按钮，然后输入参数名和参数值。例如“kylin.hbase.region.cut=1”,这样此Cube在存储的时候，Kylin将会为每个HTbase Region分配1GB来创建一个HTbase Region。</p>\n<p>#构建Cube<br>新创建的Cube只有定义，而没有计算的数据，它的状态是”DISABLED“，是不会被查询引擎挑中的。要想让Cube有数据，还需要对它进行构建。Cube的构建方式通常有两种：全量构建和增量构建；两者的构建步骤是完全一样的，区别只在于构建时读取的数据源是全集还是子集。<br>Cube的构建包含如下步骤，由任务引擎来调度执行。<br>1）创建临时的Hive平表（从Hive读取数据）<br>2）计算各维度的不同值，并收集各Cuboid的统计数据。<br>3）创建并保存字典。<br>4）保存Cuboid统计信息。<br>5）创建HTable。<br>6）计算Cube（一轮或若干轮MapRecue）。<br>7）将Cube的计算结果转成HFile。<br>8）加载HFile到HBase。<br>9）更新Cube元数据。<br>10）垃圾回收。<br>以上步骤中，前5步是计算Cube而做的准备工作，例如遍历维度值来创建字典，对数据做统计秋估算以创建HTable等；第6）步是真正的Cube计算，取决于所使用的Cube算法，它可能是一轮MapRecue任务，也可能是N（在没有优化的情况下，N可以被视作是维度数）轮迭代的MapRecue。由于Cube运算的中间结果是以SequenceFile的格式存储在HDFS上的，所以为了导入到HBase中，还需要第7）步将这些结果转换成HFile（HBase文件存储格式）。第8）步通过使用HBase BulkLoad工具，将HFile导入到HBase集群，这一步完成之后，HTable就可以查询到数据了。第9）步更新Cube的数据，将此次构建 Segment的状态从”NEW“更新为”ＲＥＡＤＹ＂，表示已经可借查询了。最后一步，清理构建过程中生成的临时文件等垃圾，释放集群资源。　　<br>Monitor页面会显示当前项目下近期的构建任务。　　</p>\n<p>##全量构建和增量构建</p>\n<p>###全量构建</p>\n<p>###增量构建</p>\n<p>##历史数据刷新</p>\n<p>##合并</p>\n<p>#查询Cube</p>\n","site":{"data":{}},"excerpt":"","more":"<p>#Apache Kylin的工作原理<br>Apache Kylin的工作原理本质上是MOLAP（Multidimensional　Online　Analytical　Processing）Cube，也就是多维　立方体分析。这是数据分析中相当经典的理论，在关系数据库年代就已经有了广泛的应用，下面将其做简要的介绍。  </p>\n<p>##维度和度量<br>简单来讲，维度就是观察数据的角度。比如电商的销售数据，可以从时间的维度来观察，也可以进一步细化，从时间和地区的维度来观察。维度一般是一组离散的值，比如时间维度上的每一个独立的日期，或者商品维度上的每一件独立的商品。因此统计时可以把维度值 相同的记录聚合在一起，然后应用聚合函数做累加、平均、去重计数等聚合计算。  <img src=\"/images/hadoop/kylin/维度和度量的例子.jpg\" alt=\"&quot;维度和度量的例子&quot;\"></p>\n<p>度量就是被聚合的统计值，也是聚合运算的结果，它一般是连续的值，如图1-2中的销售额，抑或是销售商品的总件数据 。通过比较和测量试题，分析师可以对数据进行评估，比如今年的销售额相比去年有多大的增长，增长的速度是否达到预期，不同商品类别的增长比例是否合理等。  </p>\n<p>##Cube和Cuboid<br>有了维度和度量，一个数据表或数据模型上的所有字段就可以分类了，它们要么是维度，要么是度量（可以被聚合）。于是就有了根据维度和度量来做预计算的Cube理论。<br>给定一个数据模型，我们可以对其上的所有维度进行组合。对于N个维度来说，组合的所有可能共2的n次方种。对于每一种维度的组合，将度量做聚合运算，然后将运算的结果保存为一个物化视图，称为Cuboid。所有维度组合的Coboid作为一个整体，被称为Cube。所以简单来说一个Cube就是许多按维度聚合的物化视图的集合。<br>下面来举一个具体的例子。假定有一个电商的销售数据集，其中维度包括时间（Time）、商品（Item）、地点（Location）和供应商（Supplier），度量为销售额（GMV）。那么所有维度的组合就有2的4次方=16种，比如一维度（ID）的组合有[Time]、[Item]、[Location]、[Supplier]4种；二维度（3D）的组合有[Time,Item]、[Time，Location]、[Time,Supplier]、[Item,Location]、[Item,Supplier]、[Location,Supplier]6种；三维度（3D）的组合也有4种；最后零维度（0D）和四维度（4D）的组合各有1种，总共有16种组合。<br><img src=\"/images/hadoop/kylin/一个四维Cube的例子.jpg\" alt=\"&quot;一个四维Cube的例子&quot;\"></p>\n<p>计算Cuboid，即按维度来聚合销售额。如果用SQL语句来表达计算Cuboid[Time,Location]，那么SQL语句如下：<br>Select Time,Location,Sum(GMV) as GMV from Sales group by Time,Location.<br>将计算的结果保存为物化视图，所有Cuboid物化视图的总称是Cube。</p>\n<p>##工作原理<br>Apache Kylin的工作原理就是对数据模型做Cube预计算，并利用计算的结果加速查询，具体工作过程如下：<br>1）指定数据模型，定义维度和度量<br>2）预计算Cube，计算所有Cuboid并保存为物化视图。<br>3）执行查询时，读取Cuboid，运算，产生查询结果。<br>由于Kylin的查询过程不会扫描原始记录，而是通过预计算预先完成表的关联、聚合等复杂运算，并利用预计算的结果来执行查询，因此相比非预计算的查询技术，其速度一般要快一到两个数据级，并且这点在超磊的数据集上优势更加明显。当数据集达到千亿及至万亿级别时，Kylin的速度甚至可以超越其他非预计算技术1000倍以上。</p>\n<p>#技术架构<br>Apache Kylin系统可以分为在线查询和离线构建两部分，技术架构如下图所示，在线查询的模块主要处于上半区，而离线构建则处于下半区。<br><img src=\"/images/hadoop/kylin/Kylin的技术架构.jpg\" alt=\"&quot;Kylin的技术架构&quot;\">    </p>\n<p>我们首先看看离线构建的部分。从图1-4可以看出，数据源在左侧，目前主要是Hadoop Hive，保存着待分析的用户数据。根据元数据的字义，下方构建引擎从数据源抽取数据，并构建Cube。数据以关系表的形式输入，且必须符合星形模型（Star Schema）（更复杂的雪花模型在成文时还不支持，可以通过视图将雪花模型转化为星形模型，再使用Kylin）。MapRecue是当前主要的构建技术。构建后的Cube保存在右侧的存储引擎中，一般选用HBase作为存储。<br>完成了离线构建之后，用户可以从上方查询系统发送SQL进行查询分析。Kylin提供了各种Rest　API、ＪＤＢＣ／ＯＤＢＣ接口。无论从哪个接口进入，SQL最终都会来到Rest服务层，再转交给查询引擎进行处理。这里需要注意的是，SQL语句是基于数据源的关系模型书写的，而不是Cube。Kylin在设计时刻意对查询用户屏蔽了Cube的概念，分析师只需要理解简单的关系模型就可以使用Kylin，没有额外的学习门槛，传统的SQL应用也很容易迁移。查询引擎解析SQL，生成基于关系表的逻辑执行计划，然后将其转义为基于Cube的物理执行计划，最后查询预计算生成的Cube并产生结果。整个过程不会访问原始数据源。  </p>\n<p><strong>注意</strong>：对于查询引擎下方的路由选择，在最初设计时曾考虑过将Kylin不能执行查询引导去Hive中继续执行，但在实践后发现Hive与Kylin的速度差异过大，导致用户无法对查询的速度有一致的期望，很可能大多数据查询几秒内就返回结果了，而有些查询则要等几分钟到几十分钟，因此体验非常糟糕。最后这个路由功能在发行版中默认关闭。</p>\n<p>Apache Kylin 1.5版本引入了“可扩展架构”的概念。在图1-4中显示为三个粗虚框，表示的抽象层。可扩展指Kylin可以对其主要依赖的三个模块做任意的扩展和替换。Kylin的三大依赖模型分别是数据源、构建引擎和存储引擎。在设计之初，作为Hadoop家族 一员，这三者分别是Hive、MapRecue和HBase。但随着推广和使用的深入，渐渐有用户发现它们均存在不足之处。比如，实时分析可能会希望从Kafka导入数据而不是Hive；而Spark的迅速崛起，又使我们不得不考虑将MapRecue替换为Spark，以期大幅提高Cube的构建速度；至于HBase，它的读性能可能还不如Cassandra或Kudu等 。可见，是否可以将一种技术替换为另一种技术已成为一个常见的问题。于在1.5版本的系统架构进行了重构，将数据源、构建引擎、存储引擎三大依赖抽象为接口，而Hive、MapRecue、HBase只是默认实现。深度用户可以根据自己的需要做二次开发，将其中的一个或多个替换为更适合的技术。  </p>\n<p>#核心概念</p>\n<p>##数据仓库<br>数据仓库（Data Warehouse）是一种系统的资料储存理论，此理论强调的是利用某些特殊的资料储存方式，让所包含的资料特别有利于分析和处理，从而产生有价值的资讯，并可依此做出决策。<br>利用数据仓库的方式存放资料，具有一旦存入，便不会随时间发生变动的特性，此外，存入的资料必定包含时间属性，通常一个数据仓库中会含有大量的历史性资料，并且它可利用特定的分析方式，从其中发掘特定的资讯。</p>\n<p>##OLAP<br>OLAP（Online Analytical Process），联机分析处理，以多维度的方式分析数据，而且能够弹性地提供上卷（Roll-up）、下钻（Drill-down）和透视分析（Pivot）等操作，它呈现集成性决策信息的方法，多用于决策支持系统、商务智能或数据仓库。其主要的功能在于方便大规模数据分析及统计计算，可对决策提供参考和支持。与之相区别的是取机交易处理（OLTP），联机交易处理，更侧重于基本的、日常的事务处理，包括数据的增删改查。<br>OLAP需要以大量历史数据为基础，再配合时间点的差异，对多维度及汇整型的信息进行复杂的分析。<br>OLAP需要用户有主观的信息需求定义，因此系统效率较佳。<br>OLAP的概念，在实际应用中存在广义和狭义两种不同的理解方式。广义上的理解与字面上的意义相同，泛指一切不会对数据进行更新的分析处理。但更多的情况下OLAP被理解为其狭义上的含义，即与多维分析相关，基于立方体（Cube）计算而进行的分析。</p>\n<p>##BI<br>BI（Business Intelligence），即商务智能，指现代数据仓库技术、在线分析技术、数据挖掘和数据展现技术进行数据分析以实现商业价值。</p>\n<p>##维度和度量<br>维度和度量是数据分析中的两个基本的概念<br><strong>维度</strong>是指审视数据的角度，它通常是数据记录的一个属性，例如时间、地点等。<br><strong>度量</strong>是基于数据所计算出来的考量值；它通常是一个数值，如总销售额、不同的用户数等。分析人员往往要结合若干个维度来审查度量值，以便在其中找到变化规律。在一个SQL查询中，Group By的属性通常就是维度，而所计算的值则是度量。如下面的示例：<br>    select part_dt,lstg_iste_id,sum(price) as total_selled,count(distinct seller_id) as sellers from kylin_sales group by part_dt,lstg_site_id</p>\n<p>##事实表和维度表<br><strong>事实表</strong>（Fact Table）是指存储有事实记录的表，如系统日志、销售记录等；事实表的记录在不断地动态增长，所以它的体积通常远大于其他表。</p>\n<p><strong>维度表</strong>（Dimension Table）或维表，有时也称查找表（Lookup Table），是与事实表相对应的一种表；它保存了维度的属性值，可以跟事实表做关联；相当于将事实表上经常重复出现的属性抽取、规范出来用一张表进行管理。常见的维度表有：日期表（存储与日期对应的周、月、季度等属性）、地点表（包含国家、省、城市等属性）。使用维度表有诸多好处，具体如下：<br>a.缩小了事实表的大小<br>b.便于维度的管理和维护，增加、删除和修改维度的属性，不必对事实表的大量记录进行改动。<br>c.维度表可以为多个事实表重用，以减少重复工作。</p>\n<p>##Cube、Cuboid和Cube Segment</p>\n<p>###Cube<br>Cube（或Data Cube），即数据立方体，是一种常用于数据分析与索引的技术；它可以对原始数据建立多维度索引。通过Cube对数据进行分析，可以大大加快数据的查询效率。</p>\n<p>###Cuboid<br>Cuboid在Kylin中特指在某一种维度组合下所计算的数据。</p>\n<p>##Cube Segment<br>Cube Segment是指针对源数据中的某一片段，计算出来的Cube数据。通常数据仓库中的数据数量会随着时间的增长而增长，而Cube Segment也是按时间顺序来构建的。</p>\n<p>#在Hive中准备数据<br>这里介绍准备Hive数据的一些注意事项。需要被分析的数据必须先保存为Hive表的形式，然后Kylin才能从Hive中导入数据，创建Cube。<br>Hive是一个基于Hadoop的数据仓库工具，可以将结构化的数据文件映射为数据库表，并可以将SQL语句转换为MapRecue或Tez任务进行运行，从而让用户以类SQL（HiveQL，也称HQL）的方式管理和查询Hadoop上的海量数据。<br>此外，Hive还提供了多种方式（如命令行、API和Web服务等）可供第三方方便地获取和使用元数据并进行查询。今天，Hive已经成为Hadoop数据仓库的首选，是Hadoop上不可或缺的一个重要组件，很多项目都已兼容或集成了Hive。基于此情况，Kylin选择Hive作为原始数据的主要来源。<br>在Hive中准备待分析的数据是使用Kylin的前提；将数据导入到Hive表中的方法有很多，用户管理数据的技术和工具也各式各样，因此具体步骤不在本书的讨论范围之内。</p>\n<p>##星形模型<br>数据挖掘有几种常见的多维数据模型，如星形模型（Star Schema）、雪花模型（Snowf lake Schema）、事实星座模型（Fact Constellation）等。<br>星形模型中有一张事实表，以及零个或多个维度表；事实表与维度表通过主键外键相关联，维度表之间没有关联，就像很多星星围绕在一个恒星周围，帮取名为星形模型。<br>如果将星形模型中某些维度的表再做规范，抽取成更细的维度表，然后让维度表之间也进行关联，那么这种模型称为雪花模型。<br>星形模型是更复杂的模型，其中包含了多个事实表，而维度表是公用的，可以共享。<br>不过，Kylin只支持星形模型的数据集，这是基于以下考虑的。  </p>\n<ul>\n<li>星形模型是最简单，也是最常用的模型  </li>\n<li>由于星形模型只有一张大表，因此它相比于其它模型更适合于大数据处理  </li>\n<li>其他模型可以通过一定的转换，变成星形模型。  </li>\n</ul>\n<p>##维度表的设计<br>除了数据模型以外，Kylin还对维度表有一定的要求，具体要求如下。  </p>\n<ul>\n<li>要具有数据一致性，主键值必须是唯一的；Kylin会进行检查，如果有两行的主键值相同则会报错。</li>\n<li>维度越小越好，因为Kylin会将维度表加载到内存中供查询；过大的表不适合作为维度表，默认的阈值是300MB。  </li>\n<li>改变频率低，Kylin会在每次构建中试图重用维度表的快照，如果维度表经常改变的话，重用就会失效，这就会导致要经常对维度表创建快照。</li>\n<li>维度表最好不要是Hive视图（View），虽然在Kylin1.5.3中加入了对维度表是视图这种情况的支持，但每次都需要将视图进行物化，从而导致额外的时间开销。</li>\n</ul>\n<p>##Hive表分区<br>Hive支持多分区（Partition）。简单来说，一个分区就是一个文件目录，存储了特定的数据文件。当有新的数据生成的时候，可以将数据加载到指定的分区，读取数据的时候也可以指定分区。对于 SQL查询，如果查询中指定了分区列的属性条件，则Hive会智能地选择特定分区（也就是目录），从而避免全量数据的扫描，减少读写操作对集群的压力。<br>下面举的一组SQL演示了如何使用分区：  </p>\n<p>Hie&gt;create table invites(id int,name string) partitioned by(ds string) row format delimited fields terminated by ‘t’ stroed as textfile;<br>Hive&gt;load data local inpath ‘/user/hadoop/data.txt’ overwrite into table invites partition (ds=’2016-08-16’);<br>Hive&gt;select * from invites where ds = ‘2016-08-16’;<br>Kylin支持增量的Cube构建，通常是按时间属性来增量地从Hive表中抽取数据。如果Hive表正好是按此时间属性做分区的话，那么就可以利用到Hive分区的好处，每次在Hive构建的时候都可以直接跳过不相干的日期的数据，节省Cube构建的时间。这样的列在Kylin里也称为分割时间列（Partition Time Column），通常它应该也是Hive表的分区列。</p>\n<p>##了解维度的基数<br>维度的基数（Cardinality）指的是该维度在数据集中出现的不同值的个数；例如“国家”是一个维度，如果有200个不同的值，那么此维度的基数就是200.通常一个维度的基数会从几十到几万个不等，个别维度如“用户ID”的基数会超过百万甚至千万。基数超过一百万的维度通常称为超高维度（Ulta Hight Cardinality，UHC），需要引起设计者的注意。<br>Cube中所有维度的基数都可以体现Cube的复杂度，如果一个Cube中有好几个超高基数维度，那么这个Cube膨胀就会很高。在创建Cube前需要对所有维度的基数做一个了解，这样就可以帮助设计合理的Cube。计算基数有多种途径，最简单的方法就是让Hive执行一个count distinct的SQL查询；Kylin也提供计算基数的方法，在导入Hive表定义后可以看到每一个列的基数，参数名为Cardinality</p>\n<p>##Sample Data<br>如果需要快速体验Kylin，可以用Kylin自带的Sample Data。运行${KYLIN_HOME}/bin/sample.sh来导入Sample Data，然后就能按照下面的流程来创建模型和Cube。<br>具体请执行下面命令，将Sample Data导入到Hive数据库。<br>cd ${KYLIN_HOME}<br>bin/sample.sh<br>Sample Data测试的样例数据集总共仅1M左右，共计3张表，其中事实表有10000条数据。数据集是一个规范的星形模型结构，它总包含3个数据表：<br>KYLIN_SALES是事实表，保存了销售订单的明细信息。各列分别保存着卖家、商品、分类、订单金额、商品数据等信息，每一行对应着一笔交易订单。<br>KYLIN_CATEGORY_GROUPINGS是维表，保存了商品分类的详细介绍，例如商品分类名称等。<br>KYLIN_CAL_DT也是维表，保存了时间的扩展信息。如单个日期所在的年始、月始、周始、年份、月份等。<br>这3张表一起构成了整个星形模型。  </p>\n<p>#设计Cube<br>如果数据已经在Hive中准备好了，就可以开始创建Cube了。</p>\n<p>##导入Hive表定义<br>登陆Kylin的Web界面，创建新的或选择一个已有的项目之后，需要做的就是将Hive表的定义导入到Kylin中。<br>单击Web界面的Model-&gt;Data Source下的”Local Hive Table“图标，然后输入表的名称（可以一次导入多个表，以逗号分隔表名），单击按钮”Sync“，Kylin就会使用Hive的API从Hive中获取表的属性信息。<br>导入成功后，表的结构信息会以树状的形式显示在页面的左侧，可以单击展开或收缩。</p>\n<p>同时Kylin会在后台触发一个MapRecue任务，计算此表的每个列的基数。通常稍过几分钟后再刷新页面，就会看到显示出来 的基数信息Cardinality</p>\n<p>需要注意的是，这里Kylin对基数的计算方法采用的是HyperLogLog的近似算法，与精确值略有误差，只做参考值。</p>\n<p>##创建数据模型<br>有了表信息之后，就可以开始创建数据模型（Data Model）了。数据模型是Cube的基础，它主要用于描述一个星形模型。有了数据模型以后，定义Cube的时候就可以直接从此模型定义的表和列中进行选择了，省去重复指定连接（join）条件的步骤。基于一个数据模型还可以创建多个Cube，以方便减少用户的重复性工作。<br>在Kylin界面中”Models“页面中单击”New”-&gt;”New Model”，开始创建数据模型。</p>\n<p>接下来选择用作维度和度量的列。这里只是选择一个范围，不代表这些列将来一定要用作Cube 的维度或度量，你可以把所有可能会用到表都选进来，后续创建Cube的时候，将只能从这些列中进行选择。   </p>\n<p>选择维度列时，维度可以来自事实表或维度表<br>选择度量列时，度量只能来自事实表<br>最后一步，是为模型补充侵害时间列信息和过滤条件。如果此模型中的事实表记录是按时间增长的，那么可以指定一个日期/时间列作为模型的分割时间列，从而可以让Cube按此列做增量构建。</p>\n<p>过滤（Filter）条件是指，如果想把一些记录忽略掉，那么这里可以设置一个过滤条件。Kylin在向Hive请求源数据的时候，会带上此过滤条件。</p>\n<p>随后“Save”后，出现在“Model”的列表中。</p>\n<p>##创建Cube<br>单击“New”，选择“New Cube”，会开启一个包含若干步骤的向导。</p>\n<p>第一页，选择要使用的数据模型，并为此Cube输入一个唯一的名称（必需的）和描述（可选的）；这里还可以输入一个邮件通知列表，用于在构建完成或出错时收到通知。如果不想接收处于某些状态的通知，那么可以从“Notification Events”中将其去掉。</p>\n<p>第二页，选择Cube的维度。可以通过以下两个按钮来添加维度。<br><strong>“Add Mimension”</strong>：逐个添加维度，可以是普通维度也可以是衍生（Derived）维度。<br><strong>“Auto Generator”：</strong>批量选择并添加，让Kylin自动完成其它信息。<br>使用第一种方法的时候需要为每个维度起个名字，然后选择表和列。<br>如果是衍生维度的话，则必须是来自于某个维度表，一次可以选择多个列；由于这些列值都可以从该维度表的主键值中衍生出来，所以实际上只有主键列会被Cube加入计算。而在Kylin 的具体实现中，往往采用事实表上的外键替代主键进行计算和存储。但是在逻辑上可以认为衍生列来自于维度表的主键。<br>使用第二种方法，Kylin会用一个树状结构呈现出所有的列，用户只需要勾选所需要的列即可，Kylin会自动补充其他信息，从而方便用户的操作。请注意，在这里Kylin会把维度表上的列都创建成衍生维度，这也许不是最合适的，在这种情况下请使用第一种方法。</p>\n<p>第三页，创建度量。Kylin默认会创建一个Count(1)的度量。可以单击“+Measure”按钮来添加新度量。Kylin支持的度量有：SUM、MIN、MAX、COUNT、COUNT　DISTINCT、ＴＯＰ＿Ｎ、RAW等。请选择需要的度量类型，然后再选择适当的参数（通常为列名）</p>\n<p>重复上面的步骤，创建所需要的度量。Kylin可以支持在一个Cube中添加多达上百个度量；添加完成所有度量之后，单击“Next”。</p>\n<p>第四页，是关于Cube数据刷新的设置。在这里可以设置自动合并的阈值、数据保留的最短时间，以及第一个Segment的起点时间（如果Cube有分割时间列的话）。</p>\n<p>第五页，高级设置。在此页面上可以设置聚合组和Rowkey<br>Kylin默认会把所有的维度都放在同一个聚合中；如果维度数据较多（例如&gt;10），那么建议用户根据查询的习惯和模式，单击“New Aggregation Group+”，将维度分为多个聚合组。通过使用多个聚合组，可以大大降低Cube中的Cuboid数量。下面来举例说明，如果一个Cube有（M+N)个维度，那么默认它会有2的m+n次方个Cuboid；如果把这些维度分为两个不相交的聚合组，那么Cuboid的数量将被减少为2的m次方+2的n次方。<br>在单个聚合组中，可以对维度设置高级属性，例如Mandatory、Hierarchy、Joint等。这几个属性都是为了优化Cube的计算而设计的，了解这些属性的含义对日后更好地使用Cube至关重要。<br>Mandatory维度指的是那些总是会出现在where条件或Group By语句里的维度；通过将某个维度指定为Mandatory，Kylin就可以不用预计算那些不包含此维度的Cuboid，从而减少计算量。<br>Hierarchy是一组有层级关系的维度，例如：“国家”“省”“市”，这里的“国家”是高级的维度，“省”“市”依次是低级的维度。用户会按高级别维度进行查询，也会按低级别维度进行查询，但在查询低级别维度时，往往都会带上高级别维度的条件，而不会孤立地审视低级别维度的数据。例如，用户单击“国家”作为维度来查询汇总数据，也可能单击“国家”+“省”或者“国家”+“省”+“市”来查询，但是不会跨越国家直接Group By“省”或“市”。通过指定Hierarchy，Kylin可以省略不满足此模式的cuboid。<br>Joint是将多个维度组合成一个维度，其通常适用于如下两种情况。<br>1.总是会在一起查询的维度。<br>2.基数很低的维度<br>Kylin以Key-Value的方式将Cube存在到HBase中。HBase的key，也就是Rowkey，是由各维度的值拼接而成的；为了更高效地存储这些值，Kylin会对它们进行编码和压缩；每个维度均可以选择合适的编码（Encoding）方式，默认采用的是字典（Dictionary）编码技术；除了字典以外，还有整数（Int）和固定长度（Fixed Length）的编码。<br>字典编码是将此维度下所有值构建成一个从string到int的映射表；Kylin会将字典序列化保存，在Cube中存储int值，从而大大减小存储的大小。另外，字典是保持顺序的，即如果字符串A比字符串B大的话，那么A的编码后的int值也会比B编码后的值大；这样可以使得在HBase中进行比较查询的时候，依然使用编码后的值，而无需解码。</p>\n<p>字典非常适合于非固定长度的string类型值的维度，而且用户无需指定编码后的长度；但是由于使用字典需要维护一张映射表，因些如果此维度的基数很高，那么字典的大小就非常可观，从而不适合于加载到内存中，在这种情况下就要选择其他的编码方式了。Kylin中字典编码允许的基数上限默认是500万（由参数”kylin.dictioinary.max.cardinality”配置）。<br>整数（int）编码适合于对int或bigint类型的值进行编码，它无需额外存储，同时还可以支持很大的基数。用户需要根据值域选择编码的长度。例如有一个手机号码的维度，它是一个11位的数字，如13800138000，我们知道它大于2的31次方，但是小于2的39次方减1，那么使用int(5)即可满足要求，每个值占用5字节，比按字符存储（11字节）要少占一半以上的空间。  </p>\n<p>当上面几种编码方式都不适合的时候，就使用固定长度的编码了；此编码方式其实只是将原始值截断或补充成相同长度的一组字节，没有额外的转换，所以空间效率较差，通常只是作为一种权宜手段。<br>各维度在Rowkeys中的顺序，对于 查询的性能会产生较明显的影响。在这里用户可以根据查询的模式和习惯，通过拖拽的方式调整各个维度在Rowkeys上的顺序。通常的原则是，将过滤频率较高的列放置在过滤频率较低的列之前，将基数高的列放置在基数低的列之前。这样做的好处是，充分利用过滤条件来缩小在HBase中扫描的范围，从而提高查询的效率。<br>第五页，为Cube配置参数。和其他Hadoop工具一样，Kylin使用了很多配置参数以提高录活性，用户可以根据具体的环境、场景等配置不同的参数进行调优。Kylin全局的参数值可在conf/kylin.properties文件中进行配置；如果Cube需要覆盖全局设置的话，则需要在此页面中指定。单击“+Property”按钮，然后输入参数名和参数值。例如“kylin.hbase.region.cut=1”,这样此Cube在存储的时候，Kylin将会为每个HTbase Region分配1GB来创建一个HTbase Region。</p>\n<p>#构建Cube<br>新创建的Cube只有定义，而没有计算的数据，它的状态是”DISABLED“，是不会被查询引擎挑中的。要想让Cube有数据，还需要对它进行构建。Cube的构建方式通常有两种：全量构建和增量构建；两者的构建步骤是完全一样的，区别只在于构建时读取的数据源是全集还是子集。<br>Cube的构建包含如下步骤，由任务引擎来调度执行。<br>1）创建临时的Hive平表（从Hive读取数据）<br>2）计算各维度的不同值，并收集各Cuboid的统计数据。<br>3）创建并保存字典。<br>4）保存Cuboid统计信息。<br>5）创建HTable。<br>6）计算Cube（一轮或若干轮MapRecue）。<br>7）将Cube的计算结果转成HFile。<br>8）加载HFile到HBase。<br>9）更新Cube元数据。<br>10）垃圾回收。<br>以上步骤中，前5步是计算Cube而做的准备工作，例如遍历维度值来创建字典，对数据做统计秋估算以创建HTable等；第6）步是真正的Cube计算，取决于所使用的Cube算法，它可能是一轮MapRecue任务，也可能是N（在没有优化的情况下，N可以被视作是维度数）轮迭代的MapRecue。由于Cube运算的中间结果是以SequenceFile的格式存储在HDFS上的，所以为了导入到HBase中，还需要第7）步将这些结果转换成HFile（HBase文件存储格式）。第8）步通过使用HBase BulkLoad工具，将HFile导入到HBase集群，这一步完成之后，HTable就可以查询到数据了。第9）步更新Cube的数据，将此次构建 Segment的状态从”NEW“更新为”ＲＥＡＤＹ＂，表示已经可借查询了。最后一步，清理构建过程中生成的临时文件等垃圾，释放集群资源。　　<br>Monitor页面会显示当前项目下近期的构建任务。　　</p>\n<p>##全量构建和增量构建</p>\n<p>###全量构建</p>\n<p>###增量构建</p>\n<p>##历史数据刷新</p>\n<p>##合并</p>\n<p>#查询Cube</p>\n"},{"title":"Sonar代码审查-缺陷和修改","date":"2017-05-30T08:43:49.000Z","_content":"## Sonar代码审查-缺陷和修改\nResources should be closed\n资源未关闭，打开发现有两处用到的IO流没有关闭\n\nConditions should not unconditionally evaluate to \"TRUE\" or to \"FALSE\"\nif/else判断里出现了重复判断，比如在if(a>10)的执行体里面又判断if(a<0)，而后者肯定不会是true\n\nException handlers should preserve the original exception\n处理异常的时候应该保留原始的异常情况，不要直接来个catch(Exception e)了事\n\n Throwable.printStackTrace(...) should not be called\n不应该直接调用e.printStackTrace()，而是用Loggers来处理（就是打Log）。\n\nLoggers的优势是：Users are able to easily retrieve the logs.\nThe format of log messages is uniform and allow users to browse the logs easily.\nInstance methods should not write to \"static\" fields6\n不要用实例方法改变静态成员，理想情况下，静态变量只通过同步的静态方法来改变\n \n\"public static\" fields should be constant\n公共静态成员应该加上final，也就是public static final 一般不分家\n \nThread.run() and Runnable.run() should not be called directly\n不应该直接调用Thread和Runnaale对象的run方法，直接调用run会使得run方法执行在当前线程，失去了开启新线程的意义。但有时候可能会这样做，下面有个例子。\n \nGeneric exceptions should never be thrown\n不太理解，大意是说不要直接抛Error,RuntimeException/Throwable/Exception这样的通用的异常。我的具体应用是：throw new Error(\"Error copying database\")，给出的建议是：Define and throw a dedicated exception instead of using a generic one（定义并抛出一个专用的异常来代替一个通用的异常）\n \nClass variable fields should not have public accessibility\n类变量不要设置为public，而是设为private，再提供get和set方法。\n \nSections of code should not be \"commented out\"\n不要再注释中出现大量的代码段，会使代码可读性变差\n \nPackage declaration should match source file directory\n这个没理解，包的声明应该与源文件目录匹配。\n \nUtility classes should not have public constructors\n工具类不应该有公共的构造器，也就是说至少要有一个private的构造器，如果没有，默认的构造器是public的。\n \nThe diamond operator (\"<>\") should be used\n在定义集合的时候，等号右边的<>内不需要再写上元素类型，直接空着就行。\n \nLambdas and anonymous classes should not have too many lines\nLambdas表达式和匿名内部类不要写太多行，一般最多写20行。\n \nAnonymous inner classes containing only one method should become lambdas8\n只包含一个方法的匿名内部类应该写成Lambdas表达式的形式，增强代码可读性\n \nTry-with-resources should be used8\n用Try-with-resources的形式取代try/catch/finally的形式，这个有待于以后学习。\n```try(Connection con = getConnection()) {\n   try (PreparedStatement prep = con.prepareConnection(\"Update ...\")) {\n       //prep.doSomething();\n       //...\n       //etc\ncon.commit();\n   } catch (SQLException e) {\n       //any other actions necessary on failure\n       con.rollback();\n       //consider a re-throw, throwing a wrapping exception, etc\n   }\n}\n```\n \nMethods should not be empty\n不要写空方法，除非这种情况：An abstract class may have empty methods, in order to provide default implementations for child classes.\n \nSource files should not have any duplicated blocks\n源文件中不要出现任何重复的代码段或行或字符串等。没理解。\n \n\"switch case\" clauses should not have too many lines\n\"switch case\" 每个case里面的代码不要太长，太长的话可以考虑写个方法代替，主要是为了增强代码可读性\n \nNested blocks of code should not be left empty\n嵌套代码块不要是空的，比如 if( a > 0 ) {  doSomething()  } else { }，这时候应该把后面的else{}去掉。\n \nMethods should not be too complex\n方法不要太复杂，否则难以理解和维护。\n \nUnused private fields should be removed\n没有使用的private的成员变量应该移除掉。\n \nDead stores should be removed\n没有用到的本地变量或其他死存储应该移除掉，也就是写方法的时候，定义的变量如果后来发现根本用不到，要记得删掉那行代码。\n \n\"switch\" statements should end with a \"default\" clause\nswitch语句应该以default结束，这是一种defensive programming思想\n \nUnused method parameters should be removed\n没有用到的方法参数应该移除掉\n \nControl flow statements \"if\", \"for\", \"while\", \"switch\" and \"try\" should not be nested too deeply4\nif /for/while/try这样的嵌套不要太复杂\n \nUseless parentheses around expressions should be removed to prevent any misunderstanding3\n没有意义的括号不要随便加，以免造成误解，比如\"=\"两边对象类型是相同的，就不要强转。\n \n\"for\" loop stop conditions should be invariant\nfor循环的结果条件不能是变量，而应该是常量\n \n\"static\" members should be accessed statically\nstatic成员是与类、静态方法相联系的。\n \nCatches should be combined\n具体参考下面的18，我还没理解\n \nPrimitives should not be boxed just for \"String\" conversion\n不要使用 4+\" \"这样的方式将int值转变为字符串，而是使用 Integer.toString(4)这样的方式。\n就像Integer.parseInt(\"我是字符串\")这样，不要偷懒。\n \nClasses should not be empty\n不要写空类\n \nUnused local variables should be removed\n没有用到的本地变量要删掉\n \n\"entrySet()\" should be iterated when both the key and value are needed\n直接看英文更直接：When only the keys from a map are needed in a loop, iterating the keySet makes sense. But when both the key and the value are needed, it's more efficient to iterate theentrySet, which will give access to both the key and value, instead.\n也就是说，如果只需要Map的Key，那么直接iterate这个Map的keySet就可以了，但是如果Key和value都需要，就iterate这个Map。具体看下面的19.\n \nMethod parameters, caught exceptions and foreach variables should not be reassigned\n方法参数/捕获的异常/foreach的变量不应该被重新赋值。\n \nCollection.isEmpty() should be used to test for emptiness\n当判断集合是否为空的时候，不要使用if (myCollection.size() == 0) 这样的方式，而是使用if (myCollection.isEmpty()这样的方式，后者性能更高。\n \nStandard outputs should not be used directly to log anything\n标准输出不直接打印任何东西，也就是打log的时候，不要使用System.out.println(\"My Message\")这样的方式，而是使用logger.log(\"My Message\")这种方式。\n \nGeneric wildcard types should not be used in return parameters\n通配符不应该出现在返回声明中。比如这句：List <? extends Animal>getAnimals(){...}， 我们无法知道“是否可以把a Dog, a Cat 等加进去”，等之后用到这个方法的时候，我们没必要去考虑这种问题（前面引号里面的）。\n \nSynchronized classes Vector, Hashtable, Stack and StringBuffer should not be used1\n不要使用同步的Vector/HashTable/Stack/StringBuffer等。在早期，出于线程安全问题考虑，java API 提供了这些类。但是同步会极大影响性能，即使是在同一个线程中使用他们。\n通常可以这样取代：\n`ArrayList  or  LinkedList   instead of  Vector\nDeque  instead of  Stack\nHashMap  instead of  Hashtable\nStringBuilder  instead of  StringBuffer\nExit methods should not be called`\n尽量不要调用system.exit()方法。\n \nLocal Variables should not be declared and then immediately returned or thrown\n本地变量如果赋值之后直接return了，那就直接return本地变量的赋值语句。\n \nField names should comply with a naming convention\n命名要规范\n \nLocal variable and method parameter names should comply with a naming convention\n命名要规范\n \nString literals should not be duplicated5\n字符串不应该重复，如果多次用到同一字符串，建议将该字符串定义为字符串常量，再引用。\n \nReturn of boolean expressions should not be wrapped into an \"if-then-else\" statement3\n不要写if (  a > 4  ) {  return false  } else { return true }这样的代码，直接写return a > 4。\n \nStatic non-final field names should comply with a naming convention\n命名要规范\n \nModifiers should be declared in the correct order\n修饰符等要按约定俗成的顺序书写 ，例如，写成public static 而不是static public \n \nThe members of an interface declaration or class should appear in a pre-defined order2\n与前面的一个问题类似，根据Oracle定义的Java代码规范中，不同代码的出现位置应该如下所示：\nclass and instance variables--Constructors--Methods\n \nArray designators \"[]\" should be on the type, not the variable\n数组的括号要写在类型后面，而不是变量后面，例如 int[] a 而不是int a[]\n \nMultiple variables should not be declared on the same line1\n不要在同一行定义多个变量\n \n\"switch\" statements should have at least 3 \"case\" clauses\n当至少有3种或者3种以上的情况时，才考虑用switch，否则用if/else的形式。\n \nOverriding methods should do more than simply call the same method in the super class\n既然在子类中重写了父类的某个方法，那就再这个方法中做些与父类方法不同的事情，否则没必要重写。\n \nStatements should be on separate lines\n不要把这样的代码写在同一行：if(someCondition)    doSomething()；而是应该写成下面的形式\nif(someCondition) {\ndoSomething()\n} \nMethod names should comply with a naming convention1\n命名要规范 \n\"TODO\" tags should be handle    TODO标签要及时处理，该做的事情不要忘了做\n\n\n## 部分规则详细说明\n#### 1.The members of an interface declaration or class should appear in a pre-defined order\n正确的顺序如下所示：静态成员变量→成员变量→构造器→方法\n\n```public class Foo{\npublic static final int OPEN = 4;  //Class and instance variables\nprivate int field = 0;\npublic Foo() {...}    //Constructors\npublic boolean isTrue() {...}    //Methods\n}\n\n```\n#### 2.The diamond operator (\"<>\") should be used\nNoncompliant Code Example：不规范的示例\n\n```List<String>  strings = new ArrayList<String>();  // Noncompliant\nMap<String, List<Integer>> map = new HashMap<String, List<Integer>>();  // Noncompliant\nCompliant Solution ：规范的示例\nList<String> strings = new ArrayList<>();\nMap<String, List<Integer>> map = new HashMap<>();\n```\n\n#### 3.Sections of code should not be \"commented out\"\n代码片段不应该出现在注释中，这样会bloat程序，可读性变差\n`Programmers should not comment out code as it bloats programs and reduces readability.\nUnused code should be deleted and can be retrieved from source control history if required.`\n\n#### 4.Utility classes should not have public constructors\n工具类不应该有public的构造器，也就是工具类至少要定义一个non-public的构造器\nUtility classes, which are a collection of static members, are not meant to be instantiated. Even abstract utility classes, which can be extended, should not have public constructors.\nJava adds an implicit public constructor to every class which does not define at least one explicitly. Hence, at least one non-public constructor should be defined.\n\n```class StringUtils { // Noncompliant Code Example\n    public static String concatenate(String s1, String s2) {\n          return s1 + s2;\n    }\n}\n```\n\n\n```class StringUtils { //Compliant Solution\n    private StringUtils() {\n    }\n    public static String concatenate(String s1, String s2) {\n    return s1 + s2;\n    }\n}\n```\n#### 5.\"public static\" fields should be constant\n公共的静态成员应该加上final来修饰\nThere is no good reason to declare a field \"public\" and \"static\" without also declaring it \"final\". Most of the time this is a kludge to share a state among several objects. But with this approach, any object can do whatever it wants with the shared state, such as setting it to null.\npublic static Foo foo = new Foo();//不规范的\npublic static final Foo FOO = new Foo();//规范的\n\n6.Class variable fields should not have public accessibility\n\n```public class MyClass {\npublic static final int SOME_CONSTANT = 0;    // Compliant - constants are not checked\npublic String firstName;                      // Noncompliant\n}\n```\n\n\n```public class MyClass {\npublic static final int SOME_CONSTANT = 0;    // Compliant - constants are not checked\nprivate String firstName;                      // Compliant\npublic String getFirstName() {\nreturn firstName;\n}\npublic void setFirstName(String firstName) {\nthis.firstName = firstName;\n}\n}\n#### 7.Static non-final field names should comply with a naming convention\npublic final class MyClass {//Noncompliant Code Example\n      private static String foo_bar;\n}\nclass MyClass {//Compliant Solution\nprivate static String fooBar;\n}\n\n```\n\n#### 8.\"switch\" statements should have at least 3 \"case\" clauses\n当有3种或3种情况以上的时候，才用switch，否则用if/else\nswitch statements are useful when there are many different cases depending on the value of the same expression.\nFor just one or two cases however, the code will be more readable with if statements.\n\n#### 9.String literals should not be duplicated\n\n```prepare(\"action1\");     // Noncompliant - \"action1\" is duplicated 3 times\nexecute(\"action1\");\nrelease(\"action1\");\n\nprivate static final String ACTION_1 = \"action1\";  // Compliant\nprepare(ACTION_1);                                            // Compliant\nexecute(ACTION_1);\nrelease(ACTION_1);\n```\n\n\n#### 10.Return of boolean expressions should not be wrapped into an \"if-then-else” statement\nReplace this if-then-else statement by a single return statement\n\n```if (expression) {//Noncompliant Code Example\n      return true;\n} else {\n     return false;\n}\nreturn expression;//Compliant Solution\nreturn !!expression;\n```\n\n#### 11.Method parameters, caught exceptions and foreach variables should not be reassigned\n方法参数，捕获的异常，foreach里的变量，都不应该重新赋值\n\n```class MyClass {//Noncompliant Code Example：不规范代码示例\n    public String name;\n    public MyClass(String name) {\n            name = name;          // Noncompliant - useless identity assignment\n    }\n    public int add(int a, int b) {\n        a = a + b;                // Noncompliant\n        return a;                 // Seems like the parameter is returned as is, what is the point?\n   }\n    public static void main(String[] args) {\n        MyClass foo = new MyClass();\n        int a = 40;\n        int b = 2;\n        foo.add(a, b);                  // Variable \"a\" will still hold 40 after this call\n    }\n}\n\n```\n\n```class MyClass {//Compliant Solution：规范代码示例\n    public String name;\n    public MyClass(String name) {\n         this.name = name;              // Compliant\n    }\n    public int add(int a, int b) {\n        return a + b;                  // Compliant\n    }\n    public static void main(String[] args) {\n    MyClass foo = new MyClass();\n        int a = 40;\n        int b = 2;\n        foo.add(a, b);\n     }\n}\n```\n\n\n#### 12.Local Variables should not be declared and then immediately returned or thrown\nNoncompliant Code Example：不规范代码示例\n\n```public long computeDurationInMilliseconds() {\nlong duration = (((hours * 60) + minutes) * 60 + seconds ) * 1000 ;\nreturn duration;\n}\npublic void doSomething() {\nRuntimeException myException = new RuntimeException();\nthrow myException;\n}\n```\n\nCompliant Solution：规范代码示例\n\n```public long computeDurationInMilliseconds() {\nreturn (((hours * 60) + minutes) * 60 + seconds ) * 1000 ;\n}\npublic void doSomething() {\nthrow new RuntimeException();\n}\n```\n\n#### 13.Thread.run() and Runnable.run() should not be called directly\nThe purpose of theThread.run()andRunnable.run()methods is to execute code in a separate, dedicated thread. Calling those methods directly doesn't make sense because it causes their code to be executed in the current thread.\nThread和Runnable里面的run方法设计的目的是让run方法里面的代码在不同的线程中执行。如果直接调用\n```run方法，就会导致run方法里的代码在当前线程中执行，失去意义\nNoncompliant Code Example：不规范的代码示例\nThread myThread = new Thread(runnable);\nmyThread.run(); // Noncompliant\n\nCompliant Solution：规范代码示例\nThread myThread = new Thread(runnable);\nmyThread.start(); // Compliant\n```\n\n这部分内容为个人理解，可以略过\n但在有些情况，也会直接调用Runnable的run方法，\n下面这个postTaskSafely方法会保证task永远在主线程中执行\n\n```public static void postTaskInMainThread(Runnable task) {\n     int curThreadId= android.os.Process.myTid();//得到当前线程的id\n    if(curThreadId==getMainThreadId()) {// 如果当前线程是主线程\n            task.run();//直接执行\n    }else{// 如果当前线程不是主线程\n        getMainThreadHandler().post(task);//用主线程的Handler来post\n}\n```\n\n#### 14.Lambdas and anonymous classes should not have too many lines\nAnonymous classes and lambdas (with Java 8) are a very convenient and compact way to inject a behavior without having to create a dedicated class. But those anonymous inner classes and lambdas should be used only if the behavior to be injected can be defined in a few lines of code, otherwise the source code can quickly become unreadable.\nanonymous class number of lines ： at most 20\n\n#### 15.Resources should be closed：该关闭的一定记得关闭\nJava's garbage collection cannot be relied on to clean up everything. Specifically, connections, streams, files and other classes that implement theCloseableinterface or it's super-interface,AutoCloseable, must be manually closed after creation. Failure to do so will result in a resource leak which could bring first the application and then perhaps the box it's on to their knees.\nNoncompliant Code Example：不规范的代码示例\n   \n``` OutputStream stream = null;\n    try{\n        for (String property : propertyList) {\n        stream = new FileOutputStream(\"myfile.txt\");  // Noncompliant\n        // ...\n        }\n    }catch(Exception e){\n        // ...\n    }finally{\n        stream.close();  // Multiple streams were opened. Only the last is closed.\n    }\n\n```\nCompliant Solution：规范代码示例\n  \n```  OutputStream stream = null;\n    try{\n        stream = new FileOutputStream(\"myfile.txt\");\n        for (String property : propertyList) {\n            // ...\n        }\n   }catch(Exception e){\n        // ...\n   }finally{\n       stream.close();\n   }\n\n```\n#### 16.Exception handlers should preserve the original exception\nNoncompliant Code Example:不规范的代码示例\n// Noncompliant - exception is lost\ntry { /* ... */ } catch (Exception e) { LOGGER.info(\"context\"); }\n// Noncompliant - exception is lost (only message is preserved)\ntry { /* ... */ } catch (Exception e) { LOGGER.info(e.getMessage()); }\n// Noncompliant - exception is lost\ntry { /* ... */ } catch (Exception e) { throw new RuntimeException(\"context\"); }\n\nCompliant Solution:规范的代码示例\n\n```try { /* ... */ } catch (Exception e) { LOGGER.info(e); }\ntry { /* ... */ } catch (Exception e) { throw new RuntimeException(e); }\ntry {\n/* ... */\n} catch (RuntimeException e) {\ndoSomething();\nthrow e;\n} catch (Exception e) {\n// Conversion into unchecked exception is also allowed\nthrow new RuntimeException(e);\n}\n\n```\n\n#### 17.Catches should be combined\nSince Java 7 it has been possible to catch multiple exceptions at once. Therefore, when multiplecatchblocks have the same code, they should be combined for better readability.\nNote that this rule is automatically disabled when the project'ssonar.java.sourceis lower than7.\n\n\nNoncompliant Code Example：不规范代码示例\n\n```catch (IOException e) {\n    doCleanup();\n    logger.log(e);\n}catch (SQLException e) { //Noncompliant\n    doCleanup();\n    logger.log(e);\n }catch (TimeoutException e) {  // Compliant; block contents are different\n     doCleanup();\n     throw e;\n }\n\n```\nCompliant Solution：规范代码示例\n\n```catch (IOException|SQLException e) {\n    doCleanup();\n    logger.log(e);\n }catch (TimeoutException e) {\n    doCleanup();\n    throw e;\n}\n```\n18.\"entrySet()\" should be iterated when both the key and value are needed\nNoncompliant Code Example：不规范的代码示例\n\n```public void doSomethingWithMap(Map map) {\nfor (String key : map.keySet()) {  // Noncompliant; for each key the value is retrieved\nObject value = map.get(key);\n// ...\n}   \n}   \n\n```\nCompliant SolutionL：规范代码示例\n\n```public void doSomethingWithMap(Map map) {\nfor (Map.Entry entry : map.entrySet()) {\nString key = entry.getKey();\nObject value = entry.getValue();\n// ...\n}   \n}   \n```\n\nUse a logger to log this exception\nYou should probably clarify which logger are you using.\n\norg.apache.commons.logging.Log interface has method void error(Object message, Throwable t) (and method void info(Object message, Throwable t)), which logs the stack trace together with your custom message. Log4J implementation has this method too.\n\nSo, probably you need to write:\nlogger.error(\"BOOM!\", e);\nIf you need to log it with INFO level (though, it might be a strange use case), then:\nlogger.info(\"Just a stack trace, nothing to worry about\", e);\nHope it helps.\n\nRename 'i' as this name is already used in declaration at line 26\n\n## 阻断\n\n#### 1、Close this\"FileInputStream\" in a \"finally\" clause.\n在finally中关闭FileInputStream，这个最为常见，主要是关闭方式不对，finally代码块中，应该要对每个stream进行单独关闭，而不能统一写在一个try-catch代码中，jdk 7 可以考虑try-resources方式关闭，代码相对优雅。\n另外数据库操作的statement和resultRs没有关闭的情况也非常多。这个也是要重点留意的地方。\n\n#### 2、A\"NullPointerException\" could be thrown; \"tom\" is nullablehere\n空指针，极为讨厌的问题，主要是编码经验缺少的体现。一般的高手在编码过程中，就会第一时间考虑到这类情况，并做相应的处理。解决方式无它，先判断或者先实例化，再访问里面的属性或者成员。\n\n## 严重\n#### 1、Define and throw a dedicated exception instead of using a generic one\n定义并抛出一个专用的异常来代替一个通用的异常。\n#### 2、Removethis hard-coded password\n移除代码里硬编码的密码信息。会有少许的误判的情况，一般是变量包含：PWD或者password，所以如果真的不是硬编码，可以考虑更换变量名称，比如PWD改PW等等。\n#### 3、Eitherlog or rethrow this exception\ncatch异常之后，使用log方式或者throw异常的方式解决。如果业务上真的没有throw或者记录日志的话，可以使用log.debug的方式填充来解决问题。\n\n#### 4、Makethis IP \"127.0.0.1\" address configurable\n将IP弄到配置文件中，不要硬编码到代码里。个人觉得改动稍大！\n#### 5、Make this\"public static JSAPI\" field final\n如果你将这个变量设置为public访问方式，同时又是静态Static方式，就要考虑将它设置为final了，因为这个是共享变量，其它类可以随时随地将它设置为别的值。所以如果是只是当前类使用，可以考虑将公开访问方式改为私有。\n#### 6、Makethe enclosing method \"static\" or remove this set\n见代码：\n\n```public class MyClass {\n  private static int count = 0;\n  public void doSomething() {\n    //...\n    count++;  // Noncompliant\n  }\n}\n\n```不要使用非静态方法去更新静态字段，这样很难获得正确的结果，如果有多个类实例和/或多个线程，则很容易导致错误。理想情况下，静态字段仅从同步静态方法中更新。\n#### 7、Override\"equals(Object obj)\" to comply with the contract of the\"compareTo(T o)\" method\n如果重写了compareTo方法，同时也应重写equals方法。\n#### 8、Make\"body\" transient or serializable.\n\n```public class Address {\n  //...\n}\npublic class Person implements Serializable {\n  private static final long serialVersionUID = 1905122041950251207L;\n  private String name;\n\n  private Address address;  // Noncompliant; Address isn't serializable\n}\n\n```\n如果person已经序列化，其成员变量Address也进行序列化。不然转化时会有问题。\n#### 9 Floating point numbers should not be tested for equality\n\n浮点类型的数字，不要通过==或者!=方式其它类型比较，因为浮点是不精确的，所以在比较时，会进行类型升级升级原则如下：\n·  如果运算符任意一方的类型为double，则另一方会转换为double\n·  否则，如果运算符任意一方的类型为float，则另一方会转换为float\n·  否则，如果运算符任意一方的类型为long，则另一方会转换为long\n·  否则，两边都会转换为int\n \n\n以下的方式得到的结果都是false。\n\n```\nfloat myNumber = 3.146;\nif ( myNumber == 3.146f ) { //Noncompliant. Because of floating point imprecision, this will be false\n \nif ( myNumber != 3.146f ) { //Noncompliant. Because of floating point imprecision, this will be true\nif (myNumber < 4 || myNumber > 4) { // Noncompliant; indirect  \nfloat zeroFloat = 0.0f;\nif (zeroFloat == 0) {  // Noncompliant. Computations may end up with a value close but not equal to zero.\n}\n \n```\n\n所以，要比较浮点数是否相等，需要做的事情是：\n\n    排除NaN和无穷\n\n    在精度范围内进行比较\n\n正确的例子：\n\n\n```public boolean isEqual(double a, double b) {\n    if (Double.isNaN(a) || Double.isNaN(b) || Double.isInfinite(a) || Double.isInfinite(b)) {\n       return false;\n    }\n    return (a - b) < 0.001d;\n}\n```\n\n \n\n#### 10、Thiscall to \"contains()\" may be a performance hot spot if the collectionis large.\n如果collection的记录数非常大的话，它的contains方法的时间复杂度是很高的。所以开发过程中要注意这一点。下面的是列表：\n\n\n```·  ArrayList\n\ncontains\nremove\n·  LinkedList\n\nget\ncontains\n·  ConcurrentLinkedQueue\n\nsize\ncontains\n·  ConcurrentLinkedDeque\n\nsize\ncontains\n·  CopyOnWriteArrayList\n\nadd\ncontains\nremove\n·  CopyOnWriteArraySet\n\nadd\ncontains\nremove\n\n```\n\n##### 1.Equality tests should not be made with floating point value\n　　代码举例： if (result == num) //result和num均为double 之间比较会有精度损失\n　　解决：BigDecimal data1 = new BigDecimal(totalArea);\n　　　　　BigDecimal data2 = new BigDecimal(s1);\n　　　　    int num = data1.compareTo(data2);//num =0 相等  >0前者大于后者 ，反之 <0 前者小于后者\n##### 2.This class overrides \"equals()\" and should therefore also override \"hashCode()\".　\n　　代码举例：public boolean equals(Object obj){...}  //需要添加对应的hashCode方法\n　　解决：可以添加一个最简单的hashCode方法　　\n　　　　　public int hashCode() {return 0;}　　　\n##### 3.Synchronize on a new \"Object\" instead\n　　代码举例：synchronized (\"实例化\") {...}   //里边必须是对象\n　　解决： private Object obj =\"实例化\"；\n　　　　　synchronized (obj ) {...}\n##### 4.Close this\"FileInputStream\" in a \"finally\" clause.\n　　解决方法: 在finally中关闭FileInputStream，主要是关闭方式不对，finally代码块中，应该要对每个stream进行单独关闭，而不能统一写在一个try-catch代码中。\n\n##### 5.A\"NullPointerException\" could be thrown; \"tom\" is nullablehere\n　　空指针，解决方式：先判断或者先实例化，再访问里面的属性或者成员。\n##### 6.Makethis IP \"127.0.0.1\" address configurable\n　　解决方法:不要把IP地址写在此类中，应该在对应的系统文件或者相应的配置文件中配置\n##### 7.Either log or rethrow this exception.\n　　解决方法: 把对应的输出写成Logger.error(\"aaa“);的形式 \n\n\n\n\n\n\n","source":"_posts/review/Sonar代码审查-缺陷和修改.md","raw":"---\ntitle: Sonar代码审查-缺陷和修改\ndate: 2017-05-30 16:43:49\ntags: [review]\ncategories: [review]\n---\n## Sonar代码审查-缺陷和修改\nResources should be closed\n资源未关闭，打开发现有两处用到的IO流没有关闭\n\nConditions should not unconditionally evaluate to \"TRUE\" or to \"FALSE\"\nif/else判断里出现了重复判断，比如在if(a>10)的执行体里面又判断if(a<0)，而后者肯定不会是true\n\nException handlers should preserve the original exception\n处理异常的时候应该保留原始的异常情况，不要直接来个catch(Exception e)了事\n\n Throwable.printStackTrace(...) should not be called\n不应该直接调用e.printStackTrace()，而是用Loggers来处理（就是打Log）。\n\nLoggers的优势是：Users are able to easily retrieve the logs.\nThe format of log messages is uniform and allow users to browse the logs easily.\nInstance methods should not write to \"static\" fields6\n不要用实例方法改变静态成员，理想情况下，静态变量只通过同步的静态方法来改变\n \n\"public static\" fields should be constant\n公共静态成员应该加上final，也就是public static final 一般不分家\n \nThread.run() and Runnable.run() should not be called directly\n不应该直接调用Thread和Runnaale对象的run方法，直接调用run会使得run方法执行在当前线程，失去了开启新线程的意义。但有时候可能会这样做，下面有个例子。\n \nGeneric exceptions should never be thrown\n不太理解，大意是说不要直接抛Error,RuntimeException/Throwable/Exception这样的通用的异常。我的具体应用是：throw new Error(\"Error copying database\")，给出的建议是：Define and throw a dedicated exception instead of using a generic one（定义并抛出一个专用的异常来代替一个通用的异常）\n \nClass variable fields should not have public accessibility\n类变量不要设置为public，而是设为private，再提供get和set方法。\n \nSections of code should not be \"commented out\"\n不要再注释中出现大量的代码段，会使代码可读性变差\n \nPackage declaration should match source file directory\n这个没理解，包的声明应该与源文件目录匹配。\n \nUtility classes should not have public constructors\n工具类不应该有公共的构造器，也就是说至少要有一个private的构造器，如果没有，默认的构造器是public的。\n \nThe diamond operator (\"<>\") should be used\n在定义集合的时候，等号右边的<>内不需要再写上元素类型，直接空着就行。\n \nLambdas and anonymous classes should not have too many lines\nLambdas表达式和匿名内部类不要写太多行，一般最多写20行。\n \nAnonymous inner classes containing only one method should become lambdas8\n只包含一个方法的匿名内部类应该写成Lambdas表达式的形式，增强代码可读性\n \nTry-with-resources should be used8\n用Try-with-resources的形式取代try/catch/finally的形式，这个有待于以后学习。\n```try(Connection con = getConnection()) {\n   try (PreparedStatement prep = con.prepareConnection(\"Update ...\")) {\n       //prep.doSomething();\n       //...\n       //etc\ncon.commit();\n   } catch (SQLException e) {\n       //any other actions necessary on failure\n       con.rollback();\n       //consider a re-throw, throwing a wrapping exception, etc\n   }\n}\n```\n \nMethods should not be empty\n不要写空方法，除非这种情况：An abstract class may have empty methods, in order to provide default implementations for child classes.\n \nSource files should not have any duplicated blocks\n源文件中不要出现任何重复的代码段或行或字符串等。没理解。\n \n\"switch case\" clauses should not have too many lines\n\"switch case\" 每个case里面的代码不要太长，太长的话可以考虑写个方法代替，主要是为了增强代码可读性\n \nNested blocks of code should not be left empty\n嵌套代码块不要是空的，比如 if( a > 0 ) {  doSomething()  } else { }，这时候应该把后面的else{}去掉。\n \nMethods should not be too complex\n方法不要太复杂，否则难以理解和维护。\n \nUnused private fields should be removed\n没有使用的private的成员变量应该移除掉。\n \nDead stores should be removed\n没有用到的本地变量或其他死存储应该移除掉，也就是写方法的时候，定义的变量如果后来发现根本用不到，要记得删掉那行代码。\n \n\"switch\" statements should end with a \"default\" clause\nswitch语句应该以default结束，这是一种defensive programming思想\n \nUnused method parameters should be removed\n没有用到的方法参数应该移除掉\n \nControl flow statements \"if\", \"for\", \"while\", \"switch\" and \"try\" should not be nested too deeply4\nif /for/while/try这样的嵌套不要太复杂\n \nUseless parentheses around expressions should be removed to prevent any misunderstanding3\n没有意义的括号不要随便加，以免造成误解，比如\"=\"两边对象类型是相同的，就不要强转。\n \n\"for\" loop stop conditions should be invariant\nfor循环的结果条件不能是变量，而应该是常量\n \n\"static\" members should be accessed statically\nstatic成员是与类、静态方法相联系的。\n \nCatches should be combined\n具体参考下面的18，我还没理解\n \nPrimitives should not be boxed just for \"String\" conversion\n不要使用 4+\" \"这样的方式将int值转变为字符串，而是使用 Integer.toString(4)这样的方式。\n就像Integer.parseInt(\"我是字符串\")这样，不要偷懒。\n \nClasses should not be empty\n不要写空类\n \nUnused local variables should be removed\n没有用到的本地变量要删掉\n \n\"entrySet()\" should be iterated when both the key and value are needed\n直接看英文更直接：When only the keys from a map are needed in a loop, iterating the keySet makes sense. But when both the key and the value are needed, it's more efficient to iterate theentrySet, which will give access to both the key and value, instead.\n也就是说，如果只需要Map的Key，那么直接iterate这个Map的keySet就可以了，但是如果Key和value都需要，就iterate这个Map。具体看下面的19.\n \nMethod parameters, caught exceptions and foreach variables should not be reassigned\n方法参数/捕获的异常/foreach的变量不应该被重新赋值。\n \nCollection.isEmpty() should be used to test for emptiness\n当判断集合是否为空的时候，不要使用if (myCollection.size() == 0) 这样的方式，而是使用if (myCollection.isEmpty()这样的方式，后者性能更高。\n \nStandard outputs should not be used directly to log anything\n标准输出不直接打印任何东西，也就是打log的时候，不要使用System.out.println(\"My Message\")这样的方式，而是使用logger.log(\"My Message\")这种方式。\n \nGeneric wildcard types should not be used in return parameters\n通配符不应该出现在返回声明中。比如这句：List <? extends Animal>getAnimals(){...}， 我们无法知道“是否可以把a Dog, a Cat 等加进去”，等之后用到这个方法的时候，我们没必要去考虑这种问题（前面引号里面的）。\n \nSynchronized classes Vector, Hashtable, Stack and StringBuffer should not be used1\n不要使用同步的Vector/HashTable/Stack/StringBuffer等。在早期，出于线程安全问题考虑，java API 提供了这些类。但是同步会极大影响性能，即使是在同一个线程中使用他们。\n通常可以这样取代：\n`ArrayList  or  LinkedList   instead of  Vector\nDeque  instead of  Stack\nHashMap  instead of  Hashtable\nStringBuilder  instead of  StringBuffer\nExit methods should not be called`\n尽量不要调用system.exit()方法。\n \nLocal Variables should not be declared and then immediately returned or thrown\n本地变量如果赋值之后直接return了，那就直接return本地变量的赋值语句。\n \nField names should comply with a naming convention\n命名要规范\n \nLocal variable and method parameter names should comply with a naming convention\n命名要规范\n \nString literals should not be duplicated5\n字符串不应该重复，如果多次用到同一字符串，建议将该字符串定义为字符串常量，再引用。\n \nReturn of boolean expressions should not be wrapped into an \"if-then-else\" statement3\n不要写if (  a > 4  ) {  return false  } else { return true }这样的代码，直接写return a > 4。\n \nStatic non-final field names should comply with a naming convention\n命名要规范\n \nModifiers should be declared in the correct order\n修饰符等要按约定俗成的顺序书写 ，例如，写成public static 而不是static public \n \nThe members of an interface declaration or class should appear in a pre-defined order2\n与前面的一个问题类似，根据Oracle定义的Java代码规范中，不同代码的出现位置应该如下所示：\nclass and instance variables--Constructors--Methods\n \nArray designators \"[]\" should be on the type, not the variable\n数组的括号要写在类型后面，而不是变量后面，例如 int[] a 而不是int a[]\n \nMultiple variables should not be declared on the same line1\n不要在同一行定义多个变量\n \n\"switch\" statements should have at least 3 \"case\" clauses\n当至少有3种或者3种以上的情况时，才考虑用switch，否则用if/else的形式。\n \nOverriding methods should do more than simply call the same method in the super class\n既然在子类中重写了父类的某个方法，那就再这个方法中做些与父类方法不同的事情，否则没必要重写。\n \nStatements should be on separate lines\n不要把这样的代码写在同一行：if(someCondition)    doSomething()；而是应该写成下面的形式\nif(someCondition) {\ndoSomething()\n} \nMethod names should comply with a naming convention1\n命名要规范 \n\"TODO\" tags should be handle    TODO标签要及时处理，该做的事情不要忘了做\n\n\n## 部分规则详细说明\n#### 1.The members of an interface declaration or class should appear in a pre-defined order\n正确的顺序如下所示：静态成员变量→成员变量→构造器→方法\n\n```public class Foo{\npublic static final int OPEN = 4;  //Class and instance variables\nprivate int field = 0;\npublic Foo() {...}    //Constructors\npublic boolean isTrue() {...}    //Methods\n}\n\n```\n#### 2.The diamond operator (\"<>\") should be used\nNoncompliant Code Example：不规范的示例\n\n```List<String>  strings = new ArrayList<String>();  // Noncompliant\nMap<String, List<Integer>> map = new HashMap<String, List<Integer>>();  // Noncompliant\nCompliant Solution ：规范的示例\nList<String> strings = new ArrayList<>();\nMap<String, List<Integer>> map = new HashMap<>();\n```\n\n#### 3.Sections of code should not be \"commented out\"\n代码片段不应该出现在注释中，这样会bloat程序，可读性变差\n`Programmers should not comment out code as it bloats programs and reduces readability.\nUnused code should be deleted and can be retrieved from source control history if required.`\n\n#### 4.Utility classes should not have public constructors\n工具类不应该有public的构造器，也就是工具类至少要定义一个non-public的构造器\nUtility classes, which are a collection of static members, are not meant to be instantiated. Even abstract utility classes, which can be extended, should not have public constructors.\nJava adds an implicit public constructor to every class which does not define at least one explicitly. Hence, at least one non-public constructor should be defined.\n\n```class StringUtils { // Noncompliant Code Example\n    public static String concatenate(String s1, String s2) {\n          return s1 + s2;\n    }\n}\n```\n\n\n```class StringUtils { //Compliant Solution\n    private StringUtils() {\n    }\n    public static String concatenate(String s1, String s2) {\n    return s1 + s2;\n    }\n}\n```\n#### 5.\"public static\" fields should be constant\n公共的静态成员应该加上final来修饰\nThere is no good reason to declare a field \"public\" and \"static\" without also declaring it \"final\". Most of the time this is a kludge to share a state among several objects. But with this approach, any object can do whatever it wants with the shared state, such as setting it to null.\npublic static Foo foo = new Foo();//不规范的\npublic static final Foo FOO = new Foo();//规范的\n\n6.Class variable fields should not have public accessibility\n\n```public class MyClass {\npublic static final int SOME_CONSTANT = 0;    // Compliant - constants are not checked\npublic String firstName;                      // Noncompliant\n}\n```\n\n\n```public class MyClass {\npublic static final int SOME_CONSTANT = 0;    // Compliant - constants are not checked\nprivate String firstName;                      // Compliant\npublic String getFirstName() {\nreturn firstName;\n}\npublic void setFirstName(String firstName) {\nthis.firstName = firstName;\n}\n}\n#### 7.Static non-final field names should comply with a naming convention\npublic final class MyClass {//Noncompliant Code Example\n      private static String foo_bar;\n}\nclass MyClass {//Compliant Solution\nprivate static String fooBar;\n}\n\n```\n\n#### 8.\"switch\" statements should have at least 3 \"case\" clauses\n当有3种或3种情况以上的时候，才用switch，否则用if/else\nswitch statements are useful when there are many different cases depending on the value of the same expression.\nFor just one or two cases however, the code will be more readable with if statements.\n\n#### 9.String literals should not be duplicated\n\n```prepare(\"action1\");     // Noncompliant - \"action1\" is duplicated 3 times\nexecute(\"action1\");\nrelease(\"action1\");\n\nprivate static final String ACTION_1 = \"action1\";  // Compliant\nprepare(ACTION_1);                                            // Compliant\nexecute(ACTION_1);\nrelease(ACTION_1);\n```\n\n\n#### 10.Return of boolean expressions should not be wrapped into an \"if-then-else” statement\nReplace this if-then-else statement by a single return statement\n\n```if (expression) {//Noncompliant Code Example\n      return true;\n} else {\n     return false;\n}\nreturn expression;//Compliant Solution\nreturn !!expression;\n```\n\n#### 11.Method parameters, caught exceptions and foreach variables should not be reassigned\n方法参数，捕获的异常，foreach里的变量，都不应该重新赋值\n\n```class MyClass {//Noncompliant Code Example：不规范代码示例\n    public String name;\n    public MyClass(String name) {\n            name = name;          // Noncompliant - useless identity assignment\n    }\n    public int add(int a, int b) {\n        a = a + b;                // Noncompliant\n        return a;                 // Seems like the parameter is returned as is, what is the point?\n   }\n    public static void main(String[] args) {\n        MyClass foo = new MyClass();\n        int a = 40;\n        int b = 2;\n        foo.add(a, b);                  // Variable \"a\" will still hold 40 after this call\n    }\n}\n\n```\n\n```class MyClass {//Compliant Solution：规范代码示例\n    public String name;\n    public MyClass(String name) {\n         this.name = name;              // Compliant\n    }\n    public int add(int a, int b) {\n        return a + b;                  // Compliant\n    }\n    public static void main(String[] args) {\n    MyClass foo = new MyClass();\n        int a = 40;\n        int b = 2;\n        foo.add(a, b);\n     }\n}\n```\n\n\n#### 12.Local Variables should not be declared and then immediately returned or thrown\nNoncompliant Code Example：不规范代码示例\n\n```public long computeDurationInMilliseconds() {\nlong duration = (((hours * 60) + minutes) * 60 + seconds ) * 1000 ;\nreturn duration;\n}\npublic void doSomething() {\nRuntimeException myException = new RuntimeException();\nthrow myException;\n}\n```\n\nCompliant Solution：规范代码示例\n\n```public long computeDurationInMilliseconds() {\nreturn (((hours * 60) + minutes) * 60 + seconds ) * 1000 ;\n}\npublic void doSomething() {\nthrow new RuntimeException();\n}\n```\n\n#### 13.Thread.run() and Runnable.run() should not be called directly\nThe purpose of theThread.run()andRunnable.run()methods is to execute code in a separate, dedicated thread. Calling those methods directly doesn't make sense because it causes their code to be executed in the current thread.\nThread和Runnable里面的run方法设计的目的是让run方法里面的代码在不同的线程中执行。如果直接调用\n```run方法，就会导致run方法里的代码在当前线程中执行，失去意义\nNoncompliant Code Example：不规范的代码示例\nThread myThread = new Thread(runnable);\nmyThread.run(); // Noncompliant\n\nCompliant Solution：规范代码示例\nThread myThread = new Thread(runnable);\nmyThread.start(); // Compliant\n```\n\n这部分内容为个人理解，可以略过\n但在有些情况，也会直接调用Runnable的run方法，\n下面这个postTaskSafely方法会保证task永远在主线程中执行\n\n```public static void postTaskInMainThread(Runnable task) {\n     int curThreadId= android.os.Process.myTid();//得到当前线程的id\n    if(curThreadId==getMainThreadId()) {// 如果当前线程是主线程\n            task.run();//直接执行\n    }else{// 如果当前线程不是主线程\n        getMainThreadHandler().post(task);//用主线程的Handler来post\n}\n```\n\n#### 14.Lambdas and anonymous classes should not have too many lines\nAnonymous classes and lambdas (with Java 8) are a very convenient and compact way to inject a behavior without having to create a dedicated class. But those anonymous inner classes and lambdas should be used only if the behavior to be injected can be defined in a few lines of code, otherwise the source code can quickly become unreadable.\nanonymous class number of lines ： at most 20\n\n#### 15.Resources should be closed：该关闭的一定记得关闭\nJava's garbage collection cannot be relied on to clean up everything. Specifically, connections, streams, files and other classes that implement theCloseableinterface or it's super-interface,AutoCloseable, must be manually closed after creation. Failure to do so will result in a resource leak which could bring first the application and then perhaps the box it's on to their knees.\nNoncompliant Code Example：不规范的代码示例\n   \n``` OutputStream stream = null;\n    try{\n        for (String property : propertyList) {\n        stream = new FileOutputStream(\"myfile.txt\");  // Noncompliant\n        // ...\n        }\n    }catch(Exception e){\n        // ...\n    }finally{\n        stream.close();  // Multiple streams were opened. Only the last is closed.\n    }\n\n```\nCompliant Solution：规范代码示例\n  \n```  OutputStream stream = null;\n    try{\n        stream = new FileOutputStream(\"myfile.txt\");\n        for (String property : propertyList) {\n            // ...\n        }\n   }catch(Exception e){\n        // ...\n   }finally{\n       stream.close();\n   }\n\n```\n#### 16.Exception handlers should preserve the original exception\nNoncompliant Code Example:不规范的代码示例\n// Noncompliant - exception is lost\ntry { /* ... */ } catch (Exception e) { LOGGER.info(\"context\"); }\n// Noncompliant - exception is lost (only message is preserved)\ntry { /* ... */ } catch (Exception e) { LOGGER.info(e.getMessage()); }\n// Noncompliant - exception is lost\ntry { /* ... */ } catch (Exception e) { throw new RuntimeException(\"context\"); }\n\nCompliant Solution:规范的代码示例\n\n```try { /* ... */ } catch (Exception e) { LOGGER.info(e); }\ntry { /* ... */ } catch (Exception e) { throw new RuntimeException(e); }\ntry {\n/* ... */\n} catch (RuntimeException e) {\ndoSomething();\nthrow e;\n} catch (Exception e) {\n// Conversion into unchecked exception is also allowed\nthrow new RuntimeException(e);\n}\n\n```\n\n#### 17.Catches should be combined\nSince Java 7 it has been possible to catch multiple exceptions at once. Therefore, when multiplecatchblocks have the same code, they should be combined for better readability.\nNote that this rule is automatically disabled when the project'ssonar.java.sourceis lower than7.\n\n\nNoncompliant Code Example：不规范代码示例\n\n```catch (IOException e) {\n    doCleanup();\n    logger.log(e);\n}catch (SQLException e) { //Noncompliant\n    doCleanup();\n    logger.log(e);\n }catch (TimeoutException e) {  // Compliant; block contents are different\n     doCleanup();\n     throw e;\n }\n\n```\nCompliant Solution：规范代码示例\n\n```catch (IOException|SQLException e) {\n    doCleanup();\n    logger.log(e);\n }catch (TimeoutException e) {\n    doCleanup();\n    throw e;\n}\n```\n18.\"entrySet()\" should be iterated when both the key and value are needed\nNoncompliant Code Example：不规范的代码示例\n\n```public void doSomethingWithMap(Map map) {\nfor (String key : map.keySet()) {  // Noncompliant; for each key the value is retrieved\nObject value = map.get(key);\n// ...\n}   \n}   \n\n```\nCompliant SolutionL：规范代码示例\n\n```public void doSomethingWithMap(Map map) {\nfor (Map.Entry entry : map.entrySet()) {\nString key = entry.getKey();\nObject value = entry.getValue();\n// ...\n}   \n}   \n```\n\nUse a logger to log this exception\nYou should probably clarify which logger are you using.\n\norg.apache.commons.logging.Log interface has method void error(Object message, Throwable t) (and method void info(Object message, Throwable t)), which logs the stack trace together with your custom message. Log4J implementation has this method too.\n\nSo, probably you need to write:\nlogger.error(\"BOOM!\", e);\nIf you need to log it with INFO level (though, it might be a strange use case), then:\nlogger.info(\"Just a stack trace, nothing to worry about\", e);\nHope it helps.\n\nRename 'i' as this name is already used in declaration at line 26\n\n## 阻断\n\n#### 1、Close this\"FileInputStream\" in a \"finally\" clause.\n在finally中关闭FileInputStream，这个最为常见，主要是关闭方式不对，finally代码块中，应该要对每个stream进行单独关闭，而不能统一写在一个try-catch代码中，jdk 7 可以考虑try-resources方式关闭，代码相对优雅。\n另外数据库操作的statement和resultRs没有关闭的情况也非常多。这个也是要重点留意的地方。\n\n#### 2、A\"NullPointerException\" could be thrown; \"tom\" is nullablehere\n空指针，极为讨厌的问题，主要是编码经验缺少的体现。一般的高手在编码过程中，就会第一时间考虑到这类情况，并做相应的处理。解决方式无它，先判断或者先实例化，再访问里面的属性或者成员。\n\n## 严重\n#### 1、Define and throw a dedicated exception instead of using a generic one\n定义并抛出一个专用的异常来代替一个通用的异常。\n#### 2、Removethis hard-coded password\n移除代码里硬编码的密码信息。会有少许的误判的情况，一般是变量包含：PWD或者password，所以如果真的不是硬编码，可以考虑更换变量名称，比如PWD改PW等等。\n#### 3、Eitherlog or rethrow this exception\ncatch异常之后，使用log方式或者throw异常的方式解决。如果业务上真的没有throw或者记录日志的话，可以使用log.debug的方式填充来解决问题。\n\n#### 4、Makethis IP \"127.0.0.1\" address configurable\n将IP弄到配置文件中，不要硬编码到代码里。个人觉得改动稍大！\n#### 5、Make this\"public static JSAPI\" field final\n如果你将这个变量设置为public访问方式，同时又是静态Static方式，就要考虑将它设置为final了，因为这个是共享变量，其它类可以随时随地将它设置为别的值。所以如果是只是当前类使用，可以考虑将公开访问方式改为私有。\n#### 6、Makethe enclosing method \"static\" or remove this set\n见代码：\n\n```public class MyClass {\n  private static int count = 0;\n  public void doSomething() {\n    //...\n    count++;  // Noncompliant\n  }\n}\n\n```不要使用非静态方法去更新静态字段，这样很难获得正确的结果，如果有多个类实例和/或多个线程，则很容易导致错误。理想情况下，静态字段仅从同步静态方法中更新。\n#### 7、Override\"equals(Object obj)\" to comply with the contract of the\"compareTo(T o)\" method\n如果重写了compareTo方法，同时也应重写equals方法。\n#### 8、Make\"body\" transient or serializable.\n\n```public class Address {\n  //...\n}\npublic class Person implements Serializable {\n  private static final long serialVersionUID = 1905122041950251207L;\n  private String name;\n\n  private Address address;  // Noncompliant; Address isn't serializable\n}\n\n```\n如果person已经序列化，其成员变量Address也进行序列化。不然转化时会有问题。\n#### 9 Floating point numbers should not be tested for equality\n\n浮点类型的数字，不要通过==或者!=方式其它类型比较，因为浮点是不精确的，所以在比较时，会进行类型升级升级原则如下：\n·  如果运算符任意一方的类型为double，则另一方会转换为double\n·  否则，如果运算符任意一方的类型为float，则另一方会转换为float\n·  否则，如果运算符任意一方的类型为long，则另一方会转换为long\n·  否则，两边都会转换为int\n \n\n以下的方式得到的结果都是false。\n\n```\nfloat myNumber = 3.146;\nif ( myNumber == 3.146f ) { //Noncompliant. Because of floating point imprecision, this will be false\n \nif ( myNumber != 3.146f ) { //Noncompliant. Because of floating point imprecision, this will be true\nif (myNumber < 4 || myNumber > 4) { // Noncompliant; indirect  \nfloat zeroFloat = 0.0f;\nif (zeroFloat == 0) {  // Noncompliant. Computations may end up with a value close but not equal to zero.\n}\n \n```\n\n所以，要比较浮点数是否相等，需要做的事情是：\n\n    排除NaN和无穷\n\n    在精度范围内进行比较\n\n正确的例子：\n\n\n```public boolean isEqual(double a, double b) {\n    if (Double.isNaN(a) || Double.isNaN(b) || Double.isInfinite(a) || Double.isInfinite(b)) {\n       return false;\n    }\n    return (a - b) < 0.001d;\n}\n```\n\n \n\n#### 10、Thiscall to \"contains()\" may be a performance hot spot if the collectionis large.\n如果collection的记录数非常大的话，它的contains方法的时间复杂度是很高的。所以开发过程中要注意这一点。下面的是列表：\n\n\n```·  ArrayList\n\ncontains\nremove\n·  LinkedList\n\nget\ncontains\n·  ConcurrentLinkedQueue\n\nsize\ncontains\n·  ConcurrentLinkedDeque\n\nsize\ncontains\n·  CopyOnWriteArrayList\n\nadd\ncontains\nremove\n·  CopyOnWriteArraySet\n\nadd\ncontains\nremove\n\n```\n\n##### 1.Equality tests should not be made with floating point value\n　　代码举例： if (result == num) //result和num均为double 之间比较会有精度损失\n　　解决：BigDecimal data1 = new BigDecimal(totalArea);\n　　　　　BigDecimal data2 = new BigDecimal(s1);\n　　　　    int num = data1.compareTo(data2);//num =0 相等  >0前者大于后者 ，反之 <0 前者小于后者\n##### 2.This class overrides \"equals()\" and should therefore also override \"hashCode()\".　\n　　代码举例：public boolean equals(Object obj){...}  //需要添加对应的hashCode方法\n　　解决：可以添加一个最简单的hashCode方法　　\n　　　　　public int hashCode() {return 0;}　　　\n##### 3.Synchronize on a new \"Object\" instead\n　　代码举例：synchronized (\"实例化\") {...}   //里边必须是对象\n　　解决： private Object obj =\"实例化\"；\n　　　　　synchronized (obj ) {...}\n##### 4.Close this\"FileInputStream\" in a \"finally\" clause.\n　　解决方法: 在finally中关闭FileInputStream，主要是关闭方式不对，finally代码块中，应该要对每个stream进行单独关闭，而不能统一写在一个try-catch代码中。\n\n##### 5.A\"NullPointerException\" could be thrown; \"tom\" is nullablehere\n　　空指针，解决方式：先判断或者先实例化，再访问里面的属性或者成员。\n##### 6.Makethis IP \"127.0.0.1\" address configurable\n　　解决方法:不要把IP地址写在此类中，应该在对应的系统文件或者相应的配置文件中配置\n##### 7.Either log or rethrow this exception.\n　　解决方法: 把对应的输出写成Logger.error(\"aaa“);的形式 \n\n\n\n\n\n\n","slug":"review/Sonar代码审查-缺陷和修改","published":1,"updated":"2018-05-30T09:38:07.550Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bpo00bws77rmnbvevcw","content":"<h2 id=\"Sonar代码审查-缺陷和修改\"><a href=\"#Sonar代码审查-缺陷和修改\" class=\"headerlink\" title=\"Sonar代码审查-缺陷和修改\"></a>Sonar代码审查-缺陷和修改</h2><p>Resources should be closed<br>资源未关闭，打开发现有两处用到的IO流没有关闭</p>\n<p>Conditions should not unconditionally evaluate to “TRUE” or to “FALSE”<br>if/else判断里出现了重复判断，比如在if(a&gt;10)的执行体里面又判断if(a&lt;0)，而后者肯定不会是true</p>\n<p>Exception handlers should preserve the original exception<br>处理异常的时候应该保留原始的异常情况，不要直接来个catch(Exception e)了事</p>\n<p> Throwable.printStackTrace(…) should not be called<br>不应该直接调用e.printStackTrace()，而是用Loggers来处理（就是打Log）。</p>\n<p>Loggers的优势是：Users are able to easily retrieve the logs.<br>The format of log messages is uniform and allow users to browse the logs easily.<br>Instance methods should not write to “static” fields6<br>不要用实例方法改变静态成员，理想情况下，静态变量只通过同步的静态方法来改变</p>\n<p>“public static” fields should be constant<br>公共静态成员应该加上final，也就是public static final 一般不分家</p>\n<p>Thread.run() and Runnable.run() should not be called directly<br>不应该直接调用Thread和Runnaale对象的run方法，直接调用run会使得run方法执行在当前线程，失去了开启新线程的意义。但有时候可能会这样做，下面有个例子。</p>\n<p>Generic exceptions should never be thrown<br>不太理解，大意是说不要直接抛Error,RuntimeException/Throwable/Exception这样的通用的异常。我的具体应用是：throw new Error(“Error copying database”)，给出的建议是：Define and throw a dedicated exception instead of using a generic one（定义并抛出一个专用的异常来代替一个通用的异常）</p>\n<p>Class variable fields should not have public accessibility<br>类变量不要设置为public，而是设为private，再提供get和set方法。</p>\n<p>Sections of code should not be “commented out”<br>不要再注释中出现大量的代码段，会使代码可读性变差</p>\n<p>Package declaration should match source file directory<br>这个没理解，包的声明应该与源文件目录匹配。</p>\n<p>Utility classes should not have public constructors<br>工具类不应该有公共的构造器，也就是说至少要有一个private的构造器，如果没有，默认的构造器是public的。</p>\n<p>The diamond operator (“&lt;&gt;”) should be used<br>在定义集合的时候，等号右边的&lt;&gt;内不需要再写上元素类型，直接空着就行。</p>\n<p>Lambdas and anonymous classes should not have too many lines<br>Lambdas表达式和匿名内部类不要写太多行，一般最多写20行。</p>\n<p>Anonymous inner classes containing only one method should become lambdas8<br>只包含一个方法的匿名内部类应该写成Lambdas表达式的形式，增强代码可读性</p>\n<p>Try-with-resources should be used8<br>用Try-with-resources的形式取代try/catch/finally的形式，这个有待于以后学习。<br><figure class=\"highlight plain\"><figcaption><span>con </span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   try (PreparedStatement prep = con.prepareConnection(&quot;Update ...&quot;)) &#123;</span><br><span class=\"line\">       //prep.doSomething();</span><br><span class=\"line\">       //...</span><br><span class=\"line\">       //etc</span><br><span class=\"line\">con.commit();</span><br><span class=\"line\">   &#125; catch (SQLException e) &#123;</span><br><span class=\"line\">       //any other actions necessary on failure</span><br><span class=\"line\">       con.rollback();</span><br><span class=\"line\">       //consider a re-throw, throwing a wrapping exception, etc</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Methods should not be empty<br>不要写空方法，除非这种情况：An abstract class may have empty methods, in order to provide default implementations for child classes.</p>\n<p>Source files should not have any duplicated blocks<br>源文件中不要出现任何重复的代码段或行或字符串等。没理解。</p>\n<p>“switch case” clauses should not have too many lines<br>“switch case” 每个case里面的代码不要太长，太长的话可以考虑写个方法代替，主要是为了增强代码可读性</p>\n<p>Nested blocks of code should not be left empty<br>嵌套代码块不要是空的，比如 if( a &gt; 0 ) {  doSomething()  } else { }，这时候应该把后面的else{}去掉。</p>\n<p>Methods should not be too complex<br>方法不要太复杂，否则难以理解和维护。</p>\n<p>Unused private fields should be removed<br>没有使用的private的成员变量应该移除掉。</p>\n<p>Dead stores should be removed<br>没有用到的本地变量或其他死存储应该移除掉，也就是写方法的时候，定义的变量如果后来发现根本用不到，要记得删掉那行代码。</p>\n<p>“switch” statements should end with a “default” clause<br>switch语句应该以default结束，这是一种defensive programming思想</p>\n<p>Unused method parameters should be removed<br>没有用到的方法参数应该移除掉</p>\n<p>Control flow statements “if”, “for”, “while”, “switch” and “try” should not be nested too deeply4<br>if /for/while/try这样的嵌套不要太复杂</p>\n<p>Useless parentheses around expressions should be removed to prevent any misunderstanding3<br>没有意义的括号不要随便加，以免造成误解，比如”=”两边对象类型是相同的，就不要强转。</p>\n<p>“for” loop stop conditions should be invariant<br>for循环的结果条件不能是变量，而应该是常量</p>\n<p>“static” members should be accessed statically<br>static成员是与类、静态方法相联系的。</p>\n<p>Catches should be combined<br>具体参考下面的18，我还没理解</p>\n<p>Primitives should not be boxed just for “String” conversion<br>不要使用 4+” “这样的方式将int值转变为字符串，而是使用 Integer.toString(4)这样的方式。<br>就像Integer.parseInt(“我是字符串”)这样，不要偷懒。</p>\n<p>Classes should not be empty<br>不要写空类</p>\n<p>Unused local variables should be removed<br>没有用到的本地变量要删掉</p>\n<p>“entrySet()” should be iterated when both the key and value are needed<br>直接看英文更直接：When only the keys from a map are needed in a loop, iterating the keySet makes sense. But when both the key and the value are needed, it’s more efficient to iterate theentrySet, which will give access to both the key and value, instead.<br>也就是说，如果只需要Map的Key，那么直接iterate这个Map的keySet就可以了，但是如果Key和value都需要，就iterate这个Map。具体看下面的19.</p>\n<p>Method parameters, caught exceptions and foreach variables should not be reassigned<br>方法参数/捕获的异常/foreach的变量不应该被重新赋值。</p>\n<p>Collection.isEmpty() should be used to test for emptiness<br>当判断集合是否为空的时候，不要使用if (myCollection.size() == 0) 这样的方式，而是使用if (myCollection.isEmpty()这样的方式，后者性能更高。</p>\n<p>Standard outputs should not be used directly to log anything<br>标准输出不直接打印任何东西，也就是打log的时候，不要使用System.out.println(“My Message”)这样的方式，而是使用logger.log(“My Message”)这种方式。</p>\n<p>Generic wildcard types should not be used in return parameters<br>通配符不应该出现在返回声明中。比如这句：List &lt;? extends Animal&gt;getAnimals(){…}， 我们无法知道“是否可以把a Dog, a Cat 等加进去”，等之后用到这个方法的时候，我们没必要去考虑这种问题（前面引号里面的）。</p>\n<p>Synchronized classes Vector, Hashtable, Stack and StringBuffer should not be used1<br>不要使用同步的Vector/HashTable/Stack/StringBuffer等。在早期，出于线程安全问题考虑，java API 提供了这些类。但是同步会极大影响性能，即使是在同一个线程中使用他们。<br>通常可以这样取代：<br><code>ArrayList  or  LinkedList   instead of  Vector\nDeque  instead of  Stack\nHashMap  instead of  Hashtable\nStringBuilder  instead of  StringBuffer\nExit methods should not be called</code><br>尽量不要调用system.exit()方法。</p>\n<p>Local Variables should not be declared and then immediately returned or thrown<br>本地变量如果赋值之后直接return了，那就直接return本地变量的赋值语句。</p>\n<p>Field names should comply with a naming convention<br>命名要规范</p>\n<p>Local variable and method parameter names should comply with a naming convention<br>命名要规范</p>\n<p>String literals should not be duplicated5<br>字符串不应该重复，如果多次用到同一字符串，建议将该字符串定义为字符串常量，再引用。</p>\n<p>Return of boolean expressions should not be wrapped into an “if-then-else” statement3<br>不要写if (  a &gt; 4  ) {  return false  } else { return true }这样的代码，直接写return a &gt; 4。</p>\n<p>Static non-final field names should comply with a naming convention<br>命名要规范</p>\n<p>Modifiers should be declared in the correct order<br>修饰符等要按约定俗成的顺序书写 ，例如，写成public static 而不是static public </p>\n<p>The members of an interface declaration or class should appear in a pre-defined order2<br>与前面的一个问题类似，根据Oracle定义的Java代码规范中，不同代码的出现位置应该如下所示：<br>class and instance variables–Constructors–Methods</p>\n<p>Array designators “[]” should be on the type, not the variable<br>数组的括号要写在类型后面，而不是变量后面，例如 int[] a 而不是int a[]</p>\n<p>Multiple variables should not be declared on the same line1<br>不要在同一行定义多个变量</p>\n<p>“switch” statements should have at least 3 “case” clauses<br>当至少有3种或者3种以上的情况时，才考虑用switch，否则用if/else的形式。</p>\n<p>Overriding methods should do more than simply call the same method in the super class<br>既然在子类中重写了父类的某个方法，那就再这个方法中做些与父类方法不同的事情，否则没必要重写。</p>\n<p>Statements should be on separate lines<br>不要把这样的代码写在同一行：if(someCondition)    doSomething()；而是应该写成下面的形式<br>if(someCondition) {<br>doSomething()<br>}<br>Method names should comply with a naming convention1<br>命名要规范<br>“TODO” tags should be handle    TODO标签要及时处理，该做的事情不要忘了做</p>\n<h2 id=\"部分规则详细说明\"><a href=\"#部分规则详细说明\" class=\"headerlink\" title=\"部分规则详细说明\"></a>部分规则详细说明</h2><h4 id=\"1-The-members-of-an-interface-declaration-or-class-should-appear-in-a-pre-defined-order\"><a href=\"#1-The-members-of-an-interface-declaration-or-class-should-appear-in-a-pre-defined-order\" class=\"headerlink\" title=\"1.The members of an interface declaration or class should appear in a pre-defined order\"></a>1.The members of an interface declaration or class should appear in a pre-defined order</h4><p>正确的顺序如下所示：静态成员变量→成员变量→构造器→方法</p>\n<figure class=\"highlight plain\"><figcaption><span>class Foo&#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static final int OPEN = 4;  //Class and instance variables</span><br><span class=\"line\">private int field = 0;</span><br><span class=\"line\">public Foo() &#123;...&#125;    //Constructors</span><br><span class=\"line\">public boolean isTrue() &#123;...&#125;    //Methods</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-The-diamond-operator-“-lt-gt-”-should-be-used\"><a href=\"#2-The-diamond-operator-“-lt-gt-”-should-be-used\" class=\"headerlink\" title=\"2.The diamond operator (“&lt;&gt;”) should be used\"></a>2.The diamond operator (“&lt;&gt;”) should be used</h4><p>Noncompliant Code Example：不规范的示例</p>\n<figure class=\"highlight plain\"><figcaption><span>strings </span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, List&lt;Integer&gt;&gt; map = new HashMap&lt;String, List&lt;Integer&gt;&gt;();  // Noncompliant</span><br><span class=\"line\">Compliant Solution ：规范的示例</span><br><span class=\"line\">List&lt;String&gt; strings = new ArrayList&lt;&gt;();</span><br><span class=\"line\">Map&lt;String, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-Sections-of-code-should-not-be-“commented-out”\"><a href=\"#3-Sections-of-code-should-not-be-“commented-out”\" class=\"headerlink\" title=\"3.Sections of code should not be “commented out”\"></a>3.Sections of code should not be “commented out”</h4><p>代码片段不应该出现在注释中，这样会bloat程序，可读性变差<br><code>Programmers should not comment out code as it bloats programs and reduces readability.\nUnused code should be deleted and can be retrieved from source control history if required.</code></p>\n<h4 id=\"4-Utility-classes-should-not-have-public-constructors\"><a href=\"#4-Utility-classes-should-not-have-public-constructors\" class=\"headerlink\" title=\"4.Utility classes should not have public constructors\"></a>4.Utility classes should not have public constructors</h4><p>工具类不应该有public的构造器，也就是工具类至少要定义一个non-public的构造器<br>Utility classes, which are a collection of static members, are not meant to be instantiated. Even abstract utility classes, which can be extended, should not have public constructors.<br>Java adds an implicit public constructor to every class which does not define at least one explicitly. Hence, at least one non-public constructor should be defined.</p>\n<figure class=\"highlight plain\"><figcaption><span>StringUtils &#123;</span><a href=\"//\">Noncompliant Code Example</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    public static String concatenate(String s1, String s2) &#123;</span><br><span class=\"line\">          return s1 + s2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><figcaption><span>StringUtils &#123;</span><a href=\"//Compliant\">Solution</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    private StringUtils() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public static String concatenate(String s1, String s2) &#123;</span><br><span class=\"line\">    return s1 + s2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"5-”public-static”-fields-should-be-constant\"><a href=\"#5-”public-static”-fields-should-be-constant\" class=\"headerlink\" title=\"5.”public static” fields should be constant\"></a>5.”public static” fields should be constant</h4><p>公共的静态成员应该加上final来修饰<br>There is no good reason to declare a field “public” and “static” without also declaring it “final”. Most of the time this is a kludge to share a state among several objects. But with this approach, any object can do whatever it wants with the shared state, such as setting it to null.<br>public static Foo foo = new Foo();//不规范的<br>public static final Foo FOO = new Foo();//规范的</p>\n<p>6.Class variable fields should not have public accessibility</p>\n<figure class=\"highlight plain\"><figcaption><span>class MyClass &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static final int SOME_CONSTANT = 0;    // Compliant - constants are not checked</span><br><span class=\"line\">public String firstName;                      // Noncompliant</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><figcaption><span>class MyClass &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static final int SOME_CONSTANT = 0;    // Compliant - constants are not checked</span><br><span class=\"line\">private String firstName;                      // Compliant</span><br><span class=\"line\">public String getFirstName() &#123;</span><br><span class=\"line\">return firstName;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public void setFirstName(String firstName) &#123;</span><br><span class=\"line\">this.firstName = firstName;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">#### 7.Static non-final field names should comply with a naming convention</span><br><span class=\"line\">public final class MyClass &#123;//Noncompliant Code Example</span><br><span class=\"line\">      private static String foo_bar;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class MyClass &#123;//Compliant Solution</span><br><span class=\"line\">private static String fooBar;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"8-”switch”-statements-should-have-at-least-3-“case”-clauses\"><a href=\"#8-”switch”-statements-should-have-at-least-3-“case”-clauses\" class=\"headerlink\" title=\"8.”switch” statements should have at least 3 “case” clauses\"></a>8.”switch” statements should have at least 3 “case” clauses</h4><p>当有3种或3种情况以上的时候，才用switch，否则用if/else<br>switch statements are useful when there are many different cases depending on the value of the same expression.<br>For just one or two cases however, the code will be more readable with if statements.</p>\n<h4 id=\"9-String-literals-should-not-be-duplicated\"><a href=\"#9-String-literals-should-not-be-duplicated\" class=\"headerlink\" title=\"9.String literals should not be duplicated\"></a>9.String literals should not be duplicated</h4><figure class=\"highlight plain\"><figcaption><span> </span><a href=\"//\">Noncompliant - \"action1\" is duplicated 3 times</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">execute(&quot;action1&quot;);</span><br><span class=\"line\">release(&quot;action1&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">private static final String ACTION_1 = &quot;action1&quot;;  // Compliant</span><br><span class=\"line\">prepare(ACTION_1);                                            // Compliant</span><br><span class=\"line\">execute(ACTION_1);</span><br><span class=\"line\">release(ACTION_1);</span><br></pre></td></tr></table></figure>\n<h4 id=\"10-Return-of-boolean-expressions-should-not-be-wrapped-into-an-“if-then-else”-statement\"><a href=\"#10-Return-of-boolean-expressions-should-not-be-wrapped-into-an-“if-then-else”-statement\" class=\"headerlink\" title=\"10.Return of boolean expressions should not be wrapped into an “if-then-else” statement\"></a>10.Return of boolean expressions should not be wrapped into an “if-then-else” statement</h4><p>Replace this if-then-else statement by a single return statement</p>\n<figure class=\"highlight plain\"><figcaption><span>(expression) &#123;//Noncompliant Code Example</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">      return true;</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">     return false;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">return expression;//Compliant Solution</span><br><span class=\"line\">return !!expression;</span><br></pre></td></tr></table></figure>\n<h4 id=\"11-Method-parameters-caught-exceptions-and-foreach-variables-should-not-be-reassigned\"><a href=\"#11-Method-parameters-caught-exceptions-and-foreach-variables-should-not-be-reassigned\" class=\"headerlink\" title=\"11.Method parameters, caught exceptions and foreach variables should not be reassigned\"></a>11.Method parameters, caught exceptions and foreach variables should not be reassigned</h4><p>方法参数，捕获的异常，foreach里的变量，都不应该重新赋值</p>\n<figure class=\"highlight plain\"><figcaption><span>MyClass &#123;//Noncompliant Code Example：不规范代码示例</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    public String name;</span><br><span class=\"line\">    public MyClass(String name) &#123;</span><br><span class=\"line\">            name = name;          // Noncompliant - useless identity assignment</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public int add(int a, int b) &#123;</span><br><span class=\"line\">        a = a + b;                // Noncompliant</span><br><span class=\"line\">        return a;                 // Seems like the parameter is returned as is, what is the point?</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        MyClass foo = new MyClass();</span><br><span class=\"line\">        int a = 40;</span><br><span class=\"line\">        int b = 2;</span><br><span class=\"line\">        foo.add(a, b);                  // Variable &quot;a&quot; will still hold 40 after this call</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><figcaption><span>MyClass &#123;//Compliant Solution：规范代码示例</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    public String name;</span><br><span class=\"line\">    public MyClass(String name) &#123;</span><br><span class=\"line\">         this.name = name;              // Compliant</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public int add(int a, int b) &#123;</span><br><span class=\"line\">        return a + b;                  // Compliant</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">    MyClass foo = new MyClass();</span><br><span class=\"line\">        int a = 40;</span><br><span class=\"line\">        int b = 2;</span><br><span class=\"line\">        foo.add(a, b);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"12-Local-Variables-should-not-be-declared-and-then-immediately-returned-or-thrown\"><a href=\"#12-Local-Variables-should-not-be-declared-and-then-immediately-returned-or-thrown\" class=\"headerlink\" title=\"12.Local Variables should not be declared and then immediately returned or thrown\"></a>12.Local Variables should not be declared and then immediately returned or thrown</h4><p>Noncompliant Code Example：不规范代码示例</p>\n<figure class=\"highlight plain\"><figcaption><span>long computeDurationInMilliseconds() &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">long duration = (((hours * 60) + minutes) * 60 + seconds ) * 1000 ;</span><br><span class=\"line\">return duration;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public void doSomething() &#123;</span><br><span class=\"line\">RuntimeException myException = new RuntimeException();</span><br><span class=\"line\">throw myException;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Compliant Solution：规范代码示例</p>\n<figure class=\"highlight plain\"><figcaption><span>long computeDurationInMilliseconds() &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">return (((hours * 60) + minutes) * 60 + seconds ) * 1000 ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public void doSomething() &#123;</span><br><span class=\"line\">throw new RuntimeException();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"13-Thread-run-and-Runnable-run-should-not-be-called-directly\"><a href=\"#13-Thread-run-and-Runnable-run-should-not-be-called-directly\" class=\"headerlink\" title=\"13.Thread.run() and Runnable.run() should not be called directly\"></a>13.Thread.run() and Runnable.run() should not be called directly</h4><p>The purpose of theThread.run()andRunnable.run()methods is to execute code in a separate, dedicated thread. Calling those methods directly doesn’t make sense because it causes their code to be executed in the current thread.<br>Thread和Runnable里面的run方法设计的目的是让run方法里面的代码在不同的线程中执行。如果直接调用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Noncompliant Code Example：不规范的代码示例</span><br><span class=\"line\">Thread myThread = new Thread(runnable);</span><br><span class=\"line\">myThread.run(); // Noncompliant</span><br><span class=\"line\"></span><br><span class=\"line\">Compliant Solution：规范代码示例</span><br><span class=\"line\">Thread myThread = new Thread(runnable);</span><br><span class=\"line\">myThread.start(); // Compliant</span><br></pre></td></tr></table></figure></p>\n<p>这部分内容为个人理解，可以略过<br>但在有些情况，也会直接调用Runnable的run方法，<br>下面这个postTaskSafely方法会保证task永远在主线程中执行</p>\n<figure class=\"highlight plain\"><figcaption><span>static void postTaskInMainThread(Runnable task) &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     int curThreadId= android.os.Process.myTid();//得到当前线程的id</span><br><span class=\"line\">    if(curThreadId==getMainThreadId()) &#123;// 如果当前线程是主线程</span><br><span class=\"line\">            task.run();//直接执行</span><br><span class=\"line\">    &#125;else&#123;// 如果当前线程不是主线程</span><br><span class=\"line\">        getMainThreadHandler().post(task);//用主线程的Handler来post</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"14-Lambdas-and-anonymous-classes-should-not-have-too-many-lines\"><a href=\"#14-Lambdas-and-anonymous-classes-should-not-have-too-many-lines\" class=\"headerlink\" title=\"14.Lambdas and anonymous classes should not have too many lines\"></a>14.Lambdas and anonymous classes should not have too many lines</h4><p>Anonymous classes and lambdas (with Java 8) are a very convenient and compact way to inject a behavior without having to create a dedicated class. But those anonymous inner classes and lambdas should be used only if the behavior to be injected can be defined in a few lines of code, otherwise the source code can quickly become unreadable.<br>anonymous class number of lines ： at most 20</p>\n<h4 id=\"15-Resources-should-be-closed：该关闭的一定记得关闭\"><a href=\"#15-Resources-should-be-closed：该关闭的一定记得关闭\" class=\"headerlink\" title=\"15.Resources should be closed：该关闭的一定记得关闭\"></a>15.Resources should be closed：该关闭的一定记得关闭</h4><p>Java’s garbage collection cannot be relied on to clean up everything. Specifically, connections, streams, files and other classes that implement theCloseableinterface or it’s super-interface,AutoCloseable, must be manually closed after creation. Failure to do so will result in a resource leak which could bring first the application and then perhaps the box it’s on to their knees.<br>Noncompliant Code Example：不规范的代码示例</p>\n<figure class=\"highlight plain\"><figcaption><span>stream </span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try&#123;</span><br><span class=\"line\">    for (String property : propertyList) &#123;</span><br><span class=\"line\">    stream = new FileOutputStream(&quot;myfile.txt&quot;);  // Noncompliant</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;catch(Exception e)&#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;finally&#123;</span><br><span class=\"line\">    stream.close();  // Multiple streams were opened. Only the last is closed.</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Compliant Solution：规范代码示例</p>\n<figure class=\"highlight plain\"><figcaption><span>stream </span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> try&#123;</span><br><span class=\"line\">     stream = new FileOutputStream(&quot;myfile.txt&quot;);</span><br><span class=\"line\">     for (String property : propertyList) &#123;</span><br><span class=\"line\">         // ...</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;catch(Exception e)&#123;</span><br><span class=\"line\">     // ...</span><br><span class=\"line\">&#125;finally&#123;</span><br><span class=\"line\">    stream.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"16-Exception-handlers-should-preserve-the-original-exception\"><a href=\"#16-Exception-handlers-should-preserve-the-original-exception\" class=\"headerlink\" title=\"16.Exception handlers should preserve the original exception\"></a>16.Exception handlers should preserve the original exception</h4><p>Noncompliant Code Example:不规范的代码示例<br>// Noncompliant - exception is lost<br>try { /<em> … </em>/ } catch (Exception e) { LOGGER.info(“context”); }<br>// Noncompliant - exception is lost (only message is preserved)<br>try { /<em> … </em>/ } catch (Exception e) { LOGGER.info(e.getMessage()); }<br>// Noncompliant - exception is lost<br>try { /<em> … </em>/ } catch (Exception e) { throw new RuntimeException(“context”); }</p>\n<p>Compliant Solution:规范的代码示例</p>\n<figure class=\"highlight plain\"><figcaption><span>&#123;</span><a href=\"/*\">... */ &#125; catch (Exception e) &#123; LOGGER.info(e); &#125;</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try &#123; /* ... */ &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125;</span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">/* ... */</span><br><span class=\"line\">&#125; catch (RuntimeException e) &#123;</span><br><span class=\"line\">doSomething();</span><br><span class=\"line\">throw e;</span><br><span class=\"line\">&#125; catch (Exception e) &#123;</span><br><span class=\"line\">// Conversion into unchecked exception is also allowed</span><br><span class=\"line\">throw new RuntimeException(e);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"17-Catches-should-be-combined\"><a href=\"#17-Catches-should-be-combined\" class=\"headerlink\" title=\"17.Catches should be combined\"></a>17.Catches should be combined</h4><p>Since Java 7 it has been possible to catch multiple exceptions at once. Therefore, when multiplecatchblocks have the same code, they should be combined for better readability.<br>Note that this rule is automatically disabled when the project’ssonar.java.sourceis lower than7.</p>\n<p>Noncompliant Code Example：不规范代码示例</p>\n<figure class=\"highlight plain\"><figcaption><span>(IOException e) &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    doCleanup();</span><br><span class=\"line\">    logger.log(e);</span><br><span class=\"line\">&#125;catch (SQLException e) &#123; //Noncompliant</span><br><span class=\"line\">    doCleanup();</span><br><span class=\"line\">    logger.log(e);</span><br><span class=\"line\"> &#125;catch (TimeoutException e) &#123;  // Compliant; block contents are different</span><br><span class=\"line\">     doCleanup();</span><br><span class=\"line\">     throw e;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>Compliant Solution：规范代码示例</p>\n<figure class=\"highlight plain\"><figcaption><span>(IOException|SQLException e) &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    doCleanup();</span><br><span class=\"line\">    logger.log(e);</span><br><span class=\"line\"> &#125;catch (TimeoutException e) &#123;</span><br><span class=\"line\">    doCleanup();</span><br><span class=\"line\">    throw e;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>18.”entrySet()” should be iterated when both the key and value are needed<br>Noncompliant Code Example：不规范的代码示例</p>\n<figure class=\"highlight plain\"><figcaption><span>void doSomethingWithMap(Map map) &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (String key : map.keySet()) &#123;  // Noncompliant; for each key the value is retrieved</span><br><span class=\"line\">Object value = map.get(key);</span><br><span class=\"line\">// ...</span><br><span class=\"line\">&#125;   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Compliant SolutionL：规范代码示例</p>\n<figure class=\"highlight plain\"><figcaption><span>void doSomethingWithMap(Map map) &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (Map.Entry entry : map.entrySet()) &#123;</span><br><span class=\"line\">String key = entry.getKey();</span><br><span class=\"line\">Object value = entry.getValue();</span><br><span class=\"line\">// ...</span><br><span class=\"line\">&#125;   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Use a logger to log this exception<br>You should probably clarify which logger are you using.</p>\n<p>org.apache.commons.logging.Log interface has method void error(Object message, Throwable t) (and method void info(Object message, Throwable t)), which logs the stack trace together with your custom message. Log4J implementation has this method too.</p>\n<p>So, probably you need to write:<br>logger.error(“BOOM!”, e);<br>If you need to log it with INFO level (though, it might be a strange use case), then:<br>logger.info(“Just a stack trace, nothing to worry about”, e);<br>Hope it helps.</p>\n<p>Rename ‘i’ as this name is already used in declaration at line 26</p>\n<h2 id=\"阻断\"><a href=\"#阻断\" class=\"headerlink\" title=\"阻断\"></a>阻断</h2><h4 id=\"1、Close-this”FileInputStream”-in-a-“finally”-clause\"><a href=\"#1、Close-this”FileInputStream”-in-a-“finally”-clause\" class=\"headerlink\" title=\"1、Close this”FileInputStream” in a “finally” clause.\"></a>1、Close this”FileInputStream” in a “finally” clause.</h4><p>在finally中关闭FileInputStream，这个最为常见，主要是关闭方式不对，finally代码块中，应该要对每个stream进行单独关闭，而不能统一写在一个try-catch代码中，jdk 7 可以考虑try-resources方式关闭，代码相对优雅。<br>另外数据库操作的statement和resultRs没有关闭的情况也非常多。这个也是要重点留意的地方。</p>\n<h4 id=\"2、A”NullPointerException”-could-be-thrown-“tom”-is-nullablehere\"><a href=\"#2、A”NullPointerException”-could-be-thrown-“tom”-is-nullablehere\" class=\"headerlink\" title=\"2、A”NullPointerException” could be thrown; “tom” is nullablehere\"></a>2、A”NullPointerException” could be thrown; “tom” is nullablehere</h4><p>空指针，极为讨厌的问题，主要是编码经验缺少的体现。一般的高手在编码过程中，就会第一时间考虑到这类情况，并做相应的处理。解决方式无它，先判断或者先实例化，再访问里面的属性或者成员。</p>\n<h2 id=\"严重\"><a href=\"#严重\" class=\"headerlink\" title=\"严重\"></a>严重</h2><h4 id=\"1、Define-and-throw-a-dedicated-exception-instead-of-using-a-generic-one\"><a href=\"#1、Define-and-throw-a-dedicated-exception-instead-of-using-a-generic-one\" class=\"headerlink\" title=\"1、Define and throw a dedicated exception instead of using a generic one\"></a>1、Define and throw a dedicated exception instead of using a generic one</h4><p>定义并抛出一个专用的异常来代替一个通用的异常。</p>\n<h4 id=\"2、Removethis-hard-coded-password\"><a href=\"#2、Removethis-hard-coded-password\" class=\"headerlink\" title=\"2、Removethis hard-coded password\"></a>2、Removethis hard-coded password</h4><p>移除代码里硬编码的密码信息。会有少许的误判的情况，一般是变量包含：PWD或者password，所以如果真的不是硬编码，可以考虑更换变量名称，比如PWD改PW等等。</p>\n<h4 id=\"3、Eitherlog-or-rethrow-this-exception\"><a href=\"#3、Eitherlog-or-rethrow-this-exception\" class=\"headerlink\" title=\"3、Eitherlog or rethrow this exception\"></a>3、Eitherlog or rethrow this exception</h4><p>catch异常之后，使用log方式或者throw异常的方式解决。如果业务上真的没有throw或者记录日志的话，可以使用log.debug的方式填充来解决问题。</p>\n<h4 id=\"4、Makethis-IP-“127-0-0-1”-address-configurable\"><a href=\"#4、Makethis-IP-“127-0-0-1”-address-configurable\" class=\"headerlink\" title=\"4、Makethis IP “127.0.0.1” address configurable\"></a>4、Makethis IP “127.0.0.1” address configurable</h4><p>将IP弄到配置文件中，不要硬编码到代码里。个人觉得改动稍大！</p>\n<h4 id=\"5、Make-this”public-static-JSAPI”-field-final\"><a href=\"#5、Make-this”public-static-JSAPI”-field-final\" class=\"headerlink\" title=\"5、Make this”public static JSAPI” field final\"></a>5、Make this”public static JSAPI” field final</h4><p>如果你将这个变量设置为public访问方式，同时又是静态Static方式，就要考虑将它设置为final了，因为这个是共享变量，其它类可以随时随地将它设置为别的值。所以如果是只是当前类使用，可以考虑将公开访问方式改为私有。</p>\n<h4 id=\"6、Makethe-enclosing-method-“static”-or-remove-this-set\"><a href=\"#6、Makethe-enclosing-method-“static”-or-remove-this-set\" class=\"headerlink\" title=\"6、Makethe enclosing method “static” or remove this set\"></a>6、Makethe enclosing method “static” or remove this set</h4><p>见代码：</p>\n<figure class=\"highlight plain\"><figcaption><span>class MyClass &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  private static int count = 0;</span><br><span class=\"line\">  public void doSomething() &#123;</span><br><span class=\"line\">    //...</span><br><span class=\"line\">    count++;  // Noncompliant</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">```不要使用非静态方法去更新静态字段，这样很难获得正确的结果，如果有多个类实例和/或多个线程，则很容易导致错误。理想情况下，静态字段仅从同步静态方法中更新。</span><br><span class=\"line\">#### 7、Override&quot;equals(Object obj)&quot; to comply with the contract of the&quot;compareTo(T o)&quot; method</span><br><span class=\"line\">如果重写了compareTo方法，同时也应重写equals方法。</span><br><span class=\"line\">#### 8、Make&quot;body&quot; transient or serializable.</span><br><span class=\"line\"></span><br><span class=\"line\">```public class Address &#123;</span><br><span class=\"line\">  //...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public class Person implements Serializable &#123;</span><br><span class=\"line\">  private static final long serialVersionUID = 1905122041950251207L;</span><br><span class=\"line\">  private String name;</span><br><span class=\"line\"></span><br><span class=\"line\">  private Address address;  // Noncompliant; Address isn&apos;t serializable</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果person已经序列化，其成员变量Address也进行序列化。不然转化时会有问题。</p>\n<h4 id=\"9-Floating-point-numbers-should-not-be-tested-for-equality\"><a href=\"#9-Floating-point-numbers-should-not-be-tested-for-equality\" class=\"headerlink\" title=\"9 Floating point numbers should not be tested for equality\"></a>9 Floating point numbers should not be tested for equality</h4><p>浮点类型的数字，不要通过==或者!=方式其它类型比较，因为浮点是不精确的，所以在比较时，会进行类型升级升级原则如下：<br>·  如果运算符任意一方的类型为double，则另一方会转换为double<br>·  否则，如果运算符任意一方的类型为float，则另一方会转换为float<br>·  否则，如果运算符任意一方的类型为long，则另一方会转换为long<br>·  否则，两边都会转换为int</p>\n<p>以下的方式得到的结果都是false。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">float myNumber = 3.146;</span><br><span class=\"line\">if ( myNumber == 3.146f ) &#123; //Noncompliant. Because of floating point imprecision, this will be false</span><br><span class=\"line\"> </span><br><span class=\"line\">if ( myNumber != 3.146f ) &#123; //Noncompliant. Because of floating point imprecision, this will be true</span><br><span class=\"line\">if (myNumber &lt; 4 || myNumber &gt; 4) &#123; // Noncompliant; indirect  </span><br><span class=\"line\">float zeroFloat = 0.0f;</span><br><span class=\"line\">if (zeroFloat == 0) &#123;  // Noncompliant. Computations may end up with a value close but not equal to zero.</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以，要比较浮点数是否相等，需要做的事情是：</p>\n<pre><code>排除NaN和无穷\n\n在精度范围内进行比较\n</code></pre><p>正确的例子：</p>\n<figure class=\"highlight plain\"><figcaption><span>boolean isEqual(double a, double b) &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    if (Double.isNaN(a) || Double.isNaN(b) || Double.isInfinite(a) || Double.isInfinite(b)) &#123;</span><br><span class=\"line\">       return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return (a - b) &lt; 0.001d;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"10、Thiscall-to-“contains-”-may-be-a-performance-hot-spot-if-the-collectionis-large\"><a href=\"#10、Thiscall-to-“contains-”-may-be-a-performance-hot-spot-if-the-collectionis-large\" class=\"headerlink\" title=\"10、Thiscall to “contains()” may be a performance hot spot if the collectionis large.\"></a>10、Thiscall to “contains()” may be a performance hot spot if the collectionis large.</h4><p>如果collection的记录数非常大的话，它的contains方法的时间复杂度是很高的。所以开发过程中要注意这一点。下面的是列表：</p>\n<figure class=\"highlight plain\"><figcaption><span>ArrayList</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">contains</span><br><span class=\"line\">remove</span><br><span class=\"line\">·  LinkedList</span><br><span class=\"line\"></span><br><span class=\"line\">get</span><br><span class=\"line\">contains</span><br><span class=\"line\">·  ConcurrentLinkedQueue</span><br><span class=\"line\"></span><br><span class=\"line\">size</span><br><span class=\"line\">contains</span><br><span class=\"line\">·  ConcurrentLinkedDeque</span><br><span class=\"line\"></span><br><span class=\"line\">size</span><br><span class=\"line\">contains</span><br><span class=\"line\">·  CopyOnWriteArrayList</span><br><span class=\"line\"></span><br><span class=\"line\">add</span><br><span class=\"line\">contains</span><br><span class=\"line\">remove</span><br><span class=\"line\">·  CopyOnWriteArraySet</span><br><span class=\"line\"></span><br><span class=\"line\">add</span><br><span class=\"line\">contains</span><br><span class=\"line\">remove</span><br></pre></td></tr></table></figure>\n<h5 id=\"1-Equality-tests-should-not-be-made-with-floating-point-value\"><a href=\"#1-Equality-tests-should-not-be-made-with-floating-point-value\" class=\"headerlink\" title=\"1.Equality tests should not be made with floating point value\"></a>1.Equality tests should not be made with floating point value</h5><p>　　代码举例： if (result == num) //result和num均为double 之间比较会有精度损失<br>　　解决：BigDecimal data1 = new BigDecimal(totalArea);<br>　　　　　BigDecimal data2 = new BigDecimal(s1);<br>　　　　    int num = data1.compareTo(data2);//num =0 相等  &gt;0前者大于后者 ，反之 &lt;0 前者小于后者</p>\n<h5 id=\"2-This-class-overrides-“equals-”-and-should-therefore-also-override-“hashCode-”\"><a href=\"#2-This-class-overrides-“equals-”-and-should-therefore-also-override-“hashCode-”\" class=\"headerlink\" title=\"2.This class overrides “equals()” and should therefore also override “hashCode()”.　\"></a>2.This class overrides “equals()” and should therefore also override “hashCode()”.　</h5><p>　　代码举例：public boolean equals(Object obj){…}  //需要添加对应的hashCode方法<br>　　解决：可以添加一个最简单的hashCode方法　　<br>　　　　　public int hashCode() {return 0;}　　　</p>\n<h5 id=\"3-Synchronize-on-a-new-“Object”-instead\"><a href=\"#3-Synchronize-on-a-new-“Object”-instead\" class=\"headerlink\" title=\"3.Synchronize on a new “Object” instead\"></a>3.Synchronize on a new “Object” instead</h5><p>　　代码举例：synchronized (“实例化”) {…}   //里边必须是对象<br>　　解决： private Object obj =”实例化”；<br>　　　　　synchronized (obj ) {…}</p>\n<h5 id=\"4-Close-this”FileInputStream”-in-a-“finally”-clause\"><a href=\"#4-Close-this”FileInputStream”-in-a-“finally”-clause\" class=\"headerlink\" title=\"4.Close this”FileInputStream” in a “finally” clause.\"></a>4.Close this”FileInputStream” in a “finally” clause.</h5><p>　　解决方法: 在finally中关闭FileInputStream，主要是关闭方式不对，finally代码块中，应该要对每个stream进行单独关闭，而不能统一写在一个try-catch代码中。</p>\n<h5 id=\"5-A”NullPointerException”-could-be-thrown-“tom”-is-nullablehere\"><a href=\"#5-A”NullPointerException”-could-be-thrown-“tom”-is-nullablehere\" class=\"headerlink\" title=\"5.A”NullPointerException” could be thrown; “tom” is nullablehere\"></a>5.A”NullPointerException” could be thrown; “tom” is nullablehere</h5><p>　　空指针，解决方式：先判断或者先实例化，再访问里面的属性或者成员。</p>\n<h5 id=\"6-Makethis-IP-“127-0-0-1”-address-configurable\"><a href=\"#6-Makethis-IP-“127-0-0-1”-address-configurable\" class=\"headerlink\" title=\"6.Makethis IP “127.0.0.1” address configurable\"></a>6.Makethis IP “127.0.0.1” address configurable</h5><p>　　解决方法:不要把IP地址写在此类中，应该在对应的系统文件或者相应的配置文件中配置</p>\n<h5 id=\"7-Either-log-or-rethrow-this-exception\"><a href=\"#7-Either-log-or-rethrow-this-exception\" class=\"headerlink\" title=\"7.Either log or rethrow this exception.\"></a>7.Either log or rethrow this exception.</h5><p>　　解决方法: 把对应的输出写成Logger.error(“aaa“);的形式 </p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Sonar代码审查-缺陷和修改\"><a href=\"#Sonar代码审查-缺陷和修改\" class=\"headerlink\" title=\"Sonar代码审查-缺陷和修改\"></a>Sonar代码审查-缺陷和修改</h2><p>Resources should be closed<br>资源未关闭，打开发现有两处用到的IO流没有关闭</p>\n<p>Conditions should not unconditionally evaluate to “TRUE” or to “FALSE”<br>if/else判断里出现了重复判断，比如在if(a&gt;10)的执行体里面又判断if(a&lt;0)，而后者肯定不会是true</p>\n<p>Exception handlers should preserve the original exception<br>处理异常的时候应该保留原始的异常情况，不要直接来个catch(Exception e)了事</p>\n<p> Throwable.printStackTrace(…) should not be called<br>不应该直接调用e.printStackTrace()，而是用Loggers来处理（就是打Log）。</p>\n<p>Loggers的优势是：Users are able to easily retrieve the logs.<br>The format of log messages is uniform and allow users to browse the logs easily.<br>Instance methods should not write to “static” fields6<br>不要用实例方法改变静态成员，理想情况下，静态变量只通过同步的静态方法来改变</p>\n<p>“public static” fields should be constant<br>公共静态成员应该加上final，也就是public static final 一般不分家</p>\n<p>Thread.run() and Runnable.run() should not be called directly<br>不应该直接调用Thread和Runnaale对象的run方法，直接调用run会使得run方法执行在当前线程，失去了开启新线程的意义。但有时候可能会这样做，下面有个例子。</p>\n<p>Generic exceptions should never be thrown<br>不太理解，大意是说不要直接抛Error,RuntimeException/Throwable/Exception这样的通用的异常。我的具体应用是：throw new Error(“Error copying database”)，给出的建议是：Define and throw a dedicated exception instead of using a generic one（定义并抛出一个专用的异常来代替一个通用的异常）</p>\n<p>Class variable fields should not have public accessibility<br>类变量不要设置为public，而是设为private，再提供get和set方法。</p>\n<p>Sections of code should not be “commented out”<br>不要再注释中出现大量的代码段，会使代码可读性变差</p>\n<p>Package declaration should match source file directory<br>这个没理解，包的声明应该与源文件目录匹配。</p>\n<p>Utility classes should not have public constructors<br>工具类不应该有公共的构造器，也就是说至少要有一个private的构造器，如果没有，默认的构造器是public的。</p>\n<p>The diamond operator (“&lt;&gt;”) should be used<br>在定义集合的时候，等号右边的&lt;&gt;内不需要再写上元素类型，直接空着就行。</p>\n<p>Lambdas and anonymous classes should not have too many lines<br>Lambdas表达式和匿名内部类不要写太多行，一般最多写20行。</p>\n<p>Anonymous inner classes containing only one method should become lambdas8<br>只包含一个方法的匿名内部类应该写成Lambdas表达式的形式，增强代码可读性</p>\n<p>Try-with-resources should be used8<br>用Try-with-resources的形式取代try/catch/finally的形式，这个有待于以后学习。<br><figure class=\"highlight plain\"><figcaption><span>con </span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   try (PreparedStatement prep = con.prepareConnection(&quot;Update ...&quot;)) &#123;</span><br><span class=\"line\">       //prep.doSomething();</span><br><span class=\"line\">       //...</span><br><span class=\"line\">       //etc</span><br><span class=\"line\">con.commit();</span><br><span class=\"line\">   &#125; catch (SQLException e) &#123;</span><br><span class=\"line\">       //any other actions necessary on failure</span><br><span class=\"line\">       con.rollback();</span><br><span class=\"line\">       //consider a re-throw, throwing a wrapping exception, etc</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Methods should not be empty<br>不要写空方法，除非这种情况：An abstract class may have empty methods, in order to provide default implementations for child classes.</p>\n<p>Source files should not have any duplicated blocks<br>源文件中不要出现任何重复的代码段或行或字符串等。没理解。</p>\n<p>“switch case” clauses should not have too many lines<br>“switch case” 每个case里面的代码不要太长，太长的话可以考虑写个方法代替，主要是为了增强代码可读性</p>\n<p>Nested blocks of code should not be left empty<br>嵌套代码块不要是空的，比如 if( a &gt; 0 ) {  doSomething()  } else { }，这时候应该把后面的else{}去掉。</p>\n<p>Methods should not be too complex<br>方法不要太复杂，否则难以理解和维护。</p>\n<p>Unused private fields should be removed<br>没有使用的private的成员变量应该移除掉。</p>\n<p>Dead stores should be removed<br>没有用到的本地变量或其他死存储应该移除掉，也就是写方法的时候，定义的变量如果后来发现根本用不到，要记得删掉那行代码。</p>\n<p>“switch” statements should end with a “default” clause<br>switch语句应该以default结束，这是一种defensive programming思想</p>\n<p>Unused method parameters should be removed<br>没有用到的方法参数应该移除掉</p>\n<p>Control flow statements “if”, “for”, “while”, “switch” and “try” should not be nested too deeply4<br>if /for/while/try这样的嵌套不要太复杂</p>\n<p>Useless parentheses around expressions should be removed to prevent any misunderstanding3<br>没有意义的括号不要随便加，以免造成误解，比如”=”两边对象类型是相同的，就不要强转。</p>\n<p>“for” loop stop conditions should be invariant<br>for循环的结果条件不能是变量，而应该是常量</p>\n<p>“static” members should be accessed statically<br>static成员是与类、静态方法相联系的。</p>\n<p>Catches should be combined<br>具体参考下面的18，我还没理解</p>\n<p>Primitives should not be boxed just for “String” conversion<br>不要使用 4+” “这样的方式将int值转变为字符串，而是使用 Integer.toString(4)这样的方式。<br>就像Integer.parseInt(“我是字符串”)这样，不要偷懒。</p>\n<p>Classes should not be empty<br>不要写空类</p>\n<p>Unused local variables should be removed<br>没有用到的本地变量要删掉</p>\n<p>“entrySet()” should be iterated when both the key and value are needed<br>直接看英文更直接：When only the keys from a map are needed in a loop, iterating the keySet makes sense. But when both the key and the value are needed, it’s more efficient to iterate theentrySet, which will give access to both the key and value, instead.<br>也就是说，如果只需要Map的Key，那么直接iterate这个Map的keySet就可以了，但是如果Key和value都需要，就iterate这个Map。具体看下面的19.</p>\n<p>Method parameters, caught exceptions and foreach variables should not be reassigned<br>方法参数/捕获的异常/foreach的变量不应该被重新赋值。</p>\n<p>Collection.isEmpty() should be used to test for emptiness<br>当判断集合是否为空的时候，不要使用if (myCollection.size() == 0) 这样的方式，而是使用if (myCollection.isEmpty()这样的方式，后者性能更高。</p>\n<p>Standard outputs should not be used directly to log anything<br>标准输出不直接打印任何东西，也就是打log的时候，不要使用System.out.println(“My Message”)这样的方式，而是使用logger.log(“My Message”)这种方式。</p>\n<p>Generic wildcard types should not be used in return parameters<br>通配符不应该出现在返回声明中。比如这句：List &lt;? extends Animal&gt;getAnimals(){…}， 我们无法知道“是否可以把a Dog, a Cat 等加进去”，等之后用到这个方法的时候，我们没必要去考虑这种问题（前面引号里面的）。</p>\n<p>Synchronized classes Vector, Hashtable, Stack and StringBuffer should not be used1<br>不要使用同步的Vector/HashTable/Stack/StringBuffer等。在早期，出于线程安全问题考虑，java API 提供了这些类。但是同步会极大影响性能，即使是在同一个线程中使用他们。<br>通常可以这样取代：<br><code>ArrayList  or  LinkedList   instead of  Vector\nDeque  instead of  Stack\nHashMap  instead of  Hashtable\nStringBuilder  instead of  StringBuffer\nExit methods should not be called</code><br>尽量不要调用system.exit()方法。</p>\n<p>Local Variables should not be declared and then immediately returned or thrown<br>本地变量如果赋值之后直接return了，那就直接return本地变量的赋值语句。</p>\n<p>Field names should comply with a naming convention<br>命名要规范</p>\n<p>Local variable and method parameter names should comply with a naming convention<br>命名要规范</p>\n<p>String literals should not be duplicated5<br>字符串不应该重复，如果多次用到同一字符串，建议将该字符串定义为字符串常量，再引用。</p>\n<p>Return of boolean expressions should not be wrapped into an “if-then-else” statement3<br>不要写if (  a &gt; 4  ) {  return false  } else { return true }这样的代码，直接写return a &gt; 4。</p>\n<p>Static non-final field names should comply with a naming convention<br>命名要规范</p>\n<p>Modifiers should be declared in the correct order<br>修饰符等要按约定俗成的顺序书写 ，例如，写成public static 而不是static public </p>\n<p>The members of an interface declaration or class should appear in a pre-defined order2<br>与前面的一个问题类似，根据Oracle定义的Java代码规范中，不同代码的出现位置应该如下所示：<br>class and instance variables–Constructors–Methods</p>\n<p>Array designators “[]” should be on the type, not the variable<br>数组的括号要写在类型后面，而不是变量后面，例如 int[] a 而不是int a[]</p>\n<p>Multiple variables should not be declared on the same line1<br>不要在同一行定义多个变量</p>\n<p>“switch” statements should have at least 3 “case” clauses<br>当至少有3种或者3种以上的情况时，才考虑用switch，否则用if/else的形式。</p>\n<p>Overriding methods should do more than simply call the same method in the super class<br>既然在子类中重写了父类的某个方法，那就再这个方法中做些与父类方法不同的事情，否则没必要重写。</p>\n<p>Statements should be on separate lines<br>不要把这样的代码写在同一行：if(someCondition)    doSomething()；而是应该写成下面的形式<br>if(someCondition) {<br>doSomething()<br>}<br>Method names should comply with a naming convention1<br>命名要规范<br>“TODO” tags should be handle    TODO标签要及时处理，该做的事情不要忘了做</p>\n<h2 id=\"部分规则详细说明\"><a href=\"#部分规则详细说明\" class=\"headerlink\" title=\"部分规则详细说明\"></a>部分规则详细说明</h2><h4 id=\"1-The-members-of-an-interface-declaration-or-class-should-appear-in-a-pre-defined-order\"><a href=\"#1-The-members-of-an-interface-declaration-or-class-should-appear-in-a-pre-defined-order\" class=\"headerlink\" title=\"1.The members of an interface declaration or class should appear in a pre-defined order\"></a>1.The members of an interface declaration or class should appear in a pre-defined order</h4><p>正确的顺序如下所示：静态成员变量→成员变量→构造器→方法</p>\n<figure class=\"highlight plain\"><figcaption><span>class Foo&#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static final int OPEN = 4;  //Class and instance variables</span><br><span class=\"line\">private int field = 0;</span><br><span class=\"line\">public Foo() &#123;...&#125;    //Constructors</span><br><span class=\"line\">public boolean isTrue() &#123;...&#125;    //Methods</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-The-diamond-operator-“-lt-gt-”-should-be-used\"><a href=\"#2-The-diamond-operator-“-lt-gt-”-should-be-used\" class=\"headerlink\" title=\"2.The diamond operator (“&lt;&gt;”) should be used\"></a>2.The diamond operator (“&lt;&gt;”) should be used</h4><p>Noncompliant Code Example：不规范的示例</p>\n<figure class=\"highlight plain\"><figcaption><span>strings </span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map&lt;String, List&lt;Integer&gt;&gt; map = new HashMap&lt;String, List&lt;Integer&gt;&gt;();  // Noncompliant</span><br><span class=\"line\">Compliant Solution ：规范的示例</span><br><span class=\"line\">List&lt;String&gt; strings = new ArrayList&lt;&gt;();</span><br><span class=\"line\">Map&lt;String, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-Sections-of-code-should-not-be-“commented-out”\"><a href=\"#3-Sections-of-code-should-not-be-“commented-out”\" class=\"headerlink\" title=\"3.Sections of code should not be “commented out”\"></a>3.Sections of code should not be “commented out”</h4><p>代码片段不应该出现在注释中，这样会bloat程序，可读性变差<br><code>Programmers should not comment out code as it bloats programs and reduces readability.\nUnused code should be deleted and can be retrieved from source control history if required.</code></p>\n<h4 id=\"4-Utility-classes-should-not-have-public-constructors\"><a href=\"#4-Utility-classes-should-not-have-public-constructors\" class=\"headerlink\" title=\"4.Utility classes should not have public constructors\"></a>4.Utility classes should not have public constructors</h4><p>工具类不应该有public的构造器，也就是工具类至少要定义一个non-public的构造器<br>Utility classes, which are a collection of static members, are not meant to be instantiated. Even abstract utility classes, which can be extended, should not have public constructors.<br>Java adds an implicit public constructor to every class which does not define at least one explicitly. Hence, at least one non-public constructor should be defined.</p>\n<figure class=\"highlight plain\"><figcaption><span>StringUtils &#123;</span><a href=\"//\">Noncompliant Code Example</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    public static String concatenate(String s1, String s2) &#123;</span><br><span class=\"line\">          return s1 + s2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><figcaption><span>StringUtils &#123;</span><a href=\"//Compliant\">Solution</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    private StringUtils() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public static String concatenate(String s1, String s2) &#123;</span><br><span class=\"line\">    return s1 + s2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"5-”public-static”-fields-should-be-constant\"><a href=\"#5-”public-static”-fields-should-be-constant\" class=\"headerlink\" title=\"5.”public static” fields should be constant\"></a>5.”public static” fields should be constant</h4><p>公共的静态成员应该加上final来修饰<br>There is no good reason to declare a field “public” and “static” without also declaring it “final”. Most of the time this is a kludge to share a state among several objects. But with this approach, any object can do whatever it wants with the shared state, such as setting it to null.<br>public static Foo foo = new Foo();//不规范的<br>public static final Foo FOO = new Foo();//规范的</p>\n<p>6.Class variable fields should not have public accessibility</p>\n<figure class=\"highlight plain\"><figcaption><span>class MyClass &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static final int SOME_CONSTANT = 0;    // Compliant - constants are not checked</span><br><span class=\"line\">public String firstName;                      // Noncompliant</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><figcaption><span>class MyClass &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static final int SOME_CONSTANT = 0;    // Compliant - constants are not checked</span><br><span class=\"line\">private String firstName;                      // Compliant</span><br><span class=\"line\">public String getFirstName() &#123;</span><br><span class=\"line\">return firstName;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public void setFirstName(String firstName) &#123;</span><br><span class=\"line\">this.firstName = firstName;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">#### 7.Static non-final field names should comply with a naming convention</span><br><span class=\"line\">public final class MyClass &#123;//Noncompliant Code Example</span><br><span class=\"line\">      private static String foo_bar;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class MyClass &#123;//Compliant Solution</span><br><span class=\"line\">private static String fooBar;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"8-”switch”-statements-should-have-at-least-3-“case”-clauses\"><a href=\"#8-”switch”-statements-should-have-at-least-3-“case”-clauses\" class=\"headerlink\" title=\"8.”switch” statements should have at least 3 “case” clauses\"></a>8.”switch” statements should have at least 3 “case” clauses</h4><p>当有3种或3种情况以上的时候，才用switch，否则用if/else<br>switch statements are useful when there are many different cases depending on the value of the same expression.<br>For just one or two cases however, the code will be more readable with if statements.</p>\n<h4 id=\"9-String-literals-should-not-be-duplicated\"><a href=\"#9-String-literals-should-not-be-duplicated\" class=\"headerlink\" title=\"9.String literals should not be duplicated\"></a>9.String literals should not be duplicated</h4><figure class=\"highlight plain\"><figcaption><span> </span><a href=\"//\">Noncompliant - \"action1\" is duplicated 3 times</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">execute(&quot;action1&quot;);</span><br><span class=\"line\">release(&quot;action1&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">private static final String ACTION_1 = &quot;action1&quot;;  // Compliant</span><br><span class=\"line\">prepare(ACTION_1);                                            // Compliant</span><br><span class=\"line\">execute(ACTION_1);</span><br><span class=\"line\">release(ACTION_1);</span><br></pre></td></tr></table></figure>\n<h4 id=\"10-Return-of-boolean-expressions-should-not-be-wrapped-into-an-“if-then-else”-statement\"><a href=\"#10-Return-of-boolean-expressions-should-not-be-wrapped-into-an-“if-then-else”-statement\" class=\"headerlink\" title=\"10.Return of boolean expressions should not be wrapped into an “if-then-else” statement\"></a>10.Return of boolean expressions should not be wrapped into an “if-then-else” statement</h4><p>Replace this if-then-else statement by a single return statement</p>\n<figure class=\"highlight plain\"><figcaption><span>(expression) &#123;//Noncompliant Code Example</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">      return true;</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">     return false;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">return expression;//Compliant Solution</span><br><span class=\"line\">return !!expression;</span><br></pre></td></tr></table></figure>\n<h4 id=\"11-Method-parameters-caught-exceptions-and-foreach-variables-should-not-be-reassigned\"><a href=\"#11-Method-parameters-caught-exceptions-and-foreach-variables-should-not-be-reassigned\" class=\"headerlink\" title=\"11.Method parameters, caught exceptions and foreach variables should not be reassigned\"></a>11.Method parameters, caught exceptions and foreach variables should not be reassigned</h4><p>方法参数，捕获的异常，foreach里的变量，都不应该重新赋值</p>\n<figure class=\"highlight plain\"><figcaption><span>MyClass &#123;//Noncompliant Code Example：不规范代码示例</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    public String name;</span><br><span class=\"line\">    public MyClass(String name) &#123;</span><br><span class=\"line\">            name = name;          // Noncompliant - useless identity assignment</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public int add(int a, int b) &#123;</span><br><span class=\"line\">        a = a + b;                // Noncompliant</span><br><span class=\"line\">        return a;                 // Seems like the parameter is returned as is, what is the point?</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">        MyClass foo = new MyClass();</span><br><span class=\"line\">        int a = 40;</span><br><span class=\"line\">        int b = 2;</span><br><span class=\"line\">        foo.add(a, b);                  // Variable &quot;a&quot; will still hold 40 after this call</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><figcaption><span>MyClass &#123;//Compliant Solution：规范代码示例</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    public String name;</span><br><span class=\"line\">    public MyClass(String name) &#123;</span><br><span class=\"line\">         this.name = name;              // Compliant</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public int add(int a, int b) &#123;</span><br><span class=\"line\">        return a + b;                  // Compliant</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public static void main(String[] args) &#123;</span><br><span class=\"line\">    MyClass foo = new MyClass();</span><br><span class=\"line\">        int a = 40;</span><br><span class=\"line\">        int b = 2;</span><br><span class=\"line\">        foo.add(a, b);</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"12-Local-Variables-should-not-be-declared-and-then-immediately-returned-or-thrown\"><a href=\"#12-Local-Variables-should-not-be-declared-and-then-immediately-returned-or-thrown\" class=\"headerlink\" title=\"12.Local Variables should not be declared and then immediately returned or thrown\"></a>12.Local Variables should not be declared and then immediately returned or thrown</h4><p>Noncompliant Code Example：不规范代码示例</p>\n<figure class=\"highlight plain\"><figcaption><span>long computeDurationInMilliseconds() &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">long duration = (((hours * 60) + minutes) * 60 + seconds ) * 1000 ;</span><br><span class=\"line\">return duration;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public void doSomething() &#123;</span><br><span class=\"line\">RuntimeException myException = new RuntimeException();</span><br><span class=\"line\">throw myException;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Compliant Solution：规范代码示例</p>\n<figure class=\"highlight plain\"><figcaption><span>long computeDurationInMilliseconds() &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">return (((hours * 60) + minutes) * 60 + seconds ) * 1000 ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public void doSomething() &#123;</span><br><span class=\"line\">throw new RuntimeException();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"13-Thread-run-and-Runnable-run-should-not-be-called-directly\"><a href=\"#13-Thread-run-and-Runnable-run-should-not-be-called-directly\" class=\"headerlink\" title=\"13.Thread.run() and Runnable.run() should not be called directly\"></a>13.Thread.run() and Runnable.run() should not be called directly</h4><p>The purpose of theThread.run()andRunnable.run()methods is to execute code in a separate, dedicated thread. Calling those methods directly doesn’t make sense because it causes their code to be executed in the current thread.<br>Thread和Runnable里面的run方法设计的目的是让run方法里面的代码在不同的线程中执行。如果直接调用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Noncompliant Code Example：不规范的代码示例</span><br><span class=\"line\">Thread myThread = new Thread(runnable);</span><br><span class=\"line\">myThread.run(); // Noncompliant</span><br><span class=\"line\"></span><br><span class=\"line\">Compliant Solution：规范代码示例</span><br><span class=\"line\">Thread myThread = new Thread(runnable);</span><br><span class=\"line\">myThread.start(); // Compliant</span><br></pre></td></tr></table></figure></p>\n<p>这部分内容为个人理解，可以略过<br>但在有些情况，也会直接调用Runnable的run方法，<br>下面这个postTaskSafely方法会保证task永远在主线程中执行</p>\n<figure class=\"highlight plain\"><figcaption><span>static void postTaskInMainThread(Runnable task) &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     int curThreadId= android.os.Process.myTid();//得到当前线程的id</span><br><span class=\"line\">    if(curThreadId==getMainThreadId()) &#123;// 如果当前线程是主线程</span><br><span class=\"line\">            task.run();//直接执行</span><br><span class=\"line\">    &#125;else&#123;// 如果当前线程不是主线程</span><br><span class=\"line\">        getMainThreadHandler().post(task);//用主线程的Handler来post</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"14-Lambdas-and-anonymous-classes-should-not-have-too-many-lines\"><a href=\"#14-Lambdas-and-anonymous-classes-should-not-have-too-many-lines\" class=\"headerlink\" title=\"14.Lambdas and anonymous classes should not have too many lines\"></a>14.Lambdas and anonymous classes should not have too many lines</h4><p>Anonymous classes and lambdas (with Java 8) are a very convenient and compact way to inject a behavior without having to create a dedicated class. But those anonymous inner classes and lambdas should be used only if the behavior to be injected can be defined in a few lines of code, otherwise the source code can quickly become unreadable.<br>anonymous class number of lines ： at most 20</p>\n<h4 id=\"15-Resources-should-be-closed：该关闭的一定记得关闭\"><a href=\"#15-Resources-should-be-closed：该关闭的一定记得关闭\" class=\"headerlink\" title=\"15.Resources should be closed：该关闭的一定记得关闭\"></a>15.Resources should be closed：该关闭的一定记得关闭</h4><p>Java’s garbage collection cannot be relied on to clean up everything. Specifically, connections, streams, files and other classes that implement theCloseableinterface or it’s super-interface,AutoCloseable, must be manually closed after creation. Failure to do so will result in a resource leak which could bring first the application and then perhaps the box it’s on to their knees.<br>Noncompliant Code Example：不规范的代码示例</p>\n<figure class=\"highlight plain\"><figcaption><span>stream </span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try&#123;</span><br><span class=\"line\">    for (String property : propertyList) &#123;</span><br><span class=\"line\">    stream = new FileOutputStream(&quot;myfile.txt&quot;);  // Noncompliant</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;catch(Exception e)&#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;finally&#123;</span><br><span class=\"line\">    stream.close();  // Multiple streams were opened. Only the last is closed.</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Compliant Solution：规范代码示例</p>\n<figure class=\"highlight plain\"><figcaption><span>stream </span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> try&#123;</span><br><span class=\"line\">     stream = new FileOutputStream(&quot;myfile.txt&quot;);</span><br><span class=\"line\">     for (String property : propertyList) &#123;</span><br><span class=\"line\">         // ...</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;catch(Exception e)&#123;</span><br><span class=\"line\">     // ...</span><br><span class=\"line\">&#125;finally&#123;</span><br><span class=\"line\">    stream.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"16-Exception-handlers-should-preserve-the-original-exception\"><a href=\"#16-Exception-handlers-should-preserve-the-original-exception\" class=\"headerlink\" title=\"16.Exception handlers should preserve the original exception\"></a>16.Exception handlers should preserve the original exception</h4><p>Noncompliant Code Example:不规范的代码示例<br>// Noncompliant - exception is lost<br>try { /<em> … </em>/ } catch (Exception e) { LOGGER.info(“context”); }<br>// Noncompliant - exception is lost (only message is preserved)<br>try { /<em> … </em>/ } catch (Exception e) { LOGGER.info(e.getMessage()); }<br>// Noncompliant - exception is lost<br>try { /<em> … </em>/ } catch (Exception e) { throw new RuntimeException(“context”); }</p>\n<p>Compliant Solution:规范的代码示例</p>\n<figure class=\"highlight plain\"><figcaption><span>&#123;</span><a href=\"/*\">... */ &#125; catch (Exception e) &#123; LOGGER.info(e); &#125;</a></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try &#123; /* ... */ &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125;</span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">/* ... */</span><br><span class=\"line\">&#125; catch (RuntimeException e) &#123;</span><br><span class=\"line\">doSomething();</span><br><span class=\"line\">throw e;</span><br><span class=\"line\">&#125; catch (Exception e) &#123;</span><br><span class=\"line\">// Conversion into unchecked exception is also allowed</span><br><span class=\"line\">throw new RuntimeException(e);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"17-Catches-should-be-combined\"><a href=\"#17-Catches-should-be-combined\" class=\"headerlink\" title=\"17.Catches should be combined\"></a>17.Catches should be combined</h4><p>Since Java 7 it has been possible to catch multiple exceptions at once. Therefore, when multiplecatchblocks have the same code, they should be combined for better readability.<br>Note that this rule is automatically disabled when the project’ssonar.java.sourceis lower than7.</p>\n<p>Noncompliant Code Example：不规范代码示例</p>\n<figure class=\"highlight plain\"><figcaption><span>(IOException e) &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    doCleanup();</span><br><span class=\"line\">    logger.log(e);</span><br><span class=\"line\">&#125;catch (SQLException e) &#123; //Noncompliant</span><br><span class=\"line\">    doCleanup();</span><br><span class=\"line\">    logger.log(e);</span><br><span class=\"line\"> &#125;catch (TimeoutException e) &#123;  // Compliant; block contents are different</span><br><span class=\"line\">     doCleanup();</span><br><span class=\"line\">     throw e;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>Compliant Solution：规范代码示例</p>\n<figure class=\"highlight plain\"><figcaption><span>(IOException|SQLException e) &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    doCleanup();</span><br><span class=\"line\">    logger.log(e);</span><br><span class=\"line\"> &#125;catch (TimeoutException e) &#123;</span><br><span class=\"line\">    doCleanup();</span><br><span class=\"line\">    throw e;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>18.”entrySet()” should be iterated when both the key and value are needed<br>Noncompliant Code Example：不规范的代码示例</p>\n<figure class=\"highlight plain\"><figcaption><span>void doSomethingWithMap(Map map) &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (String key : map.keySet()) &#123;  // Noncompliant; for each key the value is retrieved</span><br><span class=\"line\">Object value = map.get(key);</span><br><span class=\"line\">// ...</span><br><span class=\"line\">&#125;   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Compliant SolutionL：规范代码示例</p>\n<figure class=\"highlight plain\"><figcaption><span>void doSomethingWithMap(Map map) &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (Map.Entry entry : map.entrySet()) &#123;</span><br><span class=\"line\">String key = entry.getKey();</span><br><span class=\"line\">Object value = entry.getValue();</span><br><span class=\"line\">// ...</span><br><span class=\"line\">&#125;   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Use a logger to log this exception<br>You should probably clarify which logger are you using.</p>\n<p>org.apache.commons.logging.Log interface has method void error(Object message, Throwable t) (and method void info(Object message, Throwable t)), which logs the stack trace together with your custom message. Log4J implementation has this method too.</p>\n<p>So, probably you need to write:<br>logger.error(“BOOM!”, e);<br>If you need to log it with INFO level (though, it might be a strange use case), then:<br>logger.info(“Just a stack trace, nothing to worry about”, e);<br>Hope it helps.</p>\n<p>Rename ‘i’ as this name is already used in declaration at line 26</p>\n<h2 id=\"阻断\"><a href=\"#阻断\" class=\"headerlink\" title=\"阻断\"></a>阻断</h2><h4 id=\"1、Close-this”FileInputStream”-in-a-“finally”-clause\"><a href=\"#1、Close-this”FileInputStream”-in-a-“finally”-clause\" class=\"headerlink\" title=\"1、Close this”FileInputStream” in a “finally” clause.\"></a>1、Close this”FileInputStream” in a “finally” clause.</h4><p>在finally中关闭FileInputStream，这个最为常见，主要是关闭方式不对，finally代码块中，应该要对每个stream进行单独关闭，而不能统一写在一个try-catch代码中，jdk 7 可以考虑try-resources方式关闭，代码相对优雅。<br>另外数据库操作的statement和resultRs没有关闭的情况也非常多。这个也是要重点留意的地方。</p>\n<h4 id=\"2、A”NullPointerException”-could-be-thrown-“tom”-is-nullablehere\"><a href=\"#2、A”NullPointerException”-could-be-thrown-“tom”-is-nullablehere\" class=\"headerlink\" title=\"2、A”NullPointerException” could be thrown; “tom” is nullablehere\"></a>2、A”NullPointerException” could be thrown; “tom” is nullablehere</h4><p>空指针，极为讨厌的问题，主要是编码经验缺少的体现。一般的高手在编码过程中，就会第一时间考虑到这类情况，并做相应的处理。解决方式无它，先判断或者先实例化，再访问里面的属性或者成员。</p>\n<h2 id=\"严重\"><a href=\"#严重\" class=\"headerlink\" title=\"严重\"></a>严重</h2><h4 id=\"1、Define-and-throw-a-dedicated-exception-instead-of-using-a-generic-one\"><a href=\"#1、Define-and-throw-a-dedicated-exception-instead-of-using-a-generic-one\" class=\"headerlink\" title=\"1、Define and throw a dedicated exception instead of using a generic one\"></a>1、Define and throw a dedicated exception instead of using a generic one</h4><p>定义并抛出一个专用的异常来代替一个通用的异常。</p>\n<h4 id=\"2、Removethis-hard-coded-password\"><a href=\"#2、Removethis-hard-coded-password\" class=\"headerlink\" title=\"2、Removethis hard-coded password\"></a>2、Removethis hard-coded password</h4><p>移除代码里硬编码的密码信息。会有少许的误判的情况，一般是变量包含：PWD或者password，所以如果真的不是硬编码，可以考虑更换变量名称，比如PWD改PW等等。</p>\n<h4 id=\"3、Eitherlog-or-rethrow-this-exception\"><a href=\"#3、Eitherlog-or-rethrow-this-exception\" class=\"headerlink\" title=\"3、Eitherlog or rethrow this exception\"></a>3、Eitherlog or rethrow this exception</h4><p>catch异常之后，使用log方式或者throw异常的方式解决。如果业务上真的没有throw或者记录日志的话，可以使用log.debug的方式填充来解决问题。</p>\n<h4 id=\"4、Makethis-IP-“127-0-0-1”-address-configurable\"><a href=\"#4、Makethis-IP-“127-0-0-1”-address-configurable\" class=\"headerlink\" title=\"4、Makethis IP “127.0.0.1” address configurable\"></a>4、Makethis IP “127.0.0.1” address configurable</h4><p>将IP弄到配置文件中，不要硬编码到代码里。个人觉得改动稍大！</p>\n<h4 id=\"5、Make-this”public-static-JSAPI”-field-final\"><a href=\"#5、Make-this”public-static-JSAPI”-field-final\" class=\"headerlink\" title=\"5、Make this”public static JSAPI” field final\"></a>5、Make this”public static JSAPI” field final</h4><p>如果你将这个变量设置为public访问方式，同时又是静态Static方式，就要考虑将它设置为final了，因为这个是共享变量，其它类可以随时随地将它设置为别的值。所以如果是只是当前类使用，可以考虑将公开访问方式改为私有。</p>\n<h4 id=\"6、Makethe-enclosing-method-“static”-or-remove-this-set\"><a href=\"#6、Makethe-enclosing-method-“static”-or-remove-this-set\" class=\"headerlink\" title=\"6、Makethe enclosing method “static” or remove this set\"></a>6、Makethe enclosing method “static” or remove this set</h4><p>见代码：</p>\n<figure class=\"highlight plain\"><figcaption><span>class MyClass &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  private static int count = 0;</span><br><span class=\"line\">  public void doSomething() &#123;</span><br><span class=\"line\">    //...</span><br><span class=\"line\">    count++;  // Noncompliant</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">```不要使用非静态方法去更新静态字段，这样很难获得正确的结果，如果有多个类实例和/或多个线程，则很容易导致错误。理想情况下，静态字段仅从同步静态方法中更新。</span><br><span class=\"line\">#### 7、Override&quot;equals(Object obj)&quot; to comply with the contract of the&quot;compareTo(T o)&quot; method</span><br><span class=\"line\">如果重写了compareTo方法，同时也应重写equals方法。</span><br><span class=\"line\">#### 8、Make&quot;body&quot; transient or serializable.</span><br><span class=\"line\"></span><br><span class=\"line\">```public class Address &#123;</span><br><span class=\"line\">  //...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public class Person implements Serializable &#123;</span><br><span class=\"line\">  private static final long serialVersionUID = 1905122041950251207L;</span><br><span class=\"line\">  private String name;</span><br><span class=\"line\"></span><br><span class=\"line\">  private Address address;  // Noncompliant; Address isn&apos;t serializable</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果person已经序列化，其成员变量Address也进行序列化。不然转化时会有问题。</p>\n<h4 id=\"9-Floating-point-numbers-should-not-be-tested-for-equality\"><a href=\"#9-Floating-point-numbers-should-not-be-tested-for-equality\" class=\"headerlink\" title=\"9 Floating point numbers should not be tested for equality\"></a>9 Floating point numbers should not be tested for equality</h4><p>浮点类型的数字，不要通过==或者!=方式其它类型比较，因为浮点是不精确的，所以在比较时，会进行类型升级升级原则如下：<br>·  如果运算符任意一方的类型为double，则另一方会转换为double<br>·  否则，如果运算符任意一方的类型为float，则另一方会转换为float<br>·  否则，如果运算符任意一方的类型为long，则另一方会转换为long<br>·  否则，两边都会转换为int</p>\n<p>以下的方式得到的结果都是false。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">float myNumber = 3.146;</span><br><span class=\"line\">if ( myNumber == 3.146f ) &#123; //Noncompliant. Because of floating point imprecision, this will be false</span><br><span class=\"line\"> </span><br><span class=\"line\">if ( myNumber != 3.146f ) &#123; //Noncompliant. Because of floating point imprecision, this will be true</span><br><span class=\"line\">if (myNumber &lt; 4 || myNumber &gt; 4) &#123; // Noncompliant; indirect  </span><br><span class=\"line\">float zeroFloat = 0.0f;</span><br><span class=\"line\">if (zeroFloat == 0) &#123;  // Noncompliant. Computations may end up with a value close but not equal to zero.</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以，要比较浮点数是否相等，需要做的事情是：</p>\n<pre><code>排除NaN和无穷\n\n在精度范围内进行比较\n</code></pre><p>正确的例子：</p>\n<figure class=\"highlight plain\"><figcaption><span>boolean isEqual(double a, double b) &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    if (Double.isNaN(a) || Double.isNaN(b) || Double.isInfinite(a) || Double.isInfinite(b)) &#123;</span><br><span class=\"line\">       return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return (a - b) &lt; 0.001d;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"10、Thiscall-to-“contains-”-may-be-a-performance-hot-spot-if-the-collectionis-large\"><a href=\"#10、Thiscall-to-“contains-”-may-be-a-performance-hot-spot-if-the-collectionis-large\" class=\"headerlink\" title=\"10、Thiscall to “contains()” may be a performance hot spot if the collectionis large.\"></a>10、Thiscall to “contains()” may be a performance hot spot if the collectionis large.</h4><p>如果collection的记录数非常大的话，它的contains方法的时间复杂度是很高的。所以开发过程中要注意这一点。下面的是列表：</p>\n<figure class=\"highlight plain\"><figcaption><span>ArrayList</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">contains</span><br><span class=\"line\">remove</span><br><span class=\"line\">·  LinkedList</span><br><span class=\"line\"></span><br><span class=\"line\">get</span><br><span class=\"line\">contains</span><br><span class=\"line\">·  ConcurrentLinkedQueue</span><br><span class=\"line\"></span><br><span class=\"line\">size</span><br><span class=\"line\">contains</span><br><span class=\"line\">·  ConcurrentLinkedDeque</span><br><span class=\"line\"></span><br><span class=\"line\">size</span><br><span class=\"line\">contains</span><br><span class=\"line\">·  CopyOnWriteArrayList</span><br><span class=\"line\"></span><br><span class=\"line\">add</span><br><span class=\"line\">contains</span><br><span class=\"line\">remove</span><br><span class=\"line\">·  CopyOnWriteArraySet</span><br><span class=\"line\"></span><br><span class=\"line\">add</span><br><span class=\"line\">contains</span><br><span class=\"line\">remove</span><br></pre></td></tr></table></figure>\n<h5 id=\"1-Equality-tests-should-not-be-made-with-floating-point-value\"><a href=\"#1-Equality-tests-should-not-be-made-with-floating-point-value\" class=\"headerlink\" title=\"1.Equality tests should not be made with floating point value\"></a>1.Equality tests should not be made with floating point value</h5><p>　　代码举例： if (result == num) //result和num均为double 之间比较会有精度损失<br>　　解决：BigDecimal data1 = new BigDecimal(totalArea);<br>　　　　　BigDecimal data2 = new BigDecimal(s1);<br>　　　　    int num = data1.compareTo(data2);//num =0 相等  &gt;0前者大于后者 ，反之 &lt;0 前者小于后者</p>\n<h5 id=\"2-This-class-overrides-“equals-”-and-should-therefore-also-override-“hashCode-”\"><a href=\"#2-This-class-overrides-“equals-”-and-should-therefore-also-override-“hashCode-”\" class=\"headerlink\" title=\"2.This class overrides “equals()” and should therefore also override “hashCode()”.　\"></a>2.This class overrides “equals()” and should therefore also override “hashCode()”.　</h5><p>　　代码举例：public boolean equals(Object obj){…}  //需要添加对应的hashCode方法<br>　　解决：可以添加一个最简单的hashCode方法　　<br>　　　　　public int hashCode() {return 0;}　　　</p>\n<h5 id=\"3-Synchronize-on-a-new-“Object”-instead\"><a href=\"#3-Synchronize-on-a-new-“Object”-instead\" class=\"headerlink\" title=\"3.Synchronize on a new “Object” instead\"></a>3.Synchronize on a new “Object” instead</h5><p>　　代码举例：synchronized (“实例化”) {…}   //里边必须是对象<br>　　解决： private Object obj =”实例化”；<br>　　　　　synchronized (obj ) {…}</p>\n<h5 id=\"4-Close-this”FileInputStream”-in-a-“finally”-clause\"><a href=\"#4-Close-this”FileInputStream”-in-a-“finally”-clause\" class=\"headerlink\" title=\"4.Close this”FileInputStream” in a “finally” clause.\"></a>4.Close this”FileInputStream” in a “finally” clause.</h5><p>　　解决方法: 在finally中关闭FileInputStream，主要是关闭方式不对，finally代码块中，应该要对每个stream进行单独关闭，而不能统一写在一个try-catch代码中。</p>\n<h5 id=\"5-A”NullPointerException”-could-be-thrown-“tom”-is-nullablehere\"><a href=\"#5-A”NullPointerException”-could-be-thrown-“tom”-is-nullablehere\" class=\"headerlink\" title=\"5.A”NullPointerException” could be thrown; “tom” is nullablehere\"></a>5.A”NullPointerException” could be thrown; “tom” is nullablehere</h5><p>　　空指针，解决方式：先判断或者先实例化，再访问里面的属性或者成员。</p>\n<h5 id=\"6-Makethis-IP-“127-0-0-1”-address-configurable\"><a href=\"#6-Makethis-IP-“127-0-0-1”-address-configurable\" class=\"headerlink\" title=\"6.Makethis IP “127.0.0.1” address configurable\"></a>6.Makethis IP “127.0.0.1” address configurable</h5><p>　　解决方法:不要把IP地址写在此类中，应该在对应的系统文件或者相应的配置文件中配置</p>\n<h5 id=\"7-Either-log-or-rethrow-this-exception\"><a href=\"#7-Either-log-or-rethrow-this-exception\" class=\"headerlink\" title=\"7.Either log or rethrow this exception.\"></a>7.Either log or rethrow this exception.</h5><p>　　解决方法: 把对应的输出写成Logger.error(“aaa“);的形式 </p>\n"},{"title":"Kettle插件架构","date":"2017-04-15T11:42:49.000Z","_content":"#  #Kettle插件体系\n最近公司内有业务系统到数据中心同步的升级改造需求，从各个业务系统收集增量数据到数据中心的数据仓库平台。因为开发周期短暂，需要快速的响应，开发出可用的产品，所以决定借鉴开源程序Kettle，开发一个文件解析组件，然后利用Kettle平台的大数据组件进行与数据中心大数据平台对接\n\n数据同步部分是：业务系统（RDBMS）->Kettle(azkaban进行调度)->数据中心，因为Kettle的增量抽取组件经常出现数据不一致等问题，所以目前已更改为：业务系统（RDBMS）->OGG（CDC增量抽取）->数据中心的方式。\n\n本文主要介绍如何扩展Kettle的功能，部分内容来自《Pentaho Kettle解决方案：使用PDI构建开源ETL解决方案》一书，推荐购买阅读。\n##  ##架构\n我们先看Kettle插件架构。\n ![](http://i.imgur.com/mLvXMuV.jpg)\n从功能上看，Kettle内部的对象和外部插件没有任何区别。因为它们使用的API都是一样的，它们只是在运行时的加载方式不同。\n从Kettle4以后，Kettle内部有一个插件注册系统，它负责加载各种内部和外部插件。插件有以下两个标识属性。\n**插件类型**：由PluginTypeInterface接口定义。例如StepPluginType、JobEntryPluginType、PartitionerPluginType和RepositoryPluginType。\n**插件ID**：这是一个字符串数组，用来唯一标识一个插件。因为旧的插件可以被新的插件代替，一个插件可以有多个ID。在大多数情况下，插件只使用一个单一的字符串，如TableInput是“表输入”步骤的ID，MYSQL是MySQL数据库类型的ID。\n当Kettle环境初始化以后，插件注册系统首先加载所有的内部对象，Kettle读取下面的配置文件来加载内部对象，这些配置文件位于Kettle的.jar文件中。\n\t Kettle-steps.xml：内部转换步骤。\n\t Kettle-job-entries.xml：内部作业项。\n\t Kettle-partition-plugins.xml：内部分区类型。\n\t Kettle-database-types.xml：内部数据库类型。\n\t Kettle-repositories.xml：内部资源库类型。\n\n插件注册系统加载了所有的内部对象后，就要搜索可用的外部插件。通过浏览plugins/目录的各个子目录下的.jar文件来完成。它搜索特定的Kettle annotations来判断一个类是否是插件。加载过程将在本章的后面介绍。\n因为在内部对象加载后才加载插件，所以插件会替代相同ID的已加载的内部对象。例如，你创建了插件，插件的ID是TableInput，就可以替换Kettle标准的“表输入”步骤。这个功能可以让你用插件替换Kettle内置的步骤。可以通过子类继承方式，直接扩展已有步骤的某些功能。\n\n##  ##插件类型\nKettle有下面几种插件类型（下面的插件是Kettle4.0的插件类型，新版kettle包含了很多新的插件，比如视图插件、大数据插件等等）。\n\n- 转换步骤插件：在Kettle转换中使用的步骤，用来处理数据行。\n\n\n- 作业项插件：在Kettle作业中使用的作业项，用来实现某个任务。\n\t\n\n- 分区方法插件：利用输入字段的值指定自己的分区规则。\n\t\n\n- 数据库类型插件：用来扩展不同的数据库类型。\n\t\n\n- 资源库类型插件：可以把Kettle元数据保存为自定义类型或格式。\n\n说明：除了这些类型，还有Spoon类型的插件，可以把功能扩展到Spoon，本书不介绍这个功能。\n##  ##转换步骤插件\n转换步骤插件包括了四个Java类，这四个类分别实现四个接口。\n\n\n- StepMetaInterface：这个接口对外 提供步骤的元数据并处理串行化。\n\n\n- StepInterface:这个接口根据上面接口提供的元数据，来实现步骤的具体功能。\n\n\n- StepDataInterface:这个接口用来存储步骤的临时数据、文件句柄等。\n\n\n- StepDialogInterface:这个接口是Spoon里的图形界面，用来编辑步骤的元数据。\n\n接下来，我们介绍这些接口的基本内容。对于每个接口，在一个简单的“Hello World”例子里提供这些类的相应实现。“Hello World”例子将在数据流里增加一个字段，字段名用户可以自定义，字段值是”Hello world!“。最后介绍一下如何部署这个例子。\n###  ###StepMetaInterface\n接口org.pentaho.di.trans.step.StepMetaInterface负责步骤里所有和元数据相关的任务。和元数据相关的工作包括：  \n元数据和XML(或资源库)之间的序列化和反序列化  \ngetXML（）和loadXML()  \nsaveRep()和readRep()  \n\n描述输出字段  \ngetFields()  \n\n检验元数据是否正确  \nCheck()  \n\n获取步骤相应的要SQL语句，使步骤可以正确运行  \ngetSQLStatements()  \n\n给元数据设置默认值  \nsetDefault()  \n\n完成对数据库的影响分析  \nanalyseImpact()  \n\n描述各类输入和输出流  \ngetStepIOMeta()  \nsearchInfoAndTargetSteps()  \nhandleStreamSelection()  \ngetOptionalStreams()  \nresetStepIoMeta()  \n\n导出元数据资源  \nexportResources()  \ngetResourceDependencies()  \n\n描述使用的库  \ngetUsedLibraries()  \n\n描述使用的数据库连接  \ngetUsedDatabaseConnections()  \n\n描述这个步骤需要的字段（通常是一个数据库表）  \ngetRequiredFields()  \n\n描述步骤是否具有某些功能  \nsupportsErrorHandling()  \nexcludeFromRowLayoutVerification()  \nexcludeFromCopyDistributeVerification()  \n\n这个接口里还定义了几个方法来说明这四个接口如何结合到一起。  \nString getDialogClassName():用来描述实现了StepDialogInterface接口的对话框类的名字。如果这个方法返回了null，调用类会根据实现了StepMetaInterface接口的类的类名和包名来自动生成对话框类的名字。  \nSetpInterface getStep():创建一个实现了StepInterface接口的类。  \nStepDataInterface getStepData():创建一个实现了StepDataInterface接口的类。  \n现在我们看看”Hello World”例子里对SetpMetaInterface接口的实现  \nHelloworldStepMeta.java\n    package org.kettlesolutions.plugin.step.helloworld;\n    \n    import java.util.List;\n    import java.util.Map;\n    \n    import org.pentaho.di.core.CheckResult;\n    import org.pentaho.di.core.CheckResultInterface;\n    import org.pentaho.di.core.Const;\n    import org.pentaho.di.core.Counter;\n    import org.pentaho.di.core.annotations.Step;\n    import org.pentaho.di.core.database.DatabaseMeta;\n    import org.pentaho.di.core.exception.KettleException;\n    import org.pentaho.di.core.exception.KettleStepException;\n    import org.pentaho.di.core.exception.KettleXMLException;\n    import org.pentaho.di.core.row.RowMetaInterface;\n    import org.pentaho.di.core.row.ValueMeta;\n    import org.pentaho.di.core.row.ValueMetaInterface;\n    import org.pentaho.di.core.variables.VariableSpace;\n    import org.pentaho.di.core.xml.XMLHandler;\n    import org.pentaho.di.i18n.BaseMessages;\n    import org.pentaho.di.repository.ObjectId;\n    import org.pentaho.di.repository.Repository;\n    import org.pentaho.di.trans.Trans;\n    import org.pentaho.di.trans.TransMeta;\n    import org.pentaho.di.trans.step.BaseStepMeta;\n    import org.pentaho.di.trans.step.StepDataInterface;\n    import org.pentaho.di.trans.step.StepInterface;\n    import org.pentaho.di.trans.step.StepMeta;\n    import org.pentaho.di.trans.step.StepMetaInterface;\n    import org.w3c.dom.Node;\n    \n    @Step(\n    \t\tid=\"Helloworld\",\n    \t\tname=\"name\",\n    \t\tdescription=\"description\",\n    \t\tcategoryDescription=\"categoryDescription\", \n    \t\timage=\"org/kettlesolutions/plugin/step/helloworld/HelloWorld.png\",\n    \t\ti18nPackageName=\"org.kettlesolutions.plugin.step.helloworld\"\n    ) \n    public class HelloworldStepMeta extends BaseStepMeta implements StepMetaInterface {\n    \t/**\n    \t * PKG变量说明了messages包的位置，在messages包里有各种国际化的资源文件。\n    \t * 在本章后面经常要看到的BaseMessages.getString()方法，就是根据软件的国际化\n    \t * 设置，从不同的文件中获取文字。PKG变量通常位于类的最上方，被国际化图形工具使用，\n    \t * 通过国际化图形工具，国际化人员可以编辑不同的国际化资源文件。所以我们会在很多Kettle\n    \t * 代码里看见这样的结构。\n    \t */\n    \tprivate static Class<?> PKG = HelloworldStep.class; //for i18n\n    \tpublic enum Tag {//field_name用于保存用户输入的字段名：保存“Hello，world！\"字符串的字段名。\n    \t\tfield_name,\n    \t};\n    \t\n    \tprivate String fieldName;\n    \t\n    \t/**\n    \t * @return the fieldName\n    \t */\n    \tpublic String getFieldName() {\n    \t\treturn fieldName;\n    \t}\n    \n    \t/**\n    \t * @param fieldName the fieldName to set\n    \t */\n    \tpublic void setFieldName(String fieldName) {\n    \t\tthis.fieldName = fieldName;\n    \t}\n    \n    \t/**\n    \t * checks parameters, adds result to List<CheckResultInterface>\n    \t * used in Action > Verify transformation\n    \t * 验证用户是否在对话框里输入了字段名，并把验证结果添加到检验转换时出现的问题列表里。（最好\n    \t * 要检验用户输入的所有选项，而不只是容易出错的选项）\n    \t */\n    \tpublic void check(List<CheckResultInterface> remarks, TransMeta transMeta, StepMeta stepMeta, \n    \t\t\tRowMetaInterface prev, String input[], String output[], RowMetaInterface info) {\n    \t\t\n    \t\tif (Const.isEmpty(fieldName)) {\n    \t\t\tCheckResultInterface error = new CheckResult(\n    \t\t\t\tCheckResult.TYPE_RESULT_ERROR, \n    \t\t\t\tBaseMessages.getString(PKG, \"HelloworldMeta.CHECK_ERR_NO_FIELD\"), \n    \t\t\t\tstepMeta\n    \t\t\t);\n    \t\t\tremarks.add(error);\n    \t\t} else {\n    \t\t\tCheckResultInterface ok = new CheckResult(\n    \t\t\t\tCheckResult.TYPE_RESULT_OK, \n    \t\t\t\tBaseMessages.getString(PKG, \"HelloworldMeta.CHECK_OK_FIELD\"), \n    \t\t\t\tstepMeta\n    \t\t\t);\n    \t\t\tremarks.add(ok);//把验证结果添加到检验转换时出现的问题列表里。\n    \t\t}\n    \t}\n    \n    \t/**\n    \t *\tcreates a new instance of the step (factory)\n    \t * getStep、getStepData和getDialogClassName()方法提供了与这个步骤里其它三个接口之间的桥梁\n    \t 这个接口里还定义了几个方法来说明这四个接口如何结合到一起。\n    \tString getDialogClassName():用来描述实现了StepDialogInterace接口的对话框类的名字。如果这个方法返回\n    \t\t\t\t了null，调用类会根据实现了StepMetaInterface接口的类的类名和包名来自动生成对话框类的名字。\n    \tStepInterface getStep():创建一个实现了StepInterface接口的类。\n    \tStepInterface getStepData():创建一个实现了StepDataInterface接口的类。\n    \n    \t */\n    \tpublic StepInterface getStep(StepMeta stepMeta, StepDataInterface stepDataInterface,\n    \t\t\tint copyNr, TransMeta transMeta, Trans trans) {\n    \t\treturn new HelloworldStep(stepMeta, stepDataInterface, copyNr, transMeta, trans);\n    \t}\n    \n    \t/**\n    \t * creates new instance of the step data (factory)\n    \t * getStep、getStepData和getDialogClassName()方法提供了与这个步骤里其它三个接口之间的桥梁\n    \t */\n    \tpublic StepDataInterface getStepData() {\n    \t\treturn new HelloworldStepData();\n    \t}\n    \t/**\n    \t * getStep、getStepData和getDialogClassName()方法提供了与这个步骤里其它三个接口之间的桥梁\n    \t */\n    \t@Override\n    \tpublic String getDialogClassName() {\n    \t\treturn HelloworldStepDialog.class.getName();\n    \t}\n    \n    \t/**\n    \t * deserialize from xml \n    \t * databases = list of available connections\n    \t * counters = list of sequence steps\n    \t * \n    \t * 下面的四个方法loadXML()、getXML()、readRep()和saveRep()把元数据保存到XML文件或资源库里，\n    \t * 或者从XML文件或资源库读取元数据。保存到文件的方法利用了像XStream（http://xstream.codehaus.org）这\n    \t * 样的XML串行化技术。\n    \t */\n    \tpublic void loadXML(Node stepDomNode, List<DatabaseMeta> databases,\n    \t\t\tMap<String, Counter> sequenceCounters) throws KettleXMLException {\n    \t\tfieldName = XMLHandler.getTagValue(stepDomNode, Tag.field_name.name());\n    \t}\n    \t\n    \t/**\n    \t * @Override\n    \t */\n    \tpublic String getXML() throws KettleException {\n    \t\tStringBuilder xml = new StringBuilder();\n    \t\txml.append(XMLHandler.addTagValue(Tag.field_name.name(), fieldName));\n    \t\treturn xml.toString();\n    \t}\n    \t\n    \t/**\n    \t * De-serialize from repository (see loadXML)\n    \t */\n    \tpublic void readRep(Repository repository, ObjectId stepIdInRepository,\n    \t\t\tList<DatabaseMeta> databases, Map<String, Counter> sequenceCounters)\n    \t\t\tthrows KettleException {\n    \t\tfieldName = repository.getStepAttributeString(stepIdInRepository, Tag.field_name.name());\n    \t}\n    \n    \t/**\n    \t * serialize to repository\n    \t */\n    \tpublic void saveRep(Repository repository, ObjectId idOfTransformation, ObjectId idOfStep)\n    \t\t\tthrows KettleException {\n    \t\trepository.saveStepAttribute(idOfTransformation, idOfStep, Tag.field_name.name(), fieldName);\n    \t}\n    \t\n    \t\n    \t/**\n    \t * initiailize parameters to default\n    \t */\n    \tpublic void setDefault() {\n    \t\tfieldName = \"helloField\";\n    \t}\n    \n    \t/**\n    \t * getFields()方法非常重要，因为它描述了输出数据行的结构。这个方法需要修改inputRowMeta对象，使这个对象和\n    \t * 输出格式匹配。Spoon和后面的步骤都需要知道这个步骤要输出哪些字段。最常见的一种方法，可以给输出的RowMetaInterface对象\n    \t * 添加一个ValueMetaInterface对象。在ValueMetaInterface对象里设置的信息越详细越好，可以设置的信息包括数据类型、长度、\n    \t * 精度、格式掩码，等等。添加的字段描述元信息越多，后面生成的SQL就越准确。\n    \t */\n    \t@Override\n    \tpublic void getFields(RowMetaInterface inputRowMeta, String name,\n    \t\t\tRowMetaInterface[] info, StepMeta nextStep, VariableSpace space)\n    \t\t\tthrows KettleStepException {\n    \t\tString realFieldName = space.environmentSubstitute(fieldName);\n    \t\t//值的元数据使用ValueMetaInterface接口描述数据流里的一个字段。这个接口里定义了字段的名字、数据类型、长度、精度，等等。下面的例子用于创建一个ValueMetaInterface对象。\n    \t\tValueMetaInterface field = new ValueMeta(realFieldName, ValueMetaInterface.TYPE_STRING);\n    \t\tfield.setOrigin(name);\t\t\n    \t\tinputRowMeta.addValueMeta(field);\n    \t}\n    }\n\n\n\n代码解析\n    @Step(\n    \t\tid=\"Helloworld\",\n    \t\tname=\"name\",\n    \t\tdescription=\"description\",\n    \t\tcategoryDescription=\"categoryDescription\", \n    \t\timage=\"org/kettlesolutions/plugin/step/helloworld/HelloWorld.png\",\n    \t\ti18nPackageName=\"org.kettlesolutions.plugin.step.helloworld\"\n    )\n这段代码里的@Step annotation用来通知Kettle的插件注册系统：这个类是一个步骤类型的插件。在annotation里可以指定插件的ID、图标、国际代的包、本地化的名称、类别、描述。其中后三项是资源文件里的Key，需要在资源文件里设置真正的值。i18nPackageName指定了资源文件的包名，例如我们这个例子的资源文件位于org/kettlesolutions/plugin/step/helloworld/messages目录下，en_US（英语，美国）的本地代资源文件是messages_en_US.properties。我们例子里的这个资源文件的内容是：\nname=Hello world\ndescription=A very simple step that adds a new \"Helllo world\" field to the incoming stream\n注意，如果你指定了不存在的分类，Spoon会创建这个分类，并在Spoon的分类树的最上方显示这个分类。\n最后，annotation里的image标签指定了插件的图标。需要32*32像素的PNG文件，可以使用透明样式。\n后面的代码行说明这个类实现了StepMetaInterface接口。在BaseStepMeta抽象类里定义了这个接口的很多默认实现，可以直接继承这个抽象类，然后把工作集中在插件特有的功能上。\n\n    public class HelloworldStepMeta extends BaseStepMeta implements StepMetaInterface\n\t\n\n\n下面的四个方法loadXML()、getXML()、readRep()和saveRep()把元数据保存到XML文件或资源库里，或者从XML文件或资源库读取元数据。保存到文件的方法利用了像XStream（http://xstream.codehaus.org）这样的XML串行化技术。\n\n\ngetFields()方法非常重要，因为它描述了输出数据行的结构。这个方法需要修改inputRowMeta对象，使这个对象和输出格式匹配。Spoon和后面的步骤都需要知道这个步骤要输出哪些字段。最常见的一种方法，可以给输出的RowMetaInterface对象添加一个ValueMetaInterface对象。在ValueMetaInterface对象里设置的信息越详细越好，可以设置的信息包括数据类型、长度、精度、格式掩码，等等。添加的字段描述元信息越多，后面生成的SQL就越准确。\n####  ####值的元数据（Value Metadata）\n值的元数据使用ValueMetaInterface接口描述数据流里的一个字段。这个接口里定义了字段的名字、数据类型、长度、精度，等等。下面的例子用于创建一个ValueMetaInterface对象。  \n    ValueMetaInterface dateMeta = new ValueMeta(“birthdate”,ValueMetaInterface.TYPE_DATE);\n这个接口也负责转换数据格式。我们建议使用ValueMetaInterface接口来完成所有数据转换的工作。例如，日期类型的数据，如果想把它转换为dateMeta对象里定义的字符串格式，可以用下面的代码：  \n    //java.util.Date birthdate\n    String birthDateString = dateMeta.getString(birthdate);\nValueMeta类负责转换。因为有ValueMetaInterface进行数据类型的转换，所以你不用再去做额外的数据类型转换的工作。  \n使用ValueMetaInterface接口时还要注意数据对象是否为Null。从上一个步骤可以接收到一个数据对象和一个描述数据对象的ValueMetaInterface对象。我们要检查这个数据对象是否为null，在某些情况下如果数据对象为空是不正确的。例如：  \n数据对象是String类型，有10个空格，Value Metadata需要trim这个字符串。  \n在Value Metadata里已经定义了从文本文件里加载的数据，要延迟转换为字符串。所以数据要由二进制的格式（原始数据格式），转换为字符串格式，然后再转换为其它格式的数据。  \n一般使用下面的方法检查数据对象是否为空：  \n    Boolean n = valueMeta.isNull(valueDate);\n重要：要保证传给ValueMetaInterface对象的数据是在元数据里定义的数据类型。表23-1说明了  ValueMetaInterface里定义的数据类型和Java数据类型的对应关系。  \nKettle元数据类型和Java里数据类型的对应关系  \n<table>\n    <tr>\n        <th>Value Meta Type</th>\n        <th>Java Class</th>\n    </tr>\n    <tr>\n        <td>ValueMetaInterface.TYPE_STRING</td>\n        <td>Java.lang.String</td>\n    </tr>\n    <tr>\n        <td>ValueMetaInterface.TYPE_DATE</td>\n        <td>Java.util.Date</td>\n    </tr>\n    <tr>\n        <td>ValueMetaInterface.TYPE_BOOLEAN</td>\n        <td>Java.lang.Boolean</td>\n    </tr>\n\t<tr>\n        <td>ValueMetaInterface.TYPE_NUMBER</td>\n        <td>Java.lang.Double</td>\n    </tr>\n\t<tr>\n        <td>ValueMetaInterface.TYPE_INTEGER</td>\n        <td>Java.lang.Long</td>\n    </tr>\n\t<tr>\n        <td>ValueMetaInterface.TYPE_BIGNUMBER</td>\n        <td>Java.math.BigDecimal</td>\n    </tr>\n\t<tr>\n        <td>ValueMetaInterface.TYPE_BINARY</td>\n        <td>Byte[]</td>\n    </tr>\n</table>\n\n\n####  ####行的元数据（Row Meatadata）\n行的元数据使用RowMetaInterface接口来描述数据行的元数据，而不是一个列的元数据。实际上，RowMetaInterface的类里包含了一组ValueMetaInterface。另外还包括了一些方法来操作行元数据，倒如查询值、检查值是否存、替换值的元数据等。  \n行的元数据里唯一的规则就是一行里的列的名字必须唯一。当你添加了一个新列时，如果新列的名字和已有列的名字相同，列名后面会自动加上“_2”后缀。如果再加一个同名的列会自动加上”_3“后缀，等等。  \n因为在步骤里通常是和数据行打交道，所以从数据行里直接取数据会更方便。可以使用很多类似于getNumber()、getString()这样的方法直接从数据行取数据。例如，销售数据存储在第四列里，可以用下面的代码获取这个数据：  \n\n    Double sales = getInputRowMeta().getNumber(rowData,3);\n通过索引获取数据是最快的方式。通过indexOfValue()方法可以获取列在一行里的索引。这个方法扫描列数组，速度并不快。所以，如果要处理所有数据行，我们建议只查询一次列索引。一般是在步骤接收到第一行数据时，就查询列索引，将查询到的列索引保存起来，供后面的数据行使用。  \n###  ###StepDatainterface\n实现了org.pentaho.di.trans.step.StepDataInterface接口的类用来维护步骤的执行状态，以及存储临时对象。例如，可以把输出行的元数据、数据库连接、输入输出流等存储到这个对象里。  \nHelloworldStepData.java  \n    package org.kettlesolutions.plugin.step.helloworld;\n\nimport org.pentaho.di.core.row.RowMetaInterface;\nimport org.pentaho.di.trans.step.BaseStepData;\nimport org.pentaho.di.trans.step.StepDataInterface;\n\npublic class HelloworldStepData extends BaseStepData implements StepDataInterface {\n\n\tpublic RowMetaInterface outputRowMeta;\n\n}\n    \n###  ###StepDialogInterface\n实现org.pentaho.di.trans.step.StepDialogInterfac接口的类用来提供一个用户界面，用户通过这个界面输入元数据（转换参数）。用户界面就是一个对话框。这个接口里包含了类似open()和setRepository()等的几个简单的方法。    \n####  ####Eclipse SWT\nKettle里使用Eclipse SWT作为界面开发包，所以你也要使用SWT来开发对话框窗口。SWT为不同的操作系统Windows、OS X、Linux和Unix提供了一个抽象层。所以SWT的图形界面和操作系统期货的程序的界面风格非常相近。  \n在开始进行SWT开发之前，建议先访问SWT主面以了解更多的内容http://www.eclipse/org/swt。在SWT的网站上，你可以了解到SWT能做出什么样的界面效果：  \nSWT控件页，http://www.eclipse.org/swt/widgets/，给出了你能使用的所有控件。  \nSWT样例页，http://www.eclipse.org/swt/snippets/，给出了许多代码例子。  \n最好的资源就是Kettle里150个内置步骤的对话框源代码。  \n\nHelloworldStepDialog.java  \n    package org.kettlesolutions.plugin.step.helloworld;\n    \n    import org.eclipse.swt.SWT;\n    import org.eclipse.swt.events.ModifyEvent;\n    import org.eclipse.swt.events.ModifyListener;\n    import org.eclipse.swt.events.SelectionAdapter;\n    import org.eclipse.swt.events.SelectionEvent;\n    import org.eclipse.swt.events.ShellAdapter;\n    import org.eclipse.swt.events.ShellEvent;\n    import org.eclipse.swt.layout.FormAttachment;\n    import org.eclipse.swt.layout.FormData;\n    import org.eclipse.swt.layout.FormLayout;\n    import org.eclipse.swt.widgets.Button;\n    import org.eclipse.swt.widgets.Control;\n    import org.eclipse.swt.widgets.Display;\n    import org.eclipse.swt.widgets.Event;\n    import org.eclipse.swt.widgets.Label;\n    import org.eclipse.swt.widgets.Listener;\n    import org.eclipse.swt.widgets.Shell;\n    import org.eclipse.swt.widgets.Text;\n    import org.pentaho.di.core.Const;\n    import org.pentaho.di.i18n.BaseMessages;\n    import org.pentaho.di.trans.TransMeta;\n    import org.pentaho.di.trans.step.BaseStepMeta;\n    import org.pentaho.di.trans.step.StepDialogInterface;\n    import org.pentaho.di.ui.core.widget.TextVar;\n    import org.pentaho.di.ui.trans.step.BaseStepDialog;\n    \n    public class HelloworldStepDialog extends BaseStepDialog implements\n    \t\tStepDialogInterface {\n    \n    \tprivate static Class<?> PKG = HelloworldStepMeta.class; // for i18n\n    \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// purposes, needed\n    \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// by Translator2!!\n    \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// $NON-NLS-1$\n    \n    \tprivate HelloworldStepMeta input;\n    \n    \tprivate TextVar wFieldname;\n    \n    \tpublic HelloworldStepDialog(Shell parent, Object baseStepMeta,\n    \t\t\tTransMeta transMeta, String stepname) {\n    \t\t//初始化元数据对象以及步骤对话框的父类\n    \t\tsuper(parent, (BaseStepMeta) baseStepMeta, transMeta, stepname);\n    \t\tinput = (HelloworldStepMeta) baseStepMeta;\n    \t}\n    \n    \tpublic String open() {\n    \t\tShell parent = getParent();\n    \t\tDisplay display = parent.getDisplay();\n    \n    \t\tshell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MIN\n    \t\t\t\t| SWT.MAX);\n    \t\tprops.setLook(shell);\n    \t\tsetShellImage(shell, input);\n    \n    \t\tModifyListener lsMod = new ModifyListener() {\n    \t\t\tpublic void modifyText(ModifyEvent e) {\n    \t\t\t\tinput.setChanged();\n    \t\t\t}\n    \t\t};\n    \t\tchanged = input.hasChanged();\n    \n    \t\tFormLayout formLayout = new FormLayout();\n    \t\tformLayout.marginWidth = Const.FORM_MARGIN;\n    \t\tformLayout.marginHeight = Const.FORM_MARGIN;\n    \n    \t\tshell.setLayout(formLayout);\n    \t\tshell.setText(BaseMessages.getString(PKG,\n    \t\t\t\t\"HelloworldDialog.Shell.Title\")); //$NON-NLS-1$\n    \t\t\n    \t\t//所有控件的右侧使用一个自定义的百分对对齐。控件之间的间距使用一个常量，常量值是4像素。\n    \t\tint middle = props.getMiddlePct();\n    \t\tint margin = Const.MARGIN;\n    \n    \t\t// Stepname line\n    \t\twlStepname = new Label(shell, SWT.RIGHT);\n    \t\twlStepname.setText(BaseMessages.getString(PKG,\n    \t\t\t\t\"HelloworldDialog.Stepname.Label\")); //$NON-NLS-1$\n    \t\tprops.setLook(wlStepname);\n    \t\tfdlStepname = new FormData();\n    \t\tfdlStepname.left = new FormAttachment(0, 0);\n    \t\tfdlStepname.right = new FormAttachment(middle, -margin);\n    \t\tfdlStepname.top = new FormAttachment(0, margin);\n    \t\twlStepname.setLayoutData(fdlStepname);\n    \t\twStepname = new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n    \t\twStepname.setText(stepname);\n    \t\tprops.setLook(wStepname);\n    \t\twStepname.addModifyListener(lsMod);\n    \t\tfdStepname = new FormData();\n    \t\tfdStepname.left = new FormAttachment(middle, 0);\n    \t\tfdStepname.top = new FormAttachment(0, margin);\n    \t\tfdStepname.right = new FormAttachment(100, 0);\n    \t\twStepname.setLayoutData(fdStepname);\n    \t\tControl lastControl = wStepname;\n    \n    \t\t// Fieldname line\n    \t\t//创建一个新的标签控件，控件里文本靠右对齐\n    \t\tLabel wlFieldname = new Label(shell, SWT.RIGHT);\n    \t\twlFieldname.setText(BaseMessages.getString(PKG,\n    \t\t\t\t\"HelloworldDialog.Fieldname.Label\")); //$NON-NLS-1$\n    \t\t//下面一行为控件设置用户定义的背景色和字体\n    \t\tprops.setLook(wlFieldname);\n    \t\tFormData fdlFieldname = new FormData();\n    \t\tfdlFieldname.left = new FormAttachment(0, 0);\n    \t\tfdlFieldname.right = new FormAttachment(middle, -margin);\n    \t\tfdlFieldname.top = new FormAttachment(lastControl, margin);\n    \t\twlFieldname.setLayoutData(fdlFieldname);\n    \t\twFieldname = new TextVar(transMeta, shell, SWT.SINGLE | SWT.LEFT\n    \t\t\t\t| SWT.BORDER);\n    \t\tprops.setLook(wFieldname);\n    \t\twFieldname.addModifyListener(lsMod);\n    \t\tFormData fdFieldname = new FormData();\n    \t\tfdFieldname.left = new FormAttachment(middle, 0);\n    \t\tfdFieldname.top = new FormAttachment(lastControl, margin);\n    \t\tfdFieldname.right = new FormAttachment(100, 0);\n    \t\twFieldname.setLayoutData(fdFieldname);\n    \t\tlastControl = wFieldname;\n    \n    \t\t// Some buttons\n    \t\twOK = new Button(shell, SWT.PUSH);\n    \t\twOK.setText(BaseMessages.getString(PKG, \"System.Button.OK\")); //$NON-NLS-1$\n    \t\twCancel = new Button(shell, SWT.PUSH);\n    \t\twCancel.setText(BaseMessages.getString(PKG, \"System.Button.Cancel\")); //$NON-NLS-1$\n    \n    \t\tsetButtonPositions(new Button[] { wOK, wCancel }, margin, lastControl);\n    \n    \t\t// Add listeners\n    \t\tlsCancel = new Listener() {\n    \t\t\tpublic void handleEvent(Event e) {\n    \t\t\t\tcancel();\n    \t\t\t}\n    \t\t};\n    \t\tlsOK = new Listener() {\n    \t\t\tpublic void handleEvent(Event e) {\n    \t\t\t\tok();\n    \t\t\t}\n    \t\t};\n    \n    \t\twCancel.addListener(SWT.Selection, lsCancel);\n    \t\twOK.addListener(SWT.Selection, lsOK);\n    \n    \t\tlsDef = new SelectionAdapter() {\n    \t\t\tpublic void widgetDefaultSelected(SelectionEvent e) {\n    \t\t\t\tok();\n    \t\t\t}\n    \t\t};\n    \n    \t\twStepname.addSelectionListener(lsDef);\n    \t\twFieldname.addSelectionListener(lsDef);\n    \n    \t\t// Detect X or ALT-F4 or something that kills this window...\n    \t\tshell.addShellListener(new ShellAdapter() {//保证了窗口在非正常关闭时，取消用户的编辑\n    \t\t\tpublic void shellClosed(ShellEvent e) {\n    \t\t\t\tcancel();\n    \t\t\t}\n    \t\t});\n    \n    \t\t// Populate the data of the controls\n    \t\t//下面的代码把数据从步骤的元数据对象里复制到窗口的控件里\n    \t\tgetData();\n    \n    \t\t// Set the shell size, based upon previous time...\n    \t\t//窗口的大小和位置将根据窗口的自然属性、上次窗口大小和位置，以及显示屏的大小自动设置\n    \t\tsetSize();\n    \n    \t\tinput.setChanged(changed);\n    \n    \t\tshell.open();\n    \t\twhile (!shell.isDisposed()) {\n    \t\t\tif (!display.readAndDispatch())\n    \t\t\t\tdisplay.sleep();\n    \t\t}\n    \t\treturn stepname;\n    \t}\n    \n    \t/**\n    \t * Copy information from the meta-data input to the dialog fields.\n    \t */\n    \tpublic void getData() {\n    \t\twStepname.selectAll();\n    \t\t//为了防止用户向控件里输入空值，Kettle提供了一个静态方法来检查宿舍，Const.NVL()\n    \t\twFieldname.setText(Const.NVL(input.getFieldName(), \"\"));\n    \t}\n    \n    \tprivate void cancel() {\n    \t\tstepname = null;\n    \t\tinput.setChanged(changed);\n    \t\tdispose();\n    \t}\n    \t//单击OK把控件里用户输入的数据都写入到步骤的元数据对象中。\n    \tprivate void ok() {\n    \t\tif (Const.isEmpty(wStepname.getText()))\n    \t\t\treturn;\n    \n    \t\tstepname = wStepname.getText(); // return value\n    \n    \t\tinput.setFieldName(wFieldname.getText());\n    \n    \t\tdispose();\n    \t}\n    }\n    \n\n####  ####窗体布局\n如果你看过步骤对话框的源代码，你就会发现窗体类里有很多烦琐的代码。这些代码确保Kettle可以在各种操作系统下以合适的方式展现窗体。可以发现窗体里的大部分代码都和布局以及控件位置有关。  \nFormLayout是SWT里经常看到的布局方式。程序员可以通过FormLayout指定控件的百分比、偏移。下面是我们例子里的窗口布局的代码（HelloworldStepDialog.java）  \n    //创建一个新的标签控件，控件里文本靠右对齐\n    Label label = new Label(shell, SWT.RIGHT);\n    label.setText(BaseMessages.getString(PKG,\"HelloworldDialog.Fieldname.Label\")); //$NON-NLS-1$\n    //下面一行为控件设置用户定义的背景色和字体\n    props.setLook(label);\n    /**\n    * 下面几行将标签的左侧和对话框的最左侧对齐，把标签的右侧放在对话框中间（50%）的左侧10个像素\n    * 的位置。标签的顶部放在距离对话框顶部25个像素的位置。\n    */\n    FormData fdLabel = new FormData();\n    fdlFieldname.left = new FormAttachment(0, 0);\n    fdlFieldname.right = new FormAttachment(50, -10);\n    fdlFieldname.top = new FormAttachment(0, 25);\n    wlFieldname.setLayoutData(fdLabel);  \n简而言之，不要感到痛苦；图形用户界面的代码都比较烦琐，但代码并不复杂。  \n####  ####Kettle UI元素  \n除了标准的SWT组件，还可以使用Kettle自带的一些控件，Kettle开发人员的工作可以更简单一些。Kettle自带的组件包括以下一些。  \nTableView：这是一个数据表格组件，支持排序、选择、键盘快捷键和撤销/重做，以及右键菜单。  \nTextVar：这是一个支持变量的文本输入框，这个输入框的右上角有一个$符号。用户可以通过”Ctrl  +Alt+空格”的方式，在弹出的下拉列表中选择变量。其他功能和普通的文本框相同。  \nComboVar：标准的组合下拉列表，支持变量。  \nConditionEditor：过滤行步骤里使用的输入条件控件。  \n另外还有很多常用的对话框帮你完成相应的工作，如下所示:  \nEnterListDialog:从字符串列表里选择一个或多个字符串。左侧显示字符串列表，右侧是选中的字符串，并提供把字符串从左侧移动到右侧的按钮。  \nEnterNumberDialog:用户可以输入数字  \nEnterPasswordDialog:让用户输入密码  \nEnterSelectionDialog:通过高亮显示，从列表里选择多项  \nEnterMappingDialog:输入两组字符串的映射  \nPreviewRowsDialog:在对话框里预览一组数据行。  \nSQLEditor:一个简单的SQL编辑器，可以输入查询和DDL.  \nErrorDialog:显示异常信息，列出详细的错误栈对话框  \n####  ####Hello World例子对话框\n现在我们已经基本了解了SWT以及对话框的布局方式，再看看我们的例子，下面的代码是HelloWorldStepDialog.java里的例子。\n代码的第一部分是初始化元数据对象以及步骤对话框的父类：\n    public class HelloworldStepDialog extends BaseStepDialog implements\n    \t\tStepDialogInterface {\n    \tprivate static Class<?> PKG = HelloworldStepMeta.class; \n    \tprivate HelloworldStepMeta input;\n    \tprivate TextVar wFieldname;\n    \tpublic HelloworldStepDialog(Shell parent, Object baseStepMeta,\n    \t\t\tTransMeta transMeta, String stepname) {\n    \t\t//初始化元数据对象以及步骤对话框的父类\n    \t\tsuper(parent, (BaseStepMeta) baseStepMeta, transMeta, stepname);\n    \t\tinput = (HelloworldStepMeta) baseStepMeta;\n    \t}\n在下面的open()方法里创建对话框里的所有控件。SWT使用事件监听模式，可以为控件创建各种监听方法，以响应控件内容的变化和用户的动作。\n    public String open() {\n    \t\tShell parent = getParent();\n    \t\tDisplay display = parent.getDisplay();\n    \t\tshell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MIN\n    \t\t\t\t| SWT.MAX);\n    \t\tprops.setLook(shell);\n    \t\tsetShellImage(shell, input);\n    \t\tModifyListener lsMod = new ModifyListener() {\n    \t\t\tpublic void modifyText(ModifyEvent e) {\n    \t\t\t\tinput.setChanged();\n    \t\t\t}\n    \t\t};\n    \t\tchanged = input.hasChanged();\n    \n下面代码说明窗体里的控件将使用formLayout的布局方式：\n    FormLayout formLayout = new FormLayout();\n    \t\tformLayout.marginWidth = Const.FORM_MARGIN;\n    \t\tformLayout.marginHeight = Const.FORM_MARGIN;\n    \t\tshell.setLayout(formLayout);\n所有控件的右侧使用一个自定义的百分比对齐：props.getMiddlePct()；控件之间的间距使用一个常量，常量值是4像素。\n    shell.setLayout(formLayout);\n    \t\tshell.setText(BaseMessages.getString(PKG,\n    \t\t\t\t\"HelloworldDialog.Shell.Title\")); //$NON-NLS-1$\n    \t\tint middle = props.getMiddlePct();\n    \t\tint margin = Const.MARGIN;\n下面的代码在对话框的最上面添加了一行步骤名称标签和输入文本框：\n    // Stepname line\n    \t\twlStepname = new Label(shell, SWT.RIGHT);\n    \t\twlStepname.setText(BaseMessages.getString(PKG,\n    \t\t\t\t\"HelloworldDialog.Stepname.Label\")); //$NON-NLS-1$\n    \t\tprops.setLook(wlStepname);\n    \t\tfdlStepname = new FormData();\n    \t\tfdlStepname.left = new FormAttachment(0, 0);\n    \t\tfdlStepname.right = new FormAttachment(middle, -margin);\n    \t\tfdlStepname.top = new FormAttachment(0, margin);\n    \t\twlStepname.setLayoutData(fdlStepname);\n    \t\twStepname = new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n    \t\twStepname.setText(stepname);\n    \t\tprops.setLook(wStepname);\n    \t\twStepname.addModifyListener(lsMod);\n    \t\tfdStepname = new FormData();\n    \t\tfdStepname.left = new FormAttachment(middle, 0);\n    \t\tfdStepname.top = new FormAttachment(0, margin);\n    \t\tfdStepname.right = new FormAttachment(100, 0);\n    \t\twStepname.setLayoutData(fdStepname);\n    \t\tControl lastControl = wStepname;\n\n下面是新增输出列的列名设置的输入框：\n    // Fieldname line\n\t\t//创建一个新的标签控件，控件里文本靠右对齐\n\t\tLabel wlFieldname = new Label(shell, SWT.RIGHT);\n\t\twlFieldname.setText(BaseMessages.getString(PKG,\n\t\t\t\t\"HelloworldDialog.Fieldname.Label\")); //$NON-NLS-1$\n\t\t//下面一行为控件设置用户定义的背景色和字体\n\t\tprops.setLook(wlFieldname);\n\t\tFormData fdlFieldname = new FormData();\n\t\tfdlFieldname.left = new FormAttachment(0, 0);\n\t\tfdlFieldname.right = new FormAttachment(middle, -margin);\n\t\tfdlFieldname.top = new FormAttachment(lastControl, margin);\n\t\twlFieldname.setLayoutData(fdlFieldname);\n\t\twFieldname = new TextVar(transMeta, shell, SWT.SINGLE | SWT.LEFT\n\t\t\t\t| SWT.BORDER);\n\t\tprops.setLook(wFieldname);\n\t\twFieldname.addModifyListener(lsMod);\n\t\tFormData fdFieldname = new FormData();\n\t\tfdFieldname.left = new FormAttachment(middle, 0);\n\t\tfdFieldname.top = new FormAttachment(lastControl, margin);\n\t\tfdFieldname.right = new FormAttachment(100, 0);\n\t\twFieldname.setLayoutData(fdFieldname);\n\t\tlastControl = wFieldname;\n    \n然后创建两个按钮，“确认”和“取消”按钮，以及按钮单击事件的监听方法，把按钮放在对话框的最下面：\n    // Some buttons\n\t\twOK = new Button(shell, SWT.PUSH);\n\t\twOK.setText(BaseMessages.getString(PKG, \"System.Button.OK\")); //$NON-NLS-1$\n\t\twCancel = new Button(shell, SWT.PUSH);\n\t\twCancel.setText(BaseMessages.getString(PKG, \"System.Button.Cancel\")); //$NON-NLS-1$\n\n\t\tsetButtonPositions(new Button[] { wOK, wCancel }, margin, lastControl);\n\n\t\t// Add listeners\n\t\tlsCancel = new Listener() {\n\t\t\tpublic void handleEvent(Event e) {\n\t\t\t\tcancel();\n\t\t\t}\n\t\t};\n\t\tlsOK = new Listener() {\n\t\t\tpublic void handleEvent(Event e) {\n\t\t\t\tok();\n\t\t\t}\n\t\t};\n\t\twCancel.addListener(SWT.Selection, lsCancel);\n\t\twOK.addListener(SWT.Selection, lsOK);\n    \n下面的代码做了两件事情，上部代码可以保证当步骤名称或输出字段名称的输入框在编辑状态时，单击“确定”按钮，正在编辑的内容不会丢失；下部的代码保证了窗口在非正常关闭时（没有使用“确定”或“取消”按钮关闭），取消用户的编辑。\n    lsDef = new SelectionAdapter() {\n\t\t\tpublic void widgetDefaultSelected(SelectionEvent e) {\n\t\t\t\tok();\n\t\t\t}\n\t\t};\n\n\t\twStepname.addSelectionListener(lsDef);\n\t\twFieldname.addSelectionListener(lsDef);\n\n\t\t// Detect X or ALT-F4 or something that kills this window...\n\t\tshell.addShellListener(new ShellAdapter() {//保证了窗口在非正常关闭时，取消用户的编辑\n\t\t\tpublic void shellClosed(ShellEvent e) {\n\t\t\t\tcancel();\n\t\t\t}\n\t\t});\n\n\n下面的代码把数据从步骤的元数据对象里复制到窗口的控件里：\n    // Populate the data of the controls\n    \t\tgetData();\n窗口的大小和位置将根据窗口的自然属性、上次窗口大小和位置，以及显示屏的大小自动设置。\n    // Set the shell size, based upon previous time...\n    \t\t//窗口的大小和位置将根据窗口的自然属性、上次窗口大小和位置，以及显示屏的大小自动设置\n    \t\tsetSize();\n    \t\tinput.setChanged(changed);\n    \n    \t\tshell.open();\n    \t\twhile (!shell.isDisposed()) {\n    \t\t\tif (!display.readAndDispatch())\n    \t\t\t\tdisplay.sleep();\n    \t\t}\n    \t\treturn stepname;\n    \t}\n为了防止用户身控件里输入空值，Kettle提供了一个静态方法来检查空值，ConstNVL();\n    /**\n    \t * Copy information from the meta-data input to the dialog fields.\n    \t */\n    \tpublic void getData() {\n    \t\twStepname.selectAll();\n    \t\twFieldname.setText(Const.NVL(input.getFieldName(), \"\"));\n    \t}\n最后，单击OK按钮后，把控件里用户输入的数据都写入到步骤的元数据对象中：\n    private void cancel() {\n    \t\tstepname = null;\n    \t\tinput.setChanged(changed);\n    \t\tdispose();\n    \t}\n    \t//单击OK把控件里用户输入的数据都写入到步骤的元数据对象中。\n    \tprivate void ok() {\n    \t\tif (Const.isEmpty(wStepname.getText()))\n    \t\t\treturn;\n    \n    \t\tstepname = wStepname.getText(); // return value\n    \n    \t\tinput.setFieldName(wFieldname.getText());\n    \n    \t\tdispose();\n    \t}\n\n###  ###StepInteface\n\t这个类实现了org.pentaho.di.trans.step.StepInterface接口，这个类读取上个步骤传来的数据行，利用StepMetaInterface对象里定义的元数据，逐行转换和处理上个步骤传来的数据行，Kettle引擎直接使用这个接口里的很多方法来执行转换过程，但大部分方法都已经由BaseStep类实现了，通常开发人员只需要重载其中的几个方法。\n\tInit():步骤初始化方法，用来初始化一个步骤。初始化结果是一个true或者false的Boolean值。如果你的步骤没有任何初始化的工作，可以不用重载这个方法。\n\tDispose():如果有需要释放的资源，可以在dispose()方法里释放，例如可以关闭数据库连接、释放文件、清除缓存等。在转换的最后Kettle引擎会调用这个方法。如果没有需要释放或清除的资源，可以不用重载这个方法。\n\tprocessRow():这个方法，是步骤实现工作的地方。只要这个方法返回true，转换引擎就会重复调用这个方法。\n下面是HellWorld例子实现的StepInterface接口（HelloworldStep.java）\n\nHelloworldStep.java\n    package org.kettlesolutions.plugin.step.helloworld;\n    \n    import org.pentaho.di.core.exception.KettleException;\n    import org.pentaho.di.core.row.RowDataUtil;\n    import org.pentaho.di.trans.Trans;\n    import org.pentaho.di.trans.TransMeta;\n    import org.pentaho.di.trans.step.BaseStep;\n    import org.pentaho.di.trans.step.StepDataInterface;\n    import org.pentaho.di.trans.step.StepInterface;\n    import org.pentaho.di.trans.step.StepMeta;\n    import org.pentaho.di.trans.step.StepMetaInterface;\n    /**\n     * BaseStep抽象类已经实现了接口里的很多方法，我们只要覆盖需要修改的方法即可。\n     * @author Administrator\n     *\n     */\n    public class HelloworldStep extends BaseStep implements StepInterface {\n    \t/**\n    \t * 类的构造函数通常直接把参数传递给BaseStep父类。由父类里的方法来构造对象，然后可以直接\n    \t * 使用类似transMeta这样的对象。\n    \t * @param stepMeta\n    \t * @param stepDataInterface\n    \t * @param copyNr\n    \t * @param transMeta\n    \t * @param trans\n    \t */\n    \tpublic HelloworldStep(StepMeta stepMeta, StepDataInterface stepDataInterface,\n    \t\t\tint copyNr, TransMeta transMeta, Trans trans) {\n    \t\tsuper(stepMeta, stepDataInterface, copyNr, transMeta, trans);\n    \t\t// TODO Auto-generated constructor stub\n    \t}\n    \n    \t\n    \tpublic boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException {\n    \n    \t\tHelloworldStepMeta meta  = (HelloworldStepMeta) smi;\n    \t\tHelloworldStepData data = (HelloworldStepData) sdi;\n    \t\t/**\n    \t\t * getRow()方法从上一个步骤获取一行数据。如果没有更多要获取的数据行，这个方法就会返回null。\n    \t\t * 如果前面的步骤不能及时提供数据，这个方法就会阻塞，直到有可用的数据行。这样这个步骤的速度就会降低，也会影响\n    \t\t * 其它步骤的速度。\n    \t\t */\n    \t\tObject[] row = getRow();\n    \t\tif (row==null) {\n    \t\t\t/**\n    \t\t\t * setOutputDone()方法用来通知其它的步骤，本步骤已经没有输出数据行。下一个步骤如果\n    \t\t\t * 再调用getRow()方法就会返回null,转换也不再调用processRow()方法。\n    \t\t\t */\n    \t\t\tsetOutputDone();\n    \t\t\treturn false;\n    \t\t}\n    \t\t\n    \t\tif (first) {\n    \t\t\tfirst=false;\n    \t\t\t/**\n    \t\t\t * 从性能上考虑，getRow()方法不提供数据行的元数据，只提供上个步骤输出的数据。可以使用getInputRowMeta()方法\n    \t\t\t获取元数据，元数据只获取一次即可，所以在first代码块里获取元数据。\n    \t\t\t   如果要把数据传到下一个步骤，要使用putRow()方法。除了输出数据，还要输出RowMetaInterface元数据。\n    \t\t\t   第一行使用clone()方法把输入行的元数据结构复制给输出行。输出行的元数据结构是在输入行的基础上增加一个字段，但\n    \t\t\t   构造输出行的元数据结构只能构造一次，因为所有输出数据行的结构都是一样的，产生了输出行以后，元数据结构就不能再变化。\n    \t\t\t   所以输出行的元数据结构在first代码块里构造。first是一个内部成员，first代码块里的代码只在处理第一行数据时执行。\n    \t\t\t   下面代码的最后一行，给输出数据增加了一个字段。\n    \t\t\t */\n    \t\t\tdata.outputRowMeta = getInputRowMeta().clone();\n    \t\t\tmeta.getFields(data.outputRowMeta, getStepname(), null, null, this);\n    \t\t}\n    \t\t/**\n    \t\t * 下面的代码，把数据写入输出流。从性能角度考虑，数据行实现就是Java数组。为了开发方便，可以使用RowDataUtil类提供\n    \t\t * 的一些静态方法来操作数据。使用RowDatautil静态方法复制数据，还可以提高性能。\n    \t\t */\n    \t\tString value = \"Hello, world!\";\n    \t\t\n    \t\tObject[] outputRow = RowDataUtil.addValueData(row, getInputRowMeta().size(), value);\n    \t\t\n    \t\tputRow(data.outputRowMeta, outputRow);\n    \t\t\n    \t\treturn true;\n    \t}\n    }\n解析：\npublic class HelloworldStep extends BaseStep implements StepInterface {\nBaseStep抽象类已经实现了接口里的很多方法，我们只要覆盖需要修改的方法即可。\n类的构造函数通常直接把参数传递给BaseStep父类。由父类里的方法来构造对象，然后可以直接使用类似transMeta这样的对象。\npublic HelloworldStep(StepMeta stepMeta, StepDataInterface stepDataInterface,\n\t\t\tint copyNr, TransMeta transMeta, Trans trans) {\n\t\tsuper(stepMeta, stepDataInterface, copyNr, transMeta, trans);\n\t}\ngetRow()方法从上一个步骤获取一行数据。如果没有更多要获取的数据行，这个方法就会返回null。如果前面的步骤不能及时提供数据，这个方法就会阻塞，直到有可用的数据行。这样这个步骤的速度就会降低，也会影响其它步骤的速度。\npublic boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException {\n\t\tHelloworldStepMeta meta  = (HelloworldStepMeta) smi;\n\t\tHelloworldStepData data = (HelloworldStepData) sdi;\n\t\tObject[] row = getRow();\n\t\tif (row==null) {\n\t\t\tsetOutputDone();\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (first) {\n\t\t\tfirst=false;\n\t\t\tdata.outputRowMeta = getInputRowMeta().clone();\n\t\t\tmeta.getFields(data.outputRowMeta, getStepname(), null, null, this);\n\t\t}\n\t\tString value = \"Hello, world!\";\n\t\tObject[] outputRow = RowDataUtil.addValueData(row, getInputRowMeta().size(), value);\n\t\t\n\t\tputRow(data.outputRowMeta, outputRow);\n\t\t\n\t\treturn true;\n\t}\n从性能上考虑，getRow()方法不提供数据行的元数据，只提供上个步骤输出的数据。可以使用getInputRowMeta()方法获取元数据，元数据只获取一次即可，所以在first代码块里获取元数据。\nsetOutputDone()方法用来通知其它的步骤，本步骤已经没有输出数据行。下一个步骤如果再调用getRow()方法就会返回null,转换也不再调用processRow()方法。\n\n    Object[] row = getRow();\n    \t\tif (row==null) {\n    \t\t\tsetOutputDone();\n    \t\t\treturn false;\n    \t\t}\n   如果要把数据传到下一个步骤，要使用putRow()方法。除了输出数据，还要输出RowMetaInterface元数据。\n    data.outputRowMeta = getInputRowMeta().clone();\n    meta.getFields(data.outputRowMeta, getStepname(), null, null, this);\n第一行使用clone()方法把输入行的元数据结构复制给输出行。输出行的元数据结构是在输入行的基础上增加一个字段，但构造输出行的元数据结构只能构造一次，因为所有输出数据行的结构都是一样的，产生了输出行以后，元数据结构就不能再变化。所以输出行的元数据结构在first代码块里构造。first是一个内部成员，first代码块里的代码只在处理第一行数据时执行。下面代码的最后一行，给输出数据增加了一个字段。\n\n下面的代码，把数据写入输出流。\n\t\tString value = \"Hello, world!\";\n\t\tObject[] outputRow = RowDataUtil.addValueData(row, getInputRowMeta().size(), value);\n\t\tputRow(data.outputRowMeta, outputRow);\n从性能角度考虑，数据行实现就是Java数组。为了开发方便，可以使用RowDataUtil类提供的一些静态方法来操作数据。使用RowDatautil静态方法复制数据，还可以提高性能。\n从指定的步骤读取数据行\n如果你想从前面的某个指定的步骤读取数据行，例如”流查询“步骤，可以使用getRowFrom()方法。\n\t   RowSet rowSet = findInputRowSet(Source Step Name);\n\t   Object[] rowData = getRowFrom(rowSet);\n\t       还可以通过rowSet对象获得数据行的元数据：\n\t   RowMetaInterface rowMeta = rowSet.getRowMeta();\n把数据行写入指定的步骤\n如果想把数据写入到某个特定的步骤，例如”过滤“步骤，可以使用putRowTo()方法\n\t  RowSet rowSet = findOutputRowSet(Target Step Name);\n\t  ....\n\t  putRowTo(outputRowMeta,rowData,rowSet);\n很明显，输入和输出的RowSet对象只需获得一次即可，这样才更有效率。\n把数据行写入到错误处理步骤\n如果想让你的步骤支持错误处理，而且元数据类返回的supportErrorHandling()方法返回了true，就可以把数据输出\n\t  到错误处理步骤里。下面是使用putError()方法的例子：\n\t  Object[] rowData = getRow();\n\t  ...\n\t  try{\n\t  \t...\n\t  \tputRow(...);\n\t  }catch(Exception e){\n\t  \tif(getStepMeta().isDoingErrorHandling()){\n\t  \t\tputError(getInputRowMeta(),rowData,errorCode);\n\t  \t}else{\n\t  \t\tthrow(e);\n\t  \t}\n\t  }\n\t  从例子里可以看到，这段代码把错误的行数、错误字段名、消息、错误编码都传递给错误处理步骤。\n\t  错误处理的其他工作都自动完成了。\n#### ####识别一个步骤拷贝\n因为一个步骤可以有多份拷贝同时执行，有时需要识别出正在使用的是哪个步骤拷贝，可以用下面几个方法。\n\t getCopy():获得拷贝号。拷贝号可以唯一标识出步骤的一个拷贝，拷贝号的聚会范围是0-N，N=getStepMeta().getCopies()-1\n\t getUniqueStepNrAcrossSlaves():获得在集群模式下运行的步骤拷贝号。\n\t getUniqueStepCountAcrossSlaves():获得在集群模式下运行的步骤拷贝总数。\n\t 通过这些方法可以把一个步骤的工作分配给多份拷贝去完成。例如”CSV文件输入“和”固定文件输入“步骤里都有并行读取文件的选项，这样可以把读取文件的工作放在多个拷贝里或集群里来完成。\n#### ####结果反馈\n在调用getRow()和putRow()方法时，引擎会自动计算两类度量值，读行数和写行数。这两类度量值可以在界面或日志中记录下来，以监控程序运行的状态。下面几个方法用来操作这两类度量值。\n\tincrementLinesRead():增加从前面步骤读取到的行数。\n\tincrementLinesWritten():增加定稿到后面步骤中的行数。\n\tincrementLinesInput():增加从文件、数据库、网络等资源读取到的行数\n\tincrementLinesOutput:增加写入到文件、数据库、网络等资源的行数。\n\tincrementLinesUpdate():增加更新的行数。\n\tincrementLinesSkipped()：增加跳过的数据行的行数。\n\tincrementLinesRejected():增加拒绝的数据行的行数。\n\t这些度量值用来说明步骤执行的情况。可以在Spoon的转换度量面板里看到，也可以存到日志数据库表里。\n\t使用addResultFile()方法，可以把步骤用到的文件保留下来，保存到结果文件列表里。结果文件列表可以被其它转换或作业项使用。例如，下面的”CSV文件输入“的代码：\nResultFile resultFile = new ResultFile(\n\tResultFile.FILE_TYPE_GENERAL,\n\tfileObject,\ngetTransMeta().getName(),\ngetStepName()\n);\nresultFile.setComment(“File was read by a Csv Input step”);\naddREsultFile(resultFile);\n#### ####变量替换\n\t如果输入框需要支持变量，可以使用environmentSubstritute()方法获取变量。例如，若想在“Hello World”例子的字段名输入框里使用变量，就要把StepMetaInterface里的getFields()方法修改成下面的语句：\nString realFiledName = apace. environmentSubstritute(fieldName)；\n因为步骤本身是一个VariableSpace对象，所以也可以使用下面的语句做变量替换：String value = environmentSubstritute(meta.getSringWithVariables());\n#### ####Apache VFS\nKettle里所有操作文件的步骤，都使用Apache VFS系统的方式操作。Apache VFS不但可以从文件系统读取文件（如java.io.File），还可以从很多其他来源读取文件，如FTP服务器、Z学压缩文件，等 等 。  \nApache VFS里的FileObject对象提供了文件的抽象层，然后在Kettle的KettleVFS类里还提供了一系列的静态方法，来更方便使用FileObject对象，例如下面的代码 ：  \n\n    FileObject fileObject = KettleVFS.getFileObject(“zip:http://www.example.com/archive.zip!file.txt”);\n`String value = environmentSubstritute(meta.getSringWithVariables());`\n\n\n应该尽可能多地使用KettleVFS,因为它解决了或饶过了很多Apache VFS目前已知的问题。它也增强了SFTP协议。\n#### ####步骤插件部署\n部署之前，要把四个Java源代码文件编译为class文件。把编译好的class文件放到一个Jar包里。可以使用IDE来做这些事情，也可以手工使用ant脚本来做这些事情。  \n.jar文件应该放在Kettle的plugins/steps目录下。也可以使用一个子目录，把所有的依赖的jar包放在插件jar包所在目录的/lib目录下，不必再放Kettle的类路径中（Kettle的libext/目录）已经有了的jar包。另外可以把多个插件放在一个jar包里。\n如果想在IDE里调试插件，可以把插件元数据类的名字放在Kettle_PLUGIN_CLASSES变量里（一个逗号分隔的列表）。关于这个主题的更多信息，请参考pentaho Wiki:http://wiki.pentaho.com/display/EAI/How+to+debug+a+Kettle+4+plugin 。\n\n","source":"_posts/kettle/Kettle插件架构.md","raw":"---\ntitle: Kettle插件架构\ndate: 2017-04-15 19:42:49\ntags: [开源项目,kettle]\ncategories: [开源项目,kettle]\n---\n#  #Kettle插件体系\n最近公司内有业务系统到数据中心同步的升级改造需求，从各个业务系统收集增量数据到数据中心的数据仓库平台。因为开发周期短暂，需要快速的响应，开发出可用的产品，所以决定借鉴开源程序Kettle，开发一个文件解析组件，然后利用Kettle平台的大数据组件进行与数据中心大数据平台对接\n\n数据同步部分是：业务系统（RDBMS）->Kettle(azkaban进行调度)->数据中心，因为Kettle的增量抽取组件经常出现数据不一致等问题，所以目前已更改为：业务系统（RDBMS）->OGG（CDC增量抽取）->数据中心的方式。\n\n本文主要介绍如何扩展Kettle的功能，部分内容来自《Pentaho Kettle解决方案：使用PDI构建开源ETL解决方案》一书，推荐购买阅读。\n##  ##架构\n我们先看Kettle插件架构。\n ![](http://i.imgur.com/mLvXMuV.jpg)\n从功能上看，Kettle内部的对象和外部插件没有任何区别。因为它们使用的API都是一样的，它们只是在运行时的加载方式不同。\n从Kettle4以后，Kettle内部有一个插件注册系统，它负责加载各种内部和外部插件。插件有以下两个标识属性。\n**插件类型**：由PluginTypeInterface接口定义。例如StepPluginType、JobEntryPluginType、PartitionerPluginType和RepositoryPluginType。\n**插件ID**：这是一个字符串数组，用来唯一标识一个插件。因为旧的插件可以被新的插件代替，一个插件可以有多个ID。在大多数情况下，插件只使用一个单一的字符串，如TableInput是“表输入”步骤的ID，MYSQL是MySQL数据库类型的ID。\n当Kettle环境初始化以后，插件注册系统首先加载所有的内部对象，Kettle读取下面的配置文件来加载内部对象，这些配置文件位于Kettle的.jar文件中。\n\t Kettle-steps.xml：内部转换步骤。\n\t Kettle-job-entries.xml：内部作业项。\n\t Kettle-partition-plugins.xml：内部分区类型。\n\t Kettle-database-types.xml：内部数据库类型。\n\t Kettle-repositories.xml：内部资源库类型。\n\n插件注册系统加载了所有的内部对象后，就要搜索可用的外部插件。通过浏览plugins/目录的各个子目录下的.jar文件来完成。它搜索特定的Kettle annotations来判断一个类是否是插件。加载过程将在本章的后面介绍。\n因为在内部对象加载后才加载插件，所以插件会替代相同ID的已加载的内部对象。例如，你创建了插件，插件的ID是TableInput，就可以替换Kettle标准的“表输入”步骤。这个功能可以让你用插件替换Kettle内置的步骤。可以通过子类继承方式，直接扩展已有步骤的某些功能。\n\n##  ##插件类型\nKettle有下面几种插件类型（下面的插件是Kettle4.0的插件类型，新版kettle包含了很多新的插件，比如视图插件、大数据插件等等）。\n\n- 转换步骤插件：在Kettle转换中使用的步骤，用来处理数据行。\n\n\n- 作业项插件：在Kettle作业中使用的作业项，用来实现某个任务。\n\t\n\n- 分区方法插件：利用输入字段的值指定自己的分区规则。\n\t\n\n- 数据库类型插件：用来扩展不同的数据库类型。\n\t\n\n- 资源库类型插件：可以把Kettle元数据保存为自定义类型或格式。\n\n说明：除了这些类型，还有Spoon类型的插件，可以把功能扩展到Spoon，本书不介绍这个功能。\n##  ##转换步骤插件\n转换步骤插件包括了四个Java类，这四个类分别实现四个接口。\n\n\n- StepMetaInterface：这个接口对外 提供步骤的元数据并处理串行化。\n\n\n- StepInterface:这个接口根据上面接口提供的元数据，来实现步骤的具体功能。\n\n\n- StepDataInterface:这个接口用来存储步骤的临时数据、文件句柄等。\n\n\n- StepDialogInterface:这个接口是Spoon里的图形界面，用来编辑步骤的元数据。\n\n接下来，我们介绍这些接口的基本内容。对于每个接口，在一个简单的“Hello World”例子里提供这些类的相应实现。“Hello World”例子将在数据流里增加一个字段，字段名用户可以自定义，字段值是”Hello world!“。最后介绍一下如何部署这个例子。\n###  ###StepMetaInterface\n接口org.pentaho.di.trans.step.StepMetaInterface负责步骤里所有和元数据相关的任务。和元数据相关的工作包括：  \n元数据和XML(或资源库)之间的序列化和反序列化  \ngetXML（）和loadXML()  \nsaveRep()和readRep()  \n\n描述输出字段  \ngetFields()  \n\n检验元数据是否正确  \nCheck()  \n\n获取步骤相应的要SQL语句，使步骤可以正确运行  \ngetSQLStatements()  \n\n给元数据设置默认值  \nsetDefault()  \n\n完成对数据库的影响分析  \nanalyseImpact()  \n\n描述各类输入和输出流  \ngetStepIOMeta()  \nsearchInfoAndTargetSteps()  \nhandleStreamSelection()  \ngetOptionalStreams()  \nresetStepIoMeta()  \n\n导出元数据资源  \nexportResources()  \ngetResourceDependencies()  \n\n描述使用的库  \ngetUsedLibraries()  \n\n描述使用的数据库连接  \ngetUsedDatabaseConnections()  \n\n描述这个步骤需要的字段（通常是一个数据库表）  \ngetRequiredFields()  \n\n描述步骤是否具有某些功能  \nsupportsErrorHandling()  \nexcludeFromRowLayoutVerification()  \nexcludeFromCopyDistributeVerification()  \n\n这个接口里还定义了几个方法来说明这四个接口如何结合到一起。  \nString getDialogClassName():用来描述实现了StepDialogInterface接口的对话框类的名字。如果这个方法返回了null，调用类会根据实现了StepMetaInterface接口的类的类名和包名来自动生成对话框类的名字。  \nSetpInterface getStep():创建一个实现了StepInterface接口的类。  \nStepDataInterface getStepData():创建一个实现了StepDataInterface接口的类。  \n现在我们看看”Hello World”例子里对SetpMetaInterface接口的实现  \nHelloworldStepMeta.java\n    package org.kettlesolutions.plugin.step.helloworld;\n    \n    import java.util.List;\n    import java.util.Map;\n    \n    import org.pentaho.di.core.CheckResult;\n    import org.pentaho.di.core.CheckResultInterface;\n    import org.pentaho.di.core.Const;\n    import org.pentaho.di.core.Counter;\n    import org.pentaho.di.core.annotations.Step;\n    import org.pentaho.di.core.database.DatabaseMeta;\n    import org.pentaho.di.core.exception.KettleException;\n    import org.pentaho.di.core.exception.KettleStepException;\n    import org.pentaho.di.core.exception.KettleXMLException;\n    import org.pentaho.di.core.row.RowMetaInterface;\n    import org.pentaho.di.core.row.ValueMeta;\n    import org.pentaho.di.core.row.ValueMetaInterface;\n    import org.pentaho.di.core.variables.VariableSpace;\n    import org.pentaho.di.core.xml.XMLHandler;\n    import org.pentaho.di.i18n.BaseMessages;\n    import org.pentaho.di.repository.ObjectId;\n    import org.pentaho.di.repository.Repository;\n    import org.pentaho.di.trans.Trans;\n    import org.pentaho.di.trans.TransMeta;\n    import org.pentaho.di.trans.step.BaseStepMeta;\n    import org.pentaho.di.trans.step.StepDataInterface;\n    import org.pentaho.di.trans.step.StepInterface;\n    import org.pentaho.di.trans.step.StepMeta;\n    import org.pentaho.di.trans.step.StepMetaInterface;\n    import org.w3c.dom.Node;\n    \n    @Step(\n    \t\tid=\"Helloworld\",\n    \t\tname=\"name\",\n    \t\tdescription=\"description\",\n    \t\tcategoryDescription=\"categoryDescription\", \n    \t\timage=\"org/kettlesolutions/plugin/step/helloworld/HelloWorld.png\",\n    \t\ti18nPackageName=\"org.kettlesolutions.plugin.step.helloworld\"\n    ) \n    public class HelloworldStepMeta extends BaseStepMeta implements StepMetaInterface {\n    \t/**\n    \t * PKG变量说明了messages包的位置，在messages包里有各种国际化的资源文件。\n    \t * 在本章后面经常要看到的BaseMessages.getString()方法，就是根据软件的国际化\n    \t * 设置，从不同的文件中获取文字。PKG变量通常位于类的最上方，被国际化图形工具使用，\n    \t * 通过国际化图形工具，国际化人员可以编辑不同的国际化资源文件。所以我们会在很多Kettle\n    \t * 代码里看见这样的结构。\n    \t */\n    \tprivate static Class<?> PKG = HelloworldStep.class; //for i18n\n    \tpublic enum Tag {//field_name用于保存用户输入的字段名：保存“Hello，world！\"字符串的字段名。\n    \t\tfield_name,\n    \t};\n    \t\n    \tprivate String fieldName;\n    \t\n    \t/**\n    \t * @return the fieldName\n    \t */\n    \tpublic String getFieldName() {\n    \t\treturn fieldName;\n    \t}\n    \n    \t/**\n    \t * @param fieldName the fieldName to set\n    \t */\n    \tpublic void setFieldName(String fieldName) {\n    \t\tthis.fieldName = fieldName;\n    \t}\n    \n    \t/**\n    \t * checks parameters, adds result to List<CheckResultInterface>\n    \t * used in Action > Verify transformation\n    \t * 验证用户是否在对话框里输入了字段名，并把验证结果添加到检验转换时出现的问题列表里。（最好\n    \t * 要检验用户输入的所有选项，而不只是容易出错的选项）\n    \t */\n    \tpublic void check(List<CheckResultInterface> remarks, TransMeta transMeta, StepMeta stepMeta, \n    \t\t\tRowMetaInterface prev, String input[], String output[], RowMetaInterface info) {\n    \t\t\n    \t\tif (Const.isEmpty(fieldName)) {\n    \t\t\tCheckResultInterface error = new CheckResult(\n    \t\t\t\tCheckResult.TYPE_RESULT_ERROR, \n    \t\t\t\tBaseMessages.getString(PKG, \"HelloworldMeta.CHECK_ERR_NO_FIELD\"), \n    \t\t\t\tstepMeta\n    \t\t\t);\n    \t\t\tremarks.add(error);\n    \t\t} else {\n    \t\t\tCheckResultInterface ok = new CheckResult(\n    \t\t\t\tCheckResult.TYPE_RESULT_OK, \n    \t\t\t\tBaseMessages.getString(PKG, \"HelloworldMeta.CHECK_OK_FIELD\"), \n    \t\t\t\tstepMeta\n    \t\t\t);\n    \t\t\tremarks.add(ok);//把验证结果添加到检验转换时出现的问题列表里。\n    \t\t}\n    \t}\n    \n    \t/**\n    \t *\tcreates a new instance of the step (factory)\n    \t * getStep、getStepData和getDialogClassName()方法提供了与这个步骤里其它三个接口之间的桥梁\n    \t 这个接口里还定义了几个方法来说明这四个接口如何结合到一起。\n    \tString getDialogClassName():用来描述实现了StepDialogInterace接口的对话框类的名字。如果这个方法返回\n    \t\t\t\t了null，调用类会根据实现了StepMetaInterface接口的类的类名和包名来自动生成对话框类的名字。\n    \tStepInterface getStep():创建一个实现了StepInterface接口的类。\n    \tStepInterface getStepData():创建一个实现了StepDataInterface接口的类。\n    \n    \t */\n    \tpublic StepInterface getStep(StepMeta stepMeta, StepDataInterface stepDataInterface,\n    \t\t\tint copyNr, TransMeta transMeta, Trans trans) {\n    \t\treturn new HelloworldStep(stepMeta, stepDataInterface, copyNr, transMeta, trans);\n    \t}\n    \n    \t/**\n    \t * creates new instance of the step data (factory)\n    \t * getStep、getStepData和getDialogClassName()方法提供了与这个步骤里其它三个接口之间的桥梁\n    \t */\n    \tpublic StepDataInterface getStepData() {\n    \t\treturn new HelloworldStepData();\n    \t}\n    \t/**\n    \t * getStep、getStepData和getDialogClassName()方法提供了与这个步骤里其它三个接口之间的桥梁\n    \t */\n    \t@Override\n    \tpublic String getDialogClassName() {\n    \t\treturn HelloworldStepDialog.class.getName();\n    \t}\n    \n    \t/**\n    \t * deserialize from xml \n    \t * databases = list of available connections\n    \t * counters = list of sequence steps\n    \t * \n    \t * 下面的四个方法loadXML()、getXML()、readRep()和saveRep()把元数据保存到XML文件或资源库里，\n    \t * 或者从XML文件或资源库读取元数据。保存到文件的方法利用了像XStream（http://xstream.codehaus.org）这\n    \t * 样的XML串行化技术。\n    \t */\n    \tpublic void loadXML(Node stepDomNode, List<DatabaseMeta> databases,\n    \t\t\tMap<String, Counter> sequenceCounters) throws KettleXMLException {\n    \t\tfieldName = XMLHandler.getTagValue(stepDomNode, Tag.field_name.name());\n    \t}\n    \t\n    \t/**\n    \t * @Override\n    \t */\n    \tpublic String getXML() throws KettleException {\n    \t\tStringBuilder xml = new StringBuilder();\n    \t\txml.append(XMLHandler.addTagValue(Tag.field_name.name(), fieldName));\n    \t\treturn xml.toString();\n    \t}\n    \t\n    \t/**\n    \t * De-serialize from repository (see loadXML)\n    \t */\n    \tpublic void readRep(Repository repository, ObjectId stepIdInRepository,\n    \t\t\tList<DatabaseMeta> databases, Map<String, Counter> sequenceCounters)\n    \t\t\tthrows KettleException {\n    \t\tfieldName = repository.getStepAttributeString(stepIdInRepository, Tag.field_name.name());\n    \t}\n    \n    \t/**\n    \t * serialize to repository\n    \t */\n    \tpublic void saveRep(Repository repository, ObjectId idOfTransformation, ObjectId idOfStep)\n    \t\t\tthrows KettleException {\n    \t\trepository.saveStepAttribute(idOfTransformation, idOfStep, Tag.field_name.name(), fieldName);\n    \t}\n    \t\n    \t\n    \t/**\n    \t * initiailize parameters to default\n    \t */\n    \tpublic void setDefault() {\n    \t\tfieldName = \"helloField\";\n    \t}\n    \n    \t/**\n    \t * getFields()方法非常重要，因为它描述了输出数据行的结构。这个方法需要修改inputRowMeta对象，使这个对象和\n    \t * 输出格式匹配。Spoon和后面的步骤都需要知道这个步骤要输出哪些字段。最常见的一种方法，可以给输出的RowMetaInterface对象\n    \t * 添加一个ValueMetaInterface对象。在ValueMetaInterface对象里设置的信息越详细越好，可以设置的信息包括数据类型、长度、\n    \t * 精度、格式掩码，等等。添加的字段描述元信息越多，后面生成的SQL就越准确。\n    \t */\n    \t@Override\n    \tpublic void getFields(RowMetaInterface inputRowMeta, String name,\n    \t\t\tRowMetaInterface[] info, StepMeta nextStep, VariableSpace space)\n    \t\t\tthrows KettleStepException {\n    \t\tString realFieldName = space.environmentSubstitute(fieldName);\n    \t\t//值的元数据使用ValueMetaInterface接口描述数据流里的一个字段。这个接口里定义了字段的名字、数据类型、长度、精度，等等。下面的例子用于创建一个ValueMetaInterface对象。\n    \t\tValueMetaInterface field = new ValueMeta(realFieldName, ValueMetaInterface.TYPE_STRING);\n    \t\tfield.setOrigin(name);\t\t\n    \t\tinputRowMeta.addValueMeta(field);\n    \t}\n    }\n\n\n\n代码解析\n    @Step(\n    \t\tid=\"Helloworld\",\n    \t\tname=\"name\",\n    \t\tdescription=\"description\",\n    \t\tcategoryDescription=\"categoryDescription\", \n    \t\timage=\"org/kettlesolutions/plugin/step/helloworld/HelloWorld.png\",\n    \t\ti18nPackageName=\"org.kettlesolutions.plugin.step.helloworld\"\n    )\n这段代码里的@Step annotation用来通知Kettle的插件注册系统：这个类是一个步骤类型的插件。在annotation里可以指定插件的ID、图标、国际代的包、本地化的名称、类别、描述。其中后三项是资源文件里的Key，需要在资源文件里设置真正的值。i18nPackageName指定了资源文件的包名，例如我们这个例子的资源文件位于org/kettlesolutions/plugin/step/helloworld/messages目录下，en_US（英语，美国）的本地代资源文件是messages_en_US.properties。我们例子里的这个资源文件的内容是：\nname=Hello world\ndescription=A very simple step that adds a new \"Helllo world\" field to the incoming stream\n注意，如果你指定了不存在的分类，Spoon会创建这个分类，并在Spoon的分类树的最上方显示这个分类。\n最后，annotation里的image标签指定了插件的图标。需要32*32像素的PNG文件，可以使用透明样式。\n后面的代码行说明这个类实现了StepMetaInterface接口。在BaseStepMeta抽象类里定义了这个接口的很多默认实现，可以直接继承这个抽象类，然后把工作集中在插件特有的功能上。\n\n    public class HelloworldStepMeta extends BaseStepMeta implements StepMetaInterface\n\t\n\n\n下面的四个方法loadXML()、getXML()、readRep()和saveRep()把元数据保存到XML文件或资源库里，或者从XML文件或资源库读取元数据。保存到文件的方法利用了像XStream（http://xstream.codehaus.org）这样的XML串行化技术。\n\n\ngetFields()方法非常重要，因为它描述了输出数据行的结构。这个方法需要修改inputRowMeta对象，使这个对象和输出格式匹配。Spoon和后面的步骤都需要知道这个步骤要输出哪些字段。最常见的一种方法，可以给输出的RowMetaInterface对象添加一个ValueMetaInterface对象。在ValueMetaInterface对象里设置的信息越详细越好，可以设置的信息包括数据类型、长度、精度、格式掩码，等等。添加的字段描述元信息越多，后面生成的SQL就越准确。\n####  ####值的元数据（Value Metadata）\n值的元数据使用ValueMetaInterface接口描述数据流里的一个字段。这个接口里定义了字段的名字、数据类型、长度、精度，等等。下面的例子用于创建一个ValueMetaInterface对象。  \n    ValueMetaInterface dateMeta = new ValueMeta(“birthdate”,ValueMetaInterface.TYPE_DATE);\n这个接口也负责转换数据格式。我们建议使用ValueMetaInterface接口来完成所有数据转换的工作。例如，日期类型的数据，如果想把它转换为dateMeta对象里定义的字符串格式，可以用下面的代码：  \n    //java.util.Date birthdate\n    String birthDateString = dateMeta.getString(birthdate);\nValueMeta类负责转换。因为有ValueMetaInterface进行数据类型的转换，所以你不用再去做额外的数据类型转换的工作。  \n使用ValueMetaInterface接口时还要注意数据对象是否为Null。从上一个步骤可以接收到一个数据对象和一个描述数据对象的ValueMetaInterface对象。我们要检查这个数据对象是否为null，在某些情况下如果数据对象为空是不正确的。例如：  \n数据对象是String类型，有10个空格，Value Metadata需要trim这个字符串。  \n在Value Metadata里已经定义了从文本文件里加载的数据，要延迟转换为字符串。所以数据要由二进制的格式（原始数据格式），转换为字符串格式，然后再转换为其它格式的数据。  \n一般使用下面的方法检查数据对象是否为空：  \n    Boolean n = valueMeta.isNull(valueDate);\n重要：要保证传给ValueMetaInterface对象的数据是在元数据里定义的数据类型。表23-1说明了  ValueMetaInterface里定义的数据类型和Java数据类型的对应关系。  \nKettle元数据类型和Java里数据类型的对应关系  \n<table>\n    <tr>\n        <th>Value Meta Type</th>\n        <th>Java Class</th>\n    </tr>\n    <tr>\n        <td>ValueMetaInterface.TYPE_STRING</td>\n        <td>Java.lang.String</td>\n    </tr>\n    <tr>\n        <td>ValueMetaInterface.TYPE_DATE</td>\n        <td>Java.util.Date</td>\n    </tr>\n    <tr>\n        <td>ValueMetaInterface.TYPE_BOOLEAN</td>\n        <td>Java.lang.Boolean</td>\n    </tr>\n\t<tr>\n        <td>ValueMetaInterface.TYPE_NUMBER</td>\n        <td>Java.lang.Double</td>\n    </tr>\n\t<tr>\n        <td>ValueMetaInterface.TYPE_INTEGER</td>\n        <td>Java.lang.Long</td>\n    </tr>\n\t<tr>\n        <td>ValueMetaInterface.TYPE_BIGNUMBER</td>\n        <td>Java.math.BigDecimal</td>\n    </tr>\n\t<tr>\n        <td>ValueMetaInterface.TYPE_BINARY</td>\n        <td>Byte[]</td>\n    </tr>\n</table>\n\n\n####  ####行的元数据（Row Meatadata）\n行的元数据使用RowMetaInterface接口来描述数据行的元数据，而不是一个列的元数据。实际上，RowMetaInterface的类里包含了一组ValueMetaInterface。另外还包括了一些方法来操作行元数据，倒如查询值、检查值是否存、替换值的元数据等。  \n行的元数据里唯一的规则就是一行里的列的名字必须唯一。当你添加了一个新列时，如果新列的名字和已有列的名字相同，列名后面会自动加上“_2”后缀。如果再加一个同名的列会自动加上”_3“后缀，等等。  \n因为在步骤里通常是和数据行打交道，所以从数据行里直接取数据会更方便。可以使用很多类似于getNumber()、getString()这样的方法直接从数据行取数据。例如，销售数据存储在第四列里，可以用下面的代码获取这个数据：  \n\n    Double sales = getInputRowMeta().getNumber(rowData,3);\n通过索引获取数据是最快的方式。通过indexOfValue()方法可以获取列在一行里的索引。这个方法扫描列数组，速度并不快。所以，如果要处理所有数据行，我们建议只查询一次列索引。一般是在步骤接收到第一行数据时，就查询列索引，将查询到的列索引保存起来，供后面的数据行使用。  \n###  ###StepDatainterface\n实现了org.pentaho.di.trans.step.StepDataInterface接口的类用来维护步骤的执行状态，以及存储临时对象。例如，可以把输出行的元数据、数据库连接、输入输出流等存储到这个对象里。  \nHelloworldStepData.java  \n    package org.kettlesolutions.plugin.step.helloworld;\n\nimport org.pentaho.di.core.row.RowMetaInterface;\nimport org.pentaho.di.trans.step.BaseStepData;\nimport org.pentaho.di.trans.step.StepDataInterface;\n\npublic class HelloworldStepData extends BaseStepData implements StepDataInterface {\n\n\tpublic RowMetaInterface outputRowMeta;\n\n}\n    \n###  ###StepDialogInterface\n实现org.pentaho.di.trans.step.StepDialogInterfac接口的类用来提供一个用户界面，用户通过这个界面输入元数据（转换参数）。用户界面就是一个对话框。这个接口里包含了类似open()和setRepository()等的几个简单的方法。    \n####  ####Eclipse SWT\nKettle里使用Eclipse SWT作为界面开发包，所以你也要使用SWT来开发对话框窗口。SWT为不同的操作系统Windows、OS X、Linux和Unix提供了一个抽象层。所以SWT的图形界面和操作系统期货的程序的界面风格非常相近。  \n在开始进行SWT开发之前，建议先访问SWT主面以了解更多的内容http://www.eclipse/org/swt。在SWT的网站上，你可以了解到SWT能做出什么样的界面效果：  \nSWT控件页，http://www.eclipse.org/swt/widgets/，给出了你能使用的所有控件。  \nSWT样例页，http://www.eclipse.org/swt/snippets/，给出了许多代码例子。  \n最好的资源就是Kettle里150个内置步骤的对话框源代码。  \n\nHelloworldStepDialog.java  \n    package org.kettlesolutions.plugin.step.helloworld;\n    \n    import org.eclipse.swt.SWT;\n    import org.eclipse.swt.events.ModifyEvent;\n    import org.eclipse.swt.events.ModifyListener;\n    import org.eclipse.swt.events.SelectionAdapter;\n    import org.eclipse.swt.events.SelectionEvent;\n    import org.eclipse.swt.events.ShellAdapter;\n    import org.eclipse.swt.events.ShellEvent;\n    import org.eclipse.swt.layout.FormAttachment;\n    import org.eclipse.swt.layout.FormData;\n    import org.eclipse.swt.layout.FormLayout;\n    import org.eclipse.swt.widgets.Button;\n    import org.eclipse.swt.widgets.Control;\n    import org.eclipse.swt.widgets.Display;\n    import org.eclipse.swt.widgets.Event;\n    import org.eclipse.swt.widgets.Label;\n    import org.eclipse.swt.widgets.Listener;\n    import org.eclipse.swt.widgets.Shell;\n    import org.eclipse.swt.widgets.Text;\n    import org.pentaho.di.core.Const;\n    import org.pentaho.di.i18n.BaseMessages;\n    import org.pentaho.di.trans.TransMeta;\n    import org.pentaho.di.trans.step.BaseStepMeta;\n    import org.pentaho.di.trans.step.StepDialogInterface;\n    import org.pentaho.di.ui.core.widget.TextVar;\n    import org.pentaho.di.ui.trans.step.BaseStepDialog;\n    \n    public class HelloworldStepDialog extends BaseStepDialog implements\n    \t\tStepDialogInterface {\n    \n    \tprivate static Class<?> PKG = HelloworldStepMeta.class; // for i18n\n    \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// purposes, needed\n    \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// by Translator2!!\n    \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// $NON-NLS-1$\n    \n    \tprivate HelloworldStepMeta input;\n    \n    \tprivate TextVar wFieldname;\n    \n    \tpublic HelloworldStepDialog(Shell parent, Object baseStepMeta,\n    \t\t\tTransMeta transMeta, String stepname) {\n    \t\t//初始化元数据对象以及步骤对话框的父类\n    \t\tsuper(parent, (BaseStepMeta) baseStepMeta, transMeta, stepname);\n    \t\tinput = (HelloworldStepMeta) baseStepMeta;\n    \t}\n    \n    \tpublic String open() {\n    \t\tShell parent = getParent();\n    \t\tDisplay display = parent.getDisplay();\n    \n    \t\tshell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MIN\n    \t\t\t\t| SWT.MAX);\n    \t\tprops.setLook(shell);\n    \t\tsetShellImage(shell, input);\n    \n    \t\tModifyListener lsMod = new ModifyListener() {\n    \t\t\tpublic void modifyText(ModifyEvent e) {\n    \t\t\t\tinput.setChanged();\n    \t\t\t}\n    \t\t};\n    \t\tchanged = input.hasChanged();\n    \n    \t\tFormLayout formLayout = new FormLayout();\n    \t\tformLayout.marginWidth = Const.FORM_MARGIN;\n    \t\tformLayout.marginHeight = Const.FORM_MARGIN;\n    \n    \t\tshell.setLayout(formLayout);\n    \t\tshell.setText(BaseMessages.getString(PKG,\n    \t\t\t\t\"HelloworldDialog.Shell.Title\")); //$NON-NLS-1$\n    \t\t\n    \t\t//所有控件的右侧使用一个自定义的百分对对齐。控件之间的间距使用一个常量，常量值是4像素。\n    \t\tint middle = props.getMiddlePct();\n    \t\tint margin = Const.MARGIN;\n    \n    \t\t// Stepname line\n    \t\twlStepname = new Label(shell, SWT.RIGHT);\n    \t\twlStepname.setText(BaseMessages.getString(PKG,\n    \t\t\t\t\"HelloworldDialog.Stepname.Label\")); //$NON-NLS-1$\n    \t\tprops.setLook(wlStepname);\n    \t\tfdlStepname = new FormData();\n    \t\tfdlStepname.left = new FormAttachment(0, 0);\n    \t\tfdlStepname.right = new FormAttachment(middle, -margin);\n    \t\tfdlStepname.top = new FormAttachment(0, margin);\n    \t\twlStepname.setLayoutData(fdlStepname);\n    \t\twStepname = new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n    \t\twStepname.setText(stepname);\n    \t\tprops.setLook(wStepname);\n    \t\twStepname.addModifyListener(lsMod);\n    \t\tfdStepname = new FormData();\n    \t\tfdStepname.left = new FormAttachment(middle, 0);\n    \t\tfdStepname.top = new FormAttachment(0, margin);\n    \t\tfdStepname.right = new FormAttachment(100, 0);\n    \t\twStepname.setLayoutData(fdStepname);\n    \t\tControl lastControl = wStepname;\n    \n    \t\t// Fieldname line\n    \t\t//创建一个新的标签控件，控件里文本靠右对齐\n    \t\tLabel wlFieldname = new Label(shell, SWT.RIGHT);\n    \t\twlFieldname.setText(BaseMessages.getString(PKG,\n    \t\t\t\t\"HelloworldDialog.Fieldname.Label\")); //$NON-NLS-1$\n    \t\t//下面一行为控件设置用户定义的背景色和字体\n    \t\tprops.setLook(wlFieldname);\n    \t\tFormData fdlFieldname = new FormData();\n    \t\tfdlFieldname.left = new FormAttachment(0, 0);\n    \t\tfdlFieldname.right = new FormAttachment(middle, -margin);\n    \t\tfdlFieldname.top = new FormAttachment(lastControl, margin);\n    \t\twlFieldname.setLayoutData(fdlFieldname);\n    \t\twFieldname = new TextVar(transMeta, shell, SWT.SINGLE | SWT.LEFT\n    \t\t\t\t| SWT.BORDER);\n    \t\tprops.setLook(wFieldname);\n    \t\twFieldname.addModifyListener(lsMod);\n    \t\tFormData fdFieldname = new FormData();\n    \t\tfdFieldname.left = new FormAttachment(middle, 0);\n    \t\tfdFieldname.top = new FormAttachment(lastControl, margin);\n    \t\tfdFieldname.right = new FormAttachment(100, 0);\n    \t\twFieldname.setLayoutData(fdFieldname);\n    \t\tlastControl = wFieldname;\n    \n    \t\t// Some buttons\n    \t\twOK = new Button(shell, SWT.PUSH);\n    \t\twOK.setText(BaseMessages.getString(PKG, \"System.Button.OK\")); //$NON-NLS-1$\n    \t\twCancel = new Button(shell, SWT.PUSH);\n    \t\twCancel.setText(BaseMessages.getString(PKG, \"System.Button.Cancel\")); //$NON-NLS-1$\n    \n    \t\tsetButtonPositions(new Button[] { wOK, wCancel }, margin, lastControl);\n    \n    \t\t// Add listeners\n    \t\tlsCancel = new Listener() {\n    \t\t\tpublic void handleEvent(Event e) {\n    \t\t\t\tcancel();\n    \t\t\t}\n    \t\t};\n    \t\tlsOK = new Listener() {\n    \t\t\tpublic void handleEvent(Event e) {\n    \t\t\t\tok();\n    \t\t\t}\n    \t\t};\n    \n    \t\twCancel.addListener(SWT.Selection, lsCancel);\n    \t\twOK.addListener(SWT.Selection, lsOK);\n    \n    \t\tlsDef = new SelectionAdapter() {\n    \t\t\tpublic void widgetDefaultSelected(SelectionEvent e) {\n    \t\t\t\tok();\n    \t\t\t}\n    \t\t};\n    \n    \t\twStepname.addSelectionListener(lsDef);\n    \t\twFieldname.addSelectionListener(lsDef);\n    \n    \t\t// Detect X or ALT-F4 or something that kills this window...\n    \t\tshell.addShellListener(new ShellAdapter() {//保证了窗口在非正常关闭时，取消用户的编辑\n    \t\t\tpublic void shellClosed(ShellEvent e) {\n    \t\t\t\tcancel();\n    \t\t\t}\n    \t\t});\n    \n    \t\t// Populate the data of the controls\n    \t\t//下面的代码把数据从步骤的元数据对象里复制到窗口的控件里\n    \t\tgetData();\n    \n    \t\t// Set the shell size, based upon previous time...\n    \t\t//窗口的大小和位置将根据窗口的自然属性、上次窗口大小和位置，以及显示屏的大小自动设置\n    \t\tsetSize();\n    \n    \t\tinput.setChanged(changed);\n    \n    \t\tshell.open();\n    \t\twhile (!shell.isDisposed()) {\n    \t\t\tif (!display.readAndDispatch())\n    \t\t\t\tdisplay.sleep();\n    \t\t}\n    \t\treturn stepname;\n    \t}\n    \n    \t/**\n    \t * Copy information from the meta-data input to the dialog fields.\n    \t */\n    \tpublic void getData() {\n    \t\twStepname.selectAll();\n    \t\t//为了防止用户向控件里输入空值，Kettle提供了一个静态方法来检查宿舍，Const.NVL()\n    \t\twFieldname.setText(Const.NVL(input.getFieldName(), \"\"));\n    \t}\n    \n    \tprivate void cancel() {\n    \t\tstepname = null;\n    \t\tinput.setChanged(changed);\n    \t\tdispose();\n    \t}\n    \t//单击OK把控件里用户输入的数据都写入到步骤的元数据对象中。\n    \tprivate void ok() {\n    \t\tif (Const.isEmpty(wStepname.getText()))\n    \t\t\treturn;\n    \n    \t\tstepname = wStepname.getText(); // return value\n    \n    \t\tinput.setFieldName(wFieldname.getText());\n    \n    \t\tdispose();\n    \t}\n    }\n    \n\n####  ####窗体布局\n如果你看过步骤对话框的源代码，你就会发现窗体类里有很多烦琐的代码。这些代码确保Kettle可以在各种操作系统下以合适的方式展现窗体。可以发现窗体里的大部分代码都和布局以及控件位置有关。  \nFormLayout是SWT里经常看到的布局方式。程序员可以通过FormLayout指定控件的百分比、偏移。下面是我们例子里的窗口布局的代码（HelloworldStepDialog.java）  \n    //创建一个新的标签控件，控件里文本靠右对齐\n    Label label = new Label(shell, SWT.RIGHT);\n    label.setText(BaseMessages.getString(PKG,\"HelloworldDialog.Fieldname.Label\")); //$NON-NLS-1$\n    //下面一行为控件设置用户定义的背景色和字体\n    props.setLook(label);\n    /**\n    * 下面几行将标签的左侧和对话框的最左侧对齐，把标签的右侧放在对话框中间（50%）的左侧10个像素\n    * 的位置。标签的顶部放在距离对话框顶部25个像素的位置。\n    */\n    FormData fdLabel = new FormData();\n    fdlFieldname.left = new FormAttachment(0, 0);\n    fdlFieldname.right = new FormAttachment(50, -10);\n    fdlFieldname.top = new FormAttachment(0, 25);\n    wlFieldname.setLayoutData(fdLabel);  \n简而言之，不要感到痛苦；图形用户界面的代码都比较烦琐，但代码并不复杂。  \n####  ####Kettle UI元素  \n除了标准的SWT组件，还可以使用Kettle自带的一些控件，Kettle开发人员的工作可以更简单一些。Kettle自带的组件包括以下一些。  \nTableView：这是一个数据表格组件，支持排序、选择、键盘快捷键和撤销/重做，以及右键菜单。  \nTextVar：这是一个支持变量的文本输入框，这个输入框的右上角有一个$符号。用户可以通过”Ctrl  +Alt+空格”的方式，在弹出的下拉列表中选择变量。其他功能和普通的文本框相同。  \nComboVar：标准的组合下拉列表，支持变量。  \nConditionEditor：过滤行步骤里使用的输入条件控件。  \n另外还有很多常用的对话框帮你完成相应的工作，如下所示:  \nEnterListDialog:从字符串列表里选择一个或多个字符串。左侧显示字符串列表，右侧是选中的字符串，并提供把字符串从左侧移动到右侧的按钮。  \nEnterNumberDialog:用户可以输入数字  \nEnterPasswordDialog:让用户输入密码  \nEnterSelectionDialog:通过高亮显示，从列表里选择多项  \nEnterMappingDialog:输入两组字符串的映射  \nPreviewRowsDialog:在对话框里预览一组数据行。  \nSQLEditor:一个简单的SQL编辑器，可以输入查询和DDL.  \nErrorDialog:显示异常信息，列出详细的错误栈对话框  \n####  ####Hello World例子对话框\n现在我们已经基本了解了SWT以及对话框的布局方式，再看看我们的例子，下面的代码是HelloWorldStepDialog.java里的例子。\n代码的第一部分是初始化元数据对象以及步骤对话框的父类：\n    public class HelloworldStepDialog extends BaseStepDialog implements\n    \t\tStepDialogInterface {\n    \tprivate static Class<?> PKG = HelloworldStepMeta.class; \n    \tprivate HelloworldStepMeta input;\n    \tprivate TextVar wFieldname;\n    \tpublic HelloworldStepDialog(Shell parent, Object baseStepMeta,\n    \t\t\tTransMeta transMeta, String stepname) {\n    \t\t//初始化元数据对象以及步骤对话框的父类\n    \t\tsuper(parent, (BaseStepMeta) baseStepMeta, transMeta, stepname);\n    \t\tinput = (HelloworldStepMeta) baseStepMeta;\n    \t}\n在下面的open()方法里创建对话框里的所有控件。SWT使用事件监听模式，可以为控件创建各种监听方法，以响应控件内容的变化和用户的动作。\n    public String open() {\n    \t\tShell parent = getParent();\n    \t\tDisplay display = parent.getDisplay();\n    \t\tshell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MIN\n    \t\t\t\t| SWT.MAX);\n    \t\tprops.setLook(shell);\n    \t\tsetShellImage(shell, input);\n    \t\tModifyListener lsMod = new ModifyListener() {\n    \t\t\tpublic void modifyText(ModifyEvent e) {\n    \t\t\t\tinput.setChanged();\n    \t\t\t}\n    \t\t};\n    \t\tchanged = input.hasChanged();\n    \n下面代码说明窗体里的控件将使用formLayout的布局方式：\n    FormLayout formLayout = new FormLayout();\n    \t\tformLayout.marginWidth = Const.FORM_MARGIN;\n    \t\tformLayout.marginHeight = Const.FORM_MARGIN;\n    \t\tshell.setLayout(formLayout);\n所有控件的右侧使用一个自定义的百分比对齐：props.getMiddlePct()；控件之间的间距使用一个常量，常量值是4像素。\n    shell.setLayout(formLayout);\n    \t\tshell.setText(BaseMessages.getString(PKG,\n    \t\t\t\t\"HelloworldDialog.Shell.Title\")); //$NON-NLS-1$\n    \t\tint middle = props.getMiddlePct();\n    \t\tint margin = Const.MARGIN;\n下面的代码在对话框的最上面添加了一行步骤名称标签和输入文本框：\n    // Stepname line\n    \t\twlStepname = new Label(shell, SWT.RIGHT);\n    \t\twlStepname.setText(BaseMessages.getString(PKG,\n    \t\t\t\t\"HelloworldDialog.Stepname.Label\")); //$NON-NLS-1$\n    \t\tprops.setLook(wlStepname);\n    \t\tfdlStepname = new FormData();\n    \t\tfdlStepname.left = new FormAttachment(0, 0);\n    \t\tfdlStepname.right = new FormAttachment(middle, -margin);\n    \t\tfdlStepname.top = new FormAttachment(0, margin);\n    \t\twlStepname.setLayoutData(fdlStepname);\n    \t\twStepname = new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n    \t\twStepname.setText(stepname);\n    \t\tprops.setLook(wStepname);\n    \t\twStepname.addModifyListener(lsMod);\n    \t\tfdStepname = new FormData();\n    \t\tfdStepname.left = new FormAttachment(middle, 0);\n    \t\tfdStepname.top = new FormAttachment(0, margin);\n    \t\tfdStepname.right = new FormAttachment(100, 0);\n    \t\twStepname.setLayoutData(fdStepname);\n    \t\tControl lastControl = wStepname;\n\n下面是新增输出列的列名设置的输入框：\n    // Fieldname line\n\t\t//创建一个新的标签控件，控件里文本靠右对齐\n\t\tLabel wlFieldname = new Label(shell, SWT.RIGHT);\n\t\twlFieldname.setText(BaseMessages.getString(PKG,\n\t\t\t\t\"HelloworldDialog.Fieldname.Label\")); //$NON-NLS-1$\n\t\t//下面一行为控件设置用户定义的背景色和字体\n\t\tprops.setLook(wlFieldname);\n\t\tFormData fdlFieldname = new FormData();\n\t\tfdlFieldname.left = new FormAttachment(0, 0);\n\t\tfdlFieldname.right = new FormAttachment(middle, -margin);\n\t\tfdlFieldname.top = new FormAttachment(lastControl, margin);\n\t\twlFieldname.setLayoutData(fdlFieldname);\n\t\twFieldname = new TextVar(transMeta, shell, SWT.SINGLE | SWT.LEFT\n\t\t\t\t| SWT.BORDER);\n\t\tprops.setLook(wFieldname);\n\t\twFieldname.addModifyListener(lsMod);\n\t\tFormData fdFieldname = new FormData();\n\t\tfdFieldname.left = new FormAttachment(middle, 0);\n\t\tfdFieldname.top = new FormAttachment(lastControl, margin);\n\t\tfdFieldname.right = new FormAttachment(100, 0);\n\t\twFieldname.setLayoutData(fdFieldname);\n\t\tlastControl = wFieldname;\n    \n然后创建两个按钮，“确认”和“取消”按钮，以及按钮单击事件的监听方法，把按钮放在对话框的最下面：\n    // Some buttons\n\t\twOK = new Button(shell, SWT.PUSH);\n\t\twOK.setText(BaseMessages.getString(PKG, \"System.Button.OK\")); //$NON-NLS-1$\n\t\twCancel = new Button(shell, SWT.PUSH);\n\t\twCancel.setText(BaseMessages.getString(PKG, \"System.Button.Cancel\")); //$NON-NLS-1$\n\n\t\tsetButtonPositions(new Button[] { wOK, wCancel }, margin, lastControl);\n\n\t\t// Add listeners\n\t\tlsCancel = new Listener() {\n\t\t\tpublic void handleEvent(Event e) {\n\t\t\t\tcancel();\n\t\t\t}\n\t\t};\n\t\tlsOK = new Listener() {\n\t\t\tpublic void handleEvent(Event e) {\n\t\t\t\tok();\n\t\t\t}\n\t\t};\n\t\twCancel.addListener(SWT.Selection, lsCancel);\n\t\twOK.addListener(SWT.Selection, lsOK);\n    \n下面的代码做了两件事情，上部代码可以保证当步骤名称或输出字段名称的输入框在编辑状态时，单击“确定”按钮，正在编辑的内容不会丢失；下部的代码保证了窗口在非正常关闭时（没有使用“确定”或“取消”按钮关闭），取消用户的编辑。\n    lsDef = new SelectionAdapter() {\n\t\t\tpublic void widgetDefaultSelected(SelectionEvent e) {\n\t\t\t\tok();\n\t\t\t}\n\t\t};\n\n\t\twStepname.addSelectionListener(lsDef);\n\t\twFieldname.addSelectionListener(lsDef);\n\n\t\t// Detect X or ALT-F4 or something that kills this window...\n\t\tshell.addShellListener(new ShellAdapter() {//保证了窗口在非正常关闭时，取消用户的编辑\n\t\t\tpublic void shellClosed(ShellEvent e) {\n\t\t\t\tcancel();\n\t\t\t}\n\t\t});\n\n\n下面的代码把数据从步骤的元数据对象里复制到窗口的控件里：\n    // Populate the data of the controls\n    \t\tgetData();\n窗口的大小和位置将根据窗口的自然属性、上次窗口大小和位置，以及显示屏的大小自动设置。\n    // Set the shell size, based upon previous time...\n    \t\t//窗口的大小和位置将根据窗口的自然属性、上次窗口大小和位置，以及显示屏的大小自动设置\n    \t\tsetSize();\n    \t\tinput.setChanged(changed);\n    \n    \t\tshell.open();\n    \t\twhile (!shell.isDisposed()) {\n    \t\t\tif (!display.readAndDispatch())\n    \t\t\t\tdisplay.sleep();\n    \t\t}\n    \t\treturn stepname;\n    \t}\n为了防止用户身控件里输入空值，Kettle提供了一个静态方法来检查空值，ConstNVL();\n    /**\n    \t * Copy information from the meta-data input to the dialog fields.\n    \t */\n    \tpublic void getData() {\n    \t\twStepname.selectAll();\n    \t\twFieldname.setText(Const.NVL(input.getFieldName(), \"\"));\n    \t}\n最后，单击OK按钮后，把控件里用户输入的数据都写入到步骤的元数据对象中：\n    private void cancel() {\n    \t\tstepname = null;\n    \t\tinput.setChanged(changed);\n    \t\tdispose();\n    \t}\n    \t//单击OK把控件里用户输入的数据都写入到步骤的元数据对象中。\n    \tprivate void ok() {\n    \t\tif (Const.isEmpty(wStepname.getText()))\n    \t\t\treturn;\n    \n    \t\tstepname = wStepname.getText(); // return value\n    \n    \t\tinput.setFieldName(wFieldname.getText());\n    \n    \t\tdispose();\n    \t}\n\n###  ###StepInteface\n\t这个类实现了org.pentaho.di.trans.step.StepInterface接口，这个类读取上个步骤传来的数据行，利用StepMetaInterface对象里定义的元数据，逐行转换和处理上个步骤传来的数据行，Kettle引擎直接使用这个接口里的很多方法来执行转换过程，但大部分方法都已经由BaseStep类实现了，通常开发人员只需要重载其中的几个方法。\n\tInit():步骤初始化方法，用来初始化一个步骤。初始化结果是一个true或者false的Boolean值。如果你的步骤没有任何初始化的工作，可以不用重载这个方法。\n\tDispose():如果有需要释放的资源，可以在dispose()方法里释放，例如可以关闭数据库连接、释放文件、清除缓存等。在转换的最后Kettle引擎会调用这个方法。如果没有需要释放或清除的资源，可以不用重载这个方法。\n\tprocessRow():这个方法，是步骤实现工作的地方。只要这个方法返回true，转换引擎就会重复调用这个方法。\n下面是HellWorld例子实现的StepInterface接口（HelloworldStep.java）\n\nHelloworldStep.java\n    package org.kettlesolutions.plugin.step.helloworld;\n    \n    import org.pentaho.di.core.exception.KettleException;\n    import org.pentaho.di.core.row.RowDataUtil;\n    import org.pentaho.di.trans.Trans;\n    import org.pentaho.di.trans.TransMeta;\n    import org.pentaho.di.trans.step.BaseStep;\n    import org.pentaho.di.trans.step.StepDataInterface;\n    import org.pentaho.di.trans.step.StepInterface;\n    import org.pentaho.di.trans.step.StepMeta;\n    import org.pentaho.di.trans.step.StepMetaInterface;\n    /**\n     * BaseStep抽象类已经实现了接口里的很多方法，我们只要覆盖需要修改的方法即可。\n     * @author Administrator\n     *\n     */\n    public class HelloworldStep extends BaseStep implements StepInterface {\n    \t/**\n    \t * 类的构造函数通常直接把参数传递给BaseStep父类。由父类里的方法来构造对象，然后可以直接\n    \t * 使用类似transMeta这样的对象。\n    \t * @param stepMeta\n    \t * @param stepDataInterface\n    \t * @param copyNr\n    \t * @param transMeta\n    \t * @param trans\n    \t */\n    \tpublic HelloworldStep(StepMeta stepMeta, StepDataInterface stepDataInterface,\n    \t\t\tint copyNr, TransMeta transMeta, Trans trans) {\n    \t\tsuper(stepMeta, stepDataInterface, copyNr, transMeta, trans);\n    \t\t// TODO Auto-generated constructor stub\n    \t}\n    \n    \t\n    \tpublic boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException {\n    \n    \t\tHelloworldStepMeta meta  = (HelloworldStepMeta) smi;\n    \t\tHelloworldStepData data = (HelloworldStepData) sdi;\n    \t\t/**\n    \t\t * getRow()方法从上一个步骤获取一行数据。如果没有更多要获取的数据行，这个方法就会返回null。\n    \t\t * 如果前面的步骤不能及时提供数据，这个方法就会阻塞，直到有可用的数据行。这样这个步骤的速度就会降低，也会影响\n    \t\t * 其它步骤的速度。\n    \t\t */\n    \t\tObject[] row = getRow();\n    \t\tif (row==null) {\n    \t\t\t/**\n    \t\t\t * setOutputDone()方法用来通知其它的步骤，本步骤已经没有输出数据行。下一个步骤如果\n    \t\t\t * 再调用getRow()方法就会返回null,转换也不再调用processRow()方法。\n    \t\t\t */\n    \t\t\tsetOutputDone();\n    \t\t\treturn false;\n    \t\t}\n    \t\t\n    \t\tif (first) {\n    \t\t\tfirst=false;\n    \t\t\t/**\n    \t\t\t * 从性能上考虑，getRow()方法不提供数据行的元数据，只提供上个步骤输出的数据。可以使用getInputRowMeta()方法\n    \t\t\t获取元数据，元数据只获取一次即可，所以在first代码块里获取元数据。\n    \t\t\t   如果要把数据传到下一个步骤，要使用putRow()方法。除了输出数据，还要输出RowMetaInterface元数据。\n    \t\t\t   第一行使用clone()方法把输入行的元数据结构复制给输出行。输出行的元数据结构是在输入行的基础上增加一个字段，但\n    \t\t\t   构造输出行的元数据结构只能构造一次，因为所有输出数据行的结构都是一样的，产生了输出行以后，元数据结构就不能再变化。\n    \t\t\t   所以输出行的元数据结构在first代码块里构造。first是一个内部成员，first代码块里的代码只在处理第一行数据时执行。\n    \t\t\t   下面代码的最后一行，给输出数据增加了一个字段。\n    \t\t\t */\n    \t\t\tdata.outputRowMeta = getInputRowMeta().clone();\n    \t\t\tmeta.getFields(data.outputRowMeta, getStepname(), null, null, this);\n    \t\t}\n    \t\t/**\n    \t\t * 下面的代码，把数据写入输出流。从性能角度考虑，数据行实现就是Java数组。为了开发方便，可以使用RowDataUtil类提供\n    \t\t * 的一些静态方法来操作数据。使用RowDatautil静态方法复制数据，还可以提高性能。\n    \t\t */\n    \t\tString value = \"Hello, world!\";\n    \t\t\n    \t\tObject[] outputRow = RowDataUtil.addValueData(row, getInputRowMeta().size(), value);\n    \t\t\n    \t\tputRow(data.outputRowMeta, outputRow);\n    \t\t\n    \t\treturn true;\n    \t}\n    }\n解析：\npublic class HelloworldStep extends BaseStep implements StepInterface {\nBaseStep抽象类已经实现了接口里的很多方法，我们只要覆盖需要修改的方法即可。\n类的构造函数通常直接把参数传递给BaseStep父类。由父类里的方法来构造对象，然后可以直接使用类似transMeta这样的对象。\npublic HelloworldStep(StepMeta stepMeta, StepDataInterface stepDataInterface,\n\t\t\tint copyNr, TransMeta transMeta, Trans trans) {\n\t\tsuper(stepMeta, stepDataInterface, copyNr, transMeta, trans);\n\t}\ngetRow()方法从上一个步骤获取一行数据。如果没有更多要获取的数据行，这个方法就会返回null。如果前面的步骤不能及时提供数据，这个方法就会阻塞，直到有可用的数据行。这样这个步骤的速度就会降低，也会影响其它步骤的速度。\npublic boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException {\n\t\tHelloworldStepMeta meta  = (HelloworldStepMeta) smi;\n\t\tHelloworldStepData data = (HelloworldStepData) sdi;\n\t\tObject[] row = getRow();\n\t\tif (row==null) {\n\t\t\tsetOutputDone();\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (first) {\n\t\t\tfirst=false;\n\t\t\tdata.outputRowMeta = getInputRowMeta().clone();\n\t\t\tmeta.getFields(data.outputRowMeta, getStepname(), null, null, this);\n\t\t}\n\t\tString value = \"Hello, world!\";\n\t\tObject[] outputRow = RowDataUtil.addValueData(row, getInputRowMeta().size(), value);\n\t\t\n\t\tputRow(data.outputRowMeta, outputRow);\n\t\t\n\t\treturn true;\n\t}\n从性能上考虑，getRow()方法不提供数据行的元数据，只提供上个步骤输出的数据。可以使用getInputRowMeta()方法获取元数据，元数据只获取一次即可，所以在first代码块里获取元数据。\nsetOutputDone()方法用来通知其它的步骤，本步骤已经没有输出数据行。下一个步骤如果再调用getRow()方法就会返回null,转换也不再调用processRow()方法。\n\n    Object[] row = getRow();\n    \t\tif (row==null) {\n    \t\t\tsetOutputDone();\n    \t\t\treturn false;\n    \t\t}\n   如果要把数据传到下一个步骤，要使用putRow()方法。除了输出数据，还要输出RowMetaInterface元数据。\n    data.outputRowMeta = getInputRowMeta().clone();\n    meta.getFields(data.outputRowMeta, getStepname(), null, null, this);\n第一行使用clone()方法把输入行的元数据结构复制给输出行。输出行的元数据结构是在输入行的基础上增加一个字段，但构造输出行的元数据结构只能构造一次，因为所有输出数据行的结构都是一样的，产生了输出行以后，元数据结构就不能再变化。所以输出行的元数据结构在first代码块里构造。first是一个内部成员，first代码块里的代码只在处理第一行数据时执行。下面代码的最后一行，给输出数据增加了一个字段。\n\n下面的代码，把数据写入输出流。\n\t\tString value = \"Hello, world!\";\n\t\tObject[] outputRow = RowDataUtil.addValueData(row, getInputRowMeta().size(), value);\n\t\tputRow(data.outputRowMeta, outputRow);\n从性能角度考虑，数据行实现就是Java数组。为了开发方便，可以使用RowDataUtil类提供的一些静态方法来操作数据。使用RowDatautil静态方法复制数据，还可以提高性能。\n从指定的步骤读取数据行\n如果你想从前面的某个指定的步骤读取数据行，例如”流查询“步骤，可以使用getRowFrom()方法。\n\t   RowSet rowSet = findInputRowSet(Source Step Name);\n\t   Object[] rowData = getRowFrom(rowSet);\n\t       还可以通过rowSet对象获得数据行的元数据：\n\t   RowMetaInterface rowMeta = rowSet.getRowMeta();\n把数据行写入指定的步骤\n如果想把数据写入到某个特定的步骤，例如”过滤“步骤，可以使用putRowTo()方法\n\t  RowSet rowSet = findOutputRowSet(Target Step Name);\n\t  ....\n\t  putRowTo(outputRowMeta,rowData,rowSet);\n很明显，输入和输出的RowSet对象只需获得一次即可，这样才更有效率。\n把数据行写入到错误处理步骤\n如果想让你的步骤支持错误处理，而且元数据类返回的supportErrorHandling()方法返回了true，就可以把数据输出\n\t  到错误处理步骤里。下面是使用putError()方法的例子：\n\t  Object[] rowData = getRow();\n\t  ...\n\t  try{\n\t  \t...\n\t  \tputRow(...);\n\t  }catch(Exception e){\n\t  \tif(getStepMeta().isDoingErrorHandling()){\n\t  \t\tputError(getInputRowMeta(),rowData,errorCode);\n\t  \t}else{\n\t  \t\tthrow(e);\n\t  \t}\n\t  }\n\t  从例子里可以看到，这段代码把错误的行数、错误字段名、消息、错误编码都传递给错误处理步骤。\n\t  错误处理的其他工作都自动完成了。\n#### ####识别一个步骤拷贝\n因为一个步骤可以有多份拷贝同时执行，有时需要识别出正在使用的是哪个步骤拷贝，可以用下面几个方法。\n\t getCopy():获得拷贝号。拷贝号可以唯一标识出步骤的一个拷贝，拷贝号的聚会范围是0-N，N=getStepMeta().getCopies()-1\n\t getUniqueStepNrAcrossSlaves():获得在集群模式下运行的步骤拷贝号。\n\t getUniqueStepCountAcrossSlaves():获得在集群模式下运行的步骤拷贝总数。\n\t 通过这些方法可以把一个步骤的工作分配给多份拷贝去完成。例如”CSV文件输入“和”固定文件输入“步骤里都有并行读取文件的选项，这样可以把读取文件的工作放在多个拷贝里或集群里来完成。\n#### ####结果反馈\n在调用getRow()和putRow()方法时，引擎会自动计算两类度量值，读行数和写行数。这两类度量值可以在界面或日志中记录下来，以监控程序运行的状态。下面几个方法用来操作这两类度量值。\n\tincrementLinesRead():增加从前面步骤读取到的行数。\n\tincrementLinesWritten():增加定稿到后面步骤中的行数。\n\tincrementLinesInput():增加从文件、数据库、网络等资源读取到的行数\n\tincrementLinesOutput:增加写入到文件、数据库、网络等资源的行数。\n\tincrementLinesUpdate():增加更新的行数。\n\tincrementLinesSkipped()：增加跳过的数据行的行数。\n\tincrementLinesRejected():增加拒绝的数据行的行数。\n\t这些度量值用来说明步骤执行的情况。可以在Spoon的转换度量面板里看到，也可以存到日志数据库表里。\n\t使用addResultFile()方法，可以把步骤用到的文件保留下来，保存到结果文件列表里。结果文件列表可以被其它转换或作业项使用。例如，下面的”CSV文件输入“的代码：\nResultFile resultFile = new ResultFile(\n\tResultFile.FILE_TYPE_GENERAL,\n\tfileObject,\ngetTransMeta().getName(),\ngetStepName()\n);\nresultFile.setComment(“File was read by a Csv Input step”);\naddREsultFile(resultFile);\n#### ####变量替换\n\t如果输入框需要支持变量，可以使用environmentSubstritute()方法获取变量。例如，若想在“Hello World”例子的字段名输入框里使用变量，就要把StepMetaInterface里的getFields()方法修改成下面的语句：\nString realFiledName = apace. environmentSubstritute(fieldName)；\n因为步骤本身是一个VariableSpace对象，所以也可以使用下面的语句做变量替换：String value = environmentSubstritute(meta.getSringWithVariables());\n#### ####Apache VFS\nKettle里所有操作文件的步骤，都使用Apache VFS系统的方式操作。Apache VFS不但可以从文件系统读取文件（如java.io.File），还可以从很多其他来源读取文件，如FTP服务器、Z学压缩文件，等 等 。  \nApache VFS里的FileObject对象提供了文件的抽象层，然后在Kettle的KettleVFS类里还提供了一系列的静态方法，来更方便使用FileObject对象，例如下面的代码 ：  \n\n    FileObject fileObject = KettleVFS.getFileObject(“zip:http://www.example.com/archive.zip!file.txt”);\n`String value = environmentSubstritute(meta.getSringWithVariables());`\n\n\n应该尽可能多地使用KettleVFS,因为它解决了或饶过了很多Apache VFS目前已知的问题。它也增强了SFTP协议。\n#### ####步骤插件部署\n部署之前，要把四个Java源代码文件编译为class文件。把编译好的class文件放到一个Jar包里。可以使用IDE来做这些事情，也可以手工使用ant脚本来做这些事情。  \n.jar文件应该放在Kettle的plugins/steps目录下。也可以使用一个子目录，把所有的依赖的jar包放在插件jar包所在目录的/lib目录下，不必再放Kettle的类路径中（Kettle的libext/目录）已经有了的jar包。另外可以把多个插件放在一个jar包里。\n如果想在IDE里调试插件，可以把插件元数据类的名字放在Kettle_PLUGIN_CLASSES变量里（一个逗号分隔的列表）。关于这个主题的更多信息，请参考pentaho Wiki:http://wiki.pentaho.com/display/EAI/How+to+debug+a+Kettle+4+plugin 。\n\n","slug":"kettle/Kettle插件架构","published":1,"updated":"2017-08-18T01:44:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bpz00c7s77rtz4en8ii","content":"<h1 id=\"Kettle插件体系\"><a href=\"#Kettle插件体系\" class=\"headerlink\" title=\"#Kettle插件体系\"></a>#Kettle插件体系</h1><p>最近公司内有业务系统到数据中心同步的升级改造需求，从各个业务系统收集增量数据到数据中心的数据仓库平台。因为开发周期短暂，需要快速的响应，开发出可用的产品，所以决定借鉴开源程序Kettle，开发一个文件解析组件，然后利用Kettle平台的大数据组件进行与数据中心大数据平台对接</p>\n<p>数据同步部分是：业务系统（RDBMS）-&gt;Kettle(azkaban进行调度)-&gt;数据中心，因为Kettle的增量抽取组件经常出现数据不一致等问题，所以目前已更改为：业务系统（RDBMS）-&gt;OGG（CDC增量抽取）-&gt;数据中心的方式。</p>\n<p>本文主要介绍如何扩展Kettle的功能，部分内容来自《Pentaho Kettle解决方案：使用PDI构建开源ETL解决方案》一书，推荐购买阅读。</p>\n<h2 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"##架构\"></a>##架构</h2><p>我们先看Kettle插件架构。<br> <img src=\"http://i.imgur.com/mLvXMuV.jpg\" alt=\"\"><br>从功能上看，Kettle内部的对象和外部插件没有任何区别。因为它们使用的API都是一样的，它们只是在运行时的加载方式不同。<br>从Kettle4以后，Kettle内部有一个插件注册系统，它负责加载各种内部和外部插件。插件有以下两个标识属性。<br><strong>插件类型</strong>：由PluginTypeInterface接口定义。例如StepPluginType、JobEntryPluginType、PartitionerPluginType和RepositoryPluginType。<br><strong>插件ID</strong>：这是一个字符串数组，用来唯一标识一个插件。因为旧的插件可以被新的插件代替，一个插件可以有多个ID。在大多数情况下，插件只使用一个单一的字符串，如TableInput是“表输入”步骤的ID，MYSQL是MySQL数据库类型的ID。<br>当Kettle环境初始化以后，插件注册系统首先加载所有的内部对象，Kettle读取下面的配置文件来加载内部对象，这些配置文件位于Kettle的.jar文件中。<br>     Kettle-steps.xml：内部转换步骤。<br>     Kettle-job-entries.xml：内部作业项。<br>     Kettle-partition-plugins.xml：内部分区类型。<br>     Kettle-database-types.xml：内部数据库类型。<br>     Kettle-repositories.xml：内部资源库类型。</p>\n<p>插件注册系统加载了所有的内部对象后，就要搜索可用的外部插件。通过浏览plugins/目录的各个子目录下的.jar文件来完成。它搜索特定的Kettle annotations来判断一个类是否是插件。加载过程将在本章的后面介绍。<br>因为在内部对象加载后才加载插件，所以插件会替代相同ID的已加载的内部对象。例如，你创建了插件，插件的ID是TableInput，就可以替换Kettle标准的“表输入”步骤。这个功能可以让你用插件替换Kettle内置的步骤。可以通过子类继承方式，直接扩展已有步骤的某些功能。</p>\n<h2 id=\"插件类型\"><a href=\"#插件类型\" class=\"headerlink\" title=\"##插件类型\"></a>##插件类型</h2><p>Kettle有下面几种插件类型（下面的插件是Kettle4.0的插件类型，新版kettle包含了很多新的插件，比如视图插件、大数据插件等等）。</p>\n<ul>\n<li>转换步骤插件：在Kettle转换中使用的步骤，用来处理数据行。</li>\n</ul>\n<ul>\n<li>作业项插件：在Kettle作业中使用的作业项，用来实现某个任务。</li>\n</ul>\n<ul>\n<li>分区方法插件：利用输入字段的值指定自己的分区规则。</li>\n</ul>\n<ul>\n<li>数据库类型插件：用来扩展不同的数据库类型。</li>\n</ul>\n<ul>\n<li>资源库类型插件：可以把Kettle元数据保存为自定义类型或格式。</li>\n</ul>\n<p>说明：除了这些类型，还有Spoon类型的插件，可以把功能扩展到Spoon，本书不介绍这个功能。</p>\n<h2 id=\"转换步骤插件\"><a href=\"#转换步骤插件\" class=\"headerlink\" title=\"##转换步骤插件\"></a>##转换步骤插件</h2><p>转换步骤插件包括了四个Java类，这四个类分别实现四个接口。</p>\n<ul>\n<li>StepMetaInterface：这个接口对外 提供步骤的元数据并处理串行化。</li>\n</ul>\n<ul>\n<li>StepInterface:这个接口根据上面接口提供的元数据，来实现步骤的具体功能。</li>\n</ul>\n<ul>\n<li>StepDataInterface:这个接口用来存储步骤的临时数据、文件句柄等。</li>\n</ul>\n<ul>\n<li>StepDialogInterface:这个接口是Spoon里的图形界面，用来编辑步骤的元数据。</li>\n</ul>\n<p>接下来，我们介绍这些接口的基本内容。对于每个接口，在一个简单的“Hello World”例子里提供这些类的相应实现。“Hello World”例子将在数据流里增加一个字段，字段名用户可以自定义，字段值是”Hello world!“。最后介绍一下如何部署这个例子。</p>\n<h3 id=\"StepMetaInterface\"><a href=\"#StepMetaInterface\" class=\"headerlink\" title=\"###StepMetaInterface\"></a>###StepMetaInterface</h3><p>接口org.pentaho.di.trans.step.StepMetaInterface负责步骤里所有和元数据相关的任务。和元数据相关的工作包括：<br>元数据和XML(或资源库)之间的序列化和反序列化<br>getXML（）和loadXML()<br>saveRep()和readRep()  </p>\n<p>描述输出字段<br>getFields()  </p>\n<p>检验元数据是否正确<br>Check()  </p>\n<p>获取步骤相应的要SQL语句，使步骤可以正确运行<br>getSQLStatements()  </p>\n<p>给元数据设置默认值<br>setDefault()  </p>\n<p>完成对数据库的影响分析<br>analyseImpact()  </p>\n<p>描述各类输入和输出流<br>getStepIOMeta()<br>searchInfoAndTargetSteps()<br>handleStreamSelection()<br>getOptionalStreams()<br>resetStepIoMeta()  </p>\n<p>导出元数据资源<br>exportResources()<br>getResourceDependencies()  </p>\n<p>描述使用的库<br>getUsedLibraries()  </p>\n<p>描述使用的数据库连接<br>getUsedDatabaseConnections()  </p>\n<p>描述这个步骤需要的字段（通常是一个数据库表）<br>getRequiredFields()  </p>\n<p>描述步骤是否具有某些功能<br>supportsErrorHandling()<br>excludeFromRowLayoutVerification()<br>excludeFromCopyDistributeVerification()  </p>\n<p>这个接口里还定义了几个方法来说明这四个接口如何结合到一起。<br>String getDialogClassName():用来描述实现了StepDialogInterface接口的对话框类的名字。如果这个方法返回了null，调用类会根据实现了StepMetaInterface接口的类的类名和包名来自动生成对话框类的名字。<br>SetpInterface getStep():创建一个实现了StepInterface接口的类。<br>StepDataInterface getStepData():创建一个实现了StepDataInterface接口的类。<br>现在我们看看”Hello World”例子里对SetpMetaInterface接口的实现<br>HelloworldStepMeta.java<br>    package org.kettlesolutions.plugin.step.helloworld;</p>\n<pre><code>import java.util.List;\nimport java.util.Map;\n\nimport org.pentaho.di.core.CheckResult;\nimport org.pentaho.di.core.CheckResultInterface;\nimport org.pentaho.di.core.Const;\nimport org.pentaho.di.core.Counter;\nimport org.pentaho.di.core.annotations.Step;\nimport org.pentaho.di.core.database.DatabaseMeta;\nimport org.pentaho.di.core.exception.KettleException;\nimport org.pentaho.di.core.exception.KettleStepException;\nimport org.pentaho.di.core.exception.KettleXMLException;\nimport org.pentaho.di.core.row.RowMetaInterface;\nimport org.pentaho.di.core.row.ValueMeta;\nimport org.pentaho.di.core.row.ValueMetaInterface;\nimport org.pentaho.di.core.variables.VariableSpace;\nimport org.pentaho.di.core.xml.XMLHandler;\nimport org.pentaho.di.i18n.BaseMessages;\nimport org.pentaho.di.repository.ObjectId;\nimport org.pentaho.di.repository.Repository;\nimport org.pentaho.di.trans.Trans;\nimport org.pentaho.di.trans.TransMeta;\nimport org.pentaho.di.trans.step.BaseStepMeta;\nimport org.pentaho.di.trans.step.StepDataInterface;\nimport org.pentaho.di.trans.step.StepInterface;\nimport org.pentaho.di.trans.step.StepMeta;\nimport org.pentaho.di.trans.step.StepMetaInterface;\nimport org.w3c.dom.Node;\n\n@Step(\n        id=&quot;Helloworld&quot;,\n        name=&quot;name&quot;,\n        description=&quot;description&quot;,\n        categoryDescription=&quot;categoryDescription&quot;, \n        image=&quot;org/kettlesolutions/plugin/step/helloworld/HelloWorld.png&quot;,\n        i18nPackageName=&quot;org.kettlesolutions.plugin.step.helloworld&quot;\n) \npublic class HelloworldStepMeta extends BaseStepMeta implements StepMetaInterface {\n    /**\n     * PKG变量说明了messages包的位置，在messages包里有各种国际化的资源文件。\n     * 在本章后面经常要看到的BaseMessages.getString()方法，就是根据软件的国际化\n     * 设置，从不同的文件中获取文字。PKG变量通常位于类的最上方，被国际化图形工具使用，\n     * 通过国际化图形工具，国际化人员可以编辑不同的国际化资源文件。所以我们会在很多Kettle\n     * 代码里看见这样的结构。\n     */\n    private static Class&lt;?&gt; PKG = HelloworldStep.class; //for i18n\n    public enum Tag {//field_name用于保存用户输入的字段名：保存“Hello，world！&quot;字符串的字段名。\n        field_name,\n    };\n\n    private String fieldName;\n\n    /**\n     * @return the fieldName\n     */\n    public String getFieldName() {\n        return fieldName;\n    }\n\n    /**\n     * @param fieldName the fieldName to set\n     */\n    public void setFieldName(String fieldName) {\n        this.fieldName = fieldName;\n    }\n\n    /**\n     * checks parameters, adds result to List&lt;CheckResultInterface&gt;\n     * used in Action &gt; Verify transformation\n     * 验证用户是否在对话框里输入了字段名，并把验证结果添加到检验转换时出现的问题列表里。（最好\n     * 要检验用户输入的所有选项，而不只是容易出错的选项）\n     */\n    public void check(List&lt;CheckResultInterface&gt; remarks, TransMeta transMeta, StepMeta stepMeta, \n            RowMetaInterface prev, String input[], String output[], RowMetaInterface info) {\n\n        if (Const.isEmpty(fieldName)) {\n            CheckResultInterface error = new CheckResult(\n                CheckResult.TYPE_RESULT_ERROR, \n                BaseMessages.getString(PKG, &quot;HelloworldMeta.CHECK_ERR_NO_FIELD&quot;), \n                stepMeta\n            );\n            remarks.add(error);\n        } else {\n            CheckResultInterface ok = new CheckResult(\n                CheckResult.TYPE_RESULT_OK, \n                BaseMessages.getString(PKG, &quot;HelloworldMeta.CHECK_OK_FIELD&quot;), \n                stepMeta\n            );\n            remarks.add(ok);//把验证结果添加到检验转换时出现的问题列表里。\n        }\n    }\n\n    /**\n     *    creates a new instance of the step (factory)\n     * getStep、getStepData和getDialogClassName()方法提供了与这个步骤里其它三个接口之间的桥梁\n     这个接口里还定义了几个方法来说明这四个接口如何结合到一起。\n    String getDialogClassName():用来描述实现了StepDialogInterace接口的对话框类的名字。如果这个方法返回\n                了null，调用类会根据实现了StepMetaInterface接口的类的类名和包名来自动生成对话框类的名字。\n    StepInterface getStep():创建一个实现了StepInterface接口的类。\n    StepInterface getStepData():创建一个实现了StepDataInterface接口的类。\n\n     */\n    public StepInterface getStep(StepMeta stepMeta, StepDataInterface stepDataInterface,\n            int copyNr, TransMeta transMeta, Trans trans) {\n        return new HelloworldStep(stepMeta, stepDataInterface, copyNr, transMeta, trans);\n    }\n\n    /**\n     * creates new instance of the step data (factory)\n     * getStep、getStepData和getDialogClassName()方法提供了与这个步骤里其它三个接口之间的桥梁\n     */\n    public StepDataInterface getStepData() {\n        return new HelloworldStepData();\n    }\n    /**\n     * getStep、getStepData和getDialogClassName()方法提供了与这个步骤里其它三个接口之间的桥梁\n     */\n    @Override\n    public String getDialogClassName() {\n        return HelloworldStepDialog.class.getName();\n    }\n\n    /**\n     * deserialize from xml \n     * databases = list of available connections\n     * counters = list of sequence steps\n     * \n     * 下面的四个方法loadXML()、getXML()、readRep()和saveRep()把元数据保存到XML文件或资源库里，\n     * 或者从XML文件或资源库读取元数据。保存到文件的方法利用了像XStream（http://xstream.codehaus.org）这\n     * 样的XML串行化技术。\n     */\n    public void loadXML(Node stepDomNode, List&lt;DatabaseMeta&gt; databases,\n            Map&lt;String, Counter&gt; sequenceCounters) throws KettleXMLException {\n        fieldName = XMLHandler.getTagValue(stepDomNode, Tag.field_name.name());\n    }\n\n    /**\n     * @Override\n     */\n    public String getXML() throws KettleException {\n        StringBuilder xml = new StringBuilder();\n        xml.append(XMLHandler.addTagValue(Tag.field_name.name(), fieldName));\n        return xml.toString();\n    }\n\n    /**\n     * De-serialize from repository (see loadXML)\n     */\n    public void readRep(Repository repository, ObjectId stepIdInRepository,\n            List&lt;DatabaseMeta&gt; databases, Map&lt;String, Counter&gt; sequenceCounters)\n            throws KettleException {\n        fieldName = repository.getStepAttributeString(stepIdInRepository, Tag.field_name.name());\n    }\n\n    /**\n     * serialize to repository\n     */\n    public void saveRep(Repository repository, ObjectId idOfTransformation, ObjectId idOfStep)\n            throws KettleException {\n        repository.saveStepAttribute(idOfTransformation, idOfStep, Tag.field_name.name(), fieldName);\n    }\n\n\n    /**\n     * initiailize parameters to default\n     */\n    public void setDefault() {\n        fieldName = &quot;helloField&quot;;\n    }\n\n    /**\n     * getFields()方法非常重要，因为它描述了输出数据行的结构。这个方法需要修改inputRowMeta对象，使这个对象和\n     * 输出格式匹配。Spoon和后面的步骤都需要知道这个步骤要输出哪些字段。最常见的一种方法，可以给输出的RowMetaInterface对象\n     * 添加一个ValueMetaInterface对象。在ValueMetaInterface对象里设置的信息越详细越好，可以设置的信息包括数据类型、长度、\n     * 精度、格式掩码，等等。添加的字段描述元信息越多，后面生成的SQL就越准确。\n     */\n    @Override\n    public void getFields(RowMetaInterface inputRowMeta, String name,\n            RowMetaInterface[] info, StepMeta nextStep, VariableSpace space)\n            throws KettleStepException {\n        String realFieldName = space.environmentSubstitute(fieldName);\n        //值的元数据使用ValueMetaInterface接口描述数据流里的一个字段。这个接口里定义了字段的名字、数据类型、长度、精度，等等。下面的例子用于创建一个ValueMetaInterface对象。\n        ValueMetaInterface field = new ValueMeta(realFieldName, ValueMetaInterface.TYPE_STRING);\n        field.setOrigin(name);        \n        inputRowMeta.addValueMeta(field);\n    }\n}\n</code></pre><p>代码解析<br>    @Step(<br>            id=”Helloworld”,<br>            name=”name”,<br>            description=”description”,<br>            categoryDescription=”categoryDescription”,<br>            image=”org/kettlesolutions/plugin/step/helloworld/HelloWorld.png”,<br>            i18nPackageName=”org.kettlesolutions.plugin.step.helloworld”<br>    )<br>这段代码里的@Step annotation用来通知Kettle的插件注册系统：这个类是一个步骤类型的插件。在annotation里可以指定插件的ID、图标、国际代的包、本地化的名称、类别、描述。其中后三项是资源文件里的Key，需要在资源文件里设置真正的值。i18nPackageName指定了资源文件的包名，例如我们这个例子的资源文件位于org/kettlesolutions/plugin/step/helloworld/messages目录下，en_US（英语，美国）的本地代资源文件是messages_en_US.properties。我们例子里的这个资源文件的内容是：<br>name=Hello world<br>description=A very simple step that adds a new “Helllo world” field to the incoming stream<br>注意，如果你指定了不存在的分类，Spoon会创建这个分类，并在Spoon的分类树的最上方显示这个分类。<br>最后，annotation里的image标签指定了插件的图标。需要32*32像素的PNG文件，可以使用透明样式。<br>后面的代码行说明这个类实现了StepMetaInterface接口。在BaseStepMeta抽象类里定义了这个接口的很多默认实现，可以直接继承这个抽象类，然后把工作集中在插件特有的功能上。</p>\n<pre><code>public class HelloworldStepMeta extends BaseStepMeta implements StepMetaInterface\n</code></pre><p>下面的四个方法loadXML()、getXML()、readRep()和saveRep()把元数据保存到XML文件或资源库里，或者从XML文件或资源库读取元数据。保存到文件的方法利用了像XStream（<a href=\"http://xstream.codehaus.org）这样的XML串行化技术。\" target=\"_blank\" rel=\"noopener\">http://xstream.codehaus.org）这样的XML串行化技术。</a></p>\n<p>getFields()方法非常重要，因为它描述了输出数据行的结构。这个方法需要修改inputRowMeta对象，使这个对象和输出格式匹配。Spoon和后面的步骤都需要知道这个步骤要输出哪些字段。最常见的一种方法，可以给输出的RowMetaInterface对象添加一个ValueMetaInterface对象。在ValueMetaInterface对象里设置的信息越详细越好，可以设置的信息包括数据类型、长度、精度、格式掩码，等等。添加的字段描述元信息越多，后面生成的SQL就越准确。</p>\n<h4 id=\"值的元数据（Value-Metadata）\"><a href=\"#值的元数据（Value-Metadata）\" class=\"headerlink\" title=\"####值的元数据（Value Metadata）\"></a>####值的元数据（Value Metadata）</h4><p>值的元数据使用ValueMetaInterface接口描述数据流里的一个字段。这个接口里定义了字段的名字、数据类型、长度、精度，等等。下面的例子用于创建一个ValueMetaInterface对象。<br>    ValueMetaInterface dateMeta = new ValueMeta(“birthdate”,ValueMetaInterface.TYPE_DATE);<br>这个接口也负责转换数据格式。我们建议使用ValueMetaInterface接口来完成所有数据转换的工作。例如，日期类型的数据，如果想把它转换为dateMeta对象里定义的字符串格式，可以用下面的代码：<br>    //java.util.Date birthdate<br>    String birthDateString = dateMeta.getString(birthdate);<br>ValueMeta类负责转换。因为有ValueMetaInterface进行数据类型的转换，所以你不用再去做额外的数据类型转换的工作。<br>使用ValueMetaInterface接口时还要注意数据对象是否为Null。从上一个步骤可以接收到一个数据对象和一个描述数据对象的ValueMetaInterface对象。我们要检查这个数据对象是否为null，在某些情况下如果数据对象为空是不正确的。例如：<br>数据对象是String类型，有10个空格，Value Metadata需要trim这个字符串。<br>在Value Metadata里已经定义了从文本文件里加载的数据，要延迟转换为字符串。所以数据要由二进制的格式（原始数据格式），转换为字符串格式，然后再转换为其它格式的数据。<br>一般使用下面的方法检查数据对象是否为空：<br>    Boolean n = valueMeta.isNull(valueDate);<br>重要：要保证传给ValueMetaInterface对象的数据是在元数据里定义的数据类型。表23-1说明了  ValueMetaInterface里定义的数据类型和Java数据类型的对应关系。<br>Kettle元数据类型和Java里数据类型的对应关系  </p>\n<table><br>    <tr><br>        <th>Value Meta Type</th><br>        <th>Java Class</th><br>    </tr><br>    <tr><br>        <td>ValueMetaInterface.TYPE_STRING</td><br>        <td>Java.lang.String</td><br>    </tr><br>    <tr><br>        <td>ValueMetaInterface.TYPE_DATE</td><br>        <td>Java.util.Date</td><br>    </tr><br>    <tr><br>        <td>ValueMetaInterface.TYPE_BOOLEAN</td><br>        <td>Java.lang.Boolean</td><br>    </tr><br>    <tr><br>        <td>ValueMetaInterface.TYPE_NUMBER</td><br>        <td>Java.lang.Double</td><br>    </tr><br>    <tr><br>        <td>ValueMetaInterface.TYPE_INTEGER</td><br>        <td>Java.lang.Long</td><br>    </tr><br>    <tr><br>        <td>ValueMetaInterface.TYPE_BIGNUMBER</td><br>        <td>Java.math.BigDecimal</td><br>    </tr><br>    <tr><br>        <td>ValueMetaInterface.TYPE_BINARY</td><br>        <td>Byte[]</td><br>    </tr><br></table>\n\n\n<h4 id=\"行的元数据（Row-Meatadata）\"><a href=\"#行的元数据（Row-Meatadata）\" class=\"headerlink\" title=\"####行的元数据（Row Meatadata）\"></a>####行的元数据（Row Meatadata）</h4><p>行的元数据使用RowMetaInterface接口来描述数据行的元数据，而不是一个列的元数据。实际上，RowMetaInterface的类里包含了一组ValueMetaInterface。另外还包括了一些方法来操作行元数据，倒如查询值、检查值是否存、替换值的元数据等。<br>行的元数据里唯一的规则就是一行里的列的名字必须唯一。当你添加了一个新列时，如果新列的名字和已有列的名字相同，列名后面会自动加上“_2”后缀。如果再加一个同名的列会自动加上”_3“后缀，等等。<br>因为在步骤里通常是和数据行打交道，所以从数据行里直接取数据会更方便。可以使用很多类似于getNumber()、getString()这样的方法直接从数据行取数据。例如，销售数据存储在第四列里，可以用下面的代码获取这个数据：  </p>\n<pre><code>Double sales = getInputRowMeta().getNumber(rowData,3);\n</code></pre><p>通过索引获取数据是最快的方式。通过indexOfValue()方法可以获取列在一行里的索引。这个方法扫描列数组，速度并不快。所以，如果要处理所有数据行，我们建议只查询一次列索引。一般是在步骤接收到第一行数据时，就查询列索引，将查询到的列索引保存起来，供后面的数据行使用。  </p>\n<h3 id=\"StepDatainterface\"><a href=\"#StepDatainterface\" class=\"headerlink\" title=\"###StepDatainterface\"></a>###StepDatainterface</h3><p>实现了org.pentaho.di.trans.step.StepDataInterface接口的类用来维护步骤的执行状态，以及存储临时对象。例如，可以把输出行的元数据、数据库连接、输入输出流等存储到这个对象里。<br>HelloworldStepData.java<br>    package org.kettlesolutions.plugin.step.helloworld;</p>\n<p>import org.pentaho.di.core.row.RowMetaInterface;<br>import org.pentaho.di.trans.step.BaseStepData;<br>import org.pentaho.di.trans.step.StepDataInterface;</p>\n<p>public class HelloworldStepData extends BaseStepData implements StepDataInterface {</p>\n<pre><code>public RowMetaInterface outputRowMeta;\n</code></pre><p>}</p>\n<h3 id=\"StepDialogInterface\"><a href=\"#StepDialogInterface\" class=\"headerlink\" title=\"###StepDialogInterface\"></a>###StepDialogInterface</h3><p>实现org.pentaho.di.trans.step.StepDialogInterfac接口的类用来提供一个用户界面，用户通过这个界面输入元数据（转换参数）。用户界面就是一个对话框。这个接口里包含了类似open()和setRepository()等的几个简单的方法。    </p>\n<h4 id=\"Eclipse-SWT\"><a href=\"#Eclipse-SWT\" class=\"headerlink\" title=\"####Eclipse SWT\"></a>####Eclipse SWT</h4><p>Kettle里使用Eclipse SWT作为界面开发包，所以你也要使用SWT来开发对话框窗口。SWT为不同的操作系统Windows、OS X、Linux和Unix提供了一个抽象层。所以SWT的图形界面和操作系统期货的程序的界面风格非常相近。<br>在开始进行SWT开发之前，建议先访问SWT主面以了解更多的内容<a href=\"http://www.eclipse/org/swt。在SWT的网站上，你可以了解到SWT能做出什么样的界面效果：\" target=\"_blank\" rel=\"noopener\">http://www.eclipse/org/swt。在SWT的网站上，你可以了解到SWT能做出什么样的界面效果：</a><br>SWT控件页，<a href=\"http://www.eclipse.org/swt/widgets/，给出了你能使用的所有控件。\" target=\"_blank\" rel=\"noopener\">http://www.eclipse.org/swt/widgets/，给出了你能使用的所有控件。</a><br>SWT样例页，<a href=\"http://www.eclipse.org/swt/snippets/，给出了许多代码例子。\" target=\"_blank\" rel=\"noopener\">http://www.eclipse.org/swt/snippets/，给出了许多代码例子。</a><br>最好的资源就是Kettle里150个内置步骤的对话框源代码。  </p>\n<p>HelloworldStepDialog.java<br>    package org.kettlesolutions.plugin.step.helloworld;</p>\n<pre><code>import org.eclipse.swt.SWT;\nimport org.eclipse.swt.events.ModifyEvent;\nimport org.eclipse.swt.events.ModifyListener;\nimport org.eclipse.swt.events.SelectionAdapter;\nimport org.eclipse.swt.events.SelectionEvent;\nimport org.eclipse.swt.events.ShellAdapter;\nimport org.eclipse.swt.events.ShellEvent;\nimport org.eclipse.swt.layout.FormAttachment;\nimport org.eclipse.swt.layout.FormData;\nimport org.eclipse.swt.layout.FormLayout;\nimport org.eclipse.swt.widgets.Button;\nimport org.eclipse.swt.widgets.Control;\nimport org.eclipse.swt.widgets.Display;\nimport org.eclipse.swt.widgets.Event;\nimport org.eclipse.swt.widgets.Label;\nimport org.eclipse.swt.widgets.Listener;\nimport org.eclipse.swt.widgets.Shell;\nimport org.eclipse.swt.widgets.Text;\nimport org.pentaho.di.core.Const;\nimport org.pentaho.di.i18n.BaseMessages;\nimport org.pentaho.di.trans.TransMeta;\nimport org.pentaho.di.trans.step.BaseStepMeta;\nimport org.pentaho.di.trans.step.StepDialogInterface;\nimport org.pentaho.di.ui.core.widget.TextVar;\nimport org.pentaho.di.ui.trans.step.BaseStepDialog;\n\npublic class HelloworldStepDialog extends BaseStepDialog implements\n        StepDialogInterface {\n\n    private static Class&lt;?&gt; PKG = HelloworldStepMeta.class; // for i18n\n                                                            // purposes, needed\n                                                            // by Translator2!!\n                                                            // $NON-NLS-1$\n\n    private HelloworldStepMeta input;\n\n    private TextVar wFieldname;\n\n    public HelloworldStepDialog(Shell parent, Object baseStepMeta,\n            TransMeta transMeta, String stepname) {\n        //初始化元数据对象以及步骤对话框的父类\n        super(parent, (BaseStepMeta) baseStepMeta, transMeta, stepname);\n        input = (HelloworldStepMeta) baseStepMeta;\n    }\n\n    public String open() {\n        Shell parent = getParent();\n        Display display = parent.getDisplay();\n\n        shell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MIN\n                | SWT.MAX);\n        props.setLook(shell);\n        setShellImage(shell, input);\n\n        ModifyListener lsMod = new ModifyListener() {\n            public void modifyText(ModifyEvent e) {\n                input.setChanged();\n            }\n        };\n        changed = input.hasChanged();\n\n        FormLayout formLayout = new FormLayout();\n        formLayout.marginWidth = Const.FORM_MARGIN;\n        formLayout.marginHeight = Const.FORM_MARGIN;\n\n        shell.setLayout(formLayout);\n        shell.setText(BaseMessages.getString(PKG,\n                &quot;HelloworldDialog.Shell.Title&quot;)); //$NON-NLS-1$\n\n        //所有控件的右侧使用一个自定义的百分对对齐。控件之间的间距使用一个常量，常量值是4像素。\n        int middle = props.getMiddlePct();\n        int margin = Const.MARGIN;\n\n        // Stepname line\n        wlStepname = new Label(shell, SWT.RIGHT);\n        wlStepname.setText(BaseMessages.getString(PKG,\n                &quot;HelloworldDialog.Stepname.Label&quot;)); //$NON-NLS-1$\n        props.setLook(wlStepname);\n        fdlStepname = new FormData();\n        fdlStepname.left = new FormAttachment(0, 0);\n        fdlStepname.right = new FormAttachment(middle, -margin);\n        fdlStepname.top = new FormAttachment(0, margin);\n        wlStepname.setLayoutData(fdlStepname);\n        wStepname = new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n        wStepname.setText(stepname);\n        props.setLook(wStepname);\n        wStepname.addModifyListener(lsMod);\n        fdStepname = new FormData();\n        fdStepname.left = new FormAttachment(middle, 0);\n        fdStepname.top = new FormAttachment(0, margin);\n        fdStepname.right = new FormAttachment(100, 0);\n        wStepname.setLayoutData(fdStepname);\n        Control lastControl = wStepname;\n\n        // Fieldname line\n        //创建一个新的标签控件，控件里文本靠右对齐\n        Label wlFieldname = new Label(shell, SWT.RIGHT);\n        wlFieldname.setText(BaseMessages.getString(PKG,\n                &quot;HelloworldDialog.Fieldname.Label&quot;)); //$NON-NLS-1$\n        //下面一行为控件设置用户定义的背景色和字体\n        props.setLook(wlFieldname);\n        FormData fdlFieldname = new FormData();\n        fdlFieldname.left = new FormAttachment(0, 0);\n        fdlFieldname.right = new FormAttachment(middle, -margin);\n        fdlFieldname.top = new FormAttachment(lastControl, margin);\n        wlFieldname.setLayoutData(fdlFieldname);\n        wFieldname = new TextVar(transMeta, shell, SWT.SINGLE | SWT.LEFT\n                | SWT.BORDER);\n        props.setLook(wFieldname);\n        wFieldname.addModifyListener(lsMod);\n        FormData fdFieldname = new FormData();\n        fdFieldname.left = new FormAttachment(middle, 0);\n        fdFieldname.top = new FormAttachment(lastControl, margin);\n        fdFieldname.right = new FormAttachment(100, 0);\n        wFieldname.setLayoutData(fdFieldname);\n        lastControl = wFieldname;\n\n        // Some buttons\n        wOK = new Button(shell, SWT.PUSH);\n        wOK.setText(BaseMessages.getString(PKG, &quot;System.Button.OK&quot;)); //$NON-NLS-1$\n        wCancel = new Button(shell, SWT.PUSH);\n        wCancel.setText(BaseMessages.getString(PKG, &quot;System.Button.Cancel&quot;)); //$NON-NLS-1$\n\n        setButtonPositions(new Button[] { wOK, wCancel }, margin, lastControl);\n\n        // Add listeners\n        lsCancel = new Listener() {\n            public void handleEvent(Event e) {\n                cancel();\n            }\n        };\n        lsOK = new Listener() {\n            public void handleEvent(Event e) {\n                ok();\n            }\n        };\n\n        wCancel.addListener(SWT.Selection, lsCancel);\n        wOK.addListener(SWT.Selection, lsOK);\n\n        lsDef = new SelectionAdapter() {\n            public void widgetDefaultSelected(SelectionEvent e) {\n                ok();\n            }\n        };\n\n        wStepname.addSelectionListener(lsDef);\n        wFieldname.addSelectionListener(lsDef);\n\n        // Detect X or ALT-F4 or something that kills this window...\n        shell.addShellListener(new ShellAdapter() {//保证了窗口在非正常关闭时，取消用户的编辑\n            public void shellClosed(ShellEvent e) {\n                cancel();\n            }\n        });\n\n        // Populate the data of the controls\n        //下面的代码把数据从步骤的元数据对象里复制到窗口的控件里\n        getData();\n\n        // Set the shell size, based upon previous time...\n        //窗口的大小和位置将根据窗口的自然属性、上次窗口大小和位置，以及显示屏的大小自动设置\n        setSize();\n\n        input.setChanged(changed);\n\n        shell.open();\n        while (!shell.isDisposed()) {\n            if (!display.readAndDispatch())\n                display.sleep();\n        }\n        return stepname;\n    }\n\n    /**\n     * Copy information from the meta-data input to the dialog fields.\n     */\n    public void getData() {\n        wStepname.selectAll();\n        //为了防止用户向控件里输入空值，Kettle提供了一个静态方法来检查宿舍，Const.NVL()\n        wFieldname.setText(Const.NVL(input.getFieldName(), &quot;&quot;));\n    }\n\n    private void cancel() {\n        stepname = null;\n        input.setChanged(changed);\n        dispose();\n    }\n    //单击OK把控件里用户输入的数据都写入到步骤的元数据对象中。\n    private void ok() {\n        if (Const.isEmpty(wStepname.getText()))\n            return;\n\n        stepname = wStepname.getText(); // return value\n\n        input.setFieldName(wFieldname.getText());\n\n        dispose();\n    }\n}\n</code></pre><h4 id=\"窗体布局\"><a href=\"#窗体布局\" class=\"headerlink\" title=\"####窗体布局\"></a>####窗体布局</h4><p>如果你看过步骤对话框的源代码，你就会发现窗体类里有很多烦琐的代码。这些代码确保Kettle可以在各种操作系统下以合适的方式展现窗体。可以发现窗体里的大部分代码都和布局以及控件位置有关。<br>FormLayout是SWT里经常看到的布局方式。程序员可以通过FormLayout指定控件的百分比、偏移。下面是我们例子里的窗口布局的代码（HelloworldStepDialog.java）<br>    //创建一个新的标签控件，控件里文本靠右对齐<br>    Label label = new Label(shell, SWT.RIGHT);<br>    label.setText(BaseMessages.getString(PKG,”HelloworldDialog.Fieldname.Label”)); //$NON-NLS-1$<br>    //下面一行为控件设置用户定义的背景色和字体<br>    props.setLook(label);<br>    /**</p>\n<pre><code>* 下面几行将标签的左侧和对话框的最左侧对齐，把标签的右侧放在对话框中间（50%）的左侧10个像素\n* 的位置。标签的顶部放在距离对话框顶部25个像素的位置。\n*/\nFormData fdLabel = new FormData();\nfdlFieldname.left = new FormAttachment(0, 0);\nfdlFieldname.right = new FormAttachment(50, -10);\nfdlFieldname.top = new FormAttachment(0, 25);\nwlFieldname.setLayoutData(fdLabel);  \n</code></pre><p>简而言之，不要感到痛苦；图形用户界面的代码都比较烦琐，但代码并不复杂。  </p>\n<h4 id=\"Kettle-UI元素\"><a href=\"#Kettle-UI元素\" class=\"headerlink\" title=\"####Kettle UI元素\"></a>####Kettle UI元素</h4><p>除了标准的SWT组件，还可以使用Kettle自带的一些控件，Kettle开发人员的工作可以更简单一些。Kettle自带的组件包括以下一些。<br>TableView：这是一个数据表格组件，支持排序、选择、键盘快捷键和撤销/重做，以及右键菜单。<br>TextVar：这是一个支持变量的文本输入框，这个输入框的右上角有一个$符号。用户可以通过”Ctrl  +Alt+空格”的方式，在弹出的下拉列表中选择变量。其他功能和普通的文本框相同。<br>ComboVar：标准的组合下拉列表，支持变量。<br>ConditionEditor：过滤行步骤里使用的输入条件控件。<br>另外还有很多常用的对话框帮你完成相应的工作，如下所示:<br>EnterListDialog:从字符串列表里选择一个或多个字符串。左侧显示字符串列表，右侧是选中的字符串，并提供把字符串从左侧移动到右侧的按钮。<br>EnterNumberDialog:用户可以输入数字<br>EnterPasswordDialog:让用户输入密码<br>EnterSelectionDialog:通过高亮显示，从列表里选择多项<br>EnterMappingDialog:输入两组字符串的映射<br>PreviewRowsDialog:在对话框里预览一组数据行。<br>SQLEditor:一个简单的SQL编辑器，可以输入查询和DDL.<br>ErrorDialog:显示异常信息，列出详细的错误栈对话框  </p>\n<h4 id=\"Hello-World例子对话框\"><a href=\"#Hello-World例子对话框\" class=\"headerlink\" title=\"####Hello World例子对话框\"></a>####Hello World例子对话框</h4><p>现在我们已经基本了解了SWT以及对话框的布局方式，再看看我们的例子，下面的代码是HelloWorldStepDialog.java里的例子。<br>代码的第一部分是初始化元数据对象以及步骤对话框的父类：<br>    public class HelloworldStepDialog extends BaseStepDialog implements<br>            StepDialogInterface {<br>        private static Class&lt;?&gt; PKG = HelloworldStepMeta.class;<br>        private HelloworldStepMeta input;<br>        private TextVar wFieldname;<br>        public HelloworldStepDialog(Shell parent, Object baseStepMeta,<br>                TransMeta transMeta, String stepname) {<br>            //初始化元数据对象以及步骤对话框的父类<br>            super(parent, (BaseStepMeta) baseStepMeta, transMeta, stepname);<br>            input = (HelloworldStepMeta) baseStepMeta;<br>        }<br>在下面的open()方法里创建对话框里的所有控件。SWT使用事件监听模式，可以为控件创建各种监听方法，以响应控件内容的变化和用户的动作。<br>    public String open() {<br>            Shell parent = getParent();<br>            Display display = parent.getDisplay();<br>            shell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MIN<br>                    | SWT.MAX);<br>            props.setLook(shell);<br>            setShellImage(shell, input);<br>            ModifyListener lsMod = new ModifyListener() {<br>                public void modifyText(ModifyEvent e) {<br>                    input.setChanged();<br>                }<br>            };<br>            changed = input.hasChanged();</p>\n<p>下面代码说明窗体里的控件将使用formLayout的布局方式：<br>    FormLayout formLayout = new FormLayout();<br>            formLayout.marginWidth = Const.FORM_MARGIN;<br>            formLayout.marginHeight = Const.FORM_MARGIN;<br>            shell.setLayout(formLayout);<br>所有控件的右侧使用一个自定义的百分比对齐：props.getMiddlePct()；控件之间的间距使用一个常量，常量值是4像素。<br>    shell.setLayout(formLayout);<br>            shell.setText(BaseMessages.getString(PKG,<br>                    “HelloworldDialog.Shell.Title”)); //$NON-NLS-1$<br>            int middle = props.getMiddlePct();<br>            int margin = Const.MARGIN;<br>下面的代码在对话框的最上面添加了一行步骤名称标签和输入文本框：<br>    // Stepname line<br>            wlStepname = new Label(shell, SWT.RIGHT);<br>            wlStepname.setText(BaseMessages.getString(PKG,<br>                    “HelloworldDialog.Stepname.Label”)); //$NON-NLS-1$<br>            props.setLook(wlStepname);<br>            fdlStepname = new FormData();<br>            fdlStepname.left = new FormAttachment(0, 0);<br>            fdlStepname.right = new FormAttachment(middle, -margin);<br>            fdlStepname.top = new FormAttachment(0, margin);<br>            wlStepname.setLayoutData(fdlStepname);<br>            wStepname = new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);<br>            wStepname.setText(stepname);<br>            props.setLook(wStepname);<br>            wStepname.addModifyListener(lsMod);<br>            fdStepname = new FormData();<br>            fdStepname.left = new FormAttachment(middle, 0);<br>            fdStepname.top = new FormAttachment(0, margin);<br>            fdStepname.right = new FormAttachment(100, 0);<br>            wStepname.setLayoutData(fdStepname);<br>            Control lastControl = wStepname;</p>\n<p>下面是新增输出列的列名设置的输入框：<br>    // Fieldname line<br>        //创建一个新的标签控件，控件里文本靠右对齐<br>        Label wlFieldname = new Label(shell, SWT.RIGHT);<br>        wlFieldname.setText(BaseMessages.getString(PKG,<br>                “HelloworldDialog.Fieldname.Label”)); //$NON-NLS-1$<br>        //下面一行为控件设置用户定义的背景色和字体<br>        props.setLook(wlFieldname);<br>        FormData fdlFieldname = new FormData();<br>        fdlFieldname.left = new FormAttachment(0, 0);<br>        fdlFieldname.right = new FormAttachment(middle, -margin);<br>        fdlFieldname.top = new FormAttachment(lastControl, margin);<br>        wlFieldname.setLayoutData(fdlFieldname);<br>        wFieldname = new TextVar(transMeta, shell, SWT.SINGLE | SWT.LEFT<br>                | SWT.BORDER);<br>        props.setLook(wFieldname);<br>        wFieldname.addModifyListener(lsMod);<br>        FormData fdFieldname = new FormData();<br>        fdFieldname.left = new FormAttachment(middle, 0);<br>        fdFieldname.top = new FormAttachment(lastControl, margin);<br>        fdFieldname.right = new FormAttachment(100, 0);<br>        wFieldname.setLayoutData(fdFieldname);<br>        lastControl = wFieldname;</p>\n<p>然后创建两个按钮，“确认”和“取消”按钮，以及按钮单击事件的监听方法，把按钮放在对话框的最下面：<br>    // Some buttons<br>        wOK = new Button(shell, SWT.PUSH);<br>        wOK.setText(BaseMessages.getString(PKG, “System.Button.OK”)); //$NON-NLS-1$<br>        wCancel = new Button(shell, SWT.PUSH);<br>        wCancel.setText(BaseMessages.getString(PKG, “System.Button.Cancel”)); //$NON-NLS-1$</p>\n<pre><code>setButtonPositions(new Button[] { wOK, wCancel }, margin, lastControl);\n\n// Add listeners\nlsCancel = new Listener() {\n    public void handleEvent(Event e) {\n        cancel();\n    }\n};\nlsOK = new Listener() {\n    public void handleEvent(Event e) {\n        ok();\n    }\n};\nwCancel.addListener(SWT.Selection, lsCancel);\nwOK.addListener(SWT.Selection, lsOK);\n</code></pre><p>下面的代码做了两件事情，上部代码可以保证当步骤名称或输出字段名称的输入框在编辑状态时，单击“确定”按钮，正在编辑的内容不会丢失；下部的代码保证了窗口在非正常关闭时（没有使用“确定”或“取消”按钮关闭），取消用户的编辑。<br>    lsDef = new SelectionAdapter() {<br>            public void widgetDefaultSelected(SelectionEvent e) {<br>                ok();<br>            }<br>        };</p>\n<pre><code>wStepname.addSelectionListener(lsDef);\nwFieldname.addSelectionListener(lsDef);\n\n// Detect X or ALT-F4 or something that kills this window...\nshell.addShellListener(new ShellAdapter() {//保证了窗口在非正常关闭时，取消用户的编辑\n    public void shellClosed(ShellEvent e) {\n        cancel();\n    }\n});\n</code></pre><p>下面的代码把数据从步骤的元数据对象里复制到窗口的控件里：<br>    // Populate the data of the controls<br>            getData();<br>窗口的大小和位置将根据窗口的自然属性、上次窗口大小和位置，以及显示屏的大小自动设置。<br>    // Set the shell size, based upon previous time…<br>            //窗口的大小和位置将根据窗口的自然属性、上次窗口大小和位置，以及显示屏的大小自动设置<br>            setSize();<br>            input.setChanged(changed);</p>\n<pre><code>    shell.open();\n    while (!shell.isDisposed()) {\n        if (!display.readAndDispatch())\n            display.sleep();\n    }\n    return stepname;\n}\n</code></pre><p>为了防止用户身控件里输入空值，Kettle提供了一个静态方法来检查空值，ConstNVL();<br>    /**</p>\n<pre><code> * Copy information from the meta-data input to the dialog fields.\n */\npublic void getData() {\n    wStepname.selectAll();\n    wFieldname.setText(Const.NVL(input.getFieldName(), &quot;&quot;));\n}\n</code></pre><p>最后，单击OK按钮后，把控件里用户输入的数据都写入到步骤的元数据对象中：<br>    private void cancel() {<br>            stepname = null;<br>            input.setChanged(changed);<br>            dispose();<br>        }<br>        //单击OK把控件里用户输入的数据都写入到步骤的元数据对象中。<br>        private void ok() {<br>            if (Const.isEmpty(wStepname.getText()))<br>                return;</p>\n<pre><code>    stepname = wStepname.getText(); // return value\n\n    input.setFieldName(wFieldname.getText());\n\n    dispose();\n}\n</code></pre><h3 id=\"StepInteface\"><a href=\"#StepInteface\" class=\"headerlink\" title=\"###StepInteface\"></a>###StepInteface</h3><pre><code>这个类实现了org.pentaho.di.trans.step.StepInterface接口，这个类读取上个步骤传来的数据行，利用StepMetaInterface对象里定义的元数据，逐行转换和处理上个步骤传来的数据行，Kettle引擎直接使用这个接口里的很多方法来执行转换过程，但大部分方法都已经由BaseStep类实现了，通常开发人员只需要重载其中的几个方法。\nInit():步骤初始化方法，用来初始化一个步骤。初始化结果是一个true或者false的Boolean值。如果你的步骤没有任何初始化的工作，可以不用重载这个方法。\nDispose():如果有需要释放的资源，可以在dispose()方法里释放，例如可以关闭数据库连接、释放文件、清除缓存等。在转换的最后Kettle引擎会调用这个方法。如果没有需要释放或清除的资源，可以不用重载这个方法。\nprocessRow():这个方法，是步骤实现工作的地方。只要这个方法返回true，转换引擎就会重复调用这个方法。\n</code></pre><p>下面是HellWorld例子实现的StepInterface接口（HelloworldStep.java）</p>\n<p>HelloworldStep.java<br>    package org.kettlesolutions.plugin.step.helloworld;</p>\n<pre><code>import org.pentaho.di.core.exception.KettleException;\nimport org.pentaho.di.core.row.RowDataUtil;\nimport org.pentaho.di.trans.Trans;\nimport org.pentaho.di.trans.TransMeta;\nimport org.pentaho.di.trans.step.BaseStep;\nimport org.pentaho.di.trans.step.StepDataInterface;\nimport org.pentaho.di.trans.step.StepInterface;\nimport org.pentaho.di.trans.step.StepMeta;\nimport org.pentaho.di.trans.step.StepMetaInterface;\n/**\n * BaseStep抽象类已经实现了接口里的很多方法，我们只要覆盖需要修改的方法即可。\n * @author Administrator\n *\n */\npublic class HelloworldStep extends BaseStep implements StepInterface {\n    /**\n     * 类的构造函数通常直接把参数传递给BaseStep父类。由父类里的方法来构造对象，然后可以直接\n     * 使用类似transMeta这样的对象。\n     * @param stepMeta\n     * @param stepDataInterface\n     * @param copyNr\n     * @param transMeta\n     * @param trans\n     */\n    public HelloworldStep(StepMeta stepMeta, StepDataInterface stepDataInterface,\n            int copyNr, TransMeta transMeta, Trans trans) {\n        super(stepMeta, stepDataInterface, copyNr, transMeta, trans);\n        // TODO Auto-generated constructor stub\n    }\n\n\n    public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException {\n\n        HelloworldStepMeta meta  = (HelloworldStepMeta) smi;\n        HelloworldStepData data = (HelloworldStepData) sdi;\n        /**\n         * getRow()方法从上一个步骤获取一行数据。如果没有更多要获取的数据行，这个方法就会返回null。\n         * 如果前面的步骤不能及时提供数据，这个方法就会阻塞，直到有可用的数据行。这样这个步骤的速度就会降低，也会影响\n         * 其它步骤的速度。\n         */\n        Object[] row = getRow();\n        if (row==null) {\n            /**\n             * setOutputDone()方法用来通知其它的步骤，本步骤已经没有输出数据行。下一个步骤如果\n             * 再调用getRow()方法就会返回null,转换也不再调用processRow()方法。\n             */\n            setOutputDone();\n            return false;\n        }\n\n        if (first) {\n            first=false;\n            /**\n             * 从性能上考虑，getRow()方法不提供数据行的元数据，只提供上个步骤输出的数据。可以使用getInputRowMeta()方法\n            获取元数据，元数据只获取一次即可，所以在first代码块里获取元数据。\n               如果要把数据传到下一个步骤，要使用putRow()方法。除了输出数据，还要输出RowMetaInterface元数据。\n               第一行使用clone()方法把输入行的元数据结构复制给输出行。输出行的元数据结构是在输入行的基础上增加一个字段，但\n               构造输出行的元数据结构只能构造一次，因为所有输出数据行的结构都是一样的，产生了输出行以后，元数据结构就不能再变化。\n               所以输出行的元数据结构在first代码块里构造。first是一个内部成员，first代码块里的代码只在处理第一行数据时执行。\n               下面代码的最后一行，给输出数据增加了一个字段。\n             */\n            data.outputRowMeta = getInputRowMeta().clone();\n            meta.getFields(data.outputRowMeta, getStepname(), null, null, this);\n        }\n        /**\n         * 下面的代码，把数据写入输出流。从性能角度考虑，数据行实现就是Java数组。为了开发方便，可以使用RowDataUtil类提供\n         * 的一些静态方法来操作数据。使用RowDatautil静态方法复制数据，还可以提高性能。\n         */\n        String value = &quot;Hello, world!&quot;;\n\n        Object[] outputRow = RowDataUtil.addValueData(row, getInputRowMeta().size(), value);\n\n        putRow(data.outputRowMeta, outputRow);\n\n        return true;\n    }\n}\n</code></pre><p>解析：<br>public class HelloworldStep extends BaseStep implements StepInterface {<br>BaseStep抽象类已经实现了接口里的很多方法，我们只要覆盖需要修改的方法即可。<br>类的构造函数通常直接把参数传递给BaseStep父类。由父类里的方法来构造对象，然后可以直接使用类似transMeta这样的对象。<br>public HelloworldStep(StepMeta stepMeta, StepDataInterface stepDataInterface,<br>            int copyNr, TransMeta transMeta, Trans trans) {<br>        super(stepMeta, stepDataInterface, copyNr, transMeta, trans);<br>    }<br>getRow()方法从上一个步骤获取一行数据。如果没有更多要获取的数据行，这个方法就会返回null。如果前面的步骤不能及时提供数据，这个方法就会阻塞，直到有可用的数据行。这样这个步骤的速度就会降低，也会影响其它步骤的速度。<br>public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException {<br>        HelloworldStepMeta meta  = (HelloworldStepMeta) smi;<br>        HelloworldStepData data = (HelloworldStepData) sdi;<br>        Object[] row = getRow();<br>        if (row==null) {<br>            setOutputDone();<br>            return false;<br>        }</p>\n<pre><code>    if (first) {\n        first=false;\n        data.outputRowMeta = getInputRowMeta().clone();\n        meta.getFields(data.outputRowMeta, getStepname(), null, null, this);\n    }\n    String value = &quot;Hello, world!&quot;;\n    Object[] outputRow = RowDataUtil.addValueData(row, getInputRowMeta().size(), value);\n\n    putRow(data.outputRowMeta, outputRow);\n\n    return true;\n}\n</code></pre><p>从性能上考虑，getRow()方法不提供数据行的元数据，只提供上个步骤输出的数据。可以使用getInputRowMeta()方法获取元数据，元数据只获取一次即可，所以在first代码块里获取元数据。<br>setOutputDone()方法用来通知其它的步骤，本步骤已经没有输出数据行。下一个步骤如果再调用getRow()方法就会返回null,转换也不再调用processRow()方法。</p>\n<pre><code>Object[] row = getRow();\n        if (row==null) {\n            setOutputDone();\n            return false;\n        }\n</code></pre><p>   如果要把数据传到下一个步骤，要使用putRow()方法。除了输出数据，还要输出RowMetaInterface元数据。<br>    data.outputRowMeta = getInputRowMeta().clone();<br>    meta.getFields(data.outputRowMeta, getStepname(), null, null, this);<br>第一行使用clone()方法把输入行的元数据结构复制给输出行。输出行的元数据结构是在输入行的基础上增加一个字段，但构造输出行的元数据结构只能构造一次，因为所有输出数据行的结构都是一样的，产生了输出行以后，元数据结构就不能再变化。所以输出行的元数据结构在first代码块里构造。first是一个内部成员，first代码块里的代码只在处理第一行数据时执行。下面代码的最后一行，给输出数据增加了一个字段。</p>\n<p>下面的代码，把数据写入输出流。<br>        String value = “Hello, world!”;<br>        Object[] outputRow = RowDataUtil.addValueData(row, getInputRowMeta().size(), value);<br>        putRow(data.outputRowMeta, outputRow);<br>从性能角度考虑，数据行实现就是Java数组。为了开发方便，可以使用RowDataUtil类提供的一些静态方法来操作数据。使用RowDatautil静态方法复制数据，还可以提高性能。<br>从指定的步骤读取数据行<br>如果你想从前面的某个指定的步骤读取数据行，例如”流查询“步骤，可以使用getRowFrom()方法。<br>       RowSet rowSet = findInputRowSet(Source Step Name);<br>       Object[] rowData = getRowFrom(rowSet);<br>           还可以通过rowSet对象获得数据行的元数据：<br>       RowMetaInterface rowMeta = rowSet.getRowMeta();<br>把数据行写入指定的步骤<br>如果想把数据写入到某个特定的步骤，例如”过滤“步骤，可以使用putRowTo()方法<br>      RowSet rowSet = findOutputRowSet(Target Step Name);<br>      ….<br>      putRowTo(outputRowMeta,rowData,rowSet);<br>很明显，输入和输出的RowSet对象只需获得一次即可，这样才更有效率。<br>把数据行写入到错误处理步骤<br>如果想让你的步骤支持错误处理，而且元数据类返回的supportErrorHandling()方法返回了true，就可以把数据输出<br>      到错误处理步骤里。下面是使用putError()方法的例子：<br>      Object[] rowData = getRow();<br>      …<br>      try{<br>          …<br>          putRow(…);<br>      }catch(Exception e){<br>          if(getStepMeta().isDoingErrorHandling()){<br>              putError(getInputRowMeta(),rowData,errorCode);<br>          }else{<br>              throw(e);<br>          }<br>      }<br>      从例子里可以看到，这段代码把错误的行数、错误字段名、消息、错误编码都传递给错误处理步骤。<br>      错误处理的其他工作都自动完成了。</p>\n<h4 id=\"识别一个步骤拷贝\"><a href=\"#识别一个步骤拷贝\" class=\"headerlink\" title=\"####识别一个步骤拷贝\"></a>####识别一个步骤拷贝</h4><p>因为一个步骤可以有多份拷贝同时执行，有时需要识别出正在使用的是哪个步骤拷贝，可以用下面几个方法。<br>     getCopy():获得拷贝号。拷贝号可以唯一标识出步骤的一个拷贝，拷贝号的聚会范围是0-N，N=getStepMeta().getCopies()-1<br>     getUniqueStepNrAcrossSlaves():获得在集群模式下运行的步骤拷贝号。<br>     getUniqueStepCountAcrossSlaves():获得在集群模式下运行的步骤拷贝总数。<br>     通过这些方法可以把一个步骤的工作分配给多份拷贝去完成。例如”CSV文件输入“和”固定文件输入“步骤里都有并行读取文件的选项，这样可以把读取文件的工作放在多个拷贝里或集群里来完成。</p>\n<h4 id=\"结果反馈\"><a href=\"#结果反馈\" class=\"headerlink\" title=\"####结果反馈\"></a>####结果反馈</h4><p>在调用getRow()和putRow()方法时，引擎会自动计算两类度量值，读行数和写行数。这两类度量值可以在界面或日志中记录下来，以监控程序运行的状态。下面几个方法用来操作这两类度量值。<br>    incrementLinesRead():增加从前面步骤读取到的行数。<br>    incrementLinesWritten():增加定稿到后面步骤中的行数。<br>    incrementLinesInput():增加从文件、数据库、网络等资源读取到的行数<br>    incrementLinesOutput:增加写入到文件、数据库、网络等资源的行数。<br>    incrementLinesUpdate():增加更新的行数。<br>    incrementLinesSkipped()：增加跳过的数据行的行数。<br>    incrementLinesRejected():增加拒绝的数据行的行数。<br>    这些度量值用来说明步骤执行的情况。可以在Spoon的转换度量面板里看到，也可以存到日志数据库表里。<br>    使用addResultFile()方法，可以把步骤用到的文件保留下来，保存到结果文件列表里。结果文件列表可以被其它转换或作业项使用。例如，下面的”CSV文件输入“的代码：<br>ResultFile resultFile = new ResultFile(<br>    ResultFile.FILE_TYPE_GENERAL,<br>    fileObject,<br>getTransMeta().getName(),<br>getStepName()<br>);<br>resultFile.setComment(“File was read by a Csv Input step”);<br>addREsultFile(resultFile);</p>\n<h4 id=\"变量替换\"><a href=\"#变量替换\" class=\"headerlink\" title=\"####变量替换\"></a>####变量替换</h4><pre><code>如果输入框需要支持变量，可以使用environmentSubstritute()方法获取变量。例如，若想在“Hello World”例子的字段名输入框里使用变量，就要把StepMetaInterface里的getFields()方法修改成下面的语句：\n</code></pre><p>String realFiledName = apace. environmentSubstritute(fieldName)；<br>因为步骤本身是一个VariableSpace对象，所以也可以使用下面的语句做变量替换：String value = environmentSubstritute(meta.getSringWithVariables());</p>\n<h4 id=\"Apache-VFS\"><a href=\"#Apache-VFS\" class=\"headerlink\" title=\"####Apache VFS\"></a>####Apache VFS</h4><p>Kettle里所有操作文件的步骤，都使用Apache VFS系统的方式操作。Apache VFS不但可以从文件系统读取文件（如java.io.File），还可以从很多其他来源读取文件，如FTP服务器、Z学压缩文件，等 等 。<br>Apache VFS里的FileObject对象提供了文件的抽象层，然后在Kettle的KettleVFS类里还提供了一系列的静态方法，来更方便使用FileObject对象，例如下面的代码 ：  </p>\n<pre><code>FileObject fileObject = KettleVFS.getFileObject(“zip:http://www.example.com/archive.zip!file.txt”);\n</code></pre><p><code>String value = environmentSubstritute(meta.getSringWithVariables());</code></p>\n<p>应该尽可能多地使用KettleVFS,因为它解决了或饶过了很多Apache VFS目前已知的问题。它也增强了SFTP协议。</p>\n<h4 id=\"步骤插件部署\"><a href=\"#步骤插件部署\" class=\"headerlink\" title=\"####步骤插件部署\"></a>####步骤插件部署</h4><p>部署之前，要把四个Java源代码文件编译为class文件。把编译好的class文件放到一个Jar包里。可以使用IDE来做这些事情，也可以手工使用ant脚本来做这些事情。<br>.jar文件应该放在Kettle的plugins/steps目录下。也可以使用一个子目录，把所有的依赖的jar包放在插件jar包所在目录的/lib目录下，不必再放Kettle的类路径中（Kettle的libext/目录）已经有了的jar包。另外可以把多个插件放在一个jar包里。<br>如果想在IDE里调试插件，可以把插件元数据类的名字放在Kettle_PLUGIN_CLASSES变量里（一个逗号分隔的列表）。关于这个主题的更多信息，请参考pentaho Wiki:<a href=\"http://wiki.pentaho.com/display/EAI/How+to+debug+a+Kettle+4+plugin\" target=\"_blank\" rel=\"noopener\">http://wiki.pentaho.com/display/EAI/How+to+debug+a+Kettle+4+plugin</a> 。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Kettle插件体系\"><a href=\"#Kettle插件体系\" class=\"headerlink\" title=\"#Kettle插件体系\"></a>#Kettle插件体系</h1><p>最近公司内有业务系统到数据中心同步的升级改造需求，从各个业务系统收集增量数据到数据中心的数据仓库平台。因为开发周期短暂，需要快速的响应，开发出可用的产品，所以决定借鉴开源程序Kettle，开发一个文件解析组件，然后利用Kettle平台的大数据组件进行与数据中心大数据平台对接</p>\n<p>数据同步部分是：业务系统（RDBMS）-&gt;Kettle(azkaban进行调度)-&gt;数据中心，因为Kettle的增量抽取组件经常出现数据不一致等问题，所以目前已更改为：业务系统（RDBMS）-&gt;OGG（CDC增量抽取）-&gt;数据中心的方式。</p>\n<p>本文主要介绍如何扩展Kettle的功能，部分内容来自《Pentaho Kettle解决方案：使用PDI构建开源ETL解决方案》一书，推荐购买阅读。</p>\n<h2 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"##架构\"></a>##架构</h2><p>我们先看Kettle插件架构。<br> <img src=\"http://i.imgur.com/mLvXMuV.jpg\" alt=\"\"><br>从功能上看，Kettle内部的对象和外部插件没有任何区别。因为它们使用的API都是一样的，它们只是在运行时的加载方式不同。<br>从Kettle4以后，Kettle内部有一个插件注册系统，它负责加载各种内部和外部插件。插件有以下两个标识属性。<br><strong>插件类型</strong>：由PluginTypeInterface接口定义。例如StepPluginType、JobEntryPluginType、PartitionerPluginType和RepositoryPluginType。<br><strong>插件ID</strong>：这是一个字符串数组，用来唯一标识一个插件。因为旧的插件可以被新的插件代替，一个插件可以有多个ID。在大多数情况下，插件只使用一个单一的字符串，如TableInput是“表输入”步骤的ID，MYSQL是MySQL数据库类型的ID。<br>当Kettle环境初始化以后，插件注册系统首先加载所有的内部对象，Kettle读取下面的配置文件来加载内部对象，这些配置文件位于Kettle的.jar文件中。<br>     Kettle-steps.xml：内部转换步骤。<br>     Kettle-job-entries.xml：内部作业项。<br>     Kettle-partition-plugins.xml：内部分区类型。<br>     Kettle-database-types.xml：内部数据库类型。<br>     Kettle-repositories.xml：内部资源库类型。</p>\n<p>插件注册系统加载了所有的内部对象后，就要搜索可用的外部插件。通过浏览plugins/目录的各个子目录下的.jar文件来完成。它搜索特定的Kettle annotations来判断一个类是否是插件。加载过程将在本章的后面介绍。<br>因为在内部对象加载后才加载插件，所以插件会替代相同ID的已加载的内部对象。例如，你创建了插件，插件的ID是TableInput，就可以替换Kettle标准的“表输入”步骤。这个功能可以让你用插件替换Kettle内置的步骤。可以通过子类继承方式，直接扩展已有步骤的某些功能。</p>\n<h2 id=\"插件类型\"><a href=\"#插件类型\" class=\"headerlink\" title=\"##插件类型\"></a>##插件类型</h2><p>Kettle有下面几种插件类型（下面的插件是Kettle4.0的插件类型，新版kettle包含了很多新的插件，比如视图插件、大数据插件等等）。</p>\n<ul>\n<li>转换步骤插件：在Kettle转换中使用的步骤，用来处理数据行。</li>\n</ul>\n<ul>\n<li>作业项插件：在Kettle作业中使用的作业项，用来实现某个任务。</li>\n</ul>\n<ul>\n<li>分区方法插件：利用输入字段的值指定自己的分区规则。</li>\n</ul>\n<ul>\n<li>数据库类型插件：用来扩展不同的数据库类型。</li>\n</ul>\n<ul>\n<li>资源库类型插件：可以把Kettle元数据保存为自定义类型或格式。</li>\n</ul>\n<p>说明：除了这些类型，还有Spoon类型的插件，可以把功能扩展到Spoon，本书不介绍这个功能。</p>\n<h2 id=\"转换步骤插件\"><a href=\"#转换步骤插件\" class=\"headerlink\" title=\"##转换步骤插件\"></a>##转换步骤插件</h2><p>转换步骤插件包括了四个Java类，这四个类分别实现四个接口。</p>\n<ul>\n<li>StepMetaInterface：这个接口对外 提供步骤的元数据并处理串行化。</li>\n</ul>\n<ul>\n<li>StepInterface:这个接口根据上面接口提供的元数据，来实现步骤的具体功能。</li>\n</ul>\n<ul>\n<li>StepDataInterface:这个接口用来存储步骤的临时数据、文件句柄等。</li>\n</ul>\n<ul>\n<li>StepDialogInterface:这个接口是Spoon里的图形界面，用来编辑步骤的元数据。</li>\n</ul>\n<p>接下来，我们介绍这些接口的基本内容。对于每个接口，在一个简单的“Hello World”例子里提供这些类的相应实现。“Hello World”例子将在数据流里增加一个字段，字段名用户可以自定义，字段值是”Hello world!“。最后介绍一下如何部署这个例子。</p>\n<h3 id=\"StepMetaInterface\"><a href=\"#StepMetaInterface\" class=\"headerlink\" title=\"###StepMetaInterface\"></a>###StepMetaInterface</h3><p>接口org.pentaho.di.trans.step.StepMetaInterface负责步骤里所有和元数据相关的任务。和元数据相关的工作包括：<br>元数据和XML(或资源库)之间的序列化和反序列化<br>getXML（）和loadXML()<br>saveRep()和readRep()  </p>\n<p>描述输出字段<br>getFields()  </p>\n<p>检验元数据是否正确<br>Check()  </p>\n<p>获取步骤相应的要SQL语句，使步骤可以正确运行<br>getSQLStatements()  </p>\n<p>给元数据设置默认值<br>setDefault()  </p>\n<p>完成对数据库的影响分析<br>analyseImpact()  </p>\n<p>描述各类输入和输出流<br>getStepIOMeta()<br>searchInfoAndTargetSteps()<br>handleStreamSelection()<br>getOptionalStreams()<br>resetStepIoMeta()  </p>\n<p>导出元数据资源<br>exportResources()<br>getResourceDependencies()  </p>\n<p>描述使用的库<br>getUsedLibraries()  </p>\n<p>描述使用的数据库连接<br>getUsedDatabaseConnections()  </p>\n<p>描述这个步骤需要的字段（通常是一个数据库表）<br>getRequiredFields()  </p>\n<p>描述步骤是否具有某些功能<br>supportsErrorHandling()<br>excludeFromRowLayoutVerification()<br>excludeFromCopyDistributeVerification()  </p>\n<p>这个接口里还定义了几个方法来说明这四个接口如何结合到一起。<br>String getDialogClassName():用来描述实现了StepDialogInterface接口的对话框类的名字。如果这个方法返回了null，调用类会根据实现了StepMetaInterface接口的类的类名和包名来自动生成对话框类的名字。<br>SetpInterface getStep():创建一个实现了StepInterface接口的类。<br>StepDataInterface getStepData():创建一个实现了StepDataInterface接口的类。<br>现在我们看看”Hello World”例子里对SetpMetaInterface接口的实现<br>HelloworldStepMeta.java<br>    package org.kettlesolutions.plugin.step.helloworld;</p>\n<pre><code>import java.util.List;\nimport java.util.Map;\n\nimport org.pentaho.di.core.CheckResult;\nimport org.pentaho.di.core.CheckResultInterface;\nimport org.pentaho.di.core.Const;\nimport org.pentaho.di.core.Counter;\nimport org.pentaho.di.core.annotations.Step;\nimport org.pentaho.di.core.database.DatabaseMeta;\nimport org.pentaho.di.core.exception.KettleException;\nimport org.pentaho.di.core.exception.KettleStepException;\nimport org.pentaho.di.core.exception.KettleXMLException;\nimport org.pentaho.di.core.row.RowMetaInterface;\nimport org.pentaho.di.core.row.ValueMeta;\nimport org.pentaho.di.core.row.ValueMetaInterface;\nimport org.pentaho.di.core.variables.VariableSpace;\nimport org.pentaho.di.core.xml.XMLHandler;\nimport org.pentaho.di.i18n.BaseMessages;\nimport org.pentaho.di.repository.ObjectId;\nimport org.pentaho.di.repository.Repository;\nimport org.pentaho.di.trans.Trans;\nimport org.pentaho.di.trans.TransMeta;\nimport org.pentaho.di.trans.step.BaseStepMeta;\nimport org.pentaho.di.trans.step.StepDataInterface;\nimport org.pentaho.di.trans.step.StepInterface;\nimport org.pentaho.di.trans.step.StepMeta;\nimport org.pentaho.di.trans.step.StepMetaInterface;\nimport org.w3c.dom.Node;\n\n@Step(\n        id=&quot;Helloworld&quot;,\n        name=&quot;name&quot;,\n        description=&quot;description&quot;,\n        categoryDescription=&quot;categoryDescription&quot;, \n        image=&quot;org/kettlesolutions/plugin/step/helloworld/HelloWorld.png&quot;,\n        i18nPackageName=&quot;org.kettlesolutions.plugin.step.helloworld&quot;\n) \npublic class HelloworldStepMeta extends BaseStepMeta implements StepMetaInterface {\n    /**\n     * PKG变量说明了messages包的位置，在messages包里有各种国际化的资源文件。\n     * 在本章后面经常要看到的BaseMessages.getString()方法，就是根据软件的国际化\n     * 设置，从不同的文件中获取文字。PKG变量通常位于类的最上方，被国际化图形工具使用，\n     * 通过国际化图形工具，国际化人员可以编辑不同的国际化资源文件。所以我们会在很多Kettle\n     * 代码里看见这样的结构。\n     */\n    private static Class&lt;?&gt; PKG = HelloworldStep.class; //for i18n\n    public enum Tag {//field_name用于保存用户输入的字段名：保存“Hello，world！&quot;字符串的字段名。\n        field_name,\n    };\n\n    private String fieldName;\n\n    /**\n     * @return the fieldName\n     */\n    public String getFieldName() {\n        return fieldName;\n    }\n\n    /**\n     * @param fieldName the fieldName to set\n     */\n    public void setFieldName(String fieldName) {\n        this.fieldName = fieldName;\n    }\n\n    /**\n     * checks parameters, adds result to List&lt;CheckResultInterface&gt;\n     * used in Action &gt; Verify transformation\n     * 验证用户是否在对话框里输入了字段名，并把验证结果添加到检验转换时出现的问题列表里。（最好\n     * 要检验用户输入的所有选项，而不只是容易出错的选项）\n     */\n    public void check(List&lt;CheckResultInterface&gt; remarks, TransMeta transMeta, StepMeta stepMeta, \n            RowMetaInterface prev, String input[], String output[], RowMetaInterface info) {\n\n        if (Const.isEmpty(fieldName)) {\n            CheckResultInterface error = new CheckResult(\n                CheckResult.TYPE_RESULT_ERROR, \n                BaseMessages.getString(PKG, &quot;HelloworldMeta.CHECK_ERR_NO_FIELD&quot;), \n                stepMeta\n            );\n            remarks.add(error);\n        } else {\n            CheckResultInterface ok = new CheckResult(\n                CheckResult.TYPE_RESULT_OK, \n                BaseMessages.getString(PKG, &quot;HelloworldMeta.CHECK_OK_FIELD&quot;), \n                stepMeta\n            );\n            remarks.add(ok);//把验证结果添加到检验转换时出现的问题列表里。\n        }\n    }\n\n    /**\n     *    creates a new instance of the step (factory)\n     * getStep、getStepData和getDialogClassName()方法提供了与这个步骤里其它三个接口之间的桥梁\n     这个接口里还定义了几个方法来说明这四个接口如何结合到一起。\n    String getDialogClassName():用来描述实现了StepDialogInterace接口的对话框类的名字。如果这个方法返回\n                了null，调用类会根据实现了StepMetaInterface接口的类的类名和包名来自动生成对话框类的名字。\n    StepInterface getStep():创建一个实现了StepInterface接口的类。\n    StepInterface getStepData():创建一个实现了StepDataInterface接口的类。\n\n     */\n    public StepInterface getStep(StepMeta stepMeta, StepDataInterface stepDataInterface,\n            int copyNr, TransMeta transMeta, Trans trans) {\n        return new HelloworldStep(stepMeta, stepDataInterface, copyNr, transMeta, trans);\n    }\n\n    /**\n     * creates new instance of the step data (factory)\n     * getStep、getStepData和getDialogClassName()方法提供了与这个步骤里其它三个接口之间的桥梁\n     */\n    public StepDataInterface getStepData() {\n        return new HelloworldStepData();\n    }\n    /**\n     * getStep、getStepData和getDialogClassName()方法提供了与这个步骤里其它三个接口之间的桥梁\n     */\n    @Override\n    public String getDialogClassName() {\n        return HelloworldStepDialog.class.getName();\n    }\n\n    /**\n     * deserialize from xml \n     * databases = list of available connections\n     * counters = list of sequence steps\n     * \n     * 下面的四个方法loadXML()、getXML()、readRep()和saveRep()把元数据保存到XML文件或资源库里，\n     * 或者从XML文件或资源库读取元数据。保存到文件的方法利用了像XStream（http://xstream.codehaus.org）这\n     * 样的XML串行化技术。\n     */\n    public void loadXML(Node stepDomNode, List&lt;DatabaseMeta&gt; databases,\n            Map&lt;String, Counter&gt; sequenceCounters) throws KettleXMLException {\n        fieldName = XMLHandler.getTagValue(stepDomNode, Tag.field_name.name());\n    }\n\n    /**\n     * @Override\n     */\n    public String getXML() throws KettleException {\n        StringBuilder xml = new StringBuilder();\n        xml.append(XMLHandler.addTagValue(Tag.field_name.name(), fieldName));\n        return xml.toString();\n    }\n\n    /**\n     * De-serialize from repository (see loadXML)\n     */\n    public void readRep(Repository repository, ObjectId stepIdInRepository,\n            List&lt;DatabaseMeta&gt; databases, Map&lt;String, Counter&gt; sequenceCounters)\n            throws KettleException {\n        fieldName = repository.getStepAttributeString(stepIdInRepository, Tag.field_name.name());\n    }\n\n    /**\n     * serialize to repository\n     */\n    public void saveRep(Repository repository, ObjectId idOfTransformation, ObjectId idOfStep)\n            throws KettleException {\n        repository.saveStepAttribute(idOfTransformation, idOfStep, Tag.field_name.name(), fieldName);\n    }\n\n\n    /**\n     * initiailize parameters to default\n     */\n    public void setDefault() {\n        fieldName = &quot;helloField&quot;;\n    }\n\n    /**\n     * getFields()方法非常重要，因为它描述了输出数据行的结构。这个方法需要修改inputRowMeta对象，使这个对象和\n     * 输出格式匹配。Spoon和后面的步骤都需要知道这个步骤要输出哪些字段。最常见的一种方法，可以给输出的RowMetaInterface对象\n     * 添加一个ValueMetaInterface对象。在ValueMetaInterface对象里设置的信息越详细越好，可以设置的信息包括数据类型、长度、\n     * 精度、格式掩码，等等。添加的字段描述元信息越多，后面生成的SQL就越准确。\n     */\n    @Override\n    public void getFields(RowMetaInterface inputRowMeta, String name,\n            RowMetaInterface[] info, StepMeta nextStep, VariableSpace space)\n            throws KettleStepException {\n        String realFieldName = space.environmentSubstitute(fieldName);\n        //值的元数据使用ValueMetaInterface接口描述数据流里的一个字段。这个接口里定义了字段的名字、数据类型、长度、精度，等等。下面的例子用于创建一个ValueMetaInterface对象。\n        ValueMetaInterface field = new ValueMeta(realFieldName, ValueMetaInterface.TYPE_STRING);\n        field.setOrigin(name);        \n        inputRowMeta.addValueMeta(field);\n    }\n}\n</code></pre><p>代码解析<br>    @Step(<br>            id=”Helloworld”,<br>            name=”name”,<br>            description=”description”,<br>            categoryDescription=”categoryDescription”,<br>            image=”org/kettlesolutions/plugin/step/helloworld/HelloWorld.png”,<br>            i18nPackageName=”org.kettlesolutions.plugin.step.helloworld”<br>    )<br>这段代码里的@Step annotation用来通知Kettle的插件注册系统：这个类是一个步骤类型的插件。在annotation里可以指定插件的ID、图标、国际代的包、本地化的名称、类别、描述。其中后三项是资源文件里的Key，需要在资源文件里设置真正的值。i18nPackageName指定了资源文件的包名，例如我们这个例子的资源文件位于org/kettlesolutions/plugin/step/helloworld/messages目录下，en_US（英语，美国）的本地代资源文件是messages_en_US.properties。我们例子里的这个资源文件的内容是：<br>name=Hello world<br>description=A very simple step that adds a new “Helllo world” field to the incoming stream<br>注意，如果你指定了不存在的分类，Spoon会创建这个分类，并在Spoon的分类树的最上方显示这个分类。<br>最后，annotation里的image标签指定了插件的图标。需要32*32像素的PNG文件，可以使用透明样式。<br>后面的代码行说明这个类实现了StepMetaInterface接口。在BaseStepMeta抽象类里定义了这个接口的很多默认实现，可以直接继承这个抽象类，然后把工作集中在插件特有的功能上。</p>\n<pre><code>public class HelloworldStepMeta extends BaseStepMeta implements StepMetaInterface\n</code></pre><p>下面的四个方法loadXML()、getXML()、readRep()和saveRep()把元数据保存到XML文件或资源库里，或者从XML文件或资源库读取元数据。保存到文件的方法利用了像XStream（<a href=\"http://xstream.codehaus.org）这样的XML串行化技术。\" target=\"_blank\" rel=\"noopener\">http://xstream.codehaus.org）这样的XML串行化技术。</a></p>\n<p>getFields()方法非常重要，因为它描述了输出数据行的结构。这个方法需要修改inputRowMeta对象，使这个对象和输出格式匹配。Spoon和后面的步骤都需要知道这个步骤要输出哪些字段。最常见的一种方法，可以给输出的RowMetaInterface对象添加一个ValueMetaInterface对象。在ValueMetaInterface对象里设置的信息越详细越好，可以设置的信息包括数据类型、长度、精度、格式掩码，等等。添加的字段描述元信息越多，后面生成的SQL就越准确。</p>\n<h4 id=\"值的元数据（Value-Metadata）\"><a href=\"#值的元数据（Value-Metadata）\" class=\"headerlink\" title=\"####值的元数据（Value Metadata）\"></a>####值的元数据（Value Metadata）</h4><p>值的元数据使用ValueMetaInterface接口描述数据流里的一个字段。这个接口里定义了字段的名字、数据类型、长度、精度，等等。下面的例子用于创建一个ValueMetaInterface对象。<br>    ValueMetaInterface dateMeta = new ValueMeta(“birthdate”,ValueMetaInterface.TYPE_DATE);<br>这个接口也负责转换数据格式。我们建议使用ValueMetaInterface接口来完成所有数据转换的工作。例如，日期类型的数据，如果想把它转换为dateMeta对象里定义的字符串格式，可以用下面的代码：<br>    //java.util.Date birthdate<br>    String birthDateString = dateMeta.getString(birthdate);<br>ValueMeta类负责转换。因为有ValueMetaInterface进行数据类型的转换，所以你不用再去做额外的数据类型转换的工作。<br>使用ValueMetaInterface接口时还要注意数据对象是否为Null。从上一个步骤可以接收到一个数据对象和一个描述数据对象的ValueMetaInterface对象。我们要检查这个数据对象是否为null，在某些情况下如果数据对象为空是不正确的。例如：<br>数据对象是String类型，有10个空格，Value Metadata需要trim这个字符串。<br>在Value Metadata里已经定义了从文本文件里加载的数据，要延迟转换为字符串。所以数据要由二进制的格式（原始数据格式），转换为字符串格式，然后再转换为其它格式的数据。<br>一般使用下面的方法检查数据对象是否为空：<br>    Boolean n = valueMeta.isNull(valueDate);<br>重要：要保证传给ValueMetaInterface对象的数据是在元数据里定义的数据类型。表23-1说明了  ValueMetaInterface里定义的数据类型和Java数据类型的对应关系。<br>Kettle元数据类型和Java里数据类型的对应关系  </p>\n<table><br>    <tr><br>        <th>Value Meta Type</th><br>        <th>Java Class</th><br>    </tr><br>    <tr><br>        <td>ValueMetaInterface.TYPE_STRING</td><br>        <td>Java.lang.String</td><br>    </tr><br>    <tr><br>        <td>ValueMetaInterface.TYPE_DATE</td><br>        <td>Java.util.Date</td><br>    </tr><br>    <tr><br>        <td>ValueMetaInterface.TYPE_BOOLEAN</td><br>        <td>Java.lang.Boolean</td><br>    </tr><br>    <tr><br>        <td>ValueMetaInterface.TYPE_NUMBER</td><br>        <td>Java.lang.Double</td><br>    </tr><br>    <tr><br>        <td>ValueMetaInterface.TYPE_INTEGER</td><br>        <td>Java.lang.Long</td><br>    </tr><br>    <tr><br>        <td>ValueMetaInterface.TYPE_BIGNUMBER</td><br>        <td>Java.math.BigDecimal</td><br>    </tr><br>    <tr><br>        <td>ValueMetaInterface.TYPE_BINARY</td><br>        <td>Byte[]</td><br>    </tr><br></table>\n\n\n<h4 id=\"行的元数据（Row-Meatadata）\"><a href=\"#行的元数据（Row-Meatadata）\" class=\"headerlink\" title=\"####行的元数据（Row Meatadata）\"></a>####行的元数据（Row Meatadata）</h4><p>行的元数据使用RowMetaInterface接口来描述数据行的元数据，而不是一个列的元数据。实际上，RowMetaInterface的类里包含了一组ValueMetaInterface。另外还包括了一些方法来操作行元数据，倒如查询值、检查值是否存、替换值的元数据等。<br>行的元数据里唯一的规则就是一行里的列的名字必须唯一。当你添加了一个新列时，如果新列的名字和已有列的名字相同，列名后面会自动加上“_2”后缀。如果再加一个同名的列会自动加上”_3“后缀，等等。<br>因为在步骤里通常是和数据行打交道，所以从数据行里直接取数据会更方便。可以使用很多类似于getNumber()、getString()这样的方法直接从数据行取数据。例如，销售数据存储在第四列里，可以用下面的代码获取这个数据：  </p>\n<pre><code>Double sales = getInputRowMeta().getNumber(rowData,3);\n</code></pre><p>通过索引获取数据是最快的方式。通过indexOfValue()方法可以获取列在一行里的索引。这个方法扫描列数组，速度并不快。所以，如果要处理所有数据行，我们建议只查询一次列索引。一般是在步骤接收到第一行数据时，就查询列索引，将查询到的列索引保存起来，供后面的数据行使用。  </p>\n<h3 id=\"StepDatainterface\"><a href=\"#StepDatainterface\" class=\"headerlink\" title=\"###StepDatainterface\"></a>###StepDatainterface</h3><p>实现了org.pentaho.di.trans.step.StepDataInterface接口的类用来维护步骤的执行状态，以及存储临时对象。例如，可以把输出行的元数据、数据库连接、输入输出流等存储到这个对象里。<br>HelloworldStepData.java<br>    package org.kettlesolutions.plugin.step.helloworld;</p>\n<p>import org.pentaho.di.core.row.RowMetaInterface;<br>import org.pentaho.di.trans.step.BaseStepData;<br>import org.pentaho.di.trans.step.StepDataInterface;</p>\n<p>public class HelloworldStepData extends BaseStepData implements StepDataInterface {</p>\n<pre><code>public RowMetaInterface outputRowMeta;\n</code></pre><p>}</p>\n<h3 id=\"StepDialogInterface\"><a href=\"#StepDialogInterface\" class=\"headerlink\" title=\"###StepDialogInterface\"></a>###StepDialogInterface</h3><p>实现org.pentaho.di.trans.step.StepDialogInterfac接口的类用来提供一个用户界面，用户通过这个界面输入元数据（转换参数）。用户界面就是一个对话框。这个接口里包含了类似open()和setRepository()等的几个简单的方法。    </p>\n<h4 id=\"Eclipse-SWT\"><a href=\"#Eclipse-SWT\" class=\"headerlink\" title=\"####Eclipse SWT\"></a>####Eclipse SWT</h4><p>Kettle里使用Eclipse SWT作为界面开发包，所以你也要使用SWT来开发对话框窗口。SWT为不同的操作系统Windows、OS X、Linux和Unix提供了一个抽象层。所以SWT的图形界面和操作系统期货的程序的界面风格非常相近。<br>在开始进行SWT开发之前，建议先访问SWT主面以了解更多的内容<a href=\"http://www.eclipse/org/swt。在SWT的网站上，你可以了解到SWT能做出什么样的界面效果：\" target=\"_blank\" rel=\"noopener\">http://www.eclipse/org/swt。在SWT的网站上，你可以了解到SWT能做出什么样的界面效果：</a><br>SWT控件页，<a href=\"http://www.eclipse.org/swt/widgets/，给出了你能使用的所有控件。\" target=\"_blank\" rel=\"noopener\">http://www.eclipse.org/swt/widgets/，给出了你能使用的所有控件。</a><br>SWT样例页，<a href=\"http://www.eclipse.org/swt/snippets/，给出了许多代码例子。\" target=\"_blank\" rel=\"noopener\">http://www.eclipse.org/swt/snippets/，给出了许多代码例子。</a><br>最好的资源就是Kettle里150个内置步骤的对话框源代码。  </p>\n<p>HelloworldStepDialog.java<br>    package org.kettlesolutions.plugin.step.helloworld;</p>\n<pre><code>import org.eclipse.swt.SWT;\nimport org.eclipse.swt.events.ModifyEvent;\nimport org.eclipse.swt.events.ModifyListener;\nimport org.eclipse.swt.events.SelectionAdapter;\nimport org.eclipse.swt.events.SelectionEvent;\nimport org.eclipse.swt.events.ShellAdapter;\nimport org.eclipse.swt.events.ShellEvent;\nimport org.eclipse.swt.layout.FormAttachment;\nimport org.eclipse.swt.layout.FormData;\nimport org.eclipse.swt.layout.FormLayout;\nimport org.eclipse.swt.widgets.Button;\nimport org.eclipse.swt.widgets.Control;\nimport org.eclipse.swt.widgets.Display;\nimport org.eclipse.swt.widgets.Event;\nimport org.eclipse.swt.widgets.Label;\nimport org.eclipse.swt.widgets.Listener;\nimport org.eclipse.swt.widgets.Shell;\nimport org.eclipse.swt.widgets.Text;\nimport org.pentaho.di.core.Const;\nimport org.pentaho.di.i18n.BaseMessages;\nimport org.pentaho.di.trans.TransMeta;\nimport org.pentaho.di.trans.step.BaseStepMeta;\nimport org.pentaho.di.trans.step.StepDialogInterface;\nimport org.pentaho.di.ui.core.widget.TextVar;\nimport org.pentaho.di.ui.trans.step.BaseStepDialog;\n\npublic class HelloworldStepDialog extends BaseStepDialog implements\n        StepDialogInterface {\n\n    private static Class&lt;?&gt; PKG = HelloworldStepMeta.class; // for i18n\n                                                            // purposes, needed\n                                                            // by Translator2!!\n                                                            // $NON-NLS-1$\n\n    private HelloworldStepMeta input;\n\n    private TextVar wFieldname;\n\n    public HelloworldStepDialog(Shell parent, Object baseStepMeta,\n            TransMeta transMeta, String stepname) {\n        //初始化元数据对象以及步骤对话框的父类\n        super(parent, (BaseStepMeta) baseStepMeta, transMeta, stepname);\n        input = (HelloworldStepMeta) baseStepMeta;\n    }\n\n    public String open() {\n        Shell parent = getParent();\n        Display display = parent.getDisplay();\n\n        shell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MIN\n                | SWT.MAX);\n        props.setLook(shell);\n        setShellImage(shell, input);\n\n        ModifyListener lsMod = new ModifyListener() {\n            public void modifyText(ModifyEvent e) {\n                input.setChanged();\n            }\n        };\n        changed = input.hasChanged();\n\n        FormLayout formLayout = new FormLayout();\n        formLayout.marginWidth = Const.FORM_MARGIN;\n        formLayout.marginHeight = Const.FORM_MARGIN;\n\n        shell.setLayout(formLayout);\n        shell.setText(BaseMessages.getString(PKG,\n                &quot;HelloworldDialog.Shell.Title&quot;)); //$NON-NLS-1$\n\n        //所有控件的右侧使用一个自定义的百分对对齐。控件之间的间距使用一个常量，常量值是4像素。\n        int middle = props.getMiddlePct();\n        int margin = Const.MARGIN;\n\n        // Stepname line\n        wlStepname = new Label(shell, SWT.RIGHT);\n        wlStepname.setText(BaseMessages.getString(PKG,\n                &quot;HelloworldDialog.Stepname.Label&quot;)); //$NON-NLS-1$\n        props.setLook(wlStepname);\n        fdlStepname = new FormData();\n        fdlStepname.left = new FormAttachment(0, 0);\n        fdlStepname.right = new FormAttachment(middle, -margin);\n        fdlStepname.top = new FormAttachment(0, margin);\n        wlStepname.setLayoutData(fdlStepname);\n        wStepname = new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n        wStepname.setText(stepname);\n        props.setLook(wStepname);\n        wStepname.addModifyListener(lsMod);\n        fdStepname = new FormData();\n        fdStepname.left = new FormAttachment(middle, 0);\n        fdStepname.top = new FormAttachment(0, margin);\n        fdStepname.right = new FormAttachment(100, 0);\n        wStepname.setLayoutData(fdStepname);\n        Control lastControl = wStepname;\n\n        // Fieldname line\n        //创建一个新的标签控件，控件里文本靠右对齐\n        Label wlFieldname = new Label(shell, SWT.RIGHT);\n        wlFieldname.setText(BaseMessages.getString(PKG,\n                &quot;HelloworldDialog.Fieldname.Label&quot;)); //$NON-NLS-1$\n        //下面一行为控件设置用户定义的背景色和字体\n        props.setLook(wlFieldname);\n        FormData fdlFieldname = new FormData();\n        fdlFieldname.left = new FormAttachment(0, 0);\n        fdlFieldname.right = new FormAttachment(middle, -margin);\n        fdlFieldname.top = new FormAttachment(lastControl, margin);\n        wlFieldname.setLayoutData(fdlFieldname);\n        wFieldname = new TextVar(transMeta, shell, SWT.SINGLE | SWT.LEFT\n                | SWT.BORDER);\n        props.setLook(wFieldname);\n        wFieldname.addModifyListener(lsMod);\n        FormData fdFieldname = new FormData();\n        fdFieldname.left = new FormAttachment(middle, 0);\n        fdFieldname.top = new FormAttachment(lastControl, margin);\n        fdFieldname.right = new FormAttachment(100, 0);\n        wFieldname.setLayoutData(fdFieldname);\n        lastControl = wFieldname;\n\n        // Some buttons\n        wOK = new Button(shell, SWT.PUSH);\n        wOK.setText(BaseMessages.getString(PKG, &quot;System.Button.OK&quot;)); //$NON-NLS-1$\n        wCancel = new Button(shell, SWT.PUSH);\n        wCancel.setText(BaseMessages.getString(PKG, &quot;System.Button.Cancel&quot;)); //$NON-NLS-1$\n\n        setButtonPositions(new Button[] { wOK, wCancel }, margin, lastControl);\n\n        // Add listeners\n        lsCancel = new Listener() {\n            public void handleEvent(Event e) {\n                cancel();\n            }\n        };\n        lsOK = new Listener() {\n            public void handleEvent(Event e) {\n                ok();\n            }\n        };\n\n        wCancel.addListener(SWT.Selection, lsCancel);\n        wOK.addListener(SWT.Selection, lsOK);\n\n        lsDef = new SelectionAdapter() {\n            public void widgetDefaultSelected(SelectionEvent e) {\n                ok();\n            }\n        };\n\n        wStepname.addSelectionListener(lsDef);\n        wFieldname.addSelectionListener(lsDef);\n\n        // Detect X or ALT-F4 or something that kills this window...\n        shell.addShellListener(new ShellAdapter() {//保证了窗口在非正常关闭时，取消用户的编辑\n            public void shellClosed(ShellEvent e) {\n                cancel();\n            }\n        });\n\n        // Populate the data of the controls\n        //下面的代码把数据从步骤的元数据对象里复制到窗口的控件里\n        getData();\n\n        // Set the shell size, based upon previous time...\n        //窗口的大小和位置将根据窗口的自然属性、上次窗口大小和位置，以及显示屏的大小自动设置\n        setSize();\n\n        input.setChanged(changed);\n\n        shell.open();\n        while (!shell.isDisposed()) {\n            if (!display.readAndDispatch())\n                display.sleep();\n        }\n        return stepname;\n    }\n\n    /**\n     * Copy information from the meta-data input to the dialog fields.\n     */\n    public void getData() {\n        wStepname.selectAll();\n        //为了防止用户向控件里输入空值，Kettle提供了一个静态方法来检查宿舍，Const.NVL()\n        wFieldname.setText(Const.NVL(input.getFieldName(), &quot;&quot;));\n    }\n\n    private void cancel() {\n        stepname = null;\n        input.setChanged(changed);\n        dispose();\n    }\n    //单击OK把控件里用户输入的数据都写入到步骤的元数据对象中。\n    private void ok() {\n        if (Const.isEmpty(wStepname.getText()))\n            return;\n\n        stepname = wStepname.getText(); // return value\n\n        input.setFieldName(wFieldname.getText());\n\n        dispose();\n    }\n}\n</code></pre><h4 id=\"窗体布局\"><a href=\"#窗体布局\" class=\"headerlink\" title=\"####窗体布局\"></a>####窗体布局</h4><p>如果你看过步骤对话框的源代码，你就会发现窗体类里有很多烦琐的代码。这些代码确保Kettle可以在各种操作系统下以合适的方式展现窗体。可以发现窗体里的大部分代码都和布局以及控件位置有关。<br>FormLayout是SWT里经常看到的布局方式。程序员可以通过FormLayout指定控件的百分比、偏移。下面是我们例子里的窗口布局的代码（HelloworldStepDialog.java）<br>    //创建一个新的标签控件，控件里文本靠右对齐<br>    Label label = new Label(shell, SWT.RIGHT);<br>    label.setText(BaseMessages.getString(PKG,”HelloworldDialog.Fieldname.Label”)); //$NON-NLS-1$<br>    //下面一行为控件设置用户定义的背景色和字体<br>    props.setLook(label);<br>    /**</p>\n<pre><code>* 下面几行将标签的左侧和对话框的最左侧对齐，把标签的右侧放在对话框中间（50%）的左侧10个像素\n* 的位置。标签的顶部放在距离对话框顶部25个像素的位置。\n*/\nFormData fdLabel = new FormData();\nfdlFieldname.left = new FormAttachment(0, 0);\nfdlFieldname.right = new FormAttachment(50, -10);\nfdlFieldname.top = new FormAttachment(0, 25);\nwlFieldname.setLayoutData(fdLabel);  \n</code></pre><p>简而言之，不要感到痛苦；图形用户界面的代码都比较烦琐，但代码并不复杂。  </p>\n<h4 id=\"Kettle-UI元素\"><a href=\"#Kettle-UI元素\" class=\"headerlink\" title=\"####Kettle UI元素\"></a>####Kettle UI元素</h4><p>除了标准的SWT组件，还可以使用Kettle自带的一些控件，Kettle开发人员的工作可以更简单一些。Kettle自带的组件包括以下一些。<br>TableView：这是一个数据表格组件，支持排序、选择、键盘快捷键和撤销/重做，以及右键菜单。<br>TextVar：这是一个支持变量的文本输入框，这个输入框的右上角有一个$符号。用户可以通过”Ctrl  +Alt+空格”的方式，在弹出的下拉列表中选择变量。其他功能和普通的文本框相同。<br>ComboVar：标准的组合下拉列表，支持变量。<br>ConditionEditor：过滤行步骤里使用的输入条件控件。<br>另外还有很多常用的对话框帮你完成相应的工作，如下所示:<br>EnterListDialog:从字符串列表里选择一个或多个字符串。左侧显示字符串列表，右侧是选中的字符串，并提供把字符串从左侧移动到右侧的按钮。<br>EnterNumberDialog:用户可以输入数字<br>EnterPasswordDialog:让用户输入密码<br>EnterSelectionDialog:通过高亮显示，从列表里选择多项<br>EnterMappingDialog:输入两组字符串的映射<br>PreviewRowsDialog:在对话框里预览一组数据行。<br>SQLEditor:一个简单的SQL编辑器，可以输入查询和DDL.<br>ErrorDialog:显示异常信息，列出详细的错误栈对话框  </p>\n<h4 id=\"Hello-World例子对话框\"><a href=\"#Hello-World例子对话框\" class=\"headerlink\" title=\"####Hello World例子对话框\"></a>####Hello World例子对话框</h4><p>现在我们已经基本了解了SWT以及对话框的布局方式，再看看我们的例子，下面的代码是HelloWorldStepDialog.java里的例子。<br>代码的第一部分是初始化元数据对象以及步骤对话框的父类：<br>    public class HelloworldStepDialog extends BaseStepDialog implements<br>            StepDialogInterface {<br>        private static Class&lt;?&gt; PKG = HelloworldStepMeta.class;<br>        private HelloworldStepMeta input;<br>        private TextVar wFieldname;<br>        public HelloworldStepDialog(Shell parent, Object baseStepMeta,<br>                TransMeta transMeta, String stepname) {<br>            //初始化元数据对象以及步骤对话框的父类<br>            super(parent, (BaseStepMeta) baseStepMeta, transMeta, stepname);<br>            input = (HelloworldStepMeta) baseStepMeta;<br>        }<br>在下面的open()方法里创建对话框里的所有控件。SWT使用事件监听模式，可以为控件创建各种监听方法，以响应控件内容的变化和用户的动作。<br>    public String open() {<br>            Shell parent = getParent();<br>            Display display = parent.getDisplay();<br>            shell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MIN<br>                    | SWT.MAX);<br>            props.setLook(shell);<br>            setShellImage(shell, input);<br>            ModifyListener lsMod = new ModifyListener() {<br>                public void modifyText(ModifyEvent e) {<br>                    input.setChanged();<br>                }<br>            };<br>            changed = input.hasChanged();</p>\n<p>下面代码说明窗体里的控件将使用formLayout的布局方式：<br>    FormLayout formLayout = new FormLayout();<br>            formLayout.marginWidth = Const.FORM_MARGIN;<br>            formLayout.marginHeight = Const.FORM_MARGIN;<br>            shell.setLayout(formLayout);<br>所有控件的右侧使用一个自定义的百分比对齐：props.getMiddlePct()；控件之间的间距使用一个常量，常量值是4像素。<br>    shell.setLayout(formLayout);<br>            shell.setText(BaseMessages.getString(PKG,<br>                    “HelloworldDialog.Shell.Title”)); //$NON-NLS-1$<br>            int middle = props.getMiddlePct();<br>            int margin = Const.MARGIN;<br>下面的代码在对话框的最上面添加了一行步骤名称标签和输入文本框：<br>    // Stepname line<br>            wlStepname = new Label(shell, SWT.RIGHT);<br>            wlStepname.setText(BaseMessages.getString(PKG,<br>                    “HelloworldDialog.Stepname.Label”)); //$NON-NLS-1$<br>            props.setLook(wlStepname);<br>            fdlStepname = new FormData();<br>            fdlStepname.left = new FormAttachment(0, 0);<br>            fdlStepname.right = new FormAttachment(middle, -margin);<br>            fdlStepname.top = new FormAttachment(0, margin);<br>            wlStepname.setLayoutData(fdlStepname);<br>            wStepname = new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);<br>            wStepname.setText(stepname);<br>            props.setLook(wStepname);<br>            wStepname.addModifyListener(lsMod);<br>            fdStepname = new FormData();<br>            fdStepname.left = new FormAttachment(middle, 0);<br>            fdStepname.top = new FormAttachment(0, margin);<br>            fdStepname.right = new FormAttachment(100, 0);<br>            wStepname.setLayoutData(fdStepname);<br>            Control lastControl = wStepname;</p>\n<p>下面是新增输出列的列名设置的输入框：<br>    // Fieldname line<br>        //创建一个新的标签控件，控件里文本靠右对齐<br>        Label wlFieldname = new Label(shell, SWT.RIGHT);<br>        wlFieldname.setText(BaseMessages.getString(PKG,<br>                “HelloworldDialog.Fieldname.Label”)); //$NON-NLS-1$<br>        //下面一行为控件设置用户定义的背景色和字体<br>        props.setLook(wlFieldname);<br>        FormData fdlFieldname = new FormData();<br>        fdlFieldname.left = new FormAttachment(0, 0);<br>        fdlFieldname.right = new FormAttachment(middle, -margin);<br>        fdlFieldname.top = new FormAttachment(lastControl, margin);<br>        wlFieldname.setLayoutData(fdlFieldname);<br>        wFieldname = new TextVar(transMeta, shell, SWT.SINGLE | SWT.LEFT<br>                | SWT.BORDER);<br>        props.setLook(wFieldname);<br>        wFieldname.addModifyListener(lsMod);<br>        FormData fdFieldname = new FormData();<br>        fdFieldname.left = new FormAttachment(middle, 0);<br>        fdFieldname.top = new FormAttachment(lastControl, margin);<br>        fdFieldname.right = new FormAttachment(100, 0);<br>        wFieldname.setLayoutData(fdFieldname);<br>        lastControl = wFieldname;</p>\n<p>然后创建两个按钮，“确认”和“取消”按钮，以及按钮单击事件的监听方法，把按钮放在对话框的最下面：<br>    // Some buttons<br>        wOK = new Button(shell, SWT.PUSH);<br>        wOK.setText(BaseMessages.getString(PKG, “System.Button.OK”)); //$NON-NLS-1$<br>        wCancel = new Button(shell, SWT.PUSH);<br>        wCancel.setText(BaseMessages.getString(PKG, “System.Button.Cancel”)); //$NON-NLS-1$</p>\n<pre><code>setButtonPositions(new Button[] { wOK, wCancel }, margin, lastControl);\n\n// Add listeners\nlsCancel = new Listener() {\n    public void handleEvent(Event e) {\n        cancel();\n    }\n};\nlsOK = new Listener() {\n    public void handleEvent(Event e) {\n        ok();\n    }\n};\nwCancel.addListener(SWT.Selection, lsCancel);\nwOK.addListener(SWT.Selection, lsOK);\n</code></pre><p>下面的代码做了两件事情，上部代码可以保证当步骤名称或输出字段名称的输入框在编辑状态时，单击“确定”按钮，正在编辑的内容不会丢失；下部的代码保证了窗口在非正常关闭时（没有使用“确定”或“取消”按钮关闭），取消用户的编辑。<br>    lsDef = new SelectionAdapter() {<br>            public void widgetDefaultSelected(SelectionEvent e) {<br>                ok();<br>            }<br>        };</p>\n<pre><code>wStepname.addSelectionListener(lsDef);\nwFieldname.addSelectionListener(lsDef);\n\n// Detect X or ALT-F4 or something that kills this window...\nshell.addShellListener(new ShellAdapter() {//保证了窗口在非正常关闭时，取消用户的编辑\n    public void shellClosed(ShellEvent e) {\n        cancel();\n    }\n});\n</code></pre><p>下面的代码把数据从步骤的元数据对象里复制到窗口的控件里：<br>    // Populate the data of the controls<br>            getData();<br>窗口的大小和位置将根据窗口的自然属性、上次窗口大小和位置，以及显示屏的大小自动设置。<br>    // Set the shell size, based upon previous time…<br>            //窗口的大小和位置将根据窗口的自然属性、上次窗口大小和位置，以及显示屏的大小自动设置<br>            setSize();<br>            input.setChanged(changed);</p>\n<pre><code>    shell.open();\n    while (!shell.isDisposed()) {\n        if (!display.readAndDispatch())\n            display.sleep();\n    }\n    return stepname;\n}\n</code></pre><p>为了防止用户身控件里输入空值，Kettle提供了一个静态方法来检查空值，ConstNVL();<br>    /**</p>\n<pre><code> * Copy information from the meta-data input to the dialog fields.\n */\npublic void getData() {\n    wStepname.selectAll();\n    wFieldname.setText(Const.NVL(input.getFieldName(), &quot;&quot;));\n}\n</code></pre><p>最后，单击OK按钮后，把控件里用户输入的数据都写入到步骤的元数据对象中：<br>    private void cancel() {<br>            stepname = null;<br>            input.setChanged(changed);<br>            dispose();<br>        }<br>        //单击OK把控件里用户输入的数据都写入到步骤的元数据对象中。<br>        private void ok() {<br>            if (Const.isEmpty(wStepname.getText()))<br>                return;</p>\n<pre><code>    stepname = wStepname.getText(); // return value\n\n    input.setFieldName(wFieldname.getText());\n\n    dispose();\n}\n</code></pre><h3 id=\"StepInteface\"><a href=\"#StepInteface\" class=\"headerlink\" title=\"###StepInteface\"></a>###StepInteface</h3><pre><code>这个类实现了org.pentaho.di.trans.step.StepInterface接口，这个类读取上个步骤传来的数据行，利用StepMetaInterface对象里定义的元数据，逐行转换和处理上个步骤传来的数据行，Kettle引擎直接使用这个接口里的很多方法来执行转换过程，但大部分方法都已经由BaseStep类实现了，通常开发人员只需要重载其中的几个方法。\nInit():步骤初始化方法，用来初始化一个步骤。初始化结果是一个true或者false的Boolean值。如果你的步骤没有任何初始化的工作，可以不用重载这个方法。\nDispose():如果有需要释放的资源，可以在dispose()方法里释放，例如可以关闭数据库连接、释放文件、清除缓存等。在转换的最后Kettle引擎会调用这个方法。如果没有需要释放或清除的资源，可以不用重载这个方法。\nprocessRow():这个方法，是步骤实现工作的地方。只要这个方法返回true，转换引擎就会重复调用这个方法。\n</code></pre><p>下面是HellWorld例子实现的StepInterface接口（HelloworldStep.java）</p>\n<p>HelloworldStep.java<br>    package org.kettlesolutions.plugin.step.helloworld;</p>\n<pre><code>import org.pentaho.di.core.exception.KettleException;\nimport org.pentaho.di.core.row.RowDataUtil;\nimport org.pentaho.di.trans.Trans;\nimport org.pentaho.di.trans.TransMeta;\nimport org.pentaho.di.trans.step.BaseStep;\nimport org.pentaho.di.trans.step.StepDataInterface;\nimport org.pentaho.di.trans.step.StepInterface;\nimport org.pentaho.di.trans.step.StepMeta;\nimport org.pentaho.di.trans.step.StepMetaInterface;\n/**\n * BaseStep抽象类已经实现了接口里的很多方法，我们只要覆盖需要修改的方法即可。\n * @author Administrator\n *\n */\npublic class HelloworldStep extends BaseStep implements StepInterface {\n    /**\n     * 类的构造函数通常直接把参数传递给BaseStep父类。由父类里的方法来构造对象，然后可以直接\n     * 使用类似transMeta这样的对象。\n     * @param stepMeta\n     * @param stepDataInterface\n     * @param copyNr\n     * @param transMeta\n     * @param trans\n     */\n    public HelloworldStep(StepMeta stepMeta, StepDataInterface stepDataInterface,\n            int copyNr, TransMeta transMeta, Trans trans) {\n        super(stepMeta, stepDataInterface, copyNr, transMeta, trans);\n        // TODO Auto-generated constructor stub\n    }\n\n\n    public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException {\n\n        HelloworldStepMeta meta  = (HelloworldStepMeta) smi;\n        HelloworldStepData data = (HelloworldStepData) sdi;\n        /**\n         * getRow()方法从上一个步骤获取一行数据。如果没有更多要获取的数据行，这个方法就会返回null。\n         * 如果前面的步骤不能及时提供数据，这个方法就会阻塞，直到有可用的数据行。这样这个步骤的速度就会降低，也会影响\n         * 其它步骤的速度。\n         */\n        Object[] row = getRow();\n        if (row==null) {\n            /**\n             * setOutputDone()方法用来通知其它的步骤，本步骤已经没有输出数据行。下一个步骤如果\n             * 再调用getRow()方法就会返回null,转换也不再调用processRow()方法。\n             */\n            setOutputDone();\n            return false;\n        }\n\n        if (first) {\n            first=false;\n            /**\n             * 从性能上考虑，getRow()方法不提供数据行的元数据，只提供上个步骤输出的数据。可以使用getInputRowMeta()方法\n            获取元数据，元数据只获取一次即可，所以在first代码块里获取元数据。\n               如果要把数据传到下一个步骤，要使用putRow()方法。除了输出数据，还要输出RowMetaInterface元数据。\n               第一行使用clone()方法把输入行的元数据结构复制给输出行。输出行的元数据结构是在输入行的基础上增加一个字段，但\n               构造输出行的元数据结构只能构造一次，因为所有输出数据行的结构都是一样的，产生了输出行以后，元数据结构就不能再变化。\n               所以输出行的元数据结构在first代码块里构造。first是一个内部成员，first代码块里的代码只在处理第一行数据时执行。\n               下面代码的最后一行，给输出数据增加了一个字段。\n             */\n            data.outputRowMeta = getInputRowMeta().clone();\n            meta.getFields(data.outputRowMeta, getStepname(), null, null, this);\n        }\n        /**\n         * 下面的代码，把数据写入输出流。从性能角度考虑，数据行实现就是Java数组。为了开发方便，可以使用RowDataUtil类提供\n         * 的一些静态方法来操作数据。使用RowDatautil静态方法复制数据，还可以提高性能。\n         */\n        String value = &quot;Hello, world!&quot;;\n\n        Object[] outputRow = RowDataUtil.addValueData(row, getInputRowMeta().size(), value);\n\n        putRow(data.outputRowMeta, outputRow);\n\n        return true;\n    }\n}\n</code></pre><p>解析：<br>public class HelloworldStep extends BaseStep implements StepInterface {<br>BaseStep抽象类已经实现了接口里的很多方法，我们只要覆盖需要修改的方法即可。<br>类的构造函数通常直接把参数传递给BaseStep父类。由父类里的方法来构造对象，然后可以直接使用类似transMeta这样的对象。<br>public HelloworldStep(StepMeta stepMeta, StepDataInterface stepDataInterface,<br>            int copyNr, TransMeta transMeta, Trans trans) {<br>        super(stepMeta, stepDataInterface, copyNr, transMeta, trans);<br>    }<br>getRow()方法从上一个步骤获取一行数据。如果没有更多要获取的数据行，这个方法就会返回null。如果前面的步骤不能及时提供数据，这个方法就会阻塞，直到有可用的数据行。这样这个步骤的速度就会降低，也会影响其它步骤的速度。<br>public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException {<br>        HelloworldStepMeta meta  = (HelloworldStepMeta) smi;<br>        HelloworldStepData data = (HelloworldStepData) sdi;<br>        Object[] row = getRow();<br>        if (row==null) {<br>            setOutputDone();<br>            return false;<br>        }</p>\n<pre><code>    if (first) {\n        first=false;\n        data.outputRowMeta = getInputRowMeta().clone();\n        meta.getFields(data.outputRowMeta, getStepname(), null, null, this);\n    }\n    String value = &quot;Hello, world!&quot;;\n    Object[] outputRow = RowDataUtil.addValueData(row, getInputRowMeta().size(), value);\n\n    putRow(data.outputRowMeta, outputRow);\n\n    return true;\n}\n</code></pre><p>从性能上考虑，getRow()方法不提供数据行的元数据，只提供上个步骤输出的数据。可以使用getInputRowMeta()方法获取元数据，元数据只获取一次即可，所以在first代码块里获取元数据。<br>setOutputDone()方法用来通知其它的步骤，本步骤已经没有输出数据行。下一个步骤如果再调用getRow()方法就会返回null,转换也不再调用processRow()方法。</p>\n<pre><code>Object[] row = getRow();\n        if (row==null) {\n            setOutputDone();\n            return false;\n        }\n</code></pre><p>   如果要把数据传到下一个步骤，要使用putRow()方法。除了输出数据，还要输出RowMetaInterface元数据。<br>    data.outputRowMeta = getInputRowMeta().clone();<br>    meta.getFields(data.outputRowMeta, getStepname(), null, null, this);<br>第一行使用clone()方法把输入行的元数据结构复制给输出行。输出行的元数据结构是在输入行的基础上增加一个字段，但构造输出行的元数据结构只能构造一次，因为所有输出数据行的结构都是一样的，产生了输出行以后，元数据结构就不能再变化。所以输出行的元数据结构在first代码块里构造。first是一个内部成员，first代码块里的代码只在处理第一行数据时执行。下面代码的最后一行，给输出数据增加了一个字段。</p>\n<p>下面的代码，把数据写入输出流。<br>        String value = “Hello, world!”;<br>        Object[] outputRow = RowDataUtil.addValueData(row, getInputRowMeta().size(), value);<br>        putRow(data.outputRowMeta, outputRow);<br>从性能角度考虑，数据行实现就是Java数组。为了开发方便，可以使用RowDataUtil类提供的一些静态方法来操作数据。使用RowDatautil静态方法复制数据，还可以提高性能。<br>从指定的步骤读取数据行<br>如果你想从前面的某个指定的步骤读取数据行，例如”流查询“步骤，可以使用getRowFrom()方法。<br>       RowSet rowSet = findInputRowSet(Source Step Name);<br>       Object[] rowData = getRowFrom(rowSet);<br>           还可以通过rowSet对象获得数据行的元数据：<br>       RowMetaInterface rowMeta = rowSet.getRowMeta();<br>把数据行写入指定的步骤<br>如果想把数据写入到某个特定的步骤，例如”过滤“步骤，可以使用putRowTo()方法<br>      RowSet rowSet = findOutputRowSet(Target Step Name);<br>      ….<br>      putRowTo(outputRowMeta,rowData,rowSet);<br>很明显，输入和输出的RowSet对象只需获得一次即可，这样才更有效率。<br>把数据行写入到错误处理步骤<br>如果想让你的步骤支持错误处理，而且元数据类返回的supportErrorHandling()方法返回了true，就可以把数据输出<br>      到错误处理步骤里。下面是使用putError()方法的例子：<br>      Object[] rowData = getRow();<br>      …<br>      try{<br>          …<br>          putRow(…);<br>      }catch(Exception e){<br>          if(getStepMeta().isDoingErrorHandling()){<br>              putError(getInputRowMeta(),rowData,errorCode);<br>          }else{<br>              throw(e);<br>          }<br>      }<br>      从例子里可以看到，这段代码把错误的行数、错误字段名、消息、错误编码都传递给错误处理步骤。<br>      错误处理的其他工作都自动完成了。</p>\n<h4 id=\"识别一个步骤拷贝\"><a href=\"#识别一个步骤拷贝\" class=\"headerlink\" title=\"####识别一个步骤拷贝\"></a>####识别一个步骤拷贝</h4><p>因为一个步骤可以有多份拷贝同时执行，有时需要识别出正在使用的是哪个步骤拷贝，可以用下面几个方法。<br>     getCopy():获得拷贝号。拷贝号可以唯一标识出步骤的一个拷贝，拷贝号的聚会范围是0-N，N=getStepMeta().getCopies()-1<br>     getUniqueStepNrAcrossSlaves():获得在集群模式下运行的步骤拷贝号。<br>     getUniqueStepCountAcrossSlaves():获得在集群模式下运行的步骤拷贝总数。<br>     通过这些方法可以把一个步骤的工作分配给多份拷贝去完成。例如”CSV文件输入“和”固定文件输入“步骤里都有并行读取文件的选项，这样可以把读取文件的工作放在多个拷贝里或集群里来完成。</p>\n<h4 id=\"结果反馈\"><a href=\"#结果反馈\" class=\"headerlink\" title=\"####结果反馈\"></a>####结果反馈</h4><p>在调用getRow()和putRow()方法时，引擎会自动计算两类度量值，读行数和写行数。这两类度量值可以在界面或日志中记录下来，以监控程序运行的状态。下面几个方法用来操作这两类度量值。<br>    incrementLinesRead():增加从前面步骤读取到的行数。<br>    incrementLinesWritten():增加定稿到后面步骤中的行数。<br>    incrementLinesInput():增加从文件、数据库、网络等资源读取到的行数<br>    incrementLinesOutput:增加写入到文件、数据库、网络等资源的行数。<br>    incrementLinesUpdate():增加更新的行数。<br>    incrementLinesSkipped()：增加跳过的数据行的行数。<br>    incrementLinesRejected():增加拒绝的数据行的行数。<br>    这些度量值用来说明步骤执行的情况。可以在Spoon的转换度量面板里看到，也可以存到日志数据库表里。<br>    使用addResultFile()方法，可以把步骤用到的文件保留下来，保存到结果文件列表里。结果文件列表可以被其它转换或作业项使用。例如，下面的”CSV文件输入“的代码：<br>ResultFile resultFile = new ResultFile(<br>    ResultFile.FILE_TYPE_GENERAL,<br>    fileObject,<br>getTransMeta().getName(),<br>getStepName()<br>);<br>resultFile.setComment(“File was read by a Csv Input step”);<br>addREsultFile(resultFile);</p>\n<h4 id=\"变量替换\"><a href=\"#变量替换\" class=\"headerlink\" title=\"####变量替换\"></a>####变量替换</h4><pre><code>如果输入框需要支持变量，可以使用environmentSubstritute()方法获取变量。例如，若想在“Hello World”例子的字段名输入框里使用变量，就要把StepMetaInterface里的getFields()方法修改成下面的语句：\n</code></pre><p>String realFiledName = apace. environmentSubstritute(fieldName)；<br>因为步骤本身是一个VariableSpace对象，所以也可以使用下面的语句做变量替换：String value = environmentSubstritute(meta.getSringWithVariables());</p>\n<h4 id=\"Apache-VFS\"><a href=\"#Apache-VFS\" class=\"headerlink\" title=\"####Apache VFS\"></a>####Apache VFS</h4><p>Kettle里所有操作文件的步骤，都使用Apache VFS系统的方式操作。Apache VFS不但可以从文件系统读取文件（如java.io.File），还可以从很多其他来源读取文件，如FTP服务器、Z学压缩文件，等 等 。<br>Apache VFS里的FileObject对象提供了文件的抽象层，然后在Kettle的KettleVFS类里还提供了一系列的静态方法，来更方便使用FileObject对象，例如下面的代码 ：  </p>\n<pre><code>FileObject fileObject = KettleVFS.getFileObject(“zip:http://www.example.com/archive.zip!file.txt”);\n</code></pre><p><code>String value = environmentSubstritute(meta.getSringWithVariables());</code></p>\n<p>应该尽可能多地使用KettleVFS,因为它解决了或饶过了很多Apache VFS目前已知的问题。它也增强了SFTP协议。</p>\n<h4 id=\"步骤插件部署\"><a href=\"#步骤插件部署\" class=\"headerlink\" title=\"####步骤插件部署\"></a>####步骤插件部署</h4><p>部署之前，要把四个Java源代码文件编译为class文件。把编译好的class文件放到一个Jar包里。可以使用IDE来做这些事情，也可以手工使用ant脚本来做这些事情。<br>.jar文件应该放在Kettle的plugins/steps目录下。也可以使用一个子目录，把所有的依赖的jar包放在插件jar包所在目录的/lib目录下，不必再放Kettle的类路径中（Kettle的libext/目录）已经有了的jar包。另外可以把多个插件放在一个jar包里。<br>如果想在IDE里调试插件，可以把插件元数据类的名字放在Kettle_PLUGIN_CLASSES变量里（一个逗号分隔的列表）。关于这个主题的更多信息，请参考pentaho Wiki:<a href=\"http://wiki.pentaho.com/display/EAI/How+to+debug+a+Kettle+4+plugin\" target=\"_blank\" rel=\"noopener\">http://wiki.pentaho.com/display/EAI/How+to+debug+a+Kettle+4+plugin</a> 。</p>\n"},{"title":"Oracle SQL基础知识","date":"2016-05-22T06:43:49.000Z","_content":"## Oracle SQL基本知识##\n### 安装数据库###\n#### 1）安装Oracle常用问题(常用”用户名/密码“规则)：####\n超级管理员：sys /change_on_install\n普通管理员：system/manager\n普通用户：scott/tiger----->默认是被锁定的\n大数据用户：sh/sh\n#### 2）SQL,DDL...####\nSQL：structured query language 结构化查询语言\n1.file(文件)\n\nSQL:DDL DML TCL DQL DCL\nDDL(data definition language 数据定义语言): column(列)--structure\ncreate table (创建表):\n列名 data type(数据类型) width(宽度)\nconstraint (约束)      alter table(修改表结构)           drop table(删除表)\n\nDML(data manipulation language 数据操作语言)\n:row(行)--data\ninsert 增       update 改            delete 删数据,删表里的记录\n\nTCL(transaction control language 事务控制语言)\ncommit(提交)         rollback(回滚)               savepoint(保留点)\n\nDQL(data query language 数据查询语言)\nselect\nDCL(data control language 数据控制语言)\ngrant(授权)  grant to       revoke(回收权限) revoke from \n#### 3）RDBMS关系型数据库管理系统####\nRDBMS(relationship database management system 关系型数据库管理系统) software(软件) --->(create database)database--->login in database (登录数据库系统 )--->用SQL操作table\n\ncreate database 创建空间存储表 (datafile 数据文件)\nlogin in database\n1 远程登录到数据库所在的机器上\n  192.168.0.20 192.168.0.23 192.168.0.26\nshell(终端) telnet 192.168.0.20  (跟操作系统建连接)\nlogin:openlab\npassword:open123\nsunv210% shell提示符,执行操作系统命令\n#### 4） 登录该机器上的数据库系统####\nsunv210% sqlplus (跟数据库建连接)\nEnter user-name: openlab\nEnter password:open123\nSQL>sqlplus openlab/open123\nSQL> 数据库提示符,执行SQL命令\n\n#### 5）登录的是哪个数据库####\necho $ORACLE_SID(环境变量)<---DBA(database administrator 数据库管理员)\n查看ORACLE_SID变量的取值,oracle提供\n通过设置ORACLE_SID变量,sqlplus就知道跟哪个数据库建连接.\nunix平台\n%c shell\n%echo $ORACLE_SID  (tarena)\n%setenv ORACLE_SID hiloo\n%setenv ORACLE_SID tarena\n\n$ b shell\n$ echo $ORACLE_SID  (tarena)\n$ ORACLE_SID=hiloo\n$ export ORACLE_SID\n\nwindows平台\nD:\\>set ORACLE_SID=hiloo (设置环境变量)\nD:\\>set ORACLE_SID (查看环境变量)\nORACLE_SID=hiloo\n##### 数据表信息：##### \ndept(表名) department 部门信息   列名\ndeptno 部门号  dname  部门名称      location 位置(地区)\ncreate table dept_hiloo\n(deptno  number(2), dname char(20),  location char(20));\ninsert into dept_hiloo values (10,'developer','beijing');\ninsert into dept_hiloo values (20,'account','shanghai');\ninsert into dept_hiloo values (30,'sales','guangzhou');\ninsert into dept_hiloo values  ( 40,'operations','tianjin');\ncommit;\ninsert成功后的提示:1 rows inserted\nemp(表名) employee 员工信息    列名\nempno 员工 ename 员工名字  job   职位   salary  月薪   bonus   奖金  \nhiredate  入职日期  mgr   manager 管理者    deptno  部门号\ncreate table emp_hiloo(\nempno number(4),\tename varchar2(20),  job  varchar2(15),  \nsalary number(7,2), bonus number(7,2),  hiredate date,\n mgr number(4),  deptno number(10));\nalter session set nls_date_language='american';\ninsert into emp_hiloo values (1001,'zhangwuji','Manager',10000,2000,'12-MAR-10',1005,10);\ninsert into emp_hiloo values (1001,'zhangwuji','Manager',10000,2000,'12-MAR-10',1005,10);\ninsert into emp_hiloo values (1002,'liucangsong','Analyst',8000,1000, '01-APR-11',1001,10);\ninsert into emp_hiloo values (1003,'liyi','Analyst',9000,1000,'11-APR-10',1001,10);\ninsertinto emp_hiloo values (1004,'guofurong','Programmer',5000,null,'01-JAN-11',1001,10);\ninsertintoemp_hiloo values (1005,'zhangsanfeng','President',15000,null,'15-MAY-08',null,20);\ninsert into emp_hiloo values (1006,'yanxiaoliu','Manager',5000,400,'01-FEB-09',1005,20);\ninsert into emp_hiloo values (1007,'luwushuang','clerk',3000,500,'01-FEB-06',1006,20);\ninsert into emp_hiloo values (1008,'huangrong','Manager',5000,500,'1-MAY-09',1005,30);\ninsert into emp_hiloo values (1009,'weixiaobao','salesman',4000,null,'20-FEB-09',1008,30);\ninsert into emp_hiloo values (1010,'guojing','salesman',4500,500,'10-MAY-09',1008,30);\n报错信息\nORA-00955: name is already used by an existing object(名字已经被一个存在的对象使用)\n错误：ORA-01843:无效的月份（在中文的plsql控制台上月份要写成’10-3月-02’这种形式，必须是一个数字和一个汉语月。也可以把日期改成英文环境，在执行插入前执行alter session set nls_date_language='american';就可以 了。\n\nDQL\nselect(选择)\n源表  结果集\n1 投影操作 select子句实现\n2 选择操作 where子句实现\n3 连接操作\n 1  select ename,salary*12 ann_sal(列别名)\n 2* from emp_hiloo\n\n单引号 表达字符串 ''\n双引号 表达列别名 \"\",别名中包含空格,大小写敏感\n\n\n##### 1）null值的理解##### \n1 null值出现在算术表达式中,结果必为null,null可以看作无穷大.\n2 函数(function) nvl功能空值转换函数\nnvl是函数名,p1,p2是参数,数据类型必须一致,函数本身有返回值\nnvl(p1,p2)  \nnvl函数实现:\nif p1 is null then\n   return p2;\nelse\n   return p1;\nend if;\n\n3 若有多个null值,distinct去重时,结果集保留一个null值.\n4 null = null 不成立 null <> null 不成立\n5 若用in运算符,集合中有null值跟没有null值结果一致的,结果集中不会出现跟null值有关的记录\n  若用not in运算符,集合中有null值,这个结果集不包含记录.no rows selected.\n##### 2）各个子句的功能##### \n1 select后面跟列名,列别名,函数,表达式\n2 select后面的distinct:去重\n3 where子句\n  where 条件表达式 (列名 比较运算符 值)  \n表达式 比较运算符 值(尽量不用,为了性能)\n  where子句中的列为字符类型,放值的位置上不加单引号或加双引号当列名解释,加单引号当字符串解释.\n  where子句中的列为字符类型,表达具体值时注意字符是大小写敏感的.\nSQL提供的四个比较运算符\n肯定形式\n   between and 区间,范围\n   in <=> =any  (= or = )(跟集合里的任意一个值相等就满足条件) 集合 离散值\n   = 单值运算符\n   in =any 多值运算符\n   like 像...一样\n   通配符: %表示0或任意多个字符 _任意一个字符\n   'S' 'S%' 'S_'\n   is null  如何判断一个列的取值是否为空\n否定形式\n= <> != ^=\nbetween and   not between and\nin\tnot in (<> and <>) <=> <>all(跟集合里的所有值都不能相等)\nlike \tnot like\nis null   is not null \n各个子句的执行顺序\nfrom-->where-->select\n##### 3）课堂练习##### \n1 列出每个员工的名字和他的工资\n  select ename,salary from emp_hiloo;\n2 列出每个员工的名字和他的职位\n  select ename,job from emp_hiloo;\n3 列出每个员工的名字和他的年薪\n select ename,salary*12 ann_sal from emp_hiloo;\n4 列出每个员工的名字和他一年的总收入\n  (salary+bonus)*12 (15000+null)*12=null\n  select ename,(salary+nvl(bonus,0))*12 tol_sal\n  from emp_hiloo;\n5 输出结果如下:\n  zhangwuji is in department 10.\n  liucangsong is in department 10.\n  .....\n  guojing is in department 30.\nselect ename||'is in department'||deptno||'.'employee from emp_hiloo;\n什么要加employee呢？Employee是列别名为了显示用的。\n6 列出该公司有哪些职位\n  select distinct(job) from emp_hiloo;\n  select distinct job from emp_hiloo;\n7 列出该公司不同的奖金\n  select distinct bonus from emp_hiloo;\n8 各个部门有哪些不同的职位?\n  select distinct deptno,job from emp_hiloo;\n  去重方式:deptno和job联合唯一.\n  distinct之后和from之前的所有列联合唯一.\ndistinct是保证每一行的唯一性而非某一列的唯一性，所以必须紧跟在select后面。\n所以distinct只能放在select后面，紧跟select不然会报缺失表达式错误。\n9 哪些员工的工资高于5000?\n  select ename,salary from emp_hiloo \n  where salary > 5000; \n10 列出员工工资高于5000的员工的年薪?\n  select ename,salary*12 from emp_hiloo\n  where salary > 5000;\n11 列出员工年薪高于60000的员工的年薪?\n  select ename,salary*12 from emp_hiloo\n  where salary*12> 60000;\n  select ename,salary*12 ann_sal from emp_hiloo\n  where ann_sal > 60000(错误的写法)\n  select ename,salary*12 from emp_hiloo\n  where salary > 5000;\n12 zhangwuji的年薪是多少?\nselect ename,salary*12 from emp_hiloo\nwhere ename='zhangwuji';\n  哪些员工的职位是Manager?\nselect ename,job from emp_hiloo\nwhere job='Manager';\n  哪些员工的职位是clerk?\n  select ename,job from emp_hiloo\n  where job = 'Manager'\n   select ename,job from emp_hiloo\n  where job = 'clerk'(效率高)\n  clerk的大小写不清楚\n  函数:upper(),lower()\n  select ename,job from emp_hiloo\n  where upper(job) = 'CLERK' (通用性好)\n13 员工工资在5000到10000之间的员工的年薪\n   select ename,salary*12\n   from emp_hiloo\n   where salary >= 5000 \n   and   salary <= 10000;\n   select ename,salary*12\n   from emp_hiloo\n   where salary between 5000 and 10000;\n14 哪些员工的工资是5000或10000.\n   select ename,salary\n   from emp_hiloo\n   where salary = 5000\n   or salary = 10000\n   select ename,salary\n   from emp_hiloo\n   where salary in (5000,10000)\n   select ename,salary\n   from emp_hiloo\n   where salary =any (5000,10000)\n15 哪个员工的名字的第二个字符是a.\n   select ename\n   from emp_hiloo\n   where ename like '_a%';\n16 哪个员工的名字的第二个字符是_.\n   select ename\n   from emp_hiloo\n   where ename like '_\\_%' escape '\\';\n   第一个_表示任意一个字符,代表通配符\n   \\_必须连起来看,表示下划线本身,escape定义哪个字符可以定义转义'\\'\n17 哪些员工没有奖金?\n   select ename,bonus\n   from emp_hiloo\n   where bonus is null\n18 哪些员工有奖金?\n   select ename,bonus\n   from emp_hiloo\n   where bonus is not null\n19哪些员工的工资不是5000也不是10000.\n  select ename,salary\n  from emp_hiloo\n  where salary not in (5000,10000);\n  select ename,salary\n  from emp_hiloo\n  where salary <> 5000\n  and salary <> 10000\n\ncreate table emp_hiloo\n( hiredate date）\ninsert into emp_hiloo values (1001,'zhangwuji','Manager',10000,2000,'12-MAR-10',1005,10);\n解决方案：\n\tinsert into emp_hiloo values (1001,'zhangwuji','Manager',10000,2000,'12-3月-10',1005,10);\n##### 更改字段名字(mysql、orcle)：##### \nOracle修改表\nalter table 表名 rename column 原名 to 新名；\nMysql:\nalter table 表名 change column(可写，可不写）原名 新名 字段类型；\n\nORA-00904：“ANN_SAL\":invalid identifier\n无效的标识符\n\n\nindex(索引) view(视图) sequence(顺序号/序列号) function(函数)\nsession altered.会话已更改\nset feed on可以设置一个，显示操作数\nconnet tiger重新建立连接  show user查看当前用户是谁。\nedit 用记事本编辑  /运行。\n###Function (单行、多行)###\n单行函数:表中的一列作为函数的参数,对于每一条记录函数都有一个返回值. \n例如:upper lower nvl\n多行函数：表中的一列作为函数的参数,将记录分组,对于每组数据函数返回一个值. \n例如:avg\n####1）单行函数####\n 根据处理参数的数据类型分为\n  ##### 1）字符函数:upper,lower##### \n   ##### 2）数值函数:##### \n     round 四舍五入\n     round(12.345,2)-->12.35\n     round(12.345,0)=round(12.345)-->12\n     round(12,345,-1)-->10\n     trunc 截取\n     trunc(12.345,2)-->12.34\n     trunc(12.345,0)=trunc(12.345)-->12\n     trunc(12,345,-1)-->10\n  ##### 3) 日期和日期函数##### \n    select sysdate from dual\n    06-SEP-12 DD-MON-RR \n    alter session set\n      nls_date_format = 'yyyy mm dd hh24:mi:ss'\n    session 会话 connection(连接)\n   日期类型的数据是用固定的字节7个字节来存储世纪,年,月,日,时,分,秒. 格式敏感\n   会话级 alter session set nls_date_format\n   语句级 select to_char(c1日期类型用7个字节来表达，日期类型的数据是用固定的字节7个字节来存储世纪，年，月，日，时，分，秒。四位年的前两位代表世纪20，后两位代表当前年12\n如果不想修改sql语句运行的话，就需要在执行该语句之前，使用alter session 命令将nls_date_language修改为american，如下：\nalter session set nls_date_language='american'    --以英语显示日期\n如果不想修改sql语句运行的话，就需要在执行该语句之前，使用alter session 命令将\n\n'01-JAN-08' 系统做了隐式数据类型转换,调用了to_date函数\n'2008-01-01',用户做显式数据类型转换,自己调用\nto_date('2008-01-01','yyyy-mm-dd'),第二个参数是对第一个参数的格式说明.\nto_char的返回类型是字符类型,把date转换成了字符串类型,所以参数的数据类型是date.to_char函数可以获得日期的任何一部分信息,比如年,月,日等.\nselect c1 from ... 系统做了隐式数据类型转换,调用了to_char函数\nselect to_char(c1,.. 用户做显式数据类型转换,自己调用to_char(c1,'yyyy-mm-dd'),第二个参数是对第一个参数的格式说明.\n日期的运算\n   日期可以加减一个数值,单位为天.\n   select sysdate-1,sysdate,sysdate+1 from dual\n两个日期相减\n   add_months 按月加 返回类型是date\n   add_months(sysdate,6)\n   select add_months(hiredate,6) from emp_hiloo\n   add_months(sysdate,-6)\n   months_between()  返回类型是number\n   months_between(sysdate,hiredate) 两个日期之间相差多少个月\nselect months_between(sysdate,hiredate) from emp_hiloo;\n   last_day(sysdate) 本月的最后一天\n##### 4) 转换函数#####    \n两个日期相减转换函数\nto_date  char-->date\nto_char  date-->char , number --> char\nto_number  char-->number\n##### 其他函数##### \ncoalesce 类似nvl(oracle专有)\nnvl(bonus,salary*0.1)\ncoalesce(bonus,salary*0.1,100)。输出所有员工的奖金，如果没有奖金就按工资的10%发放，如果奖金和工资都没有的临时工，就给100元。\n不同的记录处理方式不一样时,用case when.\ncase when 条件表达式 then 返回结果\nelse\n     返回结果\nend\n若没有else,当不匹配条件,表达式的返回值为null.\ncase deptno when 10 then(不建议该语法形式)\ndecode跟case when的功能类似.\ndecode(deptno,10,salary*1.1,\n              20,salary*1.2,\n              salary)\n若没有最后一个参数,函数的返回值为null.\nselect语句\norder by子句\nselect   from    where\norder by\norder by子句是select语句中的最后一个子句.\norder by salary 缺省是升序 asc\norder by salary desc 降序\norder by子句后面可以跟列名,表达式(函数),列别名,在select子句中的位置.\nORDER BY 子句\nORDER BY 语句用于对结果集进行排序。\nORDER BY 语句\nORDER BY 语句用于根据指定的列对结果集进行排序。\nORDER BY 语句默认按照升序对记录进行排序。\n如果您希望按照降序对记录进行排序，可以使用 DESC 关键字。\n原始的表 (用在例子中的)：\nOrders 表:\nCompany\tOrderNumber\nIBM\t3532\nW3School\t2356\nApple\t4698\nW3School\t6953\n实例 1\n以字母顺序显示公司名称：\nSELECT Company, OrderNumber FROM Orders ORDER BY Company\n结果：\nCompany\tOrderNumber\nApple\t4698\nIBM\t3532\nW3School\t6953\nW3School\t2356\n实例 2\n以字母顺序显示公司名称（Company），并以数字顺序显示顺序号（OrderNumber）：\nSELECT Company, OrderNumber FROM Orders ORDER BY Company, OrderNumber\n结果：\nCompany\tOrderNumber\nApple\t4698\nIBM\t3532\nW3School\t2356\nW3School\t6953\n实例 3\n以逆字母顺序显示公司名称：\nSELECT Company, OrderNumber FROM Orders ORDER BY Company DESC\n结果：\nCompany\tOrderNumber\nW3School\t6953\nW3School\t2356\nIBM\t3532\nApple\t4698\n实例 4\n以逆字母顺序显示公司名称，并以数字顺序显示顺序号：\nSELECT Company, OrderNumber FROM Orders ORDER BY Company DESC, OrderNumber ASC\n结果：\nCompany\tOrderNumber\nW3School\t2356\nW3School\t6953\nIBM\t3532\nApple\t4698\n注意：在以上的结果中有两个相等的公司名称 (W3School)。只有这一次，在第一列中有相同的值时，第二列是以升序排列的。如果第一列中有些值为 nulls 时，情况也是这样的。\n\n#### 2) 多行函数(哪两个函数里只能放number)####\navg()\t平均值  函数的参数只能是number\nsum()\t求和\t函数的参数只能是number\ncount()\t计数 函数的参数可以是number date 字符\n        count(*)统计记录,count(bonus)\nmax() 最大值 函数的参数可以是number date 字符\nmin() 最小值 函数的参数可以是number date 字符\n\n组函数的缺省处理方式是处理所有的非空值.\navg(bonus) 所有有奖金的员工的平均值\ncount(bonus) 有奖金的员工个数\n当所有的值都是null,count函数返回0,其他组函数返回null.\n\n#### 3) group by子句####\n若有group by子句,select后面跟组标识和组函数\n组标识指group by后面的内容\nfrom-->where-->group by-->select-->order by\n若没有group by子句,select后面只要有一个是组函数,其余的都得是组函数.\n\n#### having子句####\nselect deptno,round(avg(salary)) davg\nfrom emp_hiloo\ngroup by deptno\nhaving round(avg(salary))> 5000\n\nfrom-->where-->group by-->having-->select-->order by \n#### GROUP BY 语句####\nGROUP BY 语句用于结合合计函数，根据一个或多个列对结果集进行分组。\nSQL GROUP BY 语法\nSELECT column_name, aggregate_function(column_name)\nFROM table_name\nWHERE column_name operator value\nGROUP BY column_name\nSQL GROUP BY 实例\n我们拥有下面这个 \"Orders\" 表：\nO_Id\tOrderDate\tOrderPrice\tCustomer\n1\t2008/12/29\t1000\tBush\n2\t2008/11/23\t1600\tCarter\n3\t2008/10/05\t700\tBush\n4\t2008/09/28\t300\tBush\n5\t2008/08/06\t2000\tAdams\n6\t2008/07/21\t100\tCarter\n现在，我们希望查找每个客户的总金额（总订单）。我们想要使用 GROUP BY 语句对客户进行组合。\n我们使用下列 SQL 语句：\nSELECT Customer,SUM(OrderPrice) FROM Orders\nGROUP BY Customer\n结果集类似这样：\nCustomer\tSUM(OrderPrice)\nBush\t2000\nCarter\t1700\nAdams\t2000\n很棒吧，对不对？\n让我们看一下如果省略 GROUP BY 会出现什么情况：\nSELECT Customer,SUM(OrderPrice) FROM Orders\n结果集类似这样：\nCustomer\tSUM(OrderPrice)\nBush\t5700\nCarter\t5700\nBush\t5700\nBush\t5700\nAdams\t5700\nCarter\t5700\n上面的结果集不是我们需要的。\n那么为什么不能使用上面这条 SELECT 语句呢？解释如下：上面的 SELECT 语句指定了两列（Customer 和 SUM(OrderPrice)）。\"SUM(OrderPrice)\" 返回一个单独的值（\"OrderPrice\" 列的总计），而 \"Customer\" 返回 6 个值（每个值对应 \"Orders\" 表中的每一行）。因此，我们得不到正确的结果。不过，您已经看到了，GROUP BY 语句解决了这个问题。\nGROUP BY 一个以上的列\n我们也可以对一个以上的列应用 GROUP BY 语句，就像这样：\nSELECT Customer,OrderDate,SUM(OrderPrice) FROM Orders\nGROUP BY Customer,OrderDate\n#### 4) where和having比较####\n共同点:都执行在select之前,都有过滤功能\n区别\nwhere执行在having之前\nwhere过滤的是记录,任意列名都可以出现在where子句,单行函数可以用在where子句,组函数不能出现在where子句\nhaving过滤的是组,组标识可以出现在having子句,其他列名不行,组函数用于having子句,单行函数不可以.\n##### HAVING 子句##### \n在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与合计函数一起使用。\nSQL HAVING 语法\nSELECT column_name, aggregate_function(column_name)\nFROM table_name\nWHERE column_name operator value\nGROUP BY column_name\nHAVING aggregate_function(column_name) operator value\nSQL HAVING 实例\n我们拥有下面这个 \"Orders\" 表：\nO_Id\tOrderDate\tOrderPrice\tCustomer\n1\t2008/12/29\t1000\tBush\n2\t2008/11/23\t1600\tCarter\n3\t2008/10/05\t700\tBush\n4\t2008/09/28\t300\tBush\n5\t2008/08/06\t2000\tAdams\n6\t2008/07/21\t100\tCarter\n现在，我们希望查找订单总金额少于 2000 的客户。\n我们使用如下 SQL 语句：\nSELECT Customer,SUM(OrderPrice) FROM Orders\nGROUP BY Customer\nHAVING SUM(OrderPrice)<2000\n结果集类似：\nCustomer\tSUM(OrderPrice)\nCarter\t1700\n现在我们希望查找客户 \"Bush\" 或 \"Adams\" 拥有超过 1500 的订单总金额。\n我们在 SQL 语句中增加了一个普通的 WHERE 子句：\nSELECT Customer,SUM(OrderPrice) FROM Orders\nWHERE Customer='Bush' OR Customer='Adams'\nGROUP BY Customer\nHAVING SUM(OrderPrice)>1500\n结果集：\nCustomer\tSUM(OrderPrice)\nBush\t2000\nAdams\t2000\n\n#### 5) DCL#### \nconnect openlab/open123\nselect count(*) from hiloo.emp_hiloo;\n\nconnect hiloo/hiloo123\ngrant select on emp_hiloo to openlab;\n\nconnect openlab/open123\nselect count(*) from hilool.emp_hiloo\n10rows selected\n\nconnect hiloo/hiloo123\nrevoke select on emp_hiloo from openlab;\n\nshow user\nselect count(*) from hiloo.emp_hiloo\n\ncreate synonym emp_hiloo for hiloo.emp_hiloo\n#### 6) 关于null值的讨论####\n1 case when在没有else和decode少一个参数时,返回null.\n2order by bonus,asc升序时null值在最后,desc降序时null在最前.\n3 组函数和null值的关系:1组函数的缺省处理方式是处理所有的非空值.2当所有的值都是null,count函数返回0,其他组函数返回null.\n4若group by的列有null值,所有的null值分在一组.\n课堂练习\n1将每个员工的工资涨12.34567%,用round和trunc分别实现\nselect ename,nvl(trunc(round(salary+salary*0.1234567,2),1),0.0) from emp_hiloo;//自己写的。\n2 将'2008-01-01'插入表中,\n  再将'2008 08 08 08:08:08'插入表中\ninsert into test values\n(to_date('01-JAN-08','DD-MON-RR'));\n\n3找出3月份入职的员工.\nselect ename,hiredate\nfrom emp_hiloo\nwhere to_char(hiredate,'mm') = '03';\nselect ename,hiredate\nfrom emp_hiloo\nwhere to_char(hiredate,'mm') = 3;//可以正常输出winXP下\n'03' = 3  ---> to_number('03') = 3\n字符   数值  缺省系统将字符转成数值\nselect ename,hiredate\nfrom emp_hiloo\nwhere to_char(hiredate,'fmmm') = '03';(错，未选定行，无输出)\n\nselect ename,hiredate\nfrom emp_hiloo\nwhere to_char(hiredate,'fmmm') = '3';(对)\n'03' = '3' (错)\nfm表示去掉前导0或去掉两边的空格.\n4 zhangsanfeng的mgr上显示boss,其他人不变.\nselect ename,empno,\n       nvl(to_char(mgr),'boss') mgr\nfrom emp_hiloo\n函数nvl（“1”，“2”）:如果字符串1是空，就返回字符串”2”\n#### 5十分钟之后####\n select sysdate,sysdate+1/144 from dual;\n解释：Oracle 里面,\n\nsysdate + 1 意思是 当前时间 + 1天\n\nsysdate + 1/24  意思是 当前时间 + 1/24天  也就是1小时后\n\nsysdate+1/144  意思是 当前时间 + 1/144天 （1/24*6）  也就是10分钟后\n 6 若员工是10部门的,工资涨10%,20部门工资涨20%,其他员工工资不变.\nselect ename,salary,\n       case when deptno = 10 then salary*1.1\n            when deptno = 20 then salary*1.2\n       else\n            salary\n       end new_sal\nfrom emp_hiloo;\n\nselect ename,salary, \n       decode(deptno,10,salary*1.1,\n                     20,salary*1.2,\n                     salary) new_sal\nfrom emp_hiloo;\n7 列出每个员工的年薪,按年薪降序排列.\nselect ename,salary*12\nfrom emp_hiloo\norder by salary desc (好)\nselect ename,salary*12\nfrom emp_hiloo\norder by salary*12 desc\nselect ename,salary*12 n_sal\nfrom emp_hiloo\norder by n_sal desc\n\nselect ename,salary*12 n_sal from emp_hiloo order by 2 desc;\nselect salary*12,ename n_sal from emp_hiloo order by 2 asc;\n8 列出员工的名字,部门号以及工资,按部门号从小到大的顺序,同一部门的工资按降序排列.\nselect ename,deptno,salary\nfrom emp_hiloo\norder by deptno,salary desc\n9 列出奖金的平均值,和,个数,最大值,最小值.\nAVG 函数返回数值列的平均值。NULL 值不包括在计算中\nselect avg(bonus),avg(nvl(bonus,0)),\n       sum(bonus), sum(nvl(bonus,0)),\n       count(bonus),count(nvl(bonus,0)),\n       max(bonus),max(nvl(bonus,0)),\n       min(bonus),min(nvl(bonus,0))\nfrom emp_hiloo\n10 各个部门的平均工资\nROUND 函数用于把数值字段舍入为指定的小数位数。\nselect deptno,round(avg(salary))\nfrom emp_hiloo\ngroup by deptno\n11 求10部门的平均工资,只显示平均工资\n   求10部门的平均工资,显示部门号,平均工资\n   select round(avg(salary))\n   from emp_hiloo\n   where deptno = 10\n   group by deptno\n\n   select max(deptno),round(avg(salary))\n   from emp_hiloo\n   where deptno = 10 \n12各个部门不同职位的平均工资\n   select deptno,job,round(avg(salary))\n   from emp_hiloo\n   group by deptno,job\n13 每种奖金有多少人?\n   select bonus,count(empno)\n   from emp_hiloo\n   group by bonus\n14 列出平均工资大于5000的部门的平均工资\n   select deptno,round(avg(salary)) \n   from emp_hiloo\n   group by deptno\n   having round(avg(salary)) > 5000\n15哪些员工的工资是最低的.\n  select ename from emp_hiloo\n  where salary = ( select min(salary)\n                   from emp_hiloo)\n报错信息\nORA-01861: literal does not match format string\n文字值不匹配格式串\nORA-01722: invalid number 无效的数值 to_number\nORA-00937: not a single-group group function 不是一个组函数\nORA-00979: not a GROUP BY expression 不是一个group by表达式 GROUP BY expression指跟在group by后面的东西(列名),称之为组标识\ndetail 细节 summary 聚合\n\n### 查询###\n子查询定义\n在SQL语句中嵌入select语句\ncreate table new_tabname\nas\nselect ename,salary*12 ann_sal from emp_hiloo;\n新表的结构由select后面的项来决定,new_table包含两列ename,ann_sal.\n\n#### 子查询####\n  非关联子查询\n    单列子查询\n    多列子查询\n  关联子查询\n\n##### 子查询执行##### \n非关联子查询\n子查询的表和主查询的表没有建关联\n先执行子查询(只执行一遍),当返回多条记录,系统会将自动去重的结果返回给主查询,再执行主查询.\n\n关联子查询\n子查询的表和主查询的表建关联.所谓建关联指主查询表里的列和子查询表里的列写成一个条件表达式.\n\n先执行主查询,判断表里的记录是否应该放入结果集.过程如下:拿到第一条记录,获得了各个列的值,将需要的列值带入子查询,执行后返回的结果再和主查询表里的列做比较,符合条件,该记录放入结果集,否则过滤掉.依次执行主查询表里的每条记录.子查询执行的次数由主查询表里的记录数决定.\n\n1) exists和not exists\nexists的执行过程\n从主查询表里拿到第一条记录,按子查询里的关联条件在子查询的表里看是否能找到匹配的记录,当找到第一条匹配的记录后,立即返回(即不需要找出所有匹配的记录),exists条件满足,主查询表里的该记录放入结果集.若按子查询里的关联条件将子查询\n表里的记录全部检查一遍后没有一条符合条件的记录,此时也返回, exists 条件不满足,主查询表里的该记录不能放入结果集,被过滤掉.\n\nselect ename from emp_afei o\nwhere exists\n             (select 1 from emp_afei i\n              where o.empno = i.mgr)\n\n##### 非关联子查询的分类##### \n单列子查询\nselect ename,salary\nfrom emp_hiloo \nwhere salary = (select min(salary)\n                from emp_hiloo \n                )\n多列子查询:按键值对比较\nselect ename,salary,deptno\nfrom emp_afei\nwhere (deptno,salary) in\n             (select deptno,round(avg(salary))\n              from emp_afei\n              group by deptno)\n\n2) 课堂练习\n1哪些人是领导?(非关联子查询)\n如果一个员工的empno能出现在mgr里就说明他是领导.\nselect ename\nfrom emp_hiloo\nwhere empno in (select mgr from emp_hiloo)\nselect ename\nfro emp_afei\nwhere empno in (1001,1005,1006,1008,null)\n2 哪些人是员工?\n他的empno绝对不能出现在mgr中,他的empno跟mgr的出现的所有的值不能相等. <>all\nselect ename\nfrom emp_hiloo\nwhere empno not in (select mgr from emp_hiloo)\nselect ename\nfro emp_afei\nwhere empno not in (1001,1005,1006,1008,null)\nselect ename\nfrom emp_hiloo\nwhere empno not in (select mgr from emp_hiloo\n                    where mgr is not null)\n\n3哪些部门的平均工资比30部门的平均工资高?\nselect deptno,round(avg(salary))\nfrom emp_hiloo\ngroup by deptno\nhaving round(avg(salary)) >\n                    (select round(avg(salary))\n                     from emp_hiloo\n                     where deptno = 30)\n4哪些员工的工资比zhangwuji的工资高?\nselect ename,salary\nfrom emp_afei\nwhere salary > (select salary from emp_afei\n                where ename = 'zhangwuji')\nERROR at line 3:\nORA-01427: single-row subquery returns more than one row\n单行子查询返回多条记录\n\n比所有人高 > (select max(salary))\n           >all\n比任意人高 > (select min(salary)\n           >any\n5哪些员工的工资等于本部门的平均工资?\nselect ename,salary,deptno\nfrom emp_afei\nwhere (deptno,salary) in\n             (select deptno,round(avg(salary))\n              from emp_afei\n              group by deptno)\n5哪些员工的工资比本部门的平均工资高?\nselect ename,salary,deptno\nfrom emp_afei o\nwhere salary > (select round(avg(salary))\n                from emp_afei i\n                where i.deptno = o.deptno)\n6哪些人是领导?(关联子查询)\nselect ename from emp_afei o\nwhere exists\n             (select 1 from emp_afei i\n              where o.empno = i.mgr)\n7哪些部门有员工?\nselect deptno,dname\nfrom dept_afei o\nwhere exists (select 1 from emp_afei i\n              where o.deptno = i.deptno)\n\n3) 课外练习day03am\n1 zhangwuji的领导是谁,显示名称?\n2 zangwuji领导谁,显示名称?\n3 列出devoleper部门有哪些职位?\n1) 课外练习day04am答案\n1 zhangwuji的领导是谁,显示名称?\n  select ename from emp_afei\n  where empno in \n\t\t(select mgr from emp_afei\n                 where ename = 'zhangwuji')\n\nzangwuji领导谁,显示名称?\n\n select ename from emp_afei\n where mgr in (select empno from emp_afei\n               where ename = 'zhangwuji')\n\n3 列出developer部门有哪些职位?\n  select distinct job from emp_afei\n  where deptno in \n           (select deptno from dept_afei\n            where dname = 'developer')\n\n2) 非关联子查询               \nexists和not exists\nnot exists的执行过程\n从主查询表里拿到第一条记录,按子查询里的关联条件在子查询的表里看是否能找到匹配的记录,当找到第一条匹配的记录后,立即返回(即不需要找出所有匹配的记录),not exists条件不满足,主查询表里的该记录不能放入结果集,被过滤掉.若按子查询里的关联条件将子查询表里的记录全部检查一遍后没有一条符合条件的记录,返回, not exists 条件满足,主查询表里的该记录放入结果集.\n\n对于exists和not exists,在子查询中找到第一条匹配的记录都会立即返回,exists将主查询表里的记录放入结果集,not exsits将主查询表里的记录过滤掉.\n对于exists和not exists,如果子查询没有返回任何记录,即扫描全部记录后没有一条符合条件的记录,都返回,exists将主查询表里的记录过滤掉,not exists将主查询表里的记录放入结果集. \nnot in ,<> all逻辑上跟not exists等价\nin ,=any逻辑上跟exists等价\n\n查询形式:集合操作\n把结果集作为一个集合,结果集必须是同构的,列的个数及数据类型一致\n\n3) 并集  union(去重)/union all(不去重)\nselect ename,deptno,salary,salary*1.1 new_sal\nfrom emp_afei\nwhere deptno = 10\nunion all\nselect ename,deptno,salary,salary*1.2 new_sal\nfrom emp_afei\nwhere deptno = 20\nunion all\nselect ename,deptno,salary,salary new_sal\nfrom emp_afei\nwhere deptno not in (10,20)\n\ncase when和decode可以实现类似功能.\n\n4) 交集  intersect(去重)\nselect job from emp_afei\nwhere deptno = 10\nintersect\nselect job from emp_afei\nwhere deptno = 20\n10部门和20部门都有的职位是哪些?\n\n5) 差  minus(去重)\nselect deptno from dept_afei\nminus\nselect deptno from emp_afei\n那些部门没有员工.\n\n6) 多表查询\n1) 交叉连接 cross join\nselect e.ename,d.dname\nfrom emp_afei e cross join dept_afei d\n结果集产生\n10*4=40,组合操作,笛卡尔积\n\n2) 内连接 inner join(匹配一个条件)\nselect e.ename,e.deptno,d.deptno,d.dname\nfrom emp_afei e join dept_afei d\nORA-00905: missing keyword(丢失关键字)\n\n如果把结果集的产生看成双层循环,驱动表是外层循环,匹配表是内层循环.\n对于内连接哪张表做驱动表,哪张表做匹配表产生出的结果集是一样的,不同的是性能.\n驱动表在匹配表的匹配情况如下:\n一条记录找到一条匹配\n一条记录找到多条匹配\n一条记录找不到任何匹配.\n内连接的核心是驱动表的记录要出现在结果集中必须在匹配表中能找到匹配的记录,否则该记录被过滤掉.\n\n3) 内连接查询形式\n等值连接 on e.deptno = d.deptno\n两张表有表述同一属性的列,两张表都有deptno列.\n自连接 on e.mgr = m.empno\n同一张表的不同列能写成一个表达式,即同一张表的两条记录之间有关系.通过给表起别名的方式,将同一张表的两条记录之间的关系转化成不同表的两条记录之间的关系.\n4) 外连接\n外连接 outer join(驱动表的记录一个都不能少的出现在结果集里)\nfrom t1 left join t2\non t1.c1 = t2.c2(t1驱动表,t2匹配表)\n外连接结果集=内连接的结果集+t1表中匹配不上的记录和t2表中的null记录的组合\nfrom t1 right join t2\non t1.c1 = t2.c2(t2驱动表,t1匹配表)\n外连接结果集=内连接的结果集+t2表中匹配不上的记录和t1表中的null记录的组合\nfrom t1 full join t2\non t1.c1 = t2.c2\n外连接结果集=内连接的结果集+t1表中匹配不上的记录和t2表中的null记录的组合+t2表中匹配不上的记录和t1表中的null记录的组合\n\n5) 外连接的应用场景\n1 某张表的记录全部出现在结果集中,包括匹配不上的.\nselect e.ename,nvl(m.ename,'Boss')\nfrom emp_afei e left join emp_afei m\non e.mgr = m.empno\n2解决否定问题,匹配不上的记录找出来(跟所有的记录都不匹配.)(not in/not exists)\n外连接 + where 匹配表.主键列 is null\nselect e.ename,d.dname\nfrom emp_afei e right join dept_afei d\non e.deptno = d.deptno\nwhere e.empno is null\n(解决结果集只包含匹配不上的记录.where子句执行在外连接之后)哪些部门没有员工\n\nselect d.dname\nfrom emp_afei e right join  dept_afei d\non e.deptno = d.deptno\nand e.ename = 'zhangwuji'\nwhere e.empno is null\n如果希望在外连接之前过滤匹配表用and子句,如果想在外连接之后通过匹配表里的列过滤外连接的结果集时候用where.\n过滤驱动表统计用where子句过滤.\n\n6) 课内练习\n1 哪些部门没有员工(not exists)\n  select dname from dept_afei o\n  where not exists \n        (select 1 from emp_afei i\n         where o.deptno = i.deptno)\n2 哪些人是员工?(not exists)\n  select ename from emp_afei o\n  where not exists \n            (select 1 from emp_afei i\n             where o.empno = i.mgr)\n他的empno和其他人的mgr相等是不可能存在的.即和所有人的mgr都不相等.\nnot in ,<> all逻辑上跟not exists等价\n3 列出哪些员工在北京地区上班?\n思路:确定表,两张表,匹配问题用inner join-->on(匹配条件)-->(对表是否过滤)\nselect e.ename,e.deptno,d.deptno,d.dname\nfrom emp_afei e join dept_afei d\non e.deptno = d.deptno\nand d.location = 'beijing'\n4zhangwuji在哪个地区上班?\nselect e.ename,d.dname,d.location\nfrom emp_afei e join dept_afei d\non e.deptno = d.deptno\nand e.ename = 'zhangwuji'\n5列出每个部门有哪些职位?部门名称,职位\n select distinct d.dname,e.job\n from emp_afei e join dept_afei d\n on e.deptno = d.deptno\n order by d.dname\n6各个部门的平均工资,列出部门名称,平均工资.\nselect d.dname,round(avg(e.salary)) savg\nfrom emp_afei e join dept_afei d\non e.deptno = d.deptno\ngroup by d.dname\nselect max(d.dname),round(avg(e.salary)) savg\nfrom emp_afei e join dept_afei d\non e.deptno = d.deptno\ngroup by d.deptno\nselect min(deptno),round(avg(salary))\nfrom emp_hiloo\nwhere deptno = 10\n7 列出每个员工的名字和他的领导的名字\nselect e.ename employee,\n       m.ename manager\nfrom emp_afei e join emp_afei m\non e.mgr = m.empno\n结果集是9条.\ne表中有10条记录,其中9条记录找到匹配,zhangsanfeng没匹配\nm表中有10条记录,其中4条记录找到匹配,4条记录是领导,6条记录找不到匹配,他们是员工.\nselect e.ename employee,\n       m.ename manager\nfrom emp_afei e join emp_afei m\non e.mgr = m.empno\nunion all\nselect ename,'Boss'\nfrom emp_afei\nwhere mgr is null\n\nselect e.ename employee,\n       decode(m.ename,e.ename,'Boss',\n                  m.ename)   manager\nfrom emp_afei e join emp_afei m\non nvl(e.mgr,e.empno) = m.empno\n\nselect e.ename,nvl(m.ename,'Boss')\nfrom emp_afei e left join emp_afei m\non e.mgr = m.empno\n10=9+1\n\n8哪些人是领导?\nselect distinct m.ename\nfrom emp_afei e join emp_afei m\non e.mgr = m.empno\n9哪些部门没有员工?\nselect e.ename,d.dname\nfrom emp_afei e right join dept_afei d\non e.deptno = d.deptno\nwhere e.empno is null\n(解决结果集只包含匹配不上的记录.where子句执行在外连接之后)\n11=10+1\n如果部门表里的某条记录的deptno在emp表找不到匹配,在内连接中,它被过滤,\ne表的empno的特性是唯一且非空的(主键约束),居然e.empno is null,说明null是外连接时为了驱动表中那条匹配不上的记录出现在结果集中,在匹配表中模拟的null记录.\n10哪些人是员工,哪些人不是领导?\nselect e.empno,m.ename\nfrom emp_afei e right join emp_afei m\non e.mgr = m.empno\nwhere e.empno is null\n\nfrom emp_afei e right join emp_afei m\n15=9+(10(m表中有10条记录)-4(m表中有4条匹配记录 ))\nfrom emp_afei e left join emp_afei m\n10(结果集)=9+(10(e表中有10条记录)-9(e表中有9条匹配记录))\n11 哪些部门没有叫zhangwuji的?\nselect d.dname\nfrom emp_afei e right join  dept_afei d\non e.deptno = d.deptno\nand e.ename = 'zhangwuji'\nwhere e.empno is null\n\n7) 课外练习(day04)(答案在Day05)\n1zhangwuji的领导是谁?(表连接)\n2zhangwuji领导谁?(表连接)\n3哪些人是领导?(in exists join)\n4哪些部门没有员工?(not in/not exists/outer join)\n5哪些人是员工,哪些人不是领导?(not in/not exists/outer join)\nDay05.txt\nGrade级别\nLowsal最低工资\nHisal最高工资\nCreate table salgrade_hiloo(\nGrade \n)\ncross join  inner join   outer join\ninner join(匹配)\n  等值连接\n  自连接\n  非等值连接\nouter join(匹配+不匹配)\n  等值连接\n\n  自连接\n  非等值连接\n\n所谓非等值连接表示两张表里的列不能写成等值表达式,而是写成between and之类.所以两个表之间有关系是指表里的列可以写成表达式,而不是等值表达式.\nsalgrade\ngrade  级别\nlowsal 最低工资\nhisal  最高工资\n\nfrom后面跟子查询\nemp,各个部门的平均工资dept_avgsal(depnto,avgsal)\nselect e.ename,e.salary,e.deptno\nfrom emp_afei e join\n      (select deptno,round(avg(salary)) avgsal\n       from emp_afei \n       group by deptno) a\non e.deptno = a.deptno\nand e.salary > a.avgsal\n\n各个部门的平均工资,列出部门名称,平均工资\nselect max(d.dname),round(avg(salary))\nfrom emp_afei e join dept_afei d\non e.deptno = d.deptno\ngroup by d.deptno\n\nselect d.dname,a.avgsal\nfrom dept_afei d join\n      (select deptno,round(avg(salary)) avgsal\n       from emp_afei \n       group by deptno) a\non d.deptno = a.depto\n\nDML\ninsert一条记录时,若某些列为null值,有哪些语法实现?\ninsert into tabname values (1,'a',null,sysdate)\ninsert into tabname(c1,c2,c4)\nvalues (1,'a',sysdate)\ninsert语句的两种语法形式?\ninsert into tabname values () insert一条记录\ninsert into tabname\nselect * from tabname1  insert多条记录\n连接图解：\n    \n\n### 数据类型###\n1) 课外练习答案day04\n1zhangwuji的领导是谁?(表连接)\n select m.ename\n from emp_afei e join emp_afei m\n on e.mgr = m.empno\n and m.ename = 'zhangwuji'\n2 zhanghangwuji领导谁?(表连接)\n select e.ename\n from emp_afei e join emp_afei m\n on e.mgr = m.empno\n and m.ename = 'zhangwuji'\n3哪些人是领导?(in exists join)\n select ename from emp_afei\n where empno in (select mgr from emp_afei)\n select ename from emp_afei o\n where exists\n            (select 1 from emp_afei i\n             where o.empno = i.mgr)\n select distinct m.ename\n from emp_afei e join emp_afei m\n on e.mgr = m.empno\n4哪些部门没有员工?(not in/not exists/outer join)\n select dname from dept_afei\n where deptno not in \n               (select deptno from emp_afei)\n select dname from dept_afei o\n where not exists \n             (select 1 from emp_afei i\n              where o.deptno = i.deptno)\n select d.dname\n from emp_afei e right join dept_afei d\n on e.deptno = d.deptno\n where e.empno is null\n5哪些人是员工,哪些人不是领导?(not in/not exists/outer join)\n select ename from emp_afei\n where empno not in (\n               select mgr from emp_afei\n               where mgr is not null)\n select ename from emp_afei o\n where not exists\n             (select 1 from emp_afei i\n              where o.empno = i.mgr)\n select m.ename\n from emp_afei e right join emp_afei m\n on e.mgr = m.empno\n where e.empno is null\ncross join (笛卡尔积)\n\nrownum 伪列,记录号\n若用rownum选择出记录,编号必须从1开始.\n分页问题\n第一页\nselect rownum,ename\nfrom emp_afei\nwhere rownum <= 3;\n第二页\nselect rn,ename\nfrom (\n      select rownum rn,ename\n      from emp_afei\n      where rownum <= 6)\nwhere rn between 4 and 6\n排名问题\n按工资排名的前三条记录\nselect rownum,ename,salary\nfrom emp_hiloo\nwhere rownum <=3\norder by salary desc;(错)\n\nselect rownum,ename,salary\nfrom ( select ename,salary\n       from emp_afei\n       order by salary desc)\nwhere rownum <= 3\n\nupdate语句的中set后面的=是什么含义?where后面的=是什么含义?\nset c1 = null (= 赋值)\nwhere c1 = null (= 等号)\n\nupdate和delete语句中的where子句是什么含义?\n用来确定对表里的哪些记录要进行update或delete操作,没有where子句多表里的所有记录update或delete\nupdate\nset\nwhere c1 = (select ...)\nrename 关键字 17\ncommit\n\n1011 abc 1000 10 'clerk'\nupdate 1001 1000-->2000\ndelete 1011\ncommit\n如何编写和运行一个sql脚本(文本文件)\n1 编辑文件\n在linux环境下已经编写好了test.sql,做一个鼠标右键的copy\n\n在20,23,26机器上,\nvi test.sql\n按a i o进入编辑模式,paste,按esc键,再按:wq!回车\n\n2 运行文件\nsun-server% sqlplus openlab/open123 @test.sql\n@表示运行\nSP2-0310: unable to open file \"test.sql\"在当前目录下没有test.sql文件\nsqlplus openlab/open123 ../test.sql\n\ncd ..\nsun-server% sqlplus openlab/open123 @test.sql\n\nSQL>@test.sql\n\n数据库对象 PL/SQL\ncreate or replace function test\ninsert into test values (1,1)\n            *\nERROR at line 1:\nORA-04044: procedure(存储过程), function(函数), package(包), or type is not allowed here\n\n事务(transaction 交易)\n事务里包含的DML语句\n事务的结束\ncommit 提交,(dml操作的数据入库了)\nrollback 回滚 撤销(DML操作被取消)\nsqlplus正常退出=commit\nDDL语句自动提交\n开始\n上一个事务的结束是下一个事务的开始.\n一致状态\n数据库的数据被事务改变.\noltp online transaction processing联机事务处理系统 高并发系统\n\n事务的隔离级别 read committed(读已经提交了的数据)\n\n\n如果不commit----->commit rollback\n1如果不commit,其他session是看不见你的操作\n2如果不commit,会阻塞操作同一条记录的事务(session),commit才能释放所有DML加的锁.\n3如果不commit,系统做DML操作,会将old data放入rollback segment(回滚段) ,所占用的回滚段资源不释放.\n\nDML系统会自动给表及表里的记录加锁\n表级共享锁\n行级排他锁\n\t表级共享锁 \t行级排他锁\ns1\tok\t\tok\ns2\tok\t\tenqueue wait\ns3\tok\t\tok\n\n执行DDL语句,系统自动加DDL排他锁\nSQL> drop table test purge;\ndrop table test purge\n           *\nERROR at line 1:\nORA-00054: resource busy(资源忙 test表) and acquire with NOWAIT specified (dml wait,ddl nowait 如果加不上锁,报错退出)\n\nDDL语句\n字符类型\nvarchar2,必须带宽度, 按字符串的实际长度存,本身的数据是变化,对空格敏感\nchar,可以不带宽度,缺省宽度是1,按字符串的定义长度存,本身的数据是固定长度的.对空格不敏感\n数值类型\n\nnumber类型\ncreate table test90\n(c1 number,\n c2 number(6),\n c3 number(4,2),\n c4 number(2,4),\n c5 number(3,-3))\n\n四舍五入\nnumber(6) 表示6为整数 999999\nnumber(4,2) 表示小数点后2位,整数位2位 99.99\nnumber(2,4) 表示小数点后4位,能填数字的位数是2位 0.0099\nnumber(3,-3) 999000 999123-->999000 \n                    999511-->报错\n\nuser_tables 是一张系统表,里面记录当前用户所有的表的信息,里面没有记录表的创建日期.\nuser_objects 是一张系统表,里面记录当前用户所有的数据库对象的信息.created的列记录数据库对象(如表)的创建日期.\nuser_tables和user_objects这两张表的关系体现在table_name和object_name都记录的是表名.\n\ndata block 数据块,操作数据的最小逻辑(物理)单元,最少读一个block的数据\n\nHWM high water mark 高水位线,表示曾经插入数据的最高位置\nFTS full table scan 全表扫描,把表里的所有记录读一遍,把HWM之下的所有data block读一遍\n\ntruncate table 释放空间,HWM下移\ndelete 不释放空间,HWM不动\n不适合用delete命令删大表.\n\n课内练习\n1 列出工资级别为3级,5级的员工\n  select e.ename,e.salary,s.grade\n  from emp_afei e join salgrade_afei s\n  on e.salary between s.lowsal and s.hisal\n  and s.grade in (3,5)\n2 列出各个工资级别有多少人?\n  select s.grade,count(e.empno)\n  from emp_afei e join salgrade_afei s\n  on e.salary between s.lowsal and s.hisal\n  group by s.grade\n  order by s.grade\n3 列出各个工资级别有多少人?(包含0级)\n  select s.grade,count(e.empno)\n  from emp_afei e right join salgrade_afei s\n  on e.salary between s.lowsal and s.hisal\n  group by s.grade\n  order by s.grade\n特别注意count不要写*或者s.grade\n\n课外练习day05\n1按工资排名的第4到第6名员工.\n###关键点###\n课外练习day05答案\n\n按工资排名的第4到第6名员工.\nselect rn,ename,salary\nfrom \n    (select rownum rn,ename,salary\n     from (select ename,salary\n           from emp_afei\n           order by salary desc)\n     where rownum <= 6\n    )\nwhere rn >= 4 \n\n####1）事务####\n\n####约束 constraint (安检)####\nprimary key(主键)\nforeign key(外键)\nunique key (唯一键)\nnot null(非空)\ncheck (检查)\n\n主键 (表中不会出现重复记录)\n列级约束\ncreate table test\n(c1 number(2) \n    constraint test_c1_pk primary key,\n c2 number(3))\n\n    constraint test_c1_pk primary key,\n               *\nERROR at line 3:\nORA-02264: name already used by an existing constraint (名字被存在的约束使用了)\n\nSQL> select table_name from user_constraints\n  2  where constraint_name = 'TEST_C1_PK';\n哪张表里有叫TEST_C1_PK这个约束名.\n\nORA-00001: unique constraint (HILOO(用户名) .TEST_C1_PK) violated(冲突)\n\nPK=UK + NN\n\n表级约束\ncreate table test(\nc1 number(2),\nc2 number,\nconstraint test_c1_pk primary key(c1)\n)\n表中有三列c1,c2,c3,c1和c2做成联合主键\ncreate table test(\nc1 number,\nc2 number,\nconstraint test_c1_c2_pk primary key(c1,c2),\nc3 number\n)\n没有constraint关键字,系统用自动起名字sys_c数字.\n\nnot null\ncreate table test\n(c1 number constraint test_c1_pk primary key,\n c2 number not null);\nnot null约束没有表级形式\n\nunique (pk)\n相同点:都要保证唯一性\n区别:uk允许为null,而且可以多个null值,一个表中只能有一个pk约束,可以有多个uk约束.\ncreate table test\n(c1 number constraint test_c1_pk primary key,\n c2 number constraint test_c2_uk unique)\n\ncreate table test(\nc1 number primary key,\nc2 number primary key,\nc3 number unique,\nc4 number unique)  (报错,一张表只能有一个primary key)\n\ncreate table test(\nc1 number constraint test_c1_pk primary key,\nc2 number constraint test_c2_uk unique,\nc3 number constraint test_c3_uk unique,\nc4 number ) \nc2上定义了一个唯一键 c3上定义了一个唯一键\n\ncreate table test(\nc1 number constraint test_c1_pk primary key,\nc2 number,\nc3 number,\nconstraint test_c2_c3_uk unique (c2,c3),\nc4 number)\nc2,c3联合唯一键\n\ncheck\ncreate table test(\nc1 number(3) constraint test_c1_ck\n             check (c1 > 100))\n\ncreate table test(\nc1 number(3),\nconstraint test_c1_ck check (c1 > 100))\n\n外键\nparent table(父表)上定义唯一列(pk/uk)\nchild table(子表)上定义外键列(fk)\n\n1 先create parent table(pk/uk),再create child table(fk)\n2 先insert into parent table,再insert into child table\n3 先delete from child table,再delete from parent table\n4 先drop child table,再drop parent table\n\nreference 引用\ncreate table parent\n(c1 number(3))\n\ncreate table child\n(c1 number(2) constraint child_c1_pk\n              primary key,\n c2 number(3) constraint child_c2_fk\n              references parent(c1))\n\n              references parent(c1))\n                                *\nERROR at line 5:\nORA-02270: no matching unique or primary key for this column-list\n在c1上没有定义uk或pk\n\nalter table parent\nadd constraint parent_c1_pk primary key(c1);\n给c1列增加主键约束\n\ninsert into child values (1,1)\nORA-02291: integrity constraint(完整性约束) (HILOO.CHILD_C2_FK) violated - parent key not found (父键值没发现)\n违反fk约束\n\ninsert into parent values (1);\ninsert into child values (1,1)\n\ndelete from parent where c1 = 1;\nORA-02292: integrity constraint (HILOO.CHILD_C2_FK) violated - child record\nfound(子记录被发现)\n\ndelete from child where c2 = 1;\ndelete from parent where c1 = 1;\n\ndrop table parent purge;\nORA-02449: unique/primary keys in table referenced by foreign keys\n在parent table上的pk/uk正在fk所引用\n\ndrop table child purge;\ndrop table parent purge;\n\ndrop table parent cascade constraints purge;\ncascade constraints 级联约束,child table本身没被删除,只是先把子表上的fk约束删除,再删parent table.\n\n表级约束\ncreate table child\n(c1 number(2) constraint child_c1_pk \n              primary key,\n c2 number(3),\n constraint child_c2_fk foreign key(c2)\n            references parent(c1)\n)\n\n外键约束另外两种定义方法\ncreate table child1\n(c1 number(2) constraint child1_c1_pk\n              primary key,\n c2 number(3) constraint child1_c2_fk\n              references parent(c1)\n              on delete cascade)\non delete cascade :级联删除会影响到对parent table的删除,先delete from child1,再delete from\nparent\n\ndelete from parent where c1 = 1;\ncreate table child2\n(c1 number(2) constraint child2_c1_pk\n              primary key,\n c2 number(3) constraint child2_c2_fk\n              references parent(c1)\n              on delete set null)\n\ndelete from parent where c1 = 1\n等价于以下操作\nSQL> update child2 set c2 = null\n  2  where c2 = 1;\nSQL> delete from parent where c1 = 1;\n\ntable \nDDL(数据类型 约束)\ntransaction (包含一堆DML)\n\n4000\n100 \n1000\n3100\n\n视图(view)\ncreate table test_t1\nas\nselect * from test\nwhere c1 = 1;\ncreate or replace view test_v1\nas\nselect * from test\nwhere c1 = 1;\ndesc test_v1\nselelct * from test_v1\n\ninsert into test values (1,3);\nselect * from test_v1 (1,3)\ninsert into test_v1 values (1,4)\nselect * from test_v1;\nselect * from test;\ninsert into test_v1 values (2,3);\nselect * from test_v1;(没有)\nselect * from test;(2,3)\n\ndrop table test purge;\nselect * from test_v1; \nSQL> desc test_v1\nERROR:\nORA-24372: invalid object for describe\n无法描述无效对象的结构\n\nSQL> select text from user_views\n  2  where view_name = 'TEST_V1';\n\nTEXT\n-----------------------------------------\nselect \"C1\",\"C2\" from test\nwhere c1 = 1\n\nview是一条select语句. select语句中包含的表为源表.通过view对源表做DML操作.\n\nview作用\n1 create view (deptno = 30)\n  grant view to user\n  限定用户查询的数据 子集\n2 简化查询语句\n3 create view beijing\n  as\n  select * from haidian\n  union all\n  select * from xicheng\n...\n  超集\nview的类型\n1 简单view (DML)\n2 复杂view  (不能DML)\n\ncreate or replace view avgscore_v\nselect s.name,a.avgscore\nfrom student s,\n     (select sid,round(avg(score)) avgscore\n      from stu_cour\n      group by sid) a\non s.id = a.sid\n\nview的约束\ncreate or replace view test_ck\nas\nselect * from test\nwhere c1 = 1\nwith check option;\nc1=2,违反where条件,2,3记录insert时报错\n\ncreate or replace view test_ro\nas\nselect * from test\nwhere c1 = 1\nwith read only;\n只读视图\n#### 索引####\ncreate index test_c1_idx\non test(c1);\n对索引不能做desc,select,DML操作\nrowid 代表一条记录的物理位置\n属于哪个数据对象(table)\n属于哪个数据文件的\n属于数据文件的第几个数据块\n属于数据块里的第几条记录\n#### index的结构####\nindex记录rowid\nindex的结构是一棵平衡树,有三类数据块组成,根节点,分支节点,叶子节点,数据块的数据是排序的.根节点和分支节点用于导航,里面记录下一级节点的物理位置以及该节点包含的数据范围.叶子节点里记录的是index entry(索引项),由key值和rowid组成,key值是建索引的列在每条记录上的取值,rowid是记录的物理位置,所有的叶子节点做成双向链表(升序/降序),适用于范围查询.\n用索引查询的路线图,从根节点出发,找相应的分支节点,叶子节点,最后要找到index entry,通过rowid定位\n表里所需要的数据块,避免了全表扫描.\n\n索引为什么提高查询效率,为select语句\n有效地降低了读取数据块的数量.读取数据块,一种从文件里读,物理读 physical read,一种从内存读,逻辑读 logical read /buffer gets\n\n建索引代价\n空间,DML变慢\n\n\n#### 哪些列适合建索引####\n1 经常出现在where子句的列\n2 pk/uk列\n3 经常出现在表连接的列\n4 fk列 parent.pk列 = child.fk列\n5 经常用于group by,order by的列\n7 where c1 is null(全表扫描),索引里不记null值,\n 该列有大量null值,找not null值用索引会快\n\n#### 索引类型####\n非唯一性索引,提高查询效率\n唯一性索引,解决唯一性.等价建唯一性约束\ncreate unique index test_c2_idx\non test(c2);\n\ninsert into test (c2) values (1)\n*\nERROR at line 1:\nORA-00001: unique constraint(HILOO.TEST_C2_IDX ) violated\n\n联合索引\ncreate index test_c1_c2_idx\non test(c1,c2)\nwhere c1 = 1 and c2 = 1\n\nselect ename from emp_hiloo\nwhere salary*12 > 60000\nwhere salary > 5000\n如果salary建索引,where salary > 5000(用),where salary*12 > 60000(不能用)\n\nwhere upper(ename) = 'ZHANGWUJI'\n\nwhere c1 = 100 c1是varchar2类型\nwhere to_number(c1) = 100\n\nwhere ename like 'a%'\nwhere substr(ename,1,1) = 'a'\n\ndeptno not in (20,30)\ndepotno in (10)\n\n#### 函数索引####\ncreate index test_c1_funidx\non test(round(c1));\nwhere round(c1) = 10\n\ncreate index student_name_idx\non student(name);\n\n#### 序列号####\nsequence\n为table里的主键服务,产生主键值\n唯一值产生器\nsequence_name.nextval\n\n为student表的id建sequence\ninsert into student(student_id.nextval...\n为course表的id建sequence\ninsert into course (course_id.nextval...\n\n创建序列如下：\ncreate sequence SEQ_TEST100\nminvalue 1\nmaxvalue 999999999999999999999999999\nstart with 11\nincrement by 1\ncache 10;\n\n函数\ncreate or replace function dept_avgsal\n(p_deptno number) --定义参数,数据类型不能有宽度\nreturn number    --定义函数的返回类型\nis\n  v_salary emp_hiloo.salary%type;     --变量v_salary 的类型跟表emp_hiloo里的salary的类型定义一致\nbegin\n  select round(avg(salary)) into v_salary\n  from emp_hiloo\n  where deptno = p_deptno;    --select当且仅当返回一条记录用select into语法,表示把select语句的执行结果赋值给v_salary\n  return v_salary;       --返回函数值 \nend;\n.不运行,回到SQL>下\n/表示运行\nshow error\nSQL> select dept_avgsal(10) from dual;\n\n\n\n\n\n练习\n用语法实现多对多关系\nstudent\nid pk\nname not null\n\ncourse\nid pk\nname not null\n\nstu_cour\nsid fk -->student(id)\ncid fk -->course(id)\npk(sid,cid)\nscore check [0,100](between and) \n#### 数据库日期比较####\nSql代码：\n1\ttimesten内存数据库比较日期是不是同一天,低效的方法  \n2\tto_char(create_date,'yyyymmdd')=to_char(sysdate NUMTODSINTERVAL(60*60*24,'SECOND'),'yyyymmdd')  \n3\toracle 数据库低效的方法  \n4\tto_char(create_date,'yyyymmdd')=to_char(sysdate-1,'yyyymmdd')   \n5\t2个数据库通用高效的方法  \n6\ttrunc(create_date)=trunc(sysdate)-NUMTODSINTERVAL(1,'DAY')  \n查找数据库里的表，索引等\n支持oracle的模糊查询如select * from user_tables where table_name like '%_PROJECT';查表名以PROJECT结尾的表（注：区别大小写）\n查所有用户的表在all_tables\n主键名称、外键在all_constraints\n索引在all_indexes\n但主键也会成为索引，所以主键也会在all_indexes里面。\n具体需要的字段可以DESC下这几个view，dba登陆的话可以把all换成dba。\n\n查询用户表的索引(非聚集索引):\nselect * from user_indexes\nwhere uniqueness = 'NONUNIQUE'\n\n查询用户表的主键(聚集索引):\nselect * from user_indexes\nwhere uniqueness = 'UNIQUE'\n\n1、\t查找表的所有索引（包括索引名，类型，构成列）：\nselect t.*,i.index_type from user_ind_columns t,user_indexes i where t.index_name = i.index_name and t.table_name = i.table_name and t.table_name = 要查询的表\n2、查找表的主键（包括名称，构成列）：\nselect cu.* from user_cons_columns cu, user_constraints au where cu.constraint_name = au.constraint_name and au.constraint_type = 'P' and au.table_name = 要查询的表\n3、查找表的唯一性约束（包括名称，构成列）：\nselect column_name from user_cons_columns cu, user_constraints au where cu.constraint_name = au.constraint_name and au.constraint_type = 'U' and au.table_name = 要查询的表\n4、查找表的外键（包括名称，引用表的表名和对应的键名，下面是分成多步查询）：\nselect * from user_constraints c where c.constraint_type = 'R' and c.table_name = 要查询的表\n查询外键约束的列名：\nselect * from user_cons_columns cl where cl.constraint_name = 外键名称\n查询引用表的键的列名：\nselect * from user_cons_columns cl where cl.constraint_name = 外键引用表的键名\n5、查询表的所有列及其属性\nselect t.*,c.COMMENTS from user_tab_columns t,user_col_comments c where t.table_name = c.table_name and t.column_name = c.column_name and t.table_name = 要查询的表\n####数据唯一Id：####\n1.\t用Oracle来生成UUID，做法很简单，如下：select sys_guid() from dual;数据类型是 raw(16) 有32个字符。\ncreate table test_guid3(\n    id varchar(50)\n)\nselect * from test_guid3;\ninsert into test_guid3(id) values(sys_guid())\n----------- ----------------------------------------\n       1000 7CD5B7769DF75CEFE034080020825436\n       1100 7CD5B7769DF85CEFE034080020825436\n       1200 7CD5B7769DF95CEFE034080020825436\n       1300 7CD5B7769DFA5CEFE034080020825436\n### 名词###\n\n#### Oracle的方案（Schema）和用户（User）的区别####\n \n从定义中我们可以看出方案（Schema）为数据库对象的集合，为了区分各个集合，我们需要给这个集合起个名字，这些名字就是我们在企业管理器的方案下看到的许多类似用户名的节点，这些类似用户名的节点其实就是一个schema，schema里面包含了各种对象如tables, views, sequences, stored procedures, synonyms, indexes, clusters, and database links。\n \n   一个用户一般对应一个schema,该用户的schema名等于用户名，并作为该用户缺省schema。这也就是我们在企业管理器的方案下看到schema名都为数据库用户名的原因。Oracle数据库中不能新创建一个schema，要想创建一个schema，只能通过创建一个用户的方法解决(Oracle中虽然有create schema语句，但是它并不是用来创建一个schema的)，在创建一个用户的同时为这个用户创建一个与用户名同名的schem并作为该用户的缺省shcema。即schema的个数同user的个数相同，而且schema名字同user名字一一对应并且相同，所有我们可以称schema为user的别名，虽然这样说并不准确，但是更容易理解一些。\n \n   一个用户有一个缺省的schema，其schema名就等于用户名，当然一个用户还可以使用其他的schema。如果我们访问一个表时，没有指明该表属于哪一个schema中的，系统就会自动给我们在表上加上缺省的sheman名。比如我们在访问数据库时，访问scott用户下的emp表，通过select * from emp; 其实，这sql语句的完整写法为select * from scott.emp。在数据库中一个对象的完整名称为schema.object，而不属user.object。类似如果我们在创建对象时不指定该对象的schema，在该对象的schema为用户的缺省schema。这就像一个用户有一个缺省的表空间，但是该用户还可以使用其他的表空间，如果我们在创建对象时不指定表空间，则对象存储在缺省表空间中，要想让对象存储在其他表空间中，我们需要在创建对象时指定该对象的表空间。\n \n   oracle中的schema就是指一个用户下所有对象的集合，schema本身不能理解成一个对象，oracle并没有提供创建schema的语法，schema也并不是在创建user时就创建，而是在该用户下创建第一个对象之后schema也随之产生，只要user下存在对象，schema就一定存在，user下如果不存在对象，schema也不存在；这一点类似于temp tablespace group，另外也可以通过oem来观察，如果创建一个新用户，该用户下如果没有对象则schema不存在，如果创建一个对象则和用户同名的schema也随之产生。\n####Oracle中User与Schema的简单理解####\n技术积累（126）  \n版权声明：本文为博主原创文章，未经博主允许不得转载。\n方案（Schema）为数据库对象的集合，为了区分各个集合，我们需要给这个集合起个名字，这些名字就是我们在企业管理器的方案下看到的许多类似用户名的节点，这些类似用户名的节点其实就是一个schema，schema里面包含了各种对象如tables, views, sequences, stored procedures, synonyms, indexes, clusters, and database links。  一个用户一般对应一个schema,该用户的schema名等于用户名，并作为该用户缺省schema。\nSQL Server中的Schema\nSQL Server中一个用户有一个缺省的schema，其schema名就等于用户名，这也就是我们在企业管理器的方案下看到schema名都为数据库用户名的原因。当然一个用户还可以使用其他的schema。如果我们访问一个表时，没有指明该表属于哪一个schema中的，系统就会自动给我们在表上加上缺省的sheman名。比如我们在访问数据库时，访问scott用户下的emp表，通过select * from emp; 其实，这sql语句的完整写法为select * from scott.emp。在数据库中一个对象的完整名称为schema.object，而不属user.object。类似如果我们在创建对象时不指定该对象的schema，在该对象的schema为用户的缺省schema。这就像一个用户有一个缺省的表空间，但是该用户还可以使用其他的表空间，如果我们在创建对象时不指定表空间，则对象存储在缺省表空间中，要想让对象存储在其他表空间中，我们需要在创建对象时指定该对象的表空间。\n\nOracle中的Schema\nOracle中的schema就是指一个用户下所有对象的集合，schema本身不能理解成一个对象，oracle并没有提供创建schema的语法，schema也并不是在创建user时就创建，而是在该用户下创建第一个对象之后schema也随之产生，只要user下存在对象，schema就一定存在，user下如果不存在对象，schema也不存在；如果创建一个新用户，该用户下如果没有对象则schema不存在，如果创建一个对象则和用户同名的schema也随之产生。实际上在使用上，shcema与user完全一样，没有什么区别，在出现schema名的地方也可以出现user名。\n\nTablspace \n逻辑上用来放objects,，这是个逻辑概念，本质上是一个或者多个数据文件的集合，物理上对应磁盘上的数据文件或者裸设备。\n\n数据文件\n具体存储数据的物理文件，是一个物理概念。一个数据文件只能属于一个表空间，一个表空间可以包含一个或多个数据文件。一个数据库由多个表空间组成，一个表空间只能属于一个数据库。\n\n下边是源自网络的一个形象的比喻\n我们可以把Database看作是一个大仓库，仓库分了很多很多的房间，Schema就是其中的房间，一个Schema代表一个房间，Table可以看作是每个Schema中的床，Table（床）被放入每个房间中，不能放置在房间之外，那岂不是晚上睡觉无家可归了，然后床上可以放置很多物品，就好比 Table上可以放置很多列和行一样，数据库中存储数据的基本单元是Table，现实中每个仓库放置物品的基本单位就是床， User就是每个Schema的主人，（所以Schema包含的是Object，而不是User），user和schema是一一对应的，每个user在没有特别指定下只能使用自己schema（房间）的东西，如果一个user想使用其他schema（房间）的东西，那就要看那个schema（房间）的user（主人）有没有给你这个权限了，或者看这个仓库的老大（DBA）有没有给你这个权限了。换句话说，如果你是某个仓库的主人，那么这个仓库的使用权和仓库中的所有东西都是你的（包括房间），你有完全的操作权，可以扔掉不用的东西从每个房间，也可以放置一些有用的东西到某一个房间，你还可以给每个User分配具体的权限，也就是他到某一个房间能做些什么，是只能看（Read-Only），还是可以像主人一样有所有的控制权（R/W），这个就要看这个User所对应的角色Role了。\n#### oracle的schema的含义####\n在现在做的Kraft Catalyst 项目中，Cransoft其中有一个功能就是schema refresh. 一直不理解schema什么意思，也曾经和同事讨论过，当时同事就给我举过一个例子，下面会详细说的。其实schema是Oracle中的，其他数据库中不知道有没有这个概念。\n首先,可以先看一下schema和user的定义：\nA schema is a collection of database objects (used by a user).\nSchema objects are the logical structures that directly refer to the database’s data.\nA user is a name defined in the database that can connect to and access objects.\nSchemas and users help database administrators manage database security.\n从中我们可以看出,schema为数据库对象的集合，为了区分各个集合，需要给这个集合起个名字，这些名字就是在企业管理器的方案下看到的许多类似用户名的节点，这些类似用户名的节点其实就是一个schema。\nschema里面包含了各种对象如tables, views, sequences, stored procedures, synonyms, indexes, clusters, and database links。\n一个用户一般对应一个schema，该用户的schema名等于用户名，并作为该用户缺省schema。这也就是在企业管理器的方案下看到schema名都为数据库用户名的原因。\nOracle数据库中不能新创建一个schema，要想创建一个schema，只能通过创建一个用户的方法解决(Oracle中虽然有create schema语句，但是它并不是用来创建一个schema的)。在创建一个用户的同时，为这个用户创建一个与用户名同名的schem并作为该用户的缺省 shcema。即schema的个数同user的个数相同，而且schema名字同user名字一一 对应并且相同，所有我们可以称schema为user的别名，虽然这样说并不准确，但是更容易理解一些。\n一个用户有一个缺省的schema，其schema名就等于用户名，当然一个用户还可以使用其他的schema。如果我们访问一个表时，没有指明该表属于 哪一个schema中的，系统就会自动给我们在表上加上缺省的sheman名。比如我们在访问数据库时，访问scott用户下的emp表，通过 select * from emp; 其实，这sql语句的完整写法为select * from scott.emp。在数据库中一个对象的完整名称为schema.object，而不属user.object。类似如果我们在创建对象时不指定该对象 的schema，在该对象的schema为用户的缺省schema。这就像一个用户有一个缺省的表空间，但是该用户还可以使用其他的表空间，如果我们在创 建对象时不指定表空间，则对象存储在缺省表空间中，要想让对象存储在其他表空间中，需要在创建对象时指定该对象的表空间。\n有人举了个很生动的例子，来说明Database、User、Schema、Tables、Col、Row等之间的关系\n“可以把Database看作是一个大仓库，仓库分了很多很多的房间，Schema就是其中的房间，一个Schema代表一个房间，Table可以看作是每个Schema中的床，Table（床）就被放入每个房间中，不能放置在房间之外，那岂不是晚上睡觉无家可归了。\n然后床上可以放置很多物品，就好比Table上可以放置很多列和行一样，数据库中存储数据的基本单元是Table，现实中每个仓库放置物品的基本单位就是床， User就是每个Schema的主人（所以Schema包含的是Object，而不是User）。\n其实User是对应与数据库的（即User是每个对应数据库的主人），既然有操作数据库（仓库）的权利，就肯定有操作数据库中每个Schema（房间）的 权利，就是说每个数据库映射的User有每个Schema（房间）的钥匙，换句话说，如果他是某个仓库的主人，那么这个仓库的使用权和仓库中的所有东西都 是他的（包括房间），他有完全的操作权，可以扔掉不用的东西从每个房间，也可以放置一些有用的东西到某一个房间。还可以给User分配具体的权限，也就是 他到某一个房间能做些什么，是只能看（Read-Only），还是可以像主人一样有所有的控制权（R/W），这个就要看这个User所对应的角色Role 了”\n从定义中我们可以看出schema为数据库对象的集合，为了区分各个集合，我们需要给这个集合起个名字，这些名字就是我们在企业管理器的方案下看到的许多类似用户名的节点，这些类似用户名的节点其实就是一个schema，schema里面包含了各种对象如tables, views, sequences, stored procedures, synonyms, indexes, clusters, and database links。\n一个用户一般对应一个schema,该用户的schema名等于用户名，并作为该用户缺省schema。这也就是我们在企业管理器的方案下看到schema名都为数据库用户名的原因。Oracle数据库中不能新创建一个schema，要想创建一个schema，只能通过创建一个用户的方法解决(Oracle中虽然有create schema语句，但是它并不是用来创建一个schema的)，在创建一个用户的同时为这个用户创建一个与用户名同名的schem并作为该用户的缺省shcema。即schema的个数同user的个数相同，而且schema名字同user名字一一 对应并且相同，所有我们可以称schema为user的别名，虽然这样说并不准确，但是更容易理解一些。\n一个用户有一个缺省的schema，其schema名就等于用户名，当然一个用户还可以使用其他的schema。如果我们访问一个表时，没有指明该表属于哪一个schema中的，系统就会自动给我们在表上加上缺省的sheman名。比如我们在访问数据库时，访问scott用户下的emp表，通过select * from emp; 其实，这sql语句的完整写法为select * from scott.emp。在数据库中一个对象的完整名称为schema.object，而不属user.object。类似如果我们在创建对象时不指定该对象的schema，在该对象的schema为用户的缺省schema。这就像一个用户有一个缺省的表空间，但是该用户还可以使用其他的表空间，如果我们在创建对象时不指定表空间，则对象存储在缺省表空间中，要想让对象存储在其他表空间中，我们需要在创建对象时指定该对象的表空间。\n咳，说了这么多，给大家举个例子，否则，一切枯燥无味！\nSQL> Gruant dba to scott\nSQL> create table test(name char(10));\nTable created.\nSQL> create table system.test(name char(10));\nTable created.\nSQL> insert into test values('scott');\n1 row created.\nSQL> insert into system.test values('system');\n1 row created.\nSQL> commit;\nCommit complete.\nSQL> conn system/manager\nConnected.\nSQL> select * from test;\n\nNAME\n----------\nsystem\nSQL> ALTER SESSION SET CURRENT_SCHEMA = scott; --改变用户缺省schema名\nSession altered.\nSQL> select * from test;\n\nNAME\n----------\nscott\nSQL> select owner ,table_name from dba_tables where table_name=upper('test');\nOWNER TABLE_NAME\n------------------------------ ------------------------------\nSCOTT TEST\nSYSTEM TEST\n--上面这个查询就是我说将schema作为user的别名的依据。实际上在使用上，shcema与user完全一样，没有什么区别，在出现schema名的地方也可以出现user名。\n表空间：\n一个表空间就是一片磁盘区域,他又一个或者多个磁盘文件组成,一个表空间可以容纳许多表、索引或者簇等  \n  每个表空间又一个预制的打一磁盘区域称为初始区间（initial   extent）用完这个区间厚在用下一个，知道用完表空间，这时候需要对表空间进行扩展，增加数据文件或者扩大已经存在的数据文件\n \n \n\ninstance是一大坨内存sga,pga....和后台的进程smon pmon.....组成的一个大的应用。\nschema就是一个用户和他下面的所有对象。。\ntablspace 逻辑上用来放objects.物理上对应磁盘上的数据文件或者裸设备。\n 在Oracle中，结合逻辑存储与物理存储的概念，我们可以这样来理解数据库、表空间、SCHEMA、数据文件这些概念：\n      数据库是一个大圈，里面圈着的是表空间，表空间里面是数据文件，那么schema是什么呢？schema是一个逻辑概念，是一个集合，但schema并不是一个对象，oracle也并没有提供创建schema的语法。\nschema：\n      一般而言，一个用户就对应一个schema,该用户的schema名等于用户名，并作为该用户缺省schema，用户是不能创建schema的，schema在创建用户的时候创建，并可以指定用户的各种表空间（这点与PostgreSQL是不同，PostgreSQL是可以创建schema并指派给某个用户）。当前连接到数据库上的用户创建的所有数据库对象默认都属于这个schema（即在不指明schema的情况下），比如若用户scott连接到数据库，然后create table test(id int not null)创建表，那么这个表被创建在了scott这个schema中；但若这样create kanon.table test(id int not null)的话，这个表被创建在了kanon这个schema中，当然前提是权限允许。\n      创建用户的方法是这样的：\n      create user 用户名 identified by 密码 \n      default tablespace 表空间名 \n      temporary tablespace 表空间名 \n      quota 限额  （建议创建的时候指明表空间名）\n由此来看，schema是一个逻辑概念。\n      但一定要注意一点：schema好像并不是在创建user时就创建的，而是在该用户创建了第一个对象之后才将schema真正创建的，只有user下存在对象，他对应的schema才会存在，如果user下不存在任何对象了，schema也就不存在了；\n \n数据库：\n     在oracle中，数据库是由表空间来组成的，而表空间里面是具体的物理文件---数据文件。我们可以创建数据库并为其指定各种表空间。\n \n表空间：\n     这是个逻辑概念，本质上是一个或者多个数据文件的集合。\n \n数据文件：\n     具体存储数据的物理文件，是一个物理概念。\n     一个数据文件只能属于一个表空间，一个表空间可以包含一个或多个数据文件。一个数据库由多个表空间组成，一个表空间只能属于一个数据库。\n","source":"_posts/oracle/Oracle SQL基础知识.md","raw":"---\ntitle: Oracle SQL基础知识\ndate: 2016-05-22 14:43:49\ntags: [oracle,数据库]\ncategories: [数据库,oracle]\n---\n## Oracle SQL基本知识##\n### 安装数据库###\n#### 1）安装Oracle常用问题(常用”用户名/密码“规则)：####\n超级管理员：sys /change_on_install\n普通管理员：system/manager\n普通用户：scott/tiger----->默认是被锁定的\n大数据用户：sh/sh\n#### 2）SQL,DDL...####\nSQL：structured query language 结构化查询语言\n1.file(文件)\n\nSQL:DDL DML TCL DQL DCL\nDDL(data definition language 数据定义语言): column(列)--structure\ncreate table (创建表):\n列名 data type(数据类型) width(宽度)\nconstraint (约束)      alter table(修改表结构)           drop table(删除表)\n\nDML(data manipulation language 数据操作语言)\n:row(行)--data\ninsert 增       update 改            delete 删数据,删表里的记录\n\nTCL(transaction control language 事务控制语言)\ncommit(提交)         rollback(回滚)               savepoint(保留点)\n\nDQL(data query language 数据查询语言)\nselect\nDCL(data control language 数据控制语言)\ngrant(授权)  grant to       revoke(回收权限) revoke from \n#### 3）RDBMS关系型数据库管理系统####\nRDBMS(relationship database management system 关系型数据库管理系统) software(软件) --->(create database)database--->login in database (登录数据库系统 )--->用SQL操作table\n\ncreate database 创建空间存储表 (datafile 数据文件)\nlogin in database\n1 远程登录到数据库所在的机器上\n  192.168.0.20 192.168.0.23 192.168.0.26\nshell(终端) telnet 192.168.0.20  (跟操作系统建连接)\nlogin:openlab\npassword:open123\nsunv210% shell提示符,执行操作系统命令\n#### 4） 登录该机器上的数据库系统####\nsunv210% sqlplus (跟数据库建连接)\nEnter user-name: openlab\nEnter password:open123\nSQL>sqlplus openlab/open123\nSQL> 数据库提示符,执行SQL命令\n\n#### 5）登录的是哪个数据库####\necho $ORACLE_SID(环境变量)<---DBA(database administrator 数据库管理员)\n查看ORACLE_SID变量的取值,oracle提供\n通过设置ORACLE_SID变量,sqlplus就知道跟哪个数据库建连接.\nunix平台\n%c shell\n%echo $ORACLE_SID  (tarena)\n%setenv ORACLE_SID hiloo\n%setenv ORACLE_SID tarena\n\n$ b shell\n$ echo $ORACLE_SID  (tarena)\n$ ORACLE_SID=hiloo\n$ export ORACLE_SID\n\nwindows平台\nD:\\>set ORACLE_SID=hiloo (设置环境变量)\nD:\\>set ORACLE_SID (查看环境变量)\nORACLE_SID=hiloo\n##### 数据表信息：##### \ndept(表名) department 部门信息   列名\ndeptno 部门号  dname  部门名称      location 位置(地区)\ncreate table dept_hiloo\n(deptno  number(2), dname char(20),  location char(20));\ninsert into dept_hiloo values (10,'developer','beijing');\ninsert into dept_hiloo values (20,'account','shanghai');\ninsert into dept_hiloo values (30,'sales','guangzhou');\ninsert into dept_hiloo values  ( 40,'operations','tianjin');\ncommit;\ninsert成功后的提示:1 rows inserted\nemp(表名) employee 员工信息    列名\nempno 员工 ename 员工名字  job   职位   salary  月薪   bonus   奖金  \nhiredate  入职日期  mgr   manager 管理者    deptno  部门号\ncreate table emp_hiloo(\nempno number(4),\tename varchar2(20),  job  varchar2(15),  \nsalary number(7,2), bonus number(7,2),  hiredate date,\n mgr number(4),  deptno number(10));\nalter session set nls_date_language='american';\ninsert into emp_hiloo values (1001,'zhangwuji','Manager',10000,2000,'12-MAR-10',1005,10);\ninsert into emp_hiloo values (1001,'zhangwuji','Manager',10000,2000,'12-MAR-10',1005,10);\ninsert into emp_hiloo values (1002,'liucangsong','Analyst',8000,1000, '01-APR-11',1001,10);\ninsert into emp_hiloo values (1003,'liyi','Analyst',9000,1000,'11-APR-10',1001,10);\ninsertinto emp_hiloo values (1004,'guofurong','Programmer',5000,null,'01-JAN-11',1001,10);\ninsertintoemp_hiloo values (1005,'zhangsanfeng','President',15000,null,'15-MAY-08',null,20);\ninsert into emp_hiloo values (1006,'yanxiaoliu','Manager',5000,400,'01-FEB-09',1005,20);\ninsert into emp_hiloo values (1007,'luwushuang','clerk',3000,500,'01-FEB-06',1006,20);\ninsert into emp_hiloo values (1008,'huangrong','Manager',5000,500,'1-MAY-09',1005,30);\ninsert into emp_hiloo values (1009,'weixiaobao','salesman',4000,null,'20-FEB-09',1008,30);\ninsert into emp_hiloo values (1010,'guojing','salesman',4500,500,'10-MAY-09',1008,30);\n报错信息\nORA-00955: name is already used by an existing object(名字已经被一个存在的对象使用)\n错误：ORA-01843:无效的月份（在中文的plsql控制台上月份要写成’10-3月-02’这种形式，必须是一个数字和一个汉语月。也可以把日期改成英文环境，在执行插入前执行alter session set nls_date_language='american';就可以 了。\n\nDQL\nselect(选择)\n源表  结果集\n1 投影操作 select子句实现\n2 选择操作 where子句实现\n3 连接操作\n 1  select ename,salary*12 ann_sal(列别名)\n 2* from emp_hiloo\n\n单引号 表达字符串 ''\n双引号 表达列别名 \"\",别名中包含空格,大小写敏感\n\n\n##### 1）null值的理解##### \n1 null值出现在算术表达式中,结果必为null,null可以看作无穷大.\n2 函数(function) nvl功能空值转换函数\nnvl是函数名,p1,p2是参数,数据类型必须一致,函数本身有返回值\nnvl(p1,p2)  \nnvl函数实现:\nif p1 is null then\n   return p2;\nelse\n   return p1;\nend if;\n\n3 若有多个null值,distinct去重时,结果集保留一个null值.\n4 null = null 不成立 null <> null 不成立\n5 若用in运算符,集合中有null值跟没有null值结果一致的,结果集中不会出现跟null值有关的记录\n  若用not in运算符,集合中有null值,这个结果集不包含记录.no rows selected.\n##### 2）各个子句的功能##### \n1 select后面跟列名,列别名,函数,表达式\n2 select后面的distinct:去重\n3 where子句\n  where 条件表达式 (列名 比较运算符 值)  \n表达式 比较运算符 值(尽量不用,为了性能)\n  where子句中的列为字符类型,放值的位置上不加单引号或加双引号当列名解释,加单引号当字符串解释.\n  where子句中的列为字符类型,表达具体值时注意字符是大小写敏感的.\nSQL提供的四个比较运算符\n肯定形式\n   between and 区间,范围\n   in <=> =any  (= or = )(跟集合里的任意一个值相等就满足条件) 集合 离散值\n   = 单值运算符\n   in =any 多值运算符\n   like 像...一样\n   通配符: %表示0或任意多个字符 _任意一个字符\n   'S' 'S%' 'S_'\n   is null  如何判断一个列的取值是否为空\n否定形式\n= <> != ^=\nbetween and   not between and\nin\tnot in (<> and <>) <=> <>all(跟集合里的所有值都不能相等)\nlike \tnot like\nis null   is not null \n各个子句的执行顺序\nfrom-->where-->select\n##### 3）课堂练习##### \n1 列出每个员工的名字和他的工资\n  select ename,salary from emp_hiloo;\n2 列出每个员工的名字和他的职位\n  select ename,job from emp_hiloo;\n3 列出每个员工的名字和他的年薪\n select ename,salary*12 ann_sal from emp_hiloo;\n4 列出每个员工的名字和他一年的总收入\n  (salary+bonus)*12 (15000+null)*12=null\n  select ename,(salary+nvl(bonus,0))*12 tol_sal\n  from emp_hiloo;\n5 输出结果如下:\n  zhangwuji is in department 10.\n  liucangsong is in department 10.\n  .....\n  guojing is in department 30.\nselect ename||'is in department'||deptno||'.'employee from emp_hiloo;\n什么要加employee呢？Employee是列别名为了显示用的。\n6 列出该公司有哪些职位\n  select distinct(job) from emp_hiloo;\n  select distinct job from emp_hiloo;\n7 列出该公司不同的奖金\n  select distinct bonus from emp_hiloo;\n8 各个部门有哪些不同的职位?\n  select distinct deptno,job from emp_hiloo;\n  去重方式:deptno和job联合唯一.\n  distinct之后和from之前的所有列联合唯一.\ndistinct是保证每一行的唯一性而非某一列的唯一性，所以必须紧跟在select后面。\n所以distinct只能放在select后面，紧跟select不然会报缺失表达式错误。\n9 哪些员工的工资高于5000?\n  select ename,salary from emp_hiloo \n  where salary > 5000; \n10 列出员工工资高于5000的员工的年薪?\n  select ename,salary*12 from emp_hiloo\n  where salary > 5000;\n11 列出员工年薪高于60000的员工的年薪?\n  select ename,salary*12 from emp_hiloo\n  where salary*12> 60000;\n  select ename,salary*12 ann_sal from emp_hiloo\n  where ann_sal > 60000(错误的写法)\n  select ename,salary*12 from emp_hiloo\n  where salary > 5000;\n12 zhangwuji的年薪是多少?\nselect ename,salary*12 from emp_hiloo\nwhere ename='zhangwuji';\n  哪些员工的职位是Manager?\nselect ename,job from emp_hiloo\nwhere job='Manager';\n  哪些员工的职位是clerk?\n  select ename,job from emp_hiloo\n  where job = 'Manager'\n   select ename,job from emp_hiloo\n  where job = 'clerk'(效率高)\n  clerk的大小写不清楚\n  函数:upper(),lower()\n  select ename,job from emp_hiloo\n  where upper(job) = 'CLERK' (通用性好)\n13 员工工资在5000到10000之间的员工的年薪\n   select ename,salary*12\n   from emp_hiloo\n   where salary >= 5000 \n   and   salary <= 10000;\n   select ename,salary*12\n   from emp_hiloo\n   where salary between 5000 and 10000;\n14 哪些员工的工资是5000或10000.\n   select ename,salary\n   from emp_hiloo\n   where salary = 5000\n   or salary = 10000\n   select ename,salary\n   from emp_hiloo\n   where salary in (5000,10000)\n   select ename,salary\n   from emp_hiloo\n   where salary =any (5000,10000)\n15 哪个员工的名字的第二个字符是a.\n   select ename\n   from emp_hiloo\n   where ename like '_a%';\n16 哪个员工的名字的第二个字符是_.\n   select ename\n   from emp_hiloo\n   where ename like '_\\_%' escape '\\';\n   第一个_表示任意一个字符,代表通配符\n   \\_必须连起来看,表示下划线本身,escape定义哪个字符可以定义转义'\\'\n17 哪些员工没有奖金?\n   select ename,bonus\n   from emp_hiloo\n   where bonus is null\n18 哪些员工有奖金?\n   select ename,bonus\n   from emp_hiloo\n   where bonus is not null\n19哪些员工的工资不是5000也不是10000.\n  select ename,salary\n  from emp_hiloo\n  where salary not in (5000,10000);\n  select ename,salary\n  from emp_hiloo\n  where salary <> 5000\n  and salary <> 10000\n\ncreate table emp_hiloo\n( hiredate date）\ninsert into emp_hiloo values (1001,'zhangwuji','Manager',10000,2000,'12-MAR-10',1005,10);\n解决方案：\n\tinsert into emp_hiloo values (1001,'zhangwuji','Manager',10000,2000,'12-3月-10',1005,10);\n##### 更改字段名字(mysql、orcle)：##### \nOracle修改表\nalter table 表名 rename column 原名 to 新名；\nMysql:\nalter table 表名 change column(可写，可不写）原名 新名 字段类型；\n\nORA-00904：“ANN_SAL\":invalid identifier\n无效的标识符\n\n\nindex(索引) view(视图) sequence(顺序号/序列号) function(函数)\nsession altered.会话已更改\nset feed on可以设置一个，显示操作数\nconnet tiger重新建立连接  show user查看当前用户是谁。\nedit 用记事本编辑  /运行。\n###Function (单行、多行)###\n单行函数:表中的一列作为函数的参数,对于每一条记录函数都有一个返回值. \n例如:upper lower nvl\n多行函数：表中的一列作为函数的参数,将记录分组,对于每组数据函数返回一个值. \n例如:avg\n####1）单行函数####\n 根据处理参数的数据类型分为\n  ##### 1）字符函数:upper,lower##### \n   ##### 2）数值函数:##### \n     round 四舍五入\n     round(12.345,2)-->12.35\n     round(12.345,0)=round(12.345)-->12\n     round(12,345,-1)-->10\n     trunc 截取\n     trunc(12.345,2)-->12.34\n     trunc(12.345,0)=trunc(12.345)-->12\n     trunc(12,345,-1)-->10\n  ##### 3) 日期和日期函数##### \n    select sysdate from dual\n    06-SEP-12 DD-MON-RR \n    alter session set\n      nls_date_format = 'yyyy mm dd hh24:mi:ss'\n    session 会话 connection(连接)\n   日期类型的数据是用固定的字节7个字节来存储世纪,年,月,日,时,分,秒. 格式敏感\n   会话级 alter session set nls_date_format\n   语句级 select to_char(c1日期类型用7个字节来表达，日期类型的数据是用固定的字节7个字节来存储世纪，年，月，日，时，分，秒。四位年的前两位代表世纪20，后两位代表当前年12\n如果不想修改sql语句运行的话，就需要在执行该语句之前，使用alter session 命令将nls_date_language修改为american，如下：\nalter session set nls_date_language='american'    --以英语显示日期\n如果不想修改sql语句运行的话，就需要在执行该语句之前，使用alter session 命令将\n\n'01-JAN-08' 系统做了隐式数据类型转换,调用了to_date函数\n'2008-01-01',用户做显式数据类型转换,自己调用\nto_date('2008-01-01','yyyy-mm-dd'),第二个参数是对第一个参数的格式说明.\nto_char的返回类型是字符类型,把date转换成了字符串类型,所以参数的数据类型是date.to_char函数可以获得日期的任何一部分信息,比如年,月,日等.\nselect c1 from ... 系统做了隐式数据类型转换,调用了to_char函数\nselect to_char(c1,.. 用户做显式数据类型转换,自己调用to_char(c1,'yyyy-mm-dd'),第二个参数是对第一个参数的格式说明.\n日期的运算\n   日期可以加减一个数值,单位为天.\n   select sysdate-1,sysdate,sysdate+1 from dual\n两个日期相减\n   add_months 按月加 返回类型是date\n   add_months(sysdate,6)\n   select add_months(hiredate,6) from emp_hiloo\n   add_months(sysdate,-6)\n   months_between()  返回类型是number\n   months_between(sysdate,hiredate) 两个日期之间相差多少个月\nselect months_between(sysdate,hiredate) from emp_hiloo;\n   last_day(sysdate) 本月的最后一天\n##### 4) 转换函数#####    \n两个日期相减转换函数\nto_date  char-->date\nto_char  date-->char , number --> char\nto_number  char-->number\n##### 其他函数##### \ncoalesce 类似nvl(oracle专有)\nnvl(bonus,salary*0.1)\ncoalesce(bonus,salary*0.1,100)。输出所有员工的奖金，如果没有奖金就按工资的10%发放，如果奖金和工资都没有的临时工，就给100元。\n不同的记录处理方式不一样时,用case when.\ncase when 条件表达式 then 返回结果\nelse\n     返回结果\nend\n若没有else,当不匹配条件,表达式的返回值为null.\ncase deptno when 10 then(不建议该语法形式)\ndecode跟case when的功能类似.\ndecode(deptno,10,salary*1.1,\n              20,salary*1.2,\n              salary)\n若没有最后一个参数,函数的返回值为null.\nselect语句\norder by子句\nselect   from    where\norder by\norder by子句是select语句中的最后一个子句.\norder by salary 缺省是升序 asc\norder by salary desc 降序\norder by子句后面可以跟列名,表达式(函数),列别名,在select子句中的位置.\nORDER BY 子句\nORDER BY 语句用于对结果集进行排序。\nORDER BY 语句\nORDER BY 语句用于根据指定的列对结果集进行排序。\nORDER BY 语句默认按照升序对记录进行排序。\n如果您希望按照降序对记录进行排序，可以使用 DESC 关键字。\n原始的表 (用在例子中的)：\nOrders 表:\nCompany\tOrderNumber\nIBM\t3532\nW3School\t2356\nApple\t4698\nW3School\t6953\n实例 1\n以字母顺序显示公司名称：\nSELECT Company, OrderNumber FROM Orders ORDER BY Company\n结果：\nCompany\tOrderNumber\nApple\t4698\nIBM\t3532\nW3School\t6953\nW3School\t2356\n实例 2\n以字母顺序显示公司名称（Company），并以数字顺序显示顺序号（OrderNumber）：\nSELECT Company, OrderNumber FROM Orders ORDER BY Company, OrderNumber\n结果：\nCompany\tOrderNumber\nApple\t4698\nIBM\t3532\nW3School\t2356\nW3School\t6953\n实例 3\n以逆字母顺序显示公司名称：\nSELECT Company, OrderNumber FROM Orders ORDER BY Company DESC\n结果：\nCompany\tOrderNumber\nW3School\t6953\nW3School\t2356\nIBM\t3532\nApple\t4698\n实例 4\n以逆字母顺序显示公司名称，并以数字顺序显示顺序号：\nSELECT Company, OrderNumber FROM Orders ORDER BY Company DESC, OrderNumber ASC\n结果：\nCompany\tOrderNumber\nW3School\t2356\nW3School\t6953\nIBM\t3532\nApple\t4698\n注意：在以上的结果中有两个相等的公司名称 (W3School)。只有这一次，在第一列中有相同的值时，第二列是以升序排列的。如果第一列中有些值为 nulls 时，情况也是这样的。\n\n#### 2) 多行函数(哪两个函数里只能放number)####\navg()\t平均值  函数的参数只能是number\nsum()\t求和\t函数的参数只能是number\ncount()\t计数 函数的参数可以是number date 字符\n        count(*)统计记录,count(bonus)\nmax() 最大值 函数的参数可以是number date 字符\nmin() 最小值 函数的参数可以是number date 字符\n\n组函数的缺省处理方式是处理所有的非空值.\navg(bonus) 所有有奖金的员工的平均值\ncount(bonus) 有奖金的员工个数\n当所有的值都是null,count函数返回0,其他组函数返回null.\n\n#### 3) group by子句####\n若有group by子句,select后面跟组标识和组函数\n组标识指group by后面的内容\nfrom-->where-->group by-->select-->order by\n若没有group by子句,select后面只要有一个是组函数,其余的都得是组函数.\n\n#### having子句####\nselect deptno,round(avg(salary)) davg\nfrom emp_hiloo\ngroup by deptno\nhaving round(avg(salary))> 5000\n\nfrom-->where-->group by-->having-->select-->order by \n#### GROUP BY 语句####\nGROUP BY 语句用于结合合计函数，根据一个或多个列对结果集进行分组。\nSQL GROUP BY 语法\nSELECT column_name, aggregate_function(column_name)\nFROM table_name\nWHERE column_name operator value\nGROUP BY column_name\nSQL GROUP BY 实例\n我们拥有下面这个 \"Orders\" 表：\nO_Id\tOrderDate\tOrderPrice\tCustomer\n1\t2008/12/29\t1000\tBush\n2\t2008/11/23\t1600\tCarter\n3\t2008/10/05\t700\tBush\n4\t2008/09/28\t300\tBush\n5\t2008/08/06\t2000\tAdams\n6\t2008/07/21\t100\tCarter\n现在，我们希望查找每个客户的总金额（总订单）。我们想要使用 GROUP BY 语句对客户进行组合。\n我们使用下列 SQL 语句：\nSELECT Customer,SUM(OrderPrice) FROM Orders\nGROUP BY Customer\n结果集类似这样：\nCustomer\tSUM(OrderPrice)\nBush\t2000\nCarter\t1700\nAdams\t2000\n很棒吧，对不对？\n让我们看一下如果省略 GROUP BY 会出现什么情况：\nSELECT Customer,SUM(OrderPrice) FROM Orders\n结果集类似这样：\nCustomer\tSUM(OrderPrice)\nBush\t5700\nCarter\t5700\nBush\t5700\nBush\t5700\nAdams\t5700\nCarter\t5700\n上面的结果集不是我们需要的。\n那么为什么不能使用上面这条 SELECT 语句呢？解释如下：上面的 SELECT 语句指定了两列（Customer 和 SUM(OrderPrice)）。\"SUM(OrderPrice)\" 返回一个单独的值（\"OrderPrice\" 列的总计），而 \"Customer\" 返回 6 个值（每个值对应 \"Orders\" 表中的每一行）。因此，我们得不到正确的结果。不过，您已经看到了，GROUP BY 语句解决了这个问题。\nGROUP BY 一个以上的列\n我们也可以对一个以上的列应用 GROUP BY 语句，就像这样：\nSELECT Customer,OrderDate,SUM(OrderPrice) FROM Orders\nGROUP BY Customer,OrderDate\n#### 4) where和having比较####\n共同点:都执行在select之前,都有过滤功能\n区别\nwhere执行在having之前\nwhere过滤的是记录,任意列名都可以出现在where子句,单行函数可以用在where子句,组函数不能出现在where子句\nhaving过滤的是组,组标识可以出现在having子句,其他列名不行,组函数用于having子句,单行函数不可以.\n##### HAVING 子句##### \n在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与合计函数一起使用。\nSQL HAVING 语法\nSELECT column_name, aggregate_function(column_name)\nFROM table_name\nWHERE column_name operator value\nGROUP BY column_name\nHAVING aggregate_function(column_name) operator value\nSQL HAVING 实例\n我们拥有下面这个 \"Orders\" 表：\nO_Id\tOrderDate\tOrderPrice\tCustomer\n1\t2008/12/29\t1000\tBush\n2\t2008/11/23\t1600\tCarter\n3\t2008/10/05\t700\tBush\n4\t2008/09/28\t300\tBush\n5\t2008/08/06\t2000\tAdams\n6\t2008/07/21\t100\tCarter\n现在，我们希望查找订单总金额少于 2000 的客户。\n我们使用如下 SQL 语句：\nSELECT Customer,SUM(OrderPrice) FROM Orders\nGROUP BY Customer\nHAVING SUM(OrderPrice)<2000\n结果集类似：\nCustomer\tSUM(OrderPrice)\nCarter\t1700\n现在我们希望查找客户 \"Bush\" 或 \"Adams\" 拥有超过 1500 的订单总金额。\n我们在 SQL 语句中增加了一个普通的 WHERE 子句：\nSELECT Customer,SUM(OrderPrice) FROM Orders\nWHERE Customer='Bush' OR Customer='Adams'\nGROUP BY Customer\nHAVING SUM(OrderPrice)>1500\n结果集：\nCustomer\tSUM(OrderPrice)\nBush\t2000\nAdams\t2000\n\n#### 5) DCL#### \nconnect openlab/open123\nselect count(*) from hiloo.emp_hiloo;\n\nconnect hiloo/hiloo123\ngrant select on emp_hiloo to openlab;\n\nconnect openlab/open123\nselect count(*) from hilool.emp_hiloo\n10rows selected\n\nconnect hiloo/hiloo123\nrevoke select on emp_hiloo from openlab;\n\nshow user\nselect count(*) from hiloo.emp_hiloo\n\ncreate synonym emp_hiloo for hiloo.emp_hiloo\n#### 6) 关于null值的讨论####\n1 case when在没有else和decode少一个参数时,返回null.\n2order by bonus,asc升序时null值在最后,desc降序时null在最前.\n3 组函数和null值的关系:1组函数的缺省处理方式是处理所有的非空值.2当所有的值都是null,count函数返回0,其他组函数返回null.\n4若group by的列有null值,所有的null值分在一组.\n课堂练习\n1将每个员工的工资涨12.34567%,用round和trunc分别实现\nselect ename,nvl(trunc(round(salary+salary*0.1234567,2),1),0.0) from emp_hiloo;//自己写的。\n2 将'2008-01-01'插入表中,\n  再将'2008 08 08 08:08:08'插入表中\ninsert into test values\n(to_date('01-JAN-08','DD-MON-RR'));\n\n3找出3月份入职的员工.\nselect ename,hiredate\nfrom emp_hiloo\nwhere to_char(hiredate,'mm') = '03';\nselect ename,hiredate\nfrom emp_hiloo\nwhere to_char(hiredate,'mm') = 3;//可以正常输出winXP下\n'03' = 3  ---> to_number('03') = 3\n字符   数值  缺省系统将字符转成数值\nselect ename,hiredate\nfrom emp_hiloo\nwhere to_char(hiredate,'fmmm') = '03';(错，未选定行，无输出)\n\nselect ename,hiredate\nfrom emp_hiloo\nwhere to_char(hiredate,'fmmm') = '3';(对)\n'03' = '3' (错)\nfm表示去掉前导0或去掉两边的空格.\n4 zhangsanfeng的mgr上显示boss,其他人不变.\nselect ename,empno,\n       nvl(to_char(mgr),'boss') mgr\nfrom emp_hiloo\n函数nvl（“1”，“2”）:如果字符串1是空，就返回字符串”2”\n#### 5十分钟之后####\n select sysdate,sysdate+1/144 from dual;\n解释：Oracle 里面,\n\nsysdate + 1 意思是 当前时间 + 1天\n\nsysdate + 1/24  意思是 当前时间 + 1/24天  也就是1小时后\n\nsysdate+1/144  意思是 当前时间 + 1/144天 （1/24*6）  也就是10分钟后\n 6 若员工是10部门的,工资涨10%,20部门工资涨20%,其他员工工资不变.\nselect ename,salary,\n       case when deptno = 10 then salary*1.1\n            when deptno = 20 then salary*1.2\n       else\n            salary\n       end new_sal\nfrom emp_hiloo;\n\nselect ename,salary, \n       decode(deptno,10,salary*1.1,\n                     20,salary*1.2,\n                     salary) new_sal\nfrom emp_hiloo;\n7 列出每个员工的年薪,按年薪降序排列.\nselect ename,salary*12\nfrom emp_hiloo\norder by salary desc (好)\nselect ename,salary*12\nfrom emp_hiloo\norder by salary*12 desc\nselect ename,salary*12 n_sal\nfrom emp_hiloo\norder by n_sal desc\n\nselect ename,salary*12 n_sal from emp_hiloo order by 2 desc;\nselect salary*12,ename n_sal from emp_hiloo order by 2 asc;\n8 列出员工的名字,部门号以及工资,按部门号从小到大的顺序,同一部门的工资按降序排列.\nselect ename,deptno,salary\nfrom emp_hiloo\norder by deptno,salary desc\n9 列出奖金的平均值,和,个数,最大值,最小值.\nAVG 函数返回数值列的平均值。NULL 值不包括在计算中\nselect avg(bonus),avg(nvl(bonus,0)),\n       sum(bonus), sum(nvl(bonus,0)),\n       count(bonus),count(nvl(bonus,0)),\n       max(bonus),max(nvl(bonus,0)),\n       min(bonus),min(nvl(bonus,0))\nfrom emp_hiloo\n10 各个部门的平均工资\nROUND 函数用于把数值字段舍入为指定的小数位数。\nselect deptno,round(avg(salary))\nfrom emp_hiloo\ngroup by deptno\n11 求10部门的平均工资,只显示平均工资\n   求10部门的平均工资,显示部门号,平均工资\n   select round(avg(salary))\n   from emp_hiloo\n   where deptno = 10\n   group by deptno\n\n   select max(deptno),round(avg(salary))\n   from emp_hiloo\n   where deptno = 10 \n12各个部门不同职位的平均工资\n   select deptno,job,round(avg(salary))\n   from emp_hiloo\n   group by deptno,job\n13 每种奖金有多少人?\n   select bonus,count(empno)\n   from emp_hiloo\n   group by bonus\n14 列出平均工资大于5000的部门的平均工资\n   select deptno,round(avg(salary)) \n   from emp_hiloo\n   group by deptno\n   having round(avg(salary)) > 5000\n15哪些员工的工资是最低的.\n  select ename from emp_hiloo\n  where salary = ( select min(salary)\n                   from emp_hiloo)\n报错信息\nORA-01861: literal does not match format string\n文字值不匹配格式串\nORA-01722: invalid number 无效的数值 to_number\nORA-00937: not a single-group group function 不是一个组函数\nORA-00979: not a GROUP BY expression 不是一个group by表达式 GROUP BY expression指跟在group by后面的东西(列名),称之为组标识\ndetail 细节 summary 聚合\n\n### 查询###\n子查询定义\n在SQL语句中嵌入select语句\ncreate table new_tabname\nas\nselect ename,salary*12 ann_sal from emp_hiloo;\n新表的结构由select后面的项来决定,new_table包含两列ename,ann_sal.\n\n#### 子查询####\n  非关联子查询\n    单列子查询\n    多列子查询\n  关联子查询\n\n##### 子查询执行##### \n非关联子查询\n子查询的表和主查询的表没有建关联\n先执行子查询(只执行一遍),当返回多条记录,系统会将自动去重的结果返回给主查询,再执行主查询.\n\n关联子查询\n子查询的表和主查询的表建关联.所谓建关联指主查询表里的列和子查询表里的列写成一个条件表达式.\n\n先执行主查询,判断表里的记录是否应该放入结果集.过程如下:拿到第一条记录,获得了各个列的值,将需要的列值带入子查询,执行后返回的结果再和主查询表里的列做比较,符合条件,该记录放入结果集,否则过滤掉.依次执行主查询表里的每条记录.子查询执行的次数由主查询表里的记录数决定.\n\n1) exists和not exists\nexists的执行过程\n从主查询表里拿到第一条记录,按子查询里的关联条件在子查询的表里看是否能找到匹配的记录,当找到第一条匹配的记录后,立即返回(即不需要找出所有匹配的记录),exists条件满足,主查询表里的该记录放入结果集.若按子查询里的关联条件将子查询\n表里的记录全部检查一遍后没有一条符合条件的记录,此时也返回, exists 条件不满足,主查询表里的该记录不能放入结果集,被过滤掉.\n\nselect ename from emp_afei o\nwhere exists\n             (select 1 from emp_afei i\n              where o.empno = i.mgr)\n\n##### 非关联子查询的分类##### \n单列子查询\nselect ename,salary\nfrom emp_hiloo \nwhere salary = (select min(salary)\n                from emp_hiloo \n                )\n多列子查询:按键值对比较\nselect ename,salary,deptno\nfrom emp_afei\nwhere (deptno,salary) in\n             (select deptno,round(avg(salary))\n              from emp_afei\n              group by deptno)\n\n2) 课堂练习\n1哪些人是领导?(非关联子查询)\n如果一个员工的empno能出现在mgr里就说明他是领导.\nselect ename\nfrom emp_hiloo\nwhere empno in (select mgr from emp_hiloo)\nselect ename\nfro emp_afei\nwhere empno in (1001,1005,1006,1008,null)\n2 哪些人是员工?\n他的empno绝对不能出现在mgr中,他的empno跟mgr的出现的所有的值不能相等. <>all\nselect ename\nfrom emp_hiloo\nwhere empno not in (select mgr from emp_hiloo)\nselect ename\nfro emp_afei\nwhere empno not in (1001,1005,1006,1008,null)\nselect ename\nfrom emp_hiloo\nwhere empno not in (select mgr from emp_hiloo\n                    where mgr is not null)\n\n3哪些部门的平均工资比30部门的平均工资高?\nselect deptno,round(avg(salary))\nfrom emp_hiloo\ngroup by deptno\nhaving round(avg(salary)) >\n                    (select round(avg(salary))\n                     from emp_hiloo\n                     where deptno = 30)\n4哪些员工的工资比zhangwuji的工资高?\nselect ename,salary\nfrom emp_afei\nwhere salary > (select salary from emp_afei\n                where ename = 'zhangwuji')\nERROR at line 3:\nORA-01427: single-row subquery returns more than one row\n单行子查询返回多条记录\n\n比所有人高 > (select max(salary))\n           >all\n比任意人高 > (select min(salary)\n           >any\n5哪些员工的工资等于本部门的平均工资?\nselect ename,salary,deptno\nfrom emp_afei\nwhere (deptno,salary) in\n             (select deptno,round(avg(salary))\n              from emp_afei\n              group by deptno)\n5哪些员工的工资比本部门的平均工资高?\nselect ename,salary,deptno\nfrom emp_afei o\nwhere salary > (select round(avg(salary))\n                from emp_afei i\n                where i.deptno = o.deptno)\n6哪些人是领导?(关联子查询)\nselect ename from emp_afei o\nwhere exists\n             (select 1 from emp_afei i\n              where o.empno = i.mgr)\n7哪些部门有员工?\nselect deptno,dname\nfrom dept_afei o\nwhere exists (select 1 from emp_afei i\n              where o.deptno = i.deptno)\n\n3) 课外练习day03am\n1 zhangwuji的领导是谁,显示名称?\n2 zangwuji领导谁,显示名称?\n3 列出devoleper部门有哪些职位?\n1) 课外练习day04am答案\n1 zhangwuji的领导是谁,显示名称?\n  select ename from emp_afei\n  where empno in \n\t\t(select mgr from emp_afei\n                 where ename = 'zhangwuji')\n\nzangwuji领导谁,显示名称?\n\n select ename from emp_afei\n where mgr in (select empno from emp_afei\n               where ename = 'zhangwuji')\n\n3 列出developer部门有哪些职位?\n  select distinct job from emp_afei\n  where deptno in \n           (select deptno from dept_afei\n            where dname = 'developer')\n\n2) 非关联子查询               \nexists和not exists\nnot exists的执行过程\n从主查询表里拿到第一条记录,按子查询里的关联条件在子查询的表里看是否能找到匹配的记录,当找到第一条匹配的记录后,立即返回(即不需要找出所有匹配的记录),not exists条件不满足,主查询表里的该记录不能放入结果集,被过滤掉.若按子查询里的关联条件将子查询表里的记录全部检查一遍后没有一条符合条件的记录,返回, not exists 条件满足,主查询表里的该记录放入结果集.\n\n对于exists和not exists,在子查询中找到第一条匹配的记录都会立即返回,exists将主查询表里的记录放入结果集,not exsits将主查询表里的记录过滤掉.\n对于exists和not exists,如果子查询没有返回任何记录,即扫描全部记录后没有一条符合条件的记录,都返回,exists将主查询表里的记录过滤掉,not exists将主查询表里的记录放入结果集. \nnot in ,<> all逻辑上跟not exists等价\nin ,=any逻辑上跟exists等价\n\n查询形式:集合操作\n把结果集作为一个集合,结果集必须是同构的,列的个数及数据类型一致\n\n3) 并集  union(去重)/union all(不去重)\nselect ename,deptno,salary,salary*1.1 new_sal\nfrom emp_afei\nwhere deptno = 10\nunion all\nselect ename,deptno,salary,salary*1.2 new_sal\nfrom emp_afei\nwhere deptno = 20\nunion all\nselect ename,deptno,salary,salary new_sal\nfrom emp_afei\nwhere deptno not in (10,20)\n\ncase when和decode可以实现类似功能.\n\n4) 交集  intersect(去重)\nselect job from emp_afei\nwhere deptno = 10\nintersect\nselect job from emp_afei\nwhere deptno = 20\n10部门和20部门都有的职位是哪些?\n\n5) 差  minus(去重)\nselect deptno from dept_afei\nminus\nselect deptno from emp_afei\n那些部门没有员工.\n\n6) 多表查询\n1) 交叉连接 cross join\nselect e.ename,d.dname\nfrom emp_afei e cross join dept_afei d\n结果集产生\n10*4=40,组合操作,笛卡尔积\n\n2) 内连接 inner join(匹配一个条件)\nselect e.ename,e.deptno,d.deptno,d.dname\nfrom emp_afei e join dept_afei d\nORA-00905: missing keyword(丢失关键字)\n\n如果把结果集的产生看成双层循环,驱动表是外层循环,匹配表是内层循环.\n对于内连接哪张表做驱动表,哪张表做匹配表产生出的结果集是一样的,不同的是性能.\n驱动表在匹配表的匹配情况如下:\n一条记录找到一条匹配\n一条记录找到多条匹配\n一条记录找不到任何匹配.\n内连接的核心是驱动表的记录要出现在结果集中必须在匹配表中能找到匹配的记录,否则该记录被过滤掉.\n\n3) 内连接查询形式\n等值连接 on e.deptno = d.deptno\n两张表有表述同一属性的列,两张表都有deptno列.\n自连接 on e.mgr = m.empno\n同一张表的不同列能写成一个表达式,即同一张表的两条记录之间有关系.通过给表起别名的方式,将同一张表的两条记录之间的关系转化成不同表的两条记录之间的关系.\n4) 外连接\n外连接 outer join(驱动表的记录一个都不能少的出现在结果集里)\nfrom t1 left join t2\non t1.c1 = t2.c2(t1驱动表,t2匹配表)\n外连接结果集=内连接的结果集+t1表中匹配不上的记录和t2表中的null记录的组合\nfrom t1 right join t2\non t1.c1 = t2.c2(t2驱动表,t1匹配表)\n外连接结果集=内连接的结果集+t2表中匹配不上的记录和t1表中的null记录的组合\nfrom t1 full join t2\non t1.c1 = t2.c2\n外连接结果集=内连接的结果集+t1表中匹配不上的记录和t2表中的null记录的组合+t2表中匹配不上的记录和t1表中的null记录的组合\n\n5) 外连接的应用场景\n1 某张表的记录全部出现在结果集中,包括匹配不上的.\nselect e.ename,nvl(m.ename,'Boss')\nfrom emp_afei e left join emp_afei m\non e.mgr = m.empno\n2解决否定问题,匹配不上的记录找出来(跟所有的记录都不匹配.)(not in/not exists)\n外连接 + where 匹配表.主键列 is null\nselect e.ename,d.dname\nfrom emp_afei e right join dept_afei d\non e.deptno = d.deptno\nwhere e.empno is null\n(解决结果集只包含匹配不上的记录.where子句执行在外连接之后)哪些部门没有员工\n\nselect d.dname\nfrom emp_afei e right join  dept_afei d\non e.deptno = d.deptno\nand e.ename = 'zhangwuji'\nwhere e.empno is null\n如果希望在外连接之前过滤匹配表用and子句,如果想在外连接之后通过匹配表里的列过滤外连接的结果集时候用where.\n过滤驱动表统计用where子句过滤.\n\n6) 课内练习\n1 哪些部门没有员工(not exists)\n  select dname from dept_afei o\n  where not exists \n        (select 1 from emp_afei i\n         where o.deptno = i.deptno)\n2 哪些人是员工?(not exists)\n  select ename from emp_afei o\n  where not exists \n            (select 1 from emp_afei i\n             where o.empno = i.mgr)\n他的empno和其他人的mgr相等是不可能存在的.即和所有人的mgr都不相等.\nnot in ,<> all逻辑上跟not exists等价\n3 列出哪些员工在北京地区上班?\n思路:确定表,两张表,匹配问题用inner join-->on(匹配条件)-->(对表是否过滤)\nselect e.ename,e.deptno,d.deptno,d.dname\nfrom emp_afei e join dept_afei d\non e.deptno = d.deptno\nand d.location = 'beijing'\n4zhangwuji在哪个地区上班?\nselect e.ename,d.dname,d.location\nfrom emp_afei e join dept_afei d\non e.deptno = d.deptno\nand e.ename = 'zhangwuji'\n5列出每个部门有哪些职位?部门名称,职位\n select distinct d.dname,e.job\n from emp_afei e join dept_afei d\n on e.deptno = d.deptno\n order by d.dname\n6各个部门的平均工资,列出部门名称,平均工资.\nselect d.dname,round(avg(e.salary)) savg\nfrom emp_afei e join dept_afei d\non e.deptno = d.deptno\ngroup by d.dname\nselect max(d.dname),round(avg(e.salary)) savg\nfrom emp_afei e join dept_afei d\non e.deptno = d.deptno\ngroup by d.deptno\nselect min(deptno),round(avg(salary))\nfrom emp_hiloo\nwhere deptno = 10\n7 列出每个员工的名字和他的领导的名字\nselect e.ename employee,\n       m.ename manager\nfrom emp_afei e join emp_afei m\non e.mgr = m.empno\n结果集是9条.\ne表中有10条记录,其中9条记录找到匹配,zhangsanfeng没匹配\nm表中有10条记录,其中4条记录找到匹配,4条记录是领导,6条记录找不到匹配,他们是员工.\nselect e.ename employee,\n       m.ename manager\nfrom emp_afei e join emp_afei m\non e.mgr = m.empno\nunion all\nselect ename,'Boss'\nfrom emp_afei\nwhere mgr is null\n\nselect e.ename employee,\n       decode(m.ename,e.ename,'Boss',\n                  m.ename)   manager\nfrom emp_afei e join emp_afei m\non nvl(e.mgr,e.empno) = m.empno\n\nselect e.ename,nvl(m.ename,'Boss')\nfrom emp_afei e left join emp_afei m\non e.mgr = m.empno\n10=9+1\n\n8哪些人是领导?\nselect distinct m.ename\nfrom emp_afei e join emp_afei m\non e.mgr = m.empno\n9哪些部门没有员工?\nselect e.ename,d.dname\nfrom emp_afei e right join dept_afei d\non e.deptno = d.deptno\nwhere e.empno is null\n(解决结果集只包含匹配不上的记录.where子句执行在外连接之后)\n11=10+1\n如果部门表里的某条记录的deptno在emp表找不到匹配,在内连接中,它被过滤,\ne表的empno的特性是唯一且非空的(主键约束),居然e.empno is null,说明null是外连接时为了驱动表中那条匹配不上的记录出现在结果集中,在匹配表中模拟的null记录.\n10哪些人是员工,哪些人不是领导?\nselect e.empno,m.ename\nfrom emp_afei e right join emp_afei m\non e.mgr = m.empno\nwhere e.empno is null\n\nfrom emp_afei e right join emp_afei m\n15=9+(10(m表中有10条记录)-4(m表中有4条匹配记录 ))\nfrom emp_afei e left join emp_afei m\n10(结果集)=9+(10(e表中有10条记录)-9(e表中有9条匹配记录))\n11 哪些部门没有叫zhangwuji的?\nselect d.dname\nfrom emp_afei e right join  dept_afei d\non e.deptno = d.deptno\nand e.ename = 'zhangwuji'\nwhere e.empno is null\n\n7) 课外练习(day04)(答案在Day05)\n1zhangwuji的领导是谁?(表连接)\n2zhangwuji领导谁?(表连接)\n3哪些人是领导?(in exists join)\n4哪些部门没有员工?(not in/not exists/outer join)\n5哪些人是员工,哪些人不是领导?(not in/not exists/outer join)\nDay05.txt\nGrade级别\nLowsal最低工资\nHisal最高工资\nCreate table salgrade_hiloo(\nGrade \n)\ncross join  inner join   outer join\ninner join(匹配)\n  等值连接\n  自连接\n  非等值连接\nouter join(匹配+不匹配)\n  等值连接\n\n  自连接\n  非等值连接\n\n所谓非等值连接表示两张表里的列不能写成等值表达式,而是写成between and之类.所以两个表之间有关系是指表里的列可以写成表达式,而不是等值表达式.\nsalgrade\ngrade  级别\nlowsal 最低工资\nhisal  最高工资\n\nfrom后面跟子查询\nemp,各个部门的平均工资dept_avgsal(depnto,avgsal)\nselect e.ename,e.salary,e.deptno\nfrom emp_afei e join\n      (select deptno,round(avg(salary)) avgsal\n       from emp_afei \n       group by deptno) a\non e.deptno = a.deptno\nand e.salary > a.avgsal\n\n各个部门的平均工资,列出部门名称,平均工资\nselect max(d.dname),round(avg(salary))\nfrom emp_afei e join dept_afei d\non e.deptno = d.deptno\ngroup by d.deptno\n\nselect d.dname,a.avgsal\nfrom dept_afei d join\n      (select deptno,round(avg(salary)) avgsal\n       from emp_afei \n       group by deptno) a\non d.deptno = a.depto\n\nDML\ninsert一条记录时,若某些列为null值,有哪些语法实现?\ninsert into tabname values (1,'a',null,sysdate)\ninsert into tabname(c1,c2,c4)\nvalues (1,'a',sysdate)\ninsert语句的两种语法形式?\ninsert into tabname values () insert一条记录\ninsert into tabname\nselect * from tabname1  insert多条记录\n连接图解：\n    \n\n### 数据类型###\n1) 课外练习答案day04\n1zhangwuji的领导是谁?(表连接)\n select m.ename\n from emp_afei e join emp_afei m\n on e.mgr = m.empno\n and m.ename = 'zhangwuji'\n2 zhanghangwuji领导谁?(表连接)\n select e.ename\n from emp_afei e join emp_afei m\n on e.mgr = m.empno\n and m.ename = 'zhangwuji'\n3哪些人是领导?(in exists join)\n select ename from emp_afei\n where empno in (select mgr from emp_afei)\n select ename from emp_afei o\n where exists\n            (select 1 from emp_afei i\n             where o.empno = i.mgr)\n select distinct m.ename\n from emp_afei e join emp_afei m\n on e.mgr = m.empno\n4哪些部门没有员工?(not in/not exists/outer join)\n select dname from dept_afei\n where deptno not in \n               (select deptno from emp_afei)\n select dname from dept_afei o\n where not exists \n             (select 1 from emp_afei i\n              where o.deptno = i.deptno)\n select d.dname\n from emp_afei e right join dept_afei d\n on e.deptno = d.deptno\n where e.empno is null\n5哪些人是员工,哪些人不是领导?(not in/not exists/outer join)\n select ename from emp_afei\n where empno not in (\n               select mgr from emp_afei\n               where mgr is not null)\n select ename from emp_afei o\n where not exists\n             (select 1 from emp_afei i\n              where o.empno = i.mgr)\n select m.ename\n from emp_afei e right join emp_afei m\n on e.mgr = m.empno\n where e.empno is null\ncross join (笛卡尔积)\n\nrownum 伪列,记录号\n若用rownum选择出记录,编号必须从1开始.\n分页问题\n第一页\nselect rownum,ename\nfrom emp_afei\nwhere rownum <= 3;\n第二页\nselect rn,ename\nfrom (\n      select rownum rn,ename\n      from emp_afei\n      where rownum <= 6)\nwhere rn between 4 and 6\n排名问题\n按工资排名的前三条记录\nselect rownum,ename,salary\nfrom emp_hiloo\nwhere rownum <=3\norder by salary desc;(错)\n\nselect rownum,ename,salary\nfrom ( select ename,salary\n       from emp_afei\n       order by salary desc)\nwhere rownum <= 3\n\nupdate语句的中set后面的=是什么含义?where后面的=是什么含义?\nset c1 = null (= 赋值)\nwhere c1 = null (= 等号)\n\nupdate和delete语句中的where子句是什么含义?\n用来确定对表里的哪些记录要进行update或delete操作,没有where子句多表里的所有记录update或delete\nupdate\nset\nwhere c1 = (select ...)\nrename 关键字 17\ncommit\n\n1011 abc 1000 10 'clerk'\nupdate 1001 1000-->2000\ndelete 1011\ncommit\n如何编写和运行一个sql脚本(文本文件)\n1 编辑文件\n在linux环境下已经编写好了test.sql,做一个鼠标右键的copy\n\n在20,23,26机器上,\nvi test.sql\n按a i o进入编辑模式,paste,按esc键,再按:wq!回车\n\n2 运行文件\nsun-server% sqlplus openlab/open123 @test.sql\n@表示运行\nSP2-0310: unable to open file \"test.sql\"在当前目录下没有test.sql文件\nsqlplus openlab/open123 ../test.sql\n\ncd ..\nsun-server% sqlplus openlab/open123 @test.sql\n\nSQL>@test.sql\n\n数据库对象 PL/SQL\ncreate or replace function test\ninsert into test values (1,1)\n            *\nERROR at line 1:\nORA-04044: procedure(存储过程), function(函数), package(包), or type is not allowed here\n\n事务(transaction 交易)\n事务里包含的DML语句\n事务的结束\ncommit 提交,(dml操作的数据入库了)\nrollback 回滚 撤销(DML操作被取消)\nsqlplus正常退出=commit\nDDL语句自动提交\n开始\n上一个事务的结束是下一个事务的开始.\n一致状态\n数据库的数据被事务改变.\noltp online transaction processing联机事务处理系统 高并发系统\n\n事务的隔离级别 read committed(读已经提交了的数据)\n\n\n如果不commit----->commit rollback\n1如果不commit,其他session是看不见你的操作\n2如果不commit,会阻塞操作同一条记录的事务(session),commit才能释放所有DML加的锁.\n3如果不commit,系统做DML操作,会将old data放入rollback segment(回滚段) ,所占用的回滚段资源不释放.\n\nDML系统会自动给表及表里的记录加锁\n表级共享锁\n行级排他锁\n\t表级共享锁 \t行级排他锁\ns1\tok\t\tok\ns2\tok\t\tenqueue wait\ns3\tok\t\tok\n\n执行DDL语句,系统自动加DDL排他锁\nSQL> drop table test purge;\ndrop table test purge\n           *\nERROR at line 1:\nORA-00054: resource busy(资源忙 test表) and acquire with NOWAIT specified (dml wait,ddl nowait 如果加不上锁,报错退出)\n\nDDL语句\n字符类型\nvarchar2,必须带宽度, 按字符串的实际长度存,本身的数据是变化,对空格敏感\nchar,可以不带宽度,缺省宽度是1,按字符串的定义长度存,本身的数据是固定长度的.对空格不敏感\n数值类型\n\nnumber类型\ncreate table test90\n(c1 number,\n c2 number(6),\n c3 number(4,2),\n c4 number(2,4),\n c5 number(3,-3))\n\n四舍五入\nnumber(6) 表示6为整数 999999\nnumber(4,2) 表示小数点后2位,整数位2位 99.99\nnumber(2,4) 表示小数点后4位,能填数字的位数是2位 0.0099\nnumber(3,-3) 999000 999123-->999000 \n                    999511-->报错\n\nuser_tables 是一张系统表,里面记录当前用户所有的表的信息,里面没有记录表的创建日期.\nuser_objects 是一张系统表,里面记录当前用户所有的数据库对象的信息.created的列记录数据库对象(如表)的创建日期.\nuser_tables和user_objects这两张表的关系体现在table_name和object_name都记录的是表名.\n\ndata block 数据块,操作数据的最小逻辑(物理)单元,最少读一个block的数据\n\nHWM high water mark 高水位线,表示曾经插入数据的最高位置\nFTS full table scan 全表扫描,把表里的所有记录读一遍,把HWM之下的所有data block读一遍\n\ntruncate table 释放空间,HWM下移\ndelete 不释放空间,HWM不动\n不适合用delete命令删大表.\n\n课内练习\n1 列出工资级别为3级,5级的员工\n  select e.ename,e.salary,s.grade\n  from emp_afei e join salgrade_afei s\n  on e.salary between s.lowsal and s.hisal\n  and s.grade in (3,5)\n2 列出各个工资级别有多少人?\n  select s.grade,count(e.empno)\n  from emp_afei e join salgrade_afei s\n  on e.salary between s.lowsal and s.hisal\n  group by s.grade\n  order by s.grade\n3 列出各个工资级别有多少人?(包含0级)\n  select s.grade,count(e.empno)\n  from emp_afei e right join salgrade_afei s\n  on e.salary between s.lowsal and s.hisal\n  group by s.grade\n  order by s.grade\n特别注意count不要写*或者s.grade\n\n课外练习day05\n1按工资排名的第4到第6名员工.\n###关键点###\n课外练习day05答案\n\n按工资排名的第4到第6名员工.\nselect rn,ename,salary\nfrom \n    (select rownum rn,ename,salary\n     from (select ename,salary\n           from emp_afei\n           order by salary desc)\n     where rownum <= 6\n    )\nwhere rn >= 4 \n\n####1）事务####\n\n####约束 constraint (安检)####\nprimary key(主键)\nforeign key(外键)\nunique key (唯一键)\nnot null(非空)\ncheck (检查)\n\n主键 (表中不会出现重复记录)\n列级约束\ncreate table test\n(c1 number(2) \n    constraint test_c1_pk primary key,\n c2 number(3))\n\n    constraint test_c1_pk primary key,\n               *\nERROR at line 3:\nORA-02264: name already used by an existing constraint (名字被存在的约束使用了)\n\nSQL> select table_name from user_constraints\n  2  where constraint_name = 'TEST_C1_PK';\n哪张表里有叫TEST_C1_PK这个约束名.\n\nORA-00001: unique constraint (HILOO(用户名) .TEST_C1_PK) violated(冲突)\n\nPK=UK + NN\n\n表级约束\ncreate table test(\nc1 number(2),\nc2 number,\nconstraint test_c1_pk primary key(c1)\n)\n表中有三列c1,c2,c3,c1和c2做成联合主键\ncreate table test(\nc1 number,\nc2 number,\nconstraint test_c1_c2_pk primary key(c1,c2),\nc3 number\n)\n没有constraint关键字,系统用自动起名字sys_c数字.\n\nnot null\ncreate table test\n(c1 number constraint test_c1_pk primary key,\n c2 number not null);\nnot null约束没有表级形式\n\nunique (pk)\n相同点:都要保证唯一性\n区别:uk允许为null,而且可以多个null值,一个表中只能有一个pk约束,可以有多个uk约束.\ncreate table test\n(c1 number constraint test_c1_pk primary key,\n c2 number constraint test_c2_uk unique)\n\ncreate table test(\nc1 number primary key,\nc2 number primary key,\nc3 number unique,\nc4 number unique)  (报错,一张表只能有一个primary key)\n\ncreate table test(\nc1 number constraint test_c1_pk primary key,\nc2 number constraint test_c2_uk unique,\nc3 number constraint test_c3_uk unique,\nc4 number ) \nc2上定义了一个唯一键 c3上定义了一个唯一键\n\ncreate table test(\nc1 number constraint test_c1_pk primary key,\nc2 number,\nc3 number,\nconstraint test_c2_c3_uk unique (c2,c3),\nc4 number)\nc2,c3联合唯一键\n\ncheck\ncreate table test(\nc1 number(3) constraint test_c1_ck\n             check (c1 > 100))\n\ncreate table test(\nc1 number(3),\nconstraint test_c1_ck check (c1 > 100))\n\n外键\nparent table(父表)上定义唯一列(pk/uk)\nchild table(子表)上定义外键列(fk)\n\n1 先create parent table(pk/uk),再create child table(fk)\n2 先insert into parent table,再insert into child table\n3 先delete from child table,再delete from parent table\n4 先drop child table,再drop parent table\n\nreference 引用\ncreate table parent\n(c1 number(3))\n\ncreate table child\n(c1 number(2) constraint child_c1_pk\n              primary key,\n c2 number(3) constraint child_c2_fk\n              references parent(c1))\n\n              references parent(c1))\n                                *\nERROR at line 5:\nORA-02270: no matching unique or primary key for this column-list\n在c1上没有定义uk或pk\n\nalter table parent\nadd constraint parent_c1_pk primary key(c1);\n给c1列增加主键约束\n\ninsert into child values (1,1)\nORA-02291: integrity constraint(完整性约束) (HILOO.CHILD_C2_FK) violated - parent key not found (父键值没发现)\n违反fk约束\n\ninsert into parent values (1);\ninsert into child values (1,1)\n\ndelete from parent where c1 = 1;\nORA-02292: integrity constraint (HILOO.CHILD_C2_FK) violated - child record\nfound(子记录被发现)\n\ndelete from child where c2 = 1;\ndelete from parent where c1 = 1;\n\ndrop table parent purge;\nORA-02449: unique/primary keys in table referenced by foreign keys\n在parent table上的pk/uk正在fk所引用\n\ndrop table child purge;\ndrop table parent purge;\n\ndrop table parent cascade constraints purge;\ncascade constraints 级联约束,child table本身没被删除,只是先把子表上的fk约束删除,再删parent table.\n\n表级约束\ncreate table child\n(c1 number(2) constraint child_c1_pk \n              primary key,\n c2 number(3),\n constraint child_c2_fk foreign key(c2)\n            references parent(c1)\n)\n\n外键约束另外两种定义方法\ncreate table child1\n(c1 number(2) constraint child1_c1_pk\n              primary key,\n c2 number(3) constraint child1_c2_fk\n              references parent(c1)\n              on delete cascade)\non delete cascade :级联删除会影响到对parent table的删除,先delete from child1,再delete from\nparent\n\ndelete from parent where c1 = 1;\ncreate table child2\n(c1 number(2) constraint child2_c1_pk\n              primary key,\n c2 number(3) constraint child2_c2_fk\n              references parent(c1)\n              on delete set null)\n\ndelete from parent where c1 = 1\n等价于以下操作\nSQL> update child2 set c2 = null\n  2  where c2 = 1;\nSQL> delete from parent where c1 = 1;\n\ntable \nDDL(数据类型 约束)\ntransaction (包含一堆DML)\n\n4000\n100 \n1000\n3100\n\n视图(view)\ncreate table test_t1\nas\nselect * from test\nwhere c1 = 1;\ncreate or replace view test_v1\nas\nselect * from test\nwhere c1 = 1;\ndesc test_v1\nselelct * from test_v1\n\ninsert into test values (1,3);\nselect * from test_v1 (1,3)\ninsert into test_v1 values (1,4)\nselect * from test_v1;\nselect * from test;\ninsert into test_v1 values (2,3);\nselect * from test_v1;(没有)\nselect * from test;(2,3)\n\ndrop table test purge;\nselect * from test_v1; \nSQL> desc test_v1\nERROR:\nORA-24372: invalid object for describe\n无法描述无效对象的结构\n\nSQL> select text from user_views\n  2  where view_name = 'TEST_V1';\n\nTEXT\n-----------------------------------------\nselect \"C1\",\"C2\" from test\nwhere c1 = 1\n\nview是一条select语句. select语句中包含的表为源表.通过view对源表做DML操作.\n\nview作用\n1 create view (deptno = 30)\n  grant view to user\n  限定用户查询的数据 子集\n2 简化查询语句\n3 create view beijing\n  as\n  select * from haidian\n  union all\n  select * from xicheng\n...\n  超集\nview的类型\n1 简单view (DML)\n2 复杂view  (不能DML)\n\ncreate or replace view avgscore_v\nselect s.name,a.avgscore\nfrom student s,\n     (select sid,round(avg(score)) avgscore\n      from stu_cour\n      group by sid) a\non s.id = a.sid\n\nview的约束\ncreate or replace view test_ck\nas\nselect * from test\nwhere c1 = 1\nwith check option;\nc1=2,违反where条件,2,3记录insert时报错\n\ncreate or replace view test_ro\nas\nselect * from test\nwhere c1 = 1\nwith read only;\n只读视图\n#### 索引####\ncreate index test_c1_idx\non test(c1);\n对索引不能做desc,select,DML操作\nrowid 代表一条记录的物理位置\n属于哪个数据对象(table)\n属于哪个数据文件的\n属于数据文件的第几个数据块\n属于数据块里的第几条记录\n#### index的结构####\nindex记录rowid\nindex的结构是一棵平衡树,有三类数据块组成,根节点,分支节点,叶子节点,数据块的数据是排序的.根节点和分支节点用于导航,里面记录下一级节点的物理位置以及该节点包含的数据范围.叶子节点里记录的是index entry(索引项),由key值和rowid组成,key值是建索引的列在每条记录上的取值,rowid是记录的物理位置,所有的叶子节点做成双向链表(升序/降序),适用于范围查询.\n用索引查询的路线图,从根节点出发,找相应的分支节点,叶子节点,最后要找到index entry,通过rowid定位\n表里所需要的数据块,避免了全表扫描.\n\n索引为什么提高查询效率,为select语句\n有效地降低了读取数据块的数量.读取数据块,一种从文件里读,物理读 physical read,一种从内存读,逻辑读 logical read /buffer gets\n\n建索引代价\n空间,DML变慢\n\n\n#### 哪些列适合建索引####\n1 经常出现在where子句的列\n2 pk/uk列\n3 经常出现在表连接的列\n4 fk列 parent.pk列 = child.fk列\n5 经常用于group by,order by的列\n7 where c1 is null(全表扫描),索引里不记null值,\n 该列有大量null值,找not null值用索引会快\n\n#### 索引类型####\n非唯一性索引,提高查询效率\n唯一性索引,解决唯一性.等价建唯一性约束\ncreate unique index test_c2_idx\non test(c2);\n\ninsert into test (c2) values (1)\n*\nERROR at line 1:\nORA-00001: unique constraint(HILOO.TEST_C2_IDX ) violated\n\n联合索引\ncreate index test_c1_c2_idx\non test(c1,c2)\nwhere c1 = 1 and c2 = 1\n\nselect ename from emp_hiloo\nwhere salary*12 > 60000\nwhere salary > 5000\n如果salary建索引,where salary > 5000(用),where salary*12 > 60000(不能用)\n\nwhere upper(ename) = 'ZHANGWUJI'\n\nwhere c1 = 100 c1是varchar2类型\nwhere to_number(c1) = 100\n\nwhere ename like 'a%'\nwhere substr(ename,1,1) = 'a'\n\ndeptno not in (20,30)\ndepotno in (10)\n\n#### 函数索引####\ncreate index test_c1_funidx\non test(round(c1));\nwhere round(c1) = 10\n\ncreate index student_name_idx\non student(name);\n\n#### 序列号####\nsequence\n为table里的主键服务,产生主键值\n唯一值产生器\nsequence_name.nextval\n\n为student表的id建sequence\ninsert into student(student_id.nextval...\n为course表的id建sequence\ninsert into course (course_id.nextval...\n\n创建序列如下：\ncreate sequence SEQ_TEST100\nminvalue 1\nmaxvalue 999999999999999999999999999\nstart with 11\nincrement by 1\ncache 10;\n\n函数\ncreate or replace function dept_avgsal\n(p_deptno number) --定义参数,数据类型不能有宽度\nreturn number    --定义函数的返回类型\nis\n  v_salary emp_hiloo.salary%type;     --变量v_salary 的类型跟表emp_hiloo里的salary的类型定义一致\nbegin\n  select round(avg(salary)) into v_salary\n  from emp_hiloo\n  where deptno = p_deptno;    --select当且仅当返回一条记录用select into语法,表示把select语句的执行结果赋值给v_salary\n  return v_salary;       --返回函数值 \nend;\n.不运行,回到SQL>下\n/表示运行\nshow error\nSQL> select dept_avgsal(10) from dual;\n\n\n\n\n\n练习\n用语法实现多对多关系\nstudent\nid pk\nname not null\n\ncourse\nid pk\nname not null\n\nstu_cour\nsid fk -->student(id)\ncid fk -->course(id)\npk(sid,cid)\nscore check [0,100](between and) \n#### 数据库日期比较####\nSql代码：\n1\ttimesten内存数据库比较日期是不是同一天,低效的方法  \n2\tto_char(create_date,'yyyymmdd')=to_char(sysdate NUMTODSINTERVAL(60*60*24,'SECOND'),'yyyymmdd')  \n3\toracle 数据库低效的方法  \n4\tto_char(create_date,'yyyymmdd')=to_char(sysdate-1,'yyyymmdd')   \n5\t2个数据库通用高效的方法  \n6\ttrunc(create_date)=trunc(sysdate)-NUMTODSINTERVAL(1,'DAY')  \n查找数据库里的表，索引等\n支持oracle的模糊查询如select * from user_tables where table_name like '%_PROJECT';查表名以PROJECT结尾的表（注：区别大小写）\n查所有用户的表在all_tables\n主键名称、外键在all_constraints\n索引在all_indexes\n但主键也会成为索引，所以主键也会在all_indexes里面。\n具体需要的字段可以DESC下这几个view，dba登陆的话可以把all换成dba。\n\n查询用户表的索引(非聚集索引):\nselect * from user_indexes\nwhere uniqueness = 'NONUNIQUE'\n\n查询用户表的主键(聚集索引):\nselect * from user_indexes\nwhere uniqueness = 'UNIQUE'\n\n1、\t查找表的所有索引（包括索引名，类型，构成列）：\nselect t.*,i.index_type from user_ind_columns t,user_indexes i where t.index_name = i.index_name and t.table_name = i.table_name and t.table_name = 要查询的表\n2、查找表的主键（包括名称，构成列）：\nselect cu.* from user_cons_columns cu, user_constraints au where cu.constraint_name = au.constraint_name and au.constraint_type = 'P' and au.table_name = 要查询的表\n3、查找表的唯一性约束（包括名称，构成列）：\nselect column_name from user_cons_columns cu, user_constraints au where cu.constraint_name = au.constraint_name and au.constraint_type = 'U' and au.table_name = 要查询的表\n4、查找表的外键（包括名称，引用表的表名和对应的键名，下面是分成多步查询）：\nselect * from user_constraints c where c.constraint_type = 'R' and c.table_name = 要查询的表\n查询外键约束的列名：\nselect * from user_cons_columns cl where cl.constraint_name = 外键名称\n查询引用表的键的列名：\nselect * from user_cons_columns cl where cl.constraint_name = 外键引用表的键名\n5、查询表的所有列及其属性\nselect t.*,c.COMMENTS from user_tab_columns t,user_col_comments c where t.table_name = c.table_name and t.column_name = c.column_name and t.table_name = 要查询的表\n####数据唯一Id：####\n1.\t用Oracle来生成UUID，做法很简单，如下：select sys_guid() from dual;数据类型是 raw(16) 有32个字符。\ncreate table test_guid3(\n    id varchar(50)\n)\nselect * from test_guid3;\ninsert into test_guid3(id) values(sys_guid())\n----------- ----------------------------------------\n       1000 7CD5B7769DF75CEFE034080020825436\n       1100 7CD5B7769DF85CEFE034080020825436\n       1200 7CD5B7769DF95CEFE034080020825436\n       1300 7CD5B7769DFA5CEFE034080020825436\n### 名词###\n\n#### Oracle的方案（Schema）和用户（User）的区别####\n \n从定义中我们可以看出方案（Schema）为数据库对象的集合，为了区分各个集合，我们需要给这个集合起个名字，这些名字就是我们在企业管理器的方案下看到的许多类似用户名的节点，这些类似用户名的节点其实就是一个schema，schema里面包含了各种对象如tables, views, sequences, stored procedures, synonyms, indexes, clusters, and database links。\n \n   一个用户一般对应一个schema,该用户的schema名等于用户名，并作为该用户缺省schema。这也就是我们在企业管理器的方案下看到schema名都为数据库用户名的原因。Oracle数据库中不能新创建一个schema，要想创建一个schema，只能通过创建一个用户的方法解决(Oracle中虽然有create schema语句，但是它并不是用来创建一个schema的)，在创建一个用户的同时为这个用户创建一个与用户名同名的schem并作为该用户的缺省shcema。即schema的个数同user的个数相同，而且schema名字同user名字一一对应并且相同，所有我们可以称schema为user的别名，虽然这样说并不准确，但是更容易理解一些。\n \n   一个用户有一个缺省的schema，其schema名就等于用户名，当然一个用户还可以使用其他的schema。如果我们访问一个表时，没有指明该表属于哪一个schema中的，系统就会自动给我们在表上加上缺省的sheman名。比如我们在访问数据库时，访问scott用户下的emp表，通过select * from emp; 其实，这sql语句的完整写法为select * from scott.emp。在数据库中一个对象的完整名称为schema.object，而不属user.object。类似如果我们在创建对象时不指定该对象的schema，在该对象的schema为用户的缺省schema。这就像一个用户有一个缺省的表空间，但是该用户还可以使用其他的表空间，如果我们在创建对象时不指定表空间，则对象存储在缺省表空间中，要想让对象存储在其他表空间中，我们需要在创建对象时指定该对象的表空间。\n \n   oracle中的schema就是指一个用户下所有对象的集合，schema本身不能理解成一个对象，oracle并没有提供创建schema的语法，schema也并不是在创建user时就创建，而是在该用户下创建第一个对象之后schema也随之产生，只要user下存在对象，schema就一定存在，user下如果不存在对象，schema也不存在；这一点类似于temp tablespace group，另外也可以通过oem来观察，如果创建一个新用户，该用户下如果没有对象则schema不存在，如果创建一个对象则和用户同名的schema也随之产生。\n####Oracle中User与Schema的简单理解####\n技术积累（126）  \n版权声明：本文为博主原创文章，未经博主允许不得转载。\n方案（Schema）为数据库对象的集合，为了区分各个集合，我们需要给这个集合起个名字，这些名字就是我们在企业管理器的方案下看到的许多类似用户名的节点，这些类似用户名的节点其实就是一个schema，schema里面包含了各种对象如tables, views, sequences, stored procedures, synonyms, indexes, clusters, and database links。  一个用户一般对应一个schema,该用户的schema名等于用户名，并作为该用户缺省schema。\nSQL Server中的Schema\nSQL Server中一个用户有一个缺省的schema，其schema名就等于用户名，这也就是我们在企业管理器的方案下看到schema名都为数据库用户名的原因。当然一个用户还可以使用其他的schema。如果我们访问一个表时，没有指明该表属于哪一个schema中的，系统就会自动给我们在表上加上缺省的sheman名。比如我们在访问数据库时，访问scott用户下的emp表，通过select * from emp; 其实，这sql语句的完整写法为select * from scott.emp。在数据库中一个对象的完整名称为schema.object，而不属user.object。类似如果我们在创建对象时不指定该对象的schema，在该对象的schema为用户的缺省schema。这就像一个用户有一个缺省的表空间，但是该用户还可以使用其他的表空间，如果我们在创建对象时不指定表空间，则对象存储在缺省表空间中，要想让对象存储在其他表空间中，我们需要在创建对象时指定该对象的表空间。\n\nOracle中的Schema\nOracle中的schema就是指一个用户下所有对象的集合，schema本身不能理解成一个对象，oracle并没有提供创建schema的语法，schema也并不是在创建user时就创建，而是在该用户下创建第一个对象之后schema也随之产生，只要user下存在对象，schema就一定存在，user下如果不存在对象，schema也不存在；如果创建一个新用户，该用户下如果没有对象则schema不存在，如果创建一个对象则和用户同名的schema也随之产生。实际上在使用上，shcema与user完全一样，没有什么区别，在出现schema名的地方也可以出现user名。\n\nTablspace \n逻辑上用来放objects,，这是个逻辑概念，本质上是一个或者多个数据文件的集合，物理上对应磁盘上的数据文件或者裸设备。\n\n数据文件\n具体存储数据的物理文件，是一个物理概念。一个数据文件只能属于一个表空间，一个表空间可以包含一个或多个数据文件。一个数据库由多个表空间组成，一个表空间只能属于一个数据库。\n\n下边是源自网络的一个形象的比喻\n我们可以把Database看作是一个大仓库，仓库分了很多很多的房间，Schema就是其中的房间，一个Schema代表一个房间，Table可以看作是每个Schema中的床，Table（床）被放入每个房间中，不能放置在房间之外，那岂不是晚上睡觉无家可归了，然后床上可以放置很多物品，就好比 Table上可以放置很多列和行一样，数据库中存储数据的基本单元是Table，现实中每个仓库放置物品的基本单位就是床， User就是每个Schema的主人，（所以Schema包含的是Object，而不是User），user和schema是一一对应的，每个user在没有特别指定下只能使用自己schema（房间）的东西，如果一个user想使用其他schema（房间）的东西，那就要看那个schema（房间）的user（主人）有没有给你这个权限了，或者看这个仓库的老大（DBA）有没有给你这个权限了。换句话说，如果你是某个仓库的主人，那么这个仓库的使用权和仓库中的所有东西都是你的（包括房间），你有完全的操作权，可以扔掉不用的东西从每个房间，也可以放置一些有用的东西到某一个房间，你还可以给每个User分配具体的权限，也就是他到某一个房间能做些什么，是只能看（Read-Only），还是可以像主人一样有所有的控制权（R/W），这个就要看这个User所对应的角色Role了。\n#### oracle的schema的含义####\n在现在做的Kraft Catalyst 项目中，Cransoft其中有一个功能就是schema refresh. 一直不理解schema什么意思，也曾经和同事讨论过，当时同事就给我举过一个例子，下面会详细说的。其实schema是Oracle中的，其他数据库中不知道有没有这个概念。\n首先,可以先看一下schema和user的定义：\nA schema is a collection of database objects (used by a user).\nSchema objects are the logical structures that directly refer to the database’s data.\nA user is a name defined in the database that can connect to and access objects.\nSchemas and users help database administrators manage database security.\n从中我们可以看出,schema为数据库对象的集合，为了区分各个集合，需要给这个集合起个名字，这些名字就是在企业管理器的方案下看到的许多类似用户名的节点，这些类似用户名的节点其实就是一个schema。\nschema里面包含了各种对象如tables, views, sequences, stored procedures, synonyms, indexes, clusters, and database links。\n一个用户一般对应一个schema，该用户的schema名等于用户名，并作为该用户缺省schema。这也就是在企业管理器的方案下看到schema名都为数据库用户名的原因。\nOracle数据库中不能新创建一个schema，要想创建一个schema，只能通过创建一个用户的方法解决(Oracle中虽然有create schema语句，但是它并不是用来创建一个schema的)。在创建一个用户的同时，为这个用户创建一个与用户名同名的schem并作为该用户的缺省 shcema。即schema的个数同user的个数相同，而且schema名字同user名字一一 对应并且相同，所有我们可以称schema为user的别名，虽然这样说并不准确，但是更容易理解一些。\n一个用户有一个缺省的schema，其schema名就等于用户名，当然一个用户还可以使用其他的schema。如果我们访问一个表时，没有指明该表属于 哪一个schema中的，系统就会自动给我们在表上加上缺省的sheman名。比如我们在访问数据库时，访问scott用户下的emp表，通过 select * from emp; 其实，这sql语句的完整写法为select * from scott.emp。在数据库中一个对象的完整名称为schema.object，而不属user.object。类似如果我们在创建对象时不指定该对象 的schema，在该对象的schema为用户的缺省schema。这就像一个用户有一个缺省的表空间，但是该用户还可以使用其他的表空间，如果我们在创 建对象时不指定表空间，则对象存储在缺省表空间中，要想让对象存储在其他表空间中，需要在创建对象时指定该对象的表空间。\n有人举了个很生动的例子，来说明Database、User、Schema、Tables、Col、Row等之间的关系\n“可以把Database看作是一个大仓库，仓库分了很多很多的房间，Schema就是其中的房间，一个Schema代表一个房间，Table可以看作是每个Schema中的床，Table（床）就被放入每个房间中，不能放置在房间之外，那岂不是晚上睡觉无家可归了。\n然后床上可以放置很多物品，就好比Table上可以放置很多列和行一样，数据库中存储数据的基本单元是Table，现实中每个仓库放置物品的基本单位就是床， User就是每个Schema的主人（所以Schema包含的是Object，而不是User）。\n其实User是对应与数据库的（即User是每个对应数据库的主人），既然有操作数据库（仓库）的权利，就肯定有操作数据库中每个Schema（房间）的 权利，就是说每个数据库映射的User有每个Schema（房间）的钥匙，换句话说，如果他是某个仓库的主人，那么这个仓库的使用权和仓库中的所有东西都 是他的（包括房间），他有完全的操作权，可以扔掉不用的东西从每个房间，也可以放置一些有用的东西到某一个房间。还可以给User分配具体的权限，也就是 他到某一个房间能做些什么，是只能看（Read-Only），还是可以像主人一样有所有的控制权（R/W），这个就要看这个User所对应的角色Role 了”\n从定义中我们可以看出schema为数据库对象的集合，为了区分各个集合，我们需要给这个集合起个名字，这些名字就是我们在企业管理器的方案下看到的许多类似用户名的节点，这些类似用户名的节点其实就是一个schema，schema里面包含了各种对象如tables, views, sequences, stored procedures, synonyms, indexes, clusters, and database links。\n一个用户一般对应一个schema,该用户的schema名等于用户名，并作为该用户缺省schema。这也就是我们在企业管理器的方案下看到schema名都为数据库用户名的原因。Oracle数据库中不能新创建一个schema，要想创建一个schema，只能通过创建一个用户的方法解决(Oracle中虽然有create schema语句，但是它并不是用来创建一个schema的)，在创建一个用户的同时为这个用户创建一个与用户名同名的schem并作为该用户的缺省shcema。即schema的个数同user的个数相同，而且schema名字同user名字一一 对应并且相同，所有我们可以称schema为user的别名，虽然这样说并不准确，但是更容易理解一些。\n一个用户有一个缺省的schema，其schema名就等于用户名，当然一个用户还可以使用其他的schema。如果我们访问一个表时，没有指明该表属于哪一个schema中的，系统就会自动给我们在表上加上缺省的sheman名。比如我们在访问数据库时，访问scott用户下的emp表，通过select * from emp; 其实，这sql语句的完整写法为select * from scott.emp。在数据库中一个对象的完整名称为schema.object，而不属user.object。类似如果我们在创建对象时不指定该对象的schema，在该对象的schema为用户的缺省schema。这就像一个用户有一个缺省的表空间，但是该用户还可以使用其他的表空间，如果我们在创建对象时不指定表空间，则对象存储在缺省表空间中，要想让对象存储在其他表空间中，我们需要在创建对象时指定该对象的表空间。\n咳，说了这么多，给大家举个例子，否则，一切枯燥无味！\nSQL> Gruant dba to scott\nSQL> create table test(name char(10));\nTable created.\nSQL> create table system.test(name char(10));\nTable created.\nSQL> insert into test values('scott');\n1 row created.\nSQL> insert into system.test values('system');\n1 row created.\nSQL> commit;\nCommit complete.\nSQL> conn system/manager\nConnected.\nSQL> select * from test;\n\nNAME\n----------\nsystem\nSQL> ALTER SESSION SET CURRENT_SCHEMA = scott; --改变用户缺省schema名\nSession altered.\nSQL> select * from test;\n\nNAME\n----------\nscott\nSQL> select owner ,table_name from dba_tables where table_name=upper('test');\nOWNER TABLE_NAME\n------------------------------ ------------------------------\nSCOTT TEST\nSYSTEM TEST\n--上面这个查询就是我说将schema作为user的别名的依据。实际上在使用上，shcema与user完全一样，没有什么区别，在出现schema名的地方也可以出现user名。\n表空间：\n一个表空间就是一片磁盘区域,他又一个或者多个磁盘文件组成,一个表空间可以容纳许多表、索引或者簇等  \n  每个表空间又一个预制的打一磁盘区域称为初始区间（initial   extent）用完这个区间厚在用下一个，知道用完表空间，这时候需要对表空间进行扩展，增加数据文件或者扩大已经存在的数据文件\n \n \n\ninstance是一大坨内存sga,pga....和后台的进程smon pmon.....组成的一个大的应用。\nschema就是一个用户和他下面的所有对象。。\ntablspace 逻辑上用来放objects.物理上对应磁盘上的数据文件或者裸设备。\n 在Oracle中，结合逻辑存储与物理存储的概念，我们可以这样来理解数据库、表空间、SCHEMA、数据文件这些概念：\n      数据库是一个大圈，里面圈着的是表空间，表空间里面是数据文件，那么schema是什么呢？schema是一个逻辑概念，是一个集合，但schema并不是一个对象，oracle也并没有提供创建schema的语法。\nschema：\n      一般而言，一个用户就对应一个schema,该用户的schema名等于用户名，并作为该用户缺省schema，用户是不能创建schema的，schema在创建用户的时候创建，并可以指定用户的各种表空间（这点与PostgreSQL是不同，PostgreSQL是可以创建schema并指派给某个用户）。当前连接到数据库上的用户创建的所有数据库对象默认都属于这个schema（即在不指明schema的情况下），比如若用户scott连接到数据库，然后create table test(id int not null)创建表，那么这个表被创建在了scott这个schema中；但若这样create kanon.table test(id int not null)的话，这个表被创建在了kanon这个schema中，当然前提是权限允许。\n      创建用户的方法是这样的：\n      create user 用户名 identified by 密码 \n      default tablespace 表空间名 \n      temporary tablespace 表空间名 \n      quota 限额  （建议创建的时候指明表空间名）\n由此来看，schema是一个逻辑概念。\n      但一定要注意一点：schema好像并不是在创建user时就创建的，而是在该用户创建了第一个对象之后才将schema真正创建的，只有user下存在对象，他对应的schema才会存在，如果user下不存在任何对象了，schema也就不存在了；\n \n数据库：\n     在oracle中，数据库是由表空间来组成的，而表空间里面是具体的物理文件---数据文件。我们可以创建数据库并为其指定各种表空间。\n \n表空间：\n     这是个逻辑概念，本质上是一个或者多个数据文件的集合。\n \n数据文件：\n     具体存储数据的物理文件，是一个物理概念。\n     一个数据文件只能属于一个表空间，一个表空间可以包含一个或多个数据文件。一个数据库由多个表空间组成，一个表空间只能属于一个数据库。\n","slug":"oracle/Oracle SQL基础知识","published":1,"updated":"2017-08-18T01:44:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bq300ccs77rcewj5wa8","content":"<h2 id=\"Oracle-SQL基本知识\"><a href=\"#Oracle-SQL基本知识\" class=\"headerlink\" title=\"Oracle SQL基本知识\"></a>Oracle SQL基本知识</h2><h3 id=\"安装数据库\"><a href=\"#安装数据库\" class=\"headerlink\" title=\"安装数据库\"></a>安装数据库</h3><h4 id=\"1）安装Oracle常用问题-常用”用户名-密码“规则-：\"><a href=\"#1）安装Oracle常用问题-常用”用户名-密码“规则-：\" class=\"headerlink\" title=\"1）安装Oracle常用问题(常用”用户名/密码“规则)：\"></a>1）安装Oracle常用问题(常用”用户名/密码“规则)：</h4><p>超级管理员：sys /change_on_install<br>普通管理员：system/manager<br>普通用户：scott/tiger—–&gt;默认是被锁定的<br>大数据用户：sh/sh</p>\n<h4 id=\"2）SQL-DDL…\"><a href=\"#2）SQL-DDL…\" class=\"headerlink\" title=\"2）SQL,DDL…\"></a>2）SQL,DDL…</h4><p>SQL：structured query language 结构化查询语言<br>1.file(文件)</p>\n<p>SQL:DDL DML TCL DQL DCL<br>DDL(data definition language 数据定义语言): column(列)–structure<br>create table (创建表):<br>列名 data type(数据类型) width(宽度)<br>constraint (约束)      alter table(修改表结构)           drop table(删除表)</p>\n<p>DML(data manipulation language 数据操作语言)<br>:row(行)–data<br>insert 增       update 改            delete 删数据,删表里的记录</p>\n<p>TCL(transaction control language 事务控制语言)<br>commit(提交)         rollback(回滚)               savepoint(保留点)</p>\n<p>DQL(data query language 数据查询语言)<br>select<br>DCL(data control language 数据控制语言)<br>grant(授权)  grant to       revoke(回收权限) revoke from </p>\n<h4 id=\"3）RDBMS关系型数据库管理系统\"><a href=\"#3）RDBMS关系型数据库管理系统\" class=\"headerlink\" title=\"3）RDBMS关系型数据库管理系统\"></a>3）RDBMS关系型数据库管理系统</h4><p>RDBMS(relationship database management system 关系型数据库管理系统) software(软件) —&gt;(create database)database—&gt;login in database (登录数据库系统 )—&gt;用SQL操作table</p>\n<p>create database 创建空间存储表 (datafile 数据文件)<br>login in database<br>1 远程登录到数据库所在的机器上<br>  192.168.0.20 192.168.0.23 192.168.0.26<br>shell(终端) telnet 192.168.0.20  (跟操作系统建连接)<br>login:openlab<br>password:open123<br>sunv210% shell提示符,执行操作系统命令</p>\n<h4 id=\"4）-登录该机器上的数据库系统\"><a href=\"#4）-登录该机器上的数据库系统\" class=\"headerlink\" title=\"4） 登录该机器上的数据库系统\"></a>4） 登录该机器上的数据库系统</h4><p>sunv210% sqlplus (跟数据库建连接)<br>Enter user-name: openlab<br>Enter password:open123<br>SQL&gt;sqlplus openlab/open123<br>SQL&gt; 数据库提示符,执行SQL命令</p>\n<h4 id=\"5）登录的是哪个数据库\"><a href=\"#5）登录的是哪个数据库\" class=\"headerlink\" title=\"5）登录的是哪个数据库\"></a>5）登录的是哪个数据库</h4><p>echo $ORACLE_SID(环境变量)&lt;—DBA(database administrator 数据库管理员)<br>查看ORACLE_SID变量的取值,oracle提供<br>通过设置ORACLE_SID变量,sqlplus就知道跟哪个数据库建连接.<br>unix平台<br>%c shell<br>%echo $ORACLE_SID  (tarena)<br>%setenv ORACLE_SID hiloo<br>%setenv ORACLE_SID tarena</p>\n<p>$ b shell<br>$ echo $ORACLE_SID  (tarena)<br>$ ORACLE_SID=hiloo<br>$ export ORACLE_SID</p>\n<p>windows平台<br>D:>set ORACLE_SID=hiloo (设置环境变量)<br>D:>set ORACLE_SID (查看环境变量)<br>ORACLE_SID=hiloo</p>\n<h5 id=\"数据表信息：\"><a href=\"#数据表信息：\" class=\"headerlink\" title=\"数据表信息：\"></a>数据表信息：</h5><p>dept(表名) department 部门信息   列名<br>deptno 部门号  dname  部门名称      location 位置(地区)<br>create table dept_hiloo<br>(deptno  number(2), dname char(20),  location char(20));<br>insert into dept_hiloo values (10,’developer’,’beijing’);<br>insert into dept_hiloo values (20,’account’,’shanghai’);<br>insert into dept_hiloo values (30,’sales’,’guangzhou’);<br>insert into dept_hiloo values  ( 40,’operations’,’tianjin’);<br>commit;<br>insert成功后的提示:1 rows inserted<br>emp(表名) employee 员工信息    列名<br>empno 员工 ename 员工名字  job   职位   salary  月薪   bonus   奖金<br>hiredate  入职日期  mgr   manager 管理者    deptno  部门号<br>create table emp_hiloo(<br>empno number(4),    ename varchar2(20),  job  varchar2(15),<br>salary number(7,2), bonus number(7,2),  hiredate date,<br> mgr number(4),  deptno number(10));<br>alter session set nls_date_language=’american’;<br>insert into emp_hiloo values (1001,’zhangwuji’,’Manager’,10000,2000,’12-MAR-10’,1005,10);<br>insert into emp_hiloo values (1001,’zhangwuji’,’Manager’,10000,2000,’12-MAR-10’,1005,10);<br>insert into emp_hiloo values (1002,’liucangsong’,’Analyst’,8000,1000, ‘01-APR-11’,1001,10);<br>insert into emp_hiloo values (1003,’liyi’,’Analyst’,9000,1000,’11-APR-10’,1001,10);<br>insertinto emp_hiloo values (1004,’guofurong’,’Programmer’,5000,null,’01-JAN-11’,1001,10);<br>insertintoemp_hiloo values (1005,’zhangsanfeng’,’President’,15000,null,’15-MAY-08’,null,20);<br>insert into emp_hiloo values (1006,’yanxiaoliu’,’Manager’,5000,400,’01-FEB-09’,1005,20);<br>insert into emp_hiloo values (1007,’luwushuang’,’clerk’,3000,500,’01-FEB-06’,1006,20);<br>insert into emp_hiloo values (1008,’huangrong’,’Manager’,5000,500,’1-MAY-09’,1005,30);<br>insert into emp_hiloo values (1009,’weixiaobao’,’salesman’,4000,null,’20-FEB-09’,1008,30);<br>insert into emp_hiloo values (1010,’guojing’,’salesman’,4500,500,’10-MAY-09’,1008,30);<br>报错信息<br>ORA-00955: name is already used by an existing object(名字已经被一个存在的对象使用)<br>错误：ORA-01843:无效的月份（在中文的plsql控制台上月份要写成’10-3月-02’这种形式，必须是一个数字和一个汉语月。也可以把日期改成英文环境，在执行插入前执行alter session set nls_date_language=’american’;就可以 了。</p>\n<p>DQL<br>select(选择)<br>源表  结果集<br>1 投影操作 select子句实现<br>2 选择操作 where子句实现<br>3 连接操作<br> 1  select ename,salary<em>12 ann_sal(列别名)<br> 2</em> from emp_hiloo</p>\n<p>单引号 表达字符串 ‘’<br>双引号 表达列别名 “”,别名中包含空格,大小写敏感</p>\n<h5 id=\"1）null值的理解\"><a href=\"#1）null值的理解\" class=\"headerlink\" title=\"1）null值的理解\"></a>1）null值的理解</h5><p>1 null值出现在算术表达式中,结果必为null,null可以看作无穷大.<br>2 函数(function) nvl功能空值转换函数<br>nvl是函数名,p1,p2是参数,数据类型必须一致,函数本身有返回值<br>nvl(p1,p2)<br>nvl函数实现:<br>if p1 is null then<br>   return p2;<br>else<br>   return p1;<br>end if;</p>\n<p>3 若有多个null值,distinct去重时,结果集保留一个null值.<br>4 null = null 不成立 null &lt;&gt; null 不成立<br>5 若用in运算符,集合中有null值跟没有null值结果一致的,结果集中不会出现跟null值有关的记录<br>  若用not in运算符,集合中有null值,这个结果集不包含记录.no rows selected.</p>\n<h5 id=\"2）各个子句的功能\"><a href=\"#2）各个子句的功能\" class=\"headerlink\" title=\"2）各个子句的功能\"></a>2）各个子句的功能</h5><p>1 select后面跟列名,列别名,函数,表达式<br>2 select后面的distinct:去重<br>3 where子句<br>  where 条件表达式 (列名 比较运算符 值)<br>表达式 比较运算符 值(尽量不用,为了性能)<br>  where子句中的列为字符类型,放值的位置上不加单引号或加双引号当列名解释,加单引号当字符串解释.<br>  where子句中的列为字符类型,表达具体值时注意字符是大小写敏感的.<br>SQL提供的四个比较运算符<br>肯定形式<br>   between and 区间,范围<br>   in &lt;=&gt; =any  (= or = )(跟集合里的任意一个值相等就满足条件) 集合 离散值<br>   = 单值运算符<br>   in =any 多值运算符<br>   like 像…一样<br>   通配符: %表示0或任意多个字符 <em>任意一个字符<br>   ‘S’ ‘S%’ ‘S</em>‘<br>   is null  如何判断一个列的取值是否为空<br>否定形式<br>= &lt;&gt; != ^=<br>between and   not between and<br>in    not in (&lt;&gt; and &lt;&gt;) &lt;=&gt; &lt;&gt;all(跟集合里的所有值都不能相等)<br>like     not like<br>is null   is not null<br>各个子句的执行顺序<br>from–&gt;where–&gt;select</p>\n<h5 id=\"3）课堂练习\"><a href=\"#3）课堂练习\" class=\"headerlink\" title=\"3）课堂练习\"></a>3）课堂练习</h5><p>1 列出每个员工的名字和他的工资<br>  select ename,salary from emp_hiloo;<br>2 列出每个员工的名字和他的职位<br>  select ename,job from emp_hiloo;<br>3 列出每个员工的名字和他的年薪<br> select ename,salary<em>12 ann_sal from emp_hiloo;<br>4 列出每个员工的名字和他一年的总收入<br>  (salary+bonus)</em>12 (15000+null)<em>12=null<br>  select ename,(salary+nvl(bonus,0))</em>12 tol_sal<br>  from emp_hiloo;<br>5 输出结果如下:<br>  zhangwuji is in department 10.<br>  liucangsong is in department 10.<br>  …..<br>  guojing is in department 30.<br>select ename||’is in department’||deptno||’.’employee from emp_hiloo;<br>什么要加employee呢？Employee是列别名为了显示用的。<br>6 列出该公司有哪些职位<br>  select distinct(job) from emp_hiloo;<br>  select distinct job from emp_hiloo;<br>7 列出该公司不同的奖金<br>  select distinct bonus from emp_hiloo;<br>8 各个部门有哪些不同的职位?<br>  select distinct deptno,job from emp_hiloo;<br>  去重方式:deptno和job联合唯一.<br>  distinct之后和from之前的所有列联合唯一.<br>distinct是保证每一行的唯一性而非某一列的唯一性，所以必须紧跟在select后面。<br>所以distinct只能放在select后面，紧跟select不然会报缺失表达式错误。<br>9 哪些员工的工资高于5000?<br>  select ename,salary from emp_hiloo<br>  where salary &gt; 5000;<br>10 列出员工工资高于5000的员工的年薪?<br>  select ename,salary<em>12 from emp_hiloo<br>  where salary &gt; 5000;<br>11 列出员工年薪高于60000的员工的年薪?<br>  select ename,salary</em>12 from emp_hiloo<br>  where salary<em>12&gt; 60000;<br>  select ename,salary</em>12 ann_sal from emp_hiloo<br>  where ann_sal &gt; 60000(错误的写法)<br>  select ename,salary<em>12 from emp_hiloo<br>  where salary &gt; 5000;<br>12 zhangwuji的年薪是多少?<br>select ename,salary</em>12 from emp_hiloo<br>where ename=’zhangwuji’;<br>  哪些员工的职位是Manager?<br>select ename,job from emp_hiloo<br>where job=’Manager’;<br>  哪些员工的职位是clerk?<br>  select ename,job from emp_hiloo<br>  where job = ‘Manager’<br>   select ename,job from emp_hiloo<br>  where job = ‘clerk’(效率高)<br>  clerk的大小写不清楚<br>  函数:upper(),lower()<br>  select ename,job from emp_hiloo<br>  where upper(job) = ‘CLERK’ (通用性好)<br>13 员工工资在5000到10000之间的员工的年薪<br>   select ename,salary<em>12<br>   from emp_hiloo<br>   where salary &gt;= 5000<br>   and   salary &lt;= 10000;<br>   select ename,salary</em>12<br>   from emp_hiloo<br>   where salary between 5000 and 10000;<br>14 哪些员工的工资是5000或10000.<br>   select ename,salary<br>   from emp_hiloo<br>   where salary = 5000<br>   or salary = 10000<br>   select ename,salary<br>   from emp_hiloo<br>   where salary in (5000,10000)<br>   select ename,salary<br>   from emp_hiloo<br>   where salary =any (5000,10000)<br>15 哪个员工的名字的第二个字符是a.<br>   select ename<br>   from emp_hiloo<br>   where ename like ‘<em>a%’;<br>16 哪个员工的名字的第二个字符是</em>.<br>   select ename<br>   from emp_hiloo<br>   where ename like ‘__%’ escape ‘\\’;<br>   第一个<em>表示任意一个字符,代表通配符<br>   \\</em>必须连起来看,表示下划线本身,escape定义哪个字符可以定义转义’\\’<br>17 哪些员工没有奖金?<br>   select ename,bonus<br>   from emp_hiloo<br>   where bonus is null<br>18 哪些员工有奖金?<br>   select ename,bonus<br>   from emp_hiloo<br>   where bonus is not null<br>19哪些员工的工资不是5000也不是10000.<br>  select ename,salary<br>  from emp_hiloo<br>  where salary not in (5000,10000);<br>  select ename,salary<br>  from emp_hiloo<br>  where salary &lt;&gt; 5000<br>  and salary &lt;&gt; 10000</p>\n<p>create table emp_hiloo<br>( hiredate date）<br>insert into emp_hiloo values (1001,’zhangwuji’,’Manager’,10000,2000,’12-MAR-10’,1005,10);<br>解决方案：<br>    insert into emp_hiloo values (1001,’zhangwuji’,’Manager’,10000,2000,’12-3月-10’,1005,10);</p>\n<h5 id=\"更改字段名字-mysql、orcle-：\"><a href=\"#更改字段名字-mysql、orcle-：\" class=\"headerlink\" title=\"更改字段名字(mysql、orcle)：\"></a>更改字段名字(mysql、orcle)：</h5><p>Oracle修改表<br>alter table 表名 rename column 原名 to 新名；<br>Mysql:<br>alter table 表名 change column(可写，可不写）原名 新名 字段类型；</p>\n<p>ORA-00904：“ANN_SAL”:invalid identifier<br>无效的标识符</p>\n<p>index(索引) view(视图) sequence(顺序号/序列号) function(函数)<br>session altered.会话已更改<br>set feed on可以设置一个，显示操作数<br>connet tiger重新建立连接  show user查看当前用户是谁。<br>edit 用记事本编辑  /运行。</p>\n<p>###Function (单行、多行)###<br>单行函数:表中的一列作为函数的参数,对于每一条记录函数都有一个返回值.<br>例如:upper lower nvl<br>多行函数：表中的一列作为函数的参数,将记录分组,对于每组数据函数返回一个值.<br>例如:avg</p>\n<p>####1）单行函数####<br> 根据处理参数的数据类型分为</p>\n<h5 id=\"1）字符函数-upper-lower\"><a href=\"#1）字符函数-upper-lower\" class=\"headerlink\" title=\"1）字符函数:upper,lower\"></a>1）字符函数:upper,lower</h5><h5 id=\"2）数值函数\"><a href=\"#2）数值函数\" class=\"headerlink\" title=\"2）数值函数:\"></a>2）数值函数:</h5><pre><code>round 四舍五入\nround(12.345,2)--&gt;12.35\nround(12.345,0)=round(12.345)--&gt;12\nround(12,345,-1)--&gt;10\ntrunc 截取\ntrunc(12.345,2)--&gt;12.34\ntrunc(12.345,0)=trunc(12.345)--&gt;12\ntrunc(12,345,-1)--&gt;10\n</code></pre><h5 id=\"3-日期和日期函数\"><a href=\"#3-日期和日期函数\" class=\"headerlink\" title=\"3) 日期和日期函数\"></a>3) 日期和日期函数</h5><pre><code>select sysdate from dual\n06-SEP-12 DD-MON-RR \nalter session set\n  nls_date_format = &apos;yyyy mm dd hh24:mi:ss&apos;\nsession 会话 connection(连接)\n</code></pre><p>   日期类型的数据是用固定的字节7个字节来存储世纪,年,月,日,时,分,秒. 格式敏感<br>   会话级 alter session set nls_date_format<br>   语句级 select to_char(c1日期类型用7个字节来表达，日期类型的数据是用固定的字节7个字节来存储世纪，年，月，日，时，分，秒。四位年的前两位代表世纪20，后两位代表当前年12<br>如果不想修改sql语句运行的话，就需要在执行该语句之前，使用alter session 命令将nls_date_language修改为american，如下：<br>alter session set nls_date_language=’american’    –以英语显示日期<br>如果不想修改sql语句运行的话，就需要在执行该语句之前，使用alter session 命令将</p>\n<p>‘01-JAN-08’ 系统做了隐式数据类型转换,调用了to_date函数<br>‘2008-01-01’,用户做显式数据类型转换,自己调用<br>to_date(‘2008-01-01’,’yyyy-mm-dd’),第二个参数是对第一个参数的格式说明.<br>to_char的返回类型是字符类型,把date转换成了字符串类型,所以参数的数据类型是date.to_char函数可以获得日期的任何一部分信息,比如年,月,日等.<br>select c1 from … 系统做了隐式数据类型转换,调用了to_char函数<br>select to_char(c1,.. 用户做显式数据类型转换,自己调用to_char(c1,’yyyy-mm-dd’),第二个参数是对第一个参数的格式说明.<br>日期的运算<br>   日期可以加减一个数值,单位为天.<br>   select sysdate-1,sysdate,sysdate+1 from dual<br>两个日期相减<br>   add_months 按月加 返回类型是date<br>   add_months(sysdate,6)<br>   select add_months(hiredate,6) from emp_hiloo<br>   add_months(sysdate,-6)<br>   months_between()  返回类型是number<br>   months_between(sysdate,hiredate) 两个日期之间相差多少个月<br>select months_between(sysdate,hiredate) from emp_hiloo;<br>   last_day(sysdate) 本月的最后一天</p>\n<h5 id=\"4-转换函数\"><a href=\"#4-转换函数\" class=\"headerlink\" title=\"4) 转换函数\"></a>4) 转换函数</h5><p>两个日期相减转换函数<br>to_date  char–&gt;date<br>to_char  date–&gt;char , number –&gt; char<br>to_number  char–&gt;number</p>\n<h5 id=\"其他函数\"><a href=\"#其他函数\" class=\"headerlink\" title=\"其他函数\"></a>其他函数</h5><p>coalesce 类似nvl(oracle专有)<br>nvl(bonus,salary<em>0.1)<br>coalesce(bonus,salary</em>0.1,100)。输出所有员工的奖金，如果没有奖金就按工资的10%发放，如果奖金和工资都没有的临时工，就给100元。<br>不同的记录处理方式不一样时,用case when.<br>case when 条件表达式 then 返回结果<br>else<br>     返回结果<br>end<br>若没有else,当不匹配条件,表达式的返回值为null.<br>case deptno when 10 then(不建议该语法形式)<br>decode跟case when的功能类似.<br>decode(deptno,10,salary<em>1.1,<br>              20,salary</em>1.2,<br>              salary)<br>若没有最后一个参数,函数的返回值为null.<br>select语句<br>order by子句<br>select   from    where<br>order by<br>order by子句是select语句中的最后一个子句.<br>order by salary 缺省是升序 asc<br>order by salary desc 降序<br>order by子句后面可以跟列名,表达式(函数),列别名,在select子句中的位置.<br>ORDER BY 子句<br>ORDER BY 语句用于对结果集进行排序。<br>ORDER BY 语句<br>ORDER BY 语句用于根据指定的列对结果集进行排序。<br>ORDER BY 语句默认按照升序对记录进行排序。<br>如果您希望按照降序对记录进行排序，可以使用 DESC 关键字。<br>原始的表 (用在例子中的)：<br>Orders 表:<br>Company    OrderNumber<br>IBM    3532<br>W3School    2356<br>Apple    4698<br>W3School    6953<br>实例 1<br>以字母顺序显示公司名称：<br>SELECT Company, OrderNumber FROM Orders ORDER BY Company<br>结果：<br>Company    OrderNumber<br>Apple    4698<br>IBM    3532<br>W3School    6953<br>W3School    2356<br>实例 2<br>以字母顺序显示公司名称（Company），并以数字顺序显示顺序号（OrderNumber）：<br>SELECT Company, OrderNumber FROM Orders ORDER BY Company, OrderNumber<br>结果：<br>Company    OrderNumber<br>Apple    4698<br>IBM    3532<br>W3School    2356<br>W3School    6953<br>实例 3<br>以逆字母顺序显示公司名称：<br>SELECT Company, OrderNumber FROM Orders ORDER BY Company DESC<br>结果：<br>Company    OrderNumber<br>W3School    6953<br>W3School    2356<br>IBM    3532<br>Apple    4698<br>实例 4<br>以逆字母顺序显示公司名称，并以数字顺序显示顺序号：<br>SELECT Company, OrderNumber FROM Orders ORDER BY Company DESC, OrderNumber ASC<br>结果：<br>Company    OrderNumber<br>W3School    2356<br>W3School    6953<br>IBM    3532<br>Apple    4698<br>注意：在以上的结果中有两个相等的公司名称 (W3School)。只有这一次，在第一列中有相同的值时，第二列是以升序排列的。如果第一列中有些值为 nulls 时，情况也是这样的。</p>\n<h4 id=\"2-多行函数-哪两个函数里只能放number\"><a href=\"#2-多行函数-哪两个函数里只能放number\" class=\"headerlink\" title=\"2) 多行函数(哪两个函数里只能放number)\"></a>2) 多行函数(哪两个函数里只能放number)</h4><p>avg()    平均值  函数的参数只能是number<br>sum()    求和    函数的参数只能是number<br>count()    计数 函数的参数可以是number date 字符<br>        count(*)统计记录,count(bonus)<br>max() 最大值 函数的参数可以是number date 字符<br>min() 最小值 函数的参数可以是number date 字符</p>\n<p>组函数的缺省处理方式是处理所有的非空值.<br>avg(bonus) 所有有奖金的员工的平均值<br>count(bonus) 有奖金的员工个数<br>当所有的值都是null,count函数返回0,其他组函数返回null.</p>\n<h4 id=\"3-group-by子句\"><a href=\"#3-group-by子句\" class=\"headerlink\" title=\"3) group by子句\"></a>3) group by子句</h4><p>若有group by子句,select后面跟组标识和组函数<br>组标识指group by后面的内容<br>from–&gt;where–&gt;group by–&gt;select–&gt;order by<br>若没有group by子句,select后面只要有一个是组函数,其余的都得是组函数.</p>\n<h4 id=\"having子句\"><a href=\"#having子句\" class=\"headerlink\" title=\"having子句\"></a>having子句</h4><p>select deptno,round(avg(salary)) davg<br>from emp_hiloo<br>group by deptno<br>having round(avg(salary))&gt; 5000</p>\n<p>from–&gt;where–&gt;group by–&gt;having–&gt;select–&gt;order by </p>\n<h4 id=\"GROUP-BY-语句\"><a href=\"#GROUP-BY-语句\" class=\"headerlink\" title=\"GROUP BY 语句\"></a>GROUP BY 语句</h4><p>GROUP BY 语句用于结合合计函数，根据一个或多个列对结果集进行分组。<br>SQL GROUP BY 语法<br>SELECT column_name, aggregate_function(column_name)<br>FROM table_name<br>WHERE column_name operator value<br>GROUP BY column_name<br>SQL GROUP BY 实例<br>我们拥有下面这个 “Orders” 表：<br>O_Id    OrderDate    OrderPrice    Customer<br>1    2008/12/29    1000    Bush<br>2    2008/11/23    1600    Carter<br>3    2008/10/05    700    Bush<br>4    2008/09/28    300    Bush<br>5    2008/08/06    2000    Adams<br>6    2008/07/21    100    Carter<br>现在，我们希望查找每个客户的总金额（总订单）。我们想要使用 GROUP BY 语句对客户进行组合。<br>我们使用下列 SQL 语句：<br>SELECT Customer,SUM(OrderPrice) FROM Orders<br>GROUP BY Customer<br>结果集类似这样：<br>Customer    SUM(OrderPrice)<br>Bush    2000<br>Carter    1700<br>Adams    2000<br>很棒吧，对不对？<br>让我们看一下如果省略 GROUP BY 会出现什么情况：<br>SELECT Customer,SUM(OrderPrice) FROM Orders<br>结果集类似这样：<br>Customer    SUM(OrderPrice)<br>Bush    5700<br>Carter    5700<br>Bush    5700<br>Bush    5700<br>Adams    5700<br>Carter    5700<br>上面的结果集不是我们需要的。<br>那么为什么不能使用上面这条 SELECT 语句呢？解释如下：上面的 SELECT 语句指定了两列（Customer 和 SUM(OrderPrice)）。”SUM(OrderPrice)” 返回一个单独的值（”OrderPrice” 列的总计），而 “Customer” 返回 6 个值（每个值对应 “Orders” 表中的每一行）。因此，我们得不到正确的结果。不过，您已经看到了，GROUP BY 语句解决了这个问题。<br>GROUP BY 一个以上的列<br>我们也可以对一个以上的列应用 GROUP BY 语句，就像这样：<br>SELECT Customer,OrderDate,SUM(OrderPrice) FROM Orders<br>GROUP BY Customer,OrderDate</p>\n<h4 id=\"4-where和having比较\"><a href=\"#4-where和having比较\" class=\"headerlink\" title=\"4) where和having比较\"></a>4) where和having比较</h4><p>共同点:都执行在select之前,都有过滤功能<br>区别<br>where执行在having之前<br>where过滤的是记录,任意列名都可以出现在where子句,单行函数可以用在where子句,组函数不能出现在where子句<br>having过滤的是组,组标识可以出现在having子句,其他列名不行,组函数用于having子句,单行函数不可以.</p>\n<h5 id=\"HAVING-子句\"><a href=\"#HAVING-子句\" class=\"headerlink\" title=\"HAVING 子句\"></a>HAVING 子句</h5><p>在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与合计函数一起使用。<br>SQL HAVING 语法<br>SELECT column_name, aggregate_function(column_name)<br>FROM table_name<br>WHERE column_name operator value<br>GROUP BY column_name<br>HAVING aggregate_function(column_name) operator value<br>SQL HAVING 实例<br>我们拥有下面这个 “Orders” 表：<br>O_Id    OrderDate    OrderPrice    Customer<br>1    2008/12/29    1000    Bush<br>2    2008/11/23    1600    Carter<br>3    2008/10/05    700    Bush<br>4    2008/09/28    300    Bush<br>5    2008/08/06    2000    Adams<br>6    2008/07/21    100    Carter<br>现在，我们希望查找订单总金额少于 2000 的客户。<br>我们使用如下 SQL 语句：<br>SELECT Customer,SUM(OrderPrice) FROM Orders<br>GROUP BY Customer<br>HAVING SUM(OrderPrice)<2000 1500=\"\" 1700=\"\" 结果集类似：=\"\" customer=\"\" sum(orderprice)=\"\" carter=\"\" 现在我们希望查找客户=\"\" \"bush\"=\"\" 或=\"\" \"adams\"=\"\" 拥有超过=\"\" 的订单总金额。=\"\" 我们在=\"\" sql=\"\" 语句中增加了一个普通的=\"\" where=\"\" 子句：=\"\" select=\"\" customer,sum(orderprice)=\"\" from=\"\" orders=\"\" or=\"\" group=\"\" by=\"\" having=\"\">1500<br>结果集：<br>Customer    SUM(OrderPrice)<br>Bush    2000<br>Adams    2000</2000></p>\n<h4 id=\"5-DCL\"><a href=\"#5-DCL\" class=\"headerlink\" title=\"5) DCL\"></a>5) DCL</h4><p>connect openlab/open123<br>select count(*) from hiloo.emp_hiloo;</p>\n<p>connect hiloo/hiloo123<br>grant select on emp_hiloo to openlab;</p>\n<p>connect openlab/open123<br>select count(*) from hilool.emp_hiloo<br>10rows selected</p>\n<p>connect hiloo/hiloo123<br>revoke select on emp_hiloo from openlab;</p>\n<p>show user<br>select count(*) from hiloo.emp_hiloo</p>\n<p>create synonym emp_hiloo for hiloo.emp_hiloo</p>\n<h4 id=\"6-关于null值的讨论\"><a href=\"#6-关于null值的讨论\" class=\"headerlink\" title=\"6) 关于null值的讨论\"></a>6) 关于null值的讨论</h4><p>1 case when在没有else和decode少一个参数时,返回null.<br>2order by bonus,asc升序时null值在最后,desc降序时null在最前.<br>3 组函数和null值的关系:1组函数的缺省处理方式是处理所有的非空值.2当所有的值都是null,count函数返回0,其他组函数返回null.<br>4若group by的列有null值,所有的null值分在一组.<br>课堂练习<br>1将每个员工的工资涨12.34567%,用round和trunc分别实现<br>select ename,nvl(trunc(round(salary+salary*0.1234567,2),1),0.0) from emp_hiloo;//自己写的。<br>2 将’2008-01-01’插入表中,<br>  再将’2008 08 08 08:08:08’插入表中<br>insert into test values<br>(to_date(‘01-JAN-08’,’DD-MON-RR’));</p>\n<p>3找出3月份入职的员工.<br>select ename,hiredate<br>from emp_hiloo<br>where to_char(hiredate,’mm’) = ‘03’;<br>select ename,hiredate<br>from emp_hiloo<br>where to_char(hiredate,’mm’) = 3;//可以正常输出winXP下<br>‘03’ = 3  —&gt; to_number(‘03’) = 3<br>字符   数值  缺省系统将字符转成数值<br>select ename,hiredate<br>from emp_hiloo<br>where to_char(hiredate,’fmmm’) = ‘03’;(错，未选定行，无输出)</p>\n<p>select ename,hiredate<br>from emp_hiloo<br>where to_char(hiredate,’fmmm’) = ‘3’;(对)<br>‘03’ = ‘3’ (错)<br>fm表示去掉前导0或去掉两边的空格.<br>4 zhangsanfeng的mgr上显示boss,其他人不变.<br>select ename,empno,<br>       nvl(to_char(mgr),’boss’) mgr<br>from emp_hiloo<br>函数nvl（“1”，“2”）:如果字符串1是空，就返回字符串”2”</p>\n<h4 id=\"5十分钟之后\"><a href=\"#5十分钟之后\" class=\"headerlink\" title=\"5十分钟之后\"></a>5十分钟之后</h4><p> select sysdate,sysdate+1/144 from dual;<br>解释：Oracle 里面,</p>\n<p>sysdate + 1 意思是 当前时间 + 1天</p>\n<p>sysdate + 1/24  意思是 当前时间 + 1/24天  也就是1小时后</p>\n<p>sysdate+1/144  意思是 当前时间 + 1/144天 （1/24<em>6）  也就是10分钟后<br> 6 若员工是10部门的,工资涨10%,20部门工资涨20%,其他员工工资不变.<br>select ename,salary,<br>       case when deptno = 10 then salary</em>1.1<br>            when deptno = 20 then salary*1.2<br>       else<br>            salary<br>       end new_sal<br>from emp_hiloo;</p>\n<p>select ename,salary,<br>       decode(deptno,10,salary<em>1.1,<br>                     20,salary</em>1.2,<br>                     salary) new_sal<br>from emp_hiloo;<br>7 列出每个员工的年薪,按年薪降序排列.<br>select ename,salary<em>12<br>from emp_hiloo<br>order by salary desc (好)<br>select ename,salary</em>12<br>from emp_hiloo<br>order by salary<em>12 desc<br>select ename,salary</em>12 n_sal<br>from emp_hiloo<br>order by n_sal desc</p>\n<p>select ename,salary<em>12 n_sal from emp_hiloo order by 2 desc;<br>select salary</em>12,ename n_sal from emp_hiloo order by 2 asc;<br>8 列出员工的名字,部门号以及工资,按部门号从小到大的顺序,同一部门的工资按降序排列.<br>select ename,deptno,salary<br>from emp_hiloo<br>order by deptno,salary desc<br>9 列出奖金的平均值,和,个数,最大值,最小值.<br>AVG 函数返回数值列的平均值。NULL 值不包括在计算中<br>select avg(bonus),avg(nvl(bonus,0)),<br>       sum(bonus), sum(nvl(bonus,0)),<br>       count(bonus),count(nvl(bonus,0)),<br>       max(bonus),max(nvl(bonus,0)),<br>       min(bonus),min(nvl(bonus,0))<br>from emp_hiloo<br>10 各个部门的平均工资<br>ROUND 函数用于把数值字段舍入为指定的小数位数。<br>select deptno,round(avg(salary))<br>from emp_hiloo<br>group by deptno<br>11 求10部门的平均工资,只显示平均工资<br>   求10部门的平均工资,显示部门号,平均工资<br>   select round(avg(salary))<br>   from emp_hiloo<br>   where deptno = 10<br>   group by deptno</p>\n<p>   select max(deptno),round(avg(salary))<br>   from emp_hiloo<br>   where deptno = 10<br>12各个部门不同职位的平均工资<br>   select deptno,job,round(avg(salary))<br>   from emp_hiloo<br>   group by deptno,job<br>13 每种奖金有多少人?<br>   select bonus,count(empno)<br>   from emp_hiloo<br>   group by bonus<br>14 列出平均工资大于5000的部门的平均工资<br>   select deptno,round(avg(salary))<br>   from emp_hiloo<br>   group by deptno<br>   having round(avg(salary)) &gt; 5000<br>15哪些员工的工资是最低的.<br>  select ename from emp_hiloo<br>  where salary = ( select min(salary)<br>                   from emp_hiloo)<br>报错信息<br>ORA-01861: literal does not match format string<br>文字值不匹配格式串<br>ORA-01722: invalid number 无效的数值 to_number<br>ORA-00937: not a single-group group function 不是一个组函数<br>ORA-00979: not a GROUP BY expression 不是一个group by表达式 GROUP BY expression指跟在group by后面的东西(列名),称之为组标识<br>detail 细节 summary 聚合</p>\n<h3 id=\"查询\"><a href=\"#查询\" class=\"headerlink\" title=\"查询\"></a>查询</h3><p>子查询定义<br>在SQL语句中嵌入select语句<br>create table new_tabname<br>as<br>select ename,salary*12 ann_sal from emp_hiloo;<br>新表的结构由select后面的项来决定,new_table包含两列ename,ann_sal.</p>\n<h4 id=\"子查询\"><a href=\"#子查询\" class=\"headerlink\" title=\"子查询\"></a>子查询</h4><p>  非关联子查询<br>    单列子查询<br>    多列子查询<br>  关联子查询</p>\n<h5 id=\"子查询执行\"><a href=\"#子查询执行\" class=\"headerlink\" title=\"子查询执行\"></a>子查询执行</h5><p>非关联子查询<br>子查询的表和主查询的表没有建关联<br>先执行子查询(只执行一遍),当返回多条记录,系统会将自动去重的结果返回给主查询,再执行主查询.</p>\n<p>关联子查询<br>子查询的表和主查询的表建关联.所谓建关联指主查询表里的列和子查询表里的列写成一个条件表达式.</p>\n<p>先执行主查询,判断表里的记录是否应该放入结果集.过程如下:拿到第一条记录,获得了各个列的值,将需要的列值带入子查询,执行后返回的结果再和主查询表里的列做比较,符合条件,该记录放入结果集,否则过滤掉.依次执行主查询表里的每条记录.子查询执行的次数由主查询表里的记录数决定.</p>\n<p>1) exists和not exists<br>exists的执行过程<br>从主查询表里拿到第一条记录,按子查询里的关联条件在子查询的表里看是否能找到匹配的记录,当找到第一条匹配的记录后,立即返回(即不需要找出所有匹配的记录),exists条件满足,主查询表里的该记录放入结果集.若按子查询里的关联条件将子查询<br>表里的记录全部检查一遍后没有一条符合条件的记录,此时也返回, exists 条件不满足,主查询表里的该记录不能放入结果集,被过滤掉.</p>\n<p>select ename from emp_afei o<br>where exists<br>             (select 1 from emp_afei i<br>              where o.empno = i.mgr)</p>\n<h5 id=\"非关联子查询的分类\"><a href=\"#非关联子查询的分类\" class=\"headerlink\" title=\"非关联子查询的分类\"></a>非关联子查询的分类</h5><p>单列子查询<br>select ename,salary<br>from emp_hiloo<br>where salary = (select min(salary)<br>                from emp_hiloo<br>                )<br>多列子查询:按键值对比较<br>select ename,salary,deptno<br>from emp_afei<br>where (deptno,salary) in<br>             (select deptno,round(avg(salary))<br>              from emp_afei<br>              group by deptno)</p>\n<p>2) 课堂练习<br>1哪些人是领导?(非关联子查询)<br>如果一个员工的empno能出现在mgr里就说明他是领导.<br>select ename<br>from emp_hiloo<br>where empno in (select mgr from emp_hiloo)<br>select ename<br>fro emp_afei<br>where empno in (1001,1005,1006,1008,null)<br>2 哪些人是员工?<br>他的empno绝对不能出现在mgr中,他的empno跟mgr的出现的所有的值不能相等. &lt;&gt;all<br>select ename<br>from emp_hiloo<br>where empno not in (select mgr from emp_hiloo)<br>select ename<br>fro emp_afei<br>where empno not in (1001,1005,1006,1008,null)<br>select ename<br>from emp_hiloo<br>where empno not in (select mgr from emp_hiloo<br>                    where mgr is not null)</p>\n<p>3哪些部门的平均工资比30部门的平均工资高?<br>select deptno,round(avg(salary))<br>from emp_hiloo<br>group by deptno<br>having round(avg(salary)) &gt;<br>                    (select round(avg(salary))<br>                     from emp_hiloo<br>                     where deptno = 30)<br>4哪些员工的工资比zhangwuji的工资高?<br>select ename,salary<br>from emp_afei<br>where salary &gt; (select salary from emp_afei<br>                where ename = ‘zhangwuji’)<br>ERROR at line 3:<br>ORA-01427: single-row subquery returns more than one row<br>单行子查询返回多条记录</p>\n<p>比所有人高 &gt; (select max(salary))<br>           &gt;all<br>比任意人高 &gt; (select min(salary)<br>           &gt;any<br>5哪些员工的工资等于本部门的平均工资?<br>select ename,salary,deptno<br>from emp_afei<br>where (deptno,salary) in<br>             (select deptno,round(avg(salary))<br>              from emp_afei<br>              group by deptno)<br>5哪些员工的工资比本部门的平均工资高?<br>select ename,salary,deptno<br>from emp_afei o<br>where salary &gt; (select round(avg(salary))<br>                from emp_afei i<br>                where i.deptno = o.deptno)<br>6哪些人是领导?(关联子查询)<br>select ename from emp_afei o<br>where exists<br>             (select 1 from emp_afei i<br>              where o.empno = i.mgr)<br>7哪些部门有员工?<br>select deptno,dname<br>from dept_afei o<br>where exists (select 1 from emp_afei i<br>              where o.deptno = i.deptno)</p>\n<p>3) 课外练习day03am<br>1 zhangwuji的领导是谁,显示名称?<br>2 zangwuji领导谁,显示名称?<br>3 列出devoleper部门有哪些职位?<br>1) 课外练习day04am答案<br>1 zhangwuji的领导是谁,显示名称?<br>  select ename from emp_afei<br>  where empno in<br>        (select mgr from emp_afei<br>                 where ename = ‘zhangwuji’)</p>\n<p>zangwuji领导谁,显示名称?</p>\n<p> select ename from emp_afei<br> where mgr in (select empno from emp_afei<br>               where ename = ‘zhangwuji’)</p>\n<p>3 列出developer部门有哪些职位?<br>  select distinct job from emp_afei<br>  where deptno in<br>           (select deptno from dept_afei<br>            where dname = ‘developer’)</p>\n<p>2) 非关联子查询<br>exists和not exists<br>not exists的执行过程<br>从主查询表里拿到第一条记录,按子查询里的关联条件在子查询的表里看是否能找到匹配的记录,当找到第一条匹配的记录后,立即返回(即不需要找出所有匹配的记录),not exists条件不满足,主查询表里的该记录不能放入结果集,被过滤掉.若按子查询里的关联条件将子查询表里的记录全部检查一遍后没有一条符合条件的记录,返回, not exists 条件满足,主查询表里的该记录放入结果集.</p>\n<p>对于exists和not exists,在子查询中找到第一条匹配的记录都会立即返回,exists将主查询表里的记录放入结果集,not exsits将主查询表里的记录过滤掉.<br>对于exists和not exists,如果子查询没有返回任何记录,即扫描全部记录后没有一条符合条件的记录,都返回,exists将主查询表里的记录过滤掉,not exists将主查询表里的记录放入结果集.<br>not in ,&lt;&gt; all逻辑上跟not exists等价<br>in ,=any逻辑上跟exists等价</p>\n<p>查询形式:集合操作<br>把结果集作为一个集合,结果集必须是同构的,列的个数及数据类型一致</p>\n<p>3) 并集  union(去重)/union all(不去重)<br>select ename,deptno,salary,salary<em>1.1 new_sal<br>from emp_afei<br>where deptno = 10<br>union all<br>select ename,deptno,salary,salary</em>1.2 new_sal<br>from emp_afei<br>where deptno = 20<br>union all<br>select ename,deptno,salary,salary new_sal<br>from emp_afei<br>where deptno not in (10,20)</p>\n<p>case when和decode可以实现类似功能.</p>\n<p>4) 交集  intersect(去重)<br>select job from emp_afei<br>where deptno = 10<br>intersect<br>select job from emp_afei<br>where deptno = 20<br>10部门和20部门都有的职位是哪些?</p>\n<p>5) 差  minus(去重)<br>select deptno from dept_afei<br>minus<br>select deptno from emp_afei<br>那些部门没有员工.</p>\n<p>6) 多表查询<br>1) 交叉连接 cross join<br>select e.ename,d.dname<br>from emp_afei e cross join dept_afei d<br>结果集产生<br>10*4=40,组合操作,笛卡尔积</p>\n<p>2) 内连接 inner join(匹配一个条件)<br>select e.ename,e.deptno,d.deptno,d.dname<br>from emp_afei e join dept_afei d<br>ORA-00905: missing keyword(丢失关键字)</p>\n<p>如果把结果集的产生看成双层循环,驱动表是外层循环,匹配表是内层循环.<br>对于内连接哪张表做驱动表,哪张表做匹配表产生出的结果集是一样的,不同的是性能.<br>驱动表在匹配表的匹配情况如下:<br>一条记录找到一条匹配<br>一条记录找到多条匹配<br>一条记录找不到任何匹配.<br>内连接的核心是驱动表的记录要出现在结果集中必须在匹配表中能找到匹配的记录,否则该记录被过滤掉.</p>\n<p>3) 内连接查询形式<br>等值连接 on e.deptno = d.deptno<br>两张表有表述同一属性的列,两张表都有deptno列.<br>自连接 on e.mgr = m.empno<br>同一张表的不同列能写成一个表达式,即同一张表的两条记录之间有关系.通过给表起别名的方式,将同一张表的两条记录之间的关系转化成不同表的两条记录之间的关系.<br>4) 外连接<br>外连接 outer join(驱动表的记录一个都不能少的出现在结果集里)<br>from t1 left join t2<br>on t1.c1 = t2.c2(t1驱动表,t2匹配表)<br>外连接结果集=内连接的结果集+t1表中匹配不上的记录和t2表中的null记录的组合<br>from t1 right join t2<br>on t1.c1 = t2.c2(t2驱动表,t1匹配表)<br>外连接结果集=内连接的结果集+t2表中匹配不上的记录和t1表中的null记录的组合<br>from t1 full join t2<br>on t1.c1 = t2.c2<br>外连接结果集=内连接的结果集+t1表中匹配不上的记录和t2表中的null记录的组合+t2表中匹配不上的记录和t1表中的null记录的组合</p>\n<p>5) 外连接的应用场景<br>1 某张表的记录全部出现在结果集中,包括匹配不上的.<br>select e.ename,nvl(m.ename,’Boss’)<br>from emp_afei e left join emp_afei m<br>on e.mgr = m.empno<br>2解决否定问题,匹配不上的记录找出来(跟所有的记录都不匹配.)(not in/not exists)<br>外连接 + where 匹配表.主键列 is null<br>select e.ename,d.dname<br>from emp_afei e right join dept_afei d<br>on e.deptno = d.deptno<br>where e.empno is null<br>(解决结果集只包含匹配不上的记录.where子句执行在外连接之后)哪些部门没有员工</p>\n<p>select d.dname<br>from emp_afei e right join  dept_afei d<br>on e.deptno = d.deptno<br>and e.ename = ‘zhangwuji’<br>where e.empno is null<br>如果希望在外连接之前过滤匹配表用and子句,如果想在外连接之后通过匹配表里的列过滤外连接的结果集时候用where.<br>过滤驱动表统计用where子句过滤.</p>\n<p>6) 课内练习<br>1 哪些部门没有员工(not exists)<br>  select dname from dept_afei o<br>  where not exists<br>        (select 1 from emp_afei i<br>         where o.deptno = i.deptno)<br>2 哪些人是员工?(not exists)<br>  select ename from emp_afei o<br>  where not exists<br>            (select 1 from emp_afei i<br>             where o.empno = i.mgr)<br>他的empno和其他人的mgr相等是不可能存在的.即和所有人的mgr都不相等.<br>not in ,&lt;&gt; all逻辑上跟not exists等价<br>3 列出哪些员工在北京地区上班?<br>思路:确定表,两张表,匹配问题用inner join–&gt;on(匹配条件)–&gt;(对表是否过滤)<br>select e.ename,e.deptno,d.deptno,d.dname<br>from emp_afei e join dept_afei d<br>on e.deptno = d.deptno<br>and d.location = ‘beijing’<br>4zhangwuji在哪个地区上班?<br>select e.ename,d.dname,d.location<br>from emp_afei e join dept_afei d<br>on e.deptno = d.deptno<br>and e.ename = ‘zhangwuji’<br>5列出每个部门有哪些职位?部门名称,职位<br> select distinct d.dname,e.job<br> from emp_afei e join dept_afei d<br> on e.deptno = d.deptno<br> order by d.dname<br>6各个部门的平均工资,列出部门名称,平均工资.<br>select d.dname,round(avg(e.salary)) savg<br>from emp_afei e join dept_afei d<br>on e.deptno = d.deptno<br>group by d.dname<br>select max(d.dname),round(avg(e.salary)) savg<br>from emp_afei e join dept_afei d<br>on e.deptno = d.deptno<br>group by d.deptno<br>select min(deptno),round(avg(salary))<br>from emp_hiloo<br>where deptno = 10<br>7 列出每个员工的名字和他的领导的名字<br>select e.ename employee,<br>       m.ename manager<br>from emp_afei e join emp_afei m<br>on e.mgr = m.empno<br>结果集是9条.<br>e表中有10条记录,其中9条记录找到匹配,zhangsanfeng没匹配<br>m表中有10条记录,其中4条记录找到匹配,4条记录是领导,6条记录找不到匹配,他们是员工.<br>select e.ename employee,<br>       m.ename manager<br>from emp_afei e join emp_afei m<br>on e.mgr = m.empno<br>union all<br>select ename,’Boss’<br>from emp_afei<br>where mgr is null</p>\n<p>select e.ename employee,<br>       decode(m.ename,e.ename,’Boss’,<br>                  m.ename)   manager<br>from emp_afei e join emp_afei m<br>on nvl(e.mgr,e.empno) = m.empno</p>\n<p>select e.ename,nvl(m.ename,’Boss’)<br>from emp_afei e left join emp_afei m<br>on e.mgr = m.empno<br>10=9+1</p>\n<p>8哪些人是领导?<br>select distinct m.ename<br>from emp_afei e join emp_afei m<br>on e.mgr = m.empno<br>9哪些部门没有员工?<br>select e.ename,d.dname<br>from emp_afei e right join dept_afei d<br>on e.deptno = d.deptno<br>where e.empno is null<br>(解决结果集只包含匹配不上的记录.where子句执行在外连接之后)<br>11=10+1<br>如果部门表里的某条记录的deptno在emp表找不到匹配,在内连接中,它被过滤,<br>e表的empno的特性是唯一且非空的(主键约束),居然e.empno is null,说明null是外连接时为了驱动表中那条匹配不上的记录出现在结果集中,在匹配表中模拟的null记录.<br>10哪些人是员工,哪些人不是领导?<br>select e.empno,m.ename<br>from emp_afei e right join emp_afei m<br>on e.mgr = m.empno<br>where e.empno is null</p>\n<p>from emp_afei e right join emp_afei m<br>15=9+(10(m表中有10条记录)-4(m表中有4条匹配记录 ))<br>from emp_afei e left join emp_afei m<br>10(结果集)=9+(10(e表中有10条记录)-9(e表中有9条匹配记录))<br>11 哪些部门没有叫zhangwuji的?<br>select d.dname<br>from emp_afei e right join  dept_afei d<br>on e.deptno = d.deptno<br>and e.ename = ‘zhangwuji’<br>where e.empno is null</p>\n<p>7) 课外练习(day04)(答案在Day05)<br>1zhangwuji的领导是谁?(表连接)<br>2zhangwuji领导谁?(表连接)<br>3哪些人是领导?(in exists join)<br>4哪些部门没有员工?(not in/not exists/outer join)<br>5哪些人是员工,哪些人不是领导?(not in/not exists/outer join)<br>Day05.txt<br>Grade级别<br>Lowsal最低工资<br>Hisal最高工资<br>Create table salgrade_hiloo(<br>Grade<br>)<br>cross join  inner join   outer join<br>inner join(匹配)<br>  等值连接<br>  自连接<br>  非等值连接<br>outer join(匹配+不匹配)<br>  等值连接</p>\n<p>  自连接<br>  非等值连接</p>\n<p>所谓非等值连接表示两张表里的列不能写成等值表达式,而是写成between and之类.所以两个表之间有关系是指表里的列可以写成表达式,而不是等值表达式.<br>salgrade<br>grade  级别<br>lowsal 最低工资<br>hisal  最高工资</p>\n<p>from后面跟子查询<br>emp,各个部门的平均工资dept_avgsal(depnto,avgsal)<br>select e.ename,e.salary,e.deptno<br>from emp_afei e join<br>      (select deptno,round(avg(salary)) avgsal<br>       from emp_afei<br>       group by deptno) a<br>on e.deptno = a.deptno<br>and e.salary &gt; a.avgsal</p>\n<p>各个部门的平均工资,列出部门名称,平均工资<br>select max(d.dname),round(avg(salary))<br>from emp_afei e join dept_afei d<br>on e.deptno = d.deptno<br>group by d.deptno</p>\n<p>select d.dname,a.avgsal<br>from dept_afei d join<br>      (select deptno,round(avg(salary)) avgsal<br>       from emp_afei<br>       group by deptno) a<br>on d.deptno = a.depto</p>\n<p>DML<br>insert一条记录时,若某些列为null值,有哪些语法实现?<br>insert into tabname values (1,’a’,null,sysdate)<br>insert into tabname(c1,c2,c4)<br>values (1,’a’,sysdate)<br>insert语句的两种语法形式?<br>insert into tabname values () insert一条记录<br>insert into tabname<br>select * from tabname1  insert多条记录<br>连接图解：</p>\n<h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><p>1) 课外练习答案day04<br>1zhangwuji的领导是谁?(表连接)<br> select m.ename<br> from emp_afei e join emp_afei m<br> on e.mgr = m.empno<br> and m.ename = ‘zhangwuji’<br>2 zhanghangwuji领导谁?(表连接)<br> select e.ename<br> from emp_afei e join emp_afei m<br> on e.mgr = m.empno<br> and m.ename = ‘zhangwuji’<br>3哪些人是领导?(in exists join)<br> select ename from emp_afei<br> where empno in (select mgr from emp_afei)<br> select ename from emp_afei o<br> where exists<br>            (select 1 from emp_afei i<br>             where o.empno = i.mgr)<br> select distinct m.ename<br> from emp_afei e join emp_afei m<br> on e.mgr = m.empno<br>4哪些部门没有员工?(not in/not exists/outer join)<br> select dname from dept_afei<br> where deptno not in<br>               (select deptno from emp_afei)<br> select dname from dept_afei o<br> where not exists<br>             (select 1 from emp_afei i<br>              where o.deptno = i.deptno)<br> select d.dname<br> from emp_afei e right join dept_afei d<br> on e.deptno = d.deptno<br> where e.empno is null<br>5哪些人是员工,哪些人不是领导?(not in/not exists/outer join)<br> select ename from emp_afei<br> where empno not in (<br>               select mgr from emp_afei<br>               where mgr is not null)<br> select ename from emp_afei o<br> where not exists<br>             (select 1 from emp_afei i<br>              where o.empno = i.mgr)<br> select m.ename<br> from emp_afei e right join emp_afei m<br> on e.mgr = m.empno<br> where e.empno is null<br>cross join (笛卡尔积)</p>\n<p>rownum 伪列,记录号<br>若用rownum选择出记录,编号必须从1开始.<br>分页问题<br>第一页<br>select rownum,ename<br>from emp_afei<br>where rownum &lt;= 3;<br>第二页<br>select rn,ename<br>from (<br>      select rownum rn,ename<br>      from emp_afei<br>      where rownum &lt;= 6)<br>where rn between 4 and 6<br>排名问题<br>按工资排名的前三条记录<br>select rownum,ename,salary<br>from emp_hiloo<br>where rownum &lt;=3<br>order by salary desc;(错)</p>\n<p>select rownum,ename,salary<br>from ( select ename,salary<br>       from emp_afei<br>       order by salary desc)<br>where rownum &lt;= 3</p>\n<p>update语句的中set后面的=是什么含义?where后面的=是什么含义?<br>set c1 = null (= 赋值)<br>where c1 = null (= 等号)</p>\n<p>update和delete语句中的where子句是什么含义?<br>用来确定对表里的哪些记录要进行update或delete操作,没有where子句多表里的所有记录update或delete<br>update<br>set<br>where c1 = (select …)<br>rename 关键字 17<br>commit</p>\n<p>1011 abc 1000 10 ‘clerk’<br>update 1001 1000–&gt;2000<br>delete 1011<br>commit<br>如何编写和运行一个sql脚本(文本文件)<br>1 编辑文件<br>在linux环境下已经编写好了test.sql,做一个鼠标右键的copy</p>\n<p>在20,23,26机器上,<br>vi test.sql<br>按a i o进入编辑模式,paste,按esc键,再按:wq!回车</p>\n<p>2 运行文件<br>sun-server% sqlplus openlab/open123 @test.sql<br>@表示运行<br>SP2-0310: unable to open file “test.sql”在当前目录下没有test.sql文件<br>sqlplus openlab/open123 ../test.sql</p>\n<p>cd ..<br>sun-server% sqlplus openlab/open123 @test.sql</p>\n<p>SQL&gt;@test.sql</p>\n<p>数据库对象 PL/SQL<br>create or replace function test<br>insert into test values (1,1)<br>            *<br>ERROR at line 1:<br>ORA-04044: procedure(存储过程), function(函数), package(包), or type is not allowed here</p>\n<p>事务(transaction 交易)<br>事务里包含的DML语句<br>事务的结束<br>commit 提交,(dml操作的数据入库了)<br>rollback 回滚 撤销(DML操作被取消)<br>sqlplus正常退出=commit<br>DDL语句自动提交<br>开始<br>上一个事务的结束是下一个事务的开始.<br>一致状态<br>数据库的数据被事务改变.<br>oltp online transaction processing联机事务处理系统 高并发系统</p>\n<p>事务的隔离级别 read committed(读已经提交了的数据)</p>\n<p>如果不commit—–&gt;commit rollback<br>1如果不commit,其他session是看不见你的操作<br>2如果不commit,会阻塞操作同一条记录的事务(session),commit才能释放所有DML加的锁.<br>3如果不commit,系统做DML操作,会将old data放入rollback segment(回滚段) ,所占用的回滚段资源不释放.</p>\n<p>DML系统会自动给表及表里的记录加锁<br>表级共享锁<br>行级排他锁<br>    表级共享锁     行级排他锁<br>s1    ok        ok<br>s2    ok        enqueue wait<br>s3    ok        ok</p>\n<p>执行DDL语句,系统自动加DDL排他锁<br>SQL&gt; drop table test purge;<br>drop table test purge<br>           *<br>ERROR at line 1:<br>ORA-00054: resource busy(资源忙 test表) and acquire with NOWAIT specified (dml wait,ddl nowait 如果加不上锁,报错退出)</p>\n<p>DDL语句<br>字符类型<br>varchar2,必须带宽度, 按字符串的实际长度存,本身的数据是变化,对空格敏感<br>char,可以不带宽度,缺省宽度是1,按字符串的定义长度存,本身的数据是固定长度的.对空格不敏感<br>数值类型</p>\n<p>number类型<br>create table test90<br>(c1 number,<br> c2 number(6),<br> c3 number(4,2),<br> c4 number(2,4),<br> c5 number(3,-3))</p>\n<p>四舍五入<br>number(6) 表示6为整数 999999<br>number(4,2) 表示小数点后2位,整数位2位 99.99<br>number(2,4) 表示小数点后4位,能填数字的位数是2位 0.0099<br>number(3,-3) 999000 999123–&gt;999000<br>                    999511–&gt;报错</p>\n<p>user_tables 是一张系统表,里面记录当前用户所有的表的信息,里面没有记录表的创建日期.<br>user_objects 是一张系统表,里面记录当前用户所有的数据库对象的信息.created的列记录数据库对象(如表)的创建日期.<br>user_tables和user_objects这两张表的关系体现在table_name和object_name都记录的是表名.</p>\n<p>data block 数据块,操作数据的最小逻辑(物理)单元,最少读一个block的数据</p>\n<p>HWM high water mark 高水位线,表示曾经插入数据的最高位置<br>FTS full table scan 全表扫描,把表里的所有记录读一遍,把HWM之下的所有data block读一遍</p>\n<p>truncate table 释放空间,HWM下移<br>delete 不释放空间,HWM不动<br>不适合用delete命令删大表.</p>\n<p>课内练习<br>1 列出工资级别为3级,5级的员工<br>  select e.ename,e.salary,s.grade<br>  from emp_afei e join salgrade_afei s<br>  on e.salary between s.lowsal and s.hisal<br>  and s.grade in (3,5)<br>2 列出各个工资级别有多少人?<br>  select s.grade,count(e.empno)<br>  from emp_afei e join salgrade_afei s<br>  on e.salary between s.lowsal and s.hisal<br>  group by s.grade<br>  order by s.grade<br>3 列出各个工资级别有多少人?(包含0级)<br>  select s.grade,count(e.empno)<br>  from emp_afei e right join salgrade_afei s<br>  on e.salary between s.lowsal and s.hisal<br>  group by s.grade<br>  order by s.grade<br>特别注意count不要写*或者s.grade</p>\n<p>课外练习day05<br>1按工资排名的第4到第6名员工.</p>\n<p>###关键点###<br>课外练习day05答案</p>\n<p>按工资排名的第4到第6名员工.<br>select rn,ename,salary<br>from<br>    (select rownum rn,ename,salary<br>     from (select ename,salary<br>           from emp_afei<br>           order by salary desc)<br>     where rownum &lt;= 6<br>    )<br>where rn &gt;= 4 </p>\n<p>####1）事务####</p>\n<p>####约束 constraint (安检)####<br>primary key(主键)<br>foreign key(外键)<br>unique key (唯一键)<br>not null(非空)<br>check (检查)</p>\n<p>主键 (表中不会出现重复记录)<br>列级约束<br>create table test<br>(c1 number(2)<br>    constraint test_c1_pk primary key,<br> c2 number(3))</p>\n<pre><code>constraint test_c1_pk primary key,\n           *\n</code></pre><p>ERROR at line 3:<br>ORA-02264: name already used by an existing constraint (名字被存在的约束使用了)</p>\n<p>SQL&gt; select table_name from user_constraints<br>  2  where constraint_name = ‘TEST_C1_PK’;<br>哪张表里有叫TEST_C1_PK这个约束名.</p>\n<p>ORA-00001: unique constraint (HILOO(用户名) .TEST_C1_PK) violated(冲突)</p>\n<p>PK=UK + NN</p>\n<p>表级约束<br>create table test(<br>c1 number(2),<br>c2 number,<br>constraint test_c1_pk primary key(c1)<br>)<br>表中有三列c1,c2,c3,c1和c2做成联合主键<br>create table test(<br>c1 number,<br>c2 number,<br>constraint test_c1_c2_pk primary key(c1,c2),<br>c3 number<br>)<br>没有constraint关键字,系统用自动起名字sys_c数字.</p>\n<p>not null<br>create table test<br>(c1 number constraint test_c1_pk primary key,<br> c2 number not null);<br>not null约束没有表级形式</p>\n<p>unique (pk)<br>相同点:都要保证唯一性<br>区别:uk允许为null,而且可以多个null值,一个表中只能有一个pk约束,可以有多个uk约束.<br>create table test<br>(c1 number constraint test_c1_pk primary key,<br> c2 number constraint test_c2_uk unique)</p>\n<p>create table test(<br>c1 number primary key,<br>c2 number primary key,<br>c3 number unique,<br>c4 number unique)  (报错,一张表只能有一个primary key)</p>\n<p>create table test(<br>c1 number constraint test_c1_pk primary key,<br>c2 number constraint test_c2_uk unique,<br>c3 number constraint test_c3_uk unique,<br>c4 number )<br>c2上定义了一个唯一键 c3上定义了一个唯一键</p>\n<p>create table test(<br>c1 number constraint test_c1_pk primary key,<br>c2 number,<br>c3 number,<br>constraint test_c2_c3_uk unique (c2,c3),<br>c4 number)<br>c2,c3联合唯一键</p>\n<p>check<br>create table test(<br>c1 number(3) constraint test_c1_ck<br>             check (c1 &gt; 100))</p>\n<p>create table test(<br>c1 number(3),<br>constraint test_c1_ck check (c1 &gt; 100))</p>\n<p>外键<br>parent table(父表)上定义唯一列(pk/uk)<br>child table(子表)上定义外键列(fk)</p>\n<p>1 先create parent table(pk/uk),再create child table(fk)<br>2 先insert into parent table,再insert into child table<br>3 先delete from child table,再delete from parent table<br>4 先drop child table,再drop parent table</p>\n<p>reference 引用<br>create table parent<br>(c1 number(3))</p>\n<p>create table child<br>(c1 number(2) constraint child_c1_pk<br>              primary key,<br> c2 number(3) constraint child_c2_fk<br>              references parent(c1))</p>\n<pre><code>references parent(c1))\n                  *\n</code></pre><p>ERROR at line 5:<br>ORA-02270: no matching unique or primary key for this column-list<br>在c1上没有定义uk或pk</p>\n<p>alter table parent<br>add constraint parent_c1_pk primary key(c1);<br>给c1列增加主键约束</p>\n<p>insert into child values (1,1)<br>ORA-02291: integrity constraint(完整性约束) (HILOO.CHILD_C2_FK) violated - parent key not found (父键值没发现)<br>违反fk约束</p>\n<p>insert into parent values (1);<br>insert into child values (1,1)</p>\n<p>delete from parent where c1 = 1;<br>ORA-02292: integrity constraint (HILOO.CHILD_C2_FK) violated - child record<br>found(子记录被发现)</p>\n<p>delete from child where c2 = 1;<br>delete from parent where c1 = 1;</p>\n<p>drop table parent purge;<br>ORA-02449: unique/primary keys in table referenced by foreign keys<br>在parent table上的pk/uk正在fk所引用</p>\n<p>drop table child purge;<br>drop table parent purge;</p>\n<p>drop table parent cascade constraints purge;<br>cascade constraints 级联约束,child table本身没被删除,只是先把子表上的fk约束删除,再删parent table.</p>\n<p>表级约束<br>create table child<br>(c1 number(2) constraint child_c1_pk<br>              primary key,<br> c2 number(3),<br> constraint child_c2_fk foreign key(c2)<br>            references parent(c1)<br>)</p>\n<p>外键约束另外两种定义方法<br>create table child1<br>(c1 number(2) constraint child1_c1_pk<br>              primary key,<br> c2 number(3) constraint child1_c2_fk<br>              references parent(c1)<br>              on delete cascade)<br>on delete cascade :级联删除会影响到对parent table的删除,先delete from child1,再delete from<br>parent</p>\n<p>delete from parent where c1 = 1;<br>create table child2<br>(c1 number(2) constraint child2_c1_pk<br>              primary key,<br> c2 number(3) constraint child2_c2_fk<br>              references parent(c1)<br>              on delete set null)</p>\n<p>delete from parent where c1 = 1<br>等价于以下操作<br>SQL&gt; update child2 set c2 = null<br>  2  where c2 = 1;<br>SQL&gt; delete from parent where c1 = 1;</p>\n<p>table<br>DDL(数据类型 约束)<br>transaction (包含一堆DML)</p>\n<p>4000<br>100<br>1000<br>3100</p>\n<p>视图(view)<br>create table test_t1<br>as<br>select <em> from test<br>where c1 = 1;<br>create or replace view test_v1<br>as<br>select </em> from test<br>where c1 = 1;<br>desc test_v1<br>selelct * from test_v1</p>\n<p>insert into test values (1,3);<br>select <em> from test_v1 (1,3)<br>insert into test_v1 values (1,4)<br>select </em> from test_v1;<br>select <em> from test;<br>insert into test_v1 values (2,3);<br>select </em> from test_v1;(没有)<br>select * from test;(2,3)</p>\n<p>drop table test purge;<br>select * from test_v1;<br>SQL&gt; desc test_v1<br>ERROR:<br>ORA-24372: invalid object for describe<br>无法描述无效对象的结构</p>\n<p>SQL&gt; select text from user_views<br>  2  where view_name = ‘TEST_V1’;</p>\n<h2 id=\"TEXT\"><a href=\"#TEXT\" class=\"headerlink\" title=\"TEXT\"></a>TEXT</h2><p>select “C1”,”C2” from test<br>where c1 = 1</p>\n<p>view是一条select语句. select语句中包含的表为源表.通过view对源表做DML操作.</p>\n<p>view作用<br>1 create view (deptno = 30)<br>  grant view to user<br>  限定用户查询的数据 子集<br>2 简化查询语句<br>3 create view beijing<br>  as<br>  select <em> from haidian<br>  union all<br>  select </em> from xicheng<br>…<br>  超集<br>view的类型<br>1 简单view (DML)<br>2 复杂view  (不能DML)</p>\n<p>create or replace view avgscore_v<br>select s.name,a.avgscore<br>from student s,<br>     (select sid,round(avg(score)) avgscore<br>      from stu_cour<br>      group by sid) a<br>on s.id = a.sid</p>\n<p>view的约束<br>create or replace view test_ck<br>as<br>select * from test<br>where c1 = 1<br>with check option;<br>c1=2,违反where条件,2,3记录insert时报错</p>\n<p>create or replace view test_ro<br>as<br>select * from test<br>where c1 = 1<br>with read only;<br>只读视图</p>\n<h4 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h4><p>create index test_c1_idx<br>on test(c1);<br>对索引不能做desc,select,DML操作<br>rowid 代表一条记录的物理位置<br>属于哪个数据对象(table)<br>属于哪个数据文件的<br>属于数据文件的第几个数据块<br>属于数据块里的第几条记录</p>\n<h4 id=\"index的结构\"><a href=\"#index的结构\" class=\"headerlink\" title=\"index的结构\"></a>index的结构</h4><p>index记录rowid<br>index的结构是一棵平衡树,有三类数据块组成,根节点,分支节点,叶子节点,数据块的数据是排序的.根节点和分支节点用于导航,里面记录下一级节点的物理位置以及该节点包含的数据范围.叶子节点里记录的是index entry(索引项),由key值和rowid组成,key值是建索引的列在每条记录上的取值,rowid是记录的物理位置,所有的叶子节点做成双向链表(升序/降序),适用于范围查询.<br>用索引查询的路线图,从根节点出发,找相应的分支节点,叶子节点,最后要找到index entry,通过rowid定位<br>表里所需要的数据块,避免了全表扫描.</p>\n<p>索引为什么提高查询效率,为select语句<br>有效地降低了读取数据块的数量.读取数据块,一种从文件里读,物理读 physical read,一种从内存读,逻辑读 logical read /buffer gets</p>\n<p>建索引代价<br>空间,DML变慢</p>\n<h4 id=\"哪些列适合建索引\"><a href=\"#哪些列适合建索引\" class=\"headerlink\" title=\"哪些列适合建索引\"></a>哪些列适合建索引</h4><p>1 经常出现在where子句的列<br>2 pk/uk列<br>3 经常出现在表连接的列<br>4 fk列 parent.pk列 = child.fk列<br>5 经常用于group by,order by的列<br>7 where c1 is null(全表扫描),索引里不记null值,<br> 该列有大量null值,找not null值用索引会快</p>\n<h4 id=\"索引类型\"><a href=\"#索引类型\" class=\"headerlink\" title=\"索引类型\"></a>索引类型</h4><p>非唯一性索引,提高查询效率<br>唯一性索引,解决唯一性.等价建唯一性约束<br>create unique index test_c2_idx<br>on test(c2);</p>\n<p>insert into test (c2) values (1)<br>*<br>ERROR at line 1:<br>ORA-00001: unique constraint(HILOO.TEST_C2_IDX ) violated</p>\n<p>联合索引<br>create index test_c1_c2_idx<br>on test(c1,c2)<br>where c1 = 1 and c2 = 1</p>\n<p>select ename from emp_hiloo<br>where salary<em>12 &gt; 60000<br>where salary &gt; 5000<br>如果salary建索引,where salary &gt; 5000(用),where salary</em>12 &gt; 60000(不能用)</p>\n<p>where upper(ename) = ‘ZHANGWUJI’</p>\n<p>where c1 = 100 c1是varchar2类型<br>where to_number(c1) = 100</p>\n<p>where ename like ‘a%’<br>where substr(ename,1,1) = ‘a’</p>\n<p>deptno not in (20,30)<br>depotno in (10)</p>\n<h4 id=\"函数索引\"><a href=\"#函数索引\" class=\"headerlink\" title=\"函数索引\"></a>函数索引</h4><p>create index test_c1_funidx<br>on test(round(c1));<br>where round(c1) = 10</p>\n<p>create index student_name_idx<br>on student(name);</p>\n<h4 id=\"序列号\"><a href=\"#序列号\" class=\"headerlink\" title=\"序列号\"></a>序列号</h4><p>sequence<br>为table里的主键服务,产生主键值<br>唯一值产生器<br>sequence_name.nextval</p>\n<p>为student表的id建sequence<br>insert into student(student_id.nextval…<br>为course表的id建sequence<br>insert into course (course_id.nextval…</p>\n<p>创建序列如下：<br>create sequence SEQ_TEST100<br>minvalue 1<br>maxvalue 999999999999999999999999999<br>start with 11<br>increment by 1<br>cache 10;</p>\n<p>函数<br>create or replace function dept_avgsal<br>(p_deptno number) –定义参数,数据类型不能有宽度<br>return number    –定义函数的返回类型<br>is<br>  v_salary emp_hiloo.salary%type;     –变量v_salary 的类型跟表emp_hiloo里的salary的类型定义一致<br>begin<br>  select round(avg(salary)) into v_salary<br>  from emp_hiloo<br>  where deptno = p_deptno;    –select当且仅当返回一条记录用select into语法,表示把select语句的执行结果赋值给v_salary<br>  return v_salary;       –返回函数值<br>end;<br>.不运行,回到SQL&gt;下<br>/表示运行<br>show error<br>SQL&gt; select dept_avgsal(10) from dual;</p>\n<p>练习<br>用语法实现多对多关系<br>student<br>id pk<br>name not null</p>\n<p>course<br>id pk<br>name not null</p>\n<p>stu_cour<br>sid fk –&gt;student(id)<br>cid fk –&gt;course(id)<br>pk(sid,cid)<br>score check <a href=\"between and\">0,100</a> </p>\n<h4 id=\"数据库日期比较\"><a href=\"#数据库日期比较\" class=\"headerlink\" title=\"数据库日期比较\"></a>数据库日期比较</h4><p>Sql代码：<br>1    timesten内存数据库比较日期是不是同一天,低效的方法<br>2    to_char(create_date,’yyyymmdd’)=to_char(sysdate NUMTODSINTERVAL(60<em>60</em>24,’SECOND’),’yyyymmdd’)<br>3    oracle 数据库低效的方法<br>4    to_char(create_date,’yyyymmdd’)=to_char(sysdate-1,’yyyymmdd’)<br>5    2个数据库通用高效的方法<br>6    trunc(create_date)=trunc(sysdate)-NUMTODSINTERVAL(1,’DAY’)<br>查找数据库里的表，索引等<br>支持oracle的模糊查询如select * from user_tables where table_name like ‘%_PROJECT’;查表名以PROJECT结尾的表（注：区别大小写）<br>查所有用户的表在all_tables<br>主键名称、外键在all_constraints<br>索引在all_indexes<br>但主键也会成为索引，所以主键也会在all_indexes里面。<br>具体需要的字段可以DESC下这几个view，dba登陆的话可以把all换成dba。</p>\n<p>查询用户表的索引(非聚集索引):<br>select * from user_indexes<br>where uniqueness = ‘NONUNIQUE’</p>\n<p>查询用户表的主键(聚集索引):<br>select * from user_indexes<br>where uniqueness = ‘UNIQUE’</p>\n<p>1、    查找表的所有索引（包括索引名，类型，构成列）：<br>select t.<em>,i.index_type from user_ind_columns t,user_indexes i where t.index_name = i.index_name and t.table_name = i.table_name and t.table_name = 要查询的表<br>2、查找表的主键（包括名称，构成列）：<br>select cu.</em> from user_cons_columns cu, user_constraints au where cu.constraint_name = au.constraint_name and au.constraint_type = ‘P’ and au.table_name = 要查询的表<br>3、查找表的唯一性约束（包括名称，构成列）：<br>select column_name from user_cons_columns cu, user_constraints au where cu.constraint_name = au.constraint_name and au.constraint_type = ‘U’ and au.table_name = 要查询的表<br>4、查找表的外键（包括名称，引用表的表名和对应的键名，下面是分成多步查询）：<br>select <em> from user_constraints c where c.constraint_type = ‘R’ and c.table_name = 要查询的表<br>查询外键约束的列名：<br>select </em> from user_cons_columns cl where cl.constraint_name = 外键名称<br>查询引用表的键的列名：<br>select <em> from user_cons_columns cl where cl.constraint_name = 外键引用表的键名<br>5、查询表的所有列及其属性<br>select t.</em>,c.COMMENTS from user_tab_columns t,user_col_comments c where t.table_name = c.table_name and t.column_name = c.column_name and t.table_name = 要查询的表</p>\n<p>####数据唯一Id：####</p>\n<ol>\n<li>用Oracle来生成UUID，做法很简单，如下：select sys_guid() from dual;数据类型是 raw(16) 有32个字符。<br>create table test_guid3(<br>id varchar(50)<br>)<br>select * from test_guid3;<br>insert into test_guid3(id) values(sys_guid())</li>\n</ol>\n<hr>\n<pre><code>1000 7CD5B7769DF75CEFE034080020825436\n1100 7CD5B7769DF85CEFE034080020825436\n1200 7CD5B7769DF95CEFE034080020825436\n1300 7CD5B7769DFA5CEFE034080020825436\n</code></pre><h3 id=\"名词\"><a href=\"#名词\" class=\"headerlink\" title=\"名词\"></a>名词</h3><h4 id=\"Oracle的方案（Schema）和用户（User）的区别\"><a href=\"#Oracle的方案（Schema）和用户（User）的区别\" class=\"headerlink\" title=\"Oracle的方案（Schema）和用户（User）的区别\"></a>Oracle的方案（Schema）和用户（User）的区别</h4><p>从定义中我们可以看出方案（Schema）为数据库对象的集合，为了区分各个集合，我们需要给这个集合起个名字，这些名字就是我们在企业管理器的方案下看到的许多类似用户名的节点，这些类似用户名的节点其实就是一个schema，schema里面包含了各种对象如tables, views, sequences, stored procedures, synonyms, indexes, clusters, and database links。</p>\n<p>   一个用户一般对应一个schema,该用户的schema名等于用户名，并作为该用户缺省schema。这也就是我们在企业管理器的方案下看到schema名都为数据库用户名的原因。Oracle数据库中不能新创建一个schema，要想创建一个schema，只能通过创建一个用户的方法解决(Oracle中虽然有create schema语句，但是它并不是用来创建一个schema的)，在创建一个用户的同时为这个用户创建一个与用户名同名的schem并作为该用户的缺省shcema。即schema的个数同user的个数相同，而且schema名字同user名字一一对应并且相同，所有我们可以称schema为user的别名，虽然这样说并不准确，但是更容易理解一些。</p>\n<p>   一个用户有一个缺省的schema，其schema名就等于用户名，当然一个用户还可以使用其他的schema。如果我们访问一个表时，没有指明该表属于哪一个schema中的，系统就会自动给我们在表上加上缺省的sheman名。比如我们在访问数据库时，访问scott用户下的emp表，通过select <em> from emp; 其实，这sql语句的完整写法为select </em> from scott.emp。在数据库中一个对象的完整名称为schema.object，而不属user.object。类似如果我们在创建对象时不指定该对象的schema，在该对象的schema为用户的缺省schema。这就像一个用户有一个缺省的表空间，但是该用户还可以使用其他的表空间，如果我们在创建对象时不指定表空间，则对象存储在缺省表空间中，要想让对象存储在其他表空间中，我们需要在创建对象时指定该对象的表空间。</p>\n<p>   oracle中的schema就是指一个用户下所有对象的集合，schema本身不能理解成一个对象，oracle并没有提供创建schema的语法，schema也并不是在创建user时就创建，而是在该用户下创建第一个对象之后schema也随之产生，只要user下存在对象，schema就一定存在，user下如果不存在对象，schema也不存在；这一点类似于temp tablespace group，另外也可以通过oem来观察，如果创建一个新用户，该用户下如果没有对象则schema不存在，如果创建一个对象则和用户同名的schema也随之产生。</p>\n<p>####Oracle中User与Schema的简单理解####<br>技术积累（126）<br>版权声明：本文为博主原创文章，未经博主允许不得转载。<br>方案（Schema）为数据库对象的集合，为了区分各个集合，我们需要给这个集合起个名字，这些名字就是我们在企业管理器的方案下看到的许多类似用户名的节点，这些类似用户名的节点其实就是一个schema，schema里面包含了各种对象如tables, views, sequences, stored procedures, synonyms, indexes, clusters, and database links。  一个用户一般对应一个schema,该用户的schema名等于用户名，并作为该用户缺省schema。<br>SQL Server中的Schema<br>SQL Server中一个用户有一个缺省的schema，其schema名就等于用户名，这也就是我们在企业管理器的方案下看到schema名都为数据库用户名的原因。当然一个用户还可以使用其他的schema。如果我们访问一个表时，没有指明该表属于哪一个schema中的，系统就会自动给我们在表上加上缺省的sheman名。比如我们在访问数据库时，访问scott用户下的emp表，通过select <em> from emp; 其实，这sql语句的完整写法为select </em> from scott.emp。在数据库中一个对象的完整名称为schema.object，而不属user.object。类似如果我们在创建对象时不指定该对象的schema，在该对象的schema为用户的缺省schema。这就像一个用户有一个缺省的表空间，但是该用户还可以使用其他的表空间，如果我们在创建对象时不指定表空间，则对象存储在缺省表空间中，要想让对象存储在其他表空间中，我们需要在创建对象时指定该对象的表空间。</p>\n<p>Oracle中的Schema<br>Oracle中的schema就是指一个用户下所有对象的集合，schema本身不能理解成一个对象，oracle并没有提供创建schema的语法，schema也并不是在创建user时就创建，而是在该用户下创建第一个对象之后schema也随之产生，只要user下存在对象，schema就一定存在，user下如果不存在对象，schema也不存在；如果创建一个新用户，该用户下如果没有对象则schema不存在，如果创建一个对象则和用户同名的schema也随之产生。实际上在使用上，shcema与user完全一样，没有什么区别，在出现schema名的地方也可以出现user名。</p>\n<p>Tablspace<br>逻辑上用来放objects,，这是个逻辑概念，本质上是一个或者多个数据文件的集合，物理上对应磁盘上的数据文件或者裸设备。</p>\n<p>数据文件<br>具体存储数据的物理文件，是一个物理概念。一个数据文件只能属于一个表空间，一个表空间可以包含一个或多个数据文件。一个数据库由多个表空间组成，一个表空间只能属于一个数据库。</p>\n<p>下边是源自网络的一个形象的比喻<br>我们可以把Database看作是一个大仓库，仓库分了很多很多的房间，Schema就是其中的房间，一个Schema代表一个房间，Table可以看作是每个Schema中的床，Table（床）被放入每个房间中，不能放置在房间之外，那岂不是晚上睡觉无家可归了，然后床上可以放置很多物品，就好比 Table上可以放置很多列和行一样，数据库中存储数据的基本单元是Table，现实中每个仓库放置物品的基本单位就是床， User就是每个Schema的主人，（所以Schema包含的是Object，而不是User），user和schema是一一对应的，每个user在没有特别指定下只能使用自己schema（房间）的东西，如果一个user想使用其他schema（房间）的东西，那就要看那个schema（房间）的user（主人）有没有给你这个权限了，或者看这个仓库的老大（DBA）有没有给你这个权限了。换句话说，如果你是某个仓库的主人，那么这个仓库的使用权和仓库中的所有东西都是你的（包括房间），你有完全的操作权，可以扔掉不用的东西从每个房间，也可以放置一些有用的东西到某一个房间，你还可以给每个User分配具体的权限，也就是他到某一个房间能做些什么，是只能看（Read-Only），还是可以像主人一样有所有的控制权（R/W），这个就要看这个User所对应的角色Role了。</p>\n<h4 id=\"oracle的schema的含义\"><a href=\"#oracle的schema的含义\" class=\"headerlink\" title=\"oracle的schema的含义\"></a>oracle的schema的含义</h4><p>在现在做的Kraft Catalyst 项目中，Cransoft其中有一个功能就是schema refresh. 一直不理解schema什么意思，也曾经和同事讨论过，当时同事就给我举过一个例子，下面会详细说的。其实schema是Oracle中的，其他数据库中不知道有没有这个概念。<br>首先,可以先看一下schema和user的定义：<br>A schema is a collection of database objects (used by a user).<br>Schema objects are the logical structures that directly refer to the database’s data.<br>A user is a name defined in the database that can connect to and access objects.<br>Schemas and users help database administrators manage database security.<br>从中我们可以看出,schema为数据库对象的集合，为了区分各个集合，需要给这个集合起个名字，这些名字就是在企业管理器的方案下看到的许多类似用户名的节点，这些类似用户名的节点其实就是一个schema。<br>schema里面包含了各种对象如tables, views, sequences, stored procedures, synonyms, indexes, clusters, and database links。<br>一个用户一般对应一个schema，该用户的schema名等于用户名，并作为该用户缺省schema。这也就是在企业管理器的方案下看到schema名都为数据库用户名的原因。<br>Oracle数据库中不能新创建一个schema，要想创建一个schema，只能通过创建一个用户的方法解决(Oracle中虽然有create schema语句，但是它并不是用来创建一个schema的)。在创建一个用户的同时，为这个用户创建一个与用户名同名的schem并作为该用户的缺省 shcema。即schema的个数同user的个数相同，而且schema名字同user名字一一 对应并且相同，所有我们可以称schema为user的别名，虽然这样说并不准确，但是更容易理解一些。<br>一个用户有一个缺省的schema，其schema名就等于用户名，当然一个用户还可以使用其他的schema。如果我们访问一个表时，没有指明该表属于 哪一个schema中的，系统就会自动给我们在表上加上缺省的sheman名。比如我们在访问数据库时，访问scott用户下的emp表，通过 select <em> from emp; 其实，这sql语句的完整写法为select </em> from scott.emp。在数据库中一个对象的完整名称为schema.object，而不属user.object。类似如果我们在创建对象时不指定该对象 的schema，在该对象的schema为用户的缺省schema。这就像一个用户有一个缺省的表空间，但是该用户还可以使用其他的表空间，如果我们在创 建对象时不指定表空间，则对象存储在缺省表空间中，要想让对象存储在其他表空间中，需要在创建对象时指定该对象的表空间。<br>有人举了个很生动的例子，来说明Database、User、Schema、Tables、Col、Row等之间的关系<br>“可以把Database看作是一个大仓库，仓库分了很多很多的房间，Schema就是其中的房间，一个Schema代表一个房间，Table可以看作是每个Schema中的床，Table（床）就被放入每个房间中，不能放置在房间之外，那岂不是晚上睡觉无家可归了。<br>然后床上可以放置很多物品，就好比Table上可以放置很多列和行一样，数据库中存储数据的基本单元是Table，现实中每个仓库放置物品的基本单位就是床， User就是每个Schema的主人（所以Schema包含的是Object，而不是User）。<br>其实User是对应与数据库的（即User是每个对应数据库的主人），既然有操作数据库（仓库）的权利，就肯定有操作数据库中每个Schema（房间）的 权利，就是说每个数据库映射的User有每个Schema（房间）的钥匙，换句话说，如果他是某个仓库的主人，那么这个仓库的使用权和仓库中的所有东西都 是他的（包括房间），他有完全的操作权，可以扔掉不用的东西从每个房间，也可以放置一些有用的东西到某一个房间。还可以给User分配具体的权限，也就是 他到某一个房间能做些什么，是只能看（Read-Only），还是可以像主人一样有所有的控制权（R/W），这个就要看这个User所对应的角色Role 了”<br>从定义中我们可以看出schema为数据库对象的集合，为了区分各个集合，我们需要给这个集合起个名字，这些名字就是我们在企业管理器的方案下看到的许多类似用户名的节点，这些类似用户名的节点其实就是一个schema，schema里面包含了各种对象如tables, views, sequences, stored procedures, synonyms, indexes, clusters, and database links。<br>一个用户一般对应一个schema,该用户的schema名等于用户名，并作为该用户缺省schema。这也就是我们在企业管理器的方案下看到schema名都为数据库用户名的原因。Oracle数据库中不能新创建一个schema，要想创建一个schema，只能通过创建一个用户的方法解决(Oracle中虽然有create schema语句，但是它并不是用来创建一个schema的)，在创建一个用户的同时为这个用户创建一个与用户名同名的schem并作为该用户的缺省shcema。即schema的个数同user的个数相同，而且schema名字同user名字一一 对应并且相同，所有我们可以称schema为user的别名，虽然这样说并不准确，但是更容易理解一些。<br>一个用户有一个缺省的schema，其schema名就等于用户名，当然一个用户还可以使用其他的schema。如果我们访问一个表时，没有指明该表属于哪一个schema中的，系统就会自动给我们在表上加上缺省的sheman名。比如我们在访问数据库时，访问scott用户下的emp表，通过select <em> from emp; 其实，这sql语句的完整写法为select </em> from scott.emp。在数据库中一个对象的完整名称为schema.object，而不属user.object。类似如果我们在创建对象时不指定该对象的schema，在该对象的schema为用户的缺省schema。这就像一个用户有一个缺省的表空间，但是该用户还可以使用其他的表空间，如果我们在创建对象时不指定表空间，则对象存储在缺省表空间中，要想让对象存储在其他表空间中，我们需要在创建对象时指定该对象的表空间。<br>咳，说了这么多，给大家举个例子，否则，一切枯燥无味！<br>SQL&gt; Gruant dba to scott<br>SQL&gt; create table test(name char(10));<br>Table created.<br>SQL&gt; create table system.test(name char(10));<br>Table created.<br>SQL&gt; insert into test values(‘scott’);<br>1 row created.<br>SQL&gt; insert into system.test values(‘system’);<br>1 row created.<br>SQL&gt; commit;<br>Commit complete.<br>SQL&gt; conn system/manager<br>Connected.<br>SQL&gt; select * from test;</p>\n<h2 id=\"NAME\"><a href=\"#NAME\" class=\"headerlink\" title=\"NAME\"></a>NAME</h2><p>system<br>SQL&gt; ALTER SESSION SET CURRENT_SCHEMA = scott; –改变用户缺省schema名<br>Session altered.<br>SQL&gt; select * from test;</p>\n<h2 id=\"NAME-1\"><a href=\"#NAME-1\" class=\"headerlink\" title=\"NAME\"></a>NAME</h2><p>scott<br>SQL&gt; select owner ,table_name from dba_tables where table_name=upper(‘test’);<br>OWNER TABLE_NAME</p>\n<hr>\n<p>SCOTT TEST<br>SYSTEM TEST<br>–上面这个查询就是我说将schema作为user的别名的依据。实际上在使用上，shcema与user完全一样，没有什么区别，在出现schema名的地方也可以出现user名。<br>表空间：<br>一个表空间就是一片磁盘区域,他又一个或者多个磁盘文件组成,一个表空间可以容纳许多表、索引或者簇等<br>  每个表空间又一个预制的打一磁盘区域称为初始区间（initial   extent）用完这个区间厚在用下一个，知道用完表空间，这时候需要对表空间进行扩展，增加数据文件或者扩大已经存在的数据文件</p>\n<p>instance是一大坨内存sga,pga….和后台的进程smon pmon…..组成的一个大的应用。<br>schema就是一个用户和他下面的所有对象。。<br>tablspace 逻辑上用来放objects.物理上对应磁盘上的数据文件或者裸设备。<br> 在Oracle中，结合逻辑存储与物理存储的概念，我们可以这样来理解数据库、表空间、SCHEMA、数据文件这些概念：<br>      数据库是一个大圈，里面圈着的是表空间，表空间里面是数据文件，那么schema是什么呢？schema是一个逻辑概念，是一个集合，但schema并不是一个对象，oracle也并没有提供创建schema的语法。<br>schema：<br>      一般而言，一个用户就对应一个schema,该用户的schema名等于用户名，并作为该用户缺省schema，用户是不能创建schema的，schema在创建用户的时候创建，并可以指定用户的各种表空间（这点与PostgreSQL是不同，PostgreSQL是可以创建schema并指派给某个用户）。当前连接到数据库上的用户创建的所有数据库对象默认都属于这个schema（即在不指明schema的情况下），比如若用户scott连接到数据库，然后create table test(id int not null)创建表，那么这个表被创建在了scott这个schema中；但若这样create kanon.table test(id int not null)的话，这个表被创建在了kanon这个schema中，当然前提是权限允许。<br>      创建用户的方法是这样的：<br>      create user 用户名 identified by 密码<br>      default tablespace 表空间名<br>      temporary tablespace 表空间名<br>      quota 限额  （建议创建的时候指明表空间名）<br>由此来看，schema是一个逻辑概念。<br>      但一定要注意一点：schema好像并不是在创建user时就创建的，而是在该用户创建了第一个对象之后才将schema真正创建的，只有user下存在对象，他对应的schema才会存在，如果user下不存在任何对象了，schema也就不存在了；</p>\n<p>数据库：<br>     在oracle中，数据库是由表空间来组成的，而表空间里面是具体的物理文件—数据文件。我们可以创建数据库并为其指定各种表空间。</p>\n<p>表空间：<br>     这是个逻辑概念，本质上是一个或者多个数据文件的集合。</p>\n<p>数据文件：<br>     具体存储数据的物理文件，是一个物理概念。<br>     一个数据文件只能属于一个表空间，一个表空间可以包含一个或多个数据文件。一个数据库由多个表空间组成，一个表空间只能属于一个数据库。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Oracle-SQL基本知识\"><a href=\"#Oracle-SQL基本知识\" class=\"headerlink\" title=\"Oracle SQL基本知识\"></a>Oracle SQL基本知识</h2><h3 id=\"安装数据库\"><a href=\"#安装数据库\" class=\"headerlink\" title=\"安装数据库\"></a>安装数据库</h3><h4 id=\"1）安装Oracle常用问题-常用”用户名-密码“规则-：\"><a href=\"#1）安装Oracle常用问题-常用”用户名-密码“规则-：\" class=\"headerlink\" title=\"1）安装Oracle常用问题(常用”用户名/密码“规则)：\"></a>1）安装Oracle常用问题(常用”用户名/密码“规则)：</h4><p>超级管理员：sys /change_on_install<br>普通管理员：system/manager<br>普通用户：scott/tiger—–&gt;默认是被锁定的<br>大数据用户：sh/sh</p>\n<h4 id=\"2）SQL-DDL…\"><a href=\"#2）SQL-DDL…\" class=\"headerlink\" title=\"2）SQL,DDL…\"></a>2）SQL,DDL…</h4><p>SQL：structured query language 结构化查询语言<br>1.file(文件)</p>\n<p>SQL:DDL DML TCL DQL DCL<br>DDL(data definition language 数据定义语言): column(列)–structure<br>create table (创建表):<br>列名 data type(数据类型) width(宽度)<br>constraint (约束)      alter table(修改表结构)           drop table(删除表)</p>\n<p>DML(data manipulation language 数据操作语言)<br>:row(行)–data<br>insert 增       update 改            delete 删数据,删表里的记录</p>\n<p>TCL(transaction control language 事务控制语言)<br>commit(提交)         rollback(回滚)               savepoint(保留点)</p>\n<p>DQL(data query language 数据查询语言)<br>select<br>DCL(data control language 数据控制语言)<br>grant(授权)  grant to       revoke(回收权限) revoke from </p>\n<h4 id=\"3）RDBMS关系型数据库管理系统\"><a href=\"#3）RDBMS关系型数据库管理系统\" class=\"headerlink\" title=\"3）RDBMS关系型数据库管理系统\"></a>3）RDBMS关系型数据库管理系统</h4><p>RDBMS(relationship database management system 关系型数据库管理系统) software(软件) —&gt;(create database)database—&gt;login in database (登录数据库系统 )—&gt;用SQL操作table</p>\n<p>create database 创建空间存储表 (datafile 数据文件)<br>login in database<br>1 远程登录到数据库所在的机器上<br>  192.168.0.20 192.168.0.23 192.168.0.26<br>shell(终端) telnet 192.168.0.20  (跟操作系统建连接)<br>login:openlab<br>password:open123<br>sunv210% shell提示符,执行操作系统命令</p>\n<h4 id=\"4）-登录该机器上的数据库系统\"><a href=\"#4）-登录该机器上的数据库系统\" class=\"headerlink\" title=\"4） 登录该机器上的数据库系统\"></a>4） 登录该机器上的数据库系统</h4><p>sunv210% sqlplus (跟数据库建连接)<br>Enter user-name: openlab<br>Enter password:open123<br>SQL&gt;sqlplus openlab/open123<br>SQL&gt; 数据库提示符,执行SQL命令</p>\n<h4 id=\"5）登录的是哪个数据库\"><a href=\"#5）登录的是哪个数据库\" class=\"headerlink\" title=\"5）登录的是哪个数据库\"></a>5）登录的是哪个数据库</h4><p>echo $ORACLE_SID(环境变量)&lt;—DBA(database administrator 数据库管理员)<br>查看ORACLE_SID变量的取值,oracle提供<br>通过设置ORACLE_SID变量,sqlplus就知道跟哪个数据库建连接.<br>unix平台<br>%c shell<br>%echo $ORACLE_SID  (tarena)<br>%setenv ORACLE_SID hiloo<br>%setenv ORACLE_SID tarena</p>\n<p>$ b shell<br>$ echo $ORACLE_SID  (tarena)<br>$ ORACLE_SID=hiloo<br>$ export ORACLE_SID</p>\n<p>windows平台<br>D:>set ORACLE_SID=hiloo (设置环境变量)<br>D:>set ORACLE_SID (查看环境变量)<br>ORACLE_SID=hiloo</p>\n<h5 id=\"数据表信息：\"><a href=\"#数据表信息：\" class=\"headerlink\" title=\"数据表信息：\"></a>数据表信息：</h5><p>dept(表名) department 部门信息   列名<br>deptno 部门号  dname  部门名称      location 位置(地区)<br>create table dept_hiloo<br>(deptno  number(2), dname char(20),  location char(20));<br>insert into dept_hiloo values (10,’developer’,’beijing’);<br>insert into dept_hiloo values (20,’account’,’shanghai’);<br>insert into dept_hiloo values (30,’sales’,’guangzhou’);<br>insert into dept_hiloo values  ( 40,’operations’,’tianjin’);<br>commit;<br>insert成功后的提示:1 rows inserted<br>emp(表名) employee 员工信息    列名<br>empno 员工 ename 员工名字  job   职位   salary  月薪   bonus   奖金<br>hiredate  入职日期  mgr   manager 管理者    deptno  部门号<br>create table emp_hiloo(<br>empno number(4),    ename varchar2(20),  job  varchar2(15),<br>salary number(7,2), bonus number(7,2),  hiredate date,<br> mgr number(4),  deptno number(10));<br>alter session set nls_date_language=’american’;<br>insert into emp_hiloo values (1001,’zhangwuji’,’Manager’,10000,2000,’12-MAR-10’,1005,10);<br>insert into emp_hiloo values (1001,’zhangwuji’,’Manager’,10000,2000,’12-MAR-10’,1005,10);<br>insert into emp_hiloo values (1002,’liucangsong’,’Analyst’,8000,1000, ‘01-APR-11’,1001,10);<br>insert into emp_hiloo values (1003,’liyi’,’Analyst’,9000,1000,’11-APR-10’,1001,10);<br>insertinto emp_hiloo values (1004,’guofurong’,’Programmer’,5000,null,’01-JAN-11’,1001,10);<br>insertintoemp_hiloo values (1005,’zhangsanfeng’,’President’,15000,null,’15-MAY-08’,null,20);<br>insert into emp_hiloo values (1006,’yanxiaoliu’,’Manager’,5000,400,’01-FEB-09’,1005,20);<br>insert into emp_hiloo values (1007,’luwushuang’,’clerk’,3000,500,’01-FEB-06’,1006,20);<br>insert into emp_hiloo values (1008,’huangrong’,’Manager’,5000,500,’1-MAY-09’,1005,30);<br>insert into emp_hiloo values (1009,’weixiaobao’,’salesman’,4000,null,’20-FEB-09’,1008,30);<br>insert into emp_hiloo values (1010,’guojing’,’salesman’,4500,500,’10-MAY-09’,1008,30);<br>报错信息<br>ORA-00955: name is already used by an existing object(名字已经被一个存在的对象使用)<br>错误：ORA-01843:无效的月份（在中文的plsql控制台上月份要写成’10-3月-02’这种形式，必须是一个数字和一个汉语月。也可以把日期改成英文环境，在执行插入前执行alter session set nls_date_language=’american’;就可以 了。</p>\n<p>DQL<br>select(选择)<br>源表  结果集<br>1 投影操作 select子句实现<br>2 选择操作 where子句实现<br>3 连接操作<br> 1  select ename,salary<em>12 ann_sal(列别名)<br> 2</em> from emp_hiloo</p>\n<p>单引号 表达字符串 ‘’<br>双引号 表达列别名 “”,别名中包含空格,大小写敏感</p>\n<h5 id=\"1）null值的理解\"><a href=\"#1）null值的理解\" class=\"headerlink\" title=\"1）null值的理解\"></a>1）null值的理解</h5><p>1 null值出现在算术表达式中,结果必为null,null可以看作无穷大.<br>2 函数(function) nvl功能空值转换函数<br>nvl是函数名,p1,p2是参数,数据类型必须一致,函数本身有返回值<br>nvl(p1,p2)<br>nvl函数实现:<br>if p1 is null then<br>   return p2;<br>else<br>   return p1;<br>end if;</p>\n<p>3 若有多个null值,distinct去重时,结果集保留一个null值.<br>4 null = null 不成立 null &lt;&gt; null 不成立<br>5 若用in运算符,集合中有null值跟没有null值结果一致的,结果集中不会出现跟null值有关的记录<br>  若用not in运算符,集合中有null值,这个结果集不包含记录.no rows selected.</p>\n<h5 id=\"2）各个子句的功能\"><a href=\"#2）各个子句的功能\" class=\"headerlink\" title=\"2）各个子句的功能\"></a>2）各个子句的功能</h5><p>1 select后面跟列名,列别名,函数,表达式<br>2 select后面的distinct:去重<br>3 where子句<br>  where 条件表达式 (列名 比较运算符 值)<br>表达式 比较运算符 值(尽量不用,为了性能)<br>  where子句中的列为字符类型,放值的位置上不加单引号或加双引号当列名解释,加单引号当字符串解释.<br>  where子句中的列为字符类型,表达具体值时注意字符是大小写敏感的.<br>SQL提供的四个比较运算符<br>肯定形式<br>   between and 区间,范围<br>   in &lt;=&gt; =any  (= or = )(跟集合里的任意一个值相等就满足条件) 集合 离散值<br>   = 单值运算符<br>   in =any 多值运算符<br>   like 像…一样<br>   通配符: %表示0或任意多个字符 <em>任意一个字符<br>   ‘S’ ‘S%’ ‘S</em>‘<br>   is null  如何判断一个列的取值是否为空<br>否定形式<br>= &lt;&gt; != ^=<br>between and   not between and<br>in    not in (&lt;&gt; and &lt;&gt;) &lt;=&gt; &lt;&gt;all(跟集合里的所有值都不能相等)<br>like     not like<br>is null   is not null<br>各个子句的执行顺序<br>from–&gt;where–&gt;select</p>\n<h5 id=\"3）课堂练习\"><a href=\"#3）课堂练习\" class=\"headerlink\" title=\"3）课堂练习\"></a>3）课堂练习</h5><p>1 列出每个员工的名字和他的工资<br>  select ename,salary from emp_hiloo;<br>2 列出每个员工的名字和他的职位<br>  select ename,job from emp_hiloo;<br>3 列出每个员工的名字和他的年薪<br> select ename,salary<em>12 ann_sal from emp_hiloo;<br>4 列出每个员工的名字和他一年的总收入<br>  (salary+bonus)</em>12 (15000+null)<em>12=null<br>  select ename,(salary+nvl(bonus,0))</em>12 tol_sal<br>  from emp_hiloo;<br>5 输出结果如下:<br>  zhangwuji is in department 10.<br>  liucangsong is in department 10.<br>  …..<br>  guojing is in department 30.<br>select ename||’is in department’||deptno||’.’employee from emp_hiloo;<br>什么要加employee呢？Employee是列别名为了显示用的。<br>6 列出该公司有哪些职位<br>  select distinct(job) from emp_hiloo;<br>  select distinct job from emp_hiloo;<br>7 列出该公司不同的奖金<br>  select distinct bonus from emp_hiloo;<br>8 各个部门有哪些不同的职位?<br>  select distinct deptno,job from emp_hiloo;<br>  去重方式:deptno和job联合唯一.<br>  distinct之后和from之前的所有列联合唯一.<br>distinct是保证每一行的唯一性而非某一列的唯一性，所以必须紧跟在select后面。<br>所以distinct只能放在select后面，紧跟select不然会报缺失表达式错误。<br>9 哪些员工的工资高于5000?<br>  select ename,salary from emp_hiloo<br>  where salary &gt; 5000;<br>10 列出员工工资高于5000的员工的年薪?<br>  select ename,salary<em>12 from emp_hiloo<br>  where salary &gt; 5000;<br>11 列出员工年薪高于60000的员工的年薪?<br>  select ename,salary</em>12 from emp_hiloo<br>  where salary<em>12&gt; 60000;<br>  select ename,salary</em>12 ann_sal from emp_hiloo<br>  where ann_sal &gt; 60000(错误的写法)<br>  select ename,salary<em>12 from emp_hiloo<br>  where salary &gt; 5000;<br>12 zhangwuji的年薪是多少?<br>select ename,salary</em>12 from emp_hiloo<br>where ename=’zhangwuji’;<br>  哪些员工的职位是Manager?<br>select ename,job from emp_hiloo<br>where job=’Manager’;<br>  哪些员工的职位是clerk?<br>  select ename,job from emp_hiloo<br>  where job = ‘Manager’<br>   select ename,job from emp_hiloo<br>  where job = ‘clerk’(效率高)<br>  clerk的大小写不清楚<br>  函数:upper(),lower()<br>  select ename,job from emp_hiloo<br>  where upper(job) = ‘CLERK’ (通用性好)<br>13 员工工资在5000到10000之间的员工的年薪<br>   select ename,salary<em>12<br>   from emp_hiloo<br>   where salary &gt;= 5000<br>   and   salary &lt;= 10000;<br>   select ename,salary</em>12<br>   from emp_hiloo<br>   where salary between 5000 and 10000;<br>14 哪些员工的工资是5000或10000.<br>   select ename,salary<br>   from emp_hiloo<br>   where salary = 5000<br>   or salary = 10000<br>   select ename,salary<br>   from emp_hiloo<br>   where salary in (5000,10000)<br>   select ename,salary<br>   from emp_hiloo<br>   where salary =any (5000,10000)<br>15 哪个员工的名字的第二个字符是a.<br>   select ename<br>   from emp_hiloo<br>   where ename like ‘<em>a%’;<br>16 哪个员工的名字的第二个字符是</em>.<br>   select ename<br>   from emp_hiloo<br>   where ename like ‘__%’ escape ‘\\’;<br>   第一个<em>表示任意一个字符,代表通配符<br>   \\</em>必须连起来看,表示下划线本身,escape定义哪个字符可以定义转义’\\’<br>17 哪些员工没有奖金?<br>   select ename,bonus<br>   from emp_hiloo<br>   where bonus is null<br>18 哪些员工有奖金?<br>   select ename,bonus<br>   from emp_hiloo<br>   where bonus is not null<br>19哪些员工的工资不是5000也不是10000.<br>  select ename,salary<br>  from emp_hiloo<br>  where salary not in (5000,10000);<br>  select ename,salary<br>  from emp_hiloo<br>  where salary &lt;&gt; 5000<br>  and salary &lt;&gt; 10000</p>\n<p>create table emp_hiloo<br>( hiredate date）<br>insert into emp_hiloo values (1001,’zhangwuji’,’Manager’,10000,2000,’12-MAR-10’,1005,10);<br>解决方案：<br>    insert into emp_hiloo values (1001,’zhangwuji’,’Manager’,10000,2000,’12-3月-10’,1005,10);</p>\n<h5 id=\"更改字段名字-mysql、orcle-：\"><a href=\"#更改字段名字-mysql、orcle-：\" class=\"headerlink\" title=\"更改字段名字(mysql、orcle)：\"></a>更改字段名字(mysql、orcle)：</h5><p>Oracle修改表<br>alter table 表名 rename column 原名 to 新名；<br>Mysql:<br>alter table 表名 change column(可写，可不写）原名 新名 字段类型；</p>\n<p>ORA-00904：“ANN_SAL”:invalid identifier<br>无效的标识符</p>\n<p>index(索引) view(视图) sequence(顺序号/序列号) function(函数)<br>session altered.会话已更改<br>set feed on可以设置一个，显示操作数<br>connet tiger重新建立连接  show user查看当前用户是谁。<br>edit 用记事本编辑  /运行。</p>\n<p>###Function (单行、多行)###<br>单行函数:表中的一列作为函数的参数,对于每一条记录函数都有一个返回值.<br>例如:upper lower nvl<br>多行函数：表中的一列作为函数的参数,将记录分组,对于每组数据函数返回一个值.<br>例如:avg</p>\n<p>####1）单行函数####<br> 根据处理参数的数据类型分为</p>\n<h5 id=\"1）字符函数-upper-lower\"><a href=\"#1）字符函数-upper-lower\" class=\"headerlink\" title=\"1）字符函数:upper,lower\"></a>1）字符函数:upper,lower</h5><h5 id=\"2）数值函数\"><a href=\"#2）数值函数\" class=\"headerlink\" title=\"2）数值函数:\"></a>2）数值函数:</h5><pre><code>round 四舍五入\nround(12.345,2)--&gt;12.35\nround(12.345,0)=round(12.345)--&gt;12\nround(12,345,-1)--&gt;10\ntrunc 截取\ntrunc(12.345,2)--&gt;12.34\ntrunc(12.345,0)=trunc(12.345)--&gt;12\ntrunc(12,345,-1)--&gt;10\n</code></pre><h5 id=\"3-日期和日期函数\"><a href=\"#3-日期和日期函数\" class=\"headerlink\" title=\"3) 日期和日期函数\"></a>3) 日期和日期函数</h5><pre><code>select sysdate from dual\n06-SEP-12 DD-MON-RR \nalter session set\n  nls_date_format = &apos;yyyy mm dd hh24:mi:ss&apos;\nsession 会话 connection(连接)\n</code></pre><p>   日期类型的数据是用固定的字节7个字节来存储世纪,年,月,日,时,分,秒. 格式敏感<br>   会话级 alter session set nls_date_format<br>   语句级 select to_char(c1日期类型用7个字节来表达，日期类型的数据是用固定的字节7个字节来存储世纪，年，月，日，时，分，秒。四位年的前两位代表世纪20，后两位代表当前年12<br>如果不想修改sql语句运行的话，就需要在执行该语句之前，使用alter session 命令将nls_date_language修改为american，如下：<br>alter session set nls_date_language=’american’    –以英语显示日期<br>如果不想修改sql语句运行的话，就需要在执行该语句之前，使用alter session 命令将</p>\n<p>‘01-JAN-08’ 系统做了隐式数据类型转换,调用了to_date函数<br>‘2008-01-01’,用户做显式数据类型转换,自己调用<br>to_date(‘2008-01-01’,’yyyy-mm-dd’),第二个参数是对第一个参数的格式说明.<br>to_char的返回类型是字符类型,把date转换成了字符串类型,所以参数的数据类型是date.to_char函数可以获得日期的任何一部分信息,比如年,月,日等.<br>select c1 from … 系统做了隐式数据类型转换,调用了to_char函数<br>select to_char(c1,.. 用户做显式数据类型转换,自己调用to_char(c1,’yyyy-mm-dd’),第二个参数是对第一个参数的格式说明.<br>日期的运算<br>   日期可以加减一个数值,单位为天.<br>   select sysdate-1,sysdate,sysdate+1 from dual<br>两个日期相减<br>   add_months 按月加 返回类型是date<br>   add_months(sysdate,6)<br>   select add_months(hiredate,6) from emp_hiloo<br>   add_months(sysdate,-6)<br>   months_between()  返回类型是number<br>   months_between(sysdate,hiredate) 两个日期之间相差多少个月<br>select months_between(sysdate,hiredate) from emp_hiloo;<br>   last_day(sysdate) 本月的最后一天</p>\n<h5 id=\"4-转换函数\"><a href=\"#4-转换函数\" class=\"headerlink\" title=\"4) 转换函数\"></a>4) 转换函数</h5><p>两个日期相减转换函数<br>to_date  char–&gt;date<br>to_char  date–&gt;char , number –&gt; char<br>to_number  char–&gt;number</p>\n<h5 id=\"其他函数\"><a href=\"#其他函数\" class=\"headerlink\" title=\"其他函数\"></a>其他函数</h5><p>coalesce 类似nvl(oracle专有)<br>nvl(bonus,salary<em>0.1)<br>coalesce(bonus,salary</em>0.1,100)。输出所有员工的奖金，如果没有奖金就按工资的10%发放，如果奖金和工资都没有的临时工，就给100元。<br>不同的记录处理方式不一样时,用case when.<br>case when 条件表达式 then 返回结果<br>else<br>     返回结果<br>end<br>若没有else,当不匹配条件,表达式的返回值为null.<br>case deptno when 10 then(不建议该语法形式)<br>decode跟case when的功能类似.<br>decode(deptno,10,salary<em>1.1,<br>              20,salary</em>1.2,<br>              salary)<br>若没有最后一个参数,函数的返回值为null.<br>select语句<br>order by子句<br>select   from    where<br>order by<br>order by子句是select语句中的最后一个子句.<br>order by salary 缺省是升序 asc<br>order by salary desc 降序<br>order by子句后面可以跟列名,表达式(函数),列别名,在select子句中的位置.<br>ORDER BY 子句<br>ORDER BY 语句用于对结果集进行排序。<br>ORDER BY 语句<br>ORDER BY 语句用于根据指定的列对结果集进行排序。<br>ORDER BY 语句默认按照升序对记录进行排序。<br>如果您希望按照降序对记录进行排序，可以使用 DESC 关键字。<br>原始的表 (用在例子中的)：<br>Orders 表:<br>Company    OrderNumber<br>IBM    3532<br>W3School    2356<br>Apple    4698<br>W3School    6953<br>实例 1<br>以字母顺序显示公司名称：<br>SELECT Company, OrderNumber FROM Orders ORDER BY Company<br>结果：<br>Company    OrderNumber<br>Apple    4698<br>IBM    3532<br>W3School    6953<br>W3School    2356<br>实例 2<br>以字母顺序显示公司名称（Company），并以数字顺序显示顺序号（OrderNumber）：<br>SELECT Company, OrderNumber FROM Orders ORDER BY Company, OrderNumber<br>结果：<br>Company    OrderNumber<br>Apple    4698<br>IBM    3532<br>W3School    2356<br>W3School    6953<br>实例 3<br>以逆字母顺序显示公司名称：<br>SELECT Company, OrderNumber FROM Orders ORDER BY Company DESC<br>结果：<br>Company    OrderNumber<br>W3School    6953<br>W3School    2356<br>IBM    3532<br>Apple    4698<br>实例 4<br>以逆字母顺序显示公司名称，并以数字顺序显示顺序号：<br>SELECT Company, OrderNumber FROM Orders ORDER BY Company DESC, OrderNumber ASC<br>结果：<br>Company    OrderNumber<br>W3School    2356<br>W3School    6953<br>IBM    3532<br>Apple    4698<br>注意：在以上的结果中有两个相等的公司名称 (W3School)。只有这一次，在第一列中有相同的值时，第二列是以升序排列的。如果第一列中有些值为 nulls 时，情况也是这样的。</p>\n<h4 id=\"2-多行函数-哪两个函数里只能放number\"><a href=\"#2-多行函数-哪两个函数里只能放number\" class=\"headerlink\" title=\"2) 多行函数(哪两个函数里只能放number)\"></a>2) 多行函数(哪两个函数里只能放number)</h4><p>avg()    平均值  函数的参数只能是number<br>sum()    求和    函数的参数只能是number<br>count()    计数 函数的参数可以是number date 字符<br>        count(*)统计记录,count(bonus)<br>max() 最大值 函数的参数可以是number date 字符<br>min() 最小值 函数的参数可以是number date 字符</p>\n<p>组函数的缺省处理方式是处理所有的非空值.<br>avg(bonus) 所有有奖金的员工的平均值<br>count(bonus) 有奖金的员工个数<br>当所有的值都是null,count函数返回0,其他组函数返回null.</p>\n<h4 id=\"3-group-by子句\"><a href=\"#3-group-by子句\" class=\"headerlink\" title=\"3) group by子句\"></a>3) group by子句</h4><p>若有group by子句,select后面跟组标识和组函数<br>组标识指group by后面的内容<br>from–&gt;where–&gt;group by–&gt;select–&gt;order by<br>若没有group by子句,select后面只要有一个是组函数,其余的都得是组函数.</p>\n<h4 id=\"having子句\"><a href=\"#having子句\" class=\"headerlink\" title=\"having子句\"></a>having子句</h4><p>select deptno,round(avg(salary)) davg<br>from emp_hiloo<br>group by deptno<br>having round(avg(salary))&gt; 5000</p>\n<p>from–&gt;where–&gt;group by–&gt;having–&gt;select–&gt;order by </p>\n<h4 id=\"GROUP-BY-语句\"><a href=\"#GROUP-BY-语句\" class=\"headerlink\" title=\"GROUP BY 语句\"></a>GROUP BY 语句</h4><p>GROUP BY 语句用于结合合计函数，根据一个或多个列对结果集进行分组。<br>SQL GROUP BY 语法<br>SELECT column_name, aggregate_function(column_name)<br>FROM table_name<br>WHERE column_name operator value<br>GROUP BY column_name<br>SQL GROUP BY 实例<br>我们拥有下面这个 “Orders” 表：<br>O_Id    OrderDate    OrderPrice    Customer<br>1    2008/12/29    1000    Bush<br>2    2008/11/23    1600    Carter<br>3    2008/10/05    700    Bush<br>4    2008/09/28    300    Bush<br>5    2008/08/06    2000    Adams<br>6    2008/07/21    100    Carter<br>现在，我们希望查找每个客户的总金额（总订单）。我们想要使用 GROUP BY 语句对客户进行组合。<br>我们使用下列 SQL 语句：<br>SELECT Customer,SUM(OrderPrice) FROM Orders<br>GROUP BY Customer<br>结果集类似这样：<br>Customer    SUM(OrderPrice)<br>Bush    2000<br>Carter    1700<br>Adams    2000<br>很棒吧，对不对？<br>让我们看一下如果省略 GROUP BY 会出现什么情况：<br>SELECT Customer,SUM(OrderPrice) FROM Orders<br>结果集类似这样：<br>Customer    SUM(OrderPrice)<br>Bush    5700<br>Carter    5700<br>Bush    5700<br>Bush    5700<br>Adams    5700<br>Carter    5700<br>上面的结果集不是我们需要的。<br>那么为什么不能使用上面这条 SELECT 语句呢？解释如下：上面的 SELECT 语句指定了两列（Customer 和 SUM(OrderPrice)）。”SUM(OrderPrice)” 返回一个单独的值（”OrderPrice” 列的总计），而 “Customer” 返回 6 个值（每个值对应 “Orders” 表中的每一行）。因此，我们得不到正确的结果。不过，您已经看到了，GROUP BY 语句解决了这个问题。<br>GROUP BY 一个以上的列<br>我们也可以对一个以上的列应用 GROUP BY 语句，就像这样：<br>SELECT Customer,OrderDate,SUM(OrderPrice) FROM Orders<br>GROUP BY Customer,OrderDate</p>\n<h4 id=\"4-where和having比较\"><a href=\"#4-where和having比较\" class=\"headerlink\" title=\"4) where和having比较\"></a>4) where和having比较</h4><p>共同点:都执行在select之前,都有过滤功能<br>区别<br>where执行在having之前<br>where过滤的是记录,任意列名都可以出现在where子句,单行函数可以用在where子句,组函数不能出现在where子句<br>having过滤的是组,组标识可以出现在having子句,其他列名不行,组函数用于having子句,单行函数不可以.</p>\n<h5 id=\"HAVING-子句\"><a href=\"#HAVING-子句\" class=\"headerlink\" title=\"HAVING 子句\"></a>HAVING 子句</h5><p>在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与合计函数一起使用。<br>SQL HAVING 语法<br>SELECT column_name, aggregate_function(column_name)<br>FROM table_name<br>WHERE column_name operator value<br>GROUP BY column_name<br>HAVING aggregate_function(column_name) operator value<br>SQL HAVING 实例<br>我们拥有下面这个 “Orders” 表：<br>O_Id    OrderDate    OrderPrice    Customer<br>1    2008/12/29    1000    Bush<br>2    2008/11/23    1600    Carter<br>3    2008/10/05    700    Bush<br>4    2008/09/28    300    Bush<br>5    2008/08/06    2000    Adams<br>6    2008/07/21    100    Carter<br>现在，我们希望查找订单总金额少于 2000 的客户。<br>我们使用如下 SQL 语句：<br>SELECT Customer,SUM(OrderPrice) FROM Orders<br>GROUP BY Customer<br>HAVING SUM(OrderPrice)<2000 1500=\"\" 1700=\"\" 结果集类似：=\"\" customer=\"\" sum(orderprice)=\"\" carter=\"\" 现在我们希望查找客户=\"\" \"bush\"=\"\" 或=\"\" \"adams\"=\"\" 拥有超过=\"\" 的订单总金额。=\"\" 我们在=\"\" sql=\"\" 语句中增加了一个普通的=\"\" where=\"\" 子句：=\"\" select=\"\" customer,sum(orderprice)=\"\" from=\"\" orders=\"\" or=\"\" group=\"\" by=\"\" having=\"\">1500<br>结果集：<br>Customer    SUM(OrderPrice)<br>Bush    2000<br>Adams    2000</2000></p>\n<h4 id=\"5-DCL\"><a href=\"#5-DCL\" class=\"headerlink\" title=\"5) DCL\"></a>5) DCL</h4><p>connect openlab/open123<br>select count(*) from hiloo.emp_hiloo;</p>\n<p>connect hiloo/hiloo123<br>grant select on emp_hiloo to openlab;</p>\n<p>connect openlab/open123<br>select count(*) from hilool.emp_hiloo<br>10rows selected</p>\n<p>connect hiloo/hiloo123<br>revoke select on emp_hiloo from openlab;</p>\n<p>show user<br>select count(*) from hiloo.emp_hiloo</p>\n<p>create synonym emp_hiloo for hiloo.emp_hiloo</p>\n<h4 id=\"6-关于null值的讨论\"><a href=\"#6-关于null值的讨论\" class=\"headerlink\" title=\"6) 关于null值的讨论\"></a>6) 关于null值的讨论</h4><p>1 case when在没有else和decode少一个参数时,返回null.<br>2order by bonus,asc升序时null值在最后,desc降序时null在最前.<br>3 组函数和null值的关系:1组函数的缺省处理方式是处理所有的非空值.2当所有的值都是null,count函数返回0,其他组函数返回null.<br>4若group by的列有null值,所有的null值分在一组.<br>课堂练习<br>1将每个员工的工资涨12.34567%,用round和trunc分别实现<br>select ename,nvl(trunc(round(salary+salary*0.1234567,2),1),0.0) from emp_hiloo;//自己写的。<br>2 将’2008-01-01’插入表中,<br>  再将’2008 08 08 08:08:08’插入表中<br>insert into test values<br>(to_date(‘01-JAN-08’,’DD-MON-RR’));</p>\n<p>3找出3月份入职的员工.<br>select ename,hiredate<br>from emp_hiloo<br>where to_char(hiredate,’mm’) = ‘03’;<br>select ename,hiredate<br>from emp_hiloo<br>where to_char(hiredate,’mm’) = 3;//可以正常输出winXP下<br>‘03’ = 3  —&gt; to_number(‘03’) = 3<br>字符   数值  缺省系统将字符转成数值<br>select ename,hiredate<br>from emp_hiloo<br>where to_char(hiredate,’fmmm’) = ‘03’;(错，未选定行，无输出)</p>\n<p>select ename,hiredate<br>from emp_hiloo<br>where to_char(hiredate,’fmmm’) = ‘3’;(对)<br>‘03’ = ‘3’ (错)<br>fm表示去掉前导0或去掉两边的空格.<br>4 zhangsanfeng的mgr上显示boss,其他人不变.<br>select ename,empno,<br>       nvl(to_char(mgr),’boss’) mgr<br>from emp_hiloo<br>函数nvl（“1”，“2”）:如果字符串1是空，就返回字符串”2”</p>\n<h4 id=\"5十分钟之后\"><a href=\"#5十分钟之后\" class=\"headerlink\" title=\"5十分钟之后\"></a>5十分钟之后</h4><p> select sysdate,sysdate+1/144 from dual;<br>解释：Oracle 里面,</p>\n<p>sysdate + 1 意思是 当前时间 + 1天</p>\n<p>sysdate + 1/24  意思是 当前时间 + 1/24天  也就是1小时后</p>\n<p>sysdate+1/144  意思是 当前时间 + 1/144天 （1/24<em>6）  也就是10分钟后<br> 6 若员工是10部门的,工资涨10%,20部门工资涨20%,其他员工工资不变.<br>select ename,salary,<br>       case when deptno = 10 then salary</em>1.1<br>            when deptno = 20 then salary*1.2<br>       else<br>            salary<br>       end new_sal<br>from emp_hiloo;</p>\n<p>select ename,salary,<br>       decode(deptno,10,salary<em>1.1,<br>                     20,salary</em>1.2,<br>                     salary) new_sal<br>from emp_hiloo;<br>7 列出每个员工的年薪,按年薪降序排列.<br>select ename,salary<em>12<br>from emp_hiloo<br>order by salary desc (好)<br>select ename,salary</em>12<br>from emp_hiloo<br>order by salary<em>12 desc<br>select ename,salary</em>12 n_sal<br>from emp_hiloo<br>order by n_sal desc</p>\n<p>select ename,salary<em>12 n_sal from emp_hiloo order by 2 desc;<br>select salary</em>12,ename n_sal from emp_hiloo order by 2 asc;<br>8 列出员工的名字,部门号以及工资,按部门号从小到大的顺序,同一部门的工资按降序排列.<br>select ename,deptno,salary<br>from emp_hiloo<br>order by deptno,salary desc<br>9 列出奖金的平均值,和,个数,最大值,最小值.<br>AVG 函数返回数值列的平均值。NULL 值不包括在计算中<br>select avg(bonus),avg(nvl(bonus,0)),<br>       sum(bonus), sum(nvl(bonus,0)),<br>       count(bonus),count(nvl(bonus,0)),<br>       max(bonus),max(nvl(bonus,0)),<br>       min(bonus),min(nvl(bonus,0))<br>from emp_hiloo<br>10 各个部门的平均工资<br>ROUND 函数用于把数值字段舍入为指定的小数位数。<br>select deptno,round(avg(salary))<br>from emp_hiloo<br>group by deptno<br>11 求10部门的平均工资,只显示平均工资<br>   求10部门的平均工资,显示部门号,平均工资<br>   select round(avg(salary))<br>   from emp_hiloo<br>   where deptno = 10<br>   group by deptno</p>\n<p>   select max(deptno),round(avg(salary))<br>   from emp_hiloo<br>   where deptno = 10<br>12各个部门不同职位的平均工资<br>   select deptno,job,round(avg(salary))<br>   from emp_hiloo<br>   group by deptno,job<br>13 每种奖金有多少人?<br>   select bonus,count(empno)<br>   from emp_hiloo<br>   group by bonus<br>14 列出平均工资大于5000的部门的平均工资<br>   select deptno,round(avg(salary))<br>   from emp_hiloo<br>   group by deptno<br>   having round(avg(salary)) &gt; 5000<br>15哪些员工的工资是最低的.<br>  select ename from emp_hiloo<br>  where salary = ( select min(salary)<br>                   from emp_hiloo)<br>报错信息<br>ORA-01861: literal does not match format string<br>文字值不匹配格式串<br>ORA-01722: invalid number 无效的数值 to_number<br>ORA-00937: not a single-group group function 不是一个组函数<br>ORA-00979: not a GROUP BY expression 不是一个group by表达式 GROUP BY expression指跟在group by后面的东西(列名),称之为组标识<br>detail 细节 summary 聚合</p>\n<h3 id=\"查询\"><a href=\"#查询\" class=\"headerlink\" title=\"查询\"></a>查询</h3><p>子查询定义<br>在SQL语句中嵌入select语句<br>create table new_tabname<br>as<br>select ename,salary*12 ann_sal from emp_hiloo;<br>新表的结构由select后面的项来决定,new_table包含两列ename,ann_sal.</p>\n<h4 id=\"子查询\"><a href=\"#子查询\" class=\"headerlink\" title=\"子查询\"></a>子查询</h4><p>  非关联子查询<br>    单列子查询<br>    多列子查询<br>  关联子查询</p>\n<h5 id=\"子查询执行\"><a href=\"#子查询执行\" class=\"headerlink\" title=\"子查询执行\"></a>子查询执行</h5><p>非关联子查询<br>子查询的表和主查询的表没有建关联<br>先执行子查询(只执行一遍),当返回多条记录,系统会将自动去重的结果返回给主查询,再执行主查询.</p>\n<p>关联子查询<br>子查询的表和主查询的表建关联.所谓建关联指主查询表里的列和子查询表里的列写成一个条件表达式.</p>\n<p>先执行主查询,判断表里的记录是否应该放入结果集.过程如下:拿到第一条记录,获得了各个列的值,将需要的列值带入子查询,执行后返回的结果再和主查询表里的列做比较,符合条件,该记录放入结果集,否则过滤掉.依次执行主查询表里的每条记录.子查询执行的次数由主查询表里的记录数决定.</p>\n<p>1) exists和not exists<br>exists的执行过程<br>从主查询表里拿到第一条记录,按子查询里的关联条件在子查询的表里看是否能找到匹配的记录,当找到第一条匹配的记录后,立即返回(即不需要找出所有匹配的记录),exists条件满足,主查询表里的该记录放入结果集.若按子查询里的关联条件将子查询<br>表里的记录全部检查一遍后没有一条符合条件的记录,此时也返回, exists 条件不满足,主查询表里的该记录不能放入结果集,被过滤掉.</p>\n<p>select ename from emp_afei o<br>where exists<br>             (select 1 from emp_afei i<br>              where o.empno = i.mgr)</p>\n<h5 id=\"非关联子查询的分类\"><a href=\"#非关联子查询的分类\" class=\"headerlink\" title=\"非关联子查询的分类\"></a>非关联子查询的分类</h5><p>单列子查询<br>select ename,salary<br>from emp_hiloo<br>where salary = (select min(salary)<br>                from emp_hiloo<br>                )<br>多列子查询:按键值对比较<br>select ename,salary,deptno<br>from emp_afei<br>where (deptno,salary) in<br>             (select deptno,round(avg(salary))<br>              from emp_afei<br>              group by deptno)</p>\n<p>2) 课堂练习<br>1哪些人是领导?(非关联子查询)<br>如果一个员工的empno能出现在mgr里就说明他是领导.<br>select ename<br>from emp_hiloo<br>where empno in (select mgr from emp_hiloo)<br>select ename<br>fro emp_afei<br>where empno in (1001,1005,1006,1008,null)<br>2 哪些人是员工?<br>他的empno绝对不能出现在mgr中,他的empno跟mgr的出现的所有的值不能相等. &lt;&gt;all<br>select ename<br>from emp_hiloo<br>where empno not in (select mgr from emp_hiloo)<br>select ename<br>fro emp_afei<br>where empno not in (1001,1005,1006,1008,null)<br>select ename<br>from emp_hiloo<br>where empno not in (select mgr from emp_hiloo<br>                    where mgr is not null)</p>\n<p>3哪些部门的平均工资比30部门的平均工资高?<br>select deptno,round(avg(salary))<br>from emp_hiloo<br>group by deptno<br>having round(avg(salary)) &gt;<br>                    (select round(avg(salary))<br>                     from emp_hiloo<br>                     where deptno = 30)<br>4哪些员工的工资比zhangwuji的工资高?<br>select ename,salary<br>from emp_afei<br>where salary &gt; (select salary from emp_afei<br>                where ename = ‘zhangwuji’)<br>ERROR at line 3:<br>ORA-01427: single-row subquery returns more than one row<br>单行子查询返回多条记录</p>\n<p>比所有人高 &gt; (select max(salary))<br>           &gt;all<br>比任意人高 &gt; (select min(salary)<br>           &gt;any<br>5哪些员工的工资等于本部门的平均工资?<br>select ename,salary,deptno<br>from emp_afei<br>where (deptno,salary) in<br>             (select deptno,round(avg(salary))<br>              from emp_afei<br>              group by deptno)<br>5哪些员工的工资比本部门的平均工资高?<br>select ename,salary,deptno<br>from emp_afei o<br>where salary &gt; (select round(avg(salary))<br>                from emp_afei i<br>                where i.deptno = o.deptno)<br>6哪些人是领导?(关联子查询)<br>select ename from emp_afei o<br>where exists<br>             (select 1 from emp_afei i<br>              where o.empno = i.mgr)<br>7哪些部门有员工?<br>select deptno,dname<br>from dept_afei o<br>where exists (select 1 from emp_afei i<br>              where o.deptno = i.deptno)</p>\n<p>3) 课外练习day03am<br>1 zhangwuji的领导是谁,显示名称?<br>2 zangwuji领导谁,显示名称?<br>3 列出devoleper部门有哪些职位?<br>1) 课外练习day04am答案<br>1 zhangwuji的领导是谁,显示名称?<br>  select ename from emp_afei<br>  where empno in<br>        (select mgr from emp_afei<br>                 where ename = ‘zhangwuji’)</p>\n<p>zangwuji领导谁,显示名称?</p>\n<p> select ename from emp_afei<br> where mgr in (select empno from emp_afei<br>               where ename = ‘zhangwuji’)</p>\n<p>3 列出developer部门有哪些职位?<br>  select distinct job from emp_afei<br>  where deptno in<br>           (select deptno from dept_afei<br>            where dname = ‘developer’)</p>\n<p>2) 非关联子查询<br>exists和not exists<br>not exists的执行过程<br>从主查询表里拿到第一条记录,按子查询里的关联条件在子查询的表里看是否能找到匹配的记录,当找到第一条匹配的记录后,立即返回(即不需要找出所有匹配的记录),not exists条件不满足,主查询表里的该记录不能放入结果集,被过滤掉.若按子查询里的关联条件将子查询表里的记录全部检查一遍后没有一条符合条件的记录,返回, not exists 条件满足,主查询表里的该记录放入结果集.</p>\n<p>对于exists和not exists,在子查询中找到第一条匹配的记录都会立即返回,exists将主查询表里的记录放入结果集,not exsits将主查询表里的记录过滤掉.<br>对于exists和not exists,如果子查询没有返回任何记录,即扫描全部记录后没有一条符合条件的记录,都返回,exists将主查询表里的记录过滤掉,not exists将主查询表里的记录放入结果集.<br>not in ,&lt;&gt; all逻辑上跟not exists等价<br>in ,=any逻辑上跟exists等价</p>\n<p>查询形式:集合操作<br>把结果集作为一个集合,结果集必须是同构的,列的个数及数据类型一致</p>\n<p>3) 并集  union(去重)/union all(不去重)<br>select ename,deptno,salary,salary<em>1.1 new_sal<br>from emp_afei<br>where deptno = 10<br>union all<br>select ename,deptno,salary,salary</em>1.2 new_sal<br>from emp_afei<br>where deptno = 20<br>union all<br>select ename,deptno,salary,salary new_sal<br>from emp_afei<br>where deptno not in (10,20)</p>\n<p>case when和decode可以实现类似功能.</p>\n<p>4) 交集  intersect(去重)<br>select job from emp_afei<br>where deptno = 10<br>intersect<br>select job from emp_afei<br>where deptno = 20<br>10部门和20部门都有的职位是哪些?</p>\n<p>5) 差  minus(去重)<br>select deptno from dept_afei<br>minus<br>select deptno from emp_afei<br>那些部门没有员工.</p>\n<p>6) 多表查询<br>1) 交叉连接 cross join<br>select e.ename,d.dname<br>from emp_afei e cross join dept_afei d<br>结果集产生<br>10*4=40,组合操作,笛卡尔积</p>\n<p>2) 内连接 inner join(匹配一个条件)<br>select e.ename,e.deptno,d.deptno,d.dname<br>from emp_afei e join dept_afei d<br>ORA-00905: missing keyword(丢失关键字)</p>\n<p>如果把结果集的产生看成双层循环,驱动表是外层循环,匹配表是内层循环.<br>对于内连接哪张表做驱动表,哪张表做匹配表产生出的结果集是一样的,不同的是性能.<br>驱动表在匹配表的匹配情况如下:<br>一条记录找到一条匹配<br>一条记录找到多条匹配<br>一条记录找不到任何匹配.<br>内连接的核心是驱动表的记录要出现在结果集中必须在匹配表中能找到匹配的记录,否则该记录被过滤掉.</p>\n<p>3) 内连接查询形式<br>等值连接 on e.deptno = d.deptno<br>两张表有表述同一属性的列,两张表都有deptno列.<br>自连接 on e.mgr = m.empno<br>同一张表的不同列能写成一个表达式,即同一张表的两条记录之间有关系.通过给表起别名的方式,将同一张表的两条记录之间的关系转化成不同表的两条记录之间的关系.<br>4) 外连接<br>外连接 outer join(驱动表的记录一个都不能少的出现在结果集里)<br>from t1 left join t2<br>on t1.c1 = t2.c2(t1驱动表,t2匹配表)<br>外连接结果集=内连接的结果集+t1表中匹配不上的记录和t2表中的null记录的组合<br>from t1 right join t2<br>on t1.c1 = t2.c2(t2驱动表,t1匹配表)<br>外连接结果集=内连接的结果集+t2表中匹配不上的记录和t1表中的null记录的组合<br>from t1 full join t2<br>on t1.c1 = t2.c2<br>外连接结果集=内连接的结果集+t1表中匹配不上的记录和t2表中的null记录的组合+t2表中匹配不上的记录和t1表中的null记录的组合</p>\n<p>5) 外连接的应用场景<br>1 某张表的记录全部出现在结果集中,包括匹配不上的.<br>select e.ename,nvl(m.ename,’Boss’)<br>from emp_afei e left join emp_afei m<br>on e.mgr = m.empno<br>2解决否定问题,匹配不上的记录找出来(跟所有的记录都不匹配.)(not in/not exists)<br>外连接 + where 匹配表.主键列 is null<br>select e.ename,d.dname<br>from emp_afei e right join dept_afei d<br>on e.deptno = d.deptno<br>where e.empno is null<br>(解决结果集只包含匹配不上的记录.where子句执行在外连接之后)哪些部门没有员工</p>\n<p>select d.dname<br>from emp_afei e right join  dept_afei d<br>on e.deptno = d.deptno<br>and e.ename = ‘zhangwuji’<br>where e.empno is null<br>如果希望在外连接之前过滤匹配表用and子句,如果想在外连接之后通过匹配表里的列过滤外连接的结果集时候用where.<br>过滤驱动表统计用where子句过滤.</p>\n<p>6) 课内练习<br>1 哪些部门没有员工(not exists)<br>  select dname from dept_afei o<br>  where not exists<br>        (select 1 from emp_afei i<br>         where o.deptno = i.deptno)<br>2 哪些人是员工?(not exists)<br>  select ename from emp_afei o<br>  where not exists<br>            (select 1 from emp_afei i<br>             where o.empno = i.mgr)<br>他的empno和其他人的mgr相等是不可能存在的.即和所有人的mgr都不相等.<br>not in ,&lt;&gt; all逻辑上跟not exists等价<br>3 列出哪些员工在北京地区上班?<br>思路:确定表,两张表,匹配问题用inner join–&gt;on(匹配条件)–&gt;(对表是否过滤)<br>select e.ename,e.deptno,d.deptno,d.dname<br>from emp_afei e join dept_afei d<br>on e.deptno = d.deptno<br>and d.location = ‘beijing’<br>4zhangwuji在哪个地区上班?<br>select e.ename,d.dname,d.location<br>from emp_afei e join dept_afei d<br>on e.deptno = d.deptno<br>and e.ename = ‘zhangwuji’<br>5列出每个部门有哪些职位?部门名称,职位<br> select distinct d.dname,e.job<br> from emp_afei e join dept_afei d<br> on e.deptno = d.deptno<br> order by d.dname<br>6各个部门的平均工资,列出部门名称,平均工资.<br>select d.dname,round(avg(e.salary)) savg<br>from emp_afei e join dept_afei d<br>on e.deptno = d.deptno<br>group by d.dname<br>select max(d.dname),round(avg(e.salary)) savg<br>from emp_afei e join dept_afei d<br>on e.deptno = d.deptno<br>group by d.deptno<br>select min(deptno),round(avg(salary))<br>from emp_hiloo<br>where deptno = 10<br>7 列出每个员工的名字和他的领导的名字<br>select e.ename employee,<br>       m.ename manager<br>from emp_afei e join emp_afei m<br>on e.mgr = m.empno<br>结果集是9条.<br>e表中有10条记录,其中9条记录找到匹配,zhangsanfeng没匹配<br>m表中有10条记录,其中4条记录找到匹配,4条记录是领导,6条记录找不到匹配,他们是员工.<br>select e.ename employee,<br>       m.ename manager<br>from emp_afei e join emp_afei m<br>on e.mgr = m.empno<br>union all<br>select ename,’Boss’<br>from emp_afei<br>where mgr is null</p>\n<p>select e.ename employee,<br>       decode(m.ename,e.ename,’Boss’,<br>                  m.ename)   manager<br>from emp_afei e join emp_afei m<br>on nvl(e.mgr,e.empno) = m.empno</p>\n<p>select e.ename,nvl(m.ename,’Boss’)<br>from emp_afei e left join emp_afei m<br>on e.mgr = m.empno<br>10=9+1</p>\n<p>8哪些人是领导?<br>select distinct m.ename<br>from emp_afei e join emp_afei m<br>on e.mgr = m.empno<br>9哪些部门没有员工?<br>select e.ename,d.dname<br>from emp_afei e right join dept_afei d<br>on e.deptno = d.deptno<br>where e.empno is null<br>(解决结果集只包含匹配不上的记录.where子句执行在外连接之后)<br>11=10+1<br>如果部门表里的某条记录的deptno在emp表找不到匹配,在内连接中,它被过滤,<br>e表的empno的特性是唯一且非空的(主键约束),居然e.empno is null,说明null是外连接时为了驱动表中那条匹配不上的记录出现在结果集中,在匹配表中模拟的null记录.<br>10哪些人是员工,哪些人不是领导?<br>select e.empno,m.ename<br>from emp_afei e right join emp_afei m<br>on e.mgr = m.empno<br>where e.empno is null</p>\n<p>from emp_afei e right join emp_afei m<br>15=9+(10(m表中有10条记录)-4(m表中有4条匹配记录 ))<br>from emp_afei e left join emp_afei m<br>10(结果集)=9+(10(e表中有10条记录)-9(e表中有9条匹配记录))<br>11 哪些部门没有叫zhangwuji的?<br>select d.dname<br>from emp_afei e right join  dept_afei d<br>on e.deptno = d.deptno<br>and e.ename = ‘zhangwuji’<br>where e.empno is null</p>\n<p>7) 课外练习(day04)(答案在Day05)<br>1zhangwuji的领导是谁?(表连接)<br>2zhangwuji领导谁?(表连接)<br>3哪些人是领导?(in exists join)<br>4哪些部门没有员工?(not in/not exists/outer join)<br>5哪些人是员工,哪些人不是领导?(not in/not exists/outer join)<br>Day05.txt<br>Grade级别<br>Lowsal最低工资<br>Hisal最高工资<br>Create table salgrade_hiloo(<br>Grade<br>)<br>cross join  inner join   outer join<br>inner join(匹配)<br>  等值连接<br>  自连接<br>  非等值连接<br>outer join(匹配+不匹配)<br>  等值连接</p>\n<p>  自连接<br>  非等值连接</p>\n<p>所谓非等值连接表示两张表里的列不能写成等值表达式,而是写成between and之类.所以两个表之间有关系是指表里的列可以写成表达式,而不是等值表达式.<br>salgrade<br>grade  级别<br>lowsal 最低工资<br>hisal  最高工资</p>\n<p>from后面跟子查询<br>emp,各个部门的平均工资dept_avgsal(depnto,avgsal)<br>select e.ename,e.salary,e.deptno<br>from emp_afei e join<br>      (select deptno,round(avg(salary)) avgsal<br>       from emp_afei<br>       group by deptno) a<br>on e.deptno = a.deptno<br>and e.salary &gt; a.avgsal</p>\n<p>各个部门的平均工资,列出部门名称,平均工资<br>select max(d.dname),round(avg(salary))<br>from emp_afei e join dept_afei d<br>on e.deptno = d.deptno<br>group by d.deptno</p>\n<p>select d.dname,a.avgsal<br>from dept_afei d join<br>      (select deptno,round(avg(salary)) avgsal<br>       from emp_afei<br>       group by deptno) a<br>on d.deptno = a.depto</p>\n<p>DML<br>insert一条记录时,若某些列为null值,有哪些语法实现?<br>insert into tabname values (1,’a’,null,sysdate)<br>insert into tabname(c1,c2,c4)<br>values (1,’a’,sysdate)<br>insert语句的两种语法形式?<br>insert into tabname values () insert一条记录<br>insert into tabname<br>select * from tabname1  insert多条记录<br>连接图解：</p>\n<h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><p>1) 课外练习答案day04<br>1zhangwuji的领导是谁?(表连接)<br> select m.ename<br> from emp_afei e join emp_afei m<br> on e.mgr = m.empno<br> and m.ename = ‘zhangwuji’<br>2 zhanghangwuji领导谁?(表连接)<br> select e.ename<br> from emp_afei e join emp_afei m<br> on e.mgr = m.empno<br> and m.ename = ‘zhangwuji’<br>3哪些人是领导?(in exists join)<br> select ename from emp_afei<br> where empno in (select mgr from emp_afei)<br> select ename from emp_afei o<br> where exists<br>            (select 1 from emp_afei i<br>             where o.empno = i.mgr)<br> select distinct m.ename<br> from emp_afei e join emp_afei m<br> on e.mgr = m.empno<br>4哪些部门没有员工?(not in/not exists/outer join)<br> select dname from dept_afei<br> where deptno not in<br>               (select deptno from emp_afei)<br> select dname from dept_afei o<br> where not exists<br>             (select 1 from emp_afei i<br>              where o.deptno = i.deptno)<br> select d.dname<br> from emp_afei e right join dept_afei d<br> on e.deptno = d.deptno<br> where e.empno is null<br>5哪些人是员工,哪些人不是领导?(not in/not exists/outer join)<br> select ename from emp_afei<br> where empno not in (<br>               select mgr from emp_afei<br>               where mgr is not null)<br> select ename from emp_afei o<br> where not exists<br>             (select 1 from emp_afei i<br>              where o.empno = i.mgr)<br> select m.ename<br> from emp_afei e right join emp_afei m<br> on e.mgr = m.empno<br> where e.empno is null<br>cross join (笛卡尔积)</p>\n<p>rownum 伪列,记录号<br>若用rownum选择出记录,编号必须从1开始.<br>分页问题<br>第一页<br>select rownum,ename<br>from emp_afei<br>where rownum &lt;= 3;<br>第二页<br>select rn,ename<br>from (<br>      select rownum rn,ename<br>      from emp_afei<br>      where rownum &lt;= 6)<br>where rn between 4 and 6<br>排名问题<br>按工资排名的前三条记录<br>select rownum,ename,salary<br>from emp_hiloo<br>where rownum &lt;=3<br>order by salary desc;(错)</p>\n<p>select rownum,ename,salary<br>from ( select ename,salary<br>       from emp_afei<br>       order by salary desc)<br>where rownum &lt;= 3</p>\n<p>update语句的中set后面的=是什么含义?where后面的=是什么含义?<br>set c1 = null (= 赋值)<br>where c1 = null (= 等号)</p>\n<p>update和delete语句中的where子句是什么含义?<br>用来确定对表里的哪些记录要进行update或delete操作,没有where子句多表里的所有记录update或delete<br>update<br>set<br>where c1 = (select …)<br>rename 关键字 17<br>commit</p>\n<p>1011 abc 1000 10 ‘clerk’<br>update 1001 1000–&gt;2000<br>delete 1011<br>commit<br>如何编写和运行一个sql脚本(文本文件)<br>1 编辑文件<br>在linux环境下已经编写好了test.sql,做一个鼠标右键的copy</p>\n<p>在20,23,26机器上,<br>vi test.sql<br>按a i o进入编辑模式,paste,按esc键,再按:wq!回车</p>\n<p>2 运行文件<br>sun-server% sqlplus openlab/open123 @test.sql<br>@表示运行<br>SP2-0310: unable to open file “test.sql”在当前目录下没有test.sql文件<br>sqlplus openlab/open123 ../test.sql</p>\n<p>cd ..<br>sun-server% sqlplus openlab/open123 @test.sql</p>\n<p>SQL&gt;@test.sql</p>\n<p>数据库对象 PL/SQL<br>create or replace function test<br>insert into test values (1,1)<br>            *<br>ERROR at line 1:<br>ORA-04044: procedure(存储过程), function(函数), package(包), or type is not allowed here</p>\n<p>事务(transaction 交易)<br>事务里包含的DML语句<br>事务的结束<br>commit 提交,(dml操作的数据入库了)<br>rollback 回滚 撤销(DML操作被取消)<br>sqlplus正常退出=commit<br>DDL语句自动提交<br>开始<br>上一个事务的结束是下一个事务的开始.<br>一致状态<br>数据库的数据被事务改变.<br>oltp online transaction processing联机事务处理系统 高并发系统</p>\n<p>事务的隔离级别 read committed(读已经提交了的数据)</p>\n<p>如果不commit—–&gt;commit rollback<br>1如果不commit,其他session是看不见你的操作<br>2如果不commit,会阻塞操作同一条记录的事务(session),commit才能释放所有DML加的锁.<br>3如果不commit,系统做DML操作,会将old data放入rollback segment(回滚段) ,所占用的回滚段资源不释放.</p>\n<p>DML系统会自动给表及表里的记录加锁<br>表级共享锁<br>行级排他锁<br>    表级共享锁     行级排他锁<br>s1    ok        ok<br>s2    ok        enqueue wait<br>s3    ok        ok</p>\n<p>执行DDL语句,系统自动加DDL排他锁<br>SQL&gt; drop table test purge;<br>drop table test purge<br>           *<br>ERROR at line 1:<br>ORA-00054: resource busy(资源忙 test表) and acquire with NOWAIT specified (dml wait,ddl nowait 如果加不上锁,报错退出)</p>\n<p>DDL语句<br>字符类型<br>varchar2,必须带宽度, 按字符串的实际长度存,本身的数据是变化,对空格敏感<br>char,可以不带宽度,缺省宽度是1,按字符串的定义长度存,本身的数据是固定长度的.对空格不敏感<br>数值类型</p>\n<p>number类型<br>create table test90<br>(c1 number,<br> c2 number(6),<br> c3 number(4,2),<br> c4 number(2,4),<br> c5 number(3,-3))</p>\n<p>四舍五入<br>number(6) 表示6为整数 999999<br>number(4,2) 表示小数点后2位,整数位2位 99.99<br>number(2,4) 表示小数点后4位,能填数字的位数是2位 0.0099<br>number(3,-3) 999000 999123–&gt;999000<br>                    999511–&gt;报错</p>\n<p>user_tables 是一张系统表,里面记录当前用户所有的表的信息,里面没有记录表的创建日期.<br>user_objects 是一张系统表,里面记录当前用户所有的数据库对象的信息.created的列记录数据库对象(如表)的创建日期.<br>user_tables和user_objects这两张表的关系体现在table_name和object_name都记录的是表名.</p>\n<p>data block 数据块,操作数据的最小逻辑(物理)单元,最少读一个block的数据</p>\n<p>HWM high water mark 高水位线,表示曾经插入数据的最高位置<br>FTS full table scan 全表扫描,把表里的所有记录读一遍,把HWM之下的所有data block读一遍</p>\n<p>truncate table 释放空间,HWM下移<br>delete 不释放空间,HWM不动<br>不适合用delete命令删大表.</p>\n<p>课内练习<br>1 列出工资级别为3级,5级的员工<br>  select e.ename,e.salary,s.grade<br>  from emp_afei e join salgrade_afei s<br>  on e.salary between s.lowsal and s.hisal<br>  and s.grade in (3,5)<br>2 列出各个工资级别有多少人?<br>  select s.grade,count(e.empno)<br>  from emp_afei e join salgrade_afei s<br>  on e.salary between s.lowsal and s.hisal<br>  group by s.grade<br>  order by s.grade<br>3 列出各个工资级别有多少人?(包含0级)<br>  select s.grade,count(e.empno)<br>  from emp_afei e right join salgrade_afei s<br>  on e.salary between s.lowsal and s.hisal<br>  group by s.grade<br>  order by s.grade<br>特别注意count不要写*或者s.grade</p>\n<p>课外练习day05<br>1按工资排名的第4到第6名员工.</p>\n<p>###关键点###<br>课外练习day05答案</p>\n<p>按工资排名的第4到第6名员工.<br>select rn,ename,salary<br>from<br>    (select rownum rn,ename,salary<br>     from (select ename,salary<br>           from emp_afei<br>           order by salary desc)<br>     where rownum &lt;= 6<br>    )<br>where rn &gt;= 4 </p>\n<p>####1）事务####</p>\n<p>####约束 constraint (安检)####<br>primary key(主键)<br>foreign key(外键)<br>unique key (唯一键)<br>not null(非空)<br>check (检查)</p>\n<p>主键 (表中不会出现重复记录)<br>列级约束<br>create table test<br>(c1 number(2)<br>    constraint test_c1_pk primary key,<br> c2 number(3))</p>\n<pre><code>constraint test_c1_pk primary key,\n           *\n</code></pre><p>ERROR at line 3:<br>ORA-02264: name already used by an existing constraint (名字被存在的约束使用了)</p>\n<p>SQL&gt; select table_name from user_constraints<br>  2  where constraint_name = ‘TEST_C1_PK’;<br>哪张表里有叫TEST_C1_PK这个约束名.</p>\n<p>ORA-00001: unique constraint (HILOO(用户名) .TEST_C1_PK) violated(冲突)</p>\n<p>PK=UK + NN</p>\n<p>表级约束<br>create table test(<br>c1 number(2),<br>c2 number,<br>constraint test_c1_pk primary key(c1)<br>)<br>表中有三列c1,c2,c3,c1和c2做成联合主键<br>create table test(<br>c1 number,<br>c2 number,<br>constraint test_c1_c2_pk primary key(c1,c2),<br>c3 number<br>)<br>没有constraint关键字,系统用自动起名字sys_c数字.</p>\n<p>not null<br>create table test<br>(c1 number constraint test_c1_pk primary key,<br> c2 number not null);<br>not null约束没有表级形式</p>\n<p>unique (pk)<br>相同点:都要保证唯一性<br>区别:uk允许为null,而且可以多个null值,一个表中只能有一个pk约束,可以有多个uk约束.<br>create table test<br>(c1 number constraint test_c1_pk primary key,<br> c2 number constraint test_c2_uk unique)</p>\n<p>create table test(<br>c1 number primary key,<br>c2 number primary key,<br>c3 number unique,<br>c4 number unique)  (报错,一张表只能有一个primary key)</p>\n<p>create table test(<br>c1 number constraint test_c1_pk primary key,<br>c2 number constraint test_c2_uk unique,<br>c3 number constraint test_c3_uk unique,<br>c4 number )<br>c2上定义了一个唯一键 c3上定义了一个唯一键</p>\n<p>create table test(<br>c1 number constraint test_c1_pk primary key,<br>c2 number,<br>c3 number,<br>constraint test_c2_c3_uk unique (c2,c3),<br>c4 number)<br>c2,c3联合唯一键</p>\n<p>check<br>create table test(<br>c1 number(3) constraint test_c1_ck<br>             check (c1 &gt; 100))</p>\n<p>create table test(<br>c1 number(3),<br>constraint test_c1_ck check (c1 &gt; 100))</p>\n<p>外键<br>parent table(父表)上定义唯一列(pk/uk)<br>child table(子表)上定义外键列(fk)</p>\n<p>1 先create parent table(pk/uk),再create child table(fk)<br>2 先insert into parent table,再insert into child table<br>3 先delete from child table,再delete from parent table<br>4 先drop child table,再drop parent table</p>\n<p>reference 引用<br>create table parent<br>(c1 number(3))</p>\n<p>create table child<br>(c1 number(2) constraint child_c1_pk<br>              primary key,<br> c2 number(3) constraint child_c2_fk<br>              references parent(c1))</p>\n<pre><code>references parent(c1))\n                  *\n</code></pre><p>ERROR at line 5:<br>ORA-02270: no matching unique or primary key for this column-list<br>在c1上没有定义uk或pk</p>\n<p>alter table parent<br>add constraint parent_c1_pk primary key(c1);<br>给c1列增加主键约束</p>\n<p>insert into child values (1,1)<br>ORA-02291: integrity constraint(完整性约束) (HILOO.CHILD_C2_FK) violated - parent key not found (父键值没发现)<br>违反fk约束</p>\n<p>insert into parent values (1);<br>insert into child values (1,1)</p>\n<p>delete from parent where c1 = 1;<br>ORA-02292: integrity constraint (HILOO.CHILD_C2_FK) violated - child record<br>found(子记录被发现)</p>\n<p>delete from child where c2 = 1;<br>delete from parent where c1 = 1;</p>\n<p>drop table parent purge;<br>ORA-02449: unique/primary keys in table referenced by foreign keys<br>在parent table上的pk/uk正在fk所引用</p>\n<p>drop table child purge;<br>drop table parent purge;</p>\n<p>drop table parent cascade constraints purge;<br>cascade constraints 级联约束,child table本身没被删除,只是先把子表上的fk约束删除,再删parent table.</p>\n<p>表级约束<br>create table child<br>(c1 number(2) constraint child_c1_pk<br>              primary key,<br> c2 number(3),<br> constraint child_c2_fk foreign key(c2)<br>            references parent(c1)<br>)</p>\n<p>外键约束另外两种定义方法<br>create table child1<br>(c1 number(2) constraint child1_c1_pk<br>              primary key,<br> c2 number(3) constraint child1_c2_fk<br>              references parent(c1)<br>              on delete cascade)<br>on delete cascade :级联删除会影响到对parent table的删除,先delete from child1,再delete from<br>parent</p>\n<p>delete from parent where c1 = 1;<br>create table child2<br>(c1 number(2) constraint child2_c1_pk<br>              primary key,<br> c2 number(3) constraint child2_c2_fk<br>              references parent(c1)<br>              on delete set null)</p>\n<p>delete from parent where c1 = 1<br>等价于以下操作<br>SQL&gt; update child2 set c2 = null<br>  2  where c2 = 1;<br>SQL&gt; delete from parent where c1 = 1;</p>\n<p>table<br>DDL(数据类型 约束)<br>transaction (包含一堆DML)</p>\n<p>4000<br>100<br>1000<br>3100</p>\n<p>视图(view)<br>create table test_t1<br>as<br>select <em> from test<br>where c1 = 1;<br>create or replace view test_v1<br>as<br>select </em> from test<br>where c1 = 1;<br>desc test_v1<br>selelct * from test_v1</p>\n<p>insert into test values (1,3);<br>select <em> from test_v1 (1,3)<br>insert into test_v1 values (1,4)<br>select </em> from test_v1;<br>select <em> from test;<br>insert into test_v1 values (2,3);<br>select </em> from test_v1;(没有)<br>select * from test;(2,3)</p>\n<p>drop table test purge;<br>select * from test_v1;<br>SQL&gt; desc test_v1<br>ERROR:<br>ORA-24372: invalid object for describe<br>无法描述无效对象的结构</p>\n<p>SQL&gt; select text from user_views<br>  2  where view_name = ‘TEST_V1’;</p>\n<h2 id=\"TEXT\"><a href=\"#TEXT\" class=\"headerlink\" title=\"TEXT\"></a>TEXT</h2><p>select “C1”,”C2” from test<br>where c1 = 1</p>\n<p>view是一条select语句. select语句中包含的表为源表.通过view对源表做DML操作.</p>\n<p>view作用<br>1 create view (deptno = 30)<br>  grant view to user<br>  限定用户查询的数据 子集<br>2 简化查询语句<br>3 create view beijing<br>  as<br>  select <em> from haidian<br>  union all<br>  select </em> from xicheng<br>…<br>  超集<br>view的类型<br>1 简单view (DML)<br>2 复杂view  (不能DML)</p>\n<p>create or replace view avgscore_v<br>select s.name,a.avgscore<br>from student s,<br>     (select sid,round(avg(score)) avgscore<br>      from stu_cour<br>      group by sid) a<br>on s.id = a.sid</p>\n<p>view的约束<br>create or replace view test_ck<br>as<br>select * from test<br>where c1 = 1<br>with check option;<br>c1=2,违反where条件,2,3记录insert时报错</p>\n<p>create or replace view test_ro<br>as<br>select * from test<br>where c1 = 1<br>with read only;<br>只读视图</p>\n<h4 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h4><p>create index test_c1_idx<br>on test(c1);<br>对索引不能做desc,select,DML操作<br>rowid 代表一条记录的物理位置<br>属于哪个数据对象(table)<br>属于哪个数据文件的<br>属于数据文件的第几个数据块<br>属于数据块里的第几条记录</p>\n<h4 id=\"index的结构\"><a href=\"#index的结构\" class=\"headerlink\" title=\"index的结构\"></a>index的结构</h4><p>index记录rowid<br>index的结构是一棵平衡树,有三类数据块组成,根节点,分支节点,叶子节点,数据块的数据是排序的.根节点和分支节点用于导航,里面记录下一级节点的物理位置以及该节点包含的数据范围.叶子节点里记录的是index entry(索引项),由key值和rowid组成,key值是建索引的列在每条记录上的取值,rowid是记录的物理位置,所有的叶子节点做成双向链表(升序/降序),适用于范围查询.<br>用索引查询的路线图,从根节点出发,找相应的分支节点,叶子节点,最后要找到index entry,通过rowid定位<br>表里所需要的数据块,避免了全表扫描.</p>\n<p>索引为什么提高查询效率,为select语句<br>有效地降低了读取数据块的数量.读取数据块,一种从文件里读,物理读 physical read,一种从内存读,逻辑读 logical read /buffer gets</p>\n<p>建索引代价<br>空间,DML变慢</p>\n<h4 id=\"哪些列适合建索引\"><a href=\"#哪些列适合建索引\" class=\"headerlink\" title=\"哪些列适合建索引\"></a>哪些列适合建索引</h4><p>1 经常出现在where子句的列<br>2 pk/uk列<br>3 经常出现在表连接的列<br>4 fk列 parent.pk列 = child.fk列<br>5 经常用于group by,order by的列<br>7 where c1 is null(全表扫描),索引里不记null值,<br> 该列有大量null值,找not null值用索引会快</p>\n<h4 id=\"索引类型\"><a href=\"#索引类型\" class=\"headerlink\" title=\"索引类型\"></a>索引类型</h4><p>非唯一性索引,提高查询效率<br>唯一性索引,解决唯一性.等价建唯一性约束<br>create unique index test_c2_idx<br>on test(c2);</p>\n<p>insert into test (c2) values (1)<br>*<br>ERROR at line 1:<br>ORA-00001: unique constraint(HILOO.TEST_C2_IDX ) violated</p>\n<p>联合索引<br>create index test_c1_c2_idx<br>on test(c1,c2)<br>where c1 = 1 and c2 = 1</p>\n<p>select ename from emp_hiloo<br>where salary<em>12 &gt; 60000<br>where salary &gt; 5000<br>如果salary建索引,where salary &gt; 5000(用),where salary</em>12 &gt; 60000(不能用)</p>\n<p>where upper(ename) = ‘ZHANGWUJI’</p>\n<p>where c1 = 100 c1是varchar2类型<br>where to_number(c1) = 100</p>\n<p>where ename like ‘a%’<br>where substr(ename,1,1) = ‘a’</p>\n<p>deptno not in (20,30)<br>depotno in (10)</p>\n<h4 id=\"函数索引\"><a href=\"#函数索引\" class=\"headerlink\" title=\"函数索引\"></a>函数索引</h4><p>create index test_c1_funidx<br>on test(round(c1));<br>where round(c1) = 10</p>\n<p>create index student_name_idx<br>on student(name);</p>\n<h4 id=\"序列号\"><a href=\"#序列号\" class=\"headerlink\" title=\"序列号\"></a>序列号</h4><p>sequence<br>为table里的主键服务,产生主键值<br>唯一值产生器<br>sequence_name.nextval</p>\n<p>为student表的id建sequence<br>insert into student(student_id.nextval…<br>为course表的id建sequence<br>insert into course (course_id.nextval…</p>\n<p>创建序列如下：<br>create sequence SEQ_TEST100<br>minvalue 1<br>maxvalue 999999999999999999999999999<br>start with 11<br>increment by 1<br>cache 10;</p>\n<p>函数<br>create or replace function dept_avgsal<br>(p_deptno number) –定义参数,数据类型不能有宽度<br>return number    –定义函数的返回类型<br>is<br>  v_salary emp_hiloo.salary%type;     –变量v_salary 的类型跟表emp_hiloo里的salary的类型定义一致<br>begin<br>  select round(avg(salary)) into v_salary<br>  from emp_hiloo<br>  where deptno = p_deptno;    –select当且仅当返回一条记录用select into语法,表示把select语句的执行结果赋值给v_salary<br>  return v_salary;       –返回函数值<br>end;<br>.不运行,回到SQL&gt;下<br>/表示运行<br>show error<br>SQL&gt; select dept_avgsal(10) from dual;</p>\n<p>练习<br>用语法实现多对多关系<br>student<br>id pk<br>name not null</p>\n<p>course<br>id pk<br>name not null</p>\n<p>stu_cour<br>sid fk –&gt;student(id)<br>cid fk –&gt;course(id)<br>pk(sid,cid)<br>score check <a href=\"between and\">0,100</a> </p>\n<h4 id=\"数据库日期比较\"><a href=\"#数据库日期比较\" class=\"headerlink\" title=\"数据库日期比较\"></a>数据库日期比较</h4><p>Sql代码：<br>1    timesten内存数据库比较日期是不是同一天,低效的方法<br>2    to_char(create_date,’yyyymmdd’)=to_char(sysdate NUMTODSINTERVAL(60<em>60</em>24,’SECOND’),’yyyymmdd’)<br>3    oracle 数据库低效的方法<br>4    to_char(create_date,’yyyymmdd’)=to_char(sysdate-1,’yyyymmdd’)<br>5    2个数据库通用高效的方法<br>6    trunc(create_date)=trunc(sysdate)-NUMTODSINTERVAL(1,’DAY’)<br>查找数据库里的表，索引等<br>支持oracle的模糊查询如select * from user_tables where table_name like ‘%_PROJECT’;查表名以PROJECT结尾的表（注：区别大小写）<br>查所有用户的表在all_tables<br>主键名称、外键在all_constraints<br>索引在all_indexes<br>但主键也会成为索引，所以主键也会在all_indexes里面。<br>具体需要的字段可以DESC下这几个view，dba登陆的话可以把all换成dba。</p>\n<p>查询用户表的索引(非聚集索引):<br>select * from user_indexes<br>where uniqueness = ‘NONUNIQUE’</p>\n<p>查询用户表的主键(聚集索引):<br>select * from user_indexes<br>where uniqueness = ‘UNIQUE’</p>\n<p>1、    查找表的所有索引（包括索引名，类型，构成列）：<br>select t.<em>,i.index_type from user_ind_columns t,user_indexes i where t.index_name = i.index_name and t.table_name = i.table_name and t.table_name = 要查询的表<br>2、查找表的主键（包括名称，构成列）：<br>select cu.</em> from user_cons_columns cu, user_constraints au where cu.constraint_name = au.constraint_name and au.constraint_type = ‘P’ and au.table_name = 要查询的表<br>3、查找表的唯一性约束（包括名称，构成列）：<br>select column_name from user_cons_columns cu, user_constraints au where cu.constraint_name = au.constraint_name and au.constraint_type = ‘U’ and au.table_name = 要查询的表<br>4、查找表的外键（包括名称，引用表的表名和对应的键名，下面是分成多步查询）：<br>select <em> from user_constraints c where c.constraint_type = ‘R’ and c.table_name = 要查询的表<br>查询外键约束的列名：<br>select </em> from user_cons_columns cl where cl.constraint_name = 外键名称<br>查询引用表的键的列名：<br>select <em> from user_cons_columns cl where cl.constraint_name = 外键引用表的键名<br>5、查询表的所有列及其属性<br>select t.</em>,c.COMMENTS from user_tab_columns t,user_col_comments c where t.table_name = c.table_name and t.column_name = c.column_name and t.table_name = 要查询的表</p>\n<p>####数据唯一Id：####</p>\n<ol>\n<li>用Oracle来生成UUID，做法很简单，如下：select sys_guid() from dual;数据类型是 raw(16) 有32个字符。<br>create table test_guid3(<br>id varchar(50)<br>)<br>select * from test_guid3;<br>insert into test_guid3(id) values(sys_guid())</li>\n</ol>\n<hr>\n<pre><code>1000 7CD5B7769DF75CEFE034080020825436\n1100 7CD5B7769DF85CEFE034080020825436\n1200 7CD5B7769DF95CEFE034080020825436\n1300 7CD5B7769DFA5CEFE034080020825436\n</code></pre><h3 id=\"名词\"><a href=\"#名词\" class=\"headerlink\" title=\"名词\"></a>名词</h3><h4 id=\"Oracle的方案（Schema）和用户（User）的区别\"><a href=\"#Oracle的方案（Schema）和用户（User）的区别\" class=\"headerlink\" title=\"Oracle的方案（Schema）和用户（User）的区别\"></a>Oracle的方案（Schema）和用户（User）的区别</h4><p>从定义中我们可以看出方案（Schema）为数据库对象的集合，为了区分各个集合，我们需要给这个集合起个名字，这些名字就是我们在企业管理器的方案下看到的许多类似用户名的节点，这些类似用户名的节点其实就是一个schema，schema里面包含了各种对象如tables, views, sequences, stored procedures, synonyms, indexes, clusters, and database links。</p>\n<p>   一个用户一般对应一个schema,该用户的schema名等于用户名，并作为该用户缺省schema。这也就是我们在企业管理器的方案下看到schema名都为数据库用户名的原因。Oracle数据库中不能新创建一个schema，要想创建一个schema，只能通过创建一个用户的方法解决(Oracle中虽然有create schema语句，但是它并不是用来创建一个schema的)，在创建一个用户的同时为这个用户创建一个与用户名同名的schem并作为该用户的缺省shcema。即schema的个数同user的个数相同，而且schema名字同user名字一一对应并且相同，所有我们可以称schema为user的别名，虽然这样说并不准确，但是更容易理解一些。</p>\n<p>   一个用户有一个缺省的schema，其schema名就等于用户名，当然一个用户还可以使用其他的schema。如果我们访问一个表时，没有指明该表属于哪一个schema中的，系统就会自动给我们在表上加上缺省的sheman名。比如我们在访问数据库时，访问scott用户下的emp表，通过select <em> from emp; 其实，这sql语句的完整写法为select </em> from scott.emp。在数据库中一个对象的完整名称为schema.object，而不属user.object。类似如果我们在创建对象时不指定该对象的schema，在该对象的schema为用户的缺省schema。这就像一个用户有一个缺省的表空间，但是该用户还可以使用其他的表空间，如果我们在创建对象时不指定表空间，则对象存储在缺省表空间中，要想让对象存储在其他表空间中，我们需要在创建对象时指定该对象的表空间。</p>\n<p>   oracle中的schema就是指一个用户下所有对象的集合，schema本身不能理解成一个对象，oracle并没有提供创建schema的语法，schema也并不是在创建user时就创建，而是在该用户下创建第一个对象之后schema也随之产生，只要user下存在对象，schema就一定存在，user下如果不存在对象，schema也不存在；这一点类似于temp tablespace group，另外也可以通过oem来观察，如果创建一个新用户，该用户下如果没有对象则schema不存在，如果创建一个对象则和用户同名的schema也随之产生。</p>\n<p>####Oracle中User与Schema的简单理解####<br>技术积累（126）<br>版权声明：本文为博主原创文章，未经博主允许不得转载。<br>方案（Schema）为数据库对象的集合，为了区分各个集合，我们需要给这个集合起个名字，这些名字就是我们在企业管理器的方案下看到的许多类似用户名的节点，这些类似用户名的节点其实就是一个schema，schema里面包含了各种对象如tables, views, sequences, stored procedures, synonyms, indexes, clusters, and database links。  一个用户一般对应一个schema,该用户的schema名等于用户名，并作为该用户缺省schema。<br>SQL Server中的Schema<br>SQL Server中一个用户有一个缺省的schema，其schema名就等于用户名，这也就是我们在企业管理器的方案下看到schema名都为数据库用户名的原因。当然一个用户还可以使用其他的schema。如果我们访问一个表时，没有指明该表属于哪一个schema中的，系统就会自动给我们在表上加上缺省的sheman名。比如我们在访问数据库时，访问scott用户下的emp表，通过select <em> from emp; 其实，这sql语句的完整写法为select </em> from scott.emp。在数据库中一个对象的完整名称为schema.object，而不属user.object。类似如果我们在创建对象时不指定该对象的schema，在该对象的schema为用户的缺省schema。这就像一个用户有一个缺省的表空间，但是该用户还可以使用其他的表空间，如果我们在创建对象时不指定表空间，则对象存储在缺省表空间中，要想让对象存储在其他表空间中，我们需要在创建对象时指定该对象的表空间。</p>\n<p>Oracle中的Schema<br>Oracle中的schema就是指一个用户下所有对象的集合，schema本身不能理解成一个对象，oracle并没有提供创建schema的语法，schema也并不是在创建user时就创建，而是在该用户下创建第一个对象之后schema也随之产生，只要user下存在对象，schema就一定存在，user下如果不存在对象，schema也不存在；如果创建一个新用户，该用户下如果没有对象则schema不存在，如果创建一个对象则和用户同名的schema也随之产生。实际上在使用上，shcema与user完全一样，没有什么区别，在出现schema名的地方也可以出现user名。</p>\n<p>Tablspace<br>逻辑上用来放objects,，这是个逻辑概念，本质上是一个或者多个数据文件的集合，物理上对应磁盘上的数据文件或者裸设备。</p>\n<p>数据文件<br>具体存储数据的物理文件，是一个物理概念。一个数据文件只能属于一个表空间，一个表空间可以包含一个或多个数据文件。一个数据库由多个表空间组成，一个表空间只能属于一个数据库。</p>\n<p>下边是源自网络的一个形象的比喻<br>我们可以把Database看作是一个大仓库，仓库分了很多很多的房间，Schema就是其中的房间，一个Schema代表一个房间，Table可以看作是每个Schema中的床，Table（床）被放入每个房间中，不能放置在房间之外，那岂不是晚上睡觉无家可归了，然后床上可以放置很多物品，就好比 Table上可以放置很多列和行一样，数据库中存储数据的基本单元是Table，现实中每个仓库放置物品的基本单位就是床， User就是每个Schema的主人，（所以Schema包含的是Object，而不是User），user和schema是一一对应的，每个user在没有特别指定下只能使用自己schema（房间）的东西，如果一个user想使用其他schema（房间）的东西，那就要看那个schema（房间）的user（主人）有没有给你这个权限了，或者看这个仓库的老大（DBA）有没有给你这个权限了。换句话说，如果你是某个仓库的主人，那么这个仓库的使用权和仓库中的所有东西都是你的（包括房间），你有完全的操作权，可以扔掉不用的东西从每个房间，也可以放置一些有用的东西到某一个房间，你还可以给每个User分配具体的权限，也就是他到某一个房间能做些什么，是只能看（Read-Only），还是可以像主人一样有所有的控制权（R/W），这个就要看这个User所对应的角色Role了。</p>\n<h4 id=\"oracle的schema的含义\"><a href=\"#oracle的schema的含义\" class=\"headerlink\" title=\"oracle的schema的含义\"></a>oracle的schema的含义</h4><p>在现在做的Kraft Catalyst 项目中，Cransoft其中有一个功能就是schema refresh. 一直不理解schema什么意思，也曾经和同事讨论过，当时同事就给我举过一个例子，下面会详细说的。其实schema是Oracle中的，其他数据库中不知道有没有这个概念。<br>首先,可以先看一下schema和user的定义：<br>A schema is a collection of database objects (used by a user).<br>Schema objects are the logical structures that directly refer to the database’s data.<br>A user is a name defined in the database that can connect to and access objects.<br>Schemas and users help database administrators manage database security.<br>从中我们可以看出,schema为数据库对象的集合，为了区分各个集合，需要给这个集合起个名字，这些名字就是在企业管理器的方案下看到的许多类似用户名的节点，这些类似用户名的节点其实就是一个schema。<br>schema里面包含了各种对象如tables, views, sequences, stored procedures, synonyms, indexes, clusters, and database links。<br>一个用户一般对应一个schema，该用户的schema名等于用户名，并作为该用户缺省schema。这也就是在企业管理器的方案下看到schema名都为数据库用户名的原因。<br>Oracle数据库中不能新创建一个schema，要想创建一个schema，只能通过创建一个用户的方法解决(Oracle中虽然有create schema语句，但是它并不是用来创建一个schema的)。在创建一个用户的同时，为这个用户创建一个与用户名同名的schem并作为该用户的缺省 shcema。即schema的个数同user的个数相同，而且schema名字同user名字一一 对应并且相同，所有我们可以称schema为user的别名，虽然这样说并不准确，但是更容易理解一些。<br>一个用户有一个缺省的schema，其schema名就等于用户名，当然一个用户还可以使用其他的schema。如果我们访问一个表时，没有指明该表属于 哪一个schema中的，系统就会自动给我们在表上加上缺省的sheman名。比如我们在访问数据库时，访问scott用户下的emp表，通过 select <em> from emp; 其实，这sql语句的完整写法为select </em> from scott.emp。在数据库中一个对象的完整名称为schema.object，而不属user.object。类似如果我们在创建对象时不指定该对象 的schema，在该对象的schema为用户的缺省schema。这就像一个用户有一个缺省的表空间，但是该用户还可以使用其他的表空间，如果我们在创 建对象时不指定表空间，则对象存储在缺省表空间中，要想让对象存储在其他表空间中，需要在创建对象时指定该对象的表空间。<br>有人举了个很生动的例子，来说明Database、User、Schema、Tables、Col、Row等之间的关系<br>“可以把Database看作是一个大仓库，仓库分了很多很多的房间，Schema就是其中的房间，一个Schema代表一个房间，Table可以看作是每个Schema中的床，Table（床）就被放入每个房间中，不能放置在房间之外，那岂不是晚上睡觉无家可归了。<br>然后床上可以放置很多物品，就好比Table上可以放置很多列和行一样，数据库中存储数据的基本单元是Table，现实中每个仓库放置物品的基本单位就是床， User就是每个Schema的主人（所以Schema包含的是Object，而不是User）。<br>其实User是对应与数据库的（即User是每个对应数据库的主人），既然有操作数据库（仓库）的权利，就肯定有操作数据库中每个Schema（房间）的 权利，就是说每个数据库映射的User有每个Schema（房间）的钥匙，换句话说，如果他是某个仓库的主人，那么这个仓库的使用权和仓库中的所有东西都 是他的（包括房间），他有完全的操作权，可以扔掉不用的东西从每个房间，也可以放置一些有用的东西到某一个房间。还可以给User分配具体的权限，也就是 他到某一个房间能做些什么，是只能看（Read-Only），还是可以像主人一样有所有的控制权（R/W），这个就要看这个User所对应的角色Role 了”<br>从定义中我们可以看出schema为数据库对象的集合，为了区分各个集合，我们需要给这个集合起个名字，这些名字就是我们在企业管理器的方案下看到的许多类似用户名的节点，这些类似用户名的节点其实就是一个schema，schema里面包含了各种对象如tables, views, sequences, stored procedures, synonyms, indexes, clusters, and database links。<br>一个用户一般对应一个schema,该用户的schema名等于用户名，并作为该用户缺省schema。这也就是我们在企业管理器的方案下看到schema名都为数据库用户名的原因。Oracle数据库中不能新创建一个schema，要想创建一个schema，只能通过创建一个用户的方法解决(Oracle中虽然有create schema语句，但是它并不是用来创建一个schema的)，在创建一个用户的同时为这个用户创建一个与用户名同名的schem并作为该用户的缺省shcema。即schema的个数同user的个数相同，而且schema名字同user名字一一 对应并且相同，所有我们可以称schema为user的别名，虽然这样说并不准确，但是更容易理解一些。<br>一个用户有一个缺省的schema，其schema名就等于用户名，当然一个用户还可以使用其他的schema。如果我们访问一个表时，没有指明该表属于哪一个schema中的，系统就会自动给我们在表上加上缺省的sheman名。比如我们在访问数据库时，访问scott用户下的emp表，通过select <em> from emp; 其实，这sql语句的完整写法为select </em> from scott.emp。在数据库中一个对象的完整名称为schema.object，而不属user.object。类似如果我们在创建对象时不指定该对象的schema，在该对象的schema为用户的缺省schema。这就像一个用户有一个缺省的表空间，但是该用户还可以使用其他的表空间，如果我们在创建对象时不指定表空间，则对象存储在缺省表空间中，要想让对象存储在其他表空间中，我们需要在创建对象时指定该对象的表空间。<br>咳，说了这么多，给大家举个例子，否则，一切枯燥无味！<br>SQL&gt; Gruant dba to scott<br>SQL&gt; create table test(name char(10));<br>Table created.<br>SQL&gt; create table system.test(name char(10));<br>Table created.<br>SQL&gt; insert into test values(‘scott’);<br>1 row created.<br>SQL&gt; insert into system.test values(‘system’);<br>1 row created.<br>SQL&gt; commit;<br>Commit complete.<br>SQL&gt; conn system/manager<br>Connected.<br>SQL&gt; select * from test;</p>\n<h2 id=\"NAME\"><a href=\"#NAME\" class=\"headerlink\" title=\"NAME\"></a>NAME</h2><p>system<br>SQL&gt; ALTER SESSION SET CURRENT_SCHEMA = scott; –改变用户缺省schema名<br>Session altered.<br>SQL&gt; select * from test;</p>\n<h2 id=\"NAME-1\"><a href=\"#NAME-1\" class=\"headerlink\" title=\"NAME\"></a>NAME</h2><p>scott<br>SQL&gt; select owner ,table_name from dba_tables where table_name=upper(‘test’);<br>OWNER TABLE_NAME</p>\n<hr>\n<p>SCOTT TEST<br>SYSTEM TEST<br>–上面这个查询就是我说将schema作为user的别名的依据。实际上在使用上，shcema与user完全一样，没有什么区别，在出现schema名的地方也可以出现user名。<br>表空间：<br>一个表空间就是一片磁盘区域,他又一个或者多个磁盘文件组成,一个表空间可以容纳许多表、索引或者簇等<br>  每个表空间又一个预制的打一磁盘区域称为初始区间（initial   extent）用完这个区间厚在用下一个，知道用完表空间，这时候需要对表空间进行扩展，增加数据文件或者扩大已经存在的数据文件</p>\n<p>instance是一大坨内存sga,pga….和后台的进程smon pmon…..组成的一个大的应用。<br>schema就是一个用户和他下面的所有对象。。<br>tablspace 逻辑上用来放objects.物理上对应磁盘上的数据文件或者裸设备。<br> 在Oracle中，结合逻辑存储与物理存储的概念，我们可以这样来理解数据库、表空间、SCHEMA、数据文件这些概念：<br>      数据库是一个大圈，里面圈着的是表空间，表空间里面是数据文件，那么schema是什么呢？schema是一个逻辑概念，是一个集合，但schema并不是一个对象，oracle也并没有提供创建schema的语法。<br>schema：<br>      一般而言，一个用户就对应一个schema,该用户的schema名等于用户名，并作为该用户缺省schema，用户是不能创建schema的，schema在创建用户的时候创建，并可以指定用户的各种表空间（这点与PostgreSQL是不同，PostgreSQL是可以创建schema并指派给某个用户）。当前连接到数据库上的用户创建的所有数据库对象默认都属于这个schema（即在不指明schema的情况下），比如若用户scott连接到数据库，然后create table test(id int not null)创建表，那么这个表被创建在了scott这个schema中；但若这样create kanon.table test(id int not null)的话，这个表被创建在了kanon这个schema中，当然前提是权限允许。<br>      创建用户的方法是这样的：<br>      create user 用户名 identified by 密码<br>      default tablespace 表空间名<br>      temporary tablespace 表空间名<br>      quota 限额  （建议创建的时候指明表空间名）<br>由此来看，schema是一个逻辑概念。<br>      但一定要注意一点：schema好像并不是在创建user时就创建的，而是在该用户创建了第一个对象之后才将schema真正创建的，只有user下存在对象，他对应的schema才会存在，如果user下不存在任何对象了，schema也就不存在了；</p>\n<p>数据库：<br>     在oracle中，数据库是由表空间来组成的，而表空间里面是具体的物理文件—数据文件。我们可以创建数据库并为其指定各种表空间。</p>\n<p>表空间：<br>     这是个逻辑概念，本质上是一个或者多个数据文件的集合。</p>\n<p>数据文件：<br>     具体存储数据的物理文件，是一个物理概念。<br>     一个数据文件只能属于一个表空间，一个表空间可以包含一个或多个数据文件。一个数据库由多个表空间组成，一个表空间只能属于一个数据库。</p>\n"},{"title":"Findbug代码审查-缺陷和修改","date":"2017-05-30T08:43:49.000Z","_content":"\n# FindBugs使用实践-缺陷和修改\nConfidence 是fingbug团队认为该代码导致bug的可能性。\n\n## 分类\n1 Malicious code vulnerability 恶意代码\n2 Performance 性能问题\n3 Security 安全性问题\n4 Dodgy code 小问题\n5 Correctness 代码的正确性\n6 Bad practice 不好的习惯\n7 Internationalization 国际化问题\n8 Experrimental 实验性问题\n无     Multithreaded currectness 线程问题\n\n## 常见问题\n#### 1 Bad practice 坏的实践\n一些不好的实践，下面列举几个： HE：类定义了equals()，却没有hashCode()；或类定义了equals()，却使用Object.hashCode()；或类定义了hashCode()，却没有equals()；或类定义了hashCode()，却使用Object.equals()；类继承了equals()，却使用Object.hashCode()。 \nSQL：Statement 的execute方法调用了非常量的字符串；或Prepared Statement是由一个非常量的字符串产生。 \nDE：方法终止或不处理异常，一般情况下，异常应该被处理或报告，或被方法抛出。 \nMalicious code vulnerability 可能受到的恶意攻击\n如果代码公开，可能受到恶意攻击的代码，下面列举几个： FI：一个类的finalize()应该是protected，而不是public的。MS：属性是可变的数组；属性是可变的Hashtable；属性应该是package protected的。\n#### 2 Correctness 一般的正确性问题\n可能导致错误的代码，下面列举几个： NP：空指针被引用；在方法的异常路径里，空指针被引用；方法没有检查参数是否null；null值产生并被引用；null值产生并在方法的异常路径被引用；传给方法一个声明为@NonNull的null参数；方法的返回值声明为@NonNull实际是null。 Nm：类定义了hashcode()方法，但实际上并未覆盖父类Object的hashCode()；类定义了tostring()方法，但实际上并未覆盖父类Object的toString()；很明显的方法和构造器混淆；方法名容易混淆。 SQL：方法尝试访问一个Prepared Statement的0索引；方法尝试访问一个ResultSet的0索引。 UwF：所有的write都把属性置成null，这样所有的读取都是null，这样这个属性是否有必要存在；或属性从没有被write。\n#### 3 Dodgy 危险的\n具有潜在危险的代码，可能运行期产生错误，下面列举几个： CI：类声明为final但声明了protected的属性。 DLS：对一个本地变量赋值，但却没有读取该本地变量；本地变量赋值成null，却没有读取该本地变量。 ICAST：整型数字相乘结果转化为长整型数字，应该将整型先转化为长整型数字再相乘。 INT：没必要的整型数字比较，如X <= Integer.MAX_VALUE。 NP：对readline()的直接引用，而没有判断是否null；对方法调用的直接引用，而方法可能返回null。 REC：直接捕获Exception，而实际上可能是RuntimeException。 ST：从实例方法里直接修改类变量，即static属性。\n#### 4 Performance 性能问题\n可能导致性能不佳的代码，下面列举几个： DM：方法调用了低效的Boolean的构造器，而应该用Boolean.valueOf(…)；用类似Integer.toString(1) 代替new Integer(1).toString()；方法调用了低效的float的构造器，应该用静态的valueOf方法。 SIC：如果一个内部类想在更广泛的地方被引用，它应该声明为static。 SS：如果一个实例属性不被读取，考虑声明为static。 UrF：如果一个属性从没有被read，考虑从类中去掉。 UuF：如果一个属性从没有被使用，考虑从类中去掉。\n#### 5 Multithreaded correctness 多线程的正确性多线程编程时，可能导致错误的代码，下面列举几个：\nESync：空的同步块，很难被正确使用。 MWN：错误使用notify()，可能导致IllegalMonitorStateException异常；或错误的使用wait()。 No：使用notify()而不是notifyAll()，只是唤醒一个线程而不是所有等待的线程。 SC：构造器调用了Thread.start()，当该类被继承可能会导致错误。\n#### 6 Internationalization 国际化当对字符串使用upper或lowercase方法，如果是国际的字符串，可能会不恰当的转换。\n\nAPI： http://findbugs.sourceforge.net/api/index.html\n技术手册： http://findbugs.sourceforge.net/manual/index.html\n更多请参见官网： http://findbugs.sourceforge.net/bugDescriptions.html\n##### 6.1、       ES_COMPARING_PARAMETER_STRING_WITH_EQ\n     ES: Comparison of String parameter using == or != (ES_COMPARING_PARAMETER_STRING_WITH_EQ)\nThis code compares a java.lang.String parameter for reference equality using the == or != operators. Requiring callers to pass only String constants or interned strings to a method is unnecessarily fragile, and rarely leads to measurable performance gains. Consider using the equals(Object) method instead.\n     使用 == 或者 != 来比较字符串或interned字符串，不会获得显著的性能提升，同时并不可靠，请考虑使用equals()方法。\n##### 6.2、       HE_EQUALS_NO_HASHCODE\n     HE: Class defines equals() but not hashCode() (HE_EQUALS_NO_HASHCODE)\nThis class overrides equals(Object), but does not override hashCode().  Therefore, the class may violate the invariant that equal objects must have equal hashcodes.\n     类定义了equals()方法但没有重写hashCode()方法，这样违背了相同对象必须具有相同的hashcodes的原则\n##### 6.3、IT_NO_SUCH_ELEMENT\n     It: Iterator next() method can't throw NoSuchElement exception (IT_NO_SUCH_ELEMENT)\nThis class implements the java.util.Iterator interface.  However, its next() method is not capable of throwing java.util.NoSuchElementException.  The next() method should be changed so it throws NoSuchElementException if is called when there are no more elements to return.\n     迭代器Iterator无法抛出NoSuchElement异常，类实现了java.util.Iterator接口，但是next()方法无法抛出java.util.NoSuchElementException异常，因此，next()方法应该做如此修改，当被调用时，如果没有element返回，则抛出NoSuchElementException异常\n##### 6.4、J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION\n     J2EE: Store of non serializable object into HttpSession (J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION)\nThis code seems to be storing a non-serializable object into an HttpSession. If this session is passivated or migrated, an error will result.\n     将没有实现serializable的对象放到HttpSession中，当这个session被钝化和迁移时，将会产生错误，建议放到HttpSession中的对象都实现serializable接口。\n##### 6.5、ODR_OPEN_DATABASE_RESOURCE\n     ODR: Method may fail to close database resource (ODR_OPEN_DATABASE_RESOURCE)\nThe method creates a database resource (such as a database connection or row set), does not assign it to any fields, pass it to other methods, or return it, and does not appear to close the object on all paths out of the method.  Failure to close database resources on all paths out of a method may result in poor performance, and could cause the application to have problems communicating with the database.\n     方法可能未关闭数据库资源，未关闭数据库资源将会导致性能变差，还可能引起应用与服务器间的通讯问题。\n##### 6.6、OS_OPEN_STREAM\n     OS: Method may fail to close stream (OS_OPEN_STREAM)\nThe method creates an IO stream object, does not assign it to any fields, pass it to other methods that might close it, or return it, and does not appear to close the stream on all paths out of the method.  This may result in a file descriptor leak.  It is generally a good idea to use a finally block to ensure that streams are closed.\n     方法可能未关闭stream，方法产生了一个IO流，却未关闭，将会导致文件描绘符的泄漏，建议使用finally block来确保io stream被关闭。\n##### 6.7、       DMI_CALLING_NEXT_FROM_HASNEXT\n     DMI: hasNext method invokes next (DMI_CALLING_NEXT_FROM_HASNEXT)\nThe hasNext() method invokes the next() method. This is almost certainly wrong, since the hasNext() method is not supposed to change the state of the iterator, and the next method is supposed to change the state of the iterator.\n##### 6.8、       IL_INFINITE_LOOP\n     IL: An apparent infinite loop (IL_INFINITE_LOOP)\nThis loop doesn't seem to have a way to terminate (other than by perhaps throwing an exception).\n     明显的无限循环.\n##### 6.9、       IL_INFINITE_RECURSIVE_LOOP\n     IL: An apparent infinite recursive loop (IL_INFINITE_RECURSIVE_LOOP)\nThis method unconditionally invokes itself. This would seem to indicate an infinite recursive loop that will result in a stack overflow.\n     明显的无限迭代循环,将导致堆栈溢出.\n##### 6.10、   WMI_WRONG_MAP_ITERATOR\n     WMI: Inefficient use of keySet iterator instead of entrySet iterator (WMI_WRONG_MAP_ITERATOR)\nThis method accesses the value of a Map entry, using a key that was retrieved from a keySet iterator. It is more efficient to use an iterator on the entrySet of the map, to avoid the Map.get(key) lookup.\n     使用了keySet iterator和Map.get(key)来获取Map值,这种方式效率低,建议使用entrySet的iterator效率更高.\n##### 6.11、   IM_BAD_CHECK_FOR_ODD\n     IM: Check for oddness that won't work for negative numbers (IM_BAD_CHECK_FOR_ODD)\nThe code uses x % 2 == 1 to check to see if a value is odd, but this won't work for negative numbers (e.g., (-5) % 2 == -1). If this code is intending to check for oddness, consider using x & 1 == 1, or x % 2 != 0.\n     奇偶检测逻辑,未考虑负数情况.\n#### 7.实际项目中Bug类型统计\n##### 7.1、       Call to equals() comparing different types\nid : EC_UNRELATED_TYPES, type : EC, category : CORRECTNESS This method calls equals(Object) on two references of different class types with no common subclasses. Therefore, the objects being compared are unlikely to be members of the same class at runtime (unless some application classes were not analyzed, or dynamic class loading can occur at runtime). According to the contract of equals(), objects of different classes should always compare as unequal; therefore, according to the contract defined by java.lang.Object.equals(Object), the result of this comparison will always be false at runtime.\n原因分析：\n这缺陷的意思是，大部分都是类型永远不会有这种情况， 比如a为DOUBLE类型所以EQUALS只匹配字符串 if(a.equals())或if(a.quals())这类判断是根本不会有用的；\n示例：if(\"1\".equals(DAOValue.valueofSuccess()))\n##### 7.2、       Dead store to local variable \nid: DLS_DEAD_LOCAL_STORE, type: DLS, category: STYLE\nThis instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used.\nNote that Sun's javac compiler often generates dead stores for final local variables. Because FindBugs is a bytecode-based tool, there is no easy way to eliminate these false positives.\n原因分析：\nDLS问题指的是给本地变量赋了一个值，但随后的代码并没有用到这个值。\n##### 7.3、       Method call passes null for nonnull parameter\nid: NP_NULL_PARAM_DEREF, type: NP, category: CORRECTNESS\nThis method call passes a null value for a nonnull method parameter. Either the parameter is annotated as a parameter that should always be nonnull, or analysis has shown that it will always be dereferenced.\n原因分析：对参数为null的情况未作处理。\n例如：\n\n```public void method1() {\n    String ip = null;\n    try {\n        ip = InetAddress.getLocalHost().getHostAddress();\n    } catch (UnknownHostException e) {\n        e.printStackTrace();\n    }\n    long ipCount = countIpAddress(ip);//可能会传入空引用 \n    //....\n}\n\nlong countIpAddress(String ip) {\n    long ipNum = 0;\n    String[] ipArray = ip.split(\"\\\\.\");\n}\n```\n\n```public void method1() {\n        String ip = null;\n        try {\n            ip = InetAddress.getLocalHost().getHostAddress();\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        }\n        long ipCount = countIpAddress(ip);//可能会传入空引用\n        //....\n    }\n\n    long countIpAddress(String ip) {\n        long ipNum = 0;\n        if(ip==null){\n            return 0;//抛出异常\n        }\n        String[] ipArray = ip.split(\"\\\\.\");\n    }\n```\n对于接口需要对参数校验合法性\n\n##### 7.4、Method with Boolean return type returns explicit null  \nid: NP_BOOLEAN_RETURN_NULL, type: NP, category: BAD_PRACTICE\nA method that returns either Boolean.TRUE, Boolean.FALSE or null is an accident waiting to happen. This method can be invoked as though it returned a value of type boolean, and the compiler will insert automatic unboxing of the Boolean value. If a null value is returned, this will result in a NullPointerException.\n原因分析：\n方法如果定义为返回类型Boolean，则可以返回Boolean.TRUE, Boolean.FALSE or null （如果 return 的是 true or  false， 则AutoBoxing 成 Boolean.TRUE, Boolean.FALSE）。因为JDK 支持 基本类型和装箱类型的自动转化， 所以下面的代码中：\nboolean result = test_NP_BOOLEAN_RETURN_NULL();\n因为此时test_NP_BOOLEAN_RETURN_NULL() 返回的是NULL， 所以 JDK 做 automatic unboxing 的操作时， 即调用了 object. booleanValue() 方法时，抛出了空指针。\n改成：boolean result = test_NP_BOOLEAN_RETURN_NULL()==null?false:true;\n##### 7.5、       No relationship between generic parameter and method argument\nid: GC_UNRELATED_TYPES, type: GC, category: CORRECTNESS\nThis call to a generic collection method contains an argument with an incompatible class from that of the collection's parameter (i.e., the type of the argument is neither a supertype nor a subtype of the corresponding generic type argument). Therefore, it is unlikely that the collection contains any objects that are equal to the method argument used here. Most likely, the wrong value is being passed to the method.\nIn general, instances of two unrelated classes are not equal. For example, if the Foo and Bar classes are not related by subtyping, then an instance of Foo should not be equal to an instance of Bar. Among other issues, doing so will likely result in an equals method that is not symmetrical. For example, if you define the Foo class so that a Foo can be equal to a String, your equals method isn't symmetrical since a String can only be equal to a String.\nIn rare cases, people do define nonsymmetrical equals methods and still manage to make their code work. Although none of the APIs document or guarantee it, it is typically the case that if you check if a Collection<String> contains a Foo, the equals method of argument (e.g., the equals method of the Foo class) used to perform the equality checks.\n原因分析：调用Collection类中的contains方法比较时，所比较的两个参数类型不致；\n\n##### 7.6、       Null pointer dereference in method on exception path\nid: NP_ALWAYS_NULL_EXCEPTION, type: NP, category: CORRECTNESS\nA pointer which is null on an exception path is dereferenced here.  This will lead to a NullPointerException when the code is executed.  Note that because FindBugs currently does not prune infeasible exception paths, this may be a false warning.\nAlso note that FindBugs considers the default case of a switch statement to be an exception path, since the default case is often infeasible.\n原因分析：在异常处理时，调用一个空对象的方法时可能引起空指针异常。\n##### 7.7、       Nullcheck of value previously dereferenced\nid: RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE, type:RCN, category: CORRECTNESS\nA value is checked here to see whether it is null, but this value can't be null because it was previously dereferenced and if it were null a null pointer exception would have occurred at the earlier dereference. Essentially, this code and the previous dereference disagree as to whether this value is allowed to be null. Either the check is redundant or the previous dereference is erroneous.\n原因分析：前面获取的对象，现在引用的时候没有交验是否为null。\n\n##### 7.8、       Possible null pointer dereference\nid: NP_NULL_ON_SOME_PATH, type: NP, category: CORRECTNESS\nThere is a branch of statement that, if executed, guarantees that a null value will be dereferenced, which would generate a NullPointerException when the code is executed. Of course, the problem might be that the branch or statement is infeasible and that the null pointer exception can't ever be executed; deciding that is beyond the ability of FindBugs.\n原因分析：可能存在空引用。\n \n##### 7.9、       Possible null pointer dereference in method on exception path\nid: NP_NULL_ON_SOME_PATH_EXCEPTION, type: NP, category:CORRECTNESS\nA reference value which is null on some exception control path is dereferenced here.  This may lead to a NullPointerException when the code is executed.  Note that because FindBugs currently does not prune infeasible exception paths, this may be a false warning.\nAlso note that FindBugs considers the default case of a switch statement to be an exception path, since the default case is often infeasible.\n原因分析：\n代码调用时， 遇到异常分支， 可能造成一个对象没有获得赋值依旧保持NULL空指针。 接下来如果对这个对象有引用， 可能造成NullPointerException 空指针异常。\n例如：\n\n##### 7.10、   Test for floating point equality\nid: FE_FLOATING_POINT_EQUALITY, type: FE, category: STYLE\nThis operation compares two floating point values for equality. Because floating point calculations may involve rounding, calculated float and double values may not be accurate. For values that must be precise, such as monetary values, consider using a fixed-precision type such as BigDecimal. For values that need not be precise, consider comparing for equality within some range, for example: if ( Math.abs(x - y) < .0000001 ). See the java Language Specification, section 4.2.4.\n原因分析：\nFloat类型的数据比较时，会存在的定的误差值，用!=来比较不是很准确，建议比较两个数的绝对值是否在一定的范围内来进行比较。如，if ( Math.abs(x - y) < .0000001 )\n例如：\n \n```  if(kpje.doubleValue()!=Doble.valueOf(coreCrdeInfo.getOrderpayInfo().getyeje（）)){\n        return ResultVo.valueOfError(\"订单编号\");\n    }\n\n```\n##### 7.11、   Useless assignment in return statement\nid: DLS_DEAD_LOCAL_STORE_IN_RETURN, type: DLS, category: STYLE\nThis statement assigns to a local variable in a return statement. This assignment has effect. Please verify that this statement does the right thing.\n原因分析：\n在return的对象中，没有必要通过对象赋值再进行返回。\n例如：\n\n``` DAOValue daoValue = DAOValue.valueof(false,-1,\"批量删除联系人业务大类信息失败\");\n    if(lxrCpdlVoList.size()==0){\n        return daoValue = DAOValue.valueof(true,1,\"没有批量删除联系人业务大类信息失败\");\n    }\n```\n##### 7.12、   Write to static field from instance method\nid: ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD, type: ST, category:STYLE\nThis instance method writes to a static field. This is tricky to get correct if multiple instances are being manipulated, and generally bad practice.\n原因分析：向static字段中写入值。\n例如： \n``` private static DBRBO dbrBO; \n public final void refresh() { \n        danskeBankBO = null; \n        dbrBO = null; \n        fileAndPathBO = null; \n    }\n``` \n建议改为：去掉static。\n##### 7.13、   Incorrect lazy initialization and update of static field\nid: LI_LAZY_INIT_UPDATE_STATIC, type: LI, category: MT_CORRECTNESS\nThis method contains an unsynchronized lazy initialization of a static field. After the field is set, the object stored into that location is further updated or accessed. The setting of the field is visible to other threads as soon as it is set. If the futher accesses in the method that set the field serve to initialize the object, then you have a very seriousmultithreading bug, unless something else prevents any other thread from accessing the stored object until it is fully initialized.\nEven if you feel confident that the method is never called by multiple threads, it might be better to not set the static field until the value you are setting it to is fully populated/initialized.\n原因分析：\n该方法的初始化中包含了一个迟缓初始化的静态变量。你的方法引用了一个静态变量，估计是类静态变量，那么多线程调用这个方法时，你的变量就会面临线程安全的问题了，除非别的东西阻止任何其他线程访问存储对象从直到它完全被初始化。\n##### 7.14、   Method ignores return value\nid: RV_RETURN_VALUE_IGNORED, type: RV, category: CORRECTNESS\nThe return value of this method should be checked. One common cause of this warning is to invoke a method on an immutable object, thinking that it updates the object. For example, in the following code fragment,\nString dateString = getHeaderField(name);\ndateString.trim();\nthe programmer seems to be thinking that the trim() method will update the String referenced by dateString. But since Strings are immutable, the trim() function returns a new String value, which is being ignored here. The code should be corrected to:\nString dateString = getHeaderField(name);\ndateString = dateString.trim();\n原因分析：方法忽略了设置返回值。\n例如：\n \n```String dateString = getHeaderField(name);\n    dateString.trim();\n    \n    if(CustomActionEnum.Agee_SRT.equals(operationType)||CustomActionEnum.DISSAgee_SRT.equals(operationType){\n        //....\n    }\n```\n##### 7.15、   Method might ignore exception\nid: DE_MIGHT_IGNORE, type: DE, category: BAD_PRACTICE\nThis method might ignore an exception.Â  In general, exceptions should be handled or reported in some way, or they should be thrown out of the method.\n原因分析：应该将异常 处理、打印或者抛出\n例如：\n```try{\n     //....\n }catch(Exception e){\n     \n }\n```\n\n##### 7.16、   Unwritten field\nid: UWF_UNWRITTEN_FIELD, type: UwF, category: CORRECTNESS\nThis field is never written.Â  All reads of it will return the default value. Check for errors (should it have been initialized?), or remove it if it is useless.\n原因分析：从未被初始化的变量，调用它时，将返回默认值，要么初始化，要么删掉它。\n例如：\n```try{\n        //....\n    }catch(Exception e){\n        \n    }\n```\n\n##### 7.17、   Value is null and guaranteed to be dereferenced on exception path\nid: NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH, type: NP, category:CORRECTNESS\nThere is a statement or branch on an exception path that if executed guarantees that a value is null at this point, and that value that is guaranteed to be dereferenced (except on forward paths involving runtime exceptions).\n原因分析：exception分支上，存在引用一个null对象的方法，引发空指针异常。\n例如：\n``` PrintWriter out = null;\n    try{\n        response.setContentType(\"text/html;charset=GBK\");\n        response.setHeader(\"Cache-Control;no-cache\");\n        out = response.getWriter();\n        out.flush();\n    }catch(Exception ex){\n        logger.debug(\"获取树的XML代码出错。\"+ex.getMessage());\n    }finally{\n        out.close();//out可能为空\n    }\n```\n\n##### 7.18、   Very confusing method names\nid: NM_VERY_CONFUSING, type: Nm, category: CORRECTNESS\nThe referenced methods have names that differ only by capitalization. This is very confusing because if the capitalization were identical then one of the methods would override the other.\n原因分析：被引用的方法中存在容易混淆的变量。\n例如：fzgsdm改成 fzgsDm 即可。\n \n```public String getFzgsdm() {\n    return getFzgsdm;\n}\n```\n\n##### 7.19、   Method invokes inefficient new String() constructor\nid: DM_STRING_VOID_CTOR, type: Dm, category: Performance Creating a new java.lang.String object using the no-argument constructor wastes memory because the object so created will be functionally indistinguishable from the empty string constant \"\".  Java guarantees that identical string constants will be represented by the same String object.  Therefore, you should just use the empty string constant directly.\n原因分析：不使用new String()定义空的字符串\n例如：\n  \n```String alarmCodeCond = new String();\n应当\nString alarmCodeCond = \"\";\n```      \n\n##### 7.20、   Load of known null value\nid: NP_LOAD_OF_KNOWN_NULL_VALUE, type: Np, category: Dodgy\nThe variable referenced at this point is known to be null due to an earlier check against null. Although this is valid, it might be a mistake (perhaps you intended to refer to a different variable, or perhaps the earlier check to see if the variable is null should have been a check to see if it was nonnull).\n原因分析：null值的不当使用。\n例如：\n\n``` \nif(devIds ==null && devIds.size()==0){ //.....} \n\nif(null ==tempList||tempList.size()!=0){ //.....}\n\nif(batchNo ==null){\n   throw new Exception(\"the No. \"+batchNo + \"is not exists1\"）)\n}\n```\n##### 7.21、   Method concatenates strings using + in a loop  \nid: SBSC_USE_STRINGBUFFER_CONCATENATION, type: SBSC, category: Performance\nThe method seems to be building a String using concatenation in a loop. In each iteration, the String is converted to a StringBuffer/StringBuilder, appended to, and converted back to a String. This can lead to a cost quadratic in the number of iterations, as the growing string is recopied in each iteration. Better performance can be obtained by using a StringBuffer (or StringBuilder in Java 1.5) explicitly.\nFor example:\n  // This is bad\n  String s = \"\";\n  for (int i = 0; i < field.length; ++i) {\n    s = s + field[i];\n  }\n  // This is better\n  StringBuffer buf = new StringBuffer();\n  for (int i = 0; i < field.length; ++i) {\n    buf.append(field[i]);\n  }\n  String s = buf.toString();\n原因分析：在循环里使用字符串连接，效率低，应该使用StringBuilder/StringBuffer\n \n### Bug列表\n#### BUG-0001\nBug: Field only ever set to null: com.bettersoft.admin.BtCorpManager.ps \nAll writes to this field are of the constant value null, and thus all reads of the field will return null. Check for errors, or remove it if it is useless.\nConfidence: Normal, Rank: Troubling (12)\nPattern: UWF_NULL_FIELD \nType: UwF, Category: CORRECTNESS (Correctness)\n代码片段：、\n```public class BtCorpManager {\n    private BtCorp btcorp=null;\n    private Connection con = null;\n    private Statement st = null;\n    private PreparedStatement ps = null;\n    private ResultSet rs = null;\n    private void setConnection(String centerno) throws Exception{\n        //con = DBManager.getConnection(centerno);\n        con = DBManager.getConnection();\n    }\n```\n解释说明：在BtCorpManager类里面定了一个私有的成员变量PreparedStatement ps,但是这个成员变量ps在实例范围内没有得到任何的初始化(采用默认的构造方法)，始终为null,所以在实例范围内使用该成员变量时，如果不先对其进行初始化操作或者无意识的行为忘了初始化操作，那肯定是要报空指针异常，所以这无疑是一个bug \n推荐修改： 自己看着办\n \n#### BUG-0002\nBug: Nullcheck of form at line 36 of value previously dereferenced in com.bettersoft.admin.CorpEditAction.execute(ActionMapping, ActionForm, HttpServletRequest, HttpServletResponse)\nA value is checked here to see whether it is null, but this value can't be null because it was previously dereferenced and if it were null a null pointer exception would have occurred at the earlier dereference. Essentially, this code and the previous dereference disagree as to whether this value is allowed to be null. Either the check is redundant or the previous dereference is erroneous.\nConfidence: High, Rank: Scary (9)\nPattern: RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE \nType: RCN, Category: CORRECTNESS (Correctness)\n代码片段：\n\n```public ActionForward execute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        //throw new UnsupportedOperationException(\"Method is not implemented\");\n        ActionErrors errors = new ActionErrors();\n        CreateCorpActionForm createCorp = new CreateCorpActionForm();\n        createCorp = (CreateCorpActionForm)form;\n        CreateCorpActionForm webcorp=new CreateCorpActionForm();\n        BudgetWebcorpManager budgetWebcorpManager=new BudgetWebcorpManager();\n        webcorp=budgetWebcorpManager.getCWebcorp(createCorp.getId());\n        createCorp.setFbsaddapproveid(webcorp.getFbsaddapproveid());\n        createCorp.setFbsinputapproveid(webcorp.getFbsinputapproveid());\n        createCorp.setFbsprocessapproveid(webcorp.getFbsprocessapproveid());\n \n        boolean b=false;\n        if(createCorp!=null){\n\n```\n解释说明：注意到有个局部变量 CreateCorpActionForm createCorp;再看下它的初始化过程，先是通过new给它分配了内存空间，紧接着有让它引用了了另一个未知的变量，这里说未知是指这个新的引用可能为空，显然 createCorp有可能指向一个空的地址，所以在接下来的引用中极可能报空指针异常（在引用之前不进行判空操作的话）！ 在接下来的代码，如下\n`if(createCorp!=null){\n`\n其实也就没有存在的必要，因为如果为空的话，上面这行代码根本不可能执行到，所以findbug说这是冗余的空指针检查。当然考虑到特殊情况，这里显然是struts1的action,所以只要web应用正常启动，通常以下代码\n\n`createCorp = (CreateCorpActionForm)form;`\n\n是不会导致createCorp指向空的，唯一的缺陷就是之前的new操作是多余的。\n推荐修改：自己看着办\n\n#### BUG-0003\nBug: con is null guaranteed to be dereferenced in com.bettersoft.admin.leftAction.getLeft(int, String, String) on exception path\nThere is a statement or branch on an exception path that if executed guarantees that a value is null at this point, and that value that is guaranteed to be dereferenced (except on forward paths involving runtime exceptions).\nConfidence: Normal, Rank: (Troubling 11)\nPattern: NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH \nType: NP, Category: CORRECTNESS (Correctness)\n代码片段：\n\n```finally\n        {\n            try\n            {\n                if(rs != null)\n                    rs.close();\n                if(ps!=null)\n                    ps.close();\n                con.close();\n            }catch(Exception ee)\n            {\n                ee.printStackTrace();\n            }\n        }\n```\n\n解释说明：这应该是大家很熟悉的代码片段了，可以想象Connection con是在catch代码块中进行的初始化操作，findbug对该bug说的很明白，说如果出现异常，Connection con将保证为空，因为很显然如果出现异常，con将得不到正确的初始化，即便初始化了，因为异常的出现，引用也会被解除，回到一开始定义处的null状态，那么在这里的finally代码块中调用Connection con的close()方法，将报空指针异常 \n推荐修改：自己看着办 \n \n#### BUG-0004 \nBug: Possible null pointer dereference of dbVersion in com.bettersoft.admin.LoginAction.loadVersion(HttpServletRequest, ActionErrors) on exception path \nA reference value which is null on some exception control path is dereferenced here. This may lead to aNullPointerExceptionwhen the code is executed. Note that because FindBugs currently does not prune infeasible exception paths, this may be a false warning.\nAlso note that FindBugs considers the default case of a switch statement to be an exception path, since the default case is often infeasible.\nConfidence: Normal, Rank: Troubling (11)\nPattern: NP_NULL_ON_SOME_PATH_EXCEPTION \nType: NP, Category: CORRECTNESS (Correctness)\n代码片段：\n\n```VersionInfo dbVersion = null;\n    try {\n        con = DBManager.getConnection();\n        dbVersion = vm.getVersionInfo(con);\n    } catch (Exception e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    } finally {\n        try {\n            con.close();\n        } catch (SQLException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n    }\nif (dbVersion.equals(programVersion)) {\n    programVersion.setCorrent(true);\n} else {\n    programVersion.setCorrent(false);\n}\n```\n\n解释说明：如果try catch 中捕获异常，那么dbVersion将为空， \n\n`dbVersion.equals(programVersion)`\n\n上面这行代码，将报空指针异常 \n \n#### BUG-0005\nBug: Dead store to am in com.bettersoft.approve.action.CheckAction.execute(ActionMapping, ActionForm, HttpServletRequest, HttpServletResponse)\nThis instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used.\nNote that Sun's javac compiler often generates dead stores for final local variables. Because FindBugs is a bytecode-based tool, there is no easy way to eliminate these false positives.\nConfidence: High, Rank: Of Concern (15)\nPattern: DLS_DEAD_LOCAL_STORE \nType: DLS, Category: STYLE (Dodgy code)\n代码片段：\n\n`ApproveManager am = new ApproveManager();`\n\n解释说明：am这个局部变量创建出来后，没有在任何地方被引用。这里确实没有被引用，所以是个bug,但是findbug又说明了，这有可能是误报，因为javac编译器在编译局部常量时，也会产生dead stroes。所以这个要视情况而定，不能过于纠结 \n \n \n#### BUG-0006\nBug: The class name com.bettersoft.approve.form.BtWebCorp shadows the simple name of the superclass com.bettersoft.admin.BtWebCorp\nThis class has a simple name that is identical to that of its superclass, except that its superclass is in a different package (e.g.,alpha.Fooextendsbeta.Foo). This can be exceptionally confusing, create lots of situations in which you have to look at import statements to resolve references and creates many opportunities to accidently define methods that do not override methods in their superclasses.\nConfidence: High, Rank: Troubling (14)\nPattern: NM_SAME_SIMPLE_NAME_AS_SUPERCLASS \nType: Nm, Category: BAD_PRACTICE (Bad practice)\n代码片段： \n\n```public class BtWebCorp extends com.bettersoft.admin.BtWebCorp{\n \n}\n```\n\n解释说明：这里子类和父类名称一样，findbug认为这回导致很多混淆。显然一旦出问题，将很难发现，运行结果将出乎意料 \n \n#### BUG-0007\nBug: Comparison of String objects using == or != in com.byttersoft.admin.persistence.dao.MessageOpenDao.addOpenSave(MessageOpenForm)\nThis code comparesjava.lang.Stringobjects for reference equality using the == or != operators. Unless both strings are either constants in a source file, or have been interned using theString.intern()method, the same string value may be represented by two different String objects. Consider using theequals(Object)method instead.\nConfidence: Normal, Rank: Troubling (11)\nPattern: ES_COMPARING_STRINGS_WITH_EQ \nType: ES, Category: BAD_PRACTICE (Bad practice)\n代码片段：\n\n```if(id==null || id==\"\"){\n        sql = \"insert into xx values (1,?,?,?)\";\n}else{\n        sql = \"insert into xx values ((select max(id) + 1 from xx),?,?,?)\";\n}\n```\n\n解释说明： 直接使用==进行对象实例比较，而没有使用equals,本来没觉得这个bug咋样，但是发现项目里居然最多的bug就是这个，不管是很多年前的代码还是最近的代码，都存在这大量这样的问题。看来这是一个通病，所以大家注意一下，不光是我们公司的项目有这样的问题，这应该是一个普遍的问题，尤其实在比较String类型的时候，注意只要不是java基本类型都需要使用equals进行比较，哪怕是自动解封的Integer，Double等\n \n#### BUG-0008\nBug: Call to String.equals(Double) in com.byttersoft.amm.util.BalanceInterzoneRateUtil.formatRate(Double)\nThis method calls equals(Object) on two references of different class types with no common subclasses. Therefore, the objects being compared are unlikely to be members of the same class at runtime (unless some application classes were not analyzed, or dynamic class loading can occur at runtime). According to the contract of equals(), objects of different classes should always compare as unequal; therefore, according to the contract defined by Java.lang.Object.equals(Object), the result of this comparison will always be false at runtime.\nConfidence: High, Rank: Scariest (1)\nPattern: EC_UNRELATED_TYPES \nType: EC, Category: CORRECTNESS (Correctness)\n代码片段：\n```private static String  formatRate(Double r){\n         \n        if(r==null ||  (\"undefined\").equals(r)){\n            return null;\n        }\n\n```\n解释说明：使用equals比较不同类型的数据，\"undefined\"是String类型，r是Double类型，这两个比较肯定返回false\n\n`(\"undefined\").equals(r)`\n\n上面这行代码完全没有必要 ，不可能存在这种情况\n \n#### BUG-0009\nBug: Class com.byttersoft.util.CertInfo defines non-transient non-serializable instance field subjectDnAttr\nThis Serializable class defines a non-primitive instance field which is neither transient, Serializable, orjava.lang.Object, and does not appear to implement theExternalizableinterface or thereadObject()andwriteObject()methods. Objects of this class will not be deserialized correctly if a non-Serializable object is stored in this field.\nConfidence: High, Rank: Troubling (14)\nPattern: SE_BAD_FIELD \nType: Se, Category: BAD_PRACTICE (Bad practice)\n代码片段： \n\n```public class CertInfo implements java.io.Serializable\n{\n    private String subjectDN=\"\";\n    private String issuerDN=\"\";\n    private String notAfterDate=\"\";\n    private String notBeforeDate=\"\";\n    private String serialNumber=\"\";\n    private String sigAlgName=\"\";\n    private String sigAlgOID=\"\";\n    private String version=\"\";\n    private String publicKeyFormat=\"\";\n    private String publicKeyAlgorithm=\"\";\n    private Names subjectDnAttr=null;\n｝\npublic class Names\n{}<span></span>\n```\n\n解释说明： CertInfo实现的序列话，但是他的成员变量Names subjectDnAttr没有实现序列化，这将会导致序列化失败，String已经默认实现了序列化。注意，序列化时所有的成员变量都必须递归的实现序列化，否则将导致序列化失败。如果某个成员变量不想被序列化要么标注为瞬态要么重写readObj方法\n \n#### BUG-0010\nBug: Dead store to corpGourps rather than field with same name in com.byttersoft.admin.form.CorpGroupsForm.setCorpGourps(CorpGourps)\nThis instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used. There is a field with the same name as the local variable. Did you mean to assign to that variable instead?\nConfidence: High, Rank: Scary (9)\nPattern: DLS_DEAD_LOCAL_STORE_SHADOWS_FIELD \nType: DLS, Category: STYLE (Dodgy code)\n代码片段： \n\n```\npublic void setCorpGourps(CorpGourps corpGourps) {\n        corpGourps = corpGourps;\n    }\n```\n解释说明：成员变量和局部变量重名\n \n#### BUG-0011\nBug: Invocation of toString on labelValue in com.byttersoft.approve.persistence.dao.MesAppDao.getMapByPara(String)\nThe code invokes toString on an array, which will generate a fairly useless result such as [C@16f0472. Consider using Arrays.toString to convert the array into a readable String that gives the contents of the array. See Programming Puzzlers, chapter 3, puzzle 12.\nConfidence: Normal, Rank: Troubling (10)\nPattern: DMI_INVOKING_TOSTRING_ON_ARRAY \nType: USELESS_STRING, Category: CORRECTNESS (Correctness)\n代码片段：\n\n```for (String parameter : parameters) {\n            String[] labelValue = parameter.split(\"=\");\n            if (labelValue.length == 2) {\n                String key = labelValue[0];\n                String value = labelValue[1];\n                hashMap.put(key, value);\n            } else {\n                logger.debug(\"参数 \" + labelValue + \" 配置错误。\");\n            }\n        }\n```\n\n解释说明：在进行日志输出时，直接输出对象，将默认调用对象的toString方法，而默认是输出对象的内存地址，所以这里显然有问题，本意应该是输出数组中的字符串 \n \n#### BUG-0012\nBug: Write to static field com.byttersoft.admin.service.BtSysResService.map from instance method com.byttersoft.admin.service.BtSysResService.hashCatchOfSysRes(boolean)\nThis instance method writes to a static field. This is tricky to get correct if multiple instances are being manipulated, and generally bad practice.\nConfidence: High, Rank: Of Concern (15)\nPattern: ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD \nType: ST, Category: STYLE (Dodgy code)\n代码片段： \n\n```static Map<String, BtSysRes> map = new HashMap<String, BtSysRes>();\npublic Map<String, BtSysRes> hashCatchOfSysRes(boolean isRefresh) {\n        if(isRefresh == true){\n            map = hashCatchOfSysRes();\n        }else{\n            if(map == null || map.isEmpty()){\n                map = hashCatchOfSysRes();\n            }\n        }\n        return map;\n    }\n\n```\n解释说明：在实例方法中修改类变量的引用，这会导致共享问题，因为其他实例也会访问该静态变量，但是却不知道某个实例已经修改了该静态变量的引用，导致不可预知的问题\n推荐修改：将该方法改为类方法\n \n \n#### BUG-0013\nBug: Unwritten field: com.byttersoft.admin.service.importservice.ImportServices.bank\nThis field is never written. All reads of it will return the default value. Check for errors (should it have been initialized?), or remove it if it is useless.\nConfidence: Normal, Rank: Troubling (12)\nPattern: UWF_UNWRITTEN_FIELD \nType: UwF, Category: CORRECTNESS (Correctness)\n代码片段：\n\n```public class ImportServices {\nprivate IBankAccServices bank;\npublic IBankAccServices getBank() {\n        return bank;\n    }\n｝\n```\n\n解释说明： bank对象为空，getBank方法返回了一个肯定为空的对象实例\n \n \n#### BUG-0014\nBug: There is an apparent infinite recursive loop in com.byttersoft.amm.dao.impl.CheckLoanOrProvideInfoDaoImpl.addBatch(List)\nThis method unconditionally invokes itself. This would seem to indicate an infinite recursive loop that will result in a stack overflow.\nConfidence: High, Rank: Scary (9)\nPattern: IL_INFINITE_RECURSIVE_LOOP \nType: IL, Category: CORRECTNESS (Correctness)\n代码片段： \n```public void addBatch(List<CmsPLoanToBean> cmsPLoanBeans) {\n        this.addBatch(cmsPLoanBeans);\n    }\n```\n解释说明：出现了递归调用addBatch,将出现死循环\n \n### High\n#### 1.DM_DEFAULT_ENCODING\n \n##### 1.1 Found reliance on default encoding in com.cmcc.aoi.httprequest.service.HttpRequest.sendGet(String, String): new java.io.InputStreamReader(InputStream)\nFound a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.\n \nnew BufferedReader(new InputStreamReader(connection.getInputStream()));\n \n修改为： InputStreamReader fileData = new InputStreamReader(file ,\"utf-8\");\n \n \n \n##### 1.2 Found reliance on default encoding in com.cmcc.aoi.httprequest.service.HttpRequest.sendPost(String, JSONObject): new java.io.PrintWriter(OutputStream)\nFound a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.\nout = new PrintWriter(conn.getOutputStream());\n \n修改为： out = new PrintWriter(new OutputStreamWriter(conn.getOutputStream(), \"utf-8\"));\n \n \n##### 1.3 Found reliance on default encoding in com.cmcc.aoi.selfhelp.action.DeliverWebRequestAction.calculateUserCount(HttpServletRequest): String.getBytes()\nFound a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.\nfileName = new String(req.getParameter(\"fileName\").getBytes(), \"UTF-8\");\n修改为\nfileName = new String(req.getParameter(\"fileName\").getBytes(\"UTF-8\"), \"UTF-8\");\n \n##### 1.4 Found reliance on default encoding in com.cmcc.aoi.selfhelp.action.servlet.AoeRegAction.report(HttpServletRequest, HttpServletResponse): java.io.ByteArrayOutputStream.toString()\nFound a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.\nlogger.info(\"RECV STR: \" + baos.toString());\n修改为\nlogger.info(\"RECV STR: \" + baos.toString(\"utf-8\"));\n \n##### 1.5 Found reliance on default encoding in com.cmcc.aoi.selfhelp.action.servlet.AoeUploadLogAction.report(HttpServletRequest, HttpServletResponse): new java.io.FileWriter(File)\nFound a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.\nnew FileWriter(f).append(baos.toString(\"UTF-8\")).close();\n修改为\nBufferedWriter out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(f, true))); \nout.write(baos.toString(\"UTF-8\")); \nout.close();\n \nBufferedWriter bw= new BufferedWriter( new OutputStreamWriter(new FileOutputStream(filePath, true), \"utf-8\"));\n \n##### 1.6 Found reliance on default encoding in new com.cmcc.aoi.util.TokenZipFileUtil(String): new java.io.FileReader(String)\nFound a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.\nFileReader in = new FileReader(file);\n改为\nBufferedReader reader = new BufferedReader(new InputStreamReader(newFileInputStream(file), \"UTF-8\")); \n       \n#### 2.MS_SHOULD_BE_FINAL\n \ncom.cmcc.aoi.selfhelp.action.DeliverWebRequestAction.logger isn't final but should be\nThis static field public but not final, and could be changed by malicious code or by accident from another package. The field could be made final to avoid this vulnerability.\n \nprotected static   Logger logger = LoggerFactory.getLogger(DeliverWebRequestAction.class);\n修改为 protected static final Logger logger = LoggerFactory.getLogger(DeliverWebRequestAction.class);\n \n####  3.DLS_DEAD_LOCAL_STORE\n \nDead store to s in com.cmcc.aoi.selfhelp.action.DeliverWebRequestAction.textSend(WebSendTextForm, HttpServletRequest)\nThis instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used.\nNote that Sun's javac compiler often generates dead stores for final local variables. Because FindBugs is a bytecode-based tool, there is no easy way to eliminate these false positives.\nShopMappingDeliver shopMappingDeliver = null;\n删除即可\n \n#### 4.ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD\nWrite to static field com.cmcc.aoi.selfhelp.action.MultipleMediaAoeAction.linkRoot from instance method com.cmcc.aoi.selfhelp.action.MultipleMediaAoeAction.afterPropertiesSet()\nThis instance method writes to a static field. This is tricky to get correct if multiple instances are being manipulated, and generally bad practice.\nlinkRoot = sysConfigService.getDomainName() + \"/\";\n修改改为：\n```public static String getLinkRoot() {\n        returnlinkRoot;\n    }\n \n    publicstaticvoid setLinkRoot(String linkRoot) {\n        MultipleMediaAoeAction.linkRoot = linkRoot;\n    }\n   MultipleMediaAoeAction.setLinkRoot(sysConfigService.getDomainName() + \"/\");\n\n``` \n\n#### 5. J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION\nStore of non serializable com.cmcc.aoi.selfhelp.action.UploadFileAction$FileUploadStatus into HttpSession in new com.cmcc.aoi.selfhelp.action.UploadFileAction$MyProgressListener(UploadFileAction, HttpServletRequest)\nThis code seems to be storing a non-serializable object into an HttpSession. If this session is passivated or migrated, an error will result.\n修改为 FileUploadStatus implements Serializable\n \n \n#### 6.  RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE\nRedundant nullcheck of rtr, which is known to be non-null in com.cmcc.aoi.selfhelp.action.servlet.AoeReportApplistAction.device(HttpServletRequest, HttpServletResponse)\nThis method contains a redundant check of a known non-null value against the constant null.\n```if (rtr != null) {\n            Writer writer;\n            try {\n                writer = response.getWriter();\n                if (rtr != null) {\n                    try {\n \n                        String s = JSONUtil.objToJson(rtr);\n                        if (LOGGER.isDebugEnabled()) {\n                            LOGGER.debug(\"SEND STR: \" + s);\n                        }\n                        writer.write(s);\n                        writer.flush();\n                    } catch (IOException e) {\n                        LOGGER.warn(\"\", e);\n                        if (writer != null) {\n                            try {\n                                writer.write(JSONUtil.objToJson(rtr));\n                            } catch (IOException e1) {\n                                LOGGER.warn(\"\", e1);\n                            }\n                        }\n                    }\n                } else {\n                    response.getWriter().write(\"{\\\"errorCode\\\":401}\");\n                }\n            } catch (IOException e2) {\n                LOGGER.warn(\"\", e2);\n            }\n        }\n```\n修改为\n```if (rtr != null) {\n            Writer writer;\n            try {\n                writer = response.getWriter();\n                try {\n \n                    String s = JSONUtil.objToJson(rtr);\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.debug(\"SEND STR: \" + s);\n                    }\n                    writer.write(s);\n                    writer.flush();\n                } catch (IOException e) {\n                    LOGGER.warn(\"\", e);\n                    if (writer != null) {\n                        try {\n                            writer.write(JSONUtil.objToJson(rtr));\n                        } catch (IOException e1) {\n                            LOGGER.warn(\"\", e1);\n                        }\n                    }\n                }\n \n            } catch (IOException e2) {\n                LOGGER.warn(\"\", e2);\n            }\n        } else {\n            response.getWriter().write(\"{\\\"errorCode\\\":401}\");\n        }\n```\n \n#### 7. RU_INVOKE_RUN\ncom.cmcc.aoi.selfhelp.action.servlet.UploadTokensAction$TokenFileThread.run() explicitly invokes run on a thread (did you mean to start it instead?)\nThis method explicitly invokes run() on an object.  In general, classes implement the Runnable interface because they are going to have their run() method invoked in a new thread, in which case Thread.start() is the right method to call.\n \n`ti.run();\n`\n修改为：\n\n```ti.start();\ntry {\n    ti.join();\n} catch (InterruptedException e) {\n     e.printStackTrace();\n}\n```\n \n \n#### 8. NM_SAME_SIMPLE_NAME_AS_SUPERCLASS\nThe class name com.cmcc.aoi.selfhelp.dao.BaseDao shadows the simple name of the superclass org.slave4j.orm.hibernate.BaseDao\nThis class has a simple name that is identical to that of its superclass, except that its superclass is in a different package (e.g., alpha.Foo extends beta.Foo). This can be exceptionally confusing, create lots of situations in which you have to look at import statements to resolve references and creates many opportunities to accidentally define methods that do not override methods in their superclasses\ncom.cmcc.aoi.selfhelp.dao.BaseDao\n修改为\ncom.cmcc.aoi.selfhelp.dao.BasisDao\n \n#### 9. SE_BAD_FIELD_INNER_CLASS\ncom.cmcc.aoi.selfhelp.action.UploadFileAction$FileUploadStatus is serializable but also an inner class of a non-serializable class\nThis Serializable class is an inner class of a non-serializable class. Thus, attempts to serialize it will also attempt to associate instance of the outer class with which it is associated, leading to a runtime error.\nIf possible, making the inner class a static inner class should solve the problem. Making the outer class serializable might also work, but that would mean serializing an instance of the inner class would always also serialize the instance of the outer class, which it often not what you really want.\n修改外部类\nUploadFileAction extends BaseAction implements Serializable\n \n \n#### 10. DM_BOXED_PRIMITIVE_FOR_PARSING\nBoxing/unboxing to parse a primitive com.cmcc.aoi.selfhelp.dao.StatAppEveryHourDao.findWeekList(String)\nA boxed primitive is created from a String, just to extract the unboxed primitive value. It is more efficient to just call the static parseXXX method.\n\n```statAppEveryHour.setNewnumber(Integer.valueOf(String.valueOf(objects[2])));               statAppEveryHour.setAccnumber(Integer.valueOf(String.valueOf(objects[3])));\n```\n修改为\n\n```statAppEveryHour.setStattime(sdf.parse(String.valueOf(objects[1])));\n                    statAppEveryHour\n                            .setNewnumber(Integer.parseInt(String.valueOf(objects[2]) != null\n                                    && !\"\".equals(String.valueOf(objects[2]))\n                                            ? String.valueOf(objects[2]) : \"0\"));\n                    statAppEveryHour\n                            .setAccnumber(Integer.parseInt(String.valueOf(objects[3]) != null\n                                    && !\"\".equals(String.valueOf(objects[3]))\n                                            ? String.valueOf(objects[3]) : \"0\"));\n```\n \n###  Normal\n#### 1.SBSC_USE_STRINGBUFFER_CONCATENATION\ncom.cmcc.aoi.httprequest.service.HttpRequest.sendGet(String, String) concatenates strings using + in a loop\nThe method seems to be building a String using concatenation in a loop. In each iteration, the String is converted to a StringBuffer/StringBuilder, appended to, and converted back to a String. This can lead to a cost quadratic in the number of iterations, as the growing string is recopied in each iteration.\nBetter performance can be obtained by using a StringBuffer (or StringBuilder in Java 1.5) explicitly.\nFor example:\n  // This is bad\n  String s = \"\";\n  for (int i = 0; i < field.length; ++i) {\n    s = s + field[i];\n  }\n \n  // This is better\n  StringBuffer buf = new StringBuffer();\n  for (int i = 0; i < field.length; ++i) {\n    buf.append(field[i]);\n  }\n  String s = buf.toString();\n \n#### 2. WMI_WRONG_MAP_ITERATOR\n\n```for (String key : map.keySet()) {\n                System.out.println(key + \"--->\" + map.get(key));\n}\n```\n改为\n\n```for (  Map.Entry<String, List<String>> entry : map.entrySet()) {\n                System.out.println(entry.getKey() + \"--->\" + entry.getValue());\n            }\n\n``` \n#### 3.  EI_EXPOSE_REP\ncom.cmcc.aoi.selfhelp.entity.Activation.getValidUntil() may expose internal representation by returning Activation.validUntil\nReturning a reference to a mutable object value stored in one of the object's fields exposes the internal representation of the object.  If instances are accessed by untrusted code, and unchecked changes to the mutable object would compromise security or other important properties, you will need to do something different. Returning a new copy of the object is better approach in many situations.\n \n \n    public Date getValidUntil() {\n        returnvalidUntil;\n}\n \n修改为\npublic Date getValidUntil() {\n        if(validUntil == null) {\n            returnnull;\n        }\n        return (Date) validUntil.clone();\n}\n \n#### 4. EI_EXPOSE_REP2\ncom.cmcc.aoi.selfhelp.entity.Activation.setValidUntil(Date) may expose internal representation by storing an externally mutable object into Activation.validUntil\nThis code stores a reference to an externally mutable object into the internal representation of the object.  If instances are accessed by untrusted code, and unchecked changes to the mutable object would compromise security or other important properties, you will need to do something different. Storing a copy of the object is better approach in many situations.\n\n```publicvoid setValidUntil(Date validUntil) {\nthis.validUntil = validUntil;\n}\n```\n修改为\n```publicvoid setValidUntil(Date validUntil) {\n        if(validUntil == null) {\n            this.validUntil = null;\n        }else {\n            this.validUntil = (Date) validUntil.clone();\n        }\n    }\n\n``` \n \n#### 5. BC_VACUOUS_INSTANCEOF\ninstanceof will always return true for all non-null values in com.cmcc.aoi.selfhelp.entity.AppType.compareTo(AppType), since all com.cmcc.aoi.selfhelp.entity.AppType are instances of com.cmcc.aoi.selfhelp.entity.AppType\nThis instanceof test will always return true (unless the value being tested is null). Although this is safe, make sure it isn't an indication of some misunderstanding or some other logic error. If you really want to test the value for being null, perhaps it would be clearer to do better to do a null test rather than an instanceof test.\n \n#### 6. MS_MUTABLE_ARRAY\ncom.cmcc.aoi.selfhelp.entity.DeviceType.CURRENTUSEDDEVICES is a mutable array\nA final static field references an array and can be accessed by malicious code or by accident from another package. This code can freely modify the contents of the array.\n \npublic static final int[] CURRENTUSEDDEVICES = new int []{Device.iOS.ordinal()，Device.Android.ordinal()，Device.WP.ordinal()}；\n修改为\n Public > protected\n \n#### 7. EQ_COMPARETO_USE_OBJECT_EQUALS\ncom.cmcc.aoi.selfhelp.entity.AppType defines compareTo(AppType) and uses Object.equals()\nThis class defines a compareTo(...) method but inherits its equals() method from java.lang.Object. Generally, the value of compareTo should return zero if and only if equals returns true. If this is violated, weird and unpredictable failures will occur in classes such as PriorityQueue. In Java 5 the PriorityQueue.remove method uses the compareTo method, while in Java 6 it uses the equals method.\nFrom the JavaDoc for the compareTo method in the Comparable interface:\nIt is strongly recommended, but not strictly required that (x.compareTo(y)==0) == (x.equals(y)). Generally speaking, any class that implements the Comparable interface and violates this condition should clearly indicate this fact. The recommended language is \"Note: this class has a natural ordering that is inconsistent with equals.\"\n \n修改\n添加 hashcode() 和 equals() 代码即可\n \n#### 8. BC_VACUOUS_INSTANCEOF\ninstanceof will always return true for all non-null values in com.cmcc.aoi.selfhelp.entity.AppType.compareTo(AppType), since all com.cmcc.aoi.selfhelp.entity.AppType are instances of com.cmcc.aoi.selfhelp.entity.AppType\nThis instanceof test will always return true (unless the value being tested is null). Although this is safe, make sure it isn't an indication of some misunderstanding or some other logic error. If you really want to test the value for being null, perhaps it would be clearer to do better to do a null test rather than an instanceof test.\n  \n```@Override\n    publicint compareTo(AppType o) {\n        if (oinstanceof AppType) {\n            AppType p = (AppType) o;\n            returnthis.typeId > p.typeId ? 1 : this.typeId == p.typeId ? 0 : -1;\n        }\n        return 1;\n    }\n\n``` \n\n修改为\n  \n```@Override\n    publicint compareTo(AppType o) {\n        if (null != o) {\n            AppType p  = (AppType) o ;\n            returnthis.typeId > p.typeId ? 1 : this.typeId == p.typeId ? 0 : -1;\n        }\n        return 1;\n \n    }\n\n``` \n#### 9. ME_ENUM_FIELD_SETTER\ncom.cmcc.aoi.selfhelp.dto.ActivationSituation.setSituation(String) unconditionally sets the field situation\nThis public method declared in public enum unconditionally sets enum field, thus this field can be changed by malicious code or by accident from another package. Though mutable enum fields may be used for lazy initialization, it's a bad practice to expose them to the outer world. Consider removing this method or declaring it package-private.\n    publicvoid setCode(String code) {\n        this.code = code;\n    }\n \n修改\n 删除该无用代码\n \n \n#### 10.  IM_BAD_CHECK_FOR_ODD\nCheck for oddness that won't work for negative numbers in com.cmcc.aoi.selfhelp.dto.WebSendTextForm.toDeliverWebRequest()\nThe code uses x % 2 == 1 to check to see if a value is odd, but this won't work for negative numbers (e.g., (-5) % 2 == -1). If this code is intending to check for oddness, consider using x & 1 == 1, or x % 2 != 0.\n\n```DeliverFactory\n                                    .createTextOpenApp(this.msgtype, \"\", this.content,\n                                            this.isRingAndVibrate % 2 == 1,\n                                            isRingAndVibrate / 2 >= 1, this.activity)\n                                    .toJsonString());\n\n``` \n修改为\n\n```DeliverFactory\n                                    .createTextOpenApp(this.msgtype, \"\", this.content,\n                                            this.isRingAndVibrate % 2 != 0,\n                                            isRingAndVibrate / 2 >= 1, this.activity)\n                                    .toJsonString());\n\n``` \n \n#### 11. MS_EXPOSE_REP\nPublic static com.cmcc.aoi.selfhelp.dict.DeviceSupported.getSupportedDevs() may expose internal representation by returning DeviceSupported.DEVS\nA public static method returns a reference to an array that is part of the static state of the class. Any code that calls this method can freely modify the underlying array. One fix is to return a copy of the array.\n\n```public static Device[] getSupportedDevs() {\n        return DEVS;\n    }\n```\n修改为\n\n```publicstatic Device[] getSupportedDevs() {\n        return DeviceSupported.DEVS.clone();\n    }\n\n``` \n#### 12.URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD\nUnread public/protected field: com.cmcc.aoi.selfhelp.dict.OperatorDict.countryCode\nThis field is never read.  The field is public or protected, so perhaps it is intended to be used with classes not seen as part of the analysis. If not, consider removing it from the class.\npublicintcode;\n    \n```public String enName;\n    public String cnName;\n    public String countryCode;\n \n    public OperatorDict() {\n    }\n \n    /**\n     *\n     * @param code\n     *            运营商代码,一般是5位\n     * @param enName\n     *            英文名\n     * @param countryCode\n     *            国家英文代码\n     * @param cnName\n     *            中文名\n     */\n    public OperatorDict(intcode, String enName, String countryCode, String cnName) {\n        this.code = code;\n        this.enName = enName;\n        this.countryCode = countryCode;\n        this.cnName = cnName == null ? Integer.toString(code) : cnName;\n    }\n\n```修改为\nPublic  -》 private\n  \n#### 13. ES_COMPARING_STRINGS_WITH_EQ\nComparison of String objects using == or != in com.cmcc.aoi.selfhelp.entity.Provider.compareTo(Object)\nThis code compares java.lang.String objects for reference equality using the == or != operators. Unless both strings are either constants in a source file, or have been interned using the String.intern() method, the same string value may be represented by two different String objects. Consider using the equals(Object) method instead.\n \nreturn this.spid.compareTo(p.spid) > 0 ? 1 : this.spid == p.spid ? 0 : -1;\n修改为\nthis.spid.compareTo(p.spid) > 0 ? 1 : this.spid.equals(p.spid) ? 0 : -1;\n14.DB_DUPLICATE_BRANCHES\ncom.cmcc.aoi.selfhelp.dao.ShStatTerminalDao.getListQuery(String, int, Date, Date, boolean, int) uses the same code for two branches\nThis method uses the same code to implement two branches of a conditional branch. Check to ensure that this isn't a coding mistake.\n\n```if (bool) {\n                query.setInteger(i++, nodeType);\n                query.setInteger(i++, nodeType);\n            } else {\n                query.setInteger(i++, nodeType);\n                query.setInteger(i++, nodeType);\n            }\n\n```修改为\n\n```query.setInteger(i++, nodeType);\nquery.setInteger(i++, nodeType);\n```\n \n#### 15. SE_COMPARATOR_SHOULD_BE_SERIALIZABLE\n \ncom.cmcc.aoi.selfhelp.task.entity.StatAppHabitComparator implements Comparator but not Serializable\nThis class implements the Comparator interface. You should consider whether or not it should also implement the Serializable interface. If a comparator is used to construct an ordered collection such as a TreeMap, then the TreeMap will be serializable only if the comparator is also serializable. As most comparators have little or no state, making them serializable is generally easy and good defensive programming.\n修改为\nimplements Serializable\n \n#### 16.  UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD\n \nUnwritten public or protected field: com.cmcc.aoi.selfhelp.task.entity.StatDevice.keyname\nNo writes were seen to this public/protected field.  All reads of it will return the default value. Check for errors (should it have been initialized?), or remove it if it is useless.\nPublic  String keyname;\n修改为\nPrivate  String keyname;\n \n#### 18.  RV_RETURN_VALUE_IGNORED_BAD_PRACTICE\nExceptional return value of java.io.File.mkdirs() ignored in com.cmcc.aoi.util.FileUtil.moveFile(File, String)\nThis method returns a value that is not checked. The return value should be checked since it can indicate an unusual or unexpected function execution. For example, the File.delete() method returns false if the file could not be successfully deleted (rather than throwing an Exception). If you don't check the result, you won't notice if the method invocation signals unexpected behavior by returning an atypical return value.\ntmp.mkdirs()\n修改为\nbooleanmkdirs = tmp.mkdirs();\nlogger.debug(\"debug\",mkdirs);\n \nREC_CATCH_EXCEPTION\nException is caught when Exception is not thrown in com.cmcc.aoi.selfhelp.task.fileparser.TokenIncrease.parseLine(String[])\nThis method uses a try-catch block that catches Exception objects, but Exception is not thrown within the try block, and RuntimeException is not explicitly caught. It is a common bug pattern to say try { ... } catch (Exception e) { something } as a shorthand for catching a number of types of exception each of whose catch blocks is identical, but this construct also accidentally catches RuntimeException as well, masking potential bugs.\nA better approach is to either explicitly catch the specific exceptions that are thrown, or to explicitly catch RuntimeException exception, rethrow it, and then catch all non-Runtime Exceptions, as shown below:\n \n``` try {\n    ...\n  } catch (RuntimeException e) {\n    throw e;\n  } catch (Exception e) {\n    ... deal with all non-runtime exceptions ...\n  }\n\n``` \n \n#### 19. ICAST_IDIV_CAST_TO_DOUBLE\nIntegral division result cast to double or float in com.cmcc.aoi.selfhelp.service.BaseAnalysisService.getInterval(Date, Date, int)\nThis code casts the result of an integral division (e.g., int or long division) operation to double or float. Doing division on integers truncates the result to the integer value closest to zero. The fact that the result was cast to double suggests that this precision should have been retained. What was probably meant was to cast one or both of the operands to double before performing the division. \n```Here is an example:\nint x = 2;\nint y = 5;\n// Wrong: yields result 0.0\ndouble value1 =  x / y;\n \n// Right: yields result 0.4\ndouble value2 =  x / (double) y;\n```\n\n\n\n\n\n## FindBugs规则整理\nFindBugs是基于Bug Patterns概念，查找javabytecode（.class文件）中的潜在bug，主要检查bytecode中的bug patterns，如NullPoint空指针检查、没有合理关闭资源、字符串相同判断错（==，而不是equals）等\n### 一、Security 关于代码安全性防护\n1.Dm: Hardcoded constant database password (DMI_CONSTANT_DB_PASSWORD)\n代码中创建DB的密码时采用了写死的密码。\n2.Dm: Empty database password (DMI_EMPTY_DB_PASSWORD)\n创建数据库连接时没有为数据库设置密码，这会使数据库没有必要的保护。\n3.HRS: HTTP cookie formed from untrusted input (HRS_REQUEST_PARAMETER_TO_COOKIE)\n此代码使用不受信任的HTTP参数构造一个HTTP Cookie。\n4.HRS: HTTP Response splitting vulnerability (HRS_REQUEST_PARAMETER_TO_HTTP_HEADER)\n在代码中直接把一个HTTP的参数写入一个HTTP头文件中，它为HTTP的响应暴露了漏洞。\n5.SQL: Nonconstant string passed to execute method on an SQL statement (SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE)\n该方法以字符串的形式来调用SQLstatement的execute方法，它似乎是动态生成SQL语句的方法。这会更容易受到SQL注入攻击。\n6.XSS: JSP reflected cross site scripting vulnerability (XSS_REQUEST_PARAMETER_TO_JSP_WRITER)\n在代码中在JSP输出中直接写入一个HTTP参数，这会造成一个跨站点的脚本漏洞。\n### 二、Experimental\n \n1.LG: Potential lost logger changes due to weak reference in OpenJDK (LG_LOST_LOGGER_DUE_TO_WEAK_REFERENCE)\nOpenJDK的引入了一种潜在的不兼容问题，特别是，java.util.logging.Logger的行为改变时。它现在使用内部弱引用，而不是强引用。–logger配置改变，它就是丢失对logger的引用，这本是一个合理的变化，但不幸的是一些代码对旧的行为有依赖关系。这意味着，当进行垃圾收集时对logger配置将会丢失。例如：\npublic static void initLogging() throws Exception {\n Logger logger = Logger.getLogger(\"edu.umd.cs\");\n logger.addHandler(new FileHandler()); // call to change logger configuration\n logger.setUseParentHandlers(false); // another call to change logger configuration\n}\n该方法结束时logger的引用就丢失了，如果你刚刚结束调用initLogging方法后进行垃圾回收，logger的配置将会丢失（因为只有保持记录器弱引用）。\npublic static void main(String[] args) throws Exception {\n initLogging(); // adds a file handler to the logger\n System.gc(); // logger configuration lost\n Logger.getLogger(\"edu.umd.cs\").info(\"Some message\"); // this isn't logged to the file as expected\n}\n2.OBL: Method may fail to clean up stream or resource (OBL_UNSATISFIED_OBLIGATION)\n这种方法可能无法清除（关闭，处置）一个流，数据库对象，或其他资源需要一个明确的清理行动。\n一般来说，如果一个方法打开一个流或其他资源，该方法应该使用try / finally块来确保在方法返回之前流或资源已经被清除了。这种错误模式基本上和OS_OPEN_STREAM和ODR_OPEN_DATABASE_RESOURCE错误模式相同，但是是在不同在静态分析技术。我们正为这个错误模式的效用收集反馈意见。\n \n### 三、Bad practice代码实现中的一些坏习惯\n \n1.AM: Creates an empty jar file entry (AM_CREATES_EMPTY_JAR_FILE_ENTRY)\n调用putNextEntry()方法写入新的 jar 文件条目时立即调用closeEntry()方法。这样会造成JarFile条目为空。\n2.AM: Creates an empty zip file entry (AM_CREATES_EMPTY_ZIP_FILE_ENTRY)\n调用putNextEntry()方法写入新的 zip 文件条目时立即调用closeEntry()方法。这样会造成ZipFile条目为空。\n3.BC: Equals method should not assume anything about the type of its argument (BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS)\nequals(Object o)方法不能对参数o的类型做任何的假设。比较此对象与指定的对象。当且仅当该参数不为 null，并且是表示与此对象相同的类型的对象时，结果才为 true。\n4.BC: Random object created and used only once (DMI_RANDOM_USED_ONLY_ONCE)\n随机创建对象只使用过一次就抛弃\n5.BIT: Check for sign of bitwise operation (BIT_SIGNED_CHECK)\n检查位操作符运行是否合理\n((event.detail & SWT.SELECTED) > 0)\nIf SWT.SELECTED is a negative number, this is a candidate for a bug. Even when SWT.SELECTED is not negative, it seems good practice to use '!= 0' instead of '> 0'.\n6.CN: Class implements Cloneable but does not define or use clone method (CN_IDIOM)\n按照惯例，实现此接口的类应该使用公共方法重写 Object.clone（它是受保护的），以获得有关重写此方法的详细信息。此接口不 包含 clone 方法。因此，因为某个对象实现了此接口就克隆它是不可能的,应该实现此接口的类应该使用公共方法重写 Object.clone\n7.CN: clone method does not call super.clone() (CN_IDIOM_NO_SUPER_CALL)\n一个非final类型的类定义了clone()方法而没有调用super.clone()方法。例如：B扩展自A，如果B中clone方法调用了spuer.clone（），而A中的clone没有调用spuer.clone()，就会造成结果类型不准确。要求A的clone方法中调用spuer.clone()方法。\n8.CN: Class defines clone() but doesn't implement Cloneable (CN_IMPLEMENTS_CLONE_BUT_NOT_CLONEABLE)\n类中定义了clone方法但是它没有实现Cloneable接口\n9.Co: Abstract class defines covariant compareTo() method (CO_ABSTRACT_SELF)\n抽象类中定义了多个compareTo()方法，正确的是覆写Comparable中的compareTo方法，方法的参数为Object类型，如下例：\nint compareTo(T o)  比较此对象与指定对象的顺序。\n10.Co: Covariant compareTo() method defined (CO_SELF_NO_OBJECT)\n类中定义了多个compareTo()方法，正确的是覆写Comparable中的compareTo方法，方法的参数为Object类型\n11.DE: Method might drop exception (DE_MIGHT_DROP)\n方法可能抛出异常\n12.DE: Method might ignore exception (DE_MIGHT_IGNORE)\n方法可能忽略异常\n13.DMI: Don't use removeAll to clear a collection (DMI_USING_REMOVEALL_TO_CLEAR_COLLECTION)\n不要用removeAll方法去clear一个集合\n14.DP: Classloaders should only be created inside doPrivileged block (DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED)\n类加载器只能建立在特殊的方法体内\n15.Dm: Method invokes System.exit(...) (DM_EXIT)\n在方法中调用System.exit(...)语句，考虑用RuntimeException来代替\n16.Dm: Method invokes dangerous method runFinalizersOnExit (DM_RUN_FINALIZERS_ON_EXIT)\n在方法中调用了System.runFinalizersOnExit 或者Runtime.runFinalizersOnExit方法，因为这样做是很危险的。\n17.ES: Comparison of String parameter using == or != (ES_COMPARING_PARAMETER_STRING_WITH_EQ)\n用==或者!=方法去比较String类型的参数\n18.ES: Comparison of String objects using == or != (ES_COMPARING_STRINGS_WITH_EQ)\n用==或者！=去比较String类型的对象\n19.Eq: Abstract class defines covariant equals() method (EQ_ABSTRACT_SELF)\n20.Eq: Equals checks for noncompatible operand (EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS)\nequals方法检查不一致的操作。两个类根本就是父子关系而去调用equals方法去判读对象是否相等。\npublic boolean equals(Object o) {\n  if (o instanceof Foo)\n    return name.equals(((Foo)o).name);\n  else if (o instanceof String)\n    return name.equals(o);\n  else return false;\n21.Eq: Class defines compareTo(...) and uses Object.equals() (EQ_COMPARETO_USE_OBJECT_EQUALS)\n类中定义了compareTo方法但是继承了Object中的compareTo方法\n22.Eq: equals method fails for subtypes (EQ_GETCLASS_AND_CLASS_CONSTANT)\n类中的equals方法可能被子类中的方法所破坏，当使用类似于Foo.class == o.getClass()的判断时考虑用this.getClass() == o.getClass()来替换\n23.Eq: Covariant equals() method defined (EQ_SELF_NO_OBJECT)\n类中定义了多个equals方法。正确的做法是覆写Object中的equals方法，它的参数为Object类型的对象。\n24.FI: Empty finalizer should be deleted (FI_EMPTY)\n为空的finalizer方法应该删除。一下关于finalizer的内容省略\n25.GC: Unchecked type in generic call (GC_UNCHECKED_TYPE_IN_GENERIC_CALL)\nThis call to a generic collection method passes an argument while compile type Object where a specific type from the generic type parameters is expected. Thus, neither the standard Java type system nor static analysis can provide useful information on whether the object being passed as a parameter is of an appropriate type.\n26.HE: Class defines equals() but not hashCode() (HE_EQUALS_NO_HASHCODE)\n方法定义了equals方法却没有定义hashCode方法\n27.HE: Class defines hashCode() but not equals() (HE_HASHCODE_NO_EQUALS)\n 类定义了hashCode方法去没有定义equal方法\n28.HE: Class defines equals() and uses Object.hashCode() (HE_EQUALS_USE_HASHCODE)\n一个类覆写了equals方法，没有覆写hashCode方法，使用了Object对象的hashCode方法\n29.HE: Class inherits equals() and uses Object.hashCode() (HE_INHERITS_EQUALS_USE_HASHCODE)\n子类继承了父类的equals方法却使用了Object的hashCode方法\n30.IC: Superclass uses subclass during initialization (IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION)\n子类在父类未初始化之前使用父类对象实例\npublic class CircularClassInitialization {\n        static class InnerClassSingleton extends CircularClassInitialization {\nstatic InnerClassSingleton singleton = new InnerClassSingleton();\n        }        \n        static CircularClassInitialization foo = InnerClassSingleton.singleton;\n}\n31.IMSE: Dubious catching of IllegalMonitorStateException (IMSE_DONT_CATCH_IMSE)\n捕捉违法的监控状态异常，例如当没有获取到对象锁时使用其wait和notify方法\n32.ISC: Needless instantiation of class that only supplies static methods (ISC_INSTANTIATE_STATIC_CLASS)\n为使用静态方法而创建一个实例对象。调用静态方法时只需要使用类名+静态方法名就可以了。\n33.It: Iterator next() method can't throw NoSuchElementException (IT_NO_SUCH_ELEMENT)\n迭代器的next方法不能够抛出NoSuchElementException\n34.J2EE: Store of non serializable object into HttpSession (J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION)\n在HttpSession对象中保存非连续的对象\n35.JCIP: Fields of immutable classes should be final (JCIP_FIELD_ISNT_FINAL_IN_IMMUTABLE_CLASS)\n The class is annotated with net.jcip.annotations.Immutable, and the rules for that annotation require that all fields are final. .\n36.NP: Method with Boolean return type returns explicit null (NP_BOOLEAN_RETURN_NULL)\n返回值为boolean类型的方法直接返回null，这样会导致空指针异常\n37.NP: equals() method does not check for null argument (NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT)\n变量调用equals方法时没有进行是否为null的判断\n38.NP: toString method may return null (NP_TOSTRING_COULD_RETURN_NULL)\ntoString方法可能返回null\n39.Nm: Class names should start with an upper case letter (NM_CLASS_NAMING_CONVENTION)\n类的名称以大写字母名称开头\n40.Nm: Class is not derived from an Exception, even though it is named as such (NM_CLASS_NOT_EXCEPTION)\n类的名称中含有Exception但是却不是一个异常类的子类，这种名称会造成混淆\n41.Nm: Confusing method names (NM_CONFUSING)\n令人迷惑的方面命名\n42.Nm: Field names should start with a lower case letter (NM_FIELD_NAMING_CONVENTION)\n非final类型的字段需要遵循驼峰命名原则\n43.Nm: Use of identifier that is a keyword in later versions of Java (NM_FUTURE_KEYWORD_USED_AS_IDENTIFIER)\n验证是否是java预留关键字\n44.Nm: Use of identifier that is a keyword in later versions of Java (NM_FUTURE_KEYWORD_USED_AS_MEMBER_IDENTIFIER)\n验证是否时java中的关键字\n45.Nm: Method names should start with a lower case letter (NM_METHOD_NAMING_CONVENTION)\n方法名称以小写字母开头\n46.Nm: Class names shouldn't shadow simple name of implemented interface (NM_SAME_SIMPLE_NAME_AS_INTERFACE)\n实现同一接口实现类不能使用相同的名称，即使它们位于不同的包中\n47.Nm: Class names shouldn't shadow simple name of superclass (NM_SAME_SIMPLE_NAME_AS_SUPERCLASS)\n继承同一父类的子类不能使用相同的名称，即使它们位于不同的包中\n48.Nm: Very confusing method names (but perhaps intentional) (NM_VERY_CONFUSING_INTENTIONAL)\n很容易混淆的方法命名，例如方法的名称名称使用使用大小写来区别两个不同的方法。\n49.Nm: Method doesn't override method in superclass due to wrong package for parameter (NM_WRONG_PACKAGE_INTENTIONAL)\n由于错误引用了不同包中相同类名的对象而不能够正确的覆写父类中的方法\nimport alpha.Foo;\npublic class A {\n  public int f(Foo x) { return 17; }\n}\nimport beta.Foo;\npublic class B extends A {\n  public int f(Foo x) { return 42; }\n  public int f(alpha.Foo x) { return 27; }\n}\n50.ODR: Method may fail to close database resource (ODR_OPEN_DATABASE_RESOURCE)\n方法中可能存在关闭数据连接失败的情况\n51.OS: Method may fail to close stream (OS_OPEN_STREAM)\n方法中可能存在关闭流失败的情况\n52.OS: Method may fail to close stream on exception (OS_OPEN_STREAM_EXCEPTION_PATH)\n方法中可能存在关闭流时出现异常情况\n53.RC: Suspicious reference comparison to constant (RC_REF_COMPARISON_BAD_PRACTICE)\n当两者为不同类型的对象时使用equals方法来比较它们的值是否相等，而不是使用==方法。例如比较的两者为java.lang.Integer, java.lang.Float\n54.RC: Suspicious reference comparison of Boolean values (RC_REF_COMPARISON_BAD_PRACTICE_BOOLEAN)\n使用== 或者 !=操作符来比较两个 Boolean类型的对象，建议使用equals方法。\n55.RR: Method ignores results of InputStream.read() (RR_NOT_CHECKED)\nInputStream.read方法忽略返回的多个字符，如果对结果没有检查就没法正确处理用户读取少量字符请求的情况。\n56.RR: Method ignores results of InputStream.skip() (SR_NOT_CHECKED)\nInputStream.skip()方法忽略返回的多个字符，如果对结果没有检查就没法正确处理用户跳过少量字符请求的情况\n57.RV: Method ignores exceptional return value (RV_RETURN_VALUE_IGNORED_BAD_PRACTICE)\n方法忽略返回值的异常信息\n58.SI: Static initializer creates instance before all static final fields assigned (SI_INSTANCE_BEFORE_FINALS_ASSIGNED)\n在所有的static final字段赋值之前去使用静态初始化的方法创建一个类的实例。\n59.Se: Non-serializable value stored into instance field of a serializable class (SE_BAD_FIELD_STORE)\n非序列化的值保存在声明为序列化的的非序列化字段中\n60.Se: Comparator doesn't implement Serializable (SE_COMPARATOR_SHOULD_BE_SERIALIZABLE)\nComparator接口没有实现Serializable接口\n61.Se: Serializable inner class (SE_INNER_CLASS)\n序列化内部类\n62.Se: serialVersionUID isn't final (SE_NONFINAL_SERIALVERSIONID)\n关于UID类的检查内容省略\n63.Se: Class is Serializable but its superclass doesn't define a void constructor (SE_NO_SUITABLE_CONSTRUCTOR)\n子类序列化时父类没有提供一个void的构造函数\n64.Se: Class is Externalizable but doesn't define a void constructor (SE_NO_SUITABLE_CONSTRUCTOR_FOR_EXTERNALIZATION)\nExternalizable 实例类没有定义一个void类型的构造函数\n65.Se: The readResolve method must be declared with a return type of Object. (SE_READ_RESOLVE_MUST_RETURN_OBJECT)\nreadResolve从流中读取类的一个实例，此方法必须声明返回一个Object类型的对象\n66.Se: Transient field that isn't set by deserialization. (SE_TRANSIENT_FIELD_NOT_RESTORED)\nThis class contains a field that is updated at multiple places in the class, thus it seems to be part of the state of the class. However, since the field is marked as transient and not set in readObject or readResolve, it will contain the default value in any deserialized instance of the class.\n67.SnVI: Class is Serializable, but doesn't define serialVersionUID (SE_NO_SERIALVERSIONID)\n一个类实现了Serializable接口但是没有定义serialVersionUID类型的变量。序列化运行时使用一个称为 serialVersionUID 的版本号与每个可序列化类相关联，该序列号在反序列化过程中用于验证序列化对象的发送者和接收者是否为该对象加载了与序列化兼容的类。如果接收者加载的该对象的类的 serialVersionUID 与对应的发送者的类的版本号不同，则反序列化将会导致 InvalidClassException。可序列化类可以通过声明名为 \"serialVersionUID\" 的字段（该字段必须是静态 (static)、最终 (final) 的 long 型字段）显式声明其自己的 serialVersionUID： \n ANY-ACCESS-MODIFIER static final long serialVersionUID = 42L;\n68.UI: Usage of GetResource may be unsafe if class is extended (UI_INHERITANCE_UNSAFE_GETRESOURCE)\n当一个类被子类继承后不要使用this.getClass().getResource(...)来获取资源\n \n### 四、Correctness关于代码正确性相关方面的\n1.BC: Impossible cast (BC_IMPOSSIBLE_CAST)\n不可能的类转换，执行时会抛出ClassCastException\n2.BC: Impossible downcast (BC_IMPOSSIBLE_DOWNCAST)\n父类在向下进行类型转换时抛出ClassCastException\n3.BC: Impossible downcast of toArray() result (BC_IMPOSSIBLE_DOWNCAST_OF_TOARRAY)\n集合转换为数组元素时发生的类转换错误。\nThis code is casting the result of calling toArray() on a collection to a type more specific than Object[], as in: \nString[] getAsArray(Collection<String> c) {\n  return (String[]) c.toArray();\n  }\nThis will usually fail by throwing a ClassCastException. The toArray() of almost all collections return an Object[]. They can't really do anything else, since the Collection object has no reference to the declared generic type of the collection. \nThe correct way to do get an array of a specific type from a collection is to use c.toArray(new String[]); or c.toArray(new String[c.size()]); (the latter is slightly more efficient). \n4.BC: instanceof will always return false (BC_IMPOSSIBLE_INSTANCEOF)\n采用instaneof方法进行比较时总是返回false。前提是保证它不是由于某些逻辑错误造成的。\n5.BIT: Incompatible bit masks (BIT_AND)\n错误的使用&位操作符，例如(e & C)\n6.BIT: Check to see if ((...) & 0) == 0 (BIT_AND_ZZ)\n检查恒等的逻辑错误\n7.BIT: Incompatible bit masks (BIT_IOR)\n错误的使用|位操作符，例如(e | C)\n8.BIT: Check for sign of bitwise operation (BIT_SIGNED_CHECK_HIGH_BIT)\n检查逻辑运算符操作返回的标识。例如((event.detail & SWT.SELECTED) > 0)，建议采用!=0代替>0\n9.BOA: Class overrides a method implemented in super class Adapter wrongly (BOA_BADLY_OVERRIDDEN_ADAPTER)\n子类错误的覆写父类中用于适配监听其他事件的方法，从而导致当触发条件发生时不能被监听者调用\n10.Bx: Primitive value is unboxed and coerced for ternary operator (BX_UNBOXED_AND_COERCED_FOR_TERNARY_OPERATOR)\n在三元运算符操作时如果没有对值进行封装或者类型转换。例如：b ? e1 : e2\n11.DLS: Dead store of class literal (DLS_DEAD_STORE_OF_CLASS_LITERAL)\n以类的字面名称方式为一个字段赋值后再也没有去使用它，在1.4jdk中它会自动调用静态的初始化方法，而在jdk1.5中却不会去执行。\n12.DLS: Overwritten increment (DLS_OVERWRITTEN_INCREMENT)\n覆写增量增加错误i = i++\n13.DMI: Bad constant value for month (DMI_BAD_MONTH)\nhashNext方法调用next方法。\n14.DMI: Collections should not contain themselves (DMI_COLLECTIONS_SHOULD_NOT_CONTAIN_THEMSELVES)\n集合没有包含他们自己本身。\n15.DMI: Invocation of hashCode on an array (DMI_INVOKING_HASHCODE_ON_ARRAY)\n数组直接使用hashCode方法来返回哈希码。\nint [] a1 = new int[]{1,2,3,4};\n        System.out.println(a1.hashCode());\n        System.out.println(java.util.Arrays.hashCode(a1));\n16.DMI: Double.longBitsToDouble invoked on an int (DMI_LONG_BITS_TO_DOUBLE_INVOKED_ON_INT)\n17.DMI: Vacuous call to collections (DMI_VACUOUS_SELF_COLLECTION_CALL)\n集合的调用不能被感知。例如c.containsAll(c)总是返回true，而c.retainAll(c)的返回值不能被感知。\n18.Dm: Can't use reflection to check for presence of annotation without runtime retention (DMI_ANNOTATION_IS_NOT_VISIBLE_TO_REFLECTION)\nUnless an annotation has itself been annotated with @Retention(RetentionPolicy.RUNTIME), the annotation can't be observed using reflection (e.g., by using the isAnnotationPresent method). .\n19.Dm: Useless/vacuous call to EasyMock method (DMI_VACUOUS_CALL_TO_EASYMOCK_METHOD)\nWhile ScheduledThreadPoolExecutor inherits from ThreadPoolExecutor, a few of the inherited tuning methods are not useful for it. In particular, because it acts as a fixed-sized pool using corePoolSize threads and an unbounded queue, adjustments to maximumPoolSize have no useful effect.\n20.EC: equals() used to compare array and nonarray (EC_ARRAY_AND_NONARRAY)\n数组对象使用equals方法和非数组对象进行比较。即使比较的双方都是数组对象也不应该使用equals方法，而应该比较它们的内容是否相等使用java.util.Arrays.equals(Object[], Object[]);\n21.EC: equals(...) used to compare incompatible arrays (EC_INCOMPATIBLE_ARRAY_COMPARE)\n使用equls方法去比较类型不相同的数组。例如：String[] and StringBuffer[], or String[] and int[]\n22.EC: Call to equals() with null argument (EC_NULL_ARG)\n调用equals的对象为null\n23.EC: Call to equals() comparing unrelated class and interface (EC_UNRELATED_CLASS_AND_INTERFACE)\n使用equals方法比较不相关的类和接口\n24.EC: Call to equals() comparing different interface types (EC_UNRELATED_INTERFACES)\n调用equals方法比较不同类型的接口\n25.EC: Call to equals() comparing different types (EC_UNRELATED_TYPES)\n调用equals方法比较不同类型的类\n26.EC: Using pointer equality to compare different types (EC_UNRELATED_TYPES_USING_POINTER_EQUALITY)\nThis method uses using pointer equality to compare two references that seem to be of different types. The result of this comparison will always be false at runtime.\n27.Eq: equals method always returns false (EQ_ALWAYS_FALSE)\n使用equals方法返回值总是false\n28.Eq: equals method always returns true (EQ_ALWAYS_TRUE)\nequals方法返回值总是true\n29.Eq: equals method compares class names rather than class objects (EQ_COMPARING_CLASS_NAMES)\n使用equals方法去比较一个类的实例和类的类型\n30.Eq: Covariant equals() method defined for enum (EQ_DONT_DEFINE_EQUALS_FOR_ENUM)\nThis class defines an enumeration, and equality on enumerations are defined using object identity. Defining a covariant equals method for an enumeration value is exceptionally bad practice, since it would likely result in having two different enumeration values that compare as equals using the covariant enum method, and as not equal when compared normally. Don't do it.\n31.Eq: equals() method defined that doesn't override equals(Object) (EQ_OTHER_NO_OBJECT)\n类中定义的equals方法时不要覆写equals（Object）方法\n32.Eq: equals() method defined that doesn't override Object.equals(Object) (EQ_OTHER_USE_OBJECT)\n类中定义的equals方法时不要覆写Object中的equals（Object）方法\n33.Eq: equals method overrides equals in superclass and may not be symmetric (EQ_OVERRIDING_EQUALS_NOT_SYMMETRIC)\n34.Eq: Covariant equals() method defined, Object.equals(Object) inherited (EQ_SELF_USE_OBJECT)\n类中定义了一组equals方法，但是都是继承的java.lang.Object class中的equals(Object)方法\n35.FE: Doomed test for equality to NaN (FE_TEST_IF_EQUAL_TO_NOT_A_NUMBER)\nThis code checks to see if a floating point value is equal to the special Not A Number value (e.g., if (x == Double.NaN)). However, because of the special semantics of NaN, no value is equal to Nan, including NaN. Thus, x == Double.NaN always evaluates to false. To check to see if a value contained in x is the special Not A Number value, use Double.isNaN(x) (or Float.isNaN(x) if x is floating point precision).\n36.FS: Format string placeholder incompatible with passed argument (VA_FORMAT_STRING_BAD_ARGUMENT)\n错误使用参数类型来格式化字符串\n37.FS: The type of a supplied argument doesn't match format specifier (VA_FORMAT_STRING_BAD_CONVERSION)\n指定的格式字符串和参数类型不匹配，例如：String.format(\"%d\", \"1\")\n38.FS: MessageFormat supplied where printf style format expected (VA_FORMAT_STRING_EXPECTED_MESSAGE_FORMAT_SUPPLIED)\n但用String的format方法时实际调用了ＭｅｓｓａｇｅＦｏｒｍａｔ中干的格式化方法而引起格式化结果出错。\n39.FS: More arguments are passed than are actually used in the format string (VA_FORMAT_STRING_EXTRA_ARGUMENTS_PASSED)\n使用String的format方法时有非法的参数也经过了格式化操作。\n40.FS: Illegal format string (VA_FORMAT_STRING_ILLEGAL)\n格式化String对象语句错误\n41.FS: Format string references missing argument (VA_FORMAT_STRING_MISSING_ARGUMENT)\nString的format操作缺少必要的参数。\n42.FS: No previous argument for format string (VA_FORMAT_STRING_NO_PREVIOUS_ARGUMENT)\n格式字符串定义错误，例如：formatter.format(\"%<s %s\", \"a\", \"b\"); 抛出MissingFormatArgumentException异常\n43.GC: No relationship between generic parameter and method argument (GC_UNRELATED_TYPES)\nThis call to a generic collection method contains an argument with an incompatible class from that of the collection's parameter (i.e., the type of the argument is neither a supertype nor a subtype of the corresponding generic type argument). Therefore, it is unlikely that the collection contains any objects that are equal to the method argument used here. Most likely, the wrong value is being passed to the method.\nIn general, instances of two unrelated classes are not equal. For example, if the Foo and Bar classes are not related by subtyping, then an instance of Foo should not be equal to an instance of Bar. Among other issues, doing so will likely result in an equals method that is not symmetrical. For example, if you define the Foo class so that a Foo can be equal to a String, your equals method isn't symmetrical since a String can only be equal to a String. \nIn rare cases, people do define nonsymmetrical equals methods and still manage to make their code work. Although none of the APIs document or guarantee it, it is typically the case that if you check if a Collection<String> contains a Foo, the equals method of argument (e.g., the equals method of the Foo class) used to perform the equality checks. \n44.HE: Signature declares use of unhashable class in hashed construct (HE_SIGNATURE_DECLARES_HASHING_OF_UNHASHABLE_CLASS)\nA method, field or class declares a generic signature where a non-hashable class is used in context where a hashable class is required. A class that declares an equals method but inherits a hashCode() method from Object is unhashable, since it doesn't fulfill the requirement that equal objects have equal hashCodes.\n45.HE: Use of class without a hashCode() method in a hashed data structure (HE_USE_OF_UNHASHABLE_CLASS)\nA class defines an equals(Object) method but not a hashCode() method, and thus doesn't fulfill the requirement that equal objects have equal hashCodes. An instance of this class is used in a hash data structure, making the need to fix this problem of highest importance.\n46.ICAST: integral value cast to double and then passed to Math.ceil (ICAST_INT_CAST_TO_DOUBLE_PASSED_TO_CEIL)\nintegral的值转换为double后使用了Math.ceil方法\n47.ICAST: int value cast to float and then passed to Math.round (ICAST_INT_CAST_TO_FLOAT_PASSED_TO_ROUND)\nint 类型的值转换为float类型之后调用了Math.round方法\n48.IJU: JUnit assertion in run method will not be noticed by JUnit (IJU_ASSERT_METHOD_INVOKED_FROM_RUN_METHOD)\n在JUnit中的断言在run方法中不会被告知\n49.IJU: TestCase declares a bad suite method (IJU_BAD_SUITE_METHOD)\n在一个JUnit类中声明的一个suite()方法必须声明为\npublic static junit.framework.Test suite()\n或者\npublic static junit.framework.TestSuite suite()的形式。\n50.IL: A collection is added to itself (IL_CONTAINER_ADDED_TO_ITSELF)\n集合本身作为add方法的参数，这样会引起内容溢出。\n51.IL: An apparent infinite loop (IL_INFINITE_LOOP)\n方法的自调用引起的死循环\n52.IM: Integer multiply of result of integer remainder (IM_MULTIPLYING_RESULT_OF_IREM)\n和整数余数进行乘法运算。例如：i % 60 * 1000 是进行(i % 60) * 1000运算而不是 i % (60 * 1000)\n53.INT: Bad comparison of nonnegative value with negative constant (INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE)\n保证非负数和负数进行比较\n54.INT: Bad comparison of signed byte (INT_BAD_COMPARISON_WITH_SIGNED_BYTE)\n比较有符合数，要先把有符号数转换为无符合数再进行比较\n55.IO: Doomed attempt to append to an object output stream (IO_APPENDING_TO_OBJECT_OUTPUT_STREAM)\n宣布试图在对象的输出流处添加元素，如果你希望能够添加进一个对象的输出流中必须保证对象的输出流处于打开状态。\n56.IP: A parameter is dead upon entry to a method but overwritten (IP_PARAMETER_IS_DEAD_BUT_OVERWRITTEN)\nThe initial value of this parameter is ignored, and the parameter is overwritten here. This often indicates a mistaken belief that the write to the parameter will be conveyed back to the caller.\n传入参数的值被忽略，但是对传入值进行了修改，并返回给了调用者\n57.MF: Class defines field that masks a superclass field (MF_CLASS_MASKS_FIELD)\n子类中定义了和父类中同名的字段。在调用时会出错\n58.MF: Method defines a variable that obscures a field (MF_METHOD_MASKS_FIELD)\n在方法中定义的局部变量和类变量或者父类变量同名，从而引起字段混淆。\n59.NP: Null pointer dereference (NP_ALWAYS_NULL)\n对象赋为null值后 没有被重新赋值\n60.NP: Null pointer dereference in method on exception path (NP_ALWAYS_NULL_EXCEPTION)\nA pointer which is null on an exception path is dereferenced here.  This will lead to a NullPointerException when the code is executed.  Note that because FindBugs currently does not prune infeasible exception paths, this may be a false warning.\nAlso note that FindBugs considers the default case of a switch statement to be an exception path, since the default case is often infeasible.\n空指针引用上调用去除引用方法，将发生空指针异常\n61.NP: Method does not check for null argument (NP_ARGUMENT_MIGHT_BE_NULL)\n方法没有判断参数是否为空\n62.NP: close() invoked on a value that is always null (NP_CLOSING_NULL)\n一个为空的对象调用close方法\n63.NP: Null value is guaranteed to be dereferenced (NP_GUARANTEED_DEREF)\nThere is a statement or branch that if executed guarantees that a value is null at this point, and that value that is guaranteed to be dereferenced (except on forward paths involving runtime exceptions).\n在正常的null判断分支上，对象去除引用操作是受保护的不允许的\n64.NP: Value is null and guaranteed to be dereferenced on exception path (NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH)\nThere is a statement or branch on an exception path that if executed guarantees that a value is null at this point, and that value that is guaranteed to be dereferenced (except on forward paths involving runtime exceptions).\n65.NP: Method call passes null to a nonnull parameter (NP_NONNULL_PARAM_VIOLATION)\n方法中为null的参数没有被重新赋值\n        void test(){\nString ss = null;\nsya(ss);\n        }        \n        public void sya(String ad){\nad.getBytes();\n        }\n66.NP: Method may return null, but is declared @NonNull (NP_NONNULL_RETURN_VIOLATION)\n方法声明了返回值不能为空，但是方法中有可能返回null\n67.NP: A known null value is checked to see if it is an instance of a type (NP_NULL_INSTANCEOF)\n检查一个为null的值是否是想要的类型对象，而不是由于粗心或者逻辑错误引起的\n68.NP: Possible null pointer dereference (NP_NULL_ON_SOME_PATH)\n对象可能没有重新赋值\n69.NP: Possible null pointer dereference in method on exception path (NP_NULL_ON_SOME_PATH_EXCEPTION)\nA reference value which is null on some exception control path is dereferenced here.  This may lead to a NullPointerException when the code is executed.  Note that because FindBugs currently does not prune infeasible exception paths, this may be a false warning.\nAlso note that FindBugs considers the default case of a switch statement to be an exception path, since the default case is often infeasible.\n在异常null值处理分支调用的方法上，可能存在对象去除引用操作\n70.NP: Method call passes null for nonnull parameter (NP_NULL_PARAM_DEREF_ALL_TARGETS_DANGEROUS)\n方法参数中声明为nonnull类型的参数为null\nvoid test(){\nString ss = null;\nsya(ss);\n        }        \n        public void sya(@nonnull String ad){\nad.getBytes();\n        }\n71.NP: Store of null value into field annotated NonNull (NP_STORE_INTO_NONNULL_FIELD)\n为一个已经声明为不能为null值的属性赋值为null。\n72.Nm: Class defines equal(Object); should it be equals(Object)? (NM_BAD_EQUAL)\n类中定义了一个equal方法但是却不是覆写的Object对象的equals方法\n73.Nm: Class defines hashcode(); should it be hashCode()? (NM_LCASE_HASHCODE)\n类中定义了一个hashCode方法但是却不是覆写的Object中的hashCode方法\n74.Nm: Class defines tostring(); should it be toString()? (NM_LCASE_TOSTRING)\n类中定义了一个toString方法但是却不是覆写的Object中的toString方法\n75.Nm: Apparent method/constructor confusion (NM_METHOD_CONSTRUCTOR_CONFUSION)\n构造方法定义混乱，保证一个标准的构造函数。        例如：\n        SA(){        }\n        void SA(){\n        }\n76.Nm: Very confusing method names (NM_VERY_CONFUSING)\n混乱的方法命名，如getName和getname方法同时出现的时候\n77.Nm: Method doesn't override method in superclass due to wrong package for parameter (NM_WRONG_PACKAGE)\n方法因为取了不同包中的同名的对象而没有正确覆写父类中的同名方法\nimport alpha.Foo;\npublic class A {\n  public int f(Foo x) { return 17; }\n}\n\nimport beta.Foo;\npublic class B extends A {\n  public int f(Foo x) { return 42; }\n}\n78.QBA: Method assigns boolean literal in boolean expression (QBA_QUESTIONABLE_BOOLEAN_ASSIGNMENT)\n再if或者while表达式中使用boolean类型的值时应该使用==去判断，而不是采用=操作\n79.RC: Suspicious reference comparison (RC_REF_COMPARISON)\n比较两个对象值是否相等时应该采用equals方法，而不是==方法\n80.RE: Invalid syntax for regular expression (RE_BAD_SYNTAX_FOR_REGULAR_EXPRESSION)\n对正则表达式使用了错误的语法，会抛出未经检查的异常，表明正则表达式模式中的语法错误。\n81.RE: File.separator used for regular expression (RE_CANT_USE_FILE_SEPARATOR_AS_REGULAR_EXPRESSION)\n使用正则表达式使用了错误的文件分隔符，在windows系统中正则表达式不会匹配’\\’而应该使用'\\\\'\n82.RV: Random value from 0 to 1 is coerced to the integer 0 (RV_01_TO_INT)\n从0到1随机值被强制为整数值0。在强制得到一个整数之前，你可能想得到多个随机值。或使用Random.nextInt（n）的方法。\n83.RV: Bad attempt to compute absolute value of signed 32-bit hashcode (RV_ABSOLUTE_VALUE_OF_HASHCODE)\n此代码生成一个哈希码，然后计算该哈希码的绝对值。如果哈希码是Integer.MIN_VALUE的，那么结果将是负数（因为Math.abs（Integer.MIN_VALUE的）== Integer.MIN_VALUE的）。\n在2^ 32值之外字符串有一个Integer.MIN_VALUE的hashCode包括“polygenelubricants”，“GydZG_”和“，”DESIGNING WORKHOUSES “。\n84.RV: Bad attempt to compute absolute value of signed 32-bit random integer (RV_ABSOLUTE_VALUE_OF_RANDOM_INT)\n此代码生成一个随机的符号整数，然后计算该随机整数的绝对值。如果随机数生成数绝对值为Integer.MIN_VALUE的，那么结果将是负数（因为Math.abs（Integer.MIN_VALUE的）== Integer.MIN_VALUE的）。\n85.RV: Exception created and dropped rather than thrown (RV_EXCEPTION_NOT_THROWN)\n此代码创建一个异常（或错误）的对象，但不会用它做任何事情。例如：if (x < 0)\n  new IllegalArgumentException(\"x must be nonnegative\");\n这可能是程序员的意图抛出创建的异常：\nif (x < 0)\n  throw new IllegalArgumentException(\"x must be nonnegative\");\n86.RV: Method ignores return value (RV_RETURN_VALUE_IGNORED)\n该方法的返回值应该进行检查。这种警告通常出现在调用一个不可变对象的方法，认为它更新了对象的值。例如：String dateString = getHeaderField(name);\ndateString.trim();\n程序员似乎以为trim（）方法将更新dateString引用的字符串。但由于字符串是不可改变的，trim（）函数返回一个新字符串值，在这里它是被忽略了。该代码应更正：\nString dateString = getHeaderField(name);\ndateString = dateString.trim();\n87.RpC: Repeated conditional tests (RpC_REPEATED_CONDITIONAL_TEST)\n该代码包含对同一个条件试验了两次，两边完全一样例如：（如X == 0 | | x == 0）。可能第二次出现是打算判断别的不同条件（如X == 0 | | y== 0）。\n88.SA: Double assignment of field (SA_FIELD_DOUBLE_ASSIGNMENT)\n方法中的字段包含了双重任务，例如： \n int x;\n  public void foo() {\n   x = x = 17;\n  }\n这种为变量赋值是无用的，并可能表明一个逻辑错误或拼写错误。\n89.SA: Self assignment of field (SA_FIELD_SELF_ASSIGNMENT)\n方法中包含自己对自己赋值的字段。例如：\nint x;\n  public void foo() {\n    x = x;\n  }\n90.SA: Self comparison of field with itself (SA_FIELD_SELF_COMPARISON)\n字段自己进行自比较可能表明错误或逻辑错误。\n91.SA: Self comparison of value with itself (SA_LOCAL_SELF_COMPARISON)\n方法中对一个局部变量自身进行比较运算，并可说明错误或逻辑错误。请确保您是比较正确的事情。\n92.SA: Nonsensical self computation involving a variable (e.g., x & x) (SA_LOCAL_SELF_COMPUTATION)\n此方法对同一变量执行了荒谬的计算（如x&x或x-x）操作。由于计算的性质，这一行动似乎没有意义，并可能表明错误或逻辑错误。\n93.SF: Dead store due to switch statement fall through (SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH)\n在swtich中先前的case值因为swtich执行失败而被覆写，这就像是忘记使用break推出或者没有使用return语句放回先前的值一样。\n94.SF: Dead store due to switch statement fall through to throw (SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH_TO_THROW)\n在swtich中因为出现异常而忽略了对case值的保存。\n95.SIC: Deadly embrace of non-static inner class and thread local (SIC_THREADLOCAL_DEADLY_EMBRACE)\n如果是一个静态内部类。实际上，在内部类和当前线程有死锁的可能。由于内部类不是静态的，它保留了对外部类的引用。如果线程包含对一个内部类实例的引用，那么内外实例的实例都可以被获取，这样就不具备垃圾会回收的资格。\n96.SIO: Unnecessary type check done using instanceof operator (SIO_SUPERFLUOUS_INSTANCEOF)\n在进行instanceof操作时进行没有必要的类型检查\n97.STI: Unneeded use of currentThread() call, to call interrupted() (STI_INTERRUPTED_ON_CURRENTTHREAD)\n此方法调用Thread.currentThread（）调用，只需调用interrupted（）方法。由于interrupted（）是一个静态方法， Thread.interrupted（）更简单易用。\n98.STI: Static Thread.interrupted() method invoked on thread instance (STI_INTERRUPTED_ON_UNKNOWNTHREAD)\n调用不是当前线程对象的Thread.interrupted()方法，由于interrupted（）方法是静态的，interrupted方法将会调用一个和作者原计划不同的对象。\n99.Se: Method must be private in order for serialization to work (SE_METHOD_MUST_BE_PRIVATE)\n这个类实现了Serializable接口，并定义自定义序列化的方法/反序列化。但由于这种方法不能声明为private，将被序列化/反序列化的API忽略掉。\n100.Se: The readResolve method must not be declared as a static method. (SE_READ_RESOLVE_IS_STATIC)\n为使readResolve方法得到序列化机制的识别，不能作为一个静态方法来声明。\n101.UMAC: Uncallable method defined in anonymous class (UMAC_UNCALLABLE_METHOD_OF_ANONYMOUS_CLASS)\n在匿名类中定义了一个既没有覆写超类中方法也不能直接调用的方法。因为在其他类的方法不能直接引用匿名类声明的方法，似乎这种方法不能被调用，这种方法可能只是没有任何作用的代码，但也可能覆写超类中声明。\n102.UR: Uninitialized read of field in constructor (UR_UNINIT_READ)\n此构造方法中使用了一个尚未赋值的字段或属性。\n        String a;\n        public SA() {\nString abc = a;\nSystem.out.println(abc);\n        }\n103.UR: Uninitialized read of field method called from constructor of superclass (UR_UNINIT_READ_CALLED_FROM_SUPER_CONSTRUCTOR)\n方法被超类的构造函数调用时，在当前类中的字段或属性还没有被初始化。例如：\nabstract class A {\n  int hashCode;\n  abstract Object getValue();\n  A() {\n    hashCode = getValue().hashCode();\n    }\n  }\nclass B extends A {\n  Object value;\n  B(Object v) {\n    this.value = v;\n    }\n  Object getValue() {\n    return value;\n  }\n  }\n当B是创建时，A的构造函数将在B为value赋值之前触发，然而在A的初始化方法调用getValue方法时value这个变量还没有被初始化。\n104.USELESS_STRING: Invocation of toString on an array (DMI_INVOKING_TOSTRING_ON_ANONYMOUS_ARRAY)\n该代码调用上匿名数组的toString（）方法，产生的结果形如[@ 16f0472并没有实际的意义。考虑使用Arrays.toString方法来转换成可读的字符串，提供该数组的内容数组。例如：\nString[] a = { \"a\" };\nSystem.out.println(a.toString());\n//正确的使用为\nSystem.out.println(Arrays.toString(a));\n105.USELESS_STRING: Invocation of toString on an array (DMI_INVOKING_TOSTRING_ON_ARRAY)\n该代码调用上数组的toString（）方法，产生的结果形如[@ 16f0472并不能显示数组的真实内容。考虑使用Arrays.toString方法来转换成可读的字符串，提供该数组的内容数组\n106.UwF: Field only ever set to null (UWF_NULL_FIELD)\n字段的值总是为null值，所有读取该字段的值都为null。检查错误，如果它确实没有用就删除掉。\n107.UwF: Unwritten field (UWF_UNWRITTEN_FIELD\n此字段是永远不会写入值。所有读取将返回默认值。检查错误（如果它被初始化？），如果它确实没有用就删除掉。\n\n### 五：Performance关于代码性能相关方面的\n1.Bx: Primitive value is boxed and then immediately unboxed (BX_BOXING_IMMEDIATELY_UNBOXED)\n对原始值进行装箱，然后立即取消装箱。这可能是在一个未要求装箱的地方进行了手动装箱，从而迫使编译器进行立即撤消装箱的操作\n2.Bx: Primitive value is boxed then unboxed to perform primitive coercion (BX_BOXING_IMMEDIATELY_UNBOXED_TO_PERFORM_COERCION)\n对原始值进行装箱然后立即把它强制转换为另外一种原始类型。例如：\nnew Double(d).intValue()应该直接进行强制转换例如：(int) d\n3.Bx: Method allocates a boxed primitive just to call toString (DM_BOXED_PRIMITIVE_TOSTRING)\n仅仅为了调用封装类的toString()而对原始类型进行封装操作。比这种方法更有效的是调用封装类的toString(…)方法例如：\nnew Integer(1).toString()    替换为   Integer.toString(1)\nnew Long(1).toString()    替换为   Long.toString(1) \nnew Float(1.0).toString()    替换为   Float.toString(1.0) \nnew Double(1.0).toString()    替换为   Double.toString(1.0) \nnew Byte(1).toString()    替换为   Byte.toString(1) \nnew Short(1).toString()    替换为   Short.toString(1) \nnew Boolean(true).toString()    替换为   Boolean.toString(true)\n4.Bx: Method invokes inefficient floating-point Number constructor; use static valueOf instead (DM_FP_NUMBER_CTOR)\n使用new Double(double)方法总是会创建一个新的对象，然而使用Double.valueOf(double)方法可以把值保存在编辑器或者class library、JVM中。使用存储值的方式来避免对象的分配可以或得更好的代码性能\n除非类必须符合Java 1.5以前的JVM，否则请使用自动装箱或valueOf（）方法创建Double和Float实例。\n5.Bx: Method invokes inefficient Number constructor; use static valueOf instead (DM_NUMBER_CTOR)\n使用new Integer(int)方法总是会创建一个新的对象，然而使用Integer.valueOf(int)方法可以把值保存在编辑器或者class library、JVM中。使用存储值的方式来避免对象的分配可以或得更好的代码性能\n除非类必须符合Java 1.5以前的JVM，否则请使用自动装箱或valueOf（）方法创建Long, Integer, Short, Character, Byte实例。\n6.Dm: The equals and hashCode methods of URL are blocking (DMI_BLOCKING_METHODS_ON_URL)\n使用equals和hashCode方法来对url进行资源标识符解析时会引起堵塞。考虑使用java.net.URI来代替。\n7.Dm: Maps and sets of URLs can be performance hogs (DMI_COLLECTION_OF_URLS)\n方法或者字段使用url的map/set集合。因为equals方法或者hashCode方法来进行资源标识符解析时都会引起堵塞。考虑使用java.net.URI来代替。\n8.Dm: Method invokes inefficient Boolean constructor; use Boolean.valueOf(...) instead (DM_BOOLEAN_CTOR)\n使用new方法创建一个java.lang.Boolean类型能够的实例对象是浪费空间的，因为Boolean对象是不可变的而且只有两个有用的值。使用Boolean.valueOf()或者Java1.5中的自动装箱功能来创建一个Boolean实例。\n9.Dm: Explicit garbage collection; extremely dubious except in benchmarking code (DM_GC)\n在代码中显式的调用垃圾回收命名，这样做并不能起作用。在过去，有人在关闭操作或者finalize方法中调用垃圾回收方法导致了很多的性能浪费。这样大规模回收对象时会造成处理器运行缓慢。\n10.Dm: Use the nextInt method of Random rather than nextDouble to generate a random integer (DM_NEXTINT_VIA_NEXTDOUBLE)\n 如果r是一个java.util.Random对象，你可以使r.nextInt(n)生成一个0到n-1之前的随机数，而不是使用(int)(r.nextDouble() * n)\n11.Dm: Method invokes inefficient new String(String) constructor (DM_STRING_CTOR)\n使用java.lang.String(String)构造函数会浪费内存因为这种构造方式和String作为参数在功能上容易混乱。只是使用String直接作为参数的形式\n12.Dm: Method invokes toString() method on a String (DM_STRING_TOSTRING)\n调用String.toString()是多余的操作，只要使用String就可以了。\n13.Dm: Method invokes inefficient new String() constructor (DM_STRING_VOID_CTOR)\n使用没有参数的构造方法去创建新的String对象是浪费内存空间的，因为这样创建会和空字符串“”混淆。Java中保证完成相同的构造方法会产生描绘相同的String对象。所以你只要使用空字符串来创建就可以了。\n14.ITA: Method uses toArray() with zero-length array argument (ITA_INEFFICIENT_TO_ARRAY)\n当使用集合的toArray()方法时使用数组长度为0的数组作为参数。比这更有效的一种方法是\nmyCollection.toArray(new Foo[myCollection.size()])，如果数组的长度足够大就可以直接把集合中的内容包装到数组中直接返回从而避免了第二次创建一个新的数组来存放集合中值。\n15.SBSC: Method concatenates strings using + in a loop (SBSC_USE_STRINGBUFFER_CONCATENATION)\n在循环中构建一个String对象时从性能上讲使用StringBuffer来代替String对象\n例如：\n// This is bad\n  String s = \"\";\n  for (int i = 0; i < field.length; ++i) {\n    s = s + field[i];\n  }\n  // This is better\n  StringBuffer buf = new StringBuffer();\n  for (int i = 0; i < field.length; ++i) {\n    buf.append(field[i]);\n  }\n  String s = buf.toString();\n16.SS: Unread field: should this field be static? (SS_SHOULD_BE_STATIC)\n类中所包含的final属性字段在编译器中初始化为静态的值。考虑在定义时就把它定义为static类型的。\n17.UM: Method calls static Math class method on a constant value (UM_UNNECESSARY_MATH)\n在方法中使用了java.lang.Math的静态方法代替常量来使用，使用常量速度和准确度会更好。 以下为Math中的方法产生的值。\nMethod Parameter \nabs -any- \nacos 0.0 or 1.0 \nasin 0.0 or 1.0 \natan 0.0 or 1.0 \natan2 0.0 cbrt 0.0 or 1.0 \nceil -any- \ncos 0.0 \ncosh 0.0 \nexp 0.0 or 1.0 \nexpm1 0.0 \nfloor -any- \nlog 0.0 or 1.0 \nlog10 0.0 or 1.0 \nrint -any- \nround -any- \nsin 0.0 \nsinh 0.0 \nsqrt 0.0 or 1.0 \ntan 0.0 \ntanh 0.0 \ntoDegrees 0.0 or 1.0 \ntoRadians 0.0\n18.UPM: Private method is never called (UPM_UNCALLED_PRIVATE_METHOD)\n定义为Private类型方法从未被调用，应该被删除。\n19.UrF: Unread field (URF_UNREAD_FIELD)\n类中定义的属性从未被调用，建议删除。\n20.UuF: Unused field (UUF_UNUSED_FIELD)\n类中定义的属性从未被使用，建议删除。\n21.WMI: Inefficient use of keySet iterator instead of entrySet iterator (WMI_WRONG_MAP_ITERATOR)\n当方法中接受一个Map类型的参数时，使用keySet的迭代器比使用entrySet的迭代器效率要高。\n### 六：Internationalization关于代码国际化相关方面的\nDm: Consider using Locale parameterized version of invoked method (DM_CONVERT_CASE)\n使用平台默认的编码格式对字符串进行大小写转换，这可能导致国际字符的转换不当。使用以下方式对字符进行转换\nString.toUpperCase( Locale l )\nString.toLowerCase( Locale l )\n\n### 七：Multithreaded correctness关于代码多线程正确性相关方面的\n1.DL: Synchronization on Boolean could lead to deadlock (DL_SYNCHRONIZATION_ON_BOOLEAN)\n该代码同步一个封装的原始常量，例如一个Boolean类型。\nprivate static Boolean inited = Boolean.FALSE;\n...\n  synchronized(inited) { \n    if (!inited) {\n       init();\n       inited = Boolean.TRUE;\n       }\n     }\n...\n由于通常只存在两个布尔对象，此代码可能是同步的其他无关的代码中相同的对象，这时会导致反应迟钝和可能死锁\n2.DL: Synchronization on boxed primitive could lead to deadlock (DL_SYNCHRONIZATION_ON_BOXED_PRIMITIVE)\n该代码同步一个封装的原始常量，例如一个Integer类型。\nprivate static Integer count = 0;\n...\n  synchronized(count) { \n     count++;\n     }\n...\n由于Integer对象可以共享和保存，此代码可能是同步的其他无关的代码中相同的对象，这时会导致反应迟钝和可能死锁\n3.DL: Synchronization on interned String could lead to deadlock (DL_SYNCHRONIZATION_ON_SHARED_CONSTANT)\n同步String类型的常量时，由于它被JVM中多个其他的对象所共有，这样在其他代码中会引起死锁。\n4.DL: Synchronization on boxed primitive values (DL_SYNCHRONIZATION_ON_UNSHARED_BOXED_PRIMITIVE)\n同步一个显然不是共有封装的原始值，例如一个Integer类型的对象。例如：\nprivate static final Integer fileLock = new Integer(1);\n...\n  synchronized(fileLock) { \n     .. do something ..\n     }\n...\n它最后被定义为以下方式来代替：private static final Object fileLock = new Object();\n5.Dm: Monitor wait() called on Condition (DM_MONITOR_WAIT_ON_CONDITION)\n方法中以java.util.concurrent.locks.Condition对象调用wait（）。等待一个条件发生时应该使用在Condition接口中定义的await()方法。\n6.Dm: A thread was created using the default empty run method (DM_USELESS_THREAD)\n这个方法没有通过run方法或者具体声明Thread类，也没有通过一个Runnable对象去定义一个线程，而这个线程出来浪费资源却什么也没有去做。\n7.ESync: Empty synchronized block (ESync_EMPTY_SYNC)\n该代码包含一个空的同步块：synchronized() {}\n8.IS: Inconsistent synchronization (IS2_INCONSISTENT_SYNC)\n不合理的同步\n9.IS: Field not guarded against concurrent access (IS_FIELD_NOT_GUARDED)\n域不是良好的同步访问---\n此字段被标注为net.jcip.annotations.GuardedBy，但可以在某种程度上违反注释而去访问\n10.JLM: Synchronization performed on Lock (JLM_JSR166_LOCK_MONITORENTER)\n实现java.util.concurrent.locks.Lock的对象调用了同步的方法。应该这样处理，对象被锁定/解锁时使用acquire（）/ release（）方法而不是使用同步的方法。\n11.LI: Incorrect lazy initialization of static field (LI_LAZY_INIT_STATIC)\n静态域不正确的延迟初始化--\n这种方法包含了一个不同步延迟初始化的非volatile静态字段。因为编译器或处理器可能会重新排列指令，如果该方法可以被多个线程调用，线程不能保证看到一个完全初始化的对象。你可以让字段可变来解决此问题\n12.LI: Incorrect lazy initialization and update of static field (LI_LAZY_INIT_UPDATE_STATIC)\n这种方法包含一个不同步延迟初始化的静态字段。之后为字段赋值，对象存储到该位置后进一步更新或访问。字段后尽快让其他线程能够访问。如果该方法的进一步访问该字段为初始化对象提供服务，然后你有一个非常严重的多线程bug，除非别的东西阻止任何其他线程访问存储的对象，直到它完全初始化。\n即使你有信心，该方法是永远不会被多个线程调用时，在它的值还没有被充分初始化或移动，不把它设定为static字段时它可能会更好。\n13.ML: Method synchronizes on an updated field (ML_SYNC_ON_UPDATED_FIELD)\n对象获取一个可变字段时进行同步。这是没有意义的，因为不同的线程可以在不同的对象同步。\n14.MSF: Mutable servlet field (MSF_MUTABLE_SERVLET_FIELD)\n一个web服务一般只能创建一个servlet或者jsp的实例（例如：treates是一个单利类），它会被多个线程调用这个实例的方法服务于多个同时的请求。因此使用易变的字段属性产生竞争的情况。\n15.MWN: Mismatched notify() (MWN_MISMATCHED_NOTIFY)\n此方法调用Object.notify（）或Object.notifyAll（）而没有获取到该对象的对象锁。调用notify（）或notifyAll（）而没有持有该对象的对象锁，将导致IllegalMonitorStateException异常。\n16.MWN: Mismatched wait() (MWN_MISMATCHED_WAIT)\n此方法调用Object.wait()而没有获取到该对象的对象锁。调用wait（）而没有持有该对象的对象锁，将导致IllegalMonitorStateException异常。\n17.NP: Synchronize and null check on the same field. (NP_SYNC_AND_NULL_CHECK_FIELD)\n如果代码块是同步的，那么久不可能为空。如果是空，同步时就会抛出NullPointerException异常。最好是在另一个代码块中进行同步。\n18.No: Using notify() rather than notifyAll() (NO_NOTIFY_NOT_NOTIFYALL)\n调用notify（）而不是notifyAll（）方法。 Java的监控器通常用于多个条件。调用notify（）只唤醒一个线程，这意味着该线程被唤醒只是满足的当前的唯一条件。\n19.RS: Class's readObject() method is synchronized (RS_READOBJECT_SYNC)\n序列化类中定义了同步的readObject（）。通过定义，反序列化创建的对象只有一个线程可以访问，因此没有必要的readObject（）进行同步。如果的readObject（）方法本身造成对象对另一个线程可见，那么这本身就是不好的编码方式。\n20.Ru: Invokes run on a thread (did you mean to start it instead?) (RU_INVOKE_RUN)\n这种方法显式调用一个对象的run（）。一般来说，类是实现Runnable接口的，因为在一个新的线程他们将有自己的run（）方法，在这种情况下Thread.start（）方法调用是正确的。\n21.SC: Constructor invokes Thread.start() (SC_START_IN_CTOR)\n在构造函数中启动一个线程。如果类曾经被子类扩展过，那么这很可能是错的，因为线程将在子类构造之前开始启动。\n22.SP: Method spins on field (SP_SPIN_ON_FIELD)\n方法无限循环读取一个字段。编译器可合法悬挂宣读循环，变成一个无限循环的代码。这个类应该改变，所以使用适当的同步（包括等待和通知要求）\n23.STCAL: Call to static Calendar (STCAL_INVOKE_ON_STATIC_CALENDAR_INSTANCE)\n即使JavaDoc对此不包含暗示，而Calendars本身在多线程中使用就是不安全的。探测器发现当调用Calendars的实例时将会获得一个静态对象。\nCalendar rightNow = Calendar.getInstance();\n24.STCAL: Call to static DateFormat (STCAL_INVOKE_ON_STATIC_DATE_FORMAT_INSTANCE)\n在官方的JavaDoc，DateFormats多线程使用本事就是不安全的。探测器发现调用一个DateFormat的实例将会获得一个静态对象。\nmyString = DateFormat.getDateInstance().format(myDate);\n25.STCAL: Static Calendar (STCAL_STATIC_CALENDAR_INSTANCE)\nCalendar在多线程中本身就是不安全的，如果在线程范围中共享一个Calendarde 实例而不使用一个同步的方法在应用中就会出现一些奇怪的行为。在sun.util.calendar.BaseCalendar.getCalendarDateFromFixedDate()中会抛出ArrayIndexOutOfBoundsExceptions or IndexOutOfBoundsExceptions异常。\n26.STCAL: Static DateFormat (STCAL_STATIC_SIMPLE_DATE_FORMAT_INSTANCE)\nDateFormat 在多线程中本身就是不安全的，如果在线程范围中共享一个DateFormat的实例而不使用一个同步的方法在应用中就会出现一些奇怪的行为。\n27.SWL: Method calls Thread.sleep() with a lock held (SWL_SLEEP_WITH_LOCK_HELD)\n当持有对象时调用Thread.sleep（）。这可能会导致很差的性能和可扩展性，或陷入死锁，因为其他线程可能正在等待获得锁。调用wait（）是一个更好的主意，释放对象的持有以允许其他线程运行。\n28.UG: Unsynchronized get method, synchronized set method (UG_SYNC_SET_UNSYNC_GET)\n这个类包含类似命名的get和set方法。在set方法是同步方法和get方法是非同步方法。这可能会导致在运行时的不正确行为，因为调用的get方法不一定返回对象一致状态。 GET方法应该同步。\n29.UL: Method does not release lock on all paths (UL_UNRELEASED_LOCK)\n方法获得了当前的对象所，但是在方法中始终没有释放它。一个正确的示例如下：\n  Lock l = ...;\n    l.lock();\n    try {\n        // do something\n    } finally {\n        l.unlock();\n    }\n30.UL: Method does not release lock on all exception paths (UL_UNRELEASED_LOCK_EXCEPTION_PATH)\n方法获得了当前的对象所，但是在所有的异常处理中始终没有释放它。一个正确的示例如下：\n  Lock l = ...;\n    l.lock();\n    try {\n        // do something\n    } finally {\n        l.unlock();\n    }\n31.UW: Unconditional wait (UW_UNCOND_WAIT)\n方法中包含调用java.lang.Object.wait（），而却没有放到条件流程控制中。该代码应确认条件尚未满足之前等待;先前任何通知将被忽略。\n32.VO: A volatile reference to an array doesn't treat the array elements as volatile (VO_VOLATILE_REFERENCE_TO_ARRAY)\n声明一个变量引用数组，这可能不是你想要的。如果一个变量引用数组，那么对引用数组的读和写都是不安全的，但是数组元素不是变量。取得数组的变量值你可以使用java.util.concurrent包中的数组的原子性特性\n33.WL: Sychronization on getClass rather than class literal (WL_USING_GETCLASS_RATHER_THAN_CLASS_LITERAL)\n实例的方法中同步this.getClass()，如果这个类有子类集合，那么子类集合中的对象将会在这个类的各个子类上进行同步，这不是我们想要的效果，我们只要同步当前的类对象而不包含它的所有子类，可以同步类名.getClass()。例如，java.awt.Label的代码：\n     private static final String base = \"label\";\n     private static int nameCounter = 0;\n     String constructComponentName() {\n        synchronized (getClass()) {\n            return base + nameCounter++;\n        }\n     }\nLabel中的子类集合不可能在同一个子对象上进行同步，替换上面的方法为：\n    private static final String base = \"label\";\n     private static int nameCounter = 0;\n     String constructComponentName() {\n        synchronized (Label.class) {\n            return base + nameCounter++;\n        }\n     }\n34.WS: Class's writeObject() method is synchronized but nothing else is (WS_WRITEOBJECT_SYNC)\n这个类有一个writeObject（）方法是同步的，但是这个类中没有其他的同步方法。\n35.Wa: Condition.await() not in loop (WA_AWAIT_NOT_IN_LOOP)\n方法没有在循环中调用java.util.concurrent.await()。如果对象是用于多种条件，打算调用wait()方法的条件可能不是实际发生的。\n36.Wa: Wait not in loop (WA_NOT_IN_LOOP)\n这种方法包含调用java.lang.Object.wait（），而这并不是一个循环。如果监视器用于多个条件，打算调用wait()方法的条件可能不是实际发生的。\n\n### 八：Malicious codevulnerability关于恶意破坏代码相关方面的\n1.EI: May expose internal representation by returning reference to mutable object (EI_EXPOSE_REP)\n返回一个易变对象引用并把它保存在对象字段中时会暴露对象内部的字段描述，如果接受不守信任的代码访问或者没有检查就去改变易变对象的会涉及对象的安全和其他重要属性的安全。返回一个对象的新副本，在很多情况下更好的办法。\n2.EI2: May expose internal representation by incorporating reference to mutable object (EI_EXPOSE_REP2)\n此代码把外部可变对象引用存储到对象的内部表示。如果实例受到不信任的代码的访问和没有检查的变化危及对象和重要属性的安全。存储一个对象的副本，在很多情况下是更好的办法。\n3.FI: Finalizer should be protected, not public (FI_PUBLIC_SHOULD_BE_PROTECTED)\n一个类中的finalize（）方法必须声明为protected，而不能为public类型\n4.MS: Public static method may expose internal representation by returning array (MS_EXPOSE_REP)\n一个public类型的静态方法返回一个数组，可能引用内部属性的暴露。任何代码调用此方法都可以自由修改底层数组。一个解决办法是返回一个数组的副本。\n5.MS: Field should be both final and package protected (MS_FINAL_PKGPROTECT)\n一个静态字段可能被恶意代码或另外一个包所改变的。字段可以放到protected包中也可以定义为final类型的以避免此问题。\n6.MS: Field is a mutable array (MS_MUTABLE_ARRAY)\n一个定义为final类型的静态字段引用一个数组时它可以被恶意代码或在另其他包中所使用。这些代码可以自由修改数组的内容。\n7.MS: Field is a mutable Hashtable (MS_MUTABLE_HASHTABLE)\n一个定义为final类型的静态字段引用一个Hashtable时可以被恶意代码或者在其他包中被调用，这些方法可以修改Hashtable的值。\n8.MS: Field should be moved out of an interface and made package protected (MS_OOI_PKGPROTECT)\n将域尽量不要定义在接口中，并声明为包保护\n在接口中定义了一个final类型的静态字段，如数组或哈希表等易变对象。这些对象可以被恶意代码或者在其他包中被调用，为了解决这个问题，需要把它定义到一个具体的实体类中并且声明为保护类型以避免这种错误。\n9.MS: Field should be package protected (MS_PKGPROTECT)\n一个静态字段是可以改变的恶意代码或其他的包访问修改。可以把这种类型的字段声明为final类型的以防止这种错误。\n\n### 十：Dodgy关于代码运行期安全方面的\n1.XSS: Servlet reflected cross site scripting vulnerability (XSS_REQUEST_PARAMETER_TO_SEND_ERROR)\n在代码中在Servlet输出中直接写入一个HTTP参数，这会造成一个跨站点的脚本漏洞。\n2.XSS: Servlet reflected cross site scripting vulnerability (XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER)\n代码直接写入参数的HTTP服务器错误页（使用HttpServletResponse.sendError）。表达了类似的不受信任的输入会引起跨站点脚本漏洞。\n3.BC: Questionable cast to abstract collection (BC_BAD_CAST_TO_ABSTRACT_COLLECTION)\n在代码投把一个集合强制类型转换为一个抽象的集合（如list，set或map）。保证该对象类型和将要转换的类型是一致的。如果你只是想要便利一个集合，那么你就不必将它转换为Set或List。\n4.BC: Questionable cast to concrete collection (BC_BAD_CAST_TO_CONCRETE_COLLECTION)\n代码把抽象的集合（如List，Set，或Collection）强制转换为具体落实类型（如一个ArrayList或HashSet）。这可能不正确，也可能使您的代码很脆弱，因为它使得难以在今后的切换指向其他具体实现。除非你有特别理由这样做，否则只需要使用抽象的集合类。\n5.BC: Unchecked/unconfirmed cast (BC_UNCONFIRMED_CAST)\n强制类型转换操作没有经过验证，而且不是所有的此种类型装换过的类都可以再强制类型转换为原类型。在代码中需要进行逻辑判断以保证可以进行这样的操作。\n6.BC: instanceof will always return true (BC_VACUOUS_INSTANCEOF)\ninstanceof测试将始终返回真（除非被测试的值为空）。虽然这是安全，确保它是不是说明一些误解或其他一些逻辑错误。如果你真的想测试是空的价值，也许会更清楚这样做的更好空试验，而不是一个instanceof测试。\n7.BSHIFT: Unsigned right shift cast to short/byte (ICAST_QUESTIONABLE_UNSIGNED_RIGHT_SHIFT)\n无符号数右移后进行转换为short或者byte类型时可能会丢弃掉高位的值，这样的结果就是有符合数和无符号数无法区分（这取决于移位大小）\n8.CI: Class is final but declares protected field (CI_CONFUSED_INHERITANCE)\n这个类被声明为final的，而是字段属性却声明为保护类型的。由于是final类，它不能再被继承，而再声明为保护类型的很容易造成混淆。为了从外部能正确的使用它应该把它们声明为private或者public类型。\n9.DB: Method uses the same code for two branches (DB_DUPLICATE_BRANCHES)\n此方法使用相同的代码，以实现两个有条件的分支。检查以确保这是不是一个编码错误。\n10.DB: Method uses the same code for two switch clauses (DB_DUPLICATE_SWITCH_CLAUSES)\n他的方法使用相同的代码来实现两个switch的声明条款。这可能是重复代码的情况，但可能也显示出编码的错误。\n11.DLS: Dead store to local variable (DLS_DEAD_LOCAL_STORE)\n该指令为局部变量赋值，但在其后的没有对她做任何使用。通常，这表明一个错误，因为值从未使用过。\n12.DLS: Useless assignment in return statement (DLS_DEAD_LOCAL_STORE_IN_RETURN)\n本声明把一个局部变量放到方法的返回语句中。这对于方法中局部变量来说是没有意思的。\n13.DLS: Dead store of null to local variable (DLS_DEAD_LOCAL_STORE_OF_NULL)\n把一个本地变量赋值为null值，并且再也没有对这个变量做任何的操作。这样可能是为了垃圾回收，而是Java SE 6.0，这已不再需要。\n14.DMI: Code contains a hard coded reference to an absolute pathname (DMI_HARDCODED_ABSOLUTE_FILENAME)\n此代码包含文件对象为一个绝对路径名（例如，新的文件（“/ home/dannyc/workspace/j2ee/src/share/com/sun/enterprise/deployment”）;\n15.DMI: Non serializable object written to ObjectOutput (DMI_NONSERIALIZABLE_OBJECT_WRITTEN)\n代码中让一个非序列化的对象出现在ObjectOutput.writeObject()方法中，这样会引起一个错误。\n16.DMI: Invocation of substring(0), which returns the original value (DMI_USELESS_SUBSTRING)\n此代码调用了subString(0)方法，它将返回原来的值。\n17.Eq: Class doesn't override equals in superclass (EQ_DOESNT_OVERRIDE_EQUALS)\n子类定义了一个新的equals方法但是却不是覆写了父类本省的equals()方法。\n18.FE: Test for floating point equality (FE_FLOATING_POINT_EQUALITY)\n此操作比较两个浮点值是否相等。由于浮点运算可能会涉及到舍入，计算float和double值可能不准确。如果要求值必须准确，如货币值，可以考虑使用固定精度类型，如BigDecimal类型的值来比较\n19.FS: Non-Boolean argument formatted using %b format specifier (VA_FORMAT_STRING_BAD_CONVERSION_TO_BOOLEAN)\n使用%b去格式化Boolean类型的值不正确的但是它不会抛出异常，任何非空的值都会输出true，任何为空的值都会输出false\n20.IC: Initialization circularity (IC_INIT_CIRCULARITY)\n在引用两个相互调用为环状static方法去初始化一个实例时是错误的。\n21.ICAST: integral division result cast to double or float (ICAST_IDIV_CAST_TO_DOUBLE)\n整形数除法强制转换为double或者float类型。\nint x = 2;\nint y = 5;\n// Wrong: yields result 0.0\ndouble value1 =  x / y;\n// Right: yields result 0.4\ndouble value2 =  x / (double) y;\n22.ICAST: Result of integer multiplication cast to long (ICAST_INTEGER_MULTIPLY_CAST_TO_LONG)\n整形数做乘法运算结果转换为long值时如果采用\nlong convertDaysToMilliseconds(int days) { return 1000*3600*24*days; } 结果会因为超出整形的范围而出错。\n如果使用：\nlong convertDaysToMilliseconds(int days) { return 1000L*3600*24*days; } \n或者：\nstatic final long MILLISECONDS_PER_DAY = 24L*3600*1000;\n        long convertDaysToMilliseconds(int days) { return days * MILLISECONDS_PER_DAY; } \n都可以避免此问题。\n23.IM: Computation of average could overflow (IM_AVERAGE_COMPUTATION_COULD_OVERFLOW)\n代码中使用x % 2 == 1的方法去验证运算是否存在余数的情况，但是如果出现负数的情况就不起作用了。使用x & 1 == 1, or x % 2 != 0来代替\n24.INT: Vacuous comparison of integer value (INT_VACUOUS_COMPARISON)\n整形数进行比较结果总是不变。例如：x <= Integer.MAX_VALUE\n25.MTIA: Class extends Servlet class and uses instance variables (MTIA_SUSPECT_SERVLET_INSTANCE_FIELD)\n这个类扩展从Servlet类，并使用实例的成员变量。由于只有一个Servlet类的实例，并在多线程方式使用，这种模式有可能存在问题。考虑只使用方法的局部变量。\n26.MTIA: Class extends Struts Action class and uses instance variables (MTIA_SUSPECT_STRUTS_INSTANCE_FIELD)\n类扩展自Struts的Action类并使用这个实例的成员变量，因为在Struts框架中只存在一个Action实例对象并且使用在多线程的情况下很可能会出现问题。\n27.NP: Dereference of the result of readLine() without nullcheck (NP_DEREFERENCE_OF_READLINE_VALUE)\n对readLine()的结果值没有进行判空操作就去重新赋值，这样的操作可以会抛出空指针异常。\n28.NP: Immediate dereference of the result of readLine() (NP_IMMEDIATE_DEREFERENCE_OF_READLINE)\n对readLine()的结果立即赋值，这样的操作可以会抛出空指针异常。\n29.NP: Possible null pointer dereference due to return value of called method (NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE)\n方法的返回值没有进行是否为空的检查就重新赋值，这样可能会出现空指针异常。\n30.NP: Parameter must be nonnull but is marked as nullable (NP_PARAMETER_MUST_BE_NONNULL_BUT_MARKED_AS_NULLABLE)\n参数值在任何情况下都不能为空，但是有明确的注释它可以为空。\n31.NS: Potentially dangerous use of non-short-circuit logic (NS_DANGEROUS_NON_SHORT_CIRCUIT)\n代码中使用（& or |）代替（&& or ||）操作，这会造成潜在的危险。\n32.NS: Questionable use of non-short-circuit logic (NS_NON_SHORT_CIRCUIT)\n代码中使用（& or |）代替（&& or ||）操作，会引起不安全的操作\n33.PZLA: Consider returning a zero length array rather than null (PZLA_PREFER_ZERO_LENGTH_ARRAYS)\n考虑返回一个零长度的数组，而不是null值\n34.QF: Complicated, subtle or wrong increment in for-loop (QF_QUESTIONABLE_FOR_LOOP)\n确定这个循环是正确的变量递增，看起来，另一个变量被初始化，检查的循环。这是由于for循环中太复杂的定义造成的。\n35.RCN: Redundant comparison of non-null value to null (RCN_REDUNDANT_COMPARISON_OF_NULL_AND_NONNULL_VALUE)\n方法中包含一个不能为空的赋值还包含一个可以为空的赋值。冗余比较非空值为空。\n36.RCN: Redundant comparison of two null values (RCN_REDUNDANT_COMPARISON_TWO_NULL_VALUES)\n方法中对两个null值进行比较\n37.RCN: Redundant nullcheck of value known to be non-null (RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE)\n方法中对不为空的值进行为空的判断。\n38.REC: Exception is caught when Exception is not thrown (REC_CATCH_EXCEPTION)\n在try/catch块中捕获异常，但是异常没有在try语句中抛出而RuntimeException又没有明确的被捕获\n39.RI: Class implements same interface as superclass (RI_REDUNDANT_INTERFACES)\n子类和父类都实现了同一个接口，这种定义是多余的。\n40.RV: Method discards result of readLine after checking if it is nonnull (RV_DONT_JUST_NULL_CHECK_READLINE)\nreadLine方法的结果不为空时被抛弃\n41.RV: Remainder of 32-bit signed random integer (RV_REM_OF_RANDOM_INT)\n此代码生成一个随机的符号整数，然后计算另一个值的。由于随机数可以是负数，所以其余操作的结果也可以是负面的。考虑使用Random.nextInt（int）方法代替。\n42.SA: Double assignment of local variable (SA_LOCAL_DOUBLE_ASSIGNMENT)\n为一个局部变量两次赋值，这样是没有意义的。例如：\npublic void foo() {\n    int x,y;\n    x = x = 17;\n  }\n43.SA: Self assignment of local variable (SA_LOCAL_SELF_ASSIGNMENT)\n局部变量使用自身给自己赋值\npublic void foo() {\n    int x = 3;\n    x = x;\n  }\n44.SF: Switch statement found where one case falls through to the next case (SF_SWITCH_FALLTHROUGH)\nSwitch语句中一个分支执行后又执行了下一个分支。通常case后面要跟break 或者return语句来跳出。\n45.SF: Switch statement found where default case is missing (SF_SWITCH_NO_DEFAULT)\nSwitch没有默认情况下执行的case语句。\n46.Se: private readResolve method not inherited by subclasses (SE_PRIVATE_READ_RESOLVE_NOT_INHERITED)\n声明为private的序列化方法被子类继承\n47.UCF: Useless control flow (UCF_USELESS_CONTROL_FLOW)\n没有任何作用的条件语句。\nif (argv.length == 0) {\n        // TODO: handle this case\n        }\n48.UCF: Useless control flow to next line (UCF_USELESS_CONTROL_FLOW_NEXT_LINE)\n无效的条件控制语句，注意if (argv.length == 1);以“;”结尾，下面的语句无论是否满足都会运行。\nif (argv.length == 1);\n        System.out.println(\"Hello, \" + argv[0]);\n49.UwF: Field not initialized in constructor (UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR)\n字段从来没有在任何构造函数初始化，对象被创建后值为空。如果该字段未被定义就重新赋值会产生一个空指针异常。\n50.XFB: Method directly allocates a specific implementation of xml interfaces (XFB_XML_FACTORY_BYPASS)\n方法自定义了一种XML接口的实现类。最好是使用官方提供的工厂类来创建这些对象，以便可以在运行期中改变。例如：\njavax.xml.parsers.DocumentBuilderFactory\njavax.xml.parsers.SAXParserFactory\njavax.xml.transform.TransformerFactory\norg.w3c.dom.Document.createXXXX\n\n\n\n\n\n","source":"_posts/review/Findbug代码审查-缺陷和修改.md","raw":"---\ntitle: Findbug代码审查-缺陷和修改\ndate: 2017-05-30 16:43:49\ntags: [review]\ncategories: [review]\n---\n\n# FindBugs使用实践-缺陷和修改\nConfidence 是fingbug团队认为该代码导致bug的可能性。\n\n## 分类\n1 Malicious code vulnerability 恶意代码\n2 Performance 性能问题\n3 Security 安全性问题\n4 Dodgy code 小问题\n5 Correctness 代码的正确性\n6 Bad practice 不好的习惯\n7 Internationalization 国际化问题\n8 Experrimental 实验性问题\n无     Multithreaded currectness 线程问题\n\n## 常见问题\n#### 1 Bad practice 坏的实践\n一些不好的实践，下面列举几个： HE：类定义了equals()，却没有hashCode()；或类定义了equals()，却使用Object.hashCode()；或类定义了hashCode()，却没有equals()；或类定义了hashCode()，却使用Object.equals()；类继承了equals()，却使用Object.hashCode()。 \nSQL：Statement 的execute方法调用了非常量的字符串；或Prepared Statement是由一个非常量的字符串产生。 \nDE：方法终止或不处理异常，一般情况下，异常应该被处理或报告，或被方法抛出。 \nMalicious code vulnerability 可能受到的恶意攻击\n如果代码公开，可能受到恶意攻击的代码，下面列举几个： FI：一个类的finalize()应该是protected，而不是public的。MS：属性是可变的数组；属性是可变的Hashtable；属性应该是package protected的。\n#### 2 Correctness 一般的正确性问题\n可能导致错误的代码，下面列举几个： NP：空指针被引用；在方法的异常路径里，空指针被引用；方法没有检查参数是否null；null值产生并被引用；null值产生并在方法的异常路径被引用；传给方法一个声明为@NonNull的null参数；方法的返回值声明为@NonNull实际是null。 Nm：类定义了hashcode()方法，但实际上并未覆盖父类Object的hashCode()；类定义了tostring()方法，但实际上并未覆盖父类Object的toString()；很明显的方法和构造器混淆；方法名容易混淆。 SQL：方法尝试访问一个Prepared Statement的0索引；方法尝试访问一个ResultSet的0索引。 UwF：所有的write都把属性置成null，这样所有的读取都是null，这样这个属性是否有必要存在；或属性从没有被write。\n#### 3 Dodgy 危险的\n具有潜在危险的代码，可能运行期产生错误，下面列举几个： CI：类声明为final但声明了protected的属性。 DLS：对一个本地变量赋值，但却没有读取该本地变量；本地变量赋值成null，却没有读取该本地变量。 ICAST：整型数字相乘结果转化为长整型数字，应该将整型先转化为长整型数字再相乘。 INT：没必要的整型数字比较，如X <= Integer.MAX_VALUE。 NP：对readline()的直接引用，而没有判断是否null；对方法调用的直接引用，而方法可能返回null。 REC：直接捕获Exception，而实际上可能是RuntimeException。 ST：从实例方法里直接修改类变量，即static属性。\n#### 4 Performance 性能问题\n可能导致性能不佳的代码，下面列举几个： DM：方法调用了低效的Boolean的构造器，而应该用Boolean.valueOf(…)；用类似Integer.toString(1) 代替new Integer(1).toString()；方法调用了低效的float的构造器，应该用静态的valueOf方法。 SIC：如果一个内部类想在更广泛的地方被引用，它应该声明为static。 SS：如果一个实例属性不被读取，考虑声明为static。 UrF：如果一个属性从没有被read，考虑从类中去掉。 UuF：如果一个属性从没有被使用，考虑从类中去掉。\n#### 5 Multithreaded correctness 多线程的正确性多线程编程时，可能导致错误的代码，下面列举几个：\nESync：空的同步块，很难被正确使用。 MWN：错误使用notify()，可能导致IllegalMonitorStateException异常；或错误的使用wait()。 No：使用notify()而不是notifyAll()，只是唤醒一个线程而不是所有等待的线程。 SC：构造器调用了Thread.start()，当该类被继承可能会导致错误。\n#### 6 Internationalization 国际化当对字符串使用upper或lowercase方法，如果是国际的字符串，可能会不恰当的转换。\n\nAPI： http://findbugs.sourceforge.net/api/index.html\n技术手册： http://findbugs.sourceforge.net/manual/index.html\n更多请参见官网： http://findbugs.sourceforge.net/bugDescriptions.html\n##### 6.1、       ES_COMPARING_PARAMETER_STRING_WITH_EQ\n     ES: Comparison of String parameter using == or != (ES_COMPARING_PARAMETER_STRING_WITH_EQ)\nThis code compares a java.lang.String parameter for reference equality using the == or != operators. Requiring callers to pass only String constants or interned strings to a method is unnecessarily fragile, and rarely leads to measurable performance gains. Consider using the equals(Object) method instead.\n     使用 == 或者 != 来比较字符串或interned字符串，不会获得显著的性能提升，同时并不可靠，请考虑使用equals()方法。\n##### 6.2、       HE_EQUALS_NO_HASHCODE\n     HE: Class defines equals() but not hashCode() (HE_EQUALS_NO_HASHCODE)\nThis class overrides equals(Object), but does not override hashCode().  Therefore, the class may violate the invariant that equal objects must have equal hashcodes.\n     类定义了equals()方法但没有重写hashCode()方法，这样违背了相同对象必须具有相同的hashcodes的原则\n##### 6.3、IT_NO_SUCH_ELEMENT\n     It: Iterator next() method can't throw NoSuchElement exception (IT_NO_SUCH_ELEMENT)\nThis class implements the java.util.Iterator interface.  However, its next() method is not capable of throwing java.util.NoSuchElementException.  The next() method should be changed so it throws NoSuchElementException if is called when there are no more elements to return.\n     迭代器Iterator无法抛出NoSuchElement异常，类实现了java.util.Iterator接口，但是next()方法无法抛出java.util.NoSuchElementException异常，因此，next()方法应该做如此修改，当被调用时，如果没有element返回，则抛出NoSuchElementException异常\n##### 6.4、J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION\n     J2EE: Store of non serializable object into HttpSession (J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION)\nThis code seems to be storing a non-serializable object into an HttpSession. If this session is passivated or migrated, an error will result.\n     将没有实现serializable的对象放到HttpSession中，当这个session被钝化和迁移时，将会产生错误，建议放到HttpSession中的对象都实现serializable接口。\n##### 6.5、ODR_OPEN_DATABASE_RESOURCE\n     ODR: Method may fail to close database resource (ODR_OPEN_DATABASE_RESOURCE)\nThe method creates a database resource (such as a database connection or row set), does not assign it to any fields, pass it to other methods, or return it, and does not appear to close the object on all paths out of the method.  Failure to close database resources on all paths out of a method may result in poor performance, and could cause the application to have problems communicating with the database.\n     方法可能未关闭数据库资源，未关闭数据库资源将会导致性能变差，还可能引起应用与服务器间的通讯问题。\n##### 6.6、OS_OPEN_STREAM\n     OS: Method may fail to close stream (OS_OPEN_STREAM)\nThe method creates an IO stream object, does not assign it to any fields, pass it to other methods that might close it, or return it, and does not appear to close the stream on all paths out of the method.  This may result in a file descriptor leak.  It is generally a good idea to use a finally block to ensure that streams are closed.\n     方法可能未关闭stream，方法产生了一个IO流，却未关闭，将会导致文件描绘符的泄漏，建议使用finally block来确保io stream被关闭。\n##### 6.7、       DMI_CALLING_NEXT_FROM_HASNEXT\n     DMI: hasNext method invokes next (DMI_CALLING_NEXT_FROM_HASNEXT)\nThe hasNext() method invokes the next() method. This is almost certainly wrong, since the hasNext() method is not supposed to change the state of the iterator, and the next method is supposed to change the state of the iterator.\n##### 6.8、       IL_INFINITE_LOOP\n     IL: An apparent infinite loop (IL_INFINITE_LOOP)\nThis loop doesn't seem to have a way to terminate (other than by perhaps throwing an exception).\n     明显的无限循环.\n##### 6.9、       IL_INFINITE_RECURSIVE_LOOP\n     IL: An apparent infinite recursive loop (IL_INFINITE_RECURSIVE_LOOP)\nThis method unconditionally invokes itself. This would seem to indicate an infinite recursive loop that will result in a stack overflow.\n     明显的无限迭代循环,将导致堆栈溢出.\n##### 6.10、   WMI_WRONG_MAP_ITERATOR\n     WMI: Inefficient use of keySet iterator instead of entrySet iterator (WMI_WRONG_MAP_ITERATOR)\nThis method accesses the value of a Map entry, using a key that was retrieved from a keySet iterator. It is more efficient to use an iterator on the entrySet of the map, to avoid the Map.get(key) lookup.\n     使用了keySet iterator和Map.get(key)来获取Map值,这种方式效率低,建议使用entrySet的iterator效率更高.\n##### 6.11、   IM_BAD_CHECK_FOR_ODD\n     IM: Check for oddness that won't work for negative numbers (IM_BAD_CHECK_FOR_ODD)\nThe code uses x % 2 == 1 to check to see if a value is odd, but this won't work for negative numbers (e.g., (-5) % 2 == -1). If this code is intending to check for oddness, consider using x & 1 == 1, or x % 2 != 0.\n     奇偶检测逻辑,未考虑负数情况.\n#### 7.实际项目中Bug类型统计\n##### 7.1、       Call to equals() comparing different types\nid : EC_UNRELATED_TYPES, type : EC, category : CORRECTNESS This method calls equals(Object) on two references of different class types with no common subclasses. Therefore, the objects being compared are unlikely to be members of the same class at runtime (unless some application classes were not analyzed, or dynamic class loading can occur at runtime). According to the contract of equals(), objects of different classes should always compare as unequal; therefore, according to the contract defined by java.lang.Object.equals(Object), the result of this comparison will always be false at runtime.\n原因分析：\n这缺陷的意思是，大部分都是类型永远不会有这种情况， 比如a为DOUBLE类型所以EQUALS只匹配字符串 if(a.equals())或if(a.quals())这类判断是根本不会有用的；\n示例：if(\"1\".equals(DAOValue.valueofSuccess()))\n##### 7.2、       Dead store to local variable \nid: DLS_DEAD_LOCAL_STORE, type: DLS, category: STYLE\nThis instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used.\nNote that Sun's javac compiler often generates dead stores for final local variables. Because FindBugs is a bytecode-based tool, there is no easy way to eliminate these false positives.\n原因分析：\nDLS问题指的是给本地变量赋了一个值，但随后的代码并没有用到这个值。\n##### 7.3、       Method call passes null for nonnull parameter\nid: NP_NULL_PARAM_DEREF, type: NP, category: CORRECTNESS\nThis method call passes a null value for a nonnull method parameter. Either the parameter is annotated as a parameter that should always be nonnull, or analysis has shown that it will always be dereferenced.\n原因分析：对参数为null的情况未作处理。\n例如：\n\n```public void method1() {\n    String ip = null;\n    try {\n        ip = InetAddress.getLocalHost().getHostAddress();\n    } catch (UnknownHostException e) {\n        e.printStackTrace();\n    }\n    long ipCount = countIpAddress(ip);//可能会传入空引用 \n    //....\n}\n\nlong countIpAddress(String ip) {\n    long ipNum = 0;\n    String[] ipArray = ip.split(\"\\\\.\");\n}\n```\n\n```public void method1() {\n        String ip = null;\n        try {\n            ip = InetAddress.getLocalHost().getHostAddress();\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        }\n        long ipCount = countIpAddress(ip);//可能会传入空引用\n        //....\n    }\n\n    long countIpAddress(String ip) {\n        long ipNum = 0;\n        if(ip==null){\n            return 0;//抛出异常\n        }\n        String[] ipArray = ip.split(\"\\\\.\");\n    }\n```\n对于接口需要对参数校验合法性\n\n##### 7.4、Method with Boolean return type returns explicit null  \nid: NP_BOOLEAN_RETURN_NULL, type: NP, category: BAD_PRACTICE\nA method that returns either Boolean.TRUE, Boolean.FALSE or null is an accident waiting to happen. This method can be invoked as though it returned a value of type boolean, and the compiler will insert automatic unboxing of the Boolean value. If a null value is returned, this will result in a NullPointerException.\n原因分析：\n方法如果定义为返回类型Boolean，则可以返回Boolean.TRUE, Boolean.FALSE or null （如果 return 的是 true or  false， 则AutoBoxing 成 Boolean.TRUE, Boolean.FALSE）。因为JDK 支持 基本类型和装箱类型的自动转化， 所以下面的代码中：\nboolean result = test_NP_BOOLEAN_RETURN_NULL();\n因为此时test_NP_BOOLEAN_RETURN_NULL() 返回的是NULL， 所以 JDK 做 automatic unboxing 的操作时， 即调用了 object. booleanValue() 方法时，抛出了空指针。\n改成：boolean result = test_NP_BOOLEAN_RETURN_NULL()==null?false:true;\n##### 7.5、       No relationship between generic parameter and method argument\nid: GC_UNRELATED_TYPES, type: GC, category: CORRECTNESS\nThis call to a generic collection method contains an argument with an incompatible class from that of the collection's parameter (i.e., the type of the argument is neither a supertype nor a subtype of the corresponding generic type argument). Therefore, it is unlikely that the collection contains any objects that are equal to the method argument used here. Most likely, the wrong value is being passed to the method.\nIn general, instances of two unrelated classes are not equal. For example, if the Foo and Bar classes are not related by subtyping, then an instance of Foo should not be equal to an instance of Bar. Among other issues, doing so will likely result in an equals method that is not symmetrical. For example, if you define the Foo class so that a Foo can be equal to a String, your equals method isn't symmetrical since a String can only be equal to a String.\nIn rare cases, people do define nonsymmetrical equals methods and still manage to make their code work. Although none of the APIs document or guarantee it, it is typically the case that if you check if a Collection<String> contains a Foo, the equals method of argument (e.g., the equals method of the Foo class) used to perform the equality checks.\n原因分析：调用Collection类中的contains方法比较时，所比较的两个参数类型不致；\n\n##### 7.6、       Null pointer dereference in method on exception path\nid: NP_ALWAYS_NULL_EXCEPTION, type: NP, category: CORRECTNESS\nA pointer which is null on an exception path is dereferenced here.  This will lead to a NullPointerException when the code is executed.  Note that because FindBugs currently does not prune infeasible exception paths, this may be a false warning.\nAlso note that FindBugs considers the default case of a switch statement to be an exception path, since the default case is often infeasible.\n原因分析：在异常处理时，调用一个空对象的方法时可能引起空指针异常。\n##### 7.7、       Nullcheck of value previously dereferenced\nid: RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE, type:RCN, category: CORRECTNESS\nA value is checked here to see whether it is null, but this value can't be null because it was previously dereferenced and if it were null a null pointer exception would have occurred at the earlier dereference. Essentially, this code and the previous dereference disagree as to whether this value is allowed to be null. Either the check is redundant or the previous dereference is erroneous.\n原因分析：前面获取的对象，现在引用的时候没有交验是否为null。\n\n##### 7.8、       Possible null pointer dereference\nid: NP_NULL_ON_SOME_PATH, type: NP, category: CORRECTNESS\nThere is a branch of statement that, if executed, guarantees that a null value will be dereferenced, which would generate a NullPointerException when the code is executed. Of course, the problem might be that the branch or statement is infeasible and that the null pointer exception can't ever be executed; deciding that is beyond the ability of FindBugs.\n原因分析：可能存在空引用。\n \n##### 7.9、       Possible null pointer dereference in method on exception path\nid: NP_NULL_ON_SOME_PATH_EXCEPTION, type: NP, category:CORRECTNESS\nA reference value which is null on some exception control path is dereferenced here.  This may lead to a NullPointerException when the code is executed.  Note that because FindBugs currently does not prune infeasible exception paths, this may be a false warning.\nAlso note that FindBugs considers the default case of a switch statement to be an exception path, since the default case is often infeasible.\n原因分析：\n代码调用时， 遇到异常分支， 可能造成一个对象没有获得赋值依旧保持NULL空指针。 接下来如果对这个对象有引用， 可能造成NullPointerException 空指针异常。\n例如：\n\n##### 7.10、   Test for floating point equality\nid: FE_FLOATING_POINT_EQUALITY, type: FE, category: STYLE\nThis operation compares two floating point values for equality. Because floating point calculations may involve rounding, calculated float and double values may not be accurate. For values that must be precise, such as monetary values, consider using a fixed-precision type such as BigDecimal. For values that need not be precise, consider comparing for equality within some range, for example: if ( Math.abs(x - y) < .0000001 ). See the java Language Specification, section 4.2.4.\n原因分析：\nFloat类型的数据比较时，会存在的定的误差值，用!=来比较不是很准确，建议比较两个数的绝对值是否在一定的范围内来进行比较。如，if ( Math.abs(x - y) < .0000001 )\n例如：\n \n```  if(kpje.doubleValue()!=Doble.valueOf(coreCrdeInfo.getOrderpayInfo().getyeje（）)){\n        return ResultVo.valueOfError(\"订单编号\");\n    }\n\n```\n##### 7.11、   Useless assignment in return statement\nid: DLS_DEAD_LOCAL_STORE_IN_RETURN, type: DLS, category: STYLE\nThis statement assigns to a local variable in a return statement. This assignment has effect. Please verify that this statement does the right thing.\n原因分析：\n在return的对象中，没有必要通过对象赋值再进行返回。\n例如：\n\n``` DAOValue daoValue = DAOValue.valueof(false,-1,\"批量删除联系人业务大类信息失败\");\n    if(lxrCpdlVoList.size()==0){\n        return daoValue = DAOValue.valueof(true,1,\"没有批量删除联系人业务大类信息失败\");\n    }\n```\n##### 7.12、   Write to static field from instance method\nid: ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD, type: ST, category:STYLE\nThis instance method writes to a static field. This is tricky to get correct if multiple instances are being manipulated, and generally bad practice.\n原因分析：向static字段中写入值。\n例如： \n``` private static DBRBO dbrBO; \n public final void refresh() { \n        danskeBankBO = null; \n        dbrBO = null; \n        fileAndPathBO = null; \n    }\n``` \n建议改为：去掉static。\n##### 7.13、   Incorrect lazy initialization and update of static field\nid: LI_LAZY_INIT_UPDATE_STATIC, type: LI, category: MT_CORRECTNESS\nThis method contains an unsynchronized lazy initialization of a static field. After the field is set, the object stored into that location is further updated or accessed. The setting of the field is visible to other threads as soon as it is set. If the futher accesses in the method that set the field serve to initialize the object, then you have a very seriousmultithreading bug, unless something else prevents any other thread from accessing the stored object until it is fully initialized.\nEven if you feel confident that the method is never called by multiple threads, it might be better to not set the static field until the value you are setting it to is fully populated/initialized.\n原因分析：\n该方法的初始化中包含了一个迟缓初始化的静态变量。你的方法引用了一个静态变量，估计是类静态变量，那么多线程调用这个方法时，你的变量就会面临线程安全的问题了，除非别的东西阻止任何其他线程访问存储对象从直到它完全被初始化。\n##### 7.14、   Method ignores return value\nid: RV_RETURN_VALUE_IGNORED, type: RV, category: CORRECTNESS\nThe return value of this method should be checked. One common cause of this warning is to invoke a method on an immutable object, thinking that it updates the object. For example, in the following code fragment,\nString dateString = getHeaderField(name);\ndateString.trim();\nthe programmer seems to be thinking that the trim() method will update the String referenced by dateString. But since Strings are immutable, the trim() function returns a new String value, which is being ignored here. The code should be corrected to:\nString dateString = getHeaderField(name);\ndateString = dateString.trim();\n原因分析：方法忽略了设置返回值。\n例如：\n \n```String dateString = getHeaderField(name);\n    dateString.trim();\n    \n    if(CustomActionEnum.Agee_SRT.equals(operationType)||CustomActionEnum.DISSAgee_SRT.equals(operationType){\n        //....\n    }\n```\n##### 7.15、   Method might ignore exception\nid: DE_MIGHT_IGNORE, type: DE, category: BAD_PRACTICE\nThis method might ignore an exception.Â  In general, exceptions should be handled or reported in some way, or they should be thrown out of the method.\n原因分析：应该将异常 处理、打印或者抛出\n例如：\n```try{\n     //....\n }catch(Exception e){\n     \n }\n```\n\n##### 7.16、   Unwritten field\nid: UWF_UNWRITTEN_FIELD, type: UwF, category: CORRECTNESS\nThis field is never written.Â  All reads of it will return the default value. Check for errors (should it have been initialized?), or remove it if it is useless.\n原因分析：从未被初始化的变量，调用它时，将返回默认值，要么初始化，要么删掉它。\n例如：\n```try{\n        //....\n    }catch(Exception e){\n        \n    }\n```\n\n##### 7.17、   Value is null and guaranteed to be dereferenced on exception path\nid: NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH, type: NP, category:CORRECTNESS\nThere is a statement or branch on an exception path that if executed guarantees that a value is null at this point, and that value that is guaranteed to be dereferenced (except on forward paths involving runtime exceptions).\n原因分析：exception分支上，存在引用一个null对象的方法，引发空指针异常。\n例如：\n``` PrintWriter out = null;\n    try{\n        response.setContentType(\"text/html;charset=GBK\");\n        response.setHeader(\"Cache-Control;no-cache\");\n        out = response.getWriter();\n        out.flush();\n    }catch(Exception ex){\n        logger.debug(\"获取树的XML代码出错。\"+ex.getMessage());\n    }finally{\n        out.close();//out可能为空\n    }\n```\n\n##### 7.18、   Very confusing method names\nid: NM_VERY_CONFUSING, type: Nm, category: CORRECTNESS\nThe referenced methods have names that differ only by capitalization. This is very confusing because if the capitalization were identical then one of the methods would override the other.\n原因分析：被引用的方法中存在容易混淆的变量。\n例如：fzgsdm改成 fzgsDm 即可。\n \n```public String getFzgsdm() {\n    return getFzgsdm;\n}\n```\n\n##### 7.19、   Method invokes inefficient new String() constructor\nid: DM_STRING_VOID_CTOR, type: Dm, category: Performance Creating a new java.lang.String object using the no-argument constructor wastes memory because the object so created will be functionally indistinguishable from the empty string constant \"\".  Java guarantees that identical string constants will be represented by the same String object.  Therefore, you should just use the empty string constant directly.\n原因分析：不使用new String()定义空的字符串\n例如：\n  \n```String alarmCodeCond = new String();\n应当\nString alarmCodeCond = \"\";\n```      \n\n##### 7.20、   Load of known null value\nid: NP_LOAD_OF_KNOWN_NULL_VALUE, type: Np, category: Dodgy\nThe variable referenced at this point is known to be null due to an earlier check against null. Although this is valid, it might be a mistake (perhaps you intended to refer to a different variable, or perhaps the earlier check to see if the variable is null should have been a check to see if it was nonnull).\n原因分析：null值的不当使用。\n例如：\n\n``` \nif(devIds ==null && devIds.size()==0){ //.....} \n\nif(null ==tempList||tempList.size()!=0){ //.....}\n\nif(batchNo ==null){\n   throw new Exception(\"the No. \"+batchNo + \"is not exists1\"）)\n}\n```\n##### 7.21、   Method concatenates strings using + in a loop  \nid: SBSC_USE_STRINGBUFFER_CONCATENATION, type: SBSC, category: Performance\nThe method seems to be building a String using concatenation in a loop. In each iteration, the String is converted to a StringBuffer/StringBuilder, appended to, and converted back to a String. This can lead to a cost quadratic in the number of iterations, as the growing string is recopied in each iteration. Better performance can be obtained by using a StringBuffer (or StringBuilder in Java 1.5) explicitly.\nFor example:\n  // This is bad\n  String s = \"\";\n  for (int i = 0; i < field.length; ++i) {\n    s = s + field[i];\n  }\n  // This is better\n  StringBuffer buf = new StringBuffer();\n  for (int i = 0; i < field.length; ++i) {\n    buf.append(field[i]);\n  }\n  String s = buf.toString();\n原因分析：在循环里使用字符串连接，效率低，应该使用StringBuilder/StringBuffer\n \n### Bug列表\n#### BUG-0001\nBug: Field only ever set to null: com.bettersoft.admin.BtCorpManager.ps \nAll writes to this field are of the constant value null, and thus all reads of the field will return null. Check for errors, or remove it if it is useless.\nConfidence: Normal, Rank: Troubling (12)\nPattern: UWF_NULL_FIELD \nType: UwF, Category: CORRECTNESS (Correctness)\n代码片段：、\n```public class BtCorpManager {\n    private BtCorp btcorp=null;\n    private Connection con = null;\n    private Statement st = null;\n    private PreparedStatement ps = null;\n    private ResultSet rs = null;\n    private void setConnection(String centerno) throws Exception{\n        //con = DBManager.getConnection(centerno);\n        con = DBManager.getConnection();\n    }\n```\n解释说明：在BtCorpManager类里面定了一个私有的成员变量PreparedStatement ps,但是这个成员变量ps在实例范围内没有得到任何的初始化(采用默认的构造方法)，始终为null,所以在实例范围内使用该成员变量时，如果不先对其进行初始化操作或者无意识的行为忘了初始化操作，那肯定是要报空指针异常，所以这无疑是一个bug \n推荐修改： 自己看着办\n \n#### BUG-0002\nBug: Nullcheck of form at line 36 of value previously dereferenced in com.bettersoft.admin.CorpEditAction.execute(ActionMapping, ActionForm, HttpServletRequest, HttpServletResponse)\nA value is checked here to see whether it is null, but this value can't be null because it was previously dereferenced and if it were null a null pointer exception would have occurred at the earlier dereference. Essentially, this code and the previous dereference disagree as to whether this value is allowed to be null. Either the check is redundant or the previous dereference is erroneous.\nConfidence: High, Rank: Scary (9)\nPattern: RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE \nType: RCN, Category: CORRECTNESS (Correctness)\n代码片段：\n\n```public ActionForward execute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        //throw new UnsupportedOperationException(\"Method is not implemented\");\n        ActionErrors errors = new ActionErrors();\n        CreateCorpActionForm createCorp = new CreateCorpActionForm();\n        createCorp = (CreateCorpActionForm)form;\n        CreateCorpActionForm webcorp=new CreateCorpActionForm();\n        BudgetWebcorpManager budgetWebcorpManager=new BudgetWebcorpManager();\n        webcorp=budgetWebcorpManager.getCWebcorp(createCorp.getId());\n        createCorp.setFbsaddapproveid(webcorp.getFbsaddapproveid());\n        createCorp.setFbsinputapproveid(webcorp.getFbsinputapproveid());\n        createCorp.setFbsprocessapproveid(webcorp.getFbsprocessapproveid());\n \n        boolean b=false;\n        if(createCorp!=null){\n\n```\n解释说明：注意到有个局部变量 CreateCorpActionForm createCorp;再看下它的初始化过程，先是通过new给它分配了内存空间，紧接着有让它引用了了另一个未知的变量，这里说未知是指这个新的引用可能为空，显然 createCorp有可能指向一个空的地址，所以在接下来的引用中极可能报空指针异常（在引用之前不进行判空操作的话）！ 在接下来的代码，如下\n`if(createCorp!=null){\n`\n其实也就没有存在的必要，因为如果为空的话，上面这行代码根本不可能执行到，所以findbug说这是冗余的空指针检查。当然考虑到特殊情况，这里显然是struts1的action,所以只要web应用正常启动，通常以下代码\n\n`createCorp = (CreateCorpActionForm)form;`\n\n是不会导致createCorp指向空的，唯一的缺陷就是之前的new操作是多余的。\n推荐修改：自己看着办\n\n#### BUG-0003\nBug: con is null guaranteed to be dereferenced in com.bettersoft.admin.leftAction.getLeft(int, String, String) on exception path\nThere is a statement or branch on an exception path that if executed guarantees that a value is null at this point, and that value that is guaranteed to be dereferenced (except on forward paths involving runtime exceptions).\nConfidence: Normal, Rank: (Troubling 11)\nPattern: NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH \nType: NP, Category: CORRECTNESS (Correctness)\n代码片段：\n\n```finally\n        {\n            try\n            {\n                if(rs != null)\n                    rs.close();\n                if(ps!=null)\n                    ps.close();\n                con.close();\n            }catch(Exception ee)\n            {\n                ee.printStackTrace();\n            }\n        }\n```\n\n解释说明：这应该是大家很熟悉的代码片段了，可以想象Connection con是在catch代码块中进行的初始化操作，findbug对该bug说的很明白，说如果出现异常，Connection con将保证为空，因为很显然如果出现异常，con将得不到正确的初始化，即便初始化了，因为异常的出现，引用也会被解除，回到一开始定义处的null状态，那么在这里的finally代码块中调用Connection con的close()方法，将报空指针异常 \n推荐修改：自己看着办 \n \n#### BUG-0004 \nBug: Possible null pointer dereference of dbVersion in com.bettersoft.admin.LoginAction.loadVersion(HttpServletRequest, ActionErrors) on exception path \nA reference value which is null on some exception control path is dereferenced here. This may lead to aNullPointerExceptionwhen the code is executed. Note that because FindBugs currently does not prune infeasible exception paths, this may be a false warning.\nAlso note that FindBugs considers the default case of a switch statement to be an exception path, since the default case is often infeasible.\nConfidence: Normal, Rank: Troubling (11)\nPattern: NP_NULL_ON_SOME_PATH_EXCEPTION \nType: NP, Category: CORRECTNESS (Correctness)\n代码片段：\n\n```VersionInfo dbVersion = null;\n    try {\n        con = DBManager.getConnection();\n        dbVersion = vm.getVersionInfo(con);\n    } catch (Exception e) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n    } finally {\n        try {\n            con.close();\n        } catch (SQLException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n    }\nif (dbVersion.equals(programVersion)) {\n    programVersion.setCorrent(true);\n} else {\n    programVersion.setCorrent(false);\n}\n```\n\n解释说明：如果try catch 中捕获异常，那么dbVersion将为空， \n\n`dbVersion.equals(programVersion)`\n\n上面这行代码，将报空指针异常 \n \n#### BUG-0005\nBug: Dead store to am in com.bettersoft.approve.action.CheckAction.execute(ActionMapping, ActionForm, HttpServletRequest, HttpServletResponse)\nThis instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used.\nNote that Sun's javac compiler often generates dead stores for final local variables. Because FindBugs is a bytecode-based tool, there is no easy way to eliminate these false positives.\nConfidence: High, Rank: Of Concern (15)\nPattern: DLS_DEAD_LOCAL_STORE \nType: DLS, Category: STYLE (Dodgy code)\n代码片段：\n\n`ApproveManager am = new ApproveManager();`\n\n解释说明：am这个局部变量创建出来后，没有在任何地方被引用。这里确实没有被引用，所以是个bug,但是findbug又说明了，这有可能是误报，因为javac编译器在编译局部常量时，也会产生dead stroes。所以这个要视情况而定，不能过于纠结 \n \n \n#### BUG-0006\nBug: The class name com.bettersoft.approve.form.BtWebCorp shadows the simple name of the superclass com.bettersoft.admin.BtWebCorp\nThis class has a simple name that is identical to that of its superclass, except that its superclass is in a different package (e.g.,alpha.Fooextendsbeta.Foo). This can be exceptionally confusing, create lots of situations in which you have to look at import statements to resolve references and creates many opportunities to accidently define methods that do not override methods in their superclasses.\nConfidence: High, Rank: Troubling (14)\nPattern: NM_SAME_SIMPLE_NAME_AS_SUPERCLASS \nType: Nm, Category: BAD_PRACTICE (Bad practice)\n代码片段： \n\n```public class BtWebCorp extends com.bettersoft.admin.BtWebCorp{\n \n}\n```\n\n解释说明：这里子类和父类名称一样，findbug认为这回导致很多混淆。显然一旦出问题，将很难发现，运行结果将出乎意料 \n \n#### BUG-0007\nBug: Comparison of String objects using == or != in com.byttersoft.admin.persistence.dao.MessageOpenDao.addOpenSave(MessageOpenForm)\nThis code comparesjava.lang.Stringobjects for reference equality using the == or != operators. Unless both strings are either constants in a source file, or have been interned using theString.intern()method, the same string value may be represented by two different String objects. Consider using theequals(Object)method instead.\nConfidence: Normal, Rank: Troubling (11)\nPattern: ES_COMPARING_STRINGS_WITH_EQ \nType: ES, Category: BAD_PRACTICE (Bad practice)\n代码片段：\n\n```if(id==null || id==\"\"){\n        sql = \"insert into xx values (1,?,?,?)\";\n}else{\n        sql = \"insert into xx values ((select max(id) + 1 from xx),?,?,?)\";\n}\n```\n\n解释说明： 直接使用==进行对象实例比较，而没有使用equals,本来没觉得这个bug咋样，但是发现项目里居然最多的bug就是这个，不管是很多年前的代码还是最近的代码，都存在这大量这样的问题。看来这是一个通病，所以大家注意一下，不光是我们公司的项目有这样的问题，这应该是一个普遍的问题，尤其实在比较String类型的时候，注意只要不是java基本类型都需要使用equals进行比较，哪怕是自动解封的Integer，Double等\n \n#### BUG-0008\nBug: Call to String.equals(Double) in com.byttersoft.amm.util.BalanceInterzoneRateUtil.formatRate(Double)\nThis method calls equals(Object) on two references of different class types with no common subclasses. Therefore, the objects being compared are unlikely to be members of the same class at runtime (unless some application classes were not analyzed, or dynamic class loading can occur at runtime). According to the contract of equals(), objects of different classes should always compare as unequal; therefore, according to the contract defined by Java.lang.Object.equals(Object), the result of this comparison will always be false at runtime.\nConfidence: High, Rank: Scariest (1)\nPattern: EC_UNRELATED_TYPES \nType: EC, Category: CORRECTNESS (Correctness)\n代码片段：\n```private static String  formatRate(Double r){\n         \n        if(r==null ||  (\"undefined\").equals(r)){\n            return null;\n        }\n\n```\n解释说明：使用equals比较不同类型的数据，\"undefined\"是String类型，r是Double类型，这两个比较肯定返回false\n\n`(\"undefined\").equals(r)`\n\n上面这行代码完全没有必要 ，不可能存在这种情况\n \n#### BUG-0009\nBug: Class com.byttersoft.util.CertInfo defines non-transient non-serializable instance field subjectDnAttr\nThis Serializable class defines a non-primitive instance field which is neither transient, Serializable, orjava.lang.Object, and does not appear to implement theExternalizableinterface or thereadObject()andwriteObject()methods. Objects of this class will not be deserialized correctly if a non-Serializable object is stored in this field.\nConfidence: High, Rank: Troubling (14)\nPattern: SE_BAD_FIELD \nType: Se, Category: BAD_PRACTICE (Bad practice)\n代码片段： \n\n```public class CertInfo implements java.io.Serializable\n{\n    private String subjectDN=\"\";\n    private String issuerDN=\"\";\n    private String notAfterDate=\"\";\n    private String notBeforeDate=\"\";\n    private String serialNumber=\"\";\n    private String sigAlgName=\"\";\n    private String sigAlgOID=\"\";\n    private String version=\"\";\n    private String publicKeyFormat=\"\";\n    private String publicKeyAlgorithm=\"\";\n    private Names subjectDnAttr=null;\n｝\npublic class Names\n{}<span></span>\n```\n\n解释说明： CertInfo实现的序列话，但是他的成员变量Names subjectDnAttr没有实现序列化，这将会导致序列化失败，String已经默认实现了序列化。注意，序列化时所有的成员变量都必须递归的实现序列化，否则将导致序列化失败。如果某个成员变量不想被序列化要么标注为瞬态要么重写readObj方法\n \n#### BUG-0010\nBug: Dead store to corpGourps rather than field with same name in com.byttersoft.admin.form.CorpGroupsForm.setCorpGourps(CorpGourps)\nThis instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used. There is a field with the same name as the local variable. Did you mean to assign to that variable instead?\nConfidence: High, Rank: Scary (9)\nPattern: DLS_DEAD_LOCAL_STORE_SHADOWS_FIELD \nType: DLS, Category: STYLE (Dodgy code)\n代码片段： \n\n```\npublic void setCorpGourps(CorpGourps corpGourps) {\n        corpGourps = corpGourps;\n    }\n```\n解释说明：成员变量和局部变量重名\n \n#### BUG-0011\nBug: Invocation of toString on labelValue in com.byttersoft.approve.persistence.dao.MesAppDao.getMapByPara(String)\nThe code invokes toString on an array, which will generate a fairly useless result such as [C@16f0472. Consider using Arrays.toString to convert the array into a readable String that gives the contents of the array. See Programming Puzzlers, chapter 3, puzzle 12.\nConfidence: Normal, Rank: Troubling (10)\nPattern: DMI_INVOKING_TOSTRING_ON_ARRAY \nType: USELESS_STRING, Category: CORRECTNESS (Correctness)\n代码片段：\n\n```for (String parameter : parameters) {\n            String[] labelValue = parameter.split(\"=\");\n            if (labelValue.length == 2) {\n                String key = labelValue[0];\n                String value = labelValue[1];\n                hashMap.put(key, value);\n            } else {\n                logger.debug(\"参数 \" + labelValue + \" 配置错误。\");\n            }\n        }\n```\n\n解释说明：在进行日志输出时，直接输出对象，将默认调用对象的toString方法，而默认是输出对象的内存地址，所以这里显然有问题，本意应该是输出数组中的字符串 \n \n#### BUG-0012\nBug: Write to static field com.byttersoft.admin.service.BtSysResService.map from instance method com.byttersoft.admin.service.BtSysResService.hashCatchOfSysRes(boolean)\nThis instance method writes to a static field. This is tricky to get correct if multiple instances are being manipulated, and generally bad practice.\nConfidence: High, Rank: Of Concern (15)\nPattern: ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD \nType: ST, Category: STYLE (Dodgy code)\n代码片段： \n\n```static Map<String, BtSysRes> map = new HashMap<String, BtSysRes>();\npublic Map<String, BtSysRes> hashCatchOfSysRes(boolean isRefresh) {\n        if(isRefresh == true){\n            map = hashCatchOfSysRes();\n        }else{\n            if(map == null || map.isEmpty()){\n                map = hashCatchOfSysRes();\n            }\n        }\n        return map;\n    }\n\n```\n解释说明：在实例方法中修改类变量的引用，这会导致共享问题，因为其他实例也会访问该静态变量，但是却不知道某个实例已经修改了该静态变量的引用，导致不可预知的问题\n推荐修改：将该方法改为类方法\n \n \n#### BUG-0013\nBug: Unwritten field: com.byttersoft.admin.service.importservice.ImportServices.bank\nThis field is never written. All reads of it will return the default value. Check for errors (should it have been initialized?), or remove it if it is useless.\nConfidence: Normal, Rank: Troubling (12)\nPattern: UWF_UNWRITTEN_FIELD \nType: UwF, Category: CORRECTNESS (Correctness)\n代码片段：\n\n```public class ImportServices {\nprivate IBankAccServices bank;\npublic IBankAccServices getBank() {\n        return bank;\n    }\n｝\n```\n\n解释说明： bank对象为空，getBank方法返回了一个肯定为空的对象实例\n \n \n#### BUG-0014\nBug: There is an apparent infinite recursive loop in com.byttersoft.amm.dao.impl.CheckLoanOrProvideInfoDaoImpl.addBatch(List)\nThis method unconditionally invokes itself. This would seem to indicate an infinite recursive loop that will result in a stack overflow.\nConfidence: High, Rank: Scary (9)\nPattern: IL_INFINITE_RECURSIVE_LOOP \nType: IL, Category: CORRECTNESS (Correctness)\n代码片段： \n```public void addBatch(List<CmsPLoanToBean> cmsPLoanBeans) {\n        this.addBatch(cmsPLoanBeans);\n    }\n```\n解释说明：出现了递归调用addBatch,将出现死循环\n \n### High\n#### 1.DM_DEFAULT_ENCODING\n \n##### 1.1 Found reliance on default encoding in com.cmcc.aoi.httprequest.service.HttpRequest.sendGet(String, String): new java.io.InputStreamReader(InputStream)\nFound a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.\n \nnew BufferedReader(new InputStreamReader(connection.getInputStream()));\n \n修改为： InputStreamReader fileData = new InputStreamReader(file ,\"utf-8\");\n \n \n \n##### 1.2 Found reliance on default encoding in com.cmcc.aoi.httprequest.service.HttpRequest.sendPost(String, JSONObject): new java.io.PrintWriter(OutputStream)\nFound a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.\nout = new PrintWriter(conn.getOutputStream());\n \n修改为： out = new PrintWriter(new OutputStreamWriter(conn.getOutputStream(), \"utf-8\"));\n \n \n##### 1.3 Found reliance on default encoding in com.cmcc.aoi.selfhelp.action.DeliverWebRequestAction.calculateUserCount(HttpServletRequest): String.getBytes()\nFound a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.\nfileName = new String(req.getParameter(\"fileName\").getBytes(), \"UTF-8\");\n修改为\nfileName = new String(req.getParameter(\"fileName\").getBytes(\"UTF-8\"), \"UTF-8\");\n \n##### 1.4 Found reliance on default encoding in com.cmcc.aoi.selfhelp.action.servlet.AoeRegAction.report(HttpServletRequest, HttpServletResponse): java.io.ByteArrayOutputStream.toString()\nFound a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.\nlogger.info(\"RECV STR: \" + baos.toString());\n修改为\nlogger.info(\"RECV STR: \" + baos.toString(\"utf-8\"));\n \n##### 1.5 Found reliance on default encoding in com.cmcc.aoi.selfhelp.action.servlet.AoeUploadLogAction.report(HttpServletRequest, HttpServletResponse): new java.io.FileWriter(File)\nFound a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.\nnew FileWriter(f).append(baos.toString(\"UTF-8\")).close();\n修改为\nBufferedWriter out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(f, true))); \nout.write(baos.toString(\"UTF-8\")); \nout.close();\n \nBufferedWriter bw= new BufferedWriter( new OutputStreamWriter(new FileOutputStream(filePath, true), \"utf-8\"));\n \n##### 1.6 Found reliance on default encoding in new com.cmcc.aoi.util.TokenZipFileUtil(String): new java.io.FileReader(String)\nFound a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.\nFileReader in = new FileReader(file);\n改为\nBufferedReader reader = new BufferedReader(new InputStreamReader(newFileInputStream(file), \"UTF-8\")); \n       \n#### 2.MS_SHOULD_BE_FINAL\n \ncom.cmcc.aoi.selfhelp.action.DeliverWebRequestAction.logger isn't final but should be\nThis static field public but not final, and could be changed by malicious code or by accident from another package. The field could be made final to avoid this vulnerability.\n \nprotected static   Logger logger = LoggerFactory.getLogger(DeliverWebRequestAction.class);\n修改为 protected static final Logger logger = LoggerFactory.getLogger(DeliverWebRequestAction.class);\n \n####  3.DLS_DEAD_LOCAL_STORE\n \nDead store to s in com.cmcc.aoi.selfhelp.action.DeliverWebRequestAction.textSend(WebSendTextForm, HttpServletRequest)\nThis instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used.\nNote that Sun's javac compiler often generates dead stores for final local variables. Because FindBugs is a bytecode-based tool, there is no easy way to eliminate these false positives.\nShopMappingDeliver shopMappingDeliver = null;\n删除即可\n \n#### 4.ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD\nWrite to static field com.cmcc.aoi.selfhelp.action.MultipleMediaAoeAction.linkRoot from instance method com.cmcc.aoi.selfhelp.action.MultipleMediaAoeAction.afterPropertiesSet()\nThis instance method writes to a static field. This is tricky to get correct if multiple instances are being manipulated, and generally bad practice.\nlinkRoot = sysConfigService.getDomainName() + \"/\";\n修改改为：\n```public static String getLinkRoot() {\n        returnlinkRoot;\n    }\n \n    publicstaticvoid setLinkRoot(String linkRoot) {\n        MultipleMediaAoeAction.linkRoot = linkRoot;\n    }\n   MultipleMediaAoeAction.setLinkRoot(sysConfigService.getDomainName() + \"/\");\n\n``` \n\n#### 5. J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION\nStore of non serializable com.cmcc.aoi.selfhelp.action.UploadFileAction$FileUploadStatus into HttpSession in new com.cmcc.aoi.selfhelp.action.UploadFileAction$MyProgressListener(UploadFileAction, HttpServletRequest)\nThis code seems to be storing a non-serializable object into an HttpSession. If this session is passivated or migrated, an error will result.\n修改为 FileUploadStatus implements Serializable\n \n \n#### 6.  RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE\nRedundant nullcheck of rtr, which is known to be non-null in com.cmcc.aoi.selfhelp.action.servlet.AoeReportApplistAction.device(HttpServletRequest, HttpServletResponse)\nThis method contains a redundant check of a known non-null value against the constant null.\n```if (rtr != null) {\n            Writer writer;\n            try {\n                writer = response.getWriter();\n                if (rtr != null) {\n                    try {\n \n                        String s = JSONUtil.objToJson(rtr);\n                        if (LOGGER.isDebugEnabled()) {\n                            LOGGER.debug(\"SEND STR: \" + s);\n                        }\n                        writer.write(s);\n                        writer.flush();\n                    } catch (IOException e) {\n                        LOGGER.warn(\"\", e);\n                        if (writer != null) {\n                            try {\n                                writer.write(JSONUtil.objToJson(rtr));\n                            } catch (IOException e1) {\n                                LOGGER.warn(\"\", e1);\n                            }\n                        }\n                    }\n                } else {\n                    response.getWriter().write(\"{\\\"errorCode\\\":401}\");\n                }\n            } catch (IOException e2) {\n                LOGGER.warn(\"\", e2);\n            }\n        }\n```\n修改为\n```if (rtr != null) {\n            Writer writer;\n            try {\n                writer = response.getWriter();\n                try {\n \n                    String s = JSONUtil.objToJson(rtr);\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.debug(\"SEND STR: \" + s);\n                    }\n                    writer.write(s);\n                    writer.flush();\n                } catch (IOException e) {\n                    LOGGER.warn(\"\", e);\n                    if (writer != null) {\n                        try {\n                            writer.write(JSONUtil.objToJson(rtr));\n                        } catch (IOException e1) {\n                            LOGGER.warn(\"\", e1);\n                        }\n                    }\n                }\n \n            } catch (IOException e2) {\n                LOGGER.warn(\"\", e2);\n            }\n        } else {\n            response.getWriter().write(\"{\\\"errorCode\\\":401}\");\n        }\n```\n \n#### 7. RU_INVOKE_RUN\ncom.cmcc.aoi.selfhelp.action.servlet.UploadTokensAction$TokenFileThread.run() explicitly invokes run on a thread (did you mean to start it instead?)\nThis method explicitly invokes run() on an object.  In general, classes implement the Runnable interface because they are going to have their run() method invoked in a new thread, in which case Thread.start() is the right method to call.\n \n`ti.run();\n`\n修改为：\n\n```ti.start();\ntry {\n    ti.join();\n} catch (InterruptedException e) {\n     e.printStackTrace();\n}\n```\n \n \n#### 8. NM_SAME_SIMPLE_NAME_AS_SUPERCLASS\nThe class name com.cmcc.aoi.selfhelp.dao.BaseDao shadows the simple name of the superclass org.slave4j.orm.hibernate.BaseDao\nThis class has a simple name that is identical to that of its superclass, except that its superclass is in a different package (e.g., alpha.Foo extends beta.Foo). This can be exceptionally confusing, create lots of situations in which you have to look at import statements to resolve references and creates many opportunities to accidentally define methods that do not override methods in their superclasses\ncom.cmcc.aoi.selfhelp.dao.BaseDao\n修改为\ncom.cmcc.aoi.selfhelp.dao.BasisDao\n \n#### 9. SE_BAD_FIELD_INNER_CLASS\ncom.cmcc.aoi.selfhelp.action.UploadFileAction$FileUploadStatus is serializable but also an inner class of a non-serializable class\nThis Serializable class is an inner class of a non-serializable class. Thus, attempts to serialize it will also attempt to associate instance of the outer class with which it is associated, leading to a runtime error.\nIf possible, making the inner class a static inner class should solve the problem. Making the outer class serializable might also work, but that would mean serializing an instance of the inner class would always also serialize the instance of the outer class, which it often not what you really want.\n修改外部类\nUploadFileAction extends BaseAction implements Serializable\n \n \n#### 10. DM_BOXED_PRIMITIVE_FOR_PARSING\nBoxing/unboxing to parse a primitive com.cmcc.aoi.selfhelp.dao.StatAppEveryHourDao.findWeekList(String)\nA boxed primitive is created from a String, just to extract the unboxed primitive value. It is more efficient to just call the static parseXXX method.\n\n```statAppEveryHour.setNewnumber(Integer.valueOf(String.valueOf(objects[2])));               statAppEveryHour.setAccnumber(Integer.valueOf(String.valueOf(objects[3])));\n```\n修改为\n\n```statAppEveryHour.setStattime(sdf.parse(String.valueOf(objects[1])));\n                    statAppEveryHour\n                            .setNewnumber(Integer.parseInt(String.valueOf(objects[2]) != null\n                                    && !\"\".equals(String.valueOf(objects[2]))\n                                            ? String.valueOf(objects[2]) : \"0\"));\n                    statAppEveryHour\n                            .setAccnumber(Integer.parseInt(String.valueOf(objects[3]) != null\n                                    && !\"\".equals(String.valueOf(objects[3]))\n                                            ? String.valueOf(objects[3]) : \"0\"));\n```\n \n###  Normal\n#### 1.SBSC_USE_STRINGBUFFER_CONCATENATION\ncom.cmcc.aoi.httprequest.service.HttpRequest.sendGet(String, String) concatenates strings using + in a loop\nThe method seems to be building a String using concatenation in a loop. In each iteration, the String is converted to a StringBuffer/StringBuilder, appended to, and converted back to a String. This can lead to a cost quadratic in the number of iterations, as the growing string is recopied in each iteration.\nBetter performance can be obtained by using a StringBuffer (or StringBuilder in Java 1.5) explicitly.\nFor example:\n  // This is bad\n  String s = \"\";\n  for (int i = 0; i < field.length; ++i) {\n    s = s + field[i];\n  }\n \n  // This is better\n  StringBuffer buf = new StringBuffer();\n  for (int i = 0; i < field.length; ++i) {\n    buf.append(field[i]);\n  }\n  String s = buf.toString();\n \n#### 2. WMI_WRONG_MAP_ITERATOR\n\n```for (String key : map.keySet()) {\n                System.out.println(key + \"--->\" + map.get(key));\n}\n```\n改为\n\n```for (  Map.Entry<String, List<String>> entry : map.entrySet()) {\n                System.out.println(entry.getKey() + \"--->\" + entry.getValue());\n            }\n\n``` \n#### 3.  EI_EXPOSE_REP\ncom.cmcc.aoi.selfhelp.entity.Activation.getValidUntil() may expose internal representation by returning Activation.validUntil\nReturning a reference to a mutable object value stored in one of the object's fields exposes the internal representation of the object.  If instances are accessed by untrusted code, and unchecked changes to the mutable object would compromise security or other important properties, you will need to do something different. Returning a new copy of the object is better approach in many situations.\n \n \n    public Date getValidUntil() {\n        returnvalidUntil;\n}\n \n修改为\npublic Date getValidUntil() {\n        if(validUntil == null) {\n            returnnull;\n        }\n        return (Date) validUntil.clone();\n}\n \n#### 4. EI_EXPOSE_REP2\ncom.cmcc.aoi.selfhelp.entity.Activation.setValidUntil(Date) may expose internal representation by storing an externally mutable object into Activation.validUntil\nThis code stores a reference to an externally mutable object into the internal representation of the object.  If instances are accessed by untrusted code, and unchecked changes to the mutable object would compromise security or other important properties, you will need to do something different. Storing a copy of the object is better approach in many situations.\n\n```publicvoid setValidUntil(Date validUntil) {\nthis.validUntil = validUntil;\n}\n```\n修改为\n```publicvoid setValidUntil(Date validUntil) {\n        if(validUntil == null) {\n            this.validUntil = null;\n        }else {\n            this.validUntil = (Date) validUntil.clone();\n        }\n    }\n\n``` \n \n#### 5. BC_VACUOUS_INSTANCEOF\ninstanceof will always return true for all non-null values in com.cmcc.aoi.selfhelp.entity.AppType.compareTo(AppType), since all com.cmcc.aoi.selfhelp.entity.AppType are instances of com.cmcc.aoi.selfhelp.entity.AppType\nThis instanceof test will always return true (unless the value being tested is null). Although this is safe, make sure it isn't an indication of some misunderstanding or some other logic error. If you really want to test the value for being null, perhaps it would be clearer to do better to do a null test rather than an instanceof test.\n \n#### 6. MS_MUTABLE_ARRAY\ncom.cmcc.aoi.selfhelp.entity.DeviceType.CURRENTUSEDDEVICES is a mutable array\nA final static field references an array and can be accessed by malicious code or by accident from another package. This code can freely modify the contents of the array.\n \npublic static final int[] CURRENTUSEDDEVICES = new int []{Device.iOS.ordinal()，Device.Android.ordinal()，Device.WP.ordinal()}；\n修改为\n Public > protected\n \n#### 7. EQ_COMPARETO_USE_OBJECT_EQUALS\ncom.cmcc.aoi.selfhelp.entity.AppType defines compareTo(AppType) and uses Object.equals()\nThis class defines a compareTo(...) method but inherits its equals() method from java.lang.Object. Generally, the value of compareTo should return zero if and only if equals returns true. If this is violated, weird and unpredictable failures will occur in classes such as PriorityQueue. In Java 5 the PriorityQueue.remove method uses the compareTo method, while in Java 6 it uses the equals method.\nFrom the JavaDoc for the compareTo method in the Comparable interface:\nIt is strongly recommended, but not strictly required that (x.compareTo(y)==0) == (x.equals(y)). Generally speaking, any class that implements the Comparable interface and violates this condition should clearly indicate this fact. The recommended language is \"Note: this class has a natural ordering that is inconsistent with equals.\"\n \n修改\n添加 hashcode() 和 equals() 代码即可\n \n#### 8. BC_VACUOUS_INSTANCEOF\ninstanceof will always return true for all non-null values in com.cmcc.aoi.selfhelp.entity.AppType.compareTo(AppType), since all com.cmcc.aoi.selfhelp.entity.AppType are instances of com.cmcc.aoi.selfhelp.entity.AppType\nThis instanceof test will always return true (unless the value being tested is null). Although this is safe, make sure it isn't an indication of some misunderstanding or some other logic error. If you really want to test the value for being null, perhaps it would be clearer to do better to do a null test rather than an instanceof test.\n  \n```@Override\n    publicint compareTo(AppType o) {\n        if (oinstanceof AppType) {\n            AppType p = (AppType) o;\n            returnthis.typeId > p.typeId ? 1 : this.typeId == p.typeId ? 0 : -1;\n        }\n        return 1;\n    }\n\n``` \n\n修改为\n  \n```@Override\n    publicint compareTo(AppType o) {\n        if (null != o) {\n            AppType p  = (AppType) o ;\n            returnthis.typeId > p.typeId ? 1 : this.typeId == p.typeId ? 0 : -1;\n        }\n        return 1;\n \n    }\n\n``` \n#### 9. ME_ENUM_FIELD_SETTER\ncom.cmcc.aoi.selfhelp.dto.ActivationSituation.setSituation(String) unconditionally sets the field situation\nThis public method declared in public enum unconditionally sets enum field, thus this field can be changed by malicious code or by accident from another package. Though mutable enum fields may be used for lazy initialization, it's a bad practice to expose them to the outer world. Consider removing this method or declaring it package-private.\n    publicvoid setCode(String code) {\n        this.code = code;\n    }\n \n修改\n 删除该无用代码\n \n \n#### 10.  IM_BAD_CHECK_FOR_ODD\nCheck for oddness that won't work for negative numbers in com.cmcc.aoi.selfhelp.dto.WebSendTextForm.toDeliverWebRequest()\nThe code uses x % 2 == 1 to check to see if a value is odd, but this won't work for negative numbers (e.g., (-5) % 2 == -1). If this code is intending to check for oddness, consider using x & 1 == 1, or x % 2 != 0.\n\n```DeliverFactory\n                                    .createTextOpenApp(this.msgtype, \"\", this.content,\n                                            this.isRingAndVibrate % 2 == 1,\n                                            isRingAndVibrate / 2 >= 1, this.activity)\n                                    .toJsonString());\n\n``` \n修改为\n\n```DeliverFactory\n                                    .createTextOpenApp(this.msgtype, \"\", this.content,\n                                            this.isRingAndVibrate % 2 != 0,\n                                            isRingAndVibrate / 2 >= 1, this.activity)\n                                    .toJsonString());\n\n``` \n \n#### 11. MS_EXPOSE_REP\nPublic static com.cmcc.aoi.selfhelp.dict.DeviceSupported.getSupportedDevs() may expose internal representation by returning DeviceSupported.DEVS\nA public static method returns a reference to an array that is part of the static state of the class. Any code that calls this method can freely modify the underlying array. One fix is to return a copy of the array.\n\n```public static Device[] getSupportedDevs() {\n        return DEVS;\n    }\n```\n修改为\n\n```publicstatic Device[] getSupportedDevs() {\n        return DeviceSupported.DEVS.clone();\n    }\n\n``` \n#### 12.URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD\nUnread public/protected field: com.cmcc.aoi.selfhelp.dict.OperatorDict.countryCode\nThis field is never read.  The field is public or protected, so perhaps it is intended to be used with classes not seen as part of the analysis. If not, consider removing it from the class.\npublicintcode;\n    \n```public String enName;\n    public String cnName;\n    public String countryCode;\n \n    public OperatorDict() {\n    }\n \n    /**\n     *\n     * @param code\n     *            运营商代码,一般是5位\n     * @param enName\n     *            英文名\n     * @param countryCode\n     *            国家英文代码\n     * @param cnName\n     *            中文名\n     */\n    public OperatorDict(intcode, String enName, String countryCode, String cnName) {\n        this.code = code;\n        this.enName = enName;\n        this.countryCode = countryCode;\n        this.cnName = cnName == null ? Integer.toString(code) : cnName;\n    }\n\n```修改为\nPublic  -》 private\n  \n#### 13. ES_COMPARING_STRINGS_WITH_EQ\nComparison of String objects using == or != in com.cmcc.aoi.selfhelp.entity.Provider.compareTo(Object)\nThis code compares java.lang.String objects for reference equality using the == or != operators. Unless both strings are either constants in a source file, or have been interned using the String.intern() method, the same string value may be represented by two different String objects. Consider using the equals(Object) method instead.\n \nreturn this.spid.compareTo(p.spid) > 0 ? 1 : this.spid == p.spid ? 0 : -1;\n修改为\nthis.spid.compareTo(p.spid) > 0 ? 1 : this.spid.equals(p.spid) ? 0 : -1;\n14.DB_DUPLICATE_BRANCHES\ncom.cmcc.aoi.selfhelp.dao.ShStatTerminalDao.getListQuery(String, int, Date, Date, boolean, int) uses the same code for two branches\nThis method uses the same code to implement two branches of a conditional branch. Check to ensure that this isn't a coding mistake.\n\n```if (bool) {\n                query.setInteger(i++, nodeType);\n                query.setInteger(i++, nodeType);\n            } else {\n                query.setInteger(i++, nodeType);\n                query.setInteger(i++, nodeType);\n            }\n\n```修改为\n\n```query.setInteger(i++, nodeType);\nquery.setInteger(i++, nodeType);\n```\n \n#### 15. SE_COMPARATOR_SHOULD_BE_SERIALIZABLE\n \ncom.cmcc.aoi.selfhelp.task.entity.StatAppHabitComparator implements Comparator but not Serializable\nThis class implements the Comparator interface. You should consider whether or not it should also implement the Serializable interface. If a comparator is used to construct an ordered collection such as a TreeMap, then the TreeMap will be serializable only if the comparator is also serializable. As most comparators have little or no state, making them serializable is generally easy and good defensive programming.\n修改为\nimplements Serializable\n \n#### 16.  UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD\n \nUnwritten public or protected field: com.cmcc.aoi.selfhelp.task.entity.StatDevice.keyname\nNo writes were seen to this public/protected field.  All reads of it will return the default value. Check for errors (should it have been initialized?), or remove it if it is useless.\nPublic  String keyname;\n修改为\nPrivate  String keyname;\n \n#### 18.  RV_RETURN_VALUE_IGNORED_BAD_PRACTICE\nExceptional return value of java.io.File.mkdirs() ignored in com.cmcc.aoi.util.FileUtil.moveFile(File, String)\nThis method returns a value that is not checked. The return value should be checked since it can indicate an unusual or unexpected function execution. For example, the File.delete() method returns false if the file could not be successfully deleted (rather than throwing an Exception). If you don't check the result, you won't notice if the method invocation signals unexpected behavior by returning an atypical return value.\ntmp.mkdirs()\n修改为\nbooleanmkdirs = tmp.mkdirs();\nlogger.debug(\"debug\",mkdirs);\n \nREC_CATCH_EXCEPTION\nException is caught when Exception is not thrown in com.cmcc.aoi.selfhelp.task.fileparser.TokenIncrease.parseLine(String[])\nThis method uses a try-catch block that catches Exception objects, but Exception is not thrown within the try block, and RuntimeException is not explicitly caught. It is a common bug pattern to say try { ... } catch (Exception e) { something } as a shorthand for catching a number of types of exception each of whose catch blocks is identical, but this construct also accidentally catches RuntimeException as well, masking potential bugs.\nA better approach is to either explicitly catch the specific exceptions that are thrown, or to explicitly catch RuntimeException exception, rethrow it, and then catch all non-Runtime Exceptions, as shown below:\n \n``` try {\n    ...\n  } catch (RuntimeException e) {\n    throw e;\n  } catch (Exception e) {\n    ... deal with all non-runtime exceptions ...\n  }\n\n``` \n \n#### 19. ICAST_IDIV_CAST_TO_DOUBLE\nIntegral division result cast to double or float in com.cmcc.aoi.selfhelp.service.BaseAnalysisService.getInterval(Date, Date, int)\nThis code casts the result of an integral division (e.g., int or long division) operation to double or float. Doing division on integers truncates the result to the integer value closest to zero. The fact that the result was cast to double suggests that this precision should have been retained. What was probably meant was to cast one or both of the operands to double before performing the division. \n```Here is an example:\nint x = 2;\nint y = 5;\n// Wrong: yields result 0.0\ndouble value1 =  x / y;\n \n// Right: yields result 0.4\ndouble value2 =  x / (double) y;\n```\n\n\n\n\n\n## FindBugs规则整理\nFindBugs是基于Bug Patterns概念，查找javabytecode（.class文件）中的潜在bug，主要检查bytecode中的bug patterns，如NullPoint空指针检查、没有合理关闭资源、字符串相同判断错（==，而不是equals）等\n### 一、Security 关于代码安全性防护\n1.Dm: Hardcoded constant database password (DMI_CONSTANT_DB_PASSWORD)\n代码中创建DB的密码时采用了写死的密码。\n2.Dm: Empty database password (DMI_EMPTY_DB_PASSWORD)\n创建数据库连接时没有为数据库设置密码，这会使数据库没有必要的保护。\n3.HRS: HTTP cookie formed from untrusted input (HRS_REQUEST_PARAMETER_TO_COOKIE)\n此代码使用不受信任的HTTP参数构造一个HTTP Cookie。\n4.HRS: HTTP Response splitting vulnerability (HRS_REQUEST_PARAMETER_TO_HTTP_HEADER)\n在代码中直接把一个HTTP的参数写入一个HTTP头文件中，它为HTTP的响应暴露了漏洞。\n5.SQL: Nonconstant string passed to execute method on an SQL statement (SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE)\n该方法以字符串的形式来调用SQLstatement的execute方法，它似乎是动态生成SQL语句的方法。这会更容易受到SQL注入攻击。\n6.XSS: JSP reflected cross site scripting vulnerability (XSS_REQUEST_PARAMETER_TO_JSP_WRITER)\n在代码中在JSP输出中直接写入一个HTTP参数，这会造成一个跨站点的脚本漏洞。\n### 二、Experimental\n \n1.LG: Potential lost logger changes due to weak reference in OpenJDK (LG_LOST_LOGGER_DUE_TO_WEAK_REFERENCE)\nOpenJDK的引入了一种潜在的不兼容问题，特别是，java.util.logging.Logger的行为改变时。它现在使用内部弱引用，而不是强引用。–logger配置改变，它就是丢失对logger的引用，这本是一个合理的变化，但不幸的是一些代码对旧的行为有依赖关系。这意味着，当进行垃圾收集时对logger配置将会丢失。例如：\npublic static void initLogging() throws Exception {\n Logger logger = Logger.getLogger(\"edu.umd.cs\");\n logger.addHandler(new FileHandler()); // call to change logger configuration\n logger.setUseParentHandlers(false); // another call to change logger configuration\n}\n该方法结束时logger的引用就丢失了，如果你刚刚结束调用initLogging方法后进行垃圾回收，logger的配置将会丢失（因为只有保持记录器弱引用）。\npublic static void main(String[] args) throws Exception {\n initLogging(); // adds a file handler to the logger\n System.gc(); // logger configuration lost\n Logger.getLogger(\"edu.umd.cs\").info(\"Some message\"); // this isn't logged to the file as expected\n}\n2.OBL: Method may fail to clean up stream or resource (OBL_UNSATISFIED_OBLIGATION)\n这种方法可能无法清除（关闭，处置）一个流，数据库对象，或其他资源需要一个明确的清理行动。\n一般来说，如果一个方法打开一个流或其他资源，该方法应该使用try / finally块来确保在方法返回之前流或资源已经被清除了。这种错误模式基本上和OS_OPEN_STREAM和ODR_OPEN_DATABASE_RESOURCE错误模式相同，但是是在不同在静态分析技术。我们正为这个错误模式的效用收集反馈意见。\n \n### 三、Bad practice代码实现中的一些坏习惯\n \n1.AM: Creates an empty jar file entry (AM_CREATES_EMPTY_JAR_FILE_ENTRY)\n调用putNextEntry()方法写入新的 jar 文件条目时立即调用closeEntry()方法。这样会造成JarFile条目为空。\n2.AM: Creates an empty zip file entry (AM_CREATES_EMPTY_ZIP_FILE_ENTRY)\n调用putNextEntry()方法写入新的 zip 文件条目时立即调用closeEntry()方法。这样会造成ZipFile条目为空。\n3.BC: Equals method should not assume anything about the type of its argument (BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS)\nequals(Object o)方法不能对参数o的类型做任何的假设。比较此对象与指定的对象。当且仅当该参数不为 null，并且是表示与此对象相同的类型的对象时，结果才为 true。\n4.BC: Random object created and used only once (DMI_RANDOM_USED_ONLY_ONCE)\n随机创建对象只使用过一次就抛弃\n5.BIT: Check for sign of bitwise operation (BIT_SIGNED_CHECK)\n检查位操作符运行是否合理\n((event.detail & SWT.SELECTED) > 0)\nIf SWT.SELECTED is a negative number, this is a candidate for a bug. Even when SWT.SELECTED is not negative, it seems good practice to use '!= 0' instead of '> 0'.\n6.CN: Class implements Cloneable but does not define or use clone method (CN_IDIOM)\n按照惯例，实现此接口的类应该使用公共方法重写 Object.clone（它是受保护的），以获得有关重写此方法的详细信息。此接口不 包含 clone 方法。因此，因为某个对象实现了此接口就克隆它是不可能的,应该实现此接口的类应该使用公共方法重写 Object.clone\n7.CN: clone method does not call super.clone() (CN_IDIOM_NO_SUPER_CALL)\n一个非final类型的类定义了clone()方法而没有调用super.clone()方法。例如：B扩展自A，如果B中clone方法调用了spuer.clone（），而A中的clone没有调用spuer.clone()，就会造成结果类型不准确。要求A的clone方法中调用spuer.clone()方法。\n8.CN: Class defines clone() but doesn't implement Cloneable (CN_IMPLEMENTS_CLONE_BUT_NOT_CLONEABLE)\n类中定义了clone方法但是它没有实现Cloneable接口\n9.Co: Abstract class defines covariant compareTo() method (CO_ABSTRACT_SELF)\n抽象类中定义了多个compareTo()方法，正确的是覆写Comparable中的compareTo方法，方法的参数为Object类型，如下例：\nint compareTo(T o)  比较此对象与指定对象的顺序。\n10.Co: Covariant compareTo() method defined (CO_SELF_NO_OBJECT)\n类中定义了多个compareTo()方法，正确的是覆写Comparable中的compareTo方法，方法的参数为Object类型\n11.DE: Method might drop exception (DE_MIGHT_DROP)\n方法可能抛出异常\n12.DE: Method might ignore exception (DE_MIGHT_IGNORE)\n方法可能忽略异常\n13.DMI: Don't use removeAll to clear a collection (DMI_USING_REMOVEALL_TO_CLEAR_COLLECTION)\n不要用removeAll方法去clear一个集合\n14.DP: Classloaders should only be created inside doPrivileged block (DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED)\n类加载器只能建立在特殊的方法体内\n15.Dm: Method invokes System.exit(...) (DM_EXIT)\n在方法中调用System.exit(...)语句，考虑用RuntimeException来代替\n16.Dm: Method invokes dangerous method runFinalizersOnExit (DM_RUN_FINALIZERS_ON_EXIT)\n在方法中调用了System.runFinalizersOnExit 或者Runtime.runFinalizersOnExit方法，因为这样做是很危险的。\n17.ES: Comparison of String parameter using == or != (ES_COMPARING_PARAMETER_STRING_WITH_EQ)\n用==或者!=方法去比较String类型的参数\n18.ES: Comparison of String objects using == or != (ES_COMPARING_STRINGS_WITH_EQ)\n用==或者！=去比较String类型的对象\n19.Eq: Abstract class defines covariant equals() method (EQ_ABSTRACT_SELF)\n20.Eq: Equals checks for noncompatible operand (EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS)\nequals方法检查不一致的操作。两个类根本就是父子关系而去调用equals方法去判读对象是否相等。\npublic boolean equals(Object o) {\n  if (o instanceof Foo)\n    return name.equals(((Foo)o).name);\n  else if (o instanceof String)\n    return name.equals(o);\n  else return false;\n21.Eq: Class defines compareTo(...) and uses Object.equals() (EQ_COMPARETO_USE_OBJECT_EQUALS)\n类中定义了compareTo方法但是继承了Object中的compareTo方法\n22.Eq: equals method fails for subtypes (EQ_GETCLASS_AND_CLASS_CONSTANT)\n类中的equals方法可能被子类中的方法所破坏，当使用类似于Foo.class == o.getClass()的判断时考虑用this.getClass() == o.getClass()来替换\n23.Eq: Covariant equals() method defined (EQ_SELF_NO_OBJECT)\n类中定义了多个equals方法。正确的做法是覆写Object中的equals方法，它的参数为Object类型的对象。\n24.FI: Empty finalizer should be deleted (FI_EMPTY)\n为空的finalizer方法应该删除。一下关于finalizer的内容省略\n25.GC: Unchecked type in generic call (GC_UNCHECKED_TYPE_IN_GENERIC_CALL)\nThis call to a generic collection method passes an argument while compile type Object where a specific type from the generic type parameters is expected. Thus, neither the standard Java type system nor static analysis can provide useful information on whether the object being passed as a parameter is of an appropriate type.\n26.HE: Class defines equals() but not hashCode() (HE_EQUALS_NO_HASHCODE)\n方法定义了equals方法却没有定义hashCode方法\n27.HE: Class defines hashCode() but not equals() (HE_HASHCODE_NO_EQUALS)\n 类定义了hashCode方法去没有定义equal方法\n28.HE: Class defines equals() and uses Object.hashCode() (HE_EQUALS_USE_HASHCODE)\n一个类覆写了equals方法，没有覆写hashCode方法，使用了Object对象的hashCode方法\n29.HE: Class inherits equals() and uses Object.hashCode() (HE_INHERITS_EQUALS_USE_HASHCODE)\n子类继承了父类的equals方法却使用了Object的hashCode方法\n30.IC: Superclass uses subclass during initialization (IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION)\n子类在父类未初始化之前使用父类对象实例\npublic class CircularClassInitialization {\n        static class InnerClassSingleton extends CircularClassInitialization {\nstatic InnerClassSingleton singleton = new InnerClassSingleton();\n        }        \n        static CircularClassInitialization foo = InnerClassSingleton.singleton;\n}\n31.IMSE: Dubious catching of IllegalMonitorStateException (IMSE_DONT_CATCH_IMSE)\n捕捉违法的监控状态异常，例如当没有获取到对象锁时使用其wait和notify方法\n32.ISC: Needless instantiation of class that only supplies static methods (ISC_INSTANTIATE_STATIC_CLASS)\n为使用静态方法而创建一个实例对象。调用静态方法时只需要使用类名+静态方法名就可以了。\n33.It: Iterator next() method can't throw NoSuchElementException (IT_NO_SUCH_ELEMENT)\n迭代器的next方法不能够抛出NoSuchElementException\n34.J2EE: Store of non serializable object into HttpSession (J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION)\n在HttpSession对象中保存非连续的对象\n35.JCIP: Fields of immutable classes should be final (JCIP_FIELD_ISNT_FINAL_IN_IMMUTABLE_CLASS)\n The class is annotated with net.jcip.annotations.Immutable, and the rules for that annotation require that all fields are final. .\n36.NP: Method with Boolean return type returns explicit null (NP_BOOLEAN_RETURN_NULL)\n返回值为boolean类型的方法直接返回null，这样会导致空指针异常\n37.NP: equals() method does not check for null argument (NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT)\n变量调用equals方法时没有进行是否为null的判断\n38.NP: toString method may return null (NP_TOSTRING_COULD_RETURN_NULL)\ntoString方法可能返回null\n39.Nm: Class names should start with an upper case letter (NM_CLASS_NAMING_CONVENTION)\n类的名称以大写字母名称开头\n40.Nm: Class is not derived from an Exception, even though it is named as such (NM_CLASS_NOT_EXCEPTION)\n类的名称中含有Exception但是却不是一个异常类的子类，这种名称会造成混淆\n41.Nm: Confusing method names (NM_CONFUSING)\n令人迷惑的方面命名\n42.Nm: Field names should start with a lower case letter (NM_FIELD_NAMING_CONVENTION)\n非final类型的字段需要遵循驼峰命名原则\n43.Nm: Use of identifier that is a keyword in later versions of Java (NM_FUTURE_KEYWORD_USED_AS_IDENTIFIER)\n验证是否是java预留关键字\n44.Nm: Use of identifier that is a keyword in later versions of Java (NM_FUTURE_KEYWORD_USED_AS_MEMBER_IDENTIFIER)\n验证是否时java中的关键字\n45.Nm: Method names should start with a lower case letter (NM_METHOD_NAMING_CONVENTION)\n方法名称以小写字母开头\n46.Nm: Class names shouldn't shadow simple name of implemented interface (NM_SAME_SIMPLE_NAME_AS_INTERFACE)\n实现同一接口实现类不能使用相同的名称，即使它们位于不同的包中\n47.Nm: Class names shouldn't shadow simple name of superclass (NM_SAME_SIMPLE_NAME_AS_SUPERCLASS)\n继承同一父类的子类不能使用相同的名称，即使它们位于不同的包中\n48.Nm: Very confusing method names (but perhaps intentional) (NM_VERY_CONFUSING_INTENTIONAL)\n很容易混淆的方法命名，例如方法的名称名称使用使用大小写来区别两个不同的方法。\n49.Nm: Method doesn't override method in superclass due to wrong package for parameter (NM_WRONG_PACKAGE_INTENTIONAL)\n由于错误引用了不同包中相同类名的对象而不能够正确的覆写父类中的方法\nimport alpha.Foo;\npublic class A {\n  public int f(Foo x) { return 17; }\n}\nimport beta.Foo;\npublic class B extends A {\n  public int f(Foo x) { return 42; }\n  public int f(alpha.Foo x) { return 27; }\n}\n50.ODR: Method may fail to close database resource (ODR_OPEN_DATABASE_RESOURCE)\n方法中可能存在关闭数据连接失败的情况\n51.OS: Method may fail to close stream (OS_OPEN_STREAM)\n方法中可能存在关闭流失败的情况\n52.OS: Method may fail to close stream on exception (OS_OPEN_STREAM_EXCEPTION_PATH)\n方法中可能存在关闭流时出现异常情况\n53.RC: Suspicious reference comparison to constant (RC_REF_COMPARISON_BAD_PRACTICE)\n当两者为不同类型的对象时使用equals方法来比较它们的值是否相等，而不是使用==方法。例如比较的两者为java.lang.Integer, java.lang.Float\n54.RC: Suspicious reference comparison of Boolean values (RC_REF_COMPARISON_BAD_PRACTICE_BOOLEAN)\n使用== 或者 !=操作符来比较两个 Boolean类型的对象，建议使用equals方法。\n55.RR: Method ignores results of InputStream.read() (RR_NOT_CHECKED)\nInputStream.read方法忽略返回的多个字符，如果对结果没有检查就没法正确处理用户读取少量字符请求的情况。\n56.RR: Method ignores results of InputStream.skip() (SR_NOT_CHECKED)\nInputStream.skip()方法忽略返回的多个字符，如果对结果没有检查就没法正确处理用户跳过少量字符请求的情况\n57.RV: Method ignores exceptional return value (RV_RETURN_VALUE_IGNORED_BAD_PRACTICE)\n方法忽略返回值的异常信息\n58.SI: Static initializer creates instance before all static final fields assigned (SI_INSTANCE_BEFORE_FINALS_ASSIGNED)\n在所有的static final字段赋值之前去使用静态初始化的方法创建一个类的实例。\n59.Se: Non-serializable value stored into instance field of a serializable class (SE_BAD_FIELD_STORE)\n非序列化的值保存在声明为序列化的的非序列化字段中\n60.Se: Comparator doesn't implement Serializable (SE_COMPARATOR_SHOULD_BE_SERIALIZABLE)\nComparator接口没有实现Serializable接口\n61.Se: Serializable inner class (SE_INNER_CLASS)\n序列化内部类\n62.Se: serialVersionUID isn't final (SE_NONFINAL_SERIALVERSIONID)\n关于UID类的检查内容省略\n63.Se: Class is Serializable but its superclass doesn't define a void constructor (SE_NO_SUITABLE_CONSTRUCTOR)\n子类序列化时父类没有提供一个void的构造函数\n64.Se: Class is Externalizable but doesn't define a void constructor (SE_NO_SUITABLE_CONSTRUCTOR_FOR_EXTERNALIZATION)\nExternalizable 实例类没有定义一个void类型的构造函数\n65.Se: The readResolve method must be declared with a return type of Object. (SE_READ_RESOLVE_MUST_RETURN_OBJECT)\nreadResolve从流中读取类的一个实例，此方法必须声明返回一个Object类型的对象\n66.Se: Transient field that isn't set by deserialization. (SE_TRANSIENT_FIELD_NOT_RESTORED)\nThis class contains a field that is updated at multiple places in the class, thus it seems to be part of the state of the class. However, since the field is marked as transient and not set in readObject or readResolve, it will contain the default value in any deserialized instance of the class.\n67.SnVI: Class is Serializable, but doesn't define serialVersionUID (SE_NO_SERIALVERSIONID)\n一个类实现了Serializable接口但是没有定义serialVersionUID类型的变量。序列化运行时使用一个称为 serialVersionUID 的版本号与每个可序列化类相关联，该序列号在反序列化过程中用于验证序列化对象的发送者和接收者是否为该对象加载了与序列化兼容的类。如果接收者加载的该对象的类的 serialVersionUID 与对应的发送者的类的版本号不同，则反序列化将会导致 InvalidClassException。可序列化类可以通过声明名为 \"serialVersionUID\" 的字段（该字段必须是静态 (static)、最终 (final) 的 long 型字段）显式声明其自己的 serialVersionUID： \n ANY-ACCESS-MODIFIER static final long serialVersionUID = 42L;\n68.UI: Usage of GetResource may be unsafe if class is extended (UI_INHERITANCE_UNSAFE_GETRESOURCE)\n当一个类被子类继承后不要使用this.getClass().getResource(...)来获取资源\n \n### 四、Correctness关于代码正确性相关方面的\n1.BC: Impossible cast (BC_IMPOSSIBLE_CAST)\n不可能的类转换，执行时会抛出ClassCastException\n2.BC: Impossible downcast (BC_IMPOSSIBLE_DOWNCAST)\n父类在向下进行类型转换时抛出ClassCastException\n3.BC: Impossible downcast of toArray() result (BC_IMPOSSIBLE_DOWNCAST_OF_TOARRAY)\n集合转换为数组元素时发生的类转换错误。\nThis code is casting the result of calling toArray() on a collection to a type more specific than Object[], as in: \nString[] getAsArray(Collection<String> c) {\n  return (String[]) c.toArray();\n  }\nThis will usually fail by throwing a ClassCastException. The toArray() of almost all collections return an Object[]. They can't really do anything else, since the Collection object has no reference to the declared generic type of the collection. \nThe correct way to do get an array of a specific type from a collection is to use c.toArray(new String[]); or c.toArray(new String[c.size()]); (the latter is slightly more efficient). \n4.BC: instanceof will always return false (BC_IMPOSSIBLE_INSTANCEOF)\n采用instaneof方法进行比较时总是返回false。前提是保证它不是由于某些逻辑错误造成的。\n5.BIT: Incompatible bit masks (BIT_AND)\n错误的使用&位操作符，例如(e & C)\n6.BIT: Check to see if ((...) & 0) == 0 (BIT_AND_ZZ)\n检查恒等的逻辑错误\n7.BIT: Incompatible bit masks (BIT_IOR)\n错误的使用|位操作符，例如(e | C)\n8.BIT: Check for sign of bitwise operation (BIT_SIGNED_CHECK_HIGH_BIT)\n检查逻辑运算符操作返回的标识。例如((event.detail & SWT.SELECTED) > 0)，建议采用!=0代替>0\n9.BOA: Class overrides a method implemented in super class Adapter wrongly (BOA_BADLY_OVERRIDDEN_ADAPTER)\n子类错误的覆写父类中用于适配监听其他事件的方法，从而导致当触发条件发生时不能被监听者调用\n10.Bx: Primitive value is unboxed and coerced for ternary operator (BX_UNBOXED_AND_COERCED_FOR_TERNARY_OPERATOR)\n在三元运算符操作时如果没有对值进行封装或者类型转换。例如：b ? e1 : e2\n11.DLS: Dead store of class literal (DLS_DEAD_STORE_OF_CLASS_LITERAL)\n以类的字面名称方式为一个字段赋值后再也没有去使用它，在1.4jdk中它会自动调用静态的初始化方法，而在jdk1.5中却不会去执行。\n12.DLS: Overwritten increment (DLS_OVERWRITTEN_INCREMENT)\n覆写增量增加错误i = i++\n13.DMI: Bad constant value for month (DMI_BAD_MONTH)\nhashNext方法调用next方法。\n14.DMI: Collections should not contain themselves (DMI_COLLECTIONS_SHOULD_NOT_CONTAIN_THEMSELVES)\n集合没有包含他们自己本身。\n15.DMI: Invocation of hashCode on an array (DMI_INVOKING_HASHCODE_ON_ARRAY)\n数组直接使用hashCode方法来返回哈希码。\nint [] a1 = new int[]{1,2,3,4};\n        System.out.println(a1.hashCode());\n        System.out.println(java.util.Arrays.hashCode(a1));\n16.DMI: Double.longBitsToDouble invoked on an int (DMI_LONG_BITS_TO_DOUBLE_INVOKED_ON_INT)\n17.DMI: Vacuous call to collections (DMI_VACUOUS_SELF_COLLECTION_CALL)\n集合的调用不能被感知。例如c.containsAll(c)总是返回true，而c.retainAll(c)的返回值不能被感知。\n18.Dm: Can't use reflection to check for presence of annotation without runtime retention (DMI_ANNOTATION_IS_NOT_VISIBLE_TO_REFLECTION)\nUnless an annotation has itself been annotated with @Retention(RetentionPolicy.RUNTIME), the annotation can't be observed using reflection (e.g., by using the isAnnotationPresent method). .\n19.Dm: Useless/vacuous call to EasyMock method (DMI_VACUOUS_CALL_TO_EASYMOCK_METHOD)\nWhile ScheduledThreadPoolExecutor inherits from ThreadPoolExecutor, a few of the inherited tuning methods are not useful for it. In particular, because it acts as a fixed-sized pool using corePoolSize threads and an unbounded queue, adjustments to maximumPoolSize have no useful effect.\n20.EC: equals() used to compare array and nonarray (EC_ARRAY_AND_NONARRAY)\n数组对象使用equals方法和非数组对象进行比较。即使比较的双方都是数组对象也不应该使用equals方法，而应该比较它们的内容是否相等使用java.util.Arrays.equals(Object[], Object[]);\n21.EC: equals(...) used to compare incompatible arrays (EC_INCOMPATIBLE_ARRAY_COMPARE)\n使用equls方法去比较类型不相同的数组。例如：String[] and StringBuffer[], or String[] and int[]\n22.EC: Call to equals() with null argument (EC_NULL_ARG)\n调用equals的对象为null\n23.EC: Call to equals() comparing unrelated class and interface (EC_UNRELATED_CLASS_AND_INTERFACE)\n使用equals方法比较不相关的类和接口\n24.EC: Call to equals() comparing different interface types (EC_UNRELATED_INTERFACES)\n调用equals方法比较不同类型的接口\n25.EC: Call to equals() comparing different types (EC_UNRELATED_TYPES)\n调用equals方法比较不同类型的类\n26.EC: Using pointer equality to compare different types (EC_UNRELATED_TYPES_USING_POINTER_EQUALITY)\nThis method uses using pointer equality to compare two references that seem to be of different types. The result of this comparison will always be false at runtime.\n27.Eq: equals method always returns false (EQ_ALWAYS_FALSE)\n使用equals方法返回值总是false\n28.Eq: equals method always returns true (EQ_ALWAYS_TRUE)\nequals方法返回值总是true\n29.Eq: equals method compares class names rather than class objects (EQ_COMPARING_CLASS_NAMES)\n使用equals方法去比较一个类的实例和类的类型\n30.Eq: Covariant equals() method defined for enum (EQ_DONT_DEFINE_EQUALS_FOR_ENUM)\nThis class defines an enumeration, and equality on enumerations are defined using object identity. Defining a covariant equals method for an enumeration value is exceptionally bad practice, since it would likely result in having two different enumeration values that compare as equals using the covariant enum method, and as not equal when compared normally. Don't do it.\n31.Eq: equals() method defined that doesn't override equals(Object) (EQ_OTHER_NO_OBJECT)\n类中定义的equals方法时不要覆写equals（Object）方法\n32.Eq: equals() method defined that doesn't override Object.equals(Object) (EQ_OTHER_USE_OBJECT)\n类中定义的equals方法时不要覆写Object中的equals（Object）方法\n33.Eq: equals method overrides equals in superclass and may not be symmetric (EQ_OVERRIDING_EQUALS_NOT_SYMMETRIC)\n34.Eq: Covariant equals() method defined, Object.equals(Object) inherited (EQ_SELF_USE_OBJECT)\n类中定义了一组equals方法，但是都是继承的java.lang.Object class中的equals(Object)方法\n35.FE: Doomed test for equality to NaN (FE_TEST_IF_EQUAL_TO_NOT_A_NUMBER)\nThis code checks to see if a floating point value is equal to the special Not A Number value (e.g., if (x == Double.NaN)). However, because of the special semantics of NaN, no value is equal to Nan, including NaN. Thus, x == Double.NaN always evaluates to false. To check to see if a value contained in x is the special Not A Number value, use Double.isNaN(x) (or Float.isNaN(x) if x is floating point precision).\n36.FS: Format string placeholder incompatible with passed argument (VA_FORMAT_STRING_BAD_ARGUMENT)\n错误使用参数类型来格式化字符串\n37.FS: The type of a supplied argument doesn't match format specifier (VA_FORMAT_STRING_BAD_CONVERSION)\n指定的格式字符串和参数类型不匹配，例如：String.format(\"%d\", \"1\")\n38.FS: MessageFormat supplied where printf style format expected (VA_FORMAT_STRING_EXPECTED_MESSAGE_FORMAT_SUPPLIED)\n但用String的format方法时实际调用了ＭｅｓｓａｇｅＦｏｒｍａｔ中干的格式化方法而引起格式化结果出错。\n39.FS: More arguments are passed than are actually used in the format string (VA_FORMAT_STRING_EXTRA_ARGUMENTS_PASSED)\n使用String的format方法时有非法的参数也经过了格式化操作。\n40.FS: Illegal format string (VA_FORMAT_STRING_ILLEGAL)\n格式化String对象语句错误\n41.FS: Format string references missing argument (VA_FORMAT_STRING_MISSING_ARGUMENT)\nString的format操作缺少必要的参数。\n42.FS: No previous argument for format string (VA_FORMAT_STRING_NO_PREVIOUS_ARGUMENT)\n格式字符串定义错误，例如：formatter.format(\"%<s %s\", \"a\", \"b\"); 抛出MissingFormatArgumentException异常\n43.GC: No relationship between generic parameter and method argument (GC_UNRELATED_TYPES)\nThis call to a generic collection method contains an argument with an incompatible class from that of the collection's parameter (i.e., the type of the argument is neither a supertype nor a subtype of the corresponding generic type argument). Therefore, it is unlikely that the collection contains any objects that are equal to the method argument used here. Most likely, the wrong value is being passed to the method.\nIn general, instances of two unrelated classes are not equal. For example, if the Foo and Bar classes are not related by subtyping, then an instance of Foo should not be equal to an instance of Bar. Among other issues, doing so will likely result in an equals method that is not symmetrical. For example, if you define the Foo class so that a Foo can be equal to a String, your equals method isn't symmetrical since a String can only be equal to a String. \nIn rare cases, people do define nonsymmetrical equals methods and still manage to make their code work. Although none of the APIs document or guarantee it, it is typically the case that if you check if a Collection<String> contains a Foo, the equals method of argument (e.g., the equals method of the Foo class) used to perform the equality checks. \n44.HE: Signature declares use of unhashable class in hashed construct (HE_SIGNATURE_DECLARES_HASHING_OF_UNHASHABLE_CLASS)\nA method, field or class declares a generic signature where a non-hashable class is used in context where a hashable class is required. A class that declares an equals method but inherits a hashCode() method from Object is unhashable, since it doesn't fulfill the requirement that equal objects have equal hashCodes.\n45.HE: Use of class without a hashCode() method in a hashed data structure (HE_USE_OF_UNHASHABLE_CLASS)\nA class defines an equals(Object) method but not a hashCode() method, and thus doesn't fulfill the requirement that equal objects have equal hashCodes. An instance of this class is used in a hash data structure, making the need to fix this problem of highest importance.\n46.ICAST: integral value cast to double and then passed to Math.ceil (ICAST_INT_CAST_TO_DOUBLE_PASSED_TO_CEIL)\nintegral的值转换为double后使用了Math.ceil方法\n47.ICAST: int value cast to float and then passed to Math.round (ICAST_INT_CAST_TO_FLOAT_PASSED_TO_ROUND)\nint 类型的值转换为float类型之后调用了Math.round方法\n48.IJU: JUnit assertion in run method will not be noticed by JUnit (IJU_ASSERT_METHOD_INVOKED_FROM_RUN_METHOD)\n在JUnit中的断言在run方法中不会被告知\n49.IJU: TestCase declares a bad suite method (IJU_BAD_SUITE_METHOD)\n在一个JUnit类中声明的一个suite()方法必须声明为\npublic static junit.framework.Test suite()\n或者\npublic static junit.framework.TestSuite suite()的形式。\n50.IL: A collection is added to itself (IL_CONTAINER_ADDED_TO_ITSELF)\n集合本身作为add方法的参数，这样会引起内容溢出。\n51.IL: An apparent infinite loop (IL_INFINITE_LOOP)\n方法的自调用引起的死循环\n52.IM: Integer multiply of result of integer remainder (IM_MULTIPLYING_RESULT_OF_IREM)\n和整数余数进行乘法运算。例如：i % 60 * 1000 是进行(i % 60) * 1000运算而不是 i % (60 * 1000)\n53.INT: Bad comparison of nonnegative value with negative constant (INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE)\n保证非负数和负数进行比较\n54.INT: Bad comparison of signed byte (INT_BAD_COMPARISON_WITH_SIGNED_BYTE)\n比较有符合数，要先把有符号数转换为无符合数再进行比较\n55.IO: Doomed attempt to append to an object output stream (IO_APPENDING_TO_OBJECT_OUTPUT_STREAM)\n宣布试图在对象的输出流处添加元素，如果你希望能够添加进一个对象的输出流中必须保证对象的输出流处于打开状态。\n56.IP: A parameter is dead upon entry to a method but overwritten (IP_PARAMETER_IS_DEAD_BUT_OVERWRITTEN)\nThe initial value of this parameter is ignored, and the parameter is overwritten here. This often indicates a mistaken belief that the write to the parameter will be conveyed back to the caller.\n传入参数的值被忽略，但是对传入值进行了修改，并返回给了调用者\n57.MF: Class defines field that masks a superclass field (MF_CLASS_MASKS_FIELD)\n子类中定义了和父类中同名的字段。在调用时会出错\n58.MF: Method defines a variable that obscures a field (MF_METHOD_MASKS_FIELD)\n在方法中定义的局部变量和类变量或者父类变量同名，从而引起字段混淆。\n59.NP: Null pointer dereference (NP_ALWAYS_NULL)\n对象赋为null值后 没有被重新赋值\n60.NP: Null pointer dereference in method on exception path (NP_ALWAYS_NULL_EXCEPTION)\nA pointer which is null on an exception path is dereferenced here.  This will lead to a NullPointerException when the code is executed.  Note that because FindBugs currently does not prune infeasible exception paths, this may be a false warning.\nAlso note that FindBugs considers the default case of a switch statement to be an exception path, since the default case is often infeasible.\n空指针引用上调用去除引用方法，将发生空指针异常\n61.NP: Method does not check for null argument (NP_ARGUMENT_MIGHT_BE_NULL)\n方法没有判断参数是否为空\n62.NP: close() invoked on a value that is always null (NP_CLOSING_NULL)\n一个为空的对象调用close方法\n63.NP: Null value is guaranteed to be dereferenced (NP_GUARANTEED_DEREF)\nThere is a statement or branch that if executed guarantees that a value is null at this point, and that value that is guaranteed to be dereferenced (except on forward paths involving runtime exceptions).\n在正常的null判断分支上，对象去除引用操作是受保护的不允许的\n64.NP: Value is null and guaranteed to be dereferenced on exception path (NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH)\nThere is a statement or branch on an exception path that if executed guarantees that a value is null at this point, and that value that is guaranteed to be dereferenced (except on forward paths involving runtime exceptions).\n65.NP: Method call passes null to a nonnull parameter (NP_NONNULL_PARAM_VIOLATION)\n方法中为null的参数没有被重新赋值\n        void test(){\nString ss = null;\nsya(ss);\n        }        \n        public void sya(String ad){\nad.getBytes();\n        }\n66.NP: Method may return null, but is declared @NonNull (NP_NONNULL_RETURN_VIOLATION)\n方法声明了返回值不能为空，但是方法中有可能返回null\n67.NP: A known null value is checked to see if it is an instance of a type (NP_NULL_INSTANCEOF)\n检查一个为null的值是否是想要的类型对象，而不是由于粗心或者逻辑错误引起的\n68.NP: Possible null pointer dereference (NP_NULL_ON_SOME_PATH)\n对象可能没有重新赋值\n69.NP: Possible null pointer dereference in method on exception path (NP_NULL_ON_SOME_PATH_EXCEPTION)\nA reference value which is null on some exception control path is dereferenced here.  This may lead to a NullPointerException when the code is executed.  Note that because FindBugs currently does not prune infeasible exception paths, this may be a false warning.\nAlso note that FindBugs considers the default case of a switch statement to be an exception path, since the default case is often infeasible.\n在异常null值处理分支调用的方法上，可能存在对象去除引用操作\n70.NP: Method call passes null for nonnull parameter (NP_NULL_PARAM_DEREF_ALL_TARGETS_DANGEROUS)\n方法参数中声明为nonnull类型的参数为null\nvoid test(){\nString ss = null;\nsya(ss);\n        }        \n        public void sya(@nonnull String ad){\nad.getBytes();\n        }\n71.NP: Store of null value into field annotated NonNull (NP_STORE_INTO_NONNULL_FIELD)\n为一个已经声明为不能为null值的属性赋值为null。\n72.Nm: Class defines equal(Object); should it be equals(Object)? (NM_BAD_EQUAL)\n类中定义了一个equal方法但是却不是覆写的Object对象的equals方法\n73.Nm: Class defines hashcode(); should it be hashCode()? (NM_LCASE_HASHCODE)\n类中定义了一个hashCode方法但是却不是覆写的Object中的hashCode方法\n74.Nm: Class defines tostring(); should it be toString()? (NM_LCASE_TOSTRING)\n类中定义了一个toString方法但是却不是覆写的Object中的toString方法\n75.Nm: Apparent method/constructor confusion (NM_METHOD_CONSTRUCTOR_CONFUSION)\n构造方法定义混乱，保证一个标准的构造函数。        例如：\n        SA(){        }\n        void SA(){\n        }\n76.Nm: Very confusing method names (NM_VERY_CONFUSING)\n混乱的方法命名，如getName和getname方法同时出现的时候\n77.Nm: Method doesn't override method in superclass due to wrong package for parameter (NM_WRONG_PACKAGE)\n方法因为取了不同包中的同名的对象而没有正确覆写父类中的同名方法\nimport alpha.Foo;\npublic class A {\n  public int f(Foo x) { return 17; }\n}\n\nimport beta.Foo;\npublic class B extends A {\n  public int f(Foo x) { return 42; }\n}\n78.QBA: Method assigns boolean literal in boolean expression (QBA_QUESTIONABLE_BOOLEAN_ASSIGNMENT)\n再if或者while表达式中使用boolean类型的值时应该使用==去判断，而不是采用=操作\n79.RC: Suspicious reference comparison (RC_REF_COMPARISON)\n比较两个对象值是否相等时应该采用equals方法，而不是==方法\n80.RE: Invalid syntax for regular expression (RE_BAD_SYNTAX_FOR_REGULAR_EXPRESSION)\n对正则表达式使用了错误的语法，会抛出未经检查的异常，表明正则表达式模式中的语法错误。\n81.RE: File.separator used for regular expression (RE_CANT_USE_FILE_SEPARATOR_AS_REGULAR_EXPRESSION)\n使用正则表达式使用了错误的文件分隔符，在windows系统中正则表达式不会匹配’\\’而应该使用'\\\\'\n82.RV: Random value from 0 to 1 is coerced to the integer 0 (RV_01_TO_INT)\n从0到1随机值被强制为整数值0。在强制得到一个整数之前，你可能想得到多个随机值。或使用Random.nextInt（n）的方法。\n83.RV: Bad attempt to compute absolute value of signed 32-bit hashcode (RV_ABSOLUTE_VALUE_OF_HASHCODE)\n此代码生成一个哈希码，然后计算该哈希码的绝对值。如果哈希码是Integer.MIN_VALUE的，那么结果将是负数（因为Math.abs（Integer.MIN_VALUE的）== Integer.MIN_VALUE的）。\n在2^ 32值之外字符串有一个Integer.MIN_VALUE的hashCode包括“polygenelubricants”，“GydZG_”和“，”DESIGNING WORKHOUSES “。\n84.RV: Bad attempt to compute absolute value of signed 32-bit random integer (RV_ABSOLUTE_VALUE_OF_RANDOM_INT)\n此代码生成一个随机的符号整数，然后计算该随机整数的绝对值。如果随机数生成数绝对值为Integer.MIN_VALUE的，那么结果将是负数（因为Math.abs（Integer.MIN_VALUE的）== Integer.MIN_VALUE的）。\n85.RV: Exception created and dropped rather than thrown (RV_EXCEPTION_NOT_THROWN)\n此代码创建一个异常（或错误）的对象，但不会用它做任何事情。例如：if (x < 0)\n  new IllegalArgumentException(\"x must be nonnegative\");\n这可能是程序员的意图抛出创建的异常：\nif (x < 0)\n  throw new IllegalArgumentException(\"x must be nonnegative\");\n86.RV: Method ignores return value (RV_RETURN_VALUE_IGNORED)\n该方法的返回值应该进行检查。这种警告通常出现在调用一个不可变对象的方法，认为它更新了对象的值。例如：String dateString = getHeaderField(name);\ndateString.trim();\n程序员似乎以为trim（）方法将更新dateString引用的字符串。但由于字符串是不可改变的，trim（）函数返回一个新字符串值，在这里它是被忽略了。该代码应更正：\nString dateString = getHeaderField(name);\ndateString = dateString.trim();\n87.RpC: Repeated conditional tests (RpC_REPEATED_CONDITIONAL_TEST)\n该代码包含对同一个条件试验了两次，两边完全一样例如：（如X == 0 | | x == 0）。可能第二次出现是打算判断别的不同条件（如X == 0 | | y== 0）。\n88.SA: Double assignment of field (SA_FIELD_DOUBLE_ASSIGNMENT)\n方法中的字段包含了双重任务，例如： \n int x;\n  public void foo() {\n   x = x = 17;\n  }\n这种为变量赋值是无用的，并可能表明一个逻辑错误或拼写错误。\n89.SA: Self assignment of field (SA_FIELD_SELF_ASSIGNMENT)\n方法中包含自己对自己赋值的字段。例如：\nint x;\n  public void foo() {\n    x = x;\n  }\n90.SA: Self comparison of field with itself (SA_FIELD_SELF_COMPARISON)\n字段自己进行自比较可能表明错误或逻辑错误。\n91.SA: Self comparison of value with itself (SA_LOCAL_SELF_COMPARISON)\n方法中对一个局部变量自身进行比较运算，并可说明错误或逻辑错误。请确保您是比较正确的事情。\n92.SA: Nonsensical self computation involving a variable (e.g., x & x) (SA_LOCAL_SELF_COMPUTATION)\n此方法对同一变量执行了荒谬的计算（如x&x或x-x）操作。由于计算的性质，这一行动似乎没有意义，并可能表明错误或逻辑错误。\n93.SF: Dead store due to switch statement fall through (SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH)\n在swtich中先前的case值因为swtich执行失败而被覆写，这就像是忘记使用break推出或者没有使用return语句放回先前的值一样。\n94.SF: Dead store due to switch statement fall through to throw (SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH_TO_THROW)\n在swtich中因为出现异常而忽略了对case值的保存。\n95.SIC: Deadly embrace of non-static inner class and thread local (SIC_THREADLOCAL_DEADLY_EMBRACE)\n如果是一个静态内部类。实际上，在内部类和当前线程有死锁的可能。由于内部类不是静态的，它保留了对外部类的引用。如果线程包含对一个内部类实例的引用，那么内外实例的实例都可以被获取，这样就不具备垃圾会回收的资格。\n96.SIO: Unnecessary type check done using instanceof operator (SIO_SUPERFLUOUS_INSTANCEOF)\n在进行instanceof操作时进行没有必要的类型检查\n97.STI: Unneeded use of currentThread() call, to call interrupted() (STI_INTERRUPTED_ON_CURRENTTHREAD)\n此方法调用Thread.currentThread（）调用，只需调用interrupted（）方法。由于interrupted（）是一个静态方法， Thread.interrupted（）更简单易用。\n98.STI: Static Thread.interrupted() method invoked on thread instance (STI_INTERRUPTED_ON_UNKNOWNTHREAD)\n调用不是当前线程对象的Thread.interrupted()方法，由于interrupted（）方法是静态的，interrupted方法将会调用一个和作者原计划不同的对象。\n99.Se: Method must be private in order for serialization to work (SE_METHOD_MUST_BE_PRIVATE)\n这个类实现了Serializable接口，并定义自定义序列化的方法/反序列化。但由于这种方法不能声明为private，将被序列化/反序列化的API忽略掉。\n100.Se: The readResolve method must not be declared as a static method. (SE_READ_RESOLVE_IS_STATIC)\n为使readResolve方法得到序列化机制的识别，不能作为一个静态方法来声明。\n101.UMAC: Uncallable method defined in anonymous class (UMAC_UNCALLABLE_METHOD_OF_ANONYMOUS_CLASS)\n在匿名类中定义了一个既没有覆写超类中方法也不能直接调用的方法。因为在其他类的方法不能直接引用匿名类声明的方法，似乎这种方法不能被调用，这种方法可能只是没有任何作用的代码，但也可能覆写超类中声明。\n102.UR: Uninitialized read of field in constructor (UR_UNINIT_READ)\n此构造方法中使用了一个尚未赋值的字段或属性。\n        String a;\n        public SA() {\nString abc = a;\nSystem.out.println(abc);\n        }\n103.UR: Uninitialized read of field method called from constructor of superclass (UR_UNINIT_READ_CALLED_FROM_SUPER_CONSTRUCTOR)\n方法被超类的构造函数调用时，在当前类中的字段或属性还没有被初始化。例如：\nabstract class A {\n  int hashCode;\n  abstract Object getValue();\n  A() {\n    hashCode = getValue().hashCode();\n    }\n  }\nclass B extends A {\n  Object value;\n  B(Object v) {\n    this.value = v;\n    }\n  Object getValue() {\n    return value;\n  }\n  }\n当B是创建时，A的构造函数将在B为value赋值之前触发，然而在A的初始化方法调用getValue方法时value这个变量还没有被初始化。\n104.USELESS_STRING: Invocation of toString on an array (DMI_INVOKING_TOSTRING_ON_ANONYMOUS_ARRAY)\n该代码调用上匿名数组的toString（）方法，产生的结果形如[@ 16f0472并没有实际的意义。考虑使用Arrays.toString方法来转换成可读的字符串，提供该数组的内容数组。例如：\nString[] a = { \"a\" };\nSystem.out.println(a.toString());\n//正确的使用为\nSystem.out.println(Arrays.toString(a));\n105.USELESS_STRING: Invocation of toString on an array (DMI_INVOKING_TOSTRING_ON_ARRAY)\n该代码调用上数组的toString（）方法，产生的结果形如[@ 16f0472并不能显示数组的真实内容。考虑使用Arrays.toString方法来转换成可读的字符串，提供该数组的内容数组\n106.UwF: Field only ever set to null (UWF_NULL_FIELD)\n字段的值总是为null值，所有读取该字段的值都为null。检查错误，如果它确实没有用就删除掉。\n107.UwF: Unwritten field (UWF_UNWRITTEN_FIELD\n此字段是永远不会写入值。所有读取将返回默认值。检查错误（如果它被初始化？），如果它确实没有用就删除掉。\n\n### 五：Performance关于代码性能相关方面的\n1.Bx: Primitive value is boxed and then immediately unboxed (BX_BOXING_IMMEDIATELY_UNBOXED)\n对原始值进行装箱，然后立即取消装箱。这可能是在一个未要求装箱的地方进行了手动装箱，从而迫使编译器进行立即撤消装箱的操作\n2.Bx: Primitive value is boxed then unboxed to perform primitive coercion (BX_BOXING_IMMEDIATELY_UNBOXED_TO_PERFORM_COERCION)\n对原始值进行装箱然后立即把它强制转换为另外一种原始类型。例如：\nnew Double(d).intValue()应该直接进行强制转换例如：(int) d\n3.Bx: Method allocates a boxed primitive just to call toString (DM_BOXED_PRIMITIVE_TOSTRING)\n仅仅为了调用封装类的toString()而对原始类型进行封装操作。比这种方法更有效的是调用封装类的toString(…)方法例如：\nnew Integer(1).toString()    替换为   Integer.toString(1)\nnew Long(1).toString()    替换为   Long.toString(1) \nnew Float(1.0).toString()    替换为   Float.toString(1.0) \nnew Double(1.0).toString()    替换为   Double.toString(1.0) \nnew Byte(1).toString()    替换为   Byte.toString(1) \nnew Short(1).toString()    替换为   Short.toString(1) \nnew Boolean(true).toString()    替换为   Boolean.toString(true)\n4.Bx: Method invokes inefficient floating-point Number constructor; use static valueOf instead (DM_FP_NUMBER_CTOR)\n使用new Double(double)方法总是会创建一个新的对象，然而使用Double.valueOf(double)方法可以把值保存在编辑器或者class library、JVM中。使用存储值的方式来避免对象的分配可以或得更好的代码性能\n除非类必须符合Java 1.5以前的JVM，否则请使用自动装箱或valueOf（）方法创建Double和Float实例。\n5.Bx: Method invokes inefficient Number constructor; use static valueOf instead (DM_NUMBER_CTOR)\n使用new Integer(int)方法总是会创建一个新的对象，然而使用Integer.valueOf(int)方法可以把值保存在编辑器或者class library、JVM中。使用存储值的方式来避免对象的分配可以或得更好的代码性能\n除非类必须符合Java 1.5以前的JVM，否则请使用自动装箱或valueOf（）方法创建Long, Integer, Short, Character, Byte实例。\n6.Dm: The equals and hashCode methods of URL are blocking (DMI_BLOCKING_METHODS_ON_URL)\n使用equals和hashCode方法来对url进行资源标识符解析时会引起堵塞。考虑使用java.net.URI来代替。\n7.Dm: Maps and sets of URLs can be performance hogs (DMI_COLLECTION_OF_URLS)\n方法或者字段使用url的map/set集合。因为equals方法或者hashCode方法来进行资源标识符解析时都会引起堵塞。考虑使用java.net.URI来代替。\n8.Dm: Method invokes inefficient Boolean constructor; use Boolean.valueOf(...) instead (DM_BOOLEAN_CTOR)\n使用new方法创建一个java.lang.Boolean类型能够的实例对象是浪费空间的，因为Boolean对象是不可变的而且只有两个有用的值。使用Boolean.valueOf()或者Java1.5中的自动装箱功能来创建一个Boolean实例。\n9.Dm: Explicit garbage collection; extremely dubious except in benchmarking code (DM_GC)\n在代码中显式的调用垃圾回收命名，这样做并不能起作用。在过去，有人在关闭操作或者finalize方法中调用垃圾回收方法导致了很多的性能浪费。这样大规模回收对象时会造成处理器运行缓慢。\n10.Dm: Use the nextInt method of Random rather than nextDouble to generate a random integer (DM_NEXTINT_VIA_NEXTDOUBLE)\n 如果r是一个java.util.Random对象，你可以使r.nextInt(n)生成一个0到n-1之前的随机数，而不是使用(int)(r.nextDouble() * n)\n11.Dm: Method invokes inefficient new String(String) constructor (DM_STRING_CTOR)\n使用java.lang.String(String)构造函数会浪费内存因为这种构造方式和String作为参数在功能上容易混乱。只是使用String直接作为参数的形式\n12.Dm: Method invokes toString() method on a String (DM_STRING_TOSTRING)\n调用String.toString()是多余的操作，只要使用String就可以了。\n13.Dm: Method invokes inefficient new String() constructor (DM_STRING_VOID_CTOR)\n使用没有参数的构造方法去创建新的String对象是浪费内存空间的，因为这样创建会和空字符串“”混淆。Java中保证完成相同的构造方法会产生描绘相同的String对象。所以你只要使用空字符串来创建就可以了。\n14.ITA: Method uses toArray() with zero-length array argument (ITA_INEFFICIENT_TO_ARRAY)\n当使用集合的toArray()方法时使用数组长度为0的数组作为参数。比这更有效的一种方法是\nmyCollection.toArray(new Foo[myCollection.size()])，如果数组的长度足够大就可以直接把集合中的内容包装到数组中直接返回从而避免了第二次创建一个新的数组来存放集合中值。\n15.SBSC: Method concatenates strings using + in a loop (SBSC_USE_STRINGBUFFER_CONCATENATION)\n在循环中构建一个String对象时从性能上讲使用StringBuffer来代替String对象\n例如：\n// This is bad\n  String s = \"\";\n  for (int i = 0; i < field.length; ++i) {\n    s = s + field[i];\n  }\n  // This is better\n  StringBuffer buf = new StringBuffer();\n  for (int i = 0; i < field.length; ++i) {\n    buf.append(field[i]);\n  }\n  String s = buf.toString();\n16.SS: Unread field: should this field be static? (SS_SHOULD_BE_STATIC)\n类中所包含的final属性字段在编译器中初始化为静态的值。考虑在定义时就把它定义为static类型的。\n17.UM: Method calls static Math class method on a constant value (UM_UNNECESSARY_MATH)\n在方法中使用了java.lang.Math的静态方法代替常量来使用，使用常量速度和准确度会更好。 以下为Math中的方法产生的值。\nMethod Parameter \nabs -any- \nacos 0.0 or 1.0 \nasin 0.0 or 1.0 \natan 0.0 or 1.0 \natan2 0.0 cbrt 0.0 or 1.0 \nceil -any- \ncos 0.0 \ncosh 0.0 \nexp 0.0 or 1.0 \nexpm1 0.0 \nfloor -any- \nlog 0.0 or 1.0 \nlog10 0.0 or 1.0 \nrint -any- \nround -any- \nsin 0.0 \nsinh 0.0 \nsqrt 0.0 or 1.0 \ntan 0.0 \ntanh 0.0 \ntoDegrees 0.0 or 1.0 \ntoRadians 0.0\n18.UPM: Private method is never called (UPM_UNCALLED_PRIVATE_METHOD)\n定义为Private类型方法从未被调用，应该被删除。\n19.UrF: Unread field (URF_UNREAD_FIELD)\n类中定义的属性从未被调用，建议删除。\n20.UuF: Unused field (UUF_UNUSED_FIELD)\n类中定义的属性从未被使用，建议删除。\n21.WMI: Inefficient use of keySet iterator instead of entrySet iterator (WMI_WRONG_MAP_ITERATOR)\n当方法中接受一个Map类型的参数时，使用keySet的迭代器比使用entrySet的迭代器效率要高。\n### 六：Internationalization关于代码国际化相关方面的\nDm: Consider using Locale parameterized version of invoked method (DM_CONVERT_CASE)\n使用平台默认的编码格式对字符串进行大小写转换，这可能导致国际字符的转换不当。使用以下方式对字符进行转换\nString.toUpperCase( Locale l )\nString.toLowerCase( Locale l )\n\n### 七：Multithreaded correctness关于代码多线程正确性相关方面的\n1.DL: Synchronization on Boolean could lead to deadlock (DL_SYNCHRONIZATION_ON_BOOLEAN)\n该代码同步一个封装的原始常量，例如一个Boolean类型。\nprivate static Boolean inited = Boolean.FALSE;\n...\n  synchronized(inited) { \n    if (!inited) {\n       init();\n       inited = Boolean.TRUE;\n       }\n     }\n...\n由于通常只存在两个布尔对象，此代码可能是同步的其他无关的代码中相同的对象，这时会导致反应迟钝和可能死锁\n2.DL: Synchronization on boxed primitive could lead to deadlock (DL_SYNCHRONIZATION_ON_BOXED_PRIMITIVE)\n该代码同步一个封装的原始常量，例如一个Integer类型。\nprivate static Integer count = 0;\n...\n  synchronized(count) { \n     count++;\n     }\n...\n由于Integer对象可以共享和保存，此代码可能是同步的其他无关的代码中相同的对象，这时会导致反应迟钝和可能死锁\n3.DL: Synchronization on interned String could lead to deadlock (DL_SYNCHRONIZATION_ON_SHARED_CONSTANT)\n同步String类型的常量时，由于它被JVM中多个其他的对象所共有，这样在其他代码中会引起死锁。\n4.DL: Synchronization on boxed primitive values (DL_SYNCHRONIZATION_ON_UNSHARED_BOXED_PRIMITIVE)\n同步一个显然不是共有封装的原始值，例如一个Integer类型的对象。例如：\nprivate static final Integer fileLock = new Integer(1);\n...\n  synchronized(fileLock) { \n     .. do something ..\n     }\n...\n它最后被定义为以下方式来代替：private static final Object fileLock = new Object();\n5.Dm: Monitor wait() called on Condition (DM_MONITOR_WAIT_ON_CONDITION)\n方法中以java.util.concurrent.locks.Condition对象调用wait（）。等待一个条件发生时应该使用在Condition接口中定义的await()方法。\n6.Dm: A thread was created using the default empty run method (DM_USELESS_THREAD)\n这个方法没有通过run方法或者具体声明Thread类，也没有通过一个Runnable对象去定义一个线程，而这个线程出来浪费资源却什么也没有去做。\n7.ESync: Empty synchronized block (ESync_EMPTY_SYNC)\n该代码包含一个空的同步块：synchronized() {}\n8.IS: Inconsistent synchronization (IS2_INCONSISTENT_SYNC)\n不合理的同步\n9.IS: Field not guarded against concurrent access (IS_FIELD_NOT_GUARDED)\n域不是良好的同步访问---\n此字段被标注为net.jcip.annotations.GuardedBy，但可以在某种程度上违反注释而去访问\n10.JLM: Synchronization performed on Lock (JLM_JSR166_LOCK_MONITORENTER)\n实现java.util.concurrent.locks.Lock的对象调用了同步的方法。应该这样处理，对象被锁定/解锁时使用acquire（）/ release（）方法而不是使用同步的方法。\n11.LI: Incorrect lazy initialization of static field (LI_LAZY_INIT_STATIC)\n静态域不正确的延迟初始化--\n这种方法包含了一个不同步延迟初始化的非volatile静态字段。因为编译器或处理器可能会重新排列指令，如果该方法可以被多个线程调用，线程不能保证看到一个完全初始化的对象。你可以让字段可变来解决此问题\n12.LI: Incorrect lazy initialization and update of static field (LI_LAZY_INIT_UPDATE_STATIC)\n这种方法包含一个不同步延迟初始化的静态字段。之后为字段赋值，对象存储到该位置后进一步更新或访问。字段后尽快让其他线程能够访问。如果该方法的进一步访问该字段为初始化对象提供服务，然后你有一个非常严重的多线程bug，除非别的东西阻止任何其他线程访问存储的对象，直到它完全初始化。\n即使你有信心，该方法是永远不会被多个线程调用时，在它的值还没有被充分初始化或移动，不把它设定为static字段时它可能会更好。\n13.ML: Method synchronizes on an updated field (ML_SYNC_ON_UPDATED_FIELD)\n对象获取一个可变字段时进行同步。这是没有意义的，因为不同的线程可以在不同的对象同步。\n14.MSF: Mutable servlet field (MSF_MUTABLE_SERVLET_FIELD)\n一个web服务一般只能创建一个servlet或者jsp的实例（例如：treates是一个单利类），它会被多个线程调用这个实例的方法服务于多个同时的请求。因此使用易变的字段属性产生竞争的情况。\n15.MWN: Mismatched notify() (MWN_MISMATCHED_NOTIFY)\n此方法调用Object.notify（）或Object.notifyAll（）而没有获取到该对象的对象锁。调用notify（）或notifyAll（）而没有持有该对象的对象锁，将导致IllegalMonitorStateException异常。\n16.MWN: Mismatched wait() (MWN_MISMATCHED_WAIT)\n此方法调用Object.wait()而没有获取到该对象的对象锁。调用wait（）而没有持有该对象的对象锁，将导致IllegalMonitorStateException异常。\n17.NP: Synchronize and null check on the same field. (NP_SYNC_AND_NULL_CHECK_FIELD)\n如果代码块是同步的，那么久不可能为空。如果是空，同步时就会抛出NullPointerException异常。最好是在另一个代码块中进行同步。\n18.No: Using notify() rather than notifyAll() (NO_NOTIFY_NOT_NOTIFYALL)\n调用notify（）而不是notifyAll（）方法。 Java的监控器通常用于多个条件。调用notify（）只唤醒一个线程，这意味着该线程被唤醒只是满足的当前的唯一条件。\n19.RS: Class's readObject() method is synchronized (RS_READOBJECT_SYNC)\n序列化类中定义了同步的readObject（）。通过定义，反序列化创建的对象只有一个线程可以访问，因此没有必要的readObject（）进行同步。如果的readObject（）方法本身造成对象对另一个线程可见，那么这本身就是不好的编码方式。\n20.Ru: Invokes run on a thread (did you mean to start it instead?) (RU_INVOKE_RUN)\n这种方法显式调用一个对象的run（）。一般来说，类是实现Runnable接口的，因为在一个新的线程他们将有自己的run（）方法，在这种情况下Thread.start（）方法调用是正确的。\n21.SC: Constructor invokes Thread.start() (SC_START_IN_CTOR)\n在构造函数中启动一个线程。如果类曾经被子类扩展过，那么这很可能是错的，因为线程将在子类构造之前开始启动。\n22.SP: Method spins on field (SP_SPIN_ON_FIELD)\n方法无限循环读取一个字段。编译器可合法悬挂宣读循环，变成一个无限循环的代码。这个类应该改变，所以使用适当的同步（包括等待和通知要求）\n23.STCAL: Call to static Calendar (STCAL_INVOKE_ON_STATIC_CALENDAR_INSTANCE)\n即使JavaDoc对此不包含暗示，而Calendars本身在多线程中使用就是不安全的。探测器发现当调用Calendars的实例时将会获得一个静态对象。\nCalendar rightNow = Calendar.getInstance();\n24.STCAL: Call to static DateFormat (STCAL_INVOKE_ON_STATIC_DATE_FORMAT_INSTANCE)\n在官方的JavaDoc，DateFormats多线程使用本事就是不安全的。探测器发现调用一个DateFormat的实例将会获得一个静态对象。\nmyString = DateFormat.getDateInstance().format(myDate);\n25.STCAL: Static Calendar (STCAL_STATIC_CALENDAR_INSTANCE)\nCalendar在多线程中本身就是不安全的，如果在线程范围中共享一个Calendarde 实例而不使用一个同步的方法在应用中就会出现一些奇怪的行为。在sun.util.calendar.BaseCalendar.getCalendarDateFromFixedDate()中会抛出ArrayIndexOutOfBoundsExceptions or IndexOutOfBoundsExceptions异常。\n26.STCAL: Static DateFormat (STCAL_STATIC_SIMPLE_DATE_FORMAT_INSTANCE)\nDateFormat 在多线程中本身就是不安全的，如果在线程范围中共享一个DateFormat的实例而不使用一个同步的方法在应用中就会出现一些奇怪的行为。\n27.SWL: Method calls Thread.sleep() with a lock held (SWL_SLEEP_WITH_LOCK_HELD)\n当持有对象时调用Thread.sleep（）。这可能会导致很差的性能和可扩展性，或陷入死锁，因为其他线程可能正在等待获得锁。调用wait（）是一个更好的主意，释放对象的持有以允许其他线程运行。\n28.UG: Unsynchronized get method, synchronized set method (UG_SYNC_SET_UNSYNC_GET)\n这个类包含类似命名的get和set方法。在set方法是同步方法和get方法是非同步方法。这可能会导致在运行时的不正确行为，因为调用的get方法不一定返回对象一致状态。 GET方法应该同步。\n29.UL: Method does not release lock on all paths (UL_UNRELEASED_LOCK)\n方法获得了当前的对象所，但是在方法中始终没有释放它。一个正确的示例如下：\n  Lock l = ...;\n    l.lock();\n    try {\n        // do something\n    } finally {\n        l.unlock();\n    }\n30.UL: Method does not release lock on all exception paths (UL_UNRELEASED_LOCK_EXCEPTION_PATH)\n方法获得了当前的对象所，但是在所有的异常处理中始终没有释放它。一个正确的示例如下：\n  Lock l = ...;\n    l.lock();\n    try {\n        // do something\n    } finally {\n        l.unlock();\n    }\n31.UW: Unconditional wait (UW_UNCOND_WAIT)\n方法中包含调用java.lang.Object.wait（），而却没有放到条件流程控制中。该代码应确认条件尚未满足之前等待;先前任何通知将被忽略。\n32.VO: A volatile reference to an array doesn't treat the array elements as volatile (VO_VOLATILE_REFERENCE_TO_ARRAY)\n声明一个变量引用数组，这可能不是你想要的。如果一个变量引用数组，那么对引用数组的读和写都是不安全的，但是数组元素不是变量。取得数组的变量值你可以使用java.util.concurrent包中的数组的原子性特性\n33.WL: Sychronization on getClass rather than class literal (WL_USING_GETCLASS_RATHER_THAN_CLASS_LITERAL)\n实例的方法中同步this.getClass()，如果这个类有子类集合，那么子类集合中的对象将会在这个类的各个子类上进行同步，这不是我们想要的效果，我们只要同步当前的类对象而不包含它的所有子类，可以同步类名.getClass()。例如，java.awt.Label的代码：\n     private static final String base = \"label\";\n     private static int nameCounter = 0;\n     String constructComponentName() {\n        synchronized (getClass()) {\n            return base + nameCounter++;\n        }\n     }\nLabel中的子类集合不可能在同一个子对象上进行同步，替换上面的方法为：\n    private static final String base = \"label\";\n     private static int nameCounter = 0;\n     String constructComponentName() {\n        synchronized (Label.class) {\n            return base + nameCounter++;\n        }\n     }\n34.WS: Class's writeObject() method is synchronized but nothing else is (WS_WRITEOBJECT_SYNC)\n这个类有一个writeObject（）方法是同步的，但是这个类中没有其他的同步方法。\n35.Wa: Condition.await() not in loop (WA_AWAIT_NOT_IN_LOOP)\n方法没有在循环中调用java.util.concurrent.await()。如果对象是用于多种条件，打算调用wait()方法的条件可能不是实际发生的。\n36.Wa: Wait not in loop (WA_NOT_IN_LOOP)\n这种方法包含调用java.lang.Object.wait（），而这并不是一个循环。如果监视器用于多个条件，打算调用wait()方法的条件可能不是实际发生的。\n\n### 八：Malicious codevulnerability关于恶意破坏代码相关方面的\n1.EI: May expose internal representation by returning reference to mutable object (EI_EXPOSE_REP)\n返回一个易变对象引用并把它保存在对象字段中时会暴露对象内部的字段描述，如果接受不守信任的代码访问或者没有检查就去改变易变对象的会涉及对象的安全和其他重要属性的安全。返回一个对象的新副本，在很多情况下更好的办法。\n2.EI2: May expose internal representation by incorporating reference to mutable object (EI_EXPOSE_REP2)\n此代码把外部可变对象引用存储到对象的内部表示。如果实例受到不信任的代码的访问和没有检查的变化危及对象和重要属性的安全。存储一个对象的副本，在很多情况下是更好的办法。\n3.FI: Finalizer should be protected, not public (FI_PUBLIC_SHOULD_BE_PROTECTED)\n一个类中的finalize（）方法必须声明为protected，而不能为public类型\n4.MS: Public static method may expose internal representation by returning array (MS_EXPOSE_REP)\n一个public类型的静态方法返回一个数组，可能引用内部属性的暴露。任何代码调用此方法都可以自由修改底层数组。一个解决办法是返回一个数组的副本。\n5.MS: Field should be both final and package protected (MS_FINAL_PKGPROTECT)\n一个静态字段可能被恶意代码或另外一个包所改变的。字段可以放到protected包中也可以定义为final类型的以避免此问题。\n6.MS: Field is a mutable array (MS_MUTABLE_ARRAY)\n一个定义为final类型的静态字段引用一个数组时它可以被恶意代码或在另其他包中所使用。这些代码可以自由修改数组的内容。\n7.MS: Field is a mutable Hashtable (MS_MUTABLE_HASHTABLE)\n一个定义为final类型的静态字段引用一个Hashtable时可以被恶意代码或者在其他包中被调用，这些方法可以修改Hashtable的值。\n8.MS: Field should be moved out of an interface and made package protected (MS_OOI_PKGPROTECT)\n将域尽量不要定义在接口中，并声明为包保护\n在接口中定义了一个final类型的静态字段，如数组或哈希表等易变对象。这些对象可以被恶意代码或者在其他包中被调用，为了解决这个问题，需要把它定义到一个具体的实体类中并且声明为保护类型以避免这种错误。\n9.MS: Field should be package protected (MS_PKGPROTECT)\n一个静态字段是可以改变的恶意代码或其他的包访问修改。可以把这种类型的字段声明为final类型的以防止这种错误。\n\n### 十：Dodgy关于代码运行期安全方面的\n1.XSS: Servlet reflected cross site scripting vulnerability (XSS_REQUEST_PARAMETER_TO_SEND_ERROR)\n在代码中在Servlet输出中直接写入一个HTTP参数，这会造成一个跨站点的脚本漏洞。\n2.XSS: Servlet reflected cross site scripting vulnerability (XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER)\n代码直接写入参数的HTTP服务器错误页（使用HttpServletResponse.sendError）。表达了类似的不受信任的输入会引起跨站点脚本漏洞。\n3.BC: Questionable cast to abstract collection (BC_BAD_CAST_TO_ABSTRACT_COLLECTION)\n在代码投把一个集合强制类型转换为一个抽象的集合（如list，set或map）。保证该对象类型和将要转换的类型是一致的。如果你只是想要便利一个集合，那么你就不必将它转换为Set或List。\n4.BC: Questionable cast to concrete collection (BC_BAD_CAST_TO_CONCRETE_COLLECTION)\n代码把抽象的集合（如List，Set，或Collection）强制转换为具体落实类型（如一个ArrayList或HashSet）。这可能不正确，也可能使您的代码很脆弱，因为它使得难以在今后的切换指向其他具体实现。除非你有特别理由这样做，否则只需要使用抽象的集合类。\n5.BC: Unchecked/unconfirmed cast (BC_UNCONFIRMED_CAST)\n强制类型转换操作没有经过验证，而且不是所有的此种类型装换过的类都可以再强制类型转换为原类型。在代码中需要进行逻辑判断以保证可以进行这样的操作。\n6.BC: instanceof will always return true (BC_VACUOUS_INSTANCEOF)\ninstanceof测试将始终返回真（除非被测试的值为空）。虽然这是安全，确保它是不是说明一些误解或其他一些逻辑错误。如果你真的想测试是空的价值，也许会更清楚这样做的更好空试验，而不是一个instanceof测试。\n7.BSHIFT: Unsigned right shift cast to short/byte (ICAST_QUESTIONABLE_UNSIGNED_RIGHT_SHIFT)\n无符号数右移后进行转换为short或者byte类型时可能会丢弃掉高位的值，这样的结果就是有符合数和无符号数无法区分（这取决于移位大小）\n8.CI: Class is final but declares protected field (CI_CONFUSED_INHERITANCE)\n这个类被声明为final的，而是字段属性却声明为保护类型的。由于是final类，它不能再被继承，而再声明为保护类型的很容易造成混淆。为了从外部能正确的使用它应该把它们声明为private或者public类型。\n9.DB: Method uses the same code for two branches (DB_DUPLICATE_BRANCHES)\n此方法使用相同的代码，以实现两个有条件的分支。检查以确保这是不是一个编码错误。\n10.DB: Method uses the same code for two switch clauses (DB_DUPLICATE_SWITCH_CLAUSES)\n他的方法使用相同的代码来实现两个switch的声明条款。这可能是重复代码的情况，但可能也显示出编码的错误。\n11.DLS: Dead store to local variable (DLS_DEAD_LOCAL_STORE)\n该指令为局部变量赋值，但在其后的没有对她做任何使用。通常，这表明一个错误，因为值从未使用过。\n12.DLS: Useless assignment in return statement (DLS_DEAD_LOCAL_STORE_IN_RETURN)\n本声明把一个局部变量放到方法的返回语句中。这对于方法中局部变量来说是没有意思的。\n13.DLS: Dead store of null to local variable (DLS_DEAD_LOCAL_STORE_OF_NULL)\n把一个本地变量赋值为null值，并且再也没有对这个变量做任何的操作。这样可能是为了垃圾回收，而是Java SE 6.0，这已不再需要。\n14.DMI: Code contains a hard coded reference to an absolute pathname (DMI_HARDCODED_ABSOLUTE_FILENAME)\n此代码包含文件对象为一个绝对路径名（例如，新的文件（“/ home/dannyc/workspace/j2ee/src/share/com/sun/enterprise/deployment”）;\n15.DMI: Non serializable object written to ObjectOutput (DMI_NONSERIALIZABLE_OBJECT_WRITTEN)\n代码中让一个非序列化的对象出现在ObjectOutput.writeObject()方法中，这样会引起一个错误。\n16.DMI: Invocation of substring(0), which returns the original value (DMI_USELESS_SUBSTRING)\n此代码调用了subString(0)方法，它将返回原来的值。\n17.Eq: Class doesn't override equals in superclass (EQ_DOESNT_OVERRIDE_EQUALS)\n子类定义了一个新的equals方法但是却不是覆写了父类本省的equals()方法。\n18.FE: Test for floating point equality (FE_FLOATING_POINT_EQUALITY)\n此操作比较两个浮点值是否相等。由于浮点运算可能会涉及到舍入，计算float和double值可能不准确。如果要求值必须准确，如货币值，可以考虑使用固定精度类型，如BigDecimal类型的值来比较\n19.FS: Non-Boolean argument formatted using %b format specifier (VA_FORMAT_STRING_BAD_CONVERSION_TO_BOOLEAN)\n使用%b去格式化Boolean类型的值不正确的但是它不会抛出异常，任何非空的值都会输出true，任何为空的值都会输出false\n20.IC: Initialization circularity (IC_INIT_CIRCULARITY)\n在引用两个相互调用为环状static方法去初始化一个实例时是错误的。\n21.ICAST: integral division result cast to double or float (ICAST_IDIV_CAST_TO_DOUBLE)\n整形数除法强制转换为double或者float类型。\nint x = 2;\nint y = 5;\n// Wrong: yields result 0.0\ndouble value1 =  x / y;\n// Right: yields result 0.4\ndouble value2 =  x / (double) y;\n22.ICAST: Result of integer multiplication cast to long (ICAST_INTEGER_MULTIPLY_CAST_TO_LONG)\n整形数做乘法运算结果转换为long值时如果采用\nlong convertDaysToMilliseconds(int days) { return 1000*3600*24*days; } 结果会因为超出整形的范围而出错。\n如果使用：\nlong convertDaysToMilliseconds(int days) { return 1000L*3600*24*days; } \n或者：\nstatic final long MILLISECONDS_PER_DAY = 24L*3600*1000;\n        long convertDaysToMilliseconds(int days) { return days * MILLISECONDS_PER_DAY; } \n都可以避免此问题。\n23.IM: Computation of average could overflow (IM_AVERAGE_COMPUTATION_COULD_OVERFLOW)\n代码中使用x % 2 == 1的方法去验证运算是否存在余数的情况，但是如果出现负数的情况就不起作用了。使用x & 1 == 1, or x % 2 != 0来代替\n24.INT: Vacuous comparison of integer value (INT_VACUOUS_COMPARISON)\n整形数进行比较结果总是不变。例如：x <= Integer.MAX_VALUE\n25.MTIA: Class extends Servlet class and uses instance variables (MTIA_SUSPECT_SERVLET_INSTANCE_FIELD)\n这个类扩展从Servlet类，并使用实例的成员变量。由于只有一个Servlet类的实例，并在多线程方式使用，这种模式有可能存在问题。考虑只使用方法的局部变量。\n26.MTIA: Class extends Struts Action class and uses instance variables (MTIA_SUSPECT_STRUTS_INSTANCE_FIELD)\n类扩展自Struts的Action类并使用这个实例的成员变量，因为在Struts框架中只存在一个Action实例对象并且使用在多线程的情况下很可能会出现问题。\n27.NP: Dereference of the result of readLine() without nullcheck (NP_DEREFERENCE_OF_READLINE_VALUE)\n对readLine()的结果值没有进行判空操作就去重新赋值，这样的操作可以会抛出空指针异常。\n28.NP: Immediate dereference of the result of readLine() (NP_IMMEDIATE_DEREFERENCE_OF_READLINE)\n对readLine()的结果立即赋值，这样的操作可以会抛出空指针异常。\n29.NP: Possible null pointer dereference due to return value of called method (NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE)\n方法的返回值没有进行是否为空的检查就重新赋值，这样可能会出现空指针异常。\n30.NP: Parameter must be nonnull but is marked as nullable (NP_PARAMETER_MUST_BE_NONNULL_BUT_MARKED_AS_NULLABLE)\n参数值在任何情况下都不能为空，但是有明确的注释它可以为空。\n31.NS: Potentially dangerous use of non-short-circuit logic (NS_DANGEROUS_NON_SHORT_CIRCUIT)\n代码中使用（& or |）代替（&& or ||）操作，这会造成潜在的危险。\n32.NS: Questionable use of non-short-circuit logic (NS_NON_SHORT_CIRCUIT)\n代码中使用（& or |）代替（&& or ||）操作，会引起不安全的操作\n33.PZLA: Consider returning a zero length array rather than null (PZLA_PREFER_ZERO_LENGTH_ARRAYS)\n考虑返回一个零长度的数组，而不是null值\n34.QF: Complicated, subtle or wrong increment in for-loop (QF_QUESTIONABLE_FOR_LOOP)\n确定这个循环是正确的变量递增，看起来，另一个变量被初始化，检查的循环。这是由于for循环中太复杂的定义造成的。\n35.RCN: Redundant comparison of non-null value to null (RCN_REDUNDANT_COMPARISON_OF_NULL_AND_NONNULL_VALUE)\n方法中包含一个不能为空的赋值还包含一个可以为空的赋值。冗余比较非空值为空。\n36.RCN: Redundant comparison of two null values (RCN_REDUNDANT_COMPARISON_TWO_NULL_VALUES)\n方法中对两个null值进行比较\n37.RCN: Redundant nullcheck of value known to be non-null (RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE)\n方法中对不为空的值进行为空的判断。\n38.REC: Exception is caught when Exception is not thrown (REC_CATCH_EXCEPTION)\n在try/catch块中捕获异常，但是异常没有在try语句中抛出而RuntimeException又没有明确的被捕获\n39.RI: Class implements same interface as superclass (RI_REDUNDANT_INTERFACES)\n子类和父类都实现了同一个接口，这种定义是多余的。\n40.RV: Method discards result of readLine after checking if it is nonnull (RV_DONT_JUST_NULL_CHECK_READLINE)\nreadLine方法的结果不为空时被抛弃\n41.RV: Remainder of 32-bit signed random integer (RV_REM_OF_RANDOM_INT)\n此代码生成一个随机的符号整数，然后计算另一个值的。由于随机数可以是负数，所以其余操作的结果也可以是负面的。考虑使用Random.nextInt（int）方法代替。\n42.SA: Double assignment of local variable (SA_LOCAL_DOUBLE_ASSIGNMENT)\n为一个局部变量两次赋值，这样是没有意义的。例如：\npublic void foo() {\n    int x,y;\n    x = x = 17;\n  }\n43.SA: Self assignment of local variable (SA_LOCAL_SELF_ASSIGNMENT)\n局部变量使用自身给自己赋值\npublic void foo() {\n    int x = 3;\n    x = x;\n  }\n44.SF: Switch statement found where one case falls through to the next case (SF_SWITCH_FALLTHROUGH)\nSwitch语句中一个分支执行后又执行了下一个分支。通常case后面要跟break 或者return语句来跳出。\n45.SF: Switch statement found where default case is missing (SF_SWITCH_NO_DEFAULT)\nSwitch没有默认情况下执行的case语句。\n46.Se: private readResolve method not inherited by subclasses (SE_PRIVATE_READ_RESOLVE_NOT_INHERITED)\n声明为private的序列化方法被子类继承\n47.UCF: Useless control flow (UCF_USELESS_CONTROL_FLOW)\n没有任何作用的条件语句。\nif (argv.length == 0) {\n        // TODO: handle this case\n        }\n48.UCF: Useless control flow to next line (UCF_USELESS_CONTROL_FLOW_NEXT_LINE)\n无效的条件控制语句，注意if (argv.length == 1);以“;”结尾，下面的语句无论是否满足都会运行。\nif (argv.length == 1);\n        System.out.println(\"Hello, \" + argv[0]);\n49.UwF: Field not initialized in constructor (UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR)\n字段从来没有在任何构造函数初始化，对象被创建后值为空。如果该字段未被定义就重新赋值会产生一个空指针异常。\n50.XFB: Method directly allocates a specific implementation of xml interfaces (XFB_XML_FACTORY_BYPASS)\n方法自定义了一种XML接口的实现类。最好是使用官方提供的工厂类来创建这些对象，以便可以在运行期中改变。例如：\njavax.xml.parsers.DocumentBuilderFactory\njavax.xml.parsers.SAXParserFactory\njavax.xml.transform.TransformerFactory\norg.w3c.dom.Document.createXXXX\n\n\n\n\n\n","slug":"review/Findbug代码审查-缺陷和修改","published":1,"updated":"2018-05-30T09:32:36.444Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bqb00chs77rs9ux1h5n","content":"<h1 id=\"FindBugs使用实践-缺陷和修改\"><a href=\"#FindBugs使用实践-缺陷和修改\" class=\"headerlink\" title=\"FindBugs使用实践-缺陷和修改\"></a>FindBugs使用实践-缺陷和修改</h1><p>Confidence 是fingbug团队认为该代码导致bug的可能性。</p>\n<h2 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h2><p>1 Malicious code vulnerability 恶意代码<br>2 Performance 性能问题<br>3 Security 安全性问题<br>4 Dodgy code 小问题<br>5 Correctness 代码的正确性<br>6 Bad practice 不好的习惯<br>7 Internationalization 国际化问题<br>8 Experrimental 实验性问题<br>无     Multithreaded currectness 线程问题</p>\n<h2 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h2><h4 id=\"1-Bad-practice-坏的实践\"><a href=\"#1-Bad-practice-坏的实践\" class=\"headerlink\" title=\"1 Bad practice 坏的实践\"></a>1 Bad practice 坏的实践</h4><p>一些不好的实践，下面列举几个： HE：类定义了equals()，却没有hashCode()；或类定义了equals()，却使用Object.hashCode()；或类定义了hashCode()，却没有equals()；或类定义了hashCode()，却使用Object.equals()；类继承了equals()，却使用Object.hashCode()。<br>SQL：Statement 的execute方法调用了非常量的字符串；或Prepared Statement是由一个非常量的字符串产生。<br>DE：方法终止或不处理异常，一般情况下，异常应该被处理或报告，或被方法抛出。<br>Malicious code vulnerability 可能受到的恶意攻击<br>如果代码公开，可能受到恶意攻击的代码，下面列举几个： FI：一个类的finalize()应该是protected，而不是public的。MS：属性是可变的数组；属性是可变的Hashtable；属性应该是package protected的。</p>\n<h4 id=\"2-Correctness-一般的正确性问题\"><a href=\"#2-Correctness-一般的正确性问题\" class=\"headerlink\" title=\"2 Correctness 一般的正确性问题\"></a>2 Correctness 一般的正确性问题</h4><p>可能导致错误的代码，下面列举几个： NP：空指针被引用；在方法的异常路径里，空指针被引用；方法没有检查参数是否null；null值产生并被引用；null值产生并在方法的异常路径被引用；传给方法一个声明为@NonNull的null参数；方法的返回值声明为@NonNull实际是null。 Nm：类定义了hashcode()方法，但实际上并未覆盖父类Object的hashCode()；类定义了tostring()方法，但实际上并未覆盖父类Object的toString()；很明显的方法和构造器混淆；方法名容易混淆。 SQL：方法尝试访问一个Prepared Statement的0索引；方法尝试访问一个ResultSet的0索引。 UwF：所有的write都把属性置成null，这样所有的读取都是null，这样这个属性是否有必要存在；或属性从没有被write。</p>\n<h4 id=\"3-Dodgy-危险的\"><a href=\"#3-Dodgy-危险的\" class=\"headerlink\" title=\"3 Dodgy 危险的\"></a>3 Dodgy 危险的</h4><p>具有潜在危险的代码，可能运行期产生错误，下面列举几个： CI：类声明为final但声明了protected的属性。 DLS：对一个本地变量赋值，但却没有读取该本地变量；本地变量赋值成null，却没有读取该本地变量。 ICAST：整型数字相乘结果转化为长整型数字，应该将整型先转化为长整型数字再相乘。 INT：没必要的整型数字比较，如X &lt;= Integer.MAX_VALUE。 NP：对readline()的直接引用，而没有判断是否null；对方法调用的直接引用，而方法可能返回null。 REC：直接捕获Exception，而实际上可能是RuntimeException。 ST：从实例方法里直接修改类变量，即static属性。</p>\n<h4 id=\"4-Performance-性能问题\"><a href=\"#4-Performance-性能问题\" class=\"headerlink\" title=\"4 Performance 性能问题\"></a>4 Performance 性能问题</h4><p>可能导致性能不佳的代码，下面列举几个： DM：方法调用了低效的Boolean的构造器，而应该用Boolean.valueOf(…)；用类似Integer.toString(1) 代替new Integer(1).toString()；方法调用了低效的float的构造器，应该用静态的valueOf方法。 SIC：如果一个内部类想在更广泛的地方被引用，它应该声明为static。 SS：如果一个实例属性不被读取，考虑声明为static。 UrF：如果一个属性从没有被read，考虑从类中去掉。 UuF：如果一个属性从没有被使用，考虑从类中去掉。</p>\n<h4 id=\"5-Multithreaded-correctness-多线程的正确性多线程编程时，可能导致错误的代码，下面列举几个：\"><a href=\"#5-Multithreaded-correctness-多线程的正确性多线程编程时，可能导致错误的代码，下面列举几个：\" class=\"headerlink\" title=\"5 Multithreaded correctness 多线程的正确性多线程编程时，可能导致错误的代码，下面列举几个：\"></a>5 Multithreaded correctness 多线程的正确性多线程编程时，可能导致错误的代码，下面列举几个：</h4><p>ESync：空的同步块，很难被正确使用。 MWN：错误使用notify()，可能导致IllegalMonitorStateException异常；或错误的使用wait()。 No：使用notify()而不是notifyAll()，只是唤醒一个线程而不是所有等待的线程。 SC：构造器调用了Thread.start()，当该类被继承可能会导致错误。</p>\n<h4 id=\"6-Internationalization-国际化当对字符串使用upper或lowercase方法，如果是国际的字符串，可能会不恰当的转换。\"><a href=\"#6-Internationalization-国际化当对字符串使用upper或lowercase方法，如果是国际的字符串，可能会不恰当的转换。\" class=\"headerlink\" title=\"6 Internationalization 国际化当对字符串使用upper或lowercase方法，如果是国际的字符串，可能会不恰当的转换。\"></a>6 Internationalization 国际化当对字符串使用upper或lowercase方法，如果是国际的字符串，可能会不恰当的转换。</h4><p>API： <a href=\"http://findbugs.sourceforge.net/api/index.html\" target=\"_blank\" rel=\"noopener\">http://findbugs.sourceforge.net/api/index.html</a><br>技术手册： <a href=\"http://findbugs.sourceforge.net/manual/index.html\" target=\"_blank\" rel=\"noopener\">http://findbugs.sourceforge.net/manual/index.html</a><br>更多请参见官网： <a href=\"http://findbugs.sourceforge.net/bugDescriptions.html\" target=\"_blank\" rel=\"noopener\">http://findbugs.sourceforge.net/bugDescriptions.html</a></p>\n<h5 id=\"6-1、-ES-COMPARING-PARAMETER-STRING-WITH-EQ\"><a href=\"#6-1、-ES-COMPARING-PARAMETER-STRING-WITH-EQ\" class=\"headerlink\" title=\"6.1、       ES_COMPARING_PARAMETER_STRING_WITH_EQ\"></a>6.1、       ES_COMPARING_PARAMETER_STRING_WITH_EQ</h5><pre><code>ES: Comparison of String parameter using == or != (ES_COMPARING_PARAMETER_STRING_WITH_EQ)\n</code></pre><p>This code compares a java.lang.String parameter for reference equality using the == or != operators. Requiring callers to pass only String constants or interned strings to a method is unnecessarily fragile, and rarely leads to measurable performance gains. Consider using the equals(Object) method instead.<br>     使用 == 或者 != 来比较字符串或interned字符串，不会获得显著的性能提升，同时并不可靠，请考虑使用equals()方法。</p>\n<h5 id=\"6-2、-HE-EQUALS-NO-HASHCODE\"><a href=\"#6-2、-HE-EQUALS-NO-HASHCODE\" class=\"headerlink\" title=\"6.2、       HE_EQUALS_NO_HASHCODE\"></a>6.2、       HE_EQUALS_NO_HASHCODE</h5><pre><code>HE: Class defines equals() but not hashCode() (HE_EQUALS_NO_HASHCODE)\n</code></pre><p>This class overrides equals(Object), but does not override hashCode().  Therefore, the class may violate the invariant that equal objects must have equal hashcodes.<br>     类定义了equals()方法但没有重写hashCode()方法，这样违背了相同对象必须具有相同的hashcodes的原则</p>\n<h5 id=\"6-3、IT-NO-SUCH-ELEMENT\"><a href=\"#6-3、IT-NO-SUCH-ELEMENT\" class=\"headerlink\" title=\"6.3、IT_NO_SUCH_ELEMENT\"></a>6.3、IT_NO_SUCH_ELEMENT</h5><pre><code>It: Iterator next() method can&apos;t throw NoSuchElement exception (IT_NO_SUCH_ELEMENT)\n</code></pre><p>This class implements the java.util.Iterator interface.  However, its next() method is not capable of throwing java.util.NoSuchElementException.  The next() method should be changed so it throws NoSuchElementException if is called when there are no more elements to return.<br>     迭代器Iterator无法抛出NoSuchElement异常，类实现了java.util.Iterator接口，但是next()方法无法抛出java.util.NoSuchElementException异常，因此，next()方法应该做如此修改，当被调用时，如果没有element返回，则抛出NoSuchElementException异常</p>\n<h5 id=\"6-4、J2EE-STORE-OF-NON-SERIALIZABLE-OBJECT-INTO-SESSION\"><a href=\"#6-4、J2EE-STORE-OF-NON-SERIALIZABLE-OBJECT-INTO-SESSION\" class=\"headerlink\" title=\"6.4、J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION\"></a>6.4、J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION</h5><pre><code>J2EE: Store of non serializable object into HttpSession (J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION)\n</code></pre><p>This code seems to be storing a non-serializable object into an HttpSession. If this session is passivated or migrated, an error will result.<br>     将没有实现serializable的对象放到HttpSession中，当这个session被钝化和迁移时，将会产生错误，建议放到HttpSession中的对象都实现serializable接口。</p>\n<h5 id=\"6-5、ODR-OPEN-DATABASE-RESOURCE\"><a href=\"#6-5、ODR-OPEN-DATABASE-RESOURCE\" class=\"headerlink\" title=\"6.5、ODR_OPEN_DATABASE_RESOURCE\"></a>6.5、ODR_OPEN_DATABASE_RESOURCE</h5><pre><code>ODR: Method may fail to close database resource (ODR_OPEN_DATABASE_RESOURCE)\n</code></pre><p>The method creates a database resource (such as a database connection or row set), does not assign it to any fields, pass it to other methods, or return it, and does not appear to close the object on all paths out of the method.  Failure to close database resources on all paths out of a method may result in poor performance, and could cause the application to have problems communicating with the database.<br>     方法可能未关闭数据库资源，未关闭数据库资源将会导致性能变差，还可能引起应用与服务器间的通讯问题。</p>\n<h5 id=\"6-6、OS-OPEN-STREAM\"><a href=\"#6-6、OS-OPEN-STREAM\" class=\"headerlink\" title=\"6.6、OS_OPEN_STREAM\"></a>6.6、OS_OPEN_STREAM</h5><pre><code>OS: Method may fail to close stream (OS_OPEN_STREAM)\n</code></pre><p>The method creates an IO stream object, does not assign it to any fields, pass it to other methods that might close it, or return it, and does not appear to close the stream on all paths out of the method.  This may result in a file descriptor leak.  It is generally a good idea to use a finally block to ensure that streams are closed.<br>     方法可能未关闭stream，方法产生了一个IO流，却未关闭，将会导致文件描绘符的泄漏，建议使用finally block来确保io stream被关闭。</p>\n<h5 id=\"6-7、-DMI-CALLING-NEXT-FROM-HASNEXT\"><a href=\"#6-7、-DMI-CALLING-NEXT-FROM-HASNEXT\" class=\"headerlink\" title=\"6.7、       DMI_CALLING_NEXT_FROM_HASNEXT\"></a>6.7、       DMI_CALLING_NEXT_FROM_HASNEXT</h5><pre><code>DMI: hasNext method invokes next (DMI_CALLING_NEXT_FROM_HASNEXT)\n</code></pre><p>The hasNext() method invokes the next() method. This is almost certainly wrong, since the hasNext() method is not supposed to change the state of the iterator, and the next method is supposed to change the state of the iterator.</p>\n<h5 id=\"6-8、-IL-INFINITE-LOOP\"><a href=\"#6-8、-IL-INFINITE-LOOP\" class=\"headerlink\" title=\"6.8、       IL_INFINITE_LOOP\"></a>6.8、       IL_INFINITE_LOOP</h5><pre><code>IL: An apparent infinite loop (IL_INFINITE_LOOP)\n</code></pre><p>This loop doesn’t seem to have a way to terminate (other than by perhaps throwing an exception).<br>     明显的无限循环.</p>\n<h5 id=\"6-9、-IL-INFINITE-RECURSIVE-LOOP\"><a href=\"#6-9、-IL-INFINITE-RECURSIVE-LOOP\" class=\"headerlink\" title=\"6.9、       IL_INFINITE_RECURSIVE_LOOP\"></a>6.9、       IL_INFINITE_RECURSIVE_LOOP</h5><pre><code>IL: An apparent infinite recursive loop (IL_INFINITE_RECURSIVE_LOOP)\n</code></pre><p>This method unconditionally invokes itself. This would seem to indicate an infinite recursive loop that will result in a stack overflow.<br>     明显的无限迭代循环,将导致堆栈溢出.</p>\n<h5 id=\"6-10、-WMI-WRONG-MAP-ITERATOR\"><a href=\"#6-10、-WMI-WRONG-MAP-ITERATOR\" class=\"headerlink\" title=\"6.10、   WMI_WRONG_MAP_ITERATOR\"></a>6.10、   WMI_WRONG_MAP_ITERATOR</h5><pre><code>WMI: Inefficient use of keySet iterator instead of entrySet iterator (WMI_WRONG_MAP_ITERATOR)\n</code></pre><p>This method accesses the value of a Map entry, using a key that was retrieved from a keySet iterator. It is more efficient to use an iterator on the entrySet of the map, to avoid the Map.get(key) lookup.<br>     使用了keySet iterator和Map.get(key)来获取Map值,这种方式效率低,建议使用entrySet的iterator效率更高.</p>\n<h5 id=\"6-11、-IM-BAD-CHECK-FOR-ODD\"><a href=\"#6-11、-IM-BAD-CHECK-FOR-ODD\" class=\"headerlink\" title=\"6.11、   IM_BAD_CHECK_FOR_ODD\"></a>6.11、   IM_BAD_CHECK_FOR_ODD</h5><pre><code>IM: Check for oddness that won&apos;t work for negative numbers (IM_BAD_CHECK_FOR_ODD)\n</code></pre><p>The code uses x % 2 == 1 to check to see if a value is odd, but this won’t work for negative numbers (e.g., (-5) % 2 == -1). If this code is intending to check for oddness, consider using x &amp; 1 == 1, or x % 2 != 0.<br>     奇偶检测逻辑,未考虑负数情况.</p>\n<h4 id=\"7-实际项目中Bug类型统计\"><a href=\"#7-实际项目中Bug类型统计\" class=\"headerlink\" title=\"7.实际项目中Bug类型统计\"></a>7.实际项目中Bug类型统计</h4><h5 id=\"7-1、-Call-to-equals-comparing-different-types\"><a href=\"#7-1、-Call-to-equals-comparing-different-types\" class=\"headerlink\" title=\"7.1、       Call to equals() comparing different types\"></a>7.1、       Call to equals() comparing different types</h5><p>id : EC_UNRELATED_TYPES, type : EC, category : CORRECTNESS This method calls equals(Object) on two references of different class types with no common subclasses. Therefore, the objects being compared are unlikely to be members of the same class at runtime (unless some application classes were not analyzed, or dynamic class loading can occur at runtime). According to the contract of equals(), objects of different classes should always compare as unequal; therefore, according to the contract defined by java.lang.Object.equals(Object), the result of this comparison will always be false at runtime.<br>原因分析：<br>这缺陷的意思是，大部分都是类型永远不会有这种情况， 比如a为DOUBLE类型所以EQUALS只匹配字符串 if(a.equals())或if(a.quals())这类判断是根本不会有用的；<br>示例：if(“1”.equals(DAOValue.valueofSuccess()))</p>\n<h5 id=\"7-2、-Dead-store-to-local-variable\"><a href=\"#7-2、-Dead-store-to-local-variable\" class=\"headerlink\" title=\"7.2、       Dead store to local variable\"></a>7.2、       Dead store to local variable</h5><p>id: DLS_DEAD_LOCAL_STORE, type: DLS, category: STYLE<br>This instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used.<br>Note that Sun’s javac compiler often generates dead stores for final local variables. Because FindBugs is a bytecode-based tool, there is no easy way to eliminate these false positives.<br>原因分析：<br>DLS问题指的是给本地变量赋了一个值，但随后的代码并没有用到这个值。</p>\n<h5 id=\"7-3、-Method-call-passes-null-for-nonnull-parameter\"><a href=\"#7-3、-Method-call-passes-null-for-nonnull-parameter\" class=\"headerlink\" title=\"7.3、       Method call passes null for nonnull parameter\"></a>7.3、       Method call passes null for nonnull parameter</h5><p>id: NP_NULL_PARAM_DEREF, type: NP, category: CORRECTNESS<br>This method call passes a null value for a nonnull method parameter. Either the parameter is annotated as a parameter that should always be nonnull, or analysis has shown that it will always be dereferenced.<br>原因分析：对参数为null的情况未作处理。<br>例如：</p>\n<figure class=\"highlight plain\"><figcaption><span>void method1() &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    String ip = null;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        ip = InetAddress.getLocalHost().getHostAddress();</span><br><span class=\"line\">    &#125; catch (UnknownHostException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    long ipCount = countIpAddress(ip);//可能会传入空引用 </span><br><span class=\"line\">    //....</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">long countIpAddress(String ip) &#123;</span><br><span class=\"line\">    long ipNum = 0;</span><br><span class=\"line\">    String[] ipArray = ip.split(&quot;\\\\.&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><figcaption><span>void method1() &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    String ip = null;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        ip = InetAddress.getLocalHost().getHostAddress();</span><br><span class=\"line\">    &#125; catch (UnknownHostException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    long ipCount = countIpAddress(ip);//可能会传入空引用</span><br><span class=\"line\">    //....</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">long countIpAddress(String ip) &#123;</span><br><span class=\"line\">    long ipNum = 0;</span><br><span class=\"line\">    if(ip==null)&#123;</span><br><span class=\"line\">        return 0;//抛出异常</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    String[] ipArray = ip.split(&quot;\\\\.&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于接口需要对参数校验合法性</p>\n<h5 id=\"7-4、Method-with-Boolean-return-type-returns-explicit-null\"><a href=\"#7-4、Method-with-Boolean-return-type-returns-explicit-null\" class=\"headerlink\" title=\"7.4、Method with Boolean return type returns explicit null\"></a>7.4、Method with Boolean return type returns explicit null</h5><p>id: NP_BOOLEAN_RETURN_NULL, type: NP, category: BAD_PRACTICE<br>A method that returns either Boolean.TRUE, Boolean.FALSE or null is an accident waiting to happen. This method can be invoked as though it returned a value of type boolean, and the compiler will insert automatic unboxing of the Boolean value. If a null value is returned, this will result in a NullPointerException.<br>原因分析：<br>方法如果定义为返回类型Boolean，则可以返回Boolean.TRUE, Boolean.FALSE or null （如果 return 的是 true or  false， 则AutoBoxing 成 Boolean.TRUE, Boolean.FALSE）。因为JDK 支持 基本类型和装箱类型的自动转化， 所以下面的代码中：<br>boolean result = test_NP_BOOLEAN_RETURN_NULL();<br>因为此时test_NP_BOOLEAN_RETURN_NULL() 返回的是NULL， 所以 JDK 做 automatic unboxing 的操作时， 即调用了 object. booleanValue() 方法时，抛出了空指针。<br>改成：boolean result = test_NP_BOOLEAN_RETURN_NULL()==null?false:true;</p>\n<h5 id=\"7-5、-No-relationship-between-generic-parameter-and-method-argument\"><a href=\"#7-5、-No-relationship-between-generic-parameter-and-method-argument\" class=\"headerlink\" title=\"7.5、       No relationship between generic parameter and method argument\"></a>7.5、       No relationship between generic parameter and method argument</h5><p>id: GC_UNRELATED_TYPES, type: GC, category: CORRECTNESS<br>This call to a generic collection method contains an argument with an incompatible class from that of the collection’s parameter (i.e., the type of the argument is neither a supertype nor a subtype of the corresponding generic type argument). Therefore, it is unlikely that the collection contains any objects that are equal to the method argument used here. Most likely, the wrong value is being passed to the method.<br>In general, instances of two unrelated classes are not equal. For example, if the Foo and Bar classes are not related by subtyping, then an instance of Foo should not be equal to an instance of Bar. Among other issues, doing so will likely result in an equals method that is not symmetrical. For example, if you define the Foo class so that a Foo can be equal to a String, your equals method isn’t symmetrical since a String can only be equal to a String.<br>In rare cases, people do define nonsymmetrical equals methods and still manage to make their code work. Although none of the APIs document or guarantee it, it is typically the case that if you check if a Collection<string> contains a Foo, the equals method of argument (e.g., the equals method of the Foo class) used to perform the equality checks.<br>原因分析：调用Collection类中的contains方法比较时，所比较的两个参数类型不致；</string></p>\n<h5 id=\"7-6、-Null-pointer-dereference-in-method-on-exception-path\"><a href=\"#7-6、-Null-pointer-dereference-in-method-on-exception-path\" class=\"headerlink\" title=\"7.6、       Null pointer dereference in method on exception path\"></a>7.6、       Null pointer dereference in method on exception path</h5><p>id: NP_ALWAYS_NULL_EXCEPTION, type: NP, category: CORRECTNESS<br>A pointer which is null on an exception path is dereferenced here.  This will lead to a NullPointerException when the code is executed.  Note that because FindBugs currently does not prune infeasible exception paths, this may be a false warning.<br>Also note that FindBugs considers the default case of a switch statement to be an exception path, since the default case is often infeasible.<br>原因分析：在异常处理时，调用一个空对象的方法时可能引起空指针异常。</p>\n<h5 id=\"7-7、-Nullcheck-of-value-previously-dereferenced\"><a href=\"#7-7、-Nullcheck-of-value-previously-dereferenced\" class=\"headerlink\" title=\"7.7、       Nullcheck of value previously dereferenced\"></a>7.7、       Nullcheck of value previously dereferenced</h5><p>id: RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE, type:RCN, category: CORRECTNESS<br>A value is checked here to see whether it is null, but this value can’t be null because it was previously dereferenced and if it were null a null pointer exception would have occurred at the earlier dereference. Essentially, this code and the previous dereference disagree as to whether this value is allowed to be null. Either the check is redundant or the previous dereference is erroneous.<br>原因分析：前面获取的对象，现在引用的时候没有交验是否为null。</p>\n<h5 id=\"7-8、-Possible-null-pointer-dereference\"><a href=\"#7-8、-Possible-null-pointer-dereference\" class=\"headerlink\" title=\"7.8、       Possible null pointer dereference\"></a>7.8、       Possible null pointer dereference</h5><p>id: NP_NULL_ON_SOME_PATH, type: NP, category: CORRECTNESS<br>There is a branch of statement that, if executed, guarantees that a null value will be dereferenced, which would generate a NullPointerException when the code is executed. Of course, the problem might be that the branch or statement is infeasible and that the null pointer exception can’t ever be executed; deciding that is beyond the ability of FindBugs.<br>原因分析：可能存在空引用。</p>\n<h5 id=\"7-9、-Possible-null-pointer-dereference-in-method-on-exception-path\"><a href=\"#7-9、-Possible-null-pointer-dereference-in-method-on-exception-path\" class=\"headerlink\" title=\"7.9、       Possible null pointer dereference in method on exception path\"></a>7.9、       Possible null pointer dereference in method on exception path</h5><p>id: NP_NULL_ON_SOME_PATH_EXCEPTION, type: NP, category:CORRECTNESS<br>A reference value which is null on some exception control path is dereferenced here.  This may lead to a NullPointerException when the code is executed.  Note that because FindBugs currently does not prune infeasible exception paths, this may be a false warning.<br>Also note that FindBugs considers the default case of a switch statement to be an exception path, since the default case is often infeasible.<br>原因分析：<br>代码调用时， 遇到异常分支， 可能造成一个对象没有获得赋值依旧保持NULL空指针。 接下来如果对这个对象有引用， 可能造成NullPointerException 空指针异常。<br>例如：</p>\n<h5 id=\"7-10、-Test-for-floating-point-equality\"><a href=\"#7-10、-Test-for-floating-point-equality\" class=\"headerlink\" title=\"7.10、   Test for floating point equality\"></a>7.10、   Test for floating point equality</h5><p>id: FE_FLOATING_POINT_EQUALITY, type: FE, category: STYLE<br>This operation compares two floating point values for equality. Because floating point calculations may involve rounding, calculated float and double values may not be accurate. For values that must be precise, such as monetary values, consider using a fixed-precision type such as BigDecimal. For values that need not be precise, consider comparing for equality within some range, for example: if ( Math.abs(x - y) &lt; .0000001 ). See the java Language Specification, section 4.2.4.<br>原因分析：<br>Float类型的数据比较时，会存在的定的误差值，用!=来比较不是很准确，建议比较两个数的绝对值是否在一定的范围内来进行比较。如，if ( Math.abs(x - y) &lt; .0000001 )<br>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    return ResultVo.valueOfError(&quot;订单编号&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"7-11、-Useless-assignment-in-return-statement\"><a href=\"#7-11、-Useless-assignment-in-return-statement\" class=\"headerlink\" title=\"7.11、   Useless assignment in return statement\"></a>7.11、   Useless assignment in return statement</h5><p>id: DLS_DEAD_LOCAL_STORE_IN_RETURN, type: DLS, category: STYLE<br>This statement assigns to a local variable in a return statement. This assignment has effect. Please verify that this statement does the right thing.<br>原因分析：<br>在return的对象中，没有必要通过对象赋值再进行返回。<br>例如：</p>\n<figure class=\"highlight plain\"><figcaption><span>daoValue </span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(lxrCpdlVoList.size()==0)&#123;</span><br><span class=\"line\">    return daoValue = DAOValue.valueof(true,1,&quot;没有批量删除联系人业务大类信息失败&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"7-12、-Write-to-static-field-from-instance-method\"><a href=\"#7-12、-Write-to-static-field-from-instance-method\" class=\"headerlink\" title=\"7.12、   Write to static field from instance method\"></a>7.12、   Write to static field from instance method</h5><p>id: ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD, type: ST, category:STYLE<br>This instance method writes to a static field. This is tricky to get correct if multiple instances are being manipulated, and generally bad practice.<br>原因分析：向static字段中写入值。<br>例如：<br><figure class=\"highlight plain\"><figcaption><span>static DBRBO dbrBO; </span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> public final void refresh() &#123; </span><br><span class=\"line\">        danskeBankBO = null; </span><br><span class=\"line\">        dbrBO = null; </span><br><span class=\"line\">        fileAndPathBO = null; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">``` </span><br><span class=\"line\">建议改为：去掉static。</span><br><span class=\"line\">##### 7.13、   Incorrect lazy initialization and update of static field</span><br><span class=\"line\">id: LI_LAZY_INIT_UPDATE_STATIC, type: LI, category: MT_CORRECTNESS</span><br><span class=\"line\">This method contains an unsynchronized lazy initialization of a static field. After the field is set, the object stored into that location is further updated or accessed. The setting of the field is visible to other threads as soon as it is set. If the futher accesses in the method that set the field serve to initialize the object, then you have a very seriousmultithreading bug, unless something else prevents any other thread from accessing the stored object until it is fully initialized.</span><br><span class=\"line\">Even if you feel confident that the method is never called by multiple threads, it might be better to not set the static field until the value you are setting it to is fully populated/initialized.</span><br><span class=\"line\">原因分析：</span><br><span class=\"line\">该方法的初始化中包含了一个迟缓初始化的静态变量。你的方法引用了一个静态变量，估计是类静态变量，那么多线程调用这个方法时，你的变量就会面临线程安全的问题了，除非别的东西阻止任何其他线程访问存储对象从直到它完全被初始化。</span><br><span class=\"line\">##### 7.14、   Method ignores return value</span><br><span class=\"line\">id: RV_RETURN_VALUE_IGNORED, type: RV, category: CORRECTNESS</span><br><span class=\"line\">The return value of this method should be checked. One common cause of this warning is to invoke a method on an immutable object, thinking that it updates the object. For example, in the following code fragment,</span><br><span class=\"line\">String dateString = getHeaderField(name);</span><br><span class=\"line\">dateString.trim();</span><br><span class=\"line\">the programmer seems to be thinking that the trim() method will update the String referenced by dateString. But since Strings are immutable, the trim() function returns a new String value, which is being ignored here. The code should be corrected to:</span><br><span class=\"line\">String dateString = getHeaderField(name);</span><br><span class=\"line\">dateString = dateString.trim();</span><br><span class=\"line\">原因分析：方法忽略了设置返回值。</span><br><span class=\"line\">例如：</span><br><span class=\"line\"> </span><br><span class=\"line\">```String dateString = getHeaderField(name);</span><br><span class=\"line\">    dateString.trim();</span><br><span class=\"line\">    </span><br><span class=\"line\">    if(CustomActionEnum.Agee_SRT.equals(operationType)||CustomActionEnum.DISSAgee_SRT.equals(operationType)&#123;</span><br><span class=\"line\">        //....</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"7-15、-Method-might-ignore-exception\"><a href=\"#7-15、-Method-might-ignore-exception\" class=\"headerlink\" title=\"7.15、   Method might ignore exception\"></a>7.15、   Method might ignore exception</h5><p>id: DE_MIGHT_IGNORE, type: DE, category: BAD_PRACTICE<br>This method might ignore an exception.Â  In general, exceptions should be handled or reported in some way, or they should be thrown out of the method.<br>原因分析：应该将异常 处理、打印或者抛出<br>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    //....</span><br><span class=\"line\">&#125;catch(Exception e)&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"7-16、-Unwritten-field\"><a href=\"#7-16、-Unwritten-field\" class=\"headerlink\" title=\"7.16、   Unwritten field\"></a>7.16、   Unwritten field</h5><p>id: UWF_UNWRITTEN_FIELD, type: UwF, category: CORRECTNESS<br>This field is never written.Â  All reads of it will return the default value. Check for errors (should it have been initialized?), or remove it if it is useless.<br>原因分析：从未被初始化的变量，调用它时，将返回默认值，要么初始化，要么删掉它。<br>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    //....</span><br><span class=\"line\">&#125;catch(Exception e)&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"7-17、-Value-is-null-and-guaranteed-to-be-dereferenced-on-exception-path\"><a href=\"#7-17、-Value-is-null-and-guaranteed-to-be-dereferenced-on-exception-path\" class=\"headerlink\" title=\"7.17、   Value is null and guaranteed to be dereferenced on exception path\"></a>7.17、   Value is null and guaranteed to be dereferenced on exception path</h5><p>id: NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH, type: NP, category:CORRECTNESS<br>There is a statement or branch on an exception path that if executed guarantees that a value is null at this point, and that value that is guaranteed to be dereferenced (except on forward paths involving runtime exceptions).<br>原因分析：exception分支上，存在引用一个null对象的方法，引发空指针异常。<br>例如：<br><figure class=\"highlight plain\"><figcaption><span>out </span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try&#123;</span><br><span class=\"line\">    response.setContentType(&quot;text/html;charset=GBK&quot;);</span><br><span class=\"line\">    response.setHeader(&quot;Cache-Control;no-cache&quot;);</span><br><span class=\"line\">    out = response.getWriter();</span><br><span class=\"line\">    out.flush();</span><br><span class=\"line\">&#125;catch(Exception ex)&#123;</span><br><span class=\"line\">    logger.debug(&quot;获取树的XML代码出错。&quot;+ex.getMessage());</span><br><span class=\"line\">&#125;finally&#123;</span><br><span class=\"line\">    out.close();//out可能为空</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"7-18、-Very-confusing-method-names\"><a href=\"#7-18、-Very-confusing-method-names\" class=\"headerlink\" title=\"7.18、   Very confusing method names\"></a>7.18、   Very confusing method names</h5><p>id: NM_VERY_CONFUSING, type: Nm, category: CORRECTNESS<br>The referenced methods have names that differ only by capitalization. This is very confusing because if the capitalization were identical then one of the methods would override the other.<br>原因分析：被引用的方法中存在容易混淆的变量。<br>例如：fzgsdm改成 fzgsDm 即可。</p>\n<figure class=\"highlight plain\"><figcaption><span>String getFzgsdm() &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    return getFzgsdm;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"7-19、-Method-invokes-inefficient-new-String-constructor\"><a href=\"#7-19、-Method-invokes-inefficient-new-String-constructor\" class=\"headerlink\" title=\"7.19、   Method invokes inefficient new String() constructor\"></a>7.19、   Method invokes inefficient new String() constructor</h5><p>id: DM_STRING_VOID_CTOR, type: Dm, category: Performance Creating a new java.lang.String object using the no-argument constructor wastes memory because the object so created will be functionally indistinguishable from the empty string constant “”.  Java guarantees that identical string constants will be represented by the same String object.  Therefore, you should just use the empty string constant directly.<br>原因分析：不使用new String()定义空的字符串<br>例如：</p>\n<figure class=\"highlight plain\"><figcaption><span>alarmCodeCond </span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">应当</span><br><span class=\"line\">String alarmCodeCond = &quot;&quot;;</span><br><span class=\"line\">```      </span><br><span class=\"line\"></span><br><span class=\"line\">##### 7.20、   Load of known null value</span><br><span class=\"line\">id: NP_LOAD_OF_KNOWN_NULL_VALUE, type: Np, category: Dodgy</span><br><span class=\"line\">The variable referenced at this point is known to be null due to an earlier check against null. Although this is valid, it might be a mistake (perhaps you intended to refer to a different variable, or perhaps the earlier check to see if the variable is null should have been a check to see if it was nonnull).</span><br><span class=\"line\">原因分析：null值的不当使用。</span><br><span class=\"line\">例如：</span><br><span class=\"line\"></span><br><span class=\"line\">``` </span><br><span class=\"line\">if(devIds ==null &amp;&amp; devIds.size()==0)&#123; //.....&#125; </span><br><span class=\"line\"></span><br><span class=\"line\">if(null ==tempList||tempList.size()!=0)&#123; //.....&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">if(batchNo ==null)&#123;</span><br><span class=\"line\">   throw new Exception(&quot;the No. &quot;+batchNo + &quot;is not exists1&quot;）)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"7-21、-Method-concatenates-strings-using-in-a-loop\"><a href=\"#7-21、-Method-concatenates-strings-using-in-a-loop\" class=\"headerlink\" title=\"7.21、   Method concatenates strings using + in a loop\"></a>7.21、   Method concatenates strings using + in a loop</h5><p>id: SBSC_USE_STRINGBUFFER_CONCATENATION, type: SBSC, category: Performance<br>The method seems to be building a String using concatenation in a loop. In each iteration, the String is converted to a StringBuffer/StringBuilder, appended to, and converted back to a String. This can lead to a cost quadratic in the number of iterations, as the growing string is recopied in each iteration. Better performance can be obtained by using a StringBuffer (or StringBuilder in Java 1.5) explicitly.<br>For example:<br>  // This is bad<br>  String s = “”;<br>  for (int i = 0; i &lt; field.length; ++i) {<br>    s = s + field[i];<br>  }<br>  // This is better<br>  StringBuffer buf = new StringBuffer();<br>  for (int i = 0; i &lt; field.length; ++i) {<br>    buf.append(field[i]);<br>  }<br>  String s = buf.toString();<br>原因分析：在循环里使用字符串连接，效率低，应该使用StringBuilder/StringBuffer</p>\n<h3 id=\"Bug列表\"><a href=\"#Bug列表\" class=\"headerlink\" title=\"Bug列表\"></a>Bug列表</h3><h4 id=\"BUG-0001\"><a href=\"#BUG-0001\" class=\"headerlink\" title=\"BUG-0001\"></a>BUG-0001</h4><p>Bug: Field only ever set to null: com.bettersoft.admin.BtCorpManager.ps<br>All writes to this field are of the constant value null, and thus all reads of the field will return null. Check for errors, or remove it if it is useless.<br>Confidence: Normal, Rank: Troubling (12)<br>Pattern: UWF_NULL_FIELD<br>Type: UwF, Category: CORRECTNESS (Correctness)<br>代码片段：、<br><figure class=\"highlight plain\"><figcaption><span>class BtCorpManager &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private BtCorp btcorp=null;</span><br><span class=\"line\">private Connection con = null;</span><br><span class=\"line\">private Statement st = null;</span><br><span class=\"line\">private PreparedStatement ps = null;</span><br><span class=\"line\">private ResultSet rs = null;</span><br><span class=\"line\">private void setConnection(String centerno) throws Exception&#123;</span><br><span class=\"line\">    //con = DBManager.getConnection(centerno);</span><br><span class=\"line\">    con = DBManager.getConnection();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>解释说明：在BtCorpManager类里面定了一个私有的成员变量PreparedStatement ps,但是这个成员变量ps在实例范围内没有得到任何的初始化(采用默认的构造方法)，始终为null,所以在实例范围内使用该成员变量时，如果不先对其进行初始化操作或者无意识的行为忘了初始化操作，那肯定是要报空指针异常，所以这无疑是一个bug<br>推荐修改： 自己看着办</p>\n<h4 id=\"BUG-0002\"><a href=\"#BUG-0002\" class=\"headerlink\" title=\"BUG-0002\"></a>BUG-0002</h4><p>Bug: Nullcheck of form at line 36 of value previously dereferenced in com.bettersoft.admin.CorpEditAction.execute(ActionMapping, ActionForm, HttpServletRequest, HttpServletResponse)<br>A value is checked here to see whether it is null, but this value can’t be null because it was previously dereferenced and if it were null a null pointer exception would have occurred at the earlier dereference. Essentially, this code and the previous dereference disagree as to whether this value is allowed to be null. Either the check is redundant or the previous dereference is erroneous.<br>Confidence: High, Rank: Scary (9)<br>Pattern: RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE<br>Type: RCN, Category: CORRECTNESS (Correctness)<br>代码片段：</p>\n<figure class=\"highlight plain\"><figcaption><span>ActionForward execute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//throw new UnsupportedOperationException(&quot;Method is not implemented&quot;);</span><br><span class=\"line\">ActionErrors errors = new ActionErrors();</span><br><span class=\"line\">CreateCorpActionForm createCorp = new CreateCorpActionForm();</span><br><span class=\"line\">createCorp = (CreateCorpActionForm)form;</span><br><span class=\"line\">CreateCorpActionForm webcorp=new CreateCorpActionForm();</span><br><span class=\"line\">BudgetWebcorpManager budgetWebcorpManager=new BudgetWebcorpManager();</span><br><span class=\"line\">webcorp=budgetWebcorpManager.getCWebcorp(createCorp.getId());</span><br><span class=\"line\">createCorp.setFbsaddapproveid(webcorp.getFbsaddapproveid());</span><br><span class=\"line\">createCorp.setFbsinputapproveid(webcorp.getFbsinputapproveid());</span><br><span class=\"line\">createCorp.setFbsprocessapproveid(webcorp.getFbsprocessapproveid());</span><br><span class=\"line\"> </span><br><span class=\"line\">boolean b=false;</span><br><span class=\"line\">if(createCorp!=null)&#123;</span><br></pre></td></tr></table></figure>\n<p>解释说明：注意到有个局部变量 CreateCorpActionForm createCorp;再看下它的初始化过程，先是通过new给它分配了内存空间，紧接着有让它引用了了另一个未知的变量，这里说未知是指这个新的引用可能为空，显然 createCorp有可能指向一个空的地址，所以在接下来的引用中极可能报空指针异常（在引用之前不进行判空操作的话）！ 在接下来的代码，如下<br><code>if(createCorp!=null){</code><br>其实也就没有存在的必要，因为如果为空的话，上面这行代码根本不可能执行到，所以findbug说这是冗余的空指针检查。当然考虑到特殊情况，这里显然是struts1的action,所以只要web应用正常启动，通常以下代码</p>\n<p><code>createCorp = (CreateCorpActionForm)form;</code></p>\n<p>是不会导致createCorp指向空的，唯一的缺陷就是之前的new操作是多余的。<br>推荐修改：自己看着办</p>\n<h4 id=\"BUG-0003\"><a href=\"#BUG-0003\" class=\"headerlink\" title=\"BUG-0003\"></a>BUG-0003</h4><p>Bug: con is null guaranteed to be dereferenced in com.bettersoft.admin.leftAction.getLeft(int, String, String) on exception path<br>There is a statement or branch on an exception path that if executed guarantees that a value is null at this point, and that value that is guaranteed to be dereferenced (except on forward paths involving runtime exceptions).<br>Confidence: Normal, Rank: (Troubling 11)<br>Pattern: NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH<br>Type: NP, Category: CORRECTNESS (Correctness)<br>代码片段：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    try</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if(rs != null)</span><br><span class=\"line\">            rs.close();</span><br><span class=\"line\">        if(ps!=null)</span><br><span class=\"line\">            ps.close();</span><br><span class=\"line\">        con.close();</span><br><span class=\"line\">    &#125;catch(Exception ee)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ee.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>解释说明：这应该是大家很熟悉的代码片段了，可以想象Connection con是在catch代码块中进行的初始化操作，findbug对该bug说的很明白，说如果出现异常，Connection con将保证为空，因为很显然如果出现异常，con将得不到正确的初始化，即便初始化了，因为异常的出现，引用也会被解除，回到一开始定义处的null状态，那么在这里的finally代码块中调用Connection con的close()方法，将报空指针异常<br>推荐修改：自己看着办 </p>\n<h4 id=\"BUG-0004\"><a href=\"#BUG-0004\" class=\"headerlink\" title=\"BUG-0004\"></a>BUG-0004</h4><p>Bug: Possible null pointer dereference of dbVersion in com.bettersoft.admin.LoginAction.loadVersion(HttpServletRequest, ActionErrors) on exception path<br>A reference value which is null on some exception control path is dereferenced here. This may lead to aNullPointerExceptionwhen the code is executed. Note that because FindBugs currently does not prune infeasible exception paths, this may be a false warning.<br>Also note that FindBugs considers the default case of a switch statement to be an exception path, since the default case is often infeasible.<br>Confidence: Normal, Rank: Troubling (11)<br>Pattern: NP_NULL_ON_SOME_PATH_EXCEPTION<br>Type: NP, Category: CORRECTNESS (Correctness)<br>代码片段：</p>\n<figure class=\"highlight plain\"><figcaption><span>dbVersion </span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    try &#123;</span><br><span class=\"line\">        con = DBManager.getConnection();</span><br><span class=\"line\">        dbVersion = vm.getVersionInfo(con);</span><br><span class=\"line\">    &#125; catch (Exception e) &#123;</span><br><span class=\"line\">        // TODO Auto-generated catch block</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            con.close();</span><br><span class=\"line\">        &#125; catch (SQLException e) &#123;</span><br><span class=\"line\">            // TODO Auto-generated catch block</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">if (dbVersion.equals(programVersion)) &#123;</span><br><span class=\"line\">    programVersion.setCorrent(true);</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">    programVersion.setCorrent(false);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>解释说明：如果try catch 中捕获异常，那么dbVersion将为空， </p>\n<p><code>dbVersion.equals(programVersion)</code></p>\n<p>上面这行代码，将报空指针异常 </p>\n<h4 id=\"BUG-0005\"><a href=\"#BUG-0005\" class=\"headerlink\" title=\"BUG-0005\"></a>BUG-0005</h4><p>Bug: Dead store to am in com.bettersoft.approve.action.CheckAction.execute(ActionMapping, ActionForm, HttpServletRequest, HttpServletResponse)<br>This instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used.<br>Note that Sun’s javac compiler often generates dead stores for final local variables. Because FindBugs is a bytecode-based tool, there is no easy way to eliminate these false positives.<br>Confidence: High, Rank: Of Concern (15)<br>Pattern: DLS_DEAD_LOCAL_STORE<br>Type: DLS, Category: STYLE (Dodgy code)<br>代码片段：</p>\n<p><code>ApproveManager am = new ApproveManager();</code></p>\n<p>解释说明：am这个局部变量创建出来后，没有在任何地方被引用。这里确实没有被引用，所以是个bug,但是findbug又说明了，这有可能是误报，因为javac编译器在编译局部常量时，也会产生dead stroes。所以这个要视情况而定，不能过于纠结 </p>\n<h4 id=\"BUG-0006\"><a href=\"#BUG-0006\" class=\"headerlink\" title=\"BUG-0006\"></a>BUG-0006</h4><p>Bug: The class name com.bettersoft.approve.form.BtWebCorp shadows the simple name of the superclass com.bettersoft.admin.BtWebCorp<br>This class has a simple name that is identical to that of its superclass, except that its superclass is in a different package (e.g.,alpha.Fooextendsbeta.Foo). This can be exceptionally confusing, create lots of situations in which you have to look at import statements to resolve references and creates many opportunities to accidently define methods that do not override methods in their superclasses.<br>Confidence: High, Rank: Troubling (14)<br>Pattern: NM_SAME_SIMPLE_NAME_AS_SUPERCLASS<br>Type: Nm, Category: BAD_PRACTICE (Bad practice)<br>代码片段： </p>\n<figure class=\"highlight plain\"><figcaption><span>class BtWebCorp extends com.bettersoft.admin.BtWebCorp&#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>解释说明：这里子类和父类名称一样，findbug认为这回导致很多混淆。显然一旦出问题，将很难发现，运行结果将出乎意料 </p>\n<h4 id=\"BUG-0007\"><a href=\"#BUG-0007\" class=\"headerlink\" title=\"BUG-0007\"></a>BUG-0007</h4><p>Bug: Comparison of String objects using == or != in com.byttersoft.admin.persistence.dao.MessageOpenDao.addOpenSave(MessageOpenForm)<br>This code comparesjava.lang.Stringobjects for reference equality using the == or != operators. Unless both strings are either constants in a source file, or have been interned using theString.intern()method, the same string value may be represented by two different String objects. Consider using theequals(Object)method instead.<br>Confidence: Normal, Rank: Troubling (11)<br>Pattern: ES_COMPARING_STRINGS_WITH_EQ<br>Type: ES, Category: BAD_PRACTICE (Bad practice)<br>代码片段：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">        sql = &quot;insert into xx values (1,?,?,?)&quot;;</span><br><span class=\"line\">&#125;else&#123;</span><br><span class=\"line\">        sql = &quot;insert into xx values ((select max(id) + 1 from xx),?,?,?)&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>解释说明： 直接使用==进行对象实例比较，而没有使用equals,本来没觉得这个bug咋样，但是发现项目里居然最多的bug就是这个，不管是很多年前的代码还是最近的代码，都存在这大量这样的问题。看来这是一个通病，所以大家注意一下，不光是我们公司的项目有这样的问题，这应该是一个普遍的问题，尤其实在比较String类型的时候，注意只要不是java基本类型都需要使用equals进行比较，哪怕是自动解封的Integer，Double等</p>\n<h4 id=\"BUG-0008\"><a href=\"#BUG-0008\" class=\"headerlink\" title=\"BUG-0008\"></a>BUG-0008</h4><p>Bug: Call to String.equals(Double) in com.byttersoft.amm.util.BalanceInterzoneRateUtil.formatRate(Double)<br>This method calls equals(Object) on two references of different class types with no common subclasses. Therefore, the objects being compared are unlikely to be members of the same class at runtime (unless some application classes were not analyzed, or dynamic class loading can occur at runtime). According to the contract of equals(), objects of different classes should always compare as unequal; therefore, according to the contract defined by Java.lang.Object.equals(Object), the result of this comparison will always be false at runtime.<br>Confidence: High, Rank: Scariest (1)<br>Pattern: EC_UNRELATED_TYPES<br>Type: EC, Category: CORRECTNESS (Correctness)<br>代码片段：<br><figure class=\"highlight plain\"><figcaption><span>static String  formatRate(Double r)&#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> </span><br><span class=\"line\">if(r==null ||  (&quot;undefined&quot;).equals(r))&#123;</span><br><span class=\"line\">    return null;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>解释说明：使用equals比较不同类型的数据，”undefined”是String类型，r是Double类型，这两个比较肯定返回false</p>\n<p><code>(&quot;undefined&quot;).equals(r)</code></p>\n<p>上面这行代码完全没有必要 ，不可能存在这种情况</p>\n<h4 id=\"BUG-0009\"><a href=\"#BUG-0009\" class=\"headerlink\" title=\"BUG-0009\"></a>BUG-0009</h4><p>Bug: Class com.byttersoft.util.CertInfo defines non-transient non-serializable instance field subjectDnAttr<br>This Serializable class defines a non-primitive instance field which is neither transient, Serializable, orjava.lang.Object, and does not appear to implement theExternalizableinterface or thereadObject()andwriteObject()methods. Objects of this class will not be deserialized correctly if a non-Serializable object is stored in this field.<br>Confidence: High, Rank: Troubling (14)<br>Pattern: SE_BAD_FIELD<br>Type: Se, Category: BAD_PRACTICE (Bad practice)<br>代码片段： </p>\n<figure class=\"highlight plain\"><figcaption><span>class CertInfo implements java.io.Serializable</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    private String subjectDN=&quot;&quot;;</span><br><span class=\"line\">    private String issuerDN=&quot;&quot;;</span><br><span class=\"line\">    private String notAfterDate=&quot;&quot;;</span><br><span class=\"line\">    private String notBeforeDate=&quot;&quot;;</span><br><span class=\"line\">    private String serialNumber=&quot;&quot;;</span><br><span class=\"line\">    private String sigAlgName=&quot;&quot;;</span><br><span class=\"line\">    private String sigAlgOID=&quot;&quot;;</span><br><span class=\"line\">    private String version=&quot;&quot;;</span><br><span class=\"line\">    private String publicKeyFormat=&quot;&quot;;</span><br><span class=\"line\">    private String publicKeyAlgorithm=&quot;&quot;;</span><br><span class=\"line\">    private Names subjectDnAttr=null;</span><br><span class=\"line\">｝</span><br><span class=\"line\">public class Names</span><br><span class=\"line\">&#123;&#125;&lt;span&gt;&lt;/span&gt;</span><br></pre></td></tr></table></figure>\n<p>解释说明： CertInfo实现的序列话，但是他的成员变量Names subjectDnAttr没有实现序列化，这将会导致序列化失败，String已经默认实现了序列化。注意，序列化时所有的成员变量都必须递归的实现序列化，否则将导致序列化失败。如果某个成员变量不想被序列化要么标注为瞬态要么重写readObj方法</p>\n<h4 id=\"BUG-0010\"><a href=\"#BUG-0010\" class=\"headerlink\" title=\"BUG-0010\"></a>BUG-0010</h4><p>Bug: Dead store to corpGourps rather than field with same name in com.byttersoft.admin.form.CorpGroupsForm.setCorpGourps(CorpGourps)<br>This instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used. There is a field with the same name as the local variable. Did you mean to assign to that variable instead?<br>Confidence: High, Rank: Scary (9)<br>Pattern: DLS_DEAD_LOCAL_STORE_SHADOWS_FIELD<br>Type: DLS, Category: STYLE (Dodgy code)<br>代码片段： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void setCorpGourps(CorpGourps corpGourps) &#123;</span><br><span class=\"line\">        corpGourps = corpGourps;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>解释说明：成员变量和局部变量重名</p>\n<h4 id=\"BUG-0011\"><a href=\"#BUG-0011\" class=\"headerlink\" title=\"BUG-0011\"></a>BUG-0011</h4><p>Bug: Invocation of toString on labelValue in com.byttersoft.approve.persistence.dao.MesAppDao.getMapByPara(String)<br>The code invokes toString on an array, which will generate a fairly useless result such as [C@16f0472. Consider using Arrays.toString to convert the array into a readable String that gives the contents of the array. See Programming Puzzlers, chapter 3, puzzle 12.<br>Confidence: Normal, Rank: Troubling (10)<br>Pattern: DMI_INVOKING_TOSTRING_ON_ARRAY<br>Type: USELESS_STRING, Category: CORRECTNESS (Correctness)<br>代码片段：</p>\n<figure class=\"highlight plain\"><figcaption><span>(String parameter : parameters) &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    String[] labelValue = parameter.split(&quot;=&quot;);</span><br><span class=\"line\">    if (labelValue.length == 2) &#123;</span><br><span class=\"line\">        String key = labelValue[0];</span><br><span class=\"line\">        String value = labelValue[1];</span><br><span class=\"line\">        hashMap.put(key, value);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        logger.debug(&quot;参数 &quot; + labelValue + &quot; 配置错误。&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>解释说明：在进行日志输出时，直接输出对象，将默认调用对象的toString方法，而默认是输出对象的内存地址，所以这里显然有问题，本意应该是输出数组中的字符串 </p>\n<h4 id=\"BUG-0012\"><a href=\"#BUG-0012\" class=\"headerlink\" title=\"BUG-0012\"></a>BUG-0012</h4><p>Bug: Write to static field com.byttersoft.admin.service.BtSysResService.map from instance method com.byttersoft.admin.service.BtSysResService.hashCatchOfSysRes(boolean)<br>This instance method writes to a static field. This is tricky to get correct if multiple instances are being manipulated, and generally bad practice.<br>Confidence: High, Rank: Of Concern (15)<br>Pattern: ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD<br>Type: ST, Category: STYLE (Dodgy code)<br>代码片段： </p>\n<figure class=\"highlight plain\"><figcaption><span>Map<string, btsysres=\"\"> map </string,></span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public Map&lt;String, BtSysRes&gt; hashCatchOfSysRes(boolean isRefresh) &#123;</span><br><span class=\"line\">        if(isRefresh == true)&#123;</span><br><span class=\"line\">            map = hashCatchOfSysRes();</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            if(map == null || map.isEmpty())&#123;</span><br><span class=\"line\">                map = hashCatchOfSysRes();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return map;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>解释说明：在实例方法中修改类变量的引用，这会导致共享问题，因为其他实例也会访问该静态变量，但是却不知道某个实例已经修改了该静态变量的引用，导致不可预知的问题<br>推荐修改：将该方法改为类方法</p>\n<h4 id=\"BUG-0013\"><a href=\"#BUG-0013\" class=\"headerlink\" title=\"BUG-0013\"></a>BUG-0013</h4><p>Bug: Unwritten field: com.byttersoft.admin.service.importservice.ImportServices.bank<br>This field is never written. All reads of it will return the default value. Check for errors (should it have been initialized?), or remove it if it is useless.<br>Confidence: Normal, Rank: Troubling (12)<br>Pattern: UWF_UNWRITTEN_FIELD<br>Type: UwF, Category: CORRECTNESS (Correctness)<br>代码片段：</p>\n<figure class=\"highlight plain\"><figcaption><span>class ImportServices &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private IBankAccServices bank;</span><br><span class=\"line\">public IBankAccServices getBank() &#123;</span><br><span class=\"line\">        return bank;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">｝</span><br></pre></td></tr></table></figure>\n<p>解释说明： bank对象为空，getBank方法返回了一个肯定为空的对象实例</p>\n<h4 id=\"BUG-0014\"><a href=\"#BUG-0014\" class=\"headerlink\" title=\"BUG-0014\"></a>BUG-0014</h4><p>Bug: There is an apparent infinite recursive loop in com.byttersoft.amm.dao.impl.CheckLoanOrProvideInfoDaoImpl.addBatch(List)<br>This method unconditionally invokes itself. This would seem to indicate an infinite recursive loop that will result in a stack overflow.<br>Confidence: High, Rank: Scary (9)<br>Pattern: IL_INFINITE_RECURSIVE_LOOP<br>Type: IL, Category: CORRECTNESS (Correctness)<br>代码片段：<br><figure class=\"highlight plain\"><figcaption><span>void addBatch(List<cmsploantobean> cmsPLoanBeans) &#123;</cmsploantobean></span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    this.addBatch(cmsPLoanBeans);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>解释说明：出现了递归调用addBatch,将出现死循环</p>\n<h3 id=\"High\"><a href=\"#High\" class=\"headerlink\" title=\"High\"></a>High</h3><h4 id=\"1-DM-DEFAULT-ENCODING\"><a href=\"#1-DM-DEFAULT-ENCODING\" class=\"headerlink\" title=\"1.DM_DEFAULT_ENCODING\"></a>1.DM_DEFAULT_ENCODING</h4><h5 id=\"1-1-Found-reliance-on-default-encoding-in-com-cmcc-aoi-httprequest-service-HttpRequest-sendGet-String-String-new-java-io-InputStreamReader-InputStream\"><a href=\"#1-1-Found-reliance-on-default-encoding-in-com-cmcc-aoi-httprequest-service-HttpRequest-sendGet-String-String-new-java-io-InputStreamReader-InputStream\" class=\"headerlink\" title=\"1.1 Found reliance on default encoding in com.cmcc.aoi.httprequest.service.HttpRequest.sendGet(String, String): new java.io.InputStreamReader(InputStream)\"></a>1.1 Found reliance on default encoding in com.cmcc.aoi.httprequest.service.HttpRequest.sendGet(String, String): new java.io.InputStreamReader(InputStream)</h5><p>Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.</p>\n<p>new BufferedReader(new InputStreamReader(connection.getInputStream()));</p>\n<p>修改为： InputStreamReader fileData = new InputStreamReader(file ,”utf-8”);</p>\n<h5 id=\"1-2-Found-reliance-on-default-encoding-in-com-cmcc-aoi-httprequest-service-HttpRequest-sendPost-String-JSONObject-new-java-io-PrintWriter-OutputStream\"><a href=\"#1-2-Found-reliance-on-default-encoding-in-com-cmcc-aoi-httprequest-service-HttpRequest-sendPost-String-JSONObject-new-java-io-PrintWriter-OutputStream\" class=\"headerlink\" title=\"1.2 Found reliance on default encoding in com.cmcc.aoi.httprequest.service.HttpRequest.sendPost(String, JSONObject): new java.io.PrintWriter(OutputStream)\"></a>1.2 Found reliance on default encoding in com.cmcc.aoi.httprequest.service.HttpRequest.sendPost(String, JSONObject): new java.io.PrintWriter(OutputStream)</h5><p>Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.<br>out = new PrintWriter(conn.getOutputStream());</p>\n<p>修改为： out = new PrintWriter(new OutputStreamWriter(conn.getOutputStream(), “utf-8”));</p>\n<h5 id=\"1-3-Found-reliance-on-default-encoding-in-com-cmcc-aoi-selfhelp-action-DeliverWebRequestAction-calculateUserCount-HttpServletRequest-String-getBytes\"><a href=\"#1-3-Found-reliance-on-default-encoding-in-com-cmcc-aoi-selfhelp-action-DeliverWebRequestAction-calculateUserCount-HttpServletRequest-String-getBytes\" class=\"headerlink\" title=\"1.3 Found reliance on default encoding in com.cmcc.aoi.selfhelp.action.DeliverWebRequestAction.calculateUserCount(HttpServletRequest): String.getBytes()\"></a>1.3 Found reliance on default encoding in com.cmcc.aoi.selfhelp.action.DeliverWebRequestAction.calculateUserCount(HttpServletRequest): String.getBytes()</h5><p>Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.<br>fileName = new String(req.getParameter(“fileName”).getBytes(), “UTF-8”);<br>修改为<br>fileName = new String(req.getParameter(“fileName”).getBytes(“UTF-8”), “UTF-8”);</p>\n<h5 id=\"1-4-Found-reliance-on-default-encoding-in-com-cmcc-aoi-selfhelp-action-servlet-AoeRegAction-report-HttpServletRequest-HttpServletResponse-java-io-ByteArrayOutputStream-toString\"><a href=\"#1-4-Found-reliance-on-default-encoding-in-com-cmcc-aoi-selfhelp-action-servlet-AoeRegAction-report-HttpServletRequest-HttpServletResponse-java-io-ByteArrayOutputStream-toString\" class=\"headerlink\" title=\"1.4 Found reliance on default encoding in com.cmcc.aoi.selfhelp.action.servlet.AoeRegAction.report(HttpServletRequest, HttpServletResponse): java.io.ByteArrayOutputStream.toString()\"></a>1.4 Found reliance on default encoding in com.cmcc.aoi.selfhelp.action.servlet.AoeRegAction.report(HttpServletRequest, HttpServletResponse): java.io.ByteArrayOutputStream.toString()</h5><p>Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.<br>logger.info(“RECV STR: “ + baos.toString());<br>修改为<br>logger.info(“RECV STR: “ + baos.toString(“utf-8”));</p>\n<h5 id=\"1-5-Found-reliance-on-default-encoding-in-com-cmcc-aoi-selfhelp-action-servlet-AoeUploadLogAction-report-HttpServletRequest-HttpServletResponse-new-java-io-FileWriter-File\"><a href=\"#1-5-Found-reliance-on-default-encoding-in-com-cmcc-aoi-selfhelp-action-servlet-AoeUploadLogAction-report-HttpServletRequest-HttpServletResponse-new-java-io-FileWriter-File\" class=\"headerlink\" title=\"1.5 Found reliance on default encoding in com.cmcc.aoi.selfhelp.action.servlet.AoeUploadLogAction.report(HttpServletRequest, HttpServletResponse): new java.io.FileWriter(File)\"></a>1.5 Found reliance on default encoding in com.cmcc.aoi.selfhelp.action.servlet.AoeUploadLogAction.report(HttpServletRequest, HttpServletResponse): new java.io.FileWriter(File)</h5><p>Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.<br>new FileWriter(f).append(baos.toString(“UTF-8”)).close();<br>修改为<br>BufferedWriter out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(f, true)));<br>out.write(baos.toString(“UTF-8”));<br>out.close();</p>\n<p>BufferedWriter bw= new BufferedWriter( new OutputStreamWriter(new FileOutputStream(filePath, true), “utf-8”));</p>\n<h5 id=\"1-6-Found-reliance-on-default-encoding-in-new-com-cmcc-aoi-util-TokenZipFileUtil-String-new-java-io-FileReader-String\"><a href=\"#1-6-Found-reliance-on-default-encoding-in-new-com-cmcc-aoi-util-TokenZipFileUtil-String-new-java-io-FileReader-String\" class=\"headerlink\" title=\"1.6 Found reliance on default encoding in new com.cmcc.aoi.util.TokenZipFileUtil(String): new java.io.FileReader(String)\"></a>1.6 Found reliance on default encoding in new com.cmcc.aoi.util.TokenZipFileUtil(String): new java.io.FileReader(String)</h5><p>Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.<br>FileReader in = new FileReader(file);<br>改为<br>BufferedReader reader = new BufferedReader(new InputStreamReader(newFileInputStream(file), “UTF-8”)); </p>\n<h4 id=\"2-MS-SHOULD-BE-FINAL\"><a href=\"#2-MS-SHOULD-BE-FINAL\" class=\"headerlink\" title=\"2.MS_SHOULD_BE_FINAL\"></a>2.MS_SHOULD_BE_FINAL</h4><p>com.cmcc.aoi.selfhelp.action.DeliverWebRequestAction.logger isn’t final but should be<br>This static field public but not final, and could be changed by malicious code or by accident from another package. The field could be made final to avoid this vulnerability.</p>\n<p>protected static   Logger logger = LoggerFactory.getLogger(DeliverWebRequestAction.class);<br>修改为 protected static final Logger logger = LoggerFactory.getLogger(DeliverWebRequestAction.class);</p>\n<h4 id=\"3-DLS-DEAD-LOCAL-STORE\"><a href=\"#3-DLS-DEAD-LOCAL-STORE\" class=\"headerlink\" title=\"3.DLS_DEAD_LOCAL_STORE\"></a>3.DLS_DEAD_LOCAL_STORE</h4><p>Dead store to s in com.cmcc.aoi.selfhelp.action.DeliverWebRequestAction.textSend(WebSendTextForm, HttpServletRequest)<br>This instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used.<br>Note that Sun’s javac compiler often generates dead stores for final local variables. Because FindBugs is a bytecode-based tool, there is no easy way to eliminate these false positives.<br>ShopMappingDeliver shopMappingDeliver = null;<br>删除即可</p>\n<h4 id=\"4-ST-WRITE-TO-STATIC-FROM-INSTANCE-METHOD\"><a href=\"#4-ST-WRITE-TO-STATIC-FROM-INSTANCE-METHOD\" class=\"headerlink\" title=\"4.ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD\"></a>4.ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD</h4><p>Write to static field com.cmcc.aoi.selfhelp.action.MultipleMediaAoeAction.linkRoot from instance method com.cmcc.aoi.selfhelp.action.MultipleMediaAoeAction.afterPropertiesSet()<br>This instance method writes to a static field. This is tricky to get correct if multiple instances are being manipulated, and generally bad practice.<br>linkRoot = sysConfigService.getDomainName() + “/“;<br>修改改为：<br><figure class=\"highlight plain\"><figcaption><span>static String getLinkRoot() &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">        returnlinkRoot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    publicstaticvoid setLinkRoot(String linkRoot) &#123;</span><br><span class=\"line\">        MultipleMediaAoeAction.linkRoot = linkRoot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   MultipleMediaAoeAction.setLinkRoot(sysConfigService.getDomainName() + &quot;/&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">``` </span><br><span class=\"line\"></span><br><span class=\"line\">#### 5. J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION</span><br><span class=\"line\">Store of non serializable com.cmcc.aoi.selfhelp.action.UploadFileAction$FileUploadStatus into HttpSession in new com.cmcc.aoi.selfhelp.action.UploadFileAction$MyProgressListener(UploadFileAction, HttpServletRequest)</span><br><span class=\"line\">This code seems to be storing a non-serializable object into an HttpSession. If this session is passivated or migrated, an error will result.</span><br><span class=\"line\">修改为 FileUploadStatus implements Serializable</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">#### 6.  RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE</span><br><span class=\"line\">Redundant nullcheck of rtr, which is known to be non-null in com.cmcc.aoi.selfhelp.action.servlet.AoeReportApplistAction.device(HttpServletRequest, HttpServletResponse)</span><br><span class=\"line\">This method contains a redundant check of a known non-null value against the constant null.</span><br><span class=\"line\">```if (rtr != null) &#123;</span><br><span class=\"line\">            Writer writer;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                writer = response.getWriter();</span><br><span class=\"line\">                if (rtr != null) &#123;</span><br><span class=\"line\">                    try &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">                        String s = JSONUtil.objToJson(rtr);</span><br><span class=\"line\">                        if (LOGGER.isDebugEnabled()) &#123;</span><br><span class=\"line\">                            LOGGER.debug(&quot;SEND STR: &quot; + s);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        writer.write(s);</span><br><span class=\"line\">                        writer.flush();</span><br><span class=\"line\">                    &#125; catch (IOException e) &#123;</span><br><span class=\"line\">                        LOGGER.warn(&quot;&quot;, e);</span><br><span class=\"line\">                        if (writer != null) &#123;</span><br><span class=\"line\">                            try &#123;</span><br><span class=\"line\">                                writer.write(JSONUtil.objToJson(rtr));</span><br><span class=\"line\">                            &#125; catch (IOException e1) &#123;</span><br><span class=\"line\">                                LOGGER.warn(&quot;&quot;, e1);</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    response.getWriter().write(&quot;&#123;\\&quot;errorCode\\&quot;:401&#125;&quot;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; catch (IOException e2) &#123;</span><br><span class=\"line\">                LOGGER.warn(&quot;&quot;, e2);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<p>修改为<br><figure class=\"highlight plain\"><figcaption><span>(rtr !</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    Writer writer;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        writer = response.getWriter();</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">            String s = JSONUtil.objToJson(rtr);</span><br><span class=\"line\">            if (LOGGER.isDebugEnabled()) &#123;</span><br><span class=\"line\">                LOGGER.debug(&quot;SEND STR: &quot; + s);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            writer.write(s);</span><br><span class=\"line\">            writer.flush();</span><br><span class=\"line\">        &#125; catch (IOException e) &#123;</span><br><span class=\"line\">            LOGGER.warn(&quot;&quot;, e);</span><br><span class=\"line\">            if (writer != null) &#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    writer.write(JSONUtil.objToJson(rtr));</span><br><span class=\"line\">                &#125; catch (IOException e1) &#123;</span><br><span class=\"line\">                    LOGGER.warn(&quot;&quot;, e1);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    &#125; catch (IOException e2) &#123;</span><br><span class=\"line\">        LOGGER.warn(&quot;&quot;, e2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">    response.getWriter().write(&quot;&#123;\\&quot;errorCode\\&quot;:401&#125;&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"7-RU-INVOKE-RUN\"><a href=\"#7-RU-INVOKE-RUN\" class=\"headerlink\" title=\"7. RU_INVOKE_RUN\"></a>7. RU_INVOKE_RUN</h4><p>com.cmcc.aoi.selfhelp.action.servlet.UploadTokensAction$TokenFileThread.run() explicitly invokes run on a thread (did you mean to start it instead?)<br>This method explicitly invokes run() on an object.  In general, classes implement the Runnable interface because they are going to have their run() method invoked in a new thread, in which case Thread.start() is the right method to call.</p>\n<p><code>ti.run();</code><br>修改为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try &#123;</span><br><span class=\"line\">    ti.join();</span><br><span class=\"line\">&#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">     e.printStackTrace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"8-NM-SAME-SIMPLE-NAME-AS-SUPERCLASS\"><a href=\"#8-NM-SAME-SIMPLE-NAME-AS-SUPERCLASS\" class=\"headerlink\" title=\"8. NM_SAME_SIMPLE_NAME_AS_SUPERCLASS\"></a>8. NM_SAME_SIMPLE_NAME_AS_SUPERCLASS</h4><p>The class name com.cmcc.aoi.selfhelp.dao.BaseDao shadows the simple name of the superclass org.slave4j.orm.hibernate.BaseDao<br>This class has a simple name that is identical to that of its superclass, except that its superclass is in a different package (e.g., alpha.Foo extends beta.Foo). This can be exceptionally confusing, create lots of situations in which you have to look at import statements to resolve references and creates many opportunities to accidentally define methods that do not override methods in their superclasses<br>com.cmcc.aoi.selfhelp.dao.BaseDao<br>修改为<br>com.cmcc.aoi.selfhelp.dao.BasisDao</p>\n<h4 id=\"9-SE-BAD-FIELD-INNER-CLASS\"><a href=\"#9-SE-BAD-FIELD-INNER-CLASS\" class=\"headerlink\" title=\"9. SE_BAD_FIELD_INNER_CLASS\"></a>9. SE_BAD_FIELD_INNER_CLASS</h4><p>com.cmcc.aoi.selfhelp.action.UploadFileAction$FileUploadStatus is serializable but also an inner class of a non-serializable class<br>This Serializable class is an inner class of a non-serializable class. Thus, attempts to serialize it will also attempt to associate instance of the outer class with which it is associated, leading to a runtime error.<br>If possible, making the inner class a static inner class should solve the problem. Making the outer class serializable might also work, but that would mean serializing an instance of the inner class would always also serialize the instance of the outer class, which it often not what you really want.<br>修改外部类<br>UploadFileAction extends BaseAction implements Serializable</p>\n<h4 id=\"10-DM-BOXED-PRIMITIVE-FOR-PARSING\"><a href=\"#10-DM-BOXED-PRIMITIVE-FOR-PARSING\" class=\"headerlink\" title=\"10. DM_BOXED_PRIMITIVE_FOR_PARSING\"></a>10. DM_BOXED_PRIMITIVE_FOR_PARSING</h4><p>Boxing/unboxing to parse a primitive com.cmcc.aoi.selfhelp.dao.StatAppEveryHourDao.findWeekList(String)<br>A boxed primitive is created from a String, just to extract the unboxed primitive value. It is more efficient to just call the static parseXXX method.</p>\n<figure class=\"highlight plain\"><figcaption><span>statAppEveryHour.setAccnumber(Integer.valueOf(String.valueOf(objects[3])));</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">```</span><br><span class=\"line\">修改为</span><br><span class=\"line\"></span><br><span class=\"line\">```statAppEveryHour.setStattime(sdf.parse(String.valueOf(objects[1])));</span><br><span class=\"line\">                    statAppEveryHour</span><br><span class=\"line\">                            .setNewnumber(Integer.parseInt(String.valueOf(objects[2]) != null</span><br><span class=\"line\">                                    &amp;&amp; !&quot;&quot;.equals(String.valueOf(objects[2]))</span><br><span class=\"line\">                                            ? String.valueOf(objects[2]) : &quot;0&quot;));</span><br><span class=\"line\">                    statAppEveryHour</span><br><span class=\"line\">                            .setAccnumber(Integer.parseInt(String.valueOf(objects[3]) != null</span><br><span class=\"line\">                                    &amp;&amp; !&quot;&quot;.equals(String.valueOf(objects[3]))</span><br><span class=\"line\">                                            ? String.valueOf(objects[3]) : &quot;0&quot;));</span><br></pre></td></tr></table></figure>\n<h3 id=\"Normal\"><a href=\"#Normal\" class=\"headerlink\" title=\"Normal\"></a>Normal</h3><h4 id=\"1-SBSC-USE-STRINGBUFFER-CONCATENATION\"><a href=\"#1-SBSC-USE-STRINGBUFFER-CONCATENATION\" class=\"headerlink\" title=\"1.SBSC_USE_STRINGBUFFER_CONCATENATION\"></a>1.SBSC_USE_STRINGBUFFER_CONCATENATION</h4><p>com.cmcc.aoi.httprequest.service.HttpRequest.sendGet(String, String) concatenates strings using + in a loop<br>The method seems to be building a String using concatenation in a loop. In each iteration, the String is converted to a StringBuffer/StringBuilder, appended to, and converted back to a String. This can lead to a cost quadratic in the number of iterations, as the growing string is recopied in each iteration.<br>Better performance can be obtained by using a StringBuffer (or StringBuilder in Java 1.5) explicitly.<br>For example:<br>  // This is bad<br>  String s = “”;<br>  for (int i = 0; i &lt; field.length; ++i) {<br>    s = s + field[i];<br>  }</p>\n<p>  // This is better<br>  StringBuffer buf = new StringBuffer();<br>  for (int i = 0; i &lt; field.length; ++i) {<br>    buf.append(field[i]);<br>  }<br>  String s = buf.toString();</p>\n<h4 id=\"2-WMI-WRONG-MAP-ITERATOR\"><a href=\"#2-WMI-WRONG-MAP-ITERATOR\" class=\"headerlink\" title=\"2. WMI_WRONG_MAP_ITERATOR\"></a>2. WMI_WRONG_MAP_ITERATOR</h4><figure class=\"highlight plain\"><figcaption><span>(String key : map.keySet()) &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">                System.out.println(key + &quot;---&gt;&quot; + map.get(key));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>改为</p>\n<figure class=\"highlight plain\"><figcaption><span>(  Map.Entry<string, list<string=\"\">> entry : map.entrySet()) &#123;</string,></span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">                System.out.println(entry.getKey() + &quot;---&gt;&quot; + entry.getValue());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">``` </span><br><span class=\"line\">#### 3.  EI_EXPOSE_REP</span><br><span class=\"line\">com.cmcc.aoi.selfhelp.entity.Activation.getValidUntil() may expose internal representation by returning Activation.validUntil</span><br><span class=\"line\">Returning a reference to a mutable object value stored in one of the object&apos;s fields exposes the internal representation of the object.  If instances are accessed by untrusted code, and unchecked changes to the mutable object would compromise security or other important properties, you will need to do something different. Returning a new copy of the object is better approach in many situations.</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">    public Date getValidUntil() &#123;</span><br><span class=\"line\">        returnvalidUntil;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">修改为</span><br><span class=\"line\">public Date getValidUntil() &#123;</span><br><span class=\"line\">        if(validUntil == null) &#123;</span><br><span class=\"line\">            returnnull;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return (Date) validUntil.clone();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">#### 4. EI_EXPOSE_REP2</span><br><span class=\"line\">com.cmcc.aoi.selfhelp.entity.Activation.setValidUntil(Date) may expose internal representation by storing an externally mutable object into Activation.validUntil</span><br><span class=\"line\">This code stores a reference to an externally mutable object into the internal representation of the object.  If instances are accessed by untrusted code, and unchecked changes to the mutable object would compromise security or other important properties, you will need to do something different. Storing a copy of the object is better approach in many situations.</span><br><span class=\"line\"></span><br><span class=\"line\">```publicvoid setValidUntil(Date validUntil) &#123;</span><br><span class=\"line\">this.validUntil = validUntil;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>修改为<br><figure class=\"highlight plain\"><figcaption><span>setValidUntil(Date validUntil) &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">        if(validUntil == null) &#123;</span><br><span class=\"line\">            this.validUntil = null;</span><br><span class=\"line\">        &#125;else &#123;</span><br><span class=\"line\">            this.validUntil = (Date) validUntil.clone();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">``` </span><br><span class=\"line\"> </span><br><span class=\"line\">#### 5. BC_VACUOUS_INSTANCEOF</span><br><span class=\"line\">instanceof will always return true for all non-null values in com.cmcc.aoi.selfhelp.entity.AppType.compareTo(AppType), since all com.cmcc.aoi.selfhelp.entity.AppType are instances of com.cmcc.aoi.selfhelp.entity.AppType</span><br><span class=\"line\">This instanceof test will always return true (unless the value being tested is null). Although this is safe, make sure it isn&apos;t an indication of some misunderstanding or some other logic error. If you really want to test the value for being null, perhaps it would be clearer to do better to do a null test rather than an instanceof test.</span><br><span class=\"line\"> </span><br><span class=\"line\">#### 6. MS_MUTABLE_ARRAY</span><br><span class=\"line\">com.cmcc.aoi.selfhelp.entity.DeviceType.CURRENTUSEDDEVICES is a mutable array</span><br><span class=\"line\">A final static field references an array and can be accessed by malicious code or by accident from another package. This code can freely modify the contents of the array.</span><br><span class=\"line\"> </span><br><span class=\"line\">public static final int[] CURRENTUSEDDEVICES = new int []&#123;Device.iOS.ordinal()，Device.Android.ordinal()，Device.WP.ordinal()&#125;；</span><br><span class=\"line\">修改为</span><br><span class=\"line\"> Public &gt; protected</span><br><span class=\"line\"> </span><br><span class=\"line\">#### 7. EQ_COMPARETO_USE_OBJECT_EQUALS</span><br><span class=\"line\">com.cmcc.aoi.selfhelp.entity.AppType defines compareTo(AppType) and uses Object.equals()</span><br><span class=\"line\">This class defines a compareTo(...) method but inherits its equals() method from java.lang.Object. Generally, the value of compareTo should return zero if and only if equals returns true. If this is violated, weird and unpredictable failures will occur in classes such as PriorityQueue. In Java 5 the PriorityQueue.remove method uses the compareTo method, while in Java 6 it uses the equals method.</span><br><span class=\"line\">From the JavaDoc for the compareTo method in the Comparable interface:</span><br><span class=\"line\">It is strongly recommended, but not strictly required that (x.compareTo(y)==0) == (x.equals(y)). Generally speaking, any class that implements the Comparable interface and violates this condition should clearly indicate this fact. The recommended language is &quot;Note: this class has a natural ordering that is inconsistent with equals.&quot;</span><br><span class=\"line\"> </span><br><span class=\"line\">修改</span><br><span class=\"line\">添加 hashcode() 和 equals() 代码即可</span><br><span class=\"line\"> </span><br><span class=\"line\">#### 8. BC_VACUOUS_INSTANCEOF</span><br><span class=\"line\">instanceof will always return true for all non-null values in com.cmcc.aoi.selfhelp.entity.AppType.compareTo(AppType), since all com.cmcc.aoi.selfhelp.entity.AppType are instances of com.cmcc.aoi.selfhelp.entity.AppType</span><br><span class=\"line\">This instanceof test will always return true (unless the value being tested is null). Although this is safe, make sure it isn&apos;t an indication of some misunderstanding or some other logic error. If you really want to test the value for being null, perhaps it would be clearer to do better to do a null test rather than an instanceof test.</span><br><span class=\"line\">  </span><br><span class=\"line\">```@Override</span><br><span class=\"line\">    publicint compareTo(AppType o) &#123;</span><br><span class=\"line\">        if (oinstanceof AppType) &#123;</span><br><span class=\"line\">            AppType p = (AppType) o;</span><br><span class=\"line\">            returnthis.typeId &gt; p.typeId ? 1 : this.typeId == p.typeId ? 0 : -1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">``` </span><br><span class=\"line\"></span><br><span class=\"line\">修改为</span><br><span class=\"line\">  </span><br><span class=\"line\">```@Override</span><br><span class=\"line\">    publicint compareTo(AppType o) &#123;</span><br><span class=\"line\">        if (null != o) &#123;</span><br><span class=\"line\">            AppType p  = (AppType) o ;</span><br><span class=\"line\">            returnthis.typeId &gt; p.typeId ? 1 : this.typeId == p.typeId ? 0 : -1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\"> </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">``` </span><br><span class=\"line\">#### 9. ME_ENUM_FIELD_SETTER</span><br><span class=\"line\">com.cmcc.aoi.selfhelp.dto.ActivationSituation.setSituation(String) unconditionally sets the field situation</span><br><span class=\"line\">This public method declared in public enum unconditionally sets enum field, thus this field can be changed by malicious code or by accident from another package. Though mutable enum fields may be used for lazy initialization, it&apos;s a bad practice to expose them to the outer world. Consider removing this method or declaring it package-private.</span><br><span class=\"line\">    publicvoid setCode(String code) &#123;</span><br><span class=\"line\">        this.code = code;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">修改</span><br><span class=\"line\"> 删除该无用代码</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">#### 10.  IM_BAD_CHECK_FOR_ODD</span><br><span class=\"line\">Check for oddness that won&apos;t work for negative numbers in com.cmcc.aoi.selfhelp.dto.WebSendTextForm.toDeliverWebRequest()</span><br><span class=\"line\">The code uses x % 2 == 1 to check to see if a value is odd, but this won&apos;t work for negative numbers (e.g., (-5) % 2 == -1). If this code is intending to check for oddness, consider using x &amp; 1 == 1, or x % 2 != 0.</span><br><span class=\"line\"></span><br><span class=\"line\">```DeliverFactory</span><br><span class=\"line\">                                    .createTextOpenApp(this.msgtype, &quot;&quot;, this.content,</span><br><span class=\"line\">                                            this.isRingAndVibrate % 2 == 1,</span><br><span class=\"line\">                                            isRingAndVibrate / 2 &gt;= 1, this.activity)</span><br><span class=\"line\">                                    .toJsonString());</span><br><span class=\"line\"></span><br><span class=\"line\">``` </span><br><span class=\"line\">修改为</span><br><span class=\"line\"></span><br><span class=\"line\">```DeliverFactory</span><br><span class=\"line\">                                    .createTextOpenApp(this.msgtype, &quot;&quot;, this.content,</span><br><span class=\"line\">                                            this.isRingAndVibrate % 2 != 0,</span><br><span class=\"line\">                                            isRingAndVibrate / 2 &gt;= 1, this.activity)</span><br><span class=\"line\">                                    .toJsonString());</span><br><span class=\"line\"></span><br><span class=\"line\">``` </span><br><span class=\"line\"> </span><br><span class=\"line\">#### 11. MS_EXPOSE_REP</span><br><span class=\"line\">Public static com.cmcc.aoi.selfhelp.dict.DeviceSupported.getSupportedDevs() may expose internal representation by returning DeviceSupported.DEVS</span><br><span class=\"line\">A public static method returns a reference to an array that is part of the static state of the class. Any code that calls this method can freely modify the underlying array. One fix is to return a copy of the array.</span><br><span class=\"line\"></span><br><span class=\"line\">```public static Device[] getSupportedDevs() &#123;</span><br><span class=\"line\">        return DEVS;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>修改为</p>\n<figure class=\"highlight plain\"><figcaption><span>Device[] getSupportedDevs() &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">        return DeviceSupported.DEVS.clone();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">``` </span><br><span class=\"line\">#### 12.URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD</span><br><span class=\"line\">Unread public/protected field: com.cmcc.aoi.selfhelp.dict.OperatorDict.countryCode</span><br><span class=\"line\">This field is never read.  The field is public or protected, so perhaps it is intended to be used with classes not seen as part of the analysis. If not, consider removing it from the class.</span><br><span class=\"line\">publicintcode;</span><br><span class=\"line\">    </span><br><span class=\"line\">```public String enName;</span><br><span class=\"line\">    public String cnName;</span><br><span class=\"line\">    public String countryCode;</span><br><span class=\"line\"> </span><br><span class=\"line\">    public OperatorDict() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    /**</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param code</span><br><span class=\"line\">     *            运营商代码,一般是5位</span><br><span class=\"line\">     * @param enName</span><br><span class=\"line\">     *            英文名</span><br><span class=\"line\">     * @param countryCode</span><br><span class=\"line\">     *            国家英文代码</span><br><span class=\"line\">     * @param cnName</span><br><span class=\"line\">     *            中文名</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public OperatorDict(intcode, String enName, String countryCode, String cnName) &#123;</span><br><span class=\"line\">        this.code = code;</span><br><span class=\"line\">        this.enName = enName;</span><br><span class=\"line\">        this.countryCode = countryCode;</span><br><span class=\"line\">        this.cnName = cnName == null ? Integer.toString(code) : cnName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">```修改为</span><br><span class=\"line\">Public  -》 private</span><br><span class=\"line\">  </span><br><span class=\"line\">#### 13. ES_COMPARING_STRINGS_WITH_EQ</span><br><span class=\"line\">Comparison of String objects using == or != in com.cmcc.aoi.selfhelp.entity.Provider.compareTo(Object)</span><br><span class=\"line\">This code compares java.lang.String objects for reference equality using the == or != operators. Unless both strings are either constants in a source file, or have been interned using the String.intern() method, the same string value may be represented by two different String objects. Consider using the equals(Object) method instead.</span><br><span class=\"line\"> </span><br><span class=\"line\">return this.spid.compareTo(p.spid) &gt; 0 ? 1 : this.spid == p.spid ? 0 : -1;</span><br><span class=\"line\">修改为</span><br><span class=\"line\">this.spid.compareTo(p.spid) &gt; 0 ? 1 : this.spid.equals(p.spid) ? 0 : -1;</span><br><span class=\"line\">14.DB_DUPLICATE_BRANCHES</span><br><span class=\"line\">com.cmcc.aoi.selfhelp.dao.ShStatTerminalDao.getListQuery(String, int, Date, Date, boolean, int) uses the same code for two branches</span><br><span class=\"line\">This method uses the same code to implement two branches of a conditional branch. Check to ensure that this isn&apos;t a coding mistake.</span><br><span class=\"line\"></span><br><span class=\"line\">```if (bool) &#123;</span><br><span class=\"line\">                query.setInteger(i++, nodeType);</span><br><span class=\"line\">                query.setInteger(i++, nodeType);</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                query.setInteger(i++, nodeType);</span><br><span class=\"line\">                query.setInteger(i++, nodeType);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">```修改为</span><br><span class=\"line\"></span><br><span class=\"line\">```query.setInteger(i++, nodeType);</span><br><span class=\"line\">query.setInteger(i++, nodeType);</span><br></pre></td></tr></table></figure>\n<h4 id=\"15-SE-COMPARATOR-SHOULD-BE-SERIALIZABLE\"><a href=\"#15-SE-COMPARATOR-SHOULD-BE-SERIALIZABLE\" class=\"headerlink\" title=\"15. SE_COMPARATOR_SHOULD_BE_SERIALIZABLE\"></a>15. SE_COMPARATOR_SHOULD_BE_SERIALIZABLE</h4><p>com.cmcc.aoi.selfhelp.task.entity.StatAppHabitComparator implements Comparator but not Serializable<br>This class implements the Comparator interface. You should consider whether or not it should also implement the Serializable interface. If a comparator is used to construct an ordered collection such as a TreeMap, then the TreeMap will be serializable only if the comparator is also serializable. As most comparators have little or no state, making them serializable is generally easy and good defensive programming.<br>修改为<br>implements Serializable</p>\n<h4 id=\"16-UWF-UNWRITTEN-PUBLIC-OR-PROTECTED-FIELD\"><a href=\"#16-UWF-UNWRITTEN-PUBLIC-OR-PROTECTED-FIELD\" class=\"headerlink\" title=\"16.  UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD\"></a>16.  UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD</h4><p>Unwritten public or protected field: com.cmcc.aoi.selfhelp.task.entity.StatDevice.keyname<br>No writes were seen to this public/protected field.  All reads of it will return the default value. Check for errors (should it have been initialized?), or remove it if it is useless.<br>Public  String keyname;<br>修改为<br>Private  String keyname;</p>\n<h4 id=\"18-RV-RETURN-VALUE-IGNORED-BAD-PRACTICE\"><a href=\"#18-RV-RETURN-VALUE-IGNORED-BAD-PRACTICE\" class=\"headerlink\" title=\"18.  RV_RETURN_VALUE_IGNORED_BAD_PRACTICE\"></a>18.  RV_RETURN_VALUE_IGNORED_BAD_PRACTICE</h4><p>Exceptional return value of java.io.File.mkdirs() ignored in com.cmcc.aoi.util.FileUtil.moveFile(File, String)<br>This method returns a value that is not checked. The return value should be checked since it can indicate an unusual or unexpected function execution. For example, the File.delete() method returns false if the file could not be successfully deleted (rather than throwing an Exception). If you don’t check the result, you won’t notice if the method invocation signals unexpected behavior by returning an atypical return value.<br>tmp.mkdirs()<br>修改为<br>booleanmkdirs = tmp.mkdirs();<br>logger.debug(“debug”,mkdirs);</p>\n<p>REC_CATCH_EXCEPTION<br>Exception is caught when Exception is not thrown in com.cmcc.aoi.selfhelp.task.fileparser.TokenIncrease.parseLine(String[])<br>This method uses a try-catch block that catches Exception objects, but Exception is not thrown within the try block, and RuntimeException is not explicitly caught. It is a common bug pattern to say try { … } catch (Exception e) { something } as a shorthand for catching a number of types of exception each of whose catch blocks is identical, but this construct also accidentally catches RuntimeException as well, masking potential bugs.<br>A better approach is to either explicitly catch the specific exceptions that are thrown, or to explicitly catch RuntimeException exception, rethrow it, and then catch all non-Runtime Exceptions, as shown below:</p>\n<figure class=\"highlight plain\"><figcaption><span>&#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    ...</span><br><span class=\"line\">  &#125; catch (RuntimeException e) &#123;</span><br><span class=\"line\">    throw e;</span><br><span class=\"line\">  &#125; catch (Exception e) &#123;</span><br><span class=\"line\">    ... deal with all non-runtime exceptions ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">``` </span><br><span class=\"line\"> </span><br><span class=\"line\">#### 19. ICAST_IDIV_CAST_TO_DOUBLE</span><br><span class=\"line\">Integral division result cast to double or float in com.cmcc.aoi.selfhelp.service.BaseAnalysisService.getInterval(Date, Date, int)</span><br><span class=\"line\">This code casts the result of an integral division (e.g., int or long division) operation to double or float. Doing division on integers truncates the result to the integer value closest to zero. The fact that the result was cast to double suggests that this precision should have been retained. What was probably meant was to cast one or both of the operands to double before performing the division. </span><br><span class=\"line\">```Here is an example:</span><br><span class=\"line\">int x = 2;</span><br><span class=\"line\">int y = 5;</span><br><span class=\"line\">// Wrong: yields result 0.0</span><br><span class=\"line\">double value1 =  x / y;</span><br><span class=\"line\"> </span><br><span class=\"line\">// Right: yields result 0.4</span><br><span class=\"line\">double value2 =  x / (double) y;</span><br></pre></td></tr></table></figure>\n<h2 id=\"FindBugs规则整理\"><a href=\"#FindBugs规则整理\" class=\"headerlink\" title=\"FindBugs规则整理\"></a>FindBugs规则整理</h2><p>FindBugs是基于Bug Patterns概念，查找javabytecode（.class文件）中的潜在bug，主要检查bytecode中的bug patterns，如NullPoint空指针检查、没有合理关闭资源、字符串相同判断错（==，而不是equals）等</p>\n<h3 id=\"一、Security-关于代码安全性防护\"><a href=\"#一、Security-关于代码安全性防护\" class=\"headerlink\" title=\"一、Security 关于代码安全性防护\"></a>一、Security 关于代码安全性防护</h3><p>1.Dm: Hardcoded constant database password (DMI_CONSTANT_DB_PASSWORD)<br>代码中创建DB的密码时采用了写死的密码。<br>2.Dm: Empty database password (DMI_EMPTY_DB_PASSWORD)<br>创建数据库连接时没有为数据库设置密码，这会使数据库没有必要的保护。<br>3.HRS: HTTP cookie formed from untrusted input (HRS_REQUEST_PARAMETER_TO_COOKIE)<br>此代码使用不受信任的HTTP参数构造一个HTTP Cookie。<br>4.HRS: HTTP Response splitting vulnerability (HRS_REQUEST_PARAMETER_TO_HTTP_HEADER)<br>在代码中直接把一个HTTP的参数写入一个HTTP头文件中，它为HTTP的响应暴露了漏洞。<br>5.SQL: Nonconstant string passed to execute method on an SQL statement (SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE)<br>该方法以字符串的形式来调用SQLstatement的execute方法，它似乎是动态生成SQL语句的方法。这会更容易受到SQL注入攻击。<br>6.XSS: JSP reflected cross site scripting vulnerability (XSS_REQUEST_PARAMETER_TO_JSP_WRITER)<br>在代码中在JSP输出中直接写入一个HTTP参数，这会造成一个跨站点的脚本漏洞。</p>\n<h3 id=\"二、Experimental\"><a href=\"#二、Experimental\" class=\"headerlink\" title=\"二、Experimental\"></a>二、Experimental</h3><p>1.LG: Potential lost logger changes due to weak reference in OpenJDK (LG_LOST_LOGGER_DUE_TO_WEAK_REFERENCE)<br>OpenJDK的引入了一种潜在的不兼容问题，特别是，java.util.logging.Logger的行为改变时。它现在使用内部弱引用，而不是强引用。–logger配置改变，它就是丢失对logger的引用，这本是一个合理的变化，但不幸的是一些代码对旧的行为有依赖关系。这意味着，当进行垃圾收集时对logger配置将会丢失。例如：<br>public static void initLogging() throws Exception {<br> Logger logger = Logger.getLogger(“edu.umd.cs”);<br> logger.addHandler(new FileHandler()); // call to change logger configuration<br> logger.setUseParentHandlers(false); // another call to change logger configuration<br>}<br>该方法结束时logger的引用就丢失了，如果你刚刚结束调用initLogging方法后进行垃圾回收，logger的配置将会丢失（因为只有保持记录器弱引用）。<br>public static void main(String[] args) throws Exception {<br> initLogging(); // adds a file handler to the logger<br> System.gc(); // logger configuration lost<br> Logger.getLogger(“edu.umd.cs”).info(“Some message”); // this isn’t logged to the file as expected<br>}<br>2.OBL: Method may fail to clean up stream or resource (OBL_UNSATISFIED_OBLIGATION)<br>这种方法可能无法清除（关闭，处置）一个流，数据库对象，或其他资源需要一个明确的清理行动。<br>一般来说，如果一个方法打开一个流或其他资源，该方法应该使用try / finally块来确保在方法返回之前流或资源已经被清除了。这种错误模式基本上和OS_OPEN_STREAM和ODR_OPEN_DATABASE_RESOURCE错误模式相同，但是是在不同在静态分析技术。我们正为这个错误模式的效用收集反馈意见。</p>\n<h3 id=\"三、Bad-practice代码实现中的一些坏习惯\"><a href=\"#三、Bad-practice代码实现中的一些坏习惯\" class=\"headerlink\" title=\"三、Bad practice代码实现中的一些坏习惯\"></a>三、Bad practice代码实现中的一些坏习惯</h3><p>1.AM: Creates an empty jar file entry (AM_CREATES_EMPTY_JAR_FILE_ENTRY)<br>调用putNextEntry()方法写入新的 jar 文件条目时立即调用closeEntry()方法。这样会造成JarFile条目为空。<br>2.AM: Creates an empty zip file entry (AM_CREATES_EMPTY_ZIP_FILE_ENTRY)<br>调用putNextEntry()方法写入新的 zip 文件条目时立即调用closeEntry()方法。这样会造成ZipFile条目为空。<br>3.BC: Equals method should not assume anything about the type of its argument (BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS)<br>equals(Object o)方法不能对参数o的类型做任何的假设。比较此对象与指定的对象。当且仅当该参数不为 null，并且是表示与此对象相同的类型的对象时，结果才为 true。<br>4.BC: Random object created and used only once (DMI_RANDOM_USED_ONLY_ONCE)<br>随机创建对象只使用过一次就抛弃<br>5.BIT: Check for sign of bitwise operation (BIT_SIGNED_CHECK)<br>检查位操作符运行是否合理<br>((event.detail &amp; SWT.SELECTED) &gt; 0)<br>If SWT.SELECTED is a negative number, this is a candidate for a bug. Even when SWT.SELECTED is not negative, it seems good practice to use ‘!= 0’ instead of ‘&gt; 0’.<br>6.CN: Class implements Cloneable but does not define or use clone method (CN_IDIOM)<br>按照惯例，实现此接口的类应该使用公共方法重写 Object.clone（它是受保护的），以获得有关重写此方法的详细信息。此接口不 包含 clone 方法。因此，因为某个对象实现了此接口就克隆它是不可能的,应该实现此接口的类应该使用公共方法重写 Object.clone<br>7.CN: clone method does not call super.clone() (CN_IDIOM_NO_SUPER_CALL)<br>一个非final类型的类定义了clone()方法而没有调用super.clone()方法。例如：B扩展自A，如果B中clone方法调用了spuer.clone（），而A中的clone没有调用spuer.clone()，就会造成结果类型不准确。要求A的clone方法中调用spuer.clone()方法。<br>8.CN: Class defines clone() but doesn’t implement Cloneable (CN_IMPLEMENTS_CLONE_BUT_NOT_CLONEABLE)<br>类中定义了clone方法但是它没有实现Cloneable接口<br>9.Co: Abstract class defines covariant compareTo() method (CO_ABSTRACT_SELF)<br>抽象类中定义了多个compareTo()方法，正确的是覆写Comparable中的compareTo方法，方法的参数为Object类型，如下例：<br>int compareTo(T o)  比较此对象与指定对象的顺序。<br>10.Co: Covariant compareTo() method defined (CO_SELF_NO_OBJECT)<br>类中定义了多个compareTo()方法，正确的是覆写Comparable中的compareTo方法，方法的参数为Object类型<br>11.DE: Method might drop exception (DE_MIGHT_DROP)<br>方法可能抛出异常<br>12.DE: Method might ignore exception (DE_MIGHT_IGNORE)<br>方法可能忽略异常<br>13.DMI: Don’t use removeAll to clear a collection (DMI_USING_REMOVEALL_TO_CLEAR_COLLECTION)<br>不要用removeAll方法去clear一个集合<br>14.DP: Classloaders should only be created inside doPrivileged block (DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED)<br>类加载器只能建立在特殊的方法体内<br>15.Dm: Method invokes System.exit(…) (DM_EXIT)<br>在方法中调用System.exit(…)语句，考虑用RuntimeException来代替<br>16.Dm: Method invokes dangerous method runFinalizersOnExit (DM_RUN_FINALIZERS_ON_EXIT)<br>在方法中调用了System.runFinalizersOnExit 或者Runtime.runFinalizersOnExit方法，因为这样做是很危险的。<br>17.ES: Comparison of String parameter using == or != (ES_COMPARING_PARAMETER_STRING_WITH_EQ)<br>用==或者!=方法去比较String类型的参数<br>18.ES: Comparison of String objects using == or != (ES_COMPARING_STRINGS_WITH_EQ)<br>用==或者！=去比较String类型的对象<br>19.Eq: Abstract class defines covariant equals() method (EQ_ABSTRACT_SELF)<br>20.Eq: Equals checks for noncompatible operand (EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS)<br>equals方法检查不一致的操作。两个类根本就是父子关系而去调用equals方法去判读对象是否相等。<br>public boolean equals(Object o) {<br>  if (o instanceof Foo)<br>    return name.equals(((Foo)o).name);<br>  else if (o instanceof String)<br>    return name.equals(o);<br>  else return false;<br>21.Eq: Class defines compareTo(…) and uses Object.equals() (EQ_COMPARETO_USE_OBJECT_EQUALS)<br>类中定义了compareTo方法但是继承了Object中的compareTo方法<br>22.Eq: equals method fails for subtypes (EQ_GETCLASS_AND_CLASS_CONSTANT)<br>类中的equals方法可能被子类中的方法所破坏，当使用类似于Foo.class == o.getClass()的判断时考虑用this.getClass() == o.getClass()来替换<br>23.Eq: Covariant equals() method defined (EQ_SELF_NO_OBJECT)<br>类中定义了多个equals方法。正确的做法是覆写Object中的equals方法，它的参数为Object类型的对象。<br>24.FI: Empty finalizer should be deleted (FI_EMPTY)<br>为空的finalizer方法应该删除。一下关于finalizer的内容省略<br>25.GC: Unchecked type in generic call (GC_UNCHECKED_TYPE_IN_GENERIC_CALL)<br>This call to a generic collection method passes an argument while compile type Object where a specific type from the generic type parameters is expected. Thus, neither the standard Java type system nor static analysis can provide useful information on whether the object being passed as a parameter is of an appropriate type.<br>26.HE: Class defines equals() but not hashCode() (HE_EQUALS_NO_HASHCODE)<br>方法定义了equals方法却没有定义hashCode方法<br>27.HE: Class defines hashCode() but not equals() (HE_HASHCODE_NO_EQUALS)<br> 类定义了hashCode方法去没有定义equal方法<br>28.HE: Class defines equals() and uses Object.hashCode() (HE_EQUALS_USE_HASHCODE)<br>一个类覆写了equals方法，没有覆写hashCode方法，使用了Object对象的hashCode方法<br>29.HE: Class inherits equals() and uses Object.hashCode() (HE_INHERITS_EQUALS_USE_HASHCODE)<br>子类继承了父类的equals方法却使用了Object的hashCode方法<br>30.IC: Superclass uses subclass during initialization (IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION)<br>子类在父类未初始化之前使用父类对象实例<br>public class CircularClassInitialization {<br>        static class InnerClassSingleton extends CircularClassInitialization {<br>static InnerClassSingleton singleton = new InnerClassSingleton();<br>        }<br>        static CircularClassInitialization foo = InnerClassSingleton.singleton;<br>}<br>31.IMSE: Dubious catching of IllegalMonitorStateException (IMSE_DONT_CATCH_IMSE)<br>捕捉违法的监控状态异常，例如当没有获取到对象锁时使用其wait和notify方法<br>32.ISC: Needless instantiation of class that only supplies static methods (ISC_INSTANTIATE_STATIC_CLASS)<br>为使用静态方法而创建一个实例对象。调用静态方法时只需要使用类名+静态方法名就可以了。<br>33.It: Iterator next() method can’t throw NoSuchElementException (IT_NO_SUCH_ELEMENT)<br>迭代器的next方法不能够抛出NoSuchElementException<br>34.J2EE: Store of non serializable object into HttpSession (J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION)<br>在HttpSession对象中保存非连续的对象<br>35.JCIP: Fields of immutable classes should be final (JCIP_FIELD_ISNT_FINAL_IN_IMMUTABLE_CLASS)<br> The class is annotated with net.jcip.annotations.Immutable, and the rules for that annotation require that all fields are final. .<br>36.NP: Method with Boolean return type returns explicit null (NP_BOOLEAN_RETURN_NULL)<br>返回值为boolean类型的方法直接返回null，这样会导致空指针异常<br>37.NP: equals() method does not check for null argument (NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT)<br>变量调用equals方法时没有进行是否为null的判断<br>38.NP: toString method may return null (NP_TOSTRING_COULD_RETURN_NULL)<br>toString方法可能返回null<br>39.Nm: Class names should start with an upper case letter (NM_CLASS_NAMING_CONVENTION)<br>类的名称以大写字母名称开头<br>40.Nm: Class is not derived from an Exception, even though it is named as such (NM_CLASS_NOT_EXCEPTION)<br>类的名称中含有Exception但是却不是一个异常类的子类，这种名称会造成混淆<br>41.Nm: Confusing method names (NM_CONFUSING)<br>令人迷惑的方面命名<br>42.Nm: Field names should start with a lower case letter (NM_FIELD_NAMING_CONVENTION)<br>非final类型的字段需要遵循驼峰命名原则<br>43.Nm: Use of identifier that is a keyword in later versions of Java (NM_FUTURE_KEYWORD_USED_AS_IDENTIFIER)<br>验证是否是java预留关键字<br>44.Nm: Use of identifier that is a keyword in later versions of Java (NM_FUTURE_KEYWORD_USED_AS_MEMBER_IDENTIFIER)<br>验证是否时java中的关键字<br>45.Nm: Method names should start with a lower case letter (NM_METHOD_NAMING_CONVENTION)<br>方法名称以小写字母开头<br>46.Nm: Class names shouldn’t shadow simple name of implemented interface (NM_SAME_SIMPLE_NAME_AS_INTERFACE)<br>实现同一接口实现类不能使用相同的名称，即使它们位于不同的包中<br>47.Nm: Class names shouldn’t shadow simple name of superclass (NM_SAME_SIMPLE_NAME_AS_SUPERCLASS)<br>继承同一父类的子类不能使用相同的名称，即使它们位于不同的包中<br>48.Nm: Very confusing method names (but perhaps intentional) (NM_VERY_CONFUSING_INTENTIONAL)<br>很容易混淆的方法命名，例如方法的名称名称使用使用大小写来区别两个不同的方法。<br>49.Nm: Method doesn’t override method in superclass due to wrong package for parameter (NM_WRONG_PACKAGE_INTENTIONAL)<br>由于错误引用了不同包中相同类名的对象而不能够正确的覆写父类中的方法<br>import alpha.Foo;<br>public class A {<br>  public int f(Foo x) { return 17; }<br>}<br>import beta.Foo;<br>public class B extends A {<br>  public int f(Foo x) { return 42; }<br>  public int f(alpha.Foo x) { return 27; }<br>}<br>50.ODR: Method may fail to close database resource (ODR_OPEN_DATABASE_RESOURCE)<br>方法中可能存在关闭数据连接失败的情况<br>51.OS: Method may fail to close stream (OS_OPEN_STREAM)<br>方法中可能存在关闭流失败的情况<br>52.OS: Method may fail to close stream on exception (OS_OPEN_STREAM_EXCEPTION_PATH)<br>方法中可能存在关闭流时出现异常情况<br>53.RC: Suspicious reference comparison to constant (RC_REF_COMPARISON_BAD_PRACTICE)<br>当两者为不同类型的对象时使用equals方法来比较它们的值是否相等，而不是使用==方法。例如比较的两者为java.lang.Integer, java.lang.Float<br>54.RC: Suspicious reference comparison of Boolean values (RC_REF_COMPARISON_BAD_PRACTICE_BOOLEAN)<br>使用== 或者 !=操作符来比较两个 Boolean类型的对象，建议使用equals方法。<br>55.RR: Method ignores results of InputStream.read() (RR_NOT_CHECKED)<br>InputStream.read方法忽略返回的多个字符，如果对结果没有检查就没法正确处理用户读取少量字符请求的情况。<br>56.RR: Method ignores results of InputStream.skip() (SR_NOT_CHECKED)<br>InputStream.skip()方法忽略返回的多个字符，如果对结果没有检查就没法正确处理用户跳过少量字符请求的情况<br>57.RV: Method ignores exceptional return value (RV_RETURN_VALUE_IGNORED_BAD_PRACTICE)<br>方法忽略返回值的异常信息<br>58.SI: Static initializer creates instance before all static final fields assigned (SI_INSTANCE_BEFORE_FINALS_ASSIGNED)<br>在所有的static final字段赋值之前去使用静态初始化的方法创建一个类的实例。<br>59.Se: Non-serializable value stored into instance field of a serializable class (SE_BAD_FIELD_STORE)<br>非序列化的值保存在声明为序列化的的非序列化字段中<br>60.Se: Comparator doesn’t implement Serializable (SE_COMPARATOR_SHOULD_BE_SERIALIZABLE)<br>Comparator接口没有实现Serializable接口<br>61.Se: Serializable inner class (SE_INNER_CLASS)<br>序列化内部类<br>62.Se: serialVersionUID isn’t final (SE_NONFINAL_SERIALVERSIONID)<br>关于UID类的检查内容省略<br>63.Se: Class is Serializable but its superclass doesn’t define a void constructor (SE_NO_SUITABLE_CONSTRUCTOR)<br>子类序列化时父类没有提供一个void的构造函数<br>64.Se: Class is Externalizable but doesn’t define a void constructor (SE_NO_SUITABLE_CONSTRUCTOR_FOR_EXTERNALIZATION)<br>Externalizable 实例类没有定义一个void类型的构造函数<br>65.Se: The readResolve method must be declared with a return type of Object. (SE_READ_RESOLVE_MUST_RETURN_OBJECT)<br>readResolve从流中读取类的一个实例，此方法必须声明返回一个Object类型的对象<br>66.Se: Transient field that isn’t set by deserialization. (SE_TRANSIENT_FIELD_NOT_RESTORED)<br>This class contains a field that is updated at multiple places in the class, thus it seems to be part of the state of the class. However, since the field is marked as transient and not set in readObject or readResolve, it will contain the default value in any deserialized instance of the class.<br>67.SnVI: Class is Serializable, but doesn’t define serialVersionUID (SE_NO_SERIALVERSIONID)<br>一个类实现了Serializable接口但是没有定义serialVersionUID类型的变量。序列化运行时使用一个称为 serialVersionUID 的版本号与每个可序列化类相关联，该序列号在反序列化过程中用于验证序列化对象的发送者和接收者是否为该对象加载了与序列化兼容的类。如果接收者加载的该对象的类的 serialVersionUID 与对应的发送者的类的版本号不同，则反序列化将会导致 InvalidClassException。可序列化类可以通过声明名为 “serialVersionUID” 的字段（该字段必须是静态 (static)、最终 (final) 的 long 型字段）显式声明其自己的 serialVersionUID：<br> ANY-ACCESS-MODIFIER static final long serialVersionUID = 42L;<br>68.UI: Usage of GetResource may be unsafe if class is extended (UI_INHERITANCE_UNSAFE_GETRESOURCE)<br>当一个类被子类继承后不要使用this.getClass().getResource(…)来获取资源</p>\n<h3 id=\"四、Correctness关于代码正确性相关方面的\"><a href=\"#四、Correctness关于代码正确性相关方面的\" class=\"headerlink\" title=\"四、Correctness关于代码正确性相关方面的\"></a>四、Correctness关于代码正确性相关方面的</h3><p>1.BC: Impossible cast (BC_IMPOSSIBLE_CAST)<br>不可能的类转换，执行时会抛出ClassCastException<br>2.BC: Impossible downcast (BC_IMPOSSIBLE_DOWNCAST)<br>父类在向下进行类型转换时抛出ClassCastException<br>3.BC: Impossible downcast of toArray() result (BC_IMPOSSIBLE_DOWNCAST_OF_TOARRAY)<br>集合转换为数组元素时发生的类转换错误。<br>This code is casting the result of calling toArray() on a collection to a type more specific than Object[], as in:<br>String[] getAsArray(Collection<string> c) {<br>  return (String[]) c.toArray();<br>  }<br>This will usually fail by throwing a ClassCastException. The toArray() of almost all collections return an Object[]. They can’t really do anything else, since the Collection object has no reference to the declared generic type of the collection.<br>The correct way to do get an array of a specific type from a collection is to use c.toArray(new String[]); or c.toArray(new String[c.size()]); (the latter is slightly more efficient).<br>4.BC: instanceof will always return false (BC_IMPOSSIBLE_INSTANCEOF)<br>采用instaneof方法进行比较时总是返回false。前提是保证它不是由于某些逻辑错误造成的。<br>5.BIT: Incompatible bit masks (BIT_AND)<br>错误的使用&amp;位操作符，例如(e &amp; C)<br>6.BIT: Check to see if ((…) &amp; 0) == 0 (BIT_AND_ZZ)<br>检查恒等的逻辑错误<br>7.BIT: Incompatible bit masks (BIT_IOR)<br>错误的使用|位操作符，例如(e | C)<br>8.BIT: Check for sign of bitwise operation (BIT_SIGNED_CHECK_HIGH_BIT)<br>检查逻辑运算符操作返回的标识。例如((event.detail &amp; SWT.SELECTED) &gt; 0)，建议采用!=0代替&gt;0<br>9.BOA: Class overrides a method implemented in super class Adapter wrongly (BOA_BADLY_OVERRIDDEN_ADAPTER)<br>子类错误的覆写父类中用于适配监听其他事件的方法，从而导致当触发条件发生时不能被监听者调用<br>10.Bx: Primitive value is unboxed and coerced for ternary operator (BX_UNBOXED_AND_COERCED_FOR_TERNARY_OPERATOR)<br>在三元运算符操作时如果没有对值进行封装或者类型转换。例如：b ? e1 : e2<br>11.DLS: Dead store of class literal (DLS_DEAD_STORE_OF_CLASS_LITERAL)<br>以类的字面名称方式为一个字段赋值后再也没有去使用它，在1.4jdk中它会自动调用静态的初始化方法，而在jdk1.5中却不会去执行。<br>12.DLS: Overwritten increment (DLS_OVERWRITTEN_INCREMENT)<br>覆写增量增加错误i = i++<br>13.DMI: Bad constant value for month (DMI_BAD_MONTH)<br>hashNext方法调用next方法。<br>14.DMI: Collections should not contain themselves (DMI_COLLECTIONS_SHOULD_NOT_CONTAIN_THEMSELVES)<br>集合没有包含他们自己本身。<br>15.DMI: Invocation of hashCode on an array (DMI_INVOKING_HASHCODE_ON_ARRAY)<br>数组直接使用hashCode方法来返回哈希码。<br>int [] a1 = new int[]{1,2,3,4};<br>        System.out.println(a1.hashCode());<br>        System.out.println(java.util.Arrays.hashCode(a1));<br>16.DMI: Double.longBitsToDouble invoked on an int (DMI_LONG_BITS_TO_DOUBLE_INVOKED_ON_INT)<br>17.DMI: Vacuous call to collections (DMI_VACUOUS_SELF_COLLECTION_CALL)<br>集合的调用不能被感知。例如c.containsAll(c)总是返回true，而c.retainAll(c)的返回值不能被感知。<br>18.Dm: Can’t use reflection to check for presence of annotation without runtime retention (DMI_ANNOTATION_IS_NOT_VISIBLE_TO_REFLECTION)<br>Unless an annotation has itself been annotated with @Retention(RetentionPolicy.RUNTIME), the annotation can’t be observed using reflection (e.g., by using the isAnnotationPresent method). .<br>19.Dm: Useless/vacuous call to EasyMock method (DMI_VACUOUS_CALL_TO_EASYMOCK_METHOD)<br>While ScheduledThreadPoolExecutor inherits from ThreadPoolExecutor, a few of the inherited tuning methods are not useful for it. In particular, because it acts as a fixed-sized pool using corePoolSize threads and an unbounded queue, adjustments to maximumPoolSize have no useful effect.<br>20.EC: equals() used to compare array and nonarray (EC_ARRAY_AND_NONARRAY)<br>数组对象使用equals方法和非数组对象进行比较。即使比较的双方都是数组对象也不应该使用equals方法，而应该比较它们的内容是否相等使用java.util.Arrays.equals(Object[], Object[]);<br>21.EC: equals(…) used to compare incompatible arrays (EC_INCOMPATIBLE_ARRAY_COMPARE)<br>使用equls方法去比较类型不相同的数组。例如：String[] and StringBuffer[], or String[] and int[]<br>22.EC: Call to equals() with null argument (EC_NULL_ARG)<br>调用equals的对象为null<br>23.EC: Call to equals() comparing unrelated class and interface (EC_UNRELATED_CLASS_AND_INTERFACE)<br>使用equals方法比较不相关的类和接口<br>24.EC: Call to equals() comparing different interface types (EC_UNRELATED_INTERFACES)<br>调用equals方法比较不同类型的接口<br>25.EC: Call to equals() comparing different types (EC_UNRELATED_TYPES)<br>调用equals方法比较不同类型的类<br>26.EC: Using pointer equality to compare different types (EC_UNRELATED_TYPES_USING_POINTER_EQUALITY)<br>This method uses using pointer equality to compare two references that seem to be of different types. The result of this comparison will always be false at runtime.<br>27.Eq: equals method always returns false (EQ_ALWAYS_FALSE)<br>使用equals方法返回值总是false<br>28.Eq: equals method always returns true (EQ_ALWAYS_TRUE)<br>equals方法返回值总是true<br>29.Eq: equals method compares class names rather than class objects (EQ_COMPARING_CLASS_NAMES)<br>使用equals方法去比较一个类的实例和类的类型<br>30.Eq: Covariant equals() method defined for enum (EQ_DONT_DEFINE_EQUALS_FOR_ENUM)<br>This class defines an enumeration, and equality on enumerations are defined using object identity. Defining a covariant equals method for an enumeration value is exceptionally bad practice, since it would likely result in having two different enumeration values that compare as equals using the covariant enum method, and as not equal when compared normally. Don’t do it.<br>31.Eq: equals() method defined that doesn’t override equals(Object) (EQ_OTHER_NO_OBJECT)<br>类中定义的equals方法时不要覆写equals（Object）方法<br>32.Eq: equals() method defined that doesn’t override Object.equals(Object) (EQ_OTHER_USE_OBJECT)<br>类中定义的equals方法时不要覆写Object中的equals（Object）方法<br>33.Eq: equals method overrides equals in superclass and may not be symmetric (EQ_OVERRIDING_EQUALS_NOT_SYMMETRIC)<br>34.Eq: Covariant equals() method defined, Object.equals(Object) inherited (EQ_SELF_USE_OBJECT)<br>类中定义了一组equals方法，但是都是继承的java.lang.Object class中的equals(Object)方法<br>35.FE: Doomed test for equality to NaN (FE_TEST_IF_EQUAL_TO_NOT_A_NUMBER)<br>This code checks to see if a floating point value is equal to the special Not A Number value (e.g., if (x == Double.NaN)). However, because of the special semantics of NaN, no value is equal to Nan, including NaN. Thus, x == Double.NaN always evaluates to false. To check to see if a value contained in x is the special Not A Number value, use Double.isNaN(x) (or Float.isNaN(x) if x is floating point precision).<br>36.FS: Format string placeholder incompatible with passed argument (VA_FORMAT_STRING_BAD_ARGUMENT)<br>错误使用参数类型来格式化字符串<br>37.FS: The type of a supplied argument doesn’t match format specifier (VA_FORMAT_STRING_BAD_CONVERSION)<br>指定的格式字符串和参数类型不匹配，例如：String.format(“%d”, “1”)<br>38.FS: MessageFormat supplied where printf style format expected (VA_FORMAT_STRING_EXPECTED_MESSAGE_FORMAT_SUPPLIED)<br>但用String的format方法时实际调用了ＭｅｓｓａｇｅＦｏｒｍａｔ中干的格式化方法而引起格式化结果出错。<br>39.FS: More arguments are passed than are actually used in the format string (VA_FORMAT_STRING_EXTRA_ARGUMENTS_PASSED)<br>使用String的format方法时有非法的参数也经过了格式化操作。<br>40.FS: Illegal format string (VA_FORMAT_STRING_ILLEGAL)<br>格式化String对象语句错误<br>41.FS: Format string references missing argument (VA_FORMAT_STRING_MISSING_ARGUMENT)<br>String的format操作缺少必要的参数。<br>42.FS: No previous argument for format string (VA_FORMAT_STRING_NO_PREVIOUS_ARGUMENT)<br>格式字符串定义错误，例如：formatter.format(“%&lt;s %s”, “a”, “b”); 抛出MissingFormatArgumentException异常<br>43.GC: No relationship between generic parameter and method argument (GC_UNRELATED_TYPES)<br>This call to a generic collection method contains an argument with an incompatible class from that of the collection’s parameter (i.e., the type of the argument is neither a supertype nor a subtype of the corresponding generic type argument). Therefore, it is unlikely that the collection contains any objects that are equal to the method argument used here. Most likely, the wrong value is being passed to the method.<br>In general, instances of two unrelated classes are not equal. For example, if the Foo and Bar classes are not related by subtyping, then an instance of Foo should not be equal to an instance of Bar. Among other issues, doing so will likely result in an equals method that is not symmetrical. For example, if you define the Foo class so that a Foo can be equal to a String, your equals method isn’t symmetrical since a String can only be equal to a String.<br>In rare cases, people do define nonsymmetrical equals methods and still manage to make their code work. Although none of the APIs document or guarantee it, it is typically the case that if you check if a Collection<string> contains a Foo, the equals method of argument (e.g., the equals method of the Foo class) used to perform the equality checks.<br>44.HE: Signature declares use of unhashable class in hashed construct (HE_SIGNATURE_DECLARES_HASHING_OF_UNHASHABLE_CLASS)<br>A method, field or class declares a generic signature where a non-hashable class is used in context where a hashable class is required. A class that declares an equals method but inherits a hashCode() method from Object is unhashable, since it doesn’t fulfill the requirement that equal objects have equal hashCodes.<br>45.HE: Use of class without a hashCode() method in a hashed data structure (HE_USE_OF_UNHASHABLE_CLASS)<br>A class defines an equals(Object) method but not a hashCode() method, and thus doesn’t fulfill the requirement that equal objects have equal hashCodes. An instance of this class is used in a hash data structure, making the need to fix this problem of highest importance.<br>46.ICAST: integral value cast to double and then passed to Math.ceil (ICAST_INT_CAST_TO_DOUBLE_PASSED_TO_CEIL)<br>integral的值转换为double后使用了Math.ceil方法<br>47.ICAST: int value cast to float and then passed to Math.round (ICAST_INT_CAST_TO_FLOAT_PASSED_TO_ROUND)<br>int 类型的值转换为float类型之后调用了Math.round方法<br>48.IJU: JUnit assertion in run method will not be noticed by JUnit (IJU_ASSERT_METHOD_INVOKED_FROM_RUN_METHOD)<br>在JUnit中的断言在run方法中不会被告知<br>49.IJU: TestCase declares a bad suite method (IJU_BAD_SUITE_METHOD)<br>在一个JUnit类中声明的一个suite()方法必须声明为<br>public static junit.framework.Test suite()<br>或者<br>public static junit.framework.TestSuite suite()的形式。<br>50.IL: A collection is added to itself (IL_CONTAINER_ADDED_TO_ITSELF)<br>集合本身作为add方法的参数，这样会引起内容溢出。<br>51.IL: An apparent infinite loop (IL_INFINITE_LOOP)<br>方法的自调用引起的死循环<br>52.IM: Integer multiply of result of integer remainder (IM_MULTIPLYING_RESULT_OF_IREM)<br>和整数余数进行乘法运算。例如：i % 60 <em> 1000 是进行(i % 60) </em> 1000运算而不是 i % (60 * 1000)<br>53.INT: Bad comparison of nonnegative value with negative constant (INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE)<br>保证非负数和负数进行比较<br>54.INT: Bad comparison of signed byte (INT_BAD_COMPARISON_WITH_SIGNED_BYTE)<br>比较有符合数，要先把有符号数转换为无符合数再进行比较<br>55.IO: Doomed attempt to append to an object output stream (IO_APPENDING_TO_OBJECT_OUTPUT_STREAM)<br>宣布试图在对象的输出流处添加元素，如果你希望能够添加进一个对象的输出流中必须保证对象的输出流处于打开状态。<br>56.IP: A parameter is dead upon entry to a method but overwritten (IP_PARAMETER_IS_DEAD_BUT_OVERWRITTEN)<br>The initial value of this parameter is ignored, and the parameter is overwritten here. This often indicates a mistaken belief that the write to the parameter will be conveyed back to the caller.<br>传入参数的值被忽略，但是对传入值进行了修改，并返回给了调用者<br>57.MF: Class defines field that masks a superclass field (MF_CLASS_MASKS_FIELD)<br>子类中定义了和父类中同名的字段。在调用时会出错<br>58.MF: Method defines a variable that obscures a field (MF_METHOD_MASKS_FIELD)<br>在方法中定义的局部变量和类变量或者父类变量同名，从而引起字段混淆。<br>59.NP: Null pointer dereference (NP_ALWAYS_NULL)<br>对象赋为null值后 没有被重新赋值<br>60.NP: Null pointer dereference in method on exception path (NP_ALWAYS_NULL_EXCEPTION)<br>A pointer which is null on an exception path is dereferenced here.  This will lead to a NullPointerException when the code is executed.  Note that because FindBugs currently does not prune infeasible exception paths, this may be a false warning.<br>Also note that FindBugs considers the default case of a switch statement to be an exception path, since the default case is often infeasible.<br>空指针引用上调用去除引用方法，将发生空指针异常<br>61.NP: Method does not check for null argument (NP_ARGUMENT_MIGHT_BE_NULL)<br>方法没有判断参数是否为空<br>62.NP: close() invoked on a value that is always null (NP_CLOSING_NULL)<br>一个为空的对象调用close方法<br>63.NP: Null value is guaranteed to be dereferenced (NP_GUARANTEED_DEREF)<br>There is a statement or branch that if executed guarantees that a value is null at this point, and that value that is guaranteed to be dereferenced (except on forward paths involving runtime exceptions).<br>在正常的null判断分支上，对象去除引用操作是受保护的不允许的<br>64.NP: Value is null and guaranteed to be dereferenced on exception path (NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH)<br>There is a statement or branch on an exception path that if executed guarantees that a value is null at this point, and that value that is guaranteed to be dereferenced (except on forward paths involving runtime exceptions).<br>65.NP: Method call passes null to a nonnull parameter (NP_NONNULL_PARAM_VIOLATION)<br>方法中为null的参数没有被重新赋值<br>        void test(){<br>String ss = null;<br>sya(ss);<br>        }<br>        public void sya(String ad){<br>ad.getBytes();<br>        }<br>66.NP: Method may return null, but is declared @NonNull (NP_NONNULL_RETURN_VIOLATION)<br>方法声明了返回值不能为空，但是方法中有可能返回null<br>67.NP: A known null value is checked to see if it is an instance of a type (NP_NULL_INSTANCEOF)<br>检查一个为null的值是否是想要的类型对象，而不是由于粗心或者逻辑错误引起的<br>68.NP: Possible null pointer dereference (NP_NULL_ON_SOME_PATH)<br>对象可能没有重新赋值<br>69.NP: Possible null pointer dereference in method on exception path (NP_NULL_ON_SOME_PATH_EXCEPTION)<br>A reference value which is null on some exception control path is dereferenced here.  This may lead to a NullPointerException when the code is executed.  Note that because FindBugs currently does not prune infeasible exception paths, this may be a false warning.<br>Also note that FindBugs considers the default case of a switch statement to be an exception path, since the default case is often infeasible.<br>在异常null值处理分支调用的方法上，可能存在对象去除引用操作<br>70.NP: Method call passes null for nonnull parameter (NP_NULL_PARAM_DEREF_ALL_TARGETS_DANGEROUS)<br>方法参数中声明为nonnull类型的参数为null<br>void test(){<br>String ss = null;<br>sya(ss);<br>        }<br>        public void sya(@nonnull String ad){<br>ad.getBytes();<br>        }<br>71.NP: Store of null value into field annotated NonNull (NP_STORE_INTO_NONNULL_FIELD)<br>为一个已经声明为不能为null值的属性赋值为null。<br>72.Nm: Class defines equal(Object); should it be equals(Object)? (NM_BAD_EQUAL)<br>类中定义了一个equal方法但是却不是覆写的Object对象的equals方法<br>73.Nm: Class defines hashcode(); should it be hashCode()? (NM_LCASE_HASHCODE)<br>类中定义了一个hashCode方法但是却不是覆写的Object中的hashCode方法<br>74.Nm: Class defines tostring(); should it be toString()? (NM_LCASE_TOSTRING)<br>类中定义了一个toString方法但是却不是覆写的Object中的toString方法<br>75.Nm: Apparent method/constructor confusion (NM_METHOD_CONSTRUCTOR_CONFUSION)<br>构造方法定义混乱，保证一个标准的构造函数。        例如：<br>        SA(){        }<br>        void SA(){<br>        }<br>76.Nm: Very confusing method names (NM_VERY_CONFUSING)<br>混乱的方法命名，如getName和getname方法同时出现的时候<br>77.Nm: Method doesn’t override method in superclass due to wrong package for parameter (NM_WRONG_PACKAGE)<br>方法因为取了不同包中的同名的对象而没有正确覆写父类中的同名方法<br>import alpha.Foo;<br>public class A {<br>  public int f(Foo x) { return 17; }<br>}</string></string></p>\n<p>import beta.Foo;<br>public class B extends A {<br>  public int f(Foo x) { return 42; }<br>}<br>78.QBA: Method assigns boolean literal in boolean expression (QBA_QUESTIONABLE_BOOLEAN_ASSIGNMENT)<br>再if或者while表达式中使用boolean类型的值时应该使用==去判断，而不是采用=操作<br>79.RC: Suspicious reference comparison (RC_REF_COMPARISON)<br>比较两个对象值是否相等时应该采用equals方法，而不是==方法<br>80.RE: Invalid syntax for regular expression (RE_BAD_SYNTAX_FOR_REGULAR_EXPRESSION)<br>对正则表达式使用了错误的语法，会抛出未经检查的异常，表明正则表达式模式中的语法错误。<br>81.RE: File.separator used for regular expression (RE_CANT_USE_FILE_SEPARATOR_AS_REGULAR_EXPRESSION)<br>使用正则表达式使用了错误的文件分隔符，在windows系统中正则表达式不会匹配’\\’而应该使用’\\‘<br>82.RV: Random value from 0 to 1 is coerced to the integer 0 (RV_01_TO_INT)<br>从0到1随机值被强制为整数值0。在强制得到一个整数之前，你可能想得到多个随机值。或使用Random.nextInt（n）的方法。<br>83.RV: Bad attempt to compute absolute value of signed 32-bit hashcode (RV_ABSOLUTE_VALUE_OF_HASHCODE)<br>此代码生成一个哈希码，然后计算该哈希码的绝对值。如果哈希码是Integer.MIN_VALUE的，那么结果将是负数（因为Math.abs（Integer.MIN_VALUE的）== Integer.MIN_VALUE的）。<br>在2^ 32值之外字符串有一个Integer.MIN_VALUE的hashCode包括“polygenelubricants”，“GydZG_”和“，”DESIGNING WORKHOUSES “。<br>84.RV: Bad attempt to compute absolute value of signed 32-bit random integer (RV_ABSOLUTE_VALUE_OF_RANDOM_INT)<br>此代码生成一个随机的符号整数，然后计算该随机整数的绝对值。如果随机数生成数绝对值为Integer.MIN_VALUE的，那么结果将是负数（因为Math.abs（Integer.MIN_VALUE的）== Integer.MIN_VALUE的）。<br>85.RV: Exception created and dropped rather than thrown (RV_EXCEPTION_NOT_THROWN)<br>此代码创建一个异常（或错误）的对象，但不会用它做任何事情。例如：if (x &lt; 0)<br>  new IllegalArgumentException(“x must be nonnegative”);<br>这可能是程序员的意图抛出创建的异常：<br>if (x &lt; 0)<br>  throw new IllegalArgumentException(“x must be nonnegative”);<br>86.RV: Method ignores return value (RV_RETURN_VALUE_IGNORED)<br>该方法的返回值应该进行检查。这种警告通常出现在调用一个不可变对象的方法，认为它更新了对象的值。例如：String dateString = getHeaderField(name);<br>dateString.trim();<br>程序员似乎以为trim（）方法将更新dateString引用的字符串。但由于字符串是不可改变的，trim（）函数返回一个新字符串值，在这里它是被忽略了。该代码应更正：<br>String dateString = getHeaderField(name);<br>dateString = dateString.trim();<br>87.RpC: Repeated conditional tests (RpC_REPEATED_CONDITIONAL_TEST)<br>该代码包含对同一个条件试验了两次，两边完全一样例如：（如X == 0 | | x == 0）。可能第二次出现是打算判断别的不同条件（如X == 0 | | y== 0）。<br>88.SA: Double assignment of field (SA_FIELD_DOUBLE_ASSIGNMENT)<br>方法中的字段包含了双重任务，例如：<br> int x;<br>  public void foo() {<br>   x = x = 17;<br>  }<br>这种为变量赋值是无用的，并可能表明一个逻辑错误或拼写错误。<br>89.SA: Self assignment of field (SA_FIELD_SELF_ASSIGNMENT)<br>方法中包含自己对自己赋值的字段。例如：<br>int x;<br>  public void foo() {<br>    x = x;<br>  }<br>90.SA: Self comparison of field with itself (SA_FIELD_SELF_COMPARISON)<br>字段自己进行自比较可能表明错误或逻辑错误。<br>91.SA: Self comparison of value with itself (SA_LOCAL_SELF_COMPARISON)<br>方法中对一个局部变量自身进行比较运算，并可说明错误或逻辑错误。请确保您是比较正确的事情。<br>92.SA: Nonsensical self computation involving a variable (e.g., x &amp; x) (SA_LOCAL_SELF_COMPUTATION)<br>此方法对同一变量执行了荒谬的计算（如x&amp;x或x-x）操作。由于计算的性质，这一行动似乎没有意义，并可能表明错误或逻辑错误。<br>93.SF: Dead store due to switch statement fall through (SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH)<br>在swtich中先前的case值因为swtich执行失败而被覆写，这就像是忘记使用break推出或者没有使用return语句放回先前的值一样。<br>94.SF: Dead store due to switch statement fall through to throw (SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH_TO_THROW)<br>在swtich中因为出现异常而忽略了对case值的保存。<br>95.SIC: Deadly embrace of non-static inner class and thread local (SIC_THREADLOCAL_DEADLY_EMBRACE)<br>如果是一个静态内部类。实际上，在内部类和当前线程有死锁的可能。由于内部类不是静态的，它保留了对外部类的引用。如果线程包含对一个内部类实例的引用，那么内外实例的实例都可以被获取，这样就不具备垃圾会回收的资格。<br>96.SIO: Unnecessary type check done using instanceof operator (SIO_SUPERFLUOUS_INSTANCEOF)<br>在进行instanceof操作时进行没有必要的类型检查<br>97.STI: Unneeded use of currentThread() call, to call interrupted() (STI_INTERRUPTED_ON_CURRENTTHREAD)<br>此方法调用Thread.currentThread（）调用，只需调用interrupted（）方法。由于interrupted（）是一个静态方法， Thread.interrupted（）更简单易用。<br>98.STI: Static Thread.interrupted() method invoked on thread instance (STI_INTERRUPTED_ON_UNKNOWNTHREAD)<br>调用不是当前线程对象的Thread.interrupted()方法，由于interrupted（）方法是静态的，interrupted方法将会调用一个和作者原计划不同的对象。<br>99.Se: Method must be private in order for serialization to work (SE_METHOD_MUST_BE_PRIVATE)<br>这个类实现了Serializable接口，并定义自定义序列化的方法/反序列化。但由于这种方法不能声明为private，将被序列化/反序列化的API忽略掉。<br>100.Se: The readResolve method must not be declared as a static method. (SE_READ_RESOLVE_IS_STATIC)<br>为使readResolve方法得到序列化机制的识别，不能作为一个静态方法来声明。<br>101.UMAC: Uncallable method defined in anonymous class (UMAC_UNCALLABLE_METHOD_OF_ANONYMOUS_CLASS)<br>在匿名类中定义了一个既没有覆写超类中方法也不能直接调用的方法。因为在其他类的方法不能直接引用匿名类声明的方法，似乎这种方法不能被调用，这种方法可能只是没有任何作用的代码，但也可能覆写超类中声明。<br>102.UR: Uninitialized read of field in constructor (UR_UNINIT_READ)<br>此构造方法中使用了一个尚未赋值的字段或属性。<br>        String a;<br>        public SA() {<br>String abc = a;<br>System.out.println(abc);<br>        }<br>103.UR: Uninitialized read of field method called from constructor of superclass (UR_UNINIT_READ_CALLED_FROM_SUPER_CONSTRUCTOR)<br>方法被超类的构造函数调用时，在当前类中的字段或属性还没有被初始化。例如：<br>abstract class A {<br>  int hashCode;<br>  abstract Object getValue();<br>  A() {<br>    hashCode = getValue().hashCode();<br>    }<br>  }<br>class B extends A {<br>  Object value;<br>  B(Object v) {<br>    this.value = v;<br>    }<br>  Object getValue() {<br>    return value;<br>  }<br>  }<br>当B是创建时，A的构造函数将在B为value赋值之前触发，然而在A的初始化方法调用getValue方法时value这个变量还没有被初始化。<br>104.USELESS_STRING: Invocation of toString on an array (DMI_INVOKING_TOSTRING_ON_ANONYMOUS_ARRAY)<br>该代码调用上匿名数组的toString（）方法，产生的结果形如[@ 16f0472并没有实际的意义。考虑使用Arrays.toString方法来转换成可读的字符串，提供该数组的内容数组。例如：<br>String[] a = { “a” };<br>System.out.println(a.toString());<br>//正确的使用为<br>System.out.println(Arrays.toString(a));<br>105.USELESS_STRING: Invocation of toString on an array (DMI_INVOKING_TOSTRING_ON_ARRAY)<br>该代码调用上数组的toString（）方法，产生的结果形如[@ 16f0472并不能显示数组的真实内容。考虑使用Arrays.toString方法来转换成可读的字符串，提供该数组的内容数组<br>106.UwF: Field only ever set to null (UWF_NULL_FIELD)<br>字段的值总是为null值，所有读取该字段的值都为null。检查错误，如果它确实没有用就删除掉。<br>107.UwF: Unwritten field (UWF_UNWRITTEN_FIELD<br>此字段是永远不会写入值。所有读取将返回默认值。检查错误（如果它被初始化？），如果它确实没有用就删除掉。</p>\n<h3 id=\"五：Performance关于代码性能相关方面的\"><a href=\"#五：Performance关于代码性能相关方面的\" class=\"headerlink\" title=\"五：Performance关于代码性能相关方面的\"></a>五：Performance关于代码性能相关方面的</h3><p>1.Bx: Primitive value is boxed and then immediately unboxed (BX_BOXING_IMMEDIATELY_UNBOXED)<br>对原始值进行装箱，然后立即取消装箱。这可能是在一个未要求装箱的地方进行了手动装箱，从而迫使编译器进行立即撤消装箱的操作<br>2.Bx: Primitive value is boxed then unboxed to perform primitive coercion (BX_BOXING_IMMEDIATELY_UNBOXED_TO_PERFORM_COERCION)<br>对原始值进行装箱然后立即把它强制转换为另外一种原始类型。例如：<br>new Double(d).intValue()应该直接进行强制转换例如：(int) d<br>3.Bx: Method allocates a boxed primitive just to call toString (DM_BOXED_PRIMITIVE_TOSTRING)<br>仅仅为了调用封装类的toString()而对原始类型进行封装操作。比这种方法更有效的是调用封装类的toString(…)方法例如：<br>new Integer(1).toString()    替换为   Integer.toString(1)<br>new Long(1).toString()    替换为   Long.toString(1)<br>new Float(1.0).toString()    替换为   Float.toString(1.0)<br>new Double(1.0).toString()    替换为   Double.toString(1.0)<br>new Byte(1).toString()    替换为   Byte.toString(1)<br>new Short(1).toString()    替换为   Short.toString(1)<br>new Boolean(true).toString()    替换为   Boolean.toString(true)<br>4.Bx: Method invokes inefficient floating-point Number constructor; use static valueOf instead (DM_FP_NUMBER_CTOR)<br>使用new Double(double)方法总是会创建一个新的对象，然而使用Double.valueOf(double)方法可以把值保存在编辑器或者class library、JVM中。使用存储值的方式来避免对象的分配可以或得更好的代码性能<br>除非类必须符合Java 1.5以前的JVM，否则请使用自动装箱或valueOf（）方法创建Double和Float实例。<br>5.Bx: Method invokes inefficient Number constructor; use static valueOf instead (DM_NUMBER_CTOR)<br>使用new Integer(int)方法总是会创建一个新的对象，然而使用Integer.valueOf(int)方法可以把值保存在编辑器或者class library、JVM中。使用存储值的方式来避免对象的分配可以或得更好的代码性能<br>除非类必须符合Java 1.5以前的JVM，否则请使用自动装箱或valueOf（）方法创建Long, Integer, Short, Character, Byte实例。<br>6.Dm: The equals and hashCode methods of URL are blocking (DMI_BLOCKING_METHODS_ON_URL)<br>使用equals和hashCode方法来对url进行资源标识符解析时会引起堵塞。考虑使用java.net.URI来代替。<br>7.Dm: Maps and sets of URLs can be performance hogs (DMI_COLLECTION_OF_URLS)<br>方法或者字段使用url的map/set集合。因为equals方法或者hashCode方法来进行资源标识符解析时都会引起堵塞。考虑使用java.net.URI来代替。<br>8.Dm: Method invokes inefficient Boolean constructor; use Boolean.valueOf(…) instead (DM_BOOLEAN_CTOR)<br>使用new方法创建一个java.lang.Boolean类型能够的实例对象是浪费空间的，因为Boolean对象是不可变的而且只有两个有用的值。使用Boolean.valueOf()或者Java1.5中的自动装箱功能来创建一个Boolean实例。<br>9.Dm: Explicit garbage collection; extremely dubious except in benchmarking code (DM_GC)<br>在代码中显式的调用垃圾回收命名，这样做并不能起作用。在过去，有人在关闭操作或者finalize方法中调用垃圾回收方法导致了很多的性能浪费。这样大规模回收对象时会造成处理器运行缓慢。<br>10.Dm: Use the nextInt method of Random rather than nextDouble to generate a random integer (DM_NEXTINT_VIA_NEXTDOUBLE)<br> 如果r是一个java.util.Random对象，你可以使r.nextInt(n)生成一个0到n-1之前的随机数，而不是使用(int)(r.nextDouble() * n)<br>11.Dm: Method invokes inefficient new String(String) constructor (DM_STRING_CTOR)<br>使用java.lang.String(String)构造函数会浪费内存因为这种构造方式和String作为参数在功能上容易混乱。只是使用String直接作为参数的形式<br>12.Dm: Method invokes toString() method on a String (DM_STRING_TOSTRING)<br>调用String.toString()是多余的操作，只要使用String就可以了。<br>13.Dm: Method invokes inefficient new String() constructor (DM_STRING_VOID_CTOR)<br>使用没有参数的构造方法去创建新的String对象是浪费内存空间的，因为这样创建会和空字符串“”混淆。Java中保证完成相同的构造方法会产生描绘相同的String对象。所以你只要使用空字符串来创建就可以了。<br>14.ITA: Method uses toArray() with zero-length array argument (ITA_INEFFICIENT_TO_ARRAY)<br>当使用集合的toArray()方法时使用数组长度为0的数组作为参数。比这更有效的一种方法是<br>myCollection.toArray(new Foo[myCollection.size()])，如果数组的长度足够大就可以直接把集合中的内容包装到数组中直接返回从而避免了第二次创建一个新的数组来存放集合中值。<br>15.SBSC: Method concatenates strings using + in a loop (SBSC_USE_STRINGBUFFER_CONCATENATION)<br>在循环中构建一个String对象时从性能上讲使用StringBuffer来代替String对象<br>例如：<br>// This is bad<br>  String s = “”;<br>  for (int i = 0; i &lt; field.length; ++i) {<br>    s = s + field[i];<br>  }<br>  // This is better<br>  StringBuffer buf = new StringBuffer();<br>  for (int i = 0; i &lt; field.length; ++i) {<br>    buf.append(field[i]);<br>  }<br>  String s = buf.toString();<br>16.SS: Unread field: should this field be static? (SS_SHOULD_BE_STATIC)<br>类中所包含的final属性字段在编译器中初始化为静态的值。考虑在定义时就把它定义为static类型的。<br>17.UM: Method calls static Math class method on a constant value (UM_UNNECESSARY_MATH)<br>在方法中使用了java.lang.Math的静态方法代替常量来使用，使用常量速度和准确度会更好。 以下为Math中的方法产生的值。<br>Method Parameter<br>abs -any-<br>acos 0.0 or 1.0<br>asin 0.0 or 1.0<br>atan 0.0 or 1.0<br>atan2 0.0 cbrt 0.0 or 1.0<br>ceil -any-<br>cos 0.0<br>cosh 0.0<br>exp 0.0 or 1.0<br>expm1 0.0<br>floor -any-<br>log 0.0 or 1.0<br>log10 0.0 or 1.0<br>rint -any-<br>round -any-<br>sin 0.0<br>sinh 0.0<br>sqrt 0.0 or 1.0<br>tan 0.0<br>tanh 0.0<br>toDegrees 0.0 or 1.0<br>toRadians 0.0<br>18.UPM: Private method is never called (UPM_UNCALLED_PRIVATE_METHOD)<br>定义为Private类型方法从未被调用，应该被删除。<br>19.UrF: Unread field (URF_UNREAD_FIELD)<br>类中定义的属性从未被调用，建议删除。<br>20.UuF: Unused field (UUF_UNUSED_FIELD)<br>类中定义的属性从未被使用，建议删除。<br>21.WMI: Inefficient use of keySet iterator instead of entrySet iterator (WMI_WRONG_MAP_ITERATOR)<br>当方法中接受一个Map类型的参数时，使用keySet的迭代器比使用entrySet的迭代器效率要高。</p>\n<h3 id=\"六：Internationalization关于代码国际化相关方面的\"><a href=\"#六：Internationalization关于代码国际化相关方面的\" class=\"headerlink\" title=\"六：Internationalization关于代码国际化相关方面的\"></a>六：Internationalization关于代码国际化相关方面的</h3><p>Dm: Consider using Locale parameterized version of invoked method (DM_CONVERT_CASE)<br>使用平台默认的编码格式对字符串进行大小写转换，这可能导致国际字符的转换不当。使用以下方式对字符进行转换<br>String.toUpperCase( Locale l )<br>String.toLowerCase( Locale l )</p>\n<h3 id=\"七：Multithreaded-correctness关于代码多线程正确性相关方面的\"><a href=\"#七：Multithreaded-correctness关于代码多线程正确性相关方面的\" class=\"headerlink\" title=\"七：Multithreaded correctness关于代码多线程正确性相关方面的\"></a>七：Multithreaded correctness关于代码多线程正确性相关方面的</h3><p>1.DL: Synchronization on Boolean could lead to deadlock (DL_SYNCHRONIZATION_ON_BOOLEAN)<br>该代码同步一个封装的原始常量，例如一个Boolean类型。<br>private static Boolean inited = Boolean.FALSE;<br>…<br>  synchronized(inited) {<br>    if (!inited) {<br>       init();<br>       inited = Boolean.TRUE;<br>       }<br>     }<br>…<br>由于通常只存在两个布尔对象，此代码可能是同步的其他无关的代码中相同的对象，这时会导致反应迟钝和可能死锁<br>2.DL: Synchronization on boxed primitive could lead to deadlock (DL_SYNCHRONIZATION_ON_BOXED_PRIMITIVE)<br>该代码同步一个封装的原始常量，例如一个Integer类型。<br>private static Integer count = 0;<br>…<br>  synchronized(count) {<br>     count++;<br>     }<br>…<br>由于Integer对象可以共享和保存，此代码可能是同步的其他无关的代码中相同的对象，这时会导致反应迟钝和可能死锁<br>3.DL: Synchronization on interned String could lead to deadlock (DL_SYNCHRONIZATION_ON_SHARED_CONSTANT)<br>同步String类型的常量时，由于它被JVM中多个其他的对象所共有，这样在其他代码中会引起死锁。<br>4.DL: Synchronization on boxed primitive values (DL_SYNCHRONIZATION_ON_UNSHARED_BOXED_PRIMITIVE)<br>同步一个显然不是共有封装的原始值，例如一个Integer类型的对象。例如：<br>private static final Integer fileLock = new Integer(1);<br>…<br>  synchronized(fileLock) {<br>     .. do something ..<br>     }<br>…<br>它最后被定义为以下方式来代替：private static final Object fileLock = new Object();<br>5.Dm: Monitor wait() called on Condition (DM_MONITOR_WAIT_ON_CONDITION)<br>方法中以java.util.concurrent.locks.Condition对象调用wait（）。等待一个条件发生时应该使用在Condition接口中定义的await()方法。<br>6.Dm: A thread was created using the default empty run method (DM_USELESS_THREAD)<br>这个方法没有通过run方法或者具体声明Thread类，也没有通过一个Runnable对象去定义一个线程，而这个线程出来浪费资源却什么也没有去做。<br>7.ESync: Empty synchronized block (ESync_EMPTY_SYNC)<br>该代码包含一个空的同步块：synchronized() {}<br>8.IS: Inconsistent synchronization (IS2_INCONSISTENT_SYNC)<br>不合理的同步<br>9.IS: Field not guarded against concurrent access (IS_FIELD_NOT_GUARDED)<br>域不是良好的同步访问—<br>此字段被标注为net.jcip.annotations.GuardedBy，但可以在某种程度上违反注释而去访问<br>10.JLM: Synchronization performed on Lock (JLM_JSR166_LOCK_MONITORENTER)<br>实现java.util.concurrent.locks.Lock的对象调用了同步的方法。应该这样处理，对象被锁定/解锁时使用acquire（）/ release（）方法而不是使用同步的方法。<br>11.LI: Incorrect lazy initialization of static field (LI_LAZY_INIT_STATIC)<br>静态域不正确的延迟初始化–<br>这种方法包含了一个不同步延迟初始化的非volatile静态字段。因为编译器或处理器可能会重新排列指令，如果该方法可以被多个线程调用，线程不能保证看到一个完全初始化的对象。你可以让字段可变来解决此问题<br>12.LI: Incorrect lazy initialization and update of static field (LI_LAZY_INIT_UPDATE_STATIC)<br>这种方法包含一个不同步延迟初始化的静态字段。之后为字段赋值，对象存储到该位置后进一步更新或访问。字段后尽快让其他线程能够访问。如果该方法的进一步访问该字段为初始化对象提供服务，然后你有一个非常严重的多线程bug，除非别的东西阻止任何其他线程访问存储的对象，直到它完全初始化。<br>即使你有信心，该方法是永远不会被多个线程调用时，在它的值还没有被充分初始化或移动，不把它设定为static字段时它可能会更好。<br>13.ML: Method synchronizes on an updated field (ML_SYNC_ON_UPDATED_FIELD)<br>对象获取一个可变字段时进行同步。这是没有意义的，因为不同的线程可以在不同的对象同步。<br>14.MSF: Mutable servlet field (MSF_MUTABLE_SERVLET_FIELD)<br>一个web服务一般只能创建一个servlet或者jsp的实例（例如：treates是一个单利类），它会被多个线程调用这个实例的方法服务于多个同时的请求。因此使用易变的字段属性产生竞争的情况。<br>15.MWN: Mismatched notify() (MWN_MISMATCHED_NOTIFY)<br>此方法调用Object.notify（）或Object.notifyAll（）而没有获取到该对象的对象锁。调用notify（）或notifyAll（）而没有持有该对象的对象锁，将导致IllegalMonitorStateException异常。<br>16.MWN: Mismatched wait() (MWN_MISMATCHED_WAIT)<br>此方法调用Object.wait()而没有获取到该对象的对象锁。调用wait（）而没有持有该对象的对象锁，将导致IllegalMonitorStateException异常。<br>17.NP: Synchronize and null check on the same field. (NP_SYNC_AND_NULL_CHECK_FIELD)<br>如果代码块是同步的，那么久不可能为空。如果是空，同步时就会抛出NullPointerException异常。最好是在另一个代码块中进行同步。<br>18.No: Using notify() rather than notifyAll() (NO_NOTIFY_NOT_NOTIFYALL)<br>调用notify（）而不是notifyAll（）方法。 Java的监控器通常用于多个条件。调用notify（）只唤醒一个线程，这意味着该线程被唤醒只是满足的当前的唯一条件。<br>19.RS: Class’s readObject() method is synchronized (RS_READOBJECT_SYNC)<br>序列化类中定义了同步的readObject（）。通过定义，反序列化创建的对象只有一个线程可以访问，因此没有必要的readObject（）进行同步。如果的readObject（）方法本身造成对象对另一个线程可见，那么这本身就是不好的编码方式。<br>20.Ru: Invokes run on a thread (did you mean to start it instead?) (RU_INVOKE_RUN)<br>这种方法显式调用一个对象的run（）。一般来说，类是实现Runnable接口的，因为在一个新的线程他们将有自己的run（）方法，在这种情况下Thread.start（）方法调用是正确的。<br>21.SC: Constructor invokes Thread.start() (SC_START_IN_CTOR)<br>在构造函数中启动一个线程。如果类曾经被子类扩展过，那么这很可能是错的，因为线程将在子类构造之前开始启动。<br>22.SP: Method spins on field (SP_SPIN_ON_FIELD)<br>方法无限循环读取一个字段。编译器可合法悬挂宣读循环，变成一个无限循环的代码。这个类应该改变，所以使用适当的同步（包括等待和通知要求）<br>23.STCAL: Call to static Calendar (STCAL_INVOKE_ON_STATIC_CALENDAR_INSTANCE)<br>即使JavaDoc对此不包含暗示，而Calendars本身在多线程中使用就是不安全的。探测器发现当调用Calendars的实例时将会获得一个静态对象。<br>Calendar rightNow = Calendar.getInstance();<br>24.STCAL: Call to static DateFormat (STCAL_INVOKE_ON_STATIC_DATE_FORMAT_INSTANCE)<br>在官方的JavaDoc，DateFormats多线程使用本事就是不安全的。探测器发现调用一个DateFormat的实例将会获得一个静态对象。<br>myString = DateFormat.getDateInstance().format(myDate);<br>25.STCAL: Static Calendar (STCAL_STATIC_CALENDAR_INSTANCE)<br>Calendar在多线程中本身就是不安全的，如果在线程范围中共享一个Calendarde 实例而不使用一个同步的方法在应用中就会出现一些奇怪的行为。在sun.util.calendar.BaseCalendar.getCalendarDateFromFixedDate()中会抛出ArrayIndexOutOfBoundsExceptions or IndexOutOfBoundsExceptions异常。<br>26.STCAL: Static DateFormat (STCAL_STATIC_SIMPLE_DATE_FORMAT_INSTANCE)<br>DateFormat 在多线程中本身就是不安全的，如果在线程范围中共享一个DateFormat的实例而不使用一个同步的方法在应用中就会出现一些奇怪的行为。<br>27.SWL: Method calls Thread.sleep() with a lock held (SWL_SLEEP_WITH_LOCK_HELD)<br>当持有对象时调用Thread.sleep（）。这可能会导致很差的性能和可扩展性，或陷入死锁，因为其他线程可能正在等待获得锁。调用wait（）是一个更好的主意，释放对象的持有以允许其他线程运行。<br>28.UG: Unsynchronized get method, synchronized set method (UG_SYNC_SET_UNSYNC_GET)<br>这个类包含类似命名的get和set方法。在set方法是同步方法和get方法是非同步方法。这可能会导致在运行时的不正确行为，因为调用的get方法不一定返回对象一致状态。 GET方法应该同步。<br>29.UL: Method does not release lock on all paths (UL_UNRELEASED_LOCK)<br>方法获得了当前的对象所，但是在方法中始终没有释放它。一个正确的示例如下：<br>  Lock l = …;<br>    l.lock();<br>    try {<br>        // do something<br>    } finally {<br>        l.unlock();<br>    }<br>30.UL: Method does not release lock on all exception paths (UL_UNRELEASED_LOCK_EXCEPTION_PATH)<br>方法获得了当前的对象所，但是在所有的异常处理中始终没有释放它。一个正确的示例如下：<br>  Lock l = …;<br>    l.lock();<br>    try {<br>        // do something<br>    } finally {<br>        l.unlock();<br>    }<br>31.UW: Unconditional wait (UW_UNCOND_WAIT)<br>方法中包含调用java.lang.Object.wait（），而却没有放到条件流程控制中。该代码应确认条件尚未满足之前等待;先前任何通知将被忽略。<br>32.VO: A volatile reference to an array doesn’t treat the array elements as volatile (VO_VOLATILE_REFERENCE_TO_ARRAY)<br>声明一个变量引用数组，这可能不是你想要的。如果一个变量引用数组，那么对引用数组的读和写都是不安全的，但是数组元素不是变量。取得数组的变量值你可以使用java.util.concurrent包中的数组的原子性特性<br>33.WL: Sychronization on getClass rather than class literal (WL_USING_GETCLASS_RATHER_THAN_CLASS_LITERAL)<br>实例的方法中同步this.getClass()，如果这个类有子类集合，那么子类集合中的对象将会在这个类的各个子类上进行同步，这不是我们想要的效果，我们只要同步当前的类对象而不包含它的所有子类，可以同步类名.getClass()。例如，java.awt.Label的代码：<br>     private static final String base = “label”;<br>     private static int nameCounter = 0;<br>     String constructComponentName() {<br>        synchronized (getClass()) {<br>            return base + nameCounter++;<br>        }<br>     }<br>Label中的子类集合不可能在同一个子对象上进行同步，替换上面的方法为：<br>    private static final String base = “label”;<br>     private static int nameCounter = 0;<br>     String constructComponentName() {<br>        synchronized (Label.class) {<br>            return base + nameCounter++;<br>        }<br>     }<br>34.WS: Class’s writeObject() method is synchronized but nothing else is (WS_WRITEOBJECT_SYNC)<br>这个类有一个writeObject（）方法是同步的，但是这个类中没有其他的同步方法。<br>35.Wa: Condition.await() not in loop (WA_AWAIT_NOT_IN_LOOP)<br>方法没有在循环中调用java.util.concurrent.await()。如果对象是用于多种条件，打算调用wait()方法的条件可能不是实际发生的。<br>36.Wa: Wait not in loop (WA_NOT_IN_LOOP)<br>这种方法包含调用java.lang.Object.wait（），而这并不是一个循环。如果监视器用于多个条件，打算调用wait()方法的条件可能不是实际发生的。</p>\n<h3 id=\"八：Malicious-codevulnerability关于恶意破坏代码相关方面的\"><a href=\"#八：Malicious-codevulnerability关于恶意破坏代码相关方面的\" class=\"headerlink\" title=\"八：Malicious codevulnerability关于恶意破坏代码相关方面的\"></a>八：Malicious codevulnerability关于恶意破坏代码相关方面的</h3><p>1.EI: May expose internal representation by returning reference to mutable object (EI_EXPOSE_REP)<br>返回一个易变对象引用并把它保存在对象字段中时会暴露对象内部的字段描述，如果接受不守信任的代码访问或者没有检查就去改变易变对象的会涉及对象的安全和其他重要属性的安全。返回一个对象的新副本，在很多情况下更好的办法。<br>2.EI2: May expose internal representation by incorporating reference to mutable object (EI_EXPOSE_REP2)<br>此代码把外部可变对象引用存储到对象的内部表示。如果实例受到不信任的代码的访问和没有检查的变化危及对象和重要属性的安全。存储一个对象的副本，在很多情况下是更好的办法。<br>3.FI: Finalizer should be protected, not public (FI_PUBLIC_SHOULD_BE_PROTECTED)<br>一个类中的finalize（）方法必须声明为protected，而不能为public类型<br>4.MS: Public static method may expose internal representation by returning array (MS_EXPOSE_REP)<br>一个public类型的静态方法返回一个数组，可能引用内部属性的暴露。任何代码调用此方法都可以自由修改底层数组。一个解决办法是返回一个数组的副本。<br>5.MS: Field should be both final and package protected (MS_FINAL_PKGPROTECT)<br>一个静态字段可能被恶意代码或另外一个包所改变的。字段可以放到protected包中也可以定义为final类型的以避免此问题。<br>6.MS: Field is a mutable array (MS_MUTABLE_ARRAY)<br>一个定义为final类型的静态字段引用一个数组时它可以被恶意代码或在另其他包中所使用。这些代码可以自由修改数组的内容。<br>7.MS: Field is a mutable Hashtable (MS_MUTABLE_HASHTABLE)<br>一个定义为final类型的静态字段引用一个Hashtable时可以被恶意代码或者在其他包中被调用，这些方法可以修改Hashtable的值。<br>8.MS: Field should be moved out of an interface and made package protected (MS_OOI_PKGPROTECT)<br>将域尽量不要定义在接口中，并声明为包保护<br>在接口中定义了一个final类型的静态字段，如数组或哈希表等易变对象。这些对象可以被恶意代码或者在其他包中被调用，为了解决这个问题，需要把它定义到一个具体的实体类中并且声明为保护类型以避免这种错误。<br>9.MS: Field should be package protected (MS_PKGPROTECT)<br>一个静态字段是可以改变的恶意代码或其他的包访问修改。可以把这种类型的字段声明为final类型的以防止这种错误。</p>\n<h3 id=\"十：Dodgy关于代码运行期安全方面的\"><a href=\"#十：Dodgy关于代码运行期安全方面的\" class=\"headerlink\" title=\"十：Dodgy关于代码运行期安全方面的\"></a>十：Dodgy关于代码运行期安全方面的</h3><p>1.XSS: Servlet reflected cross site scripting vulnerability (XSS_REQUEST_PARAMETER_TO_SEND_ERROR)<br>在代码中在Servlet输出中直接写入一个HTTP参数，这会造成一个跨站点的脚本漏洞。<br>2.XSS: Servlet reflected cross site scripting vulnerability (XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER)<br>代码直接写入参数的HTTP服务器错误页（使用HttpServletResponse.sendError）。表达了类似的不受信任的输入会引起跨站点脚本漏洞。<br>3.BC: Questionable cast to abstract collection (BC_BAD_CAST_TO_ABSTRACT_COLLECTION)<br>在代码投把一个集合强制类型转换为一个抽象的集合（如list，set或map）。保证该对象类型和将要转换的类型是一致的。如果你只是想要便利一个集合，那么你就不必将它转换为Set或List。<br>4.BC: Questionable cast to concrete collection (BC_BAD_CAST_TO_CONCRETE_COLLECTION)<br>代码把抽象的集合（如List，Set，或Collection）强制转换为具体落实类型（如一个ArrayList或HashSet）。这可能不正确，也可能使您的代码很脆弱，因为它使得难以在今后的切换指向其他具体实现。除非你有特别理由这样做，否则只需要使用抽象的集合类。<br>5.BC: Unchecked/unconfirmed cast (BC_UNCONFIRMED_CAST)<br>强制类型转换操作没有经过验证，而且不是所有的此种类型装换过的类都可以再强制类型转换为原类型。在代码中需要进行逻辑判断以保证可以进行这样的操作。<br>6.BC: instanceof will always return true (BC_VACUOUS_INSTANCEOF)<br>instanceof测试将始终返回真（除非被测试的值为空）。虽然这是安全，确保它是不是说明一些误解或其他一些逻辑错误。如果你真的想测试是空的价值，也许会更清楚这样做的更好空试验，而不是一个instanceof测试。<br>7.BSHIFT: Unsigned right shift cast to short/byte (ICAST_QUESTIONABLE_UNSIGNED_RIGHT_SHIFT)<br>无符号数右移后进行转换为short或者byte类型时可能会丢弃掉高位的值，这样的结果就是有符合数和无符号数无法区分（这取决于移位大小）<br>8.CI: Class is final but declares protected field (CI_CONFUSED_INHERITANCE)<br>这个类被声明为final的，而是字段属性却声明为保护类型的。由于是final类，它不能再被继承，而再声明为保护类型的很容易造成混淆。为了从外部能正确的使用它应该把它们声明为private或者public类型。<br>9.DB: Method uses the same code for two branches (DB_DUPLICATE_BRANCHES)<br>此方法使用相同的代码，以实现两个有条件的分支。检查以确保这是不是一个编码错误。<br>10.DB: Method uses the same code for two switch clauses (DB_DUPLICATE_SWITCH_CLAUSES)<br>他的方法使用相同的代码来实现两个switch的声明条款。这可能是重复代码的情况，但可能也显示出编码的错误。<br>11.DLS: Dead store to local variable (DLS_DEAD_LOCAL_STORE)<br>该指令为局部变量赋值，但在其后的没有对她做任何使用。通常，这表明一个错误，因为值从未使用过。<br>12.DLS: Useless assignment in return statement (DLS_DEAD_LOCAL_STORE_IN_RETURN)<br>本声明把一个局部变量放到方法的返回语句中。这对于方法中局部变量来说是没有意思的。<br>13.DLS: Dead store of null to local variable (DLS_DEAD_LOCAL_STORE_OF_NULL)<br>把一个本地变量赋值为null值，并且再也没有对这个变量做任何的操作。这样可能是为了垃圾回收，而是Java SE 6.0，这已不再需要。<br>14.DMI: Code contains a hard coded reference to an absolute pathname (DMI_HARDCODED_ABSOLUTE_FILENAME)<br>此代码包含文件对象为一个绝对路径名（例如，新的文件（“/ home/dannyc/workspace/j2ee/src/share/com/sun/enterprise/deployment”）;<br>15.DMI: Non serializable object written to ObjectOutput (DMI_NONSERIALIZABLE_OBJECT_WRITTEN)<br>代码中让一个非序列化的对象出现在ObjectOutput.writeObject()方法中，这样会引起一个错误。<br>16.DMI: Invocation of substring(0), which returns the original value (DMI_USELESS_SUBSTRING)<br>此代码调用了subString(0)方法，它将返回原来的值。<br>17.Eq: Class doesn’t override equals in superclass (EQ_DOESNT_OVERRIDE_EQUALS)<br>子类定义了一个新的equals方法但是却不是覆写了父类本省的equals()方法。<br>18.FE: Test for floating point equality (FE_FLOATING_POINT_EQUALITY)<br>此操作比较两个浮点值是否相等。由于浮点运算可能会涉及到舍入，计算float和double值可能不准确。如果要求值必须准确，如货币值，可以考虑使用固定精度类型，如BigDecimal类型的值来比较<br>19.FS: Non-Boolean argument formatted using %b format specifier (VA_FORMAT_STRING_BAD_CONVERSION_TO_BOOLEAN)<br>使用%b去格式化Boolean类型的值不正确的但是它不会抛出异常，任何非空的值都会输出true，任何为空的值都会输出false<br>20.IC: Initialization circularity (IC_INIT_CIRCULARITY)<br>在引用两个相互调用为环状static方法去初始化一个实例时是错误的。<br>21.ICAST: integral division result cast to double or float (ICAST_IDIV_CAST_TO_DOUBLE)<br>整形数除法强制转换为double或者float类型。<br>int x = 2;<br>int y = 5;<br>// Wrong: yields result 0.0<br>double value1 =  x / y;<br>// Right: yields result 0.4<br>double value2 =  x / (double) y;<br>22.ICAST: Result of integer multiplication cast to long (ICAST_INTEGER_MULTIPLY_CAST_TO_LONG)<br>整形数做乘法运算结果转换为long值时如果采用<br>long convertDaysToMilliseconds(int days) { return 1000<em>3600</em>24<em>days; } 结果会因为超出整形的范围而出错。<br>如果使用：<br>long convertDaysToMilliseconds(int days) { return 1000L</em>3600<em>24</em>days; }<br>或者：<br>static final long MILLISECONDS_PER_DAY = 24L<em>3600</em>1000;<br>        long convertDaysToMilliseconds(int days) { return days * MILLISECONDS_PER_DAY; }<br>都可以避免此问题。<br>23.IM: Computation of average could overflow (IM_AVERAGE_COMPUTATION_COULD_OVERFLOW)<br>代码中使用x % 2 == 1的方法去验证运算是否存在余数的情况，但是如果出现负数的情况就不起作用了。使用x &amp; 1 == 1, or x % 2 != 0来代替<br>24.INT: Vacuous comparison of integer value (INT_VACUOUS_COMPARISON)<br>整形数进行比较结果总是不变。例如：x &lt;= Integer.MAX_VALUE<br>25.MTIA: Class extends Servlet class and uses instance variables (MTIA_SUSPECT_SERVLET_INSTANCE_FIELD)<br>这个类扩展从Servlet类，并使用实例的成员变量。由于只有一个Servlet类的实例，并在多线程方式使用，这种模式有可能存在问题。考虑只使用方法的局部变量。<br>26.MTIA: Class extends Struts Action class and uses instance variables (MTIA_SUSPECT_STRUTS_INSTANCE_FIELD)<br>类扩展自Struts的Action类并使用这个实例的成员变量，因为在Struts框架中只存在一个Action实例对象并且使用在多线程的情况下很可能会出现问题。<br>27.NP: Dereference of the result of readLine() without nullcheck (NP_DEREFERENCE_OF_READLINE_VALUE)<br>对readLine()的结果值没有进行判空操作就去重新赋值，这样的操作可以会抛出空指针异常。<br>28.NP: Immediate dereference of the result of readLine() (NP_IMMEDIATE_DEREFERENCE_OF_READLINE)<br>对readLine()的结果立即赋值，这样的操作可以会抛出空指针异常。<br>29.NP: Possible null pointer dereference due to return value of called method (NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE)<br>方法的返回值没有进行是否为空的检查就重新赋值，这样可能会出现空指针异常。<br>30.NP: Parameter must be nonnull but is marked as nullable (NP_PARAMETER_MUST_BE_NONNULL_BUT_MARKED_AS_NULLABLE)<br>参数值在任何情况下都不能为空，但是有明确的注释它可以为空。<br>31.NS: Potentially dangerous use of non-short-circuit logic (NS_DANGEROUS_NON_SHORT_CIRCUIT)<br>代码中使用（&amp; or |）代替（&amp;&amp; or ||）操作，这会造成潜在的危险。<br>32.NS: Questionable use of non-short-circuit logic (NS_NON_SHORT_CIRCUIT)<br>代码中使用（&amp; or |）代替（&amp;&amp; or ||）操作，会引起不安全的操作<br>33.PZLA: Consider returning a zero length array rather than null (PZLA_PREFER_ZERO_LENGTH_ARRAYS)<br>考虑返回一个零长度的数组，而不是null值<br>34.QF: Complicated, subtle or wrong increment in for-loop (QF_QUESTIONABLE_FOR_LOOP)<br>确定这个循环是正确的变量递增，看起来，另一个变量被初始化，检查的循环。这是由于for循环中太复杂的定义造成的。<br>35.RCN: Redundant comparison of non-null value to null (RCN_REDUNDANT_COMPARISON_OF_NULL_AND_NONNULL_VALUE)<br>方法中包含一个不能为空的赋值还包含一个可以为空的赋值。冗余比较非空值为空。<br>36.RCN: Redundant comparison of two null values (RCN_REDUNDANT_COMPARISON_TWO_NULL_VALUES)<br>方法中对两个null值进行比较<br>37.RCN: Redundant nullcheck of value known to be non-null (RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE)<br>方法中对不为空的值进行为空的判断。<br>38.REC: Exception is caught when Exception is not thrown (REC_CATCH_EXCEPTION)<br>在try/catch块中捕获异常，但是异常没有在try语句中抛出而RuntimeException又没有明确的被捕获<br>39.RI: Class implements same interface as superclass (RI_REDUNDANT_INTERFACES)<br>子类和父类都实现了同一个接口，这种定义是多余的。<br>40.RV: Method discards result of readLine after checking if it is nonnull (RV_DONT_JUST_NULL_CHECK_READLINE)<br>readLine方法的结果不为空时被抛弃<br>41.RV: Remainder of 32-bit signed random integer (RV_REM_OF_RANDOM_INT)<br>此代码生成一个随机的符号整数，然后计算另一个值的。由于随机数可以是负数，所以其余操作的结果也可以是负面的。考虑使用Random.nextInt（int）方法代替。<br>42.SA: Double assignment of local variable (SA_LOCAL_DOUBLE_ASSIGNMENT)<br>为一个局部变量两次赋值，这样是没有意义的。例如：<br>public void foo() {<br>    int x,y;<br>    x = x = 17;<br>  }<br>43.SA: Self assignment of local variable (SA_LOCAL_SELF_ASSIGNMENT)<br>局部变量使用自身给自己赋值<br>public void foo() {<br>    int x = 3;<br>    x = x;<br>  }<br>44.SF: Switch statement found where one case falls through to the next case (SF_SWITCH_FALLTHROUGH)<br>Switch语句中一个分支执行后又执行了下一个分支。通常case后面要跟break 或者return语句来跳出。<br>45.SF: Switch statement found where default case is missing (SF_SWITCH_NO_DEFAULT)<br>Switch没有默认情况下执行的case语句。<br>46.Se: private readResolve method not inherited by subclasses (SE_PRIVATE_READ_RESOLVE_NOT_INHERITED)<br>声明为private的序列化方法被子类继承<br>47.UCF: Useless control flow (UCF_USELESS_CONTROL_FLOW)<br>没有任何作用的条件语句。<br>if (argv.length == 0) {<br>        // TODO: handle this case<br>        }<br>48.UCF: Useless control flow to next line (UCF_USELESS_CONTROL_FLOW_NEXT_LINE)<br>无效的条件控制语句，注意if (argv.length == 1);以“;”结尾，下面的语句无论是否满足都会运行。<br>if (argv.length == 1);<br>        System.out.println(“Hello, “ + argv[0]);<br>49.UwF: Field not initialized in constructor (UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR)<br>字段从来没有在任何构造函数初始化，对象被创建后值为空。如果该字段未被定义就重新赋值会产生一个空指针异常。<br>50.XFB: Method directly allocates a specific implementation of xml interfaces (XFB_XML_FACTORY_BYPASS)<br>方法自定义了一种XML接口的实现类。最好是使用官方提供的工厂类来创建这些对象，以便可以在运行期中改变。例如：<br>javax.xml.parsers.DocumentBuilderFactory<br>javax.xml.parsers.SAXParserFactory<br>javax.xml.transform.TransformerFactory<br>org.w3c.dom.Document.createXXXX</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"FindBugs使用实践-缺陷和修改\"><a href=\"#FindBugs使用实践-缺陷和修改\" class=\"headerlink\" title=\"FindBugs使用实践-缺陷和修改\"></a>FindBugs使用实践-缺陷和修改</h1><p>Confidence 是fingbug团队认为该代码导致bug的可能性。</p>\n<h2 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h2><p>1 Malicious code vulnerability 恶意代码<br>2 Performance 性能问题<br>3 Security 安全性问题<br>4 Dodgy code 小问题<br>5 Correctness 代码的正确性<br>6 Bad practice 不好的习惯<br>7 Internationalization 国际化问题<br>8 Experrimental 实验性问题<br>无     Multithreaded currectness 线程问题</p>\n<h2 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h2><h4 id=\"1-Bad-practice-坏的实践\"><a href=\"#1-Bad-practice-坏的实践\" class=\"headerlink\" title=\"1 Bad practice 坏的实践\"></a>1 Bad practice 坏的实践</h4><p>一些不好的实践，下面列举几个： HE：类定义了equals()，却没有hashCode()；或类定义了equals()，却使用Object.hashCode()；或类定义了hashCode()，却没有equals()；或类定义了hashCode()，却使用Object.equals()；类继承了equals()，却使用Object.hashCode()。<br>SQL：Statement 的execute方法调用了非常量的字符串；或Prepared Statement是由一个非常量的字符串产生。<br>DE：方法终止或不处理异常，一般情况下，异常应该被处理或报告，或被方法抛出。<br>Malicious code vulnerability 可能受到的恶意攻击<br>如果代码公开，可能受到恶意攻击的代码，下面列举几个： FI：一个类的finalize()应该是protected，而不是public的。MS：属性是可变的数组；属性是可变的Hashtable；属性应该是package protected的。</p>\n<h4 id=\"2-Correctness-一般的正确性问题\"><a href=\"#2-Correctness-一般的正确性问题\" class=\"headerlink\" title=\"2 Correctness 一般的正确性问题\"></a>2 Correctness 一般的正确性问题</h4><p>可能导致错误的代码，下面列举几个： NP：空指针被引用；在方法的异常路径里，空指针被引用；方法没有检查参数是否null；null值产生并被引用；null值产生并在方法的异常路径被引用；传给方法一个声明为@NonNull的null参数；方法的返回值声明为@NonNull实际是null。 Nm：类定义了hashcode()方法，但实际上并未覆盖父类Object的hashCode()；类定义了tostring()方法，但实际上并未覆盖父类Object的toString()；很明显的方法和构造器混淆；方法名容易混淆。 SQL：方法尝试访问一个Prepared Statement的0索引；方法尝试访问一个ResultSet的0索引。 UwF：所有的write都把属性置成null，这样所有的读取都是null，这样这个属性是否有必要存在；或属性从没有被write。</p>\n<h4 id=\"3-Dodgy-危险的\"><a href=\"#3-Dodgy-危险的\" class=\"headerlink\" title=\"3 Dodgy 危险的\"></a>3 Dodgy 危险的</h4><p>具有潜在危险的代码，可能运行期产生错误，下面列举几个： CI：类声明为final但声明了protected的属性。 DLS：对一个本地变量赋值，但却没有读取该本地变量；本地变量赋值成null，却没有读取该本地变量。 ICAST：整型数字相乘结果转化为长整型数字，应该将整型先转化为长整型数字再相乘。 INT：没必要的整型数字比较，如X &lt;= Integer.MAX_VALUE。 NP：对readline()的直接引用，而没有判断是否null；对方法调用的直接引用，而方法可能返回null。 REC：直接捕获Exception，而实际上可能是RuntimeException。 ST：从实例方法里直接修改类变量，即static属性。</p>\n<h4 id=\"4-Performance-性能问题\"><a href=\"#4-Performance-性能问题\" class=\"headerlink\" title=\"4 Performance 性能问题\"></a>4 Performance 性能问题</h4><p>可能导致性能不佳的代码，下面列举几个： DM：方法调用了低效的Boolean的构造器，而应该用Boolean.valueOf(…)；用类似Integer.toString(1) 代替new Integer(1).toString()；方法调用了低效的float的构造器，应该用静态的valueOf方法。 SIC：如果一个内部类想在更广泛的地方被引用，它应该声明为static。 SS：如果一个实例属性不被读取，考虑声明为static。 UrF：如果一个属性从没有被read，考虑从类中去掉。 UuF：如果一个属性从没有被使用，考虑从类中去掉。</p>\n<h4 id=\"5-Multithreaded-correctness-多线程的正确性多线程编程时，可能导致错误的代码，下面列举几个：\"><a href=\"#5-Multithreaded-correctness-多线程的正确性多线程编程时，可能导致错误的代码，下面列举几个：\" class=\"headerlink\" title=\"5 Multithreaded correctness 多线程的正确性多线程编程时，可能导致错误的代码，下面列举几个：\"></a>5 Multithreaded correctness 多线程的正确性多线程编程时，可能导致错误的代码，下面列举几个：</h4><p>ESync：空的同步块，很难被正确使用。 MWN：错误使用notify()，可能导致IllegalMonitorStateException异常；或错误的使用wait()。 No：使用notify()而不是notifyAll()，只是唤醒一个线程而不是所有等待的线程。 SC：构造器调用了Thread.start()，当该类被继承可能会导致错误。</p>\n<h4 id=\"6-Internationalization-国际化当对字符串使用upper或lowercase方法，如果是国际的字符串，可能会不恰当的转换。\"><a href=\"#6-Internationalization-国际化当对字符串使用upper或lowercase方法，如果是国际的字符串，可能会不恰当的转换。\" class=\"headerlink\" title=\"6 Internationalization 国际化当对字符串使用upper或lowercase方法，如果是国际的字符串，可能会不恰当的转换。\"></a>6 Internationalization 国际化当对字符串使用upper或lowercase方法，如果是国际的字符串，可能会不恰当的转换。</h4><p>API： <a href=\"http://findbugs.sourceforge.net/api/index.html\" target=\"_blank\" rel=\"noopener\">http://findbugs.sourceforge.net/api/index.html</a><br>技术手册： <a href=\"http://findbugs.sourceforge.net/manual/index.html\" target=\"_blank\" rel=\"noopener\">http://findbugs.sourceforge.net/manual/index.html</a><br>更多请参见官网： <a href=\"http://findbugs.sourceforge.net/bugDescriptions.html\" target=\"_blank\" rel=\"noopener\">http://findbugs.sourceforge.net/bugDescriptions.html</a></p>\n<h5 id=\"6-1、-ES-COMPARING-PARAMETER-STRING-WITH-EQ\"><a href=\"#6-1、-ES-COMPARING-PARAMETER-STRING-WITH-EQ\" class=\"headerlink\" title=\"6.1、       ES_COMPARING_PARAMETER_STRING_WITH_EQ\"></a>6.1、       ES_COMPARING_PARAMETER_STRING_WITH_EQ</h5><pre><code>ES: Comparison of String parameter using == or != (ES_COMPARING_PARAMETER_STRING_WITH_EQ)\n</code></pre><p>This code compares a java.lang.String parameter for reference equality using the == or != operators. Requiring callers to pass only String constants or interned strings to a method is unnecessarily fragile, and rarely leads to measurable performance gains. Consider using the equals(Object) method instead.<br>     使用 == 或者 != 来比较字符串或interned字符串，不会获得显著的性能提升，同时并不可靠，请考虑使用equals()方法。</p>\n<h5 id=\"6-2、-HE-EQUALS-NO-HASHCODE\"><a href=\"#6-2、-HE-EQUALS-NO-HASHCODE\" class=\"headerlink\" title=\"6.2、       HE_EQUALS_NO_HASHCODE\"></a>6.2、       HE_EQUALS_NO_HASHCODE</h5><pre><code>HE: Class defines equals() but not hashCode() (HE_EQUALS_NO_HASHCODE)\n</code></pre><p>This class overrides equals(Object), but does not override hashCode().  Therefore, the class may violate the invariant that equal objects must have equal hashcodes.<br>     类定义了equals()方法但没有重写hashCode()方法，这样违背了相同对象必须具有相同的hashcodes的原则</p>\n<h5 id=\"6-3、IT-NO-SUCH-ELEMENT\"><a href=\"#6-3、IT-NO-SUCH-ELEMENT\" class=\"headerlink\" title=\"6.3、IT_NO_SUCH_ELEMENT\"></a>6.3、IT_NO_SUCH_ELEMENT</h5><pre><code>It: Iterator next() method can&apos;t throw NoSuchElement exception (IT_NO_SUCH_ELEMENT)\n</code></pre><p>This class implements the java.util.Iterator interface.  However, its next() method is not capable of throwing java.util.NoSuchElementException.  The next() method should be changed so it throws NoSuchElementException if is called when there are no more elements to return.<br>     迭代器Iterator无法抛出NoSuchElement异常，类实现了java.util.Iterator接口，但是next()方法无法抛出java.util.NoSuchElementException异常，因此，next()方法应该做如此修改，当被调用时，如果没有element返回，则抛出NoSuchElementException异常</p>\n<h5 id=\"6-4、J2EE-STORE-OF-NON-SERIALIZABLE-OBJECT-INTO-SESSION\"><a href=\"#6-4、J2EE-STORE-OF-NON-SERIALIZABLE-OBJECT-INTO-SESSION\" class=\"headerlink\" title=\"6.4、J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION\"></a>6.4、J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION</h5><pre><code>J2EE: Store of non serializable object into HttpSession (J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION)\n</code></pre><p>This code seems to be storing a non-serializable object into an HttpSession. If this session is passivated or migrated, an error will result.<br>     将没有实现serializable的对象放到HttpSession中，当这个session被钝化和迁移时，将会产生错误，建议放到HttpSession中的对象都实现serializable接口。</p>\n<h5 id=\"6-5、ODR-OPEN-DATABASE-RESOURCE\"><a href=\"#6-5、ODR-OPEN-DATABASE-RESOURCE\" class=\"headerlink\" title=\"6.5、ODR_OPEN_DATABASE_RESOURCE\"></a>6.5、ODR_OPEN_DATABASE_RESOURCE</h5><pre><code>ODR: Method may fail to close database resource (ODR_OPEN_DATABASE_RESOURCE)\n</code></pre><p>The method creates a database resource (such as a database connection or row set), does not assign it to any fields, pass it to other methods, or return it, and does not appear to close the object on all paths out of the method.  Failure to close database resources on all paths out of a method may result in poor performance, and could cause the application to have problems communicating with the database.<br>     方法可能未关闭数据库资源，未关闭数据库资源将会导致性能变差，还可能引起应用与服务器间的通讯问题。</p>\n<h5 id=\"6-6、OS-OPEN-STREAM\"><a href=\"#6-6、OS-OPEN-STREAM\" class=\"headerlink\" title=\"6.6、OS_OPEN_STREAM\"></a>6.6、OS_OPEN_STREAM</h5><pre><code>OS: Method may fail to close stream (OS_OPEN_STREAM)\n</code></pre><p>The method creates an IO stream object, does not assign it to any fields, pass it to other methods that might close it, or return it, and does not appear to close the stream on all paths out of the method.  This may result in a file descriptor leak.  It is generally a good idea to use a finally block to ensure that streams are closed.<br>     方法可能未关闭stream，方法产生了一个IO流，却未关闭，将会导致文件描绘符的泄漏，建议使用finally block来确保io stream被关闭。</p>\n<h5 id=\"6-7、-DMI-CALLING-NEXT-FROM-HASNEXT\"><a href=\"#6-7、-DMI-CALLING-NEXT-FROM-HASNEXT\" class=\"headerlink\" title=\"6.7、       DMI_CALLING_NEXT_FROM_HASNEXT\"></a>6.7、       DMI_CALLING_NEXT_FROM_HASNEXT</h5><pre><code>DMI: hasNext method invokes next (DMI_CALLING_NEXT_FROM_HASNEXT)\n</code></pre><p>The hasNext() method invokes the next() method. This is almost certainly wrong, since the hasNext() method is not supposed to change the state of the iterator, and the next method is supposed to change the state of the iterator.</p>\n<h5 id=\"6-8、-IL-INFINITE-LOOP\"><a href=\"#6-8、-IL-INFINITE-LOOP\" class=\"headerlink\" title=\"6.8、       IL_INFINITE_LOOP\"></a>6.8、       IL_INFINITE_LOOP</h5><pre><code>IL: An apparent infinite loop (IL_INFINITE_LOOP)\n</code></pre><p>This loop doesn’t seem to have a way to terminate (other than by perhaps throwing an exception).<br>     明显的无限循环.</p>\n<h5 id=\"6-9、-IL-INFINITE-RECURSIVE-LOOP\"><a href=\"#6-9、-IL-INFINITE-RECURSIVE-LOOP\" class=\"headerlink\" title=\"6.9、       IL_INFINITE_RECURSIVE_LOOP\"></a>6.9、       IL_INFINITE_RECURSIVE_LOOP</h5><pre><code>IL: An apparent infinite recursive loop (IL_INFINITE_RECURSIVE_LOOP)\n</code></pre><p>This method unconditionally invokes itself. This would seem to indicate an infinite recursive loop that will result in a stack overflow.<br>     明显的无限迭代循环,将导致堆栈溢出.</p>\n<h5 id=\"6-10、-WMI-WRONG-MAP-ITERATOR\"><a href=\"#6-10、-WMI-WRONG-MAP-ITERATOR\" class=\"headerlink\" title=\"6.10、   WMI_WRONG_MAP_ITERATOR\"></a>6.10、   WMI_WRONG_MAP_ITERATOR</h5><pre><code>WMI: Inefficient use of keySet iterator instead of entrySet iterator (WMI_WRONG_MAP_ITERATOR)\n</code></pre><p>This method accesses the value of a Map entry, using a key that was retrieved from a keySet iterator. It is more efficient to use an iterator on the entrySet of the map, to avoid the Map.get(key) lookup.<br>     使用了keySet iterator和Map.get(key)来获取Map值,这种方式效率低,建议使用entrySet的iterator效率更高.</p>\n<h5 id=\"6-11、-IM-BAD-CHECK-FOR-ODD\"><a href=\"#6-11、-IM-BAD-CHECK-FOR-ODD\" class=\"headerlink\" title=\"6.11、   IM_BAD_CHECK_FOR_ODD\"></a>6.11、   IM_BAD_CHECK_FOR_ODD</h5><pre><code>IM: Check for oddness that won&apos;t work for negative numbers (IM_BAD_CHECK_FOR_ODD)\n</code></pre><p>The code uses x % 2 == 1 to check to see if a value is odd, but this won’t work for negative numbers (e.g., (-5) % 2 == -1). If this code is intending to check for oddness, consider using x &amp; 1 == 1, or x % 2 != 0.<br>     奇偶检测逻辑,未考虑负数情况.</p>\n<h4 id=\"7-实际项目中Bug类型统计\"><a href=\"#7-实际项目中Bug类型统计\" class=\"headerlink\" title=\"7.实际项目中Bug类型统计\"></a>7.实际项目中Bug类型统计</h4><h5 id=\"7-1、-Call-to-equals-comparing-different-types\"><a href=\"#7-1、-Call-to-equals-comparing-different-types\" class=\"headerlink\" title=\"7.1、       Call to equals() comparing different types\"></a>7.1、       Call to equals() comparing different types</h5><p>id : EC_UNRELATED_TYPES, type : EC, category : CORRECTNESS This method calls equals(Object) on two references of different class types with no common subclasses. Therefore, the objects being compared are unlikely to be members of the same class at runtime (unless some application classes were not analyzed, or dynamic class loading can occur at runtime). According to the contract of equals(), objects of different classes should always compare as unequal; therefore, according to the contract defined by java.lang.Object.equals(Object), the result of this comparison will always be false at runtime.<br>原因分析：<br>这缺陷的意思是，大部分都是类型永远不会有这种情况， 比如a为DOUBLE类型所以EQUALS只匹配字符串 if(a.equals())或if(a.quals())这类判断是根本不会有用的；<br>示例：if(“1”.equals(DAOValue.valueofSuccess()))</p>\n<h5 id=\"7-2、-Dead-store-to-local-variable\"><a href=\"#7-2、-Dead-store-to-local-variable\" class=\"headerlink\" title=\"7.2、       Dead store to local variable\"></a>7.2、       Dead store to local variable</h5><p>id: DLS_DEAD_LOCAL_STORE, type: DLS, category: STYLE<br>This instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used.<br>Note that Sun’s javac compiler often generates dead stores for final local variables. Because FindBugs is a bytecode-based tool, there is no easy way to eliminate these false positives.<br>原因分析：<br>DLS问题指的是给本地变量赋了一个值，但随后的代码并没有用到这个值。</p>\n<h5 id=\"7-3、-Method-call-passes-null-for-nonnull-parameter\"><a href=\"#7-3、-Method-call-passes-null-for-nonnull-parameter\" class=\"headerlink\" title=\"7.3、       Method call passes null for nonnull parameter\"></a>7.3、       Method call passes null for nonnull parameter</h5><p>id: NP_NULL_PARAM_DEREF, type: NP, category: CORRECTNESS<br>This method call passes a null value for a nonnull method parameter. Either the parameter is annotated as a parameter that should always be nonnull, or analysis has shown that it will always be dereferenced.<br>原因分析：对参数为null的情况未作处理。<br>例如：</p>\n<figure class=\"highlight plain\"><figcaption><span>void method1() &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    String ip = null;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        ip = InetAddress.getLocalHost().getHostAddress();</span><br><span class=\"line\">    &#125; catch (UnknownHostException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    long ipCount = countIpAddress(ip);//可能会传入空引用 </span><br><span class=\"line\">    //....</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">long countIpAddress(String ip) &#123;</span><br><span class=\"line\">    long ipNum = 0;</span><br><span class=\"line\">    String[] ipArray = ip.split(&quot;\\\\.&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><figcaption><span>void method1() &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    String ip = null;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        ip = InetAddress.getLocalHost().getHostAddress();</span><br><span class=\"line\">    &#125; catch (UnknownHostException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    long ipCount = countIpAddress(ip);//可能会传入空引用</span><br><span class=\"line\">    //....</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">long countIpAddress(String ip) &#123;</span><br><span class=\"line\">    long ipNum = 0;</span><br><span class=\"line\">    if(ip==null)&#123;</span><br><span class=\"line\">        return 0;//抛出异常</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    String[] ipArray = ip.split(&quot;\\\\.&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于接口需要对参数校验合法性</p>\n<h5 id=\"7-4、Method-with-Boolean-return-type-returns-explicit-null\"><a href=\"#7-4、Method-with-Boolean-return-type-returns-explicit-null\" class=\"headerlink\" title=\"7.4、Method with Boolean return type returns explicit null\"></a>7.4、Method with Boolean return type returns explicit null</h5><p>id: NP_BOOLEAN_RETURN_NULL, type: NP, category: BAD_PRACTICE<br>A method that returns either Boolean.TRUE, Boolean.FALSE or null is an accident waiting to happen. This method can be invoked as though it returned a value of type boolean, and the compiler will insert automatic unboxing of the Boolean value. If a null value is returned, this will result in a NullPointerException.<br>原因分析：<br>方法如果定义为返回类型Boolean，则可以返回Boolean.TRUE, Boolean.FALSE or null （如果 return 的是 true or  false， 则AutoBoxing 成 Boolean.TRUE, Boolean.FALSE）。因为JDK 支持 基本类型和装箱类型的自动转化， 所以下面的代码中：<br>boolean result = test_NP_BOOLEAN_RETURN_NULL();<br>因为此时test_NP_BOOLEAN_RETURN_NULL() 返回的是NULL， 所以 JDK 做 automatic unboxing 的操作时， 即调用了 object. booleanValue() 方法时，抛出了空指针。<br>改成：boolean result = test_NP_BOOLEAN_RETURN_NULL()==null?false:true;</p>\n<h5 id=\"7-5、-No-relationship-between-generic-parameter-and-method-argument\"><a href=\"#7-5、-No-relationship-between-generic-parameter-and-method-argument\" class=\"headerlink\" title=\"7.5、       No relationship between generic parameter and method argument\"></a>7.5、       No relationship between generic parameter and method argument</h5><p>id: GC_UNRELATED_TYPES, type: GC, category: CORRECTNESS<br>This call to a generic collection method contains an argument with an incompatible class from that of the collection’s parameter (i.e., the type of the argument is neither a supertype nor a subtype of the corresponding generic type argument). Therefore, it is unlikely that the collection contains any objects that are equal to the method argument used here. Most likely, the wrong value is being passed to the method.<br>In general, instances of two unrelated classes are not equal. For example, if the Foo and Bar classes are not related by subtyping, then an instance of Foo should not be equal to an instance of Bar. Among other issues, doing so will likely result in an equals method that is not symmetrical. For example, if you define the Foo class so that a Foo can be equal to a String, your equals method isn’t symmetrical since a String can only be equal to a String.<br>In rare cases, people do define nonsymmetrical equals methods and still manage to make their code work. Although none of the APIs document or guarantee it, it is typically the case that if you check if a Collection<string> contains a Foo, the equals method of argument (e.g., the equals method of the Foo class) used to perform the equality checks.<br>原因分析：调用Collection类中的contains方法比较时，所比较的两个参数类型不致；</string></p>\n<h5 id=\"7-6、-Null-pointer-dereference-in-method-on-exception-path\"><a href=\"#7-6、-Null-pointer-dereference-in-method-on-exception-path\" class=\"headerlink\" title=\"7.6、       Null pointer dereference in method on exception path\"></a>7.6、       Null pointer dereference in method on exception path</h5><p>id: NP_ALWAYS_NULL_EXCEPTION, type: NP, category: CORRECTNESS<br>A pointer which is null on an exception path is dereferenced here.  This will lead to a NullPointerException when the code is executed.  Note that because FindBugs currently does not prune infeasible exception paths, this may be a false warning.<br>Also note that FindBugs considers the default case of a switch statement to be an exception path, since the default case is often infeasible.<br>原因分析：在异常处理时，调用一个空对象的方法时可能引起空指针异常。</p>\n<h5 id=\"7-7、-Nullcheck-of-value-previously-dereferenced\"><a href=\"#7-7、-Nullcheck-of-value-previously-dereferenced\" class=\"headerlink\" title=\"7.7、       Nullcheck of value previously dereferenced\"></a>7.7、       Nullcheck of value previously dereferenced</h5><p>id: RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE, type:RCN, category: CORRECTNESS<br>A value is checked here to see whether it is null, but this value can’t be null because it was previously dereferenced and if it were null a null pointer exception would have occurred at the earlier dereference. Essentially, this code and the previous dereference disagree as to whether this value is allowed to be null. Either the check is redundant or the previous dereference is erroneous.<br>原因分析：前面获取的对象，现在引用的时候没有交验是否为null。</p>\n<h5 id=\"7-8、-Possible-null-pointer-dereference\"><a href=\"#7-8、-Possible-null-pointer-dereference\" class=\"headerlink\" title=\"7.8、       Possible null pointer dereference\"></a>7.8、       Possible null pointer dereference</h5><p>id: NP_NULL_ON_SOME_PATH, type: NP, category: CORRECTNESS<br>There is a branch of statement that, if executed, guarantees that a null value will be dereferenced, which would generate a NullPointerException when the code is executed. Of course, the problem might be that the branch or statement is infeasible and that the null pointer exception can’t ever be executed; deciding that is beyond the ability of FindBugs.<br>原因分析：可能存在空引用。</p>\n<h5 id=\"7-9、-Possible-null-pointer-dereference-in-method-on-exception-path\"><a href=\"#7-9、-Possible-null-pointer-dereference-in-method-on-exception-path\" class=\"headerlink\" title=\"7.9、       Possible null pointer dereference in method on exception path\"></a>7.9、       Possible null pointer dereference in method on exception path</h5><p>id: NP_NULL_ON_SOME_PATH_EXCEPTION, type: NP, category:CORRECTNESS<br>A reference value which is null on some exception control path is dereferenced here.  This may lead to a NullPointerException when the code is executed.  Note that because FindBugs currently does not prune infeasible exception paths, this may be a false warning.<br>Also note that FindBugs considers the default case of a switch statement to be an exception path, since the default case is often infeasible.<br>原因分析：<br>代码调用时， 遇到异常分支， 可能造成一个对象没有获得赋值依旧保持NULL空指针。 接下来如果对这个对象有引用， 可能造成NullPointerException 空指针异常。<br>例如：</p>\n<h5 id=\"7-10、-Test-for-floating-point-equality\"><a href=\"#7-10、-Test-for-floating-point-equality\" class=\"headerlink\" title=\"7.10、   Test for floating point equality\"></a>7.10、   Test for floating point equality</h5><p>id: FE_FLOATING_POINT_EQUALITY, type: FE, category: STYLE<br>This operation compares two floating point values for equality. Because floating point calculations may involve rounding, calculated float and double values may not be accurate. For values that must be precise, such as monetary values, consider using a fixed-precision type such as BigDecimal. For values that need not be precise, consider comparing for equality within some range, for example: if ( Math.abs(x - y) &lt; .0000001 ). See the java Language Specification, section 4.2.4.<br>原因分析：<br>Float类型的数据比较时，会存在的定的误差值，用!=来比较不是很准确，建议比较两个数的绝对值是否在一定的范围内来进行比较。如，if ( Math.abs(x - y) &lt; .0000001 )<br>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    return ResultVo.valueOfError(&quot;订单编号&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"7-11、-Useless-assignment-in-return-statement\"><a href=\"#7-11、-Useless-assignment-in-return-statement\" class=\"headerlink\" title=\"7.11、   Useless assignment in return statement\"></a>7.11、   Useless assignment in return statement</h5><p>id: DLS_DEAD_LOCAL_STORE_IN_RETURN, type: DLS, category: STYLE<br>This statement assigns to a local variable in a return statement. This assignment has effect. Please verify that this statement does the right thing.<br>原因分析：<br>在return的对象中，没有必要通过对象赋值再进行返回。<br>例如：</p>\n<figure class=\"highlight plain\"><figcaption><span>daoValue </span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(lxrCpdlVoList.size()==0)&#123;</span><br><span class=\"line\">    return daoValue = DAOValue.valueof(true,1,&quot;没有批量删除联系人业务大类信息失败&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"7-12、-Write-to-static-field-from-instance-method\"><a href=\"#7-12、-Write-to-static-field-from-instance-method\" class=\"headerlink\" title=\"7.12、   Write to static field from instance method\"></a>7.12、   Write to static field from instance method</h5><p>id: ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD, type: ST, category:STYLE<br>This instance method writes to a static field. This is tricky to get correct if multiple instances are being manipulated, and generally bad practice.<br>原因分析：向static字段中写入值。<br>例如：<br><figure class=\"highlight plain\"><figcaption><span>static DBRBO dbrBO; </span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> public final void refresh() &#123; </span><br><span class=\"line\">        danskeBankBO = null; </span><br><span class=\"line\">        dbrBO = null; </span><br><span class=\"line\">        fileAndPathBO = null; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">``` </span><br><span class=\"line\">建议改为：去掉static。</span><br><span class=\"line\">##### 7.13、   Incorrect lazy initialization and update of static field</span><br><span class=\"line\">id: LI_LAZY_INIT_UPDATE_STATIC, type: LI, category: MT_CORRECTNESS</span><br><span class=\"line\">This method contains an unsynchronized lazy initialization of a static field. After the field is set, the object stored into that location is further updated or accessed. The setting of the field is visible to other threads as soon as it is set. If the futher accesses in the method that set the field serve to initialize the object, then you have a very seriousmultithreading bug, unless something else prevents any other thread from accessing the stored object until it is fully initialized.</span><br><span class=\"line\">Even if you feel confident that the method is never called by multiple threads, it might be better to not set the static field until the value you are setting it to is fully populated/initialized.</span><br><span class=\"line\">原因分析：</span><br><span class=\"line\">该方法的初始化中包含了一个迟缓初始化的静态变量。你的方法引用了一个静态变量，估计是类静态变量，那么多线程调用这个方法时，你的变量就会面临线程安全的问题了，除非别的东西阻止任何其他线程访问存储对象从直到它完全被初始化。</span><br><span class=\"line\">##### 7.14、   Method ignores return value</span><br><span class=\"line\">id: RV_RETURN_VALUE_IGNORED, type: RV, category: CORRECTNESS</span><br><span class=\"line\">The return value of this method should be checked. One common cause of this warning is to invoke a method on an immutable object, thinking that it updates the object. For example, in the following code fragment,</span><br><span class=\"line\">String dateString = getHeaderField(name);</span><br><span class=\"line\">dateString.trim();</span><br><span class=\"line\">the programmer seems to be thinking that the trim() method will update the String referenced by dateString. But since Strings are immutable, the trim() function returns a new String value, which is being ignored here. The code should be corrected to:</span><br><span class=\"line\">String dateString = getHeaderField(name);</span><br><span class=\"line\">dateString = dateString.trim();</span><br><span class=\"line\">原因分析：方法忽略了设置返回值。</span><br><span class=\"line\">例如：</span><br><span class=\"line\"> </span><br><span class=\"line\">```String dateString = getHeaderField(name);</span><br><span class=\"line\">    dateString.trim();</span><br><span class=\"line\">    </span><br><span class=\"line\">    if(CustomActionEnum.Agee_SRT.equals(operationType)||CustomActionEnum.DISSAgee_SRT.equals(operationType)&#123;</span><br><span class=\"line\">        //....</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"7-15、-Method-might-ignore-exception\"><a href=\"#7-15、-Method-might-ignore-exception\" class=\"headerlink\" title=\"7.15、   Method might ignore exception\"></a>7.15、   Method might ignore exception</h5><p>id: DE_MIGHT_IGNORE, type: DE, category: BAD_PRACTICE<br>This method might ignore an exception.Â  In general, exceptions should be handled or reported in some way, or they should be thrown out of the method.<br>原因分析：应该将异常 处理、打印或者抛出<br>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    //....</span><br><span class=\"line\">&#125;catch(Exception e)&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"7-16、-Unwritten-field\"><a href=\"#7-16、-Unwritten-field\" class=\"headerlink\" title=\"7.16、   Unwritten field\"></a>7.16、   Unwritten field</h5><p>id: UWF_UNWRITTEN_FIELD, type: UwF, category: CORRECTNESS<br>This field is never written.Â  All reads of it will return the default value. Check for errors (should it have been initialized?), or remove it if it is useless.<br>原因分析：从未被初始化的变量，调用它时，将返回默认值，要么初始化，要么删掉它。<br>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    //....</span><br><span class=\"line\">&#125;catch(Exception e)&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"7-17、-Value-is-null-and-guaranteed-to-be-dereferenced-on-exception-path\"><a href=\"#7-17、-Value-is-null-and-guaranteed-to-be-dereferenced-on-exception-path\" class=\"headerlink\" title=\"7.17、   Value is null and guaranteed to be dereferenced on exception path\"></a>7.17、   Value is null and guaranteed to be dereferenced on exception path</h5><p>id: NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH, type: NP, category:CORRECTNESS<br>There is a statement or branch on an exception path that if executed guarantees that a value is null at this point, and that value that is guaranteed to be dereferenced (except on forward paths involving runtime exceptions).<br>原因分析：exception分支上，存在引用一个null对象的方法，引发空指针异常。<br>例如：<br><figure class=\"highlight plain\"><figcaption><span>out </span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try&#123;</span><br><span class=\"line\">    response.setContentType(&quot;text/html;charset=GBK&quot;);</span><br><span class=\"line\">    response.setHeader(&quot;Cache-Control;no-cache&quot;);</span><br><span class=\"line\">    out = response.getWriter();</span><br><span class=\"line\">    out.flush();</span><br><span class=\"line\">&#125;catch(Exception ex)&#123;</span><br><span class=\"line\">    logger.debug(&quot;获取树的XML代码出错。&quot;+ex.getMessage());</span><br><span class=\"line\">&#125;finally&#123;</span><br><span class=\"line\">    out.close();//out可能为空</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"7-18、-Very-confusing-method-names\"><a href=\"#7-18、-Very-confusing-method-names\" class=\"headerlink\" title=\"7.18、   Very confusing method names\"></a>7.18、   Very confusing method names</h5><p>id: NM_VERY_CONFUSING, type: Nm, category: CORRECTNESS<br>The referenced methods have names that differ only by capitalization. This is very confusing because if the capitalization were identical then one of the methods would override the other.<br>原因分析：被引用的方法中存在容易混淆的变量。<br>例如：fzgsdm改成 fzgsDm 即可。</p>\n<figure class=\"highlight plain\"><figcaption><span>String getFzgsdm() &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    return getFzgsdm;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"7-19、-Method-invokes-inefficient-new-String-constructor\"><a href=\"#7-19、-Method-invokes-inefficient-new-String-constructor\" class=\"headerlink\" title=\"7.19、   Method invokes inefficient new String() constructor\"></a>7.19、   Method invokes inefficient new String() constructor</h5><p>id: DM_STRING_VOID_CTOR, type: Dm, category: Performance Creating a new java.lang.String object using the no-argument constructor wastes memory because the object so created will be functionally indistinguishable from the empty string constant “”.  Java guarantees that identical string constants will be represented by the same String object.  Therefore, you should just use the empty string constant directly.<br>原因分析：不使用new String()定义空的字符串<br>例如：</p>\n<figure class=\"highlight plain\"><figcaption><span>alarmCodeCond </span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">应当</span><br><span class=\"line\">String alarmCodeCond = &quot;&quot;;</span><br><span class=\"line\">```      </span><br><span class=\"line\"></span><br><span class=\"line\">##### 7.20、   Load of known null value</span><br><span class=\"line\">id: NP_LOAD_OF_KNOWN_NULL_VALUE, type: Np, category: Dodgy</span><br><span class=\"line\">The variable referenced at this point is known to be null due to an earlier check against null. Although this is valid, it might be a mistake (perhaps you intended to refer to a different variable, or perhaps the earlier check to see if the variable is null should have been a check to see if it was nonnull).</span><br><span class=\"line\">原因分析：null值的不当使用。</span><br><span class=\"line\">例如：</span><br><span class=\"line\"></span><br><span class=\"line\">``` </span><br><span class=\"line\">if(devIds ==null &amp;&amp; devIds.size()==0)&#123; //.....&#125; </span><br><span class=\"line\"></span><br><span class=\"line\">if(null ==tempList||tempList.size()!=0)&#123; //.....&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">if(batchNo ==null)&#123;</span><br><span class=\"line\">   throw new Exception(&quot;the No. &quot;+batchNo + &quot;is not exists1&quot;）)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"7-21、-Method-concatenates-strings-using-in-a-loop\"><a href=\"#7-21、-Method-concatenates-strings-using-in-a-loop\" class=\"headerlink\" title=\"7.21、   Method concatenates strings using + in a loop\"></a>7.21、   Method concatenates strings using + in a loop</h5><p>id: SBSC_USE_STRINGBUFFER_CONCATENATION, type: SBSC, category: Performance<br>The method seems to be building a String using concatenation in a loop. In each iteration, the String is converted to a StringBuffer/StringBuilder, appended to, and converted back to a String. This can lead to a cost quadratic in the number of iterations, as the growing string is recopied in each iteration. Better performance can be obtained by using a StringBuffer (or StringBuilder in Java 1.5) explicitly.<br>For example:<br>  // This is bad<br>  String s = “”;<br>  for (int i = 0; i &lt; field.length; ++i) {<br>    s = s + field[i];<br>  }<br>  // This is better<br>  StringBuffer buf = new StringBuffer();<br>  for (int i = 0; i &lt; field.length; ++i) {<br>    buf.append(field[i]);<br>  }<br>  String s = buf.toString();<br>原因分析：在循环里使用字符串连接，效率低，应该使用StringBuilder/StringBuffer</p>\n<h3 id=\"Bug列表\"><a href=\"#Bug列表\" class=\"headerlink\" title=\"Bug列表\"></a>Bug列表</h3><h4 id=\"BUG-0001\"><a href=\"#BUG-0001\" class=\"headerlink\" title=\"BUG-0001\"></a>BUG-0001</h4><p>Bug: Field only ever set to null: com.bettersoft.admin.BtCorpManager.ps<br>All writes to this field are of the constant value null, and thus all reads of the field will return null. Check for errors, or remove it if it is useless.<br>Confidence: Normal, Rank: Troubling (12)<br>Pattern: UWF_NULL_FIELD<br>Type: UwF, Category: CORRECTNESS (Correctness)<br>代码片段：、<br><figure class=\"highlight plain\"><figcaption><span>class BtCorpManager &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private BtCorp btcorp=null;</span><br><span class=\"line\">private Connection con = null;</span><br><span class=\"line\">private Statement st = null;</span><br><span class=\"line\">private PreparedStatement ps = null;</span><br><span class=\"line\">private ResultSet rs = null;</span><br><span class=\"line\">private void setConnection(String centerno) throws Exception&#123;</span><br><span class=\"line\">    //con = DBManager.getConnection(centerno);</span><br><span class=\"line\">    con = DBManager.getConnection();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>解释说明：在BtCorpManager类里面定了一个私有的成员变量PreparedStatement ps,但是这个成员变量ps在实例范围内没有得到任何的初始化(采用默认的构造方法)，始终为null,所以在实例范围内使用该成员变量时，如果不先对其进行初始化操作或者无意识的行为忘了初始化操作，那肯定是要报空指针异常，所以这无疑是一个bug<br>推荐修改： 自己看着办</p>\n<h4 id=\"BUG-0002\"><a href=\"#BUG-0002\" class=\"headerlink\" title=\"BUG-0002\"></a>BUG-0002</h4><p>Bug: Nullcheck of form at line 36 of value previously dereferenced in com.bettersoft.admin.CorpEditAction.execute(ActionMapping, ActionForm, HttpServletRequest, HttpServletResponse)<br>A value is checked here to see whether it is null, but this value can’t be null because it was previously dereferenced and if it were null a null pointer exception would have occurred at the earlier dereference. Essentially, this code and the previous dereference disagree as to whether this value is allowed to be null. Either the check is redundant or the previous dereference is erroneous.<br>Confidence: High, Rank: Scary (9)<br>Pattern: RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE<br>Type: RCN, Category: CORRECTNESS (Correctness)<br>代码片段：</p>\n<figure class=\"highlight plain\"><figcaption><span>ActionForward execute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//throw new UnsupportedOperationException(&quot;Method is not implemented&quot;);</span><br><span class=\"line\">ActionErrors errors = new ActionErrors();</span><br><span class=\"line\">CreateCorpActionForm createCorp = new CreateCorpActionForm();</span><br><span class=\"line\">createCorp = (CreateCorpActionForm)form;</span><br><span class=\"line\">CreateCorpActionForm webcorp=new CreateCorpActionForm();</span><br><span class=\"line\">BudgetWebcorpManager budgetWebcorpManager=new BudgetWebcorpManager();</span><br><span class=\"line\">webcorp=budgetWebcorpManager.getCWebcorp(createCorp.getId());</span><br><span class=\"line\">createCorp.setFbsaddapproveid(webcorp.getFbsaddapproveid());</span><br><span class=\"line\">createCorp.setFbsinputapproveid(webcorp.getFbsinputapproveid());</span><br><span class=\"line\">createCorp.setFbsprocessapproveid(webcorp.getFbsprocessapproveid());</span><br><span class=\"line\"> </span><br><span class=\"line\">boolean b=false;</span><br><span class=\"line\">if(createCorp!=null)&#123;</span><br></pre></td></tr></table></figure>\n<p>解释说明：注意到有个局部变量 CreateCorpActionForm createCorp;再看下它的初始化过程，先是通过new给它分配了内存空间，紧接着有让它引用了了另一个未知的变量，这里说未知是指这个新的引用可能为空，显然 createCorp有可能指向一个空的地址，所以在接下来的引用中极可能报空指针异常（在引用之前不进行判空操作的话）！ 在接下来的代码，如下<br><code>if(createCorp!=null){</code><br>其实也就没有存在的必要，因为如果为空的话，上面这行代码根本不可能执行到，所以findbug说这是冗余的空指针检查。当然考虑到特殊情况，这里显然是struts1的action,所以只要web应用正常启动，通常以下代码</p>\n<p><code>createCorp = (CreateCorpActionForm)form;</code></p>\n<p>是不会导致createCorp指向空的，唯一的缺陷就是之前的new操作是多余的。<br>推荐修改：自己看着办</p>\n<h4 id=\"BUG-0003\"><a href=\"#BUG-0003\" class=\"headerlink\" title=\"BUG-0003\"></a>BUG-0003</h4><p>Bug: con is null guaranteed to be dereferenced in com.bettersoft.admin.leftAction.getLeft(int, String, String) on exception path<br>There is a statement or branch on an exception path that if executed guarantees that a value is null at this point, and that value that is guaranteed to be dereferenced (except on forward paths involving runtime exceptions).<br>Confidence: Normal, Rank: (Troubling 11)<br>Pattern: NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH<br>Type: NP, Category: CORRECTNESS (Correctness)<br>代码片段：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    try</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if(rs != null)</span><br><span class=\"line\">            rs.close();</span><br><span class=\"line\">        if(ps!=null)</span><br><span class=\"line\">            ps.close();</span><br><span class=\"line\">        con.close();</span><br><span class=\"line\">    &#125;catch(Exception ee)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ee.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>解释说明：这应该是大家很熟悉的代码片段了，可以想象Connection con是在catch代码块中进行的初始化操作，findbug对该bug说的很明白，说如果出现异常，Connection con将保证为空，因为很显然如果出现异常，con将得不到正确的初始化，即便初始化了，因为异常的出现，引用也会被解除，回到一开始定义处的null状态，那么在这里的finally代码块中调用Connection con的close()方法，将报空指针异常<br>推荐修改：自己看着办 </p>\n<h4 id=\"BUG-0004\"><a href=\"#BUG-0004\" class=\"headerlink\" title=\"BUG-0004\"></a>BUG-0004</h4><p>Bug: Possible null pointer dereference of dbVersion in com.bettersoft.admin.LoginAction.loadVersion(HttpServletRequest, ActionErrors) on exception path<br>A reference value which is null on some exception control path is dereferenced here. This may lead to aNullPointerExceptionwhen the code is executed. Note that because FindBugs currently does not prune infeasible exception paths, this may be a false warning.<br>Also note that FindBugs considers the default case of a switch statement to be an exception path, since the default case is often infeasible.<br>Confidence: Normal, Rank: Troubling (11)<br>Pattern: NP_NULL_ON_SOME_PATH_EXCEPTION<br>Type: NP, Category: CORRECTNESS (Correctness)<br>代码片段：</p>\n<figure class=\"highlight plain\"><figcaption><span>dbVersion </span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    try &#123;</span><br><span class=\"line\">        con = DBManager.getConnection();</span><br><span class=\"line\">        dbVersion = vm.getVersionInfo(con);</span><br><span class=\"line\">    &#125; catch (Exception e) &#123;</span><br><span class=\"line\">        // TODO Auto-generated catch block</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125; finally &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            con.close();</span><br><span class=\"line\">        &#125; catch (SQLException e) &#123;</span><br><span class=\"line\">            // TODO Auto-generated catch block</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">if (dbVersion.equals(programVersion)) &#123;</span><br><span class=\"line\">    programVersion.setCorrent(true);</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">    programVersion.setCorrent(false);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>解释说明：如果try catch 中捕获异常，那么dbVersion将为空， </p>\n<p><code>dbVersion.equals(programVersion)</code></p>\n<p>上面这行代码，将报空指针异常 </p>\n<h4 id=\"BUG-0005\"><a href=\"#BUG-0005\" class=\"headerlink\" title=\"BUG-0005\"></a>BUG-0005</h4><p>Bug: Dead store to am in com.bettersoft.approve.action.CheckAction.execute(ActionMapping, ActionForm, HttpServletRequest, HttpServletResponse)<br>This instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used.<br>Note that Sun’s javac compiler often generates dead stores for final local variables. Because FindBugs is a bytecode-based tool, there is no easy way to eliminate these false positives.<br>Confidence: High, Rank: Of Concern (15)<br>Pattern: DLS_DEAD_LOCAL_STORE<br>Type: DLS, Category: STYLE (Dodgy code)<br>代码片段：</p>\n<p><code>ApproveManager am = new ApproveManager();</code></p>\n<p>解释说明：am这个局部变量创建出来后，没有在任何地方被引用。这里确实没有被引用，所以是个bug,但是findbug又说明了，这有可能是误报，因为javac编译器在编译局部常量时，也会产生dead stroes。所以这个要视情况而定，不能过于纠结 </p>\n<h4 id=\"BUG-0006\"><a href=\"#BUG-0006\" class=\"headerlink\" title=\"BUG-0006\"></a>BUG-0006</h4><p>Bug: The class name com.bettersoft.approve.form.BtWebCorp shadows the simple name of the superclass com.bettersoft.admin.BtWebCorp<br>This class has a simple name that is identical to that of its superclass, except that its superclass is in a different package (e.g.,alpha.Fooextendsbeta.Foo). This can be exceptionally confusing, create lots of situations in which you have to look at import statements to resolve references and creates many opportunities to accidently define methods that do not override methods in their superclasses.<br>Confidence: High, Rank: Troubling (14)<br>Pattern: NM_SAME_SIMPLE_NAME_AS_SUPERCLASS<br>Type: Nm, Category: BAD_PRACTICE (Bad practice)<br>代码片段： </p>\n<figure class=\"highlight plain\"><figcaption><span>class BtWebCorp extends com.bettersoft.admin.BtWebCorp&#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>解释说明：这里子类和父类名称一样，findbug认为这回导致很多混淆。显然一旦出问题，将很难发现，运行结果将出乎意料 </p>\n<h4 id=\"BUG-0007\"><a href=\"#BUG-0007\" class=\"headerlink\" title=\"BUG-0007\"></a>BUG-0007</h4><p>Bug: Comparison of String objects using == or != in com.byttersoft.admin.persistence.dao.MessageOpenDao.addOpenSave(MessageOpenForm)<br>This code comparesjava.lang.Stringobjects for reference equality using the == or != operators. Unless both strings are either constants in a source file, or have been interned using theString.intern()method, the same string value may be represented by two different String objects. Consider using theequals(Object)method instead.<br>Confidence: Normal, Rank: Troubling (11)<br>Pattern: ES_COMPARING_STRINGS_WITH_EQ<br>Type: ES, Category: BAD_PRACTICE (Bad practice)<br>代码片段：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">        sql = &quot;insert into xx values (1,?,?,?)&quot;;</span><br><span class=\"line\">&#125;else&#123;</span><br><span class=\"line\">        sql = &quot;insert into xx values ((select max(id) + 1 from xx),?,?,?)&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>解释说明： 直接使用==进行对象实例比较，而没有使用equals,本来没觉得这个bug咋样，但是发现项目里居然最多的bug就是这个，不管是很多年前的代码还是最近的代码，都存在这大量这样的问题。看来这是一个通病，所以大家注意一下，不光是我们公司的项目有这样的问题，这应该是一个普遍的问题，尤其实在比较String类型的时候，注意只要不是java基本类型都需要使用equals进行比较，哪怕是自动解封的Integer，Double等</p>\n<h4 id=\"BUG-0008\"><a href=\"#BUG-0008\" class=\"headerlink\" title=\"BUG-0008\"></a>BUG-0008</h4><p>Bug: Call to String.equals(Double) in com.byttersoft.amm.util.BalanceInterzoneRateUtil.formatRate(Double)<br>This method calls equals(Object) on two references of different class types with no common subclasses. Therefore, the objects being compared are unlikely to be members of the same class at runtime (unless some application classes were not analyzed, or dynamic class loading can occur at runtime). According to the contract of equals(), objects of different classes should always compare as unequal; therefore, according to the contract defined by Java.lang.Object.equals(Object), the result of this comparison will always be false at runtime.<br>Confidence: High, Rank: Scariest (1)<br>Pattern: EC_UNRELATED_TYPES<br>Type: EC, Category: CORRECTNESS (Correctness)<br>代码片段：<br><figure class=\"highlight plain\"><figcaption><span>static String  formatRate(Double r)&#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> </span><br><span class=\"line\">if(r==null ||  (&quot;undefined&quot;).equals(r))&#123;</span><br><span class=\"line\">    return null;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>解释说明：使用equals比较不同类型的数据，”undefined”是String类型，r是Double类型，这两个比较肯定返回false</p>\n<p><code>(&quot;undefined&quot;).equals(r)</code></p>\n<p>上面这行代码完全没有必要 ，不可能存在这种情况</p>\n<h4 id=\"BUG-0009\"><a href=\"#BUG-0009\" class=\"headerlink\" title=\"BUG-0009\"></a>BUG-0009</h4><p>Bug: Class com.byttersoft.util.CertInfo defines non-transient non-serializable instance field subjectDnAttr<br>This Serializable class defines a non-primitive instance field which is neither transient, Serializable, orjava.lang.Object, and does not appear to implement theExternalizableinterface or thereadObject()andwriteObject()methods. Objects of this class will not be deserialized correctly if a non-Serializable object is stored in this field.<br>Confidence: High, Rank: Troubling (14)<br>Pattern: SE_BAD_FIELD<br>Type: Se, Category: BAD_PRACTICE (Bad practice)<br>代码片段： </p>\n<figure class=\"highlight plain\"><figcaption><span>class CertInfo implements java.io.Serializable</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    private String subjectDN=&quot;&quot;;</span><br><span class=\"line\">    private String issuerDN=&quot;&quot;;</span><br><span class=\"line\">    private String notAfterDate=&quot;&quot;;</span><br><span class=\"line\">    private String notBeforeDate=&quot;&quot;;</span><br><span class=\"line\">    private String serialNumber=&quot;&quot;;</span><br><span class=\"line\">    private String sigAlgName=&quot;&quot;;</span><br><span class=\"line\">    private String sigAlgOID=&quot;&quot;;</span><br><span class=\"line\">    private String version=&quot;&quot;;</span><br><span class=\"line\">    private String publicKeyFormat=&quot;&quot;;</span><br><span class=\"line\">    private String publicKeyAlgorithm=&quot;&quot;;</span><br><span class=\"line\">    private Names subjectDnAttr=null;</span><br><span class=\"line\">｝</span><br><span class=\"line\">public class Names</span><br><span class=\"line\">&#123;&#125;&lt;span&gt;&lt;/span&gt;</span><br></pre></td></tr></table></figure>\n<p>解释说明： CertInfo实现的序列话，但是他的成员变量Names subjectDnAttr没有实现序列化，这将会导致序列化失败，String已经默认实现了序列化。注意，序列化时所有的成员变量都必须递归的实现序列化，否则将导致序列化失败。如果某个成员变量不想被序列化要么标注为瞬态要么重写readObj方法</p>\n<h4 id=\"BUG-0010\"><a href=\"#BUG-0010\" class=\"headerlink\" title=\"BUG-0010\"></a>BUG-0010</h4><p>Bug: Dead store to corpGourps rather than field with same name in com.byttersoft.admin.form.CorpGroupsForm.setCorpGourps(CorpGourps)<br>This instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used. There is a field with the same name as the local variable. Did you mean to assign to that variable instead?<br>Confidence: High, Rank: Scary (9)<br>Pattern: DLS_DEAD_LOCAL_STORE_SHADOWS_FIELD<br>Type: DLS, Category: STYLE (Dodgy code)<br>代码片段： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public void setCorpGourps(CorpGourps corpGourps) &#123;</span><br><span class=\"line\">        corpGourps = corpGourps;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>解释说明：成员变量和局部变量重名</p>\n<h4 id=\"BUG-0011\"><a href=\"#BUG-0011\" class=\"headerlink\" title=\"BUG-0011\"></a>BUG-0011</h4><p>Bug: Invocation of toString on labelValue in com.byttersoft.approve.persistence.dao.MesAppDao.getMapByPara(String)<br>The code invokes toString on an array, which will generate a fairly useless result such as [C@16f0472. Consider using Arrays.toString to convert the array into a readable String that gives the contents of the array. See Programming Puzzlers, chapter 3, puzzle 12.<br>Confidence: Normal, Rank: Troubling (10)<br>Pattern: DMI_INVOKING_TOSTRING_ON_ARRAY<br>Type: USELESS_STRING, Category: CORRECTNESS (Correctness)<br>代码片段：</p>\n<figure class=\"highlight plain\"><figcaption><span>(String parameter : parameters) &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    String[] labelValue = parameter.split(&quot;=&quot;);</span><br><span class=\"line\">    if (labelValue.length == 2) &#123;</span><br><span class=\"line\">        String key = labelValue[0];</span><br><span class=\"line\">        String value = labelValue[1];</span><br><span class=\"line\">        hashMap.put(key, value);</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        logger.debug(&quot;参数 &quot; + labelValue + &quot; 配置错误。&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>解释说明：在进行日志输出时，直接输出对象，将默认调用对象的toString方法，而默认是输出对象的内存地址，所以这里显然有问题，本意应该是输出数组中的字符串 </p>\n<h4 id=\"BUG-0012\"><a href=\"#BUG-0012\" class=\"headerlink\" title=\"BUG-0012\"></a>BUG-0012</h4><p>Bug: Write to static field com.byttersoft.admin.service.BtSysResService.map from instance method com.byttersoft.admin.service.BtSysResService.hashCatchOfSysRes(boolean)<br>This instance method writes to a static field. This is tricky to get correct if multiple instances are being manipulated, and generally bad practice.<br>Confidence: High, Rank: Of Concern (15)<br>Pattern: ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD<br>Type: ST, Category: STYLE (Dodgy code)<br>代码片段： </p>\n<figure class=\"highlight plain\"><figcaption><span>Map<string, btsysres=\"\"> map </string,></span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public Map&lt;String, BtSysRes&gt; hashCatchOfSysRes(boolean isRefresh) &#123;</span><br><span class=\"line\">        if(isRefresh == true)&#123;</span><br><span class=\"line\">            map = hashCatchOfSysRes();</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            if(map == null || map.isEmpty())&#123;</span><br><span class=\"line\">                map = hashCatchOfSysRes();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return map;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>解释说明：在实例方法中修改类变量的引用，这会导致共享问题，因为其他实例也会访问该静态变量，但是却不知道某个实例已经修改了该静态变量的引用，导致不可预知的问题<br>推荐修改：将该方法改为类方法</p>\n<h4 id=\"BUG-0013\"><a href=\"#BUG-0013\" class=\"headerlink\" title=\"BUG-0013\"></a>BUG-0013</h4><p>Bug: Unwritten field: com.byttersoft.admin.service.importservice.ImportServices.bank<br>This field is never written. All reads of it will return the default value. Check for errors (should it have been initialized?), or remove it if it is useless.<br>Confidence: Normal, Rank: Troubling (12)<br>Pattern: UWF_UNWRITTEN_FIELD<br>Type: UwF, Category: CORRECTNESS (Correctness)<br>代码片段：</p>\n<figure class=\"highlight plain\"><figcaption><span>class ImportServices &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private IBankAccServices bank;</span><br><span class=\"line\">public IBankAccServices getBank() &#123;</span><br><span class=\"line\">        return bank;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">｝</span><br></pre></td></tr></table></figure>\n<p>解释说明： bank对象为空，getBank方法返回了一个肯定为空的对象实例</p>\n<h4 id=\"BUG-0014\"><a href=\"#BUG-0014\" class=\"headerlink\" title=\"BUG-0014\"></a>BUG-0014</h4><p>Bug: There is an apparent infinite recursive loop in com.byttersoft.amm.dao.impl.CheckLoanOrProvideInfoDaoImpl.addBatch(List)<br>This method unconditionally invokes itself. This would seem to indicate an infinite recursive loop that will result in a stack overflow.<br>Confidence: High, Rank: Scary (9)<br>Pattern: IL_INFINITE_RECURSIVE_LOOP<br>Type: IL, Category: CORRECTNESS (Correctness)<br>代码片段：<br><figure class=\"highlight plain\"><figcaption><span>void addBatch(List<cmsploantobean> cmsPLoanBeans) &#123;</cmsploantobean></span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    this.addBatch(cmsPLoanBeans);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>解释说明：出现了递归调用addBatch,将出现死循环</p>\n<h3 id=\"High\"><a href=\"#High\" class=\"headerlink\" title=\"High\"></a>High</h3><h4 id=\"1-DM-DEFAULT-ENCODING\"><a href=\"#1-DM-DEFAULT-ENCODING\" class=\"headerlink\" title=\"1.DM_DEFAULT_ENCODING\"></a>1.DM_DEFAULT_ENCODING</h4><h5 id=\"1-1-Found-reliance-on-default-encoding-in-com-cmcc-aoi-httprequest-service-HttpRequest-sendGet-String-String-new-java-io-InputStreamReader-InputStream\"><a href=\"#1-1-Found-reliance-on-default-encoding-in-com-cmcc-aoi-httprequest-service-HttpRequest-sendGet-String-String-new-java-io-InputStreamReader-InputStream\" class=\"headerlink\" title=\"1.1 Found reliance on default encoding in com.cmcc.aoi.httprequest.service.HttpRequest.sendGet(String, String): new java.io.InputStreamReader(InputStream)\"></a>1.1 Found reliance on default encoding in com.cmcc.aoi.httprequest.service.HttpRequest.sendGet(String, String): new java.io.InputStreamReader(InputStream)</h5><p>Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.</p>\n<p>new BufferedReader(new InputStreamReader(connection.getInputStream()));</p>\n<p>修改为： InputStreamReader fileData = new InputStreamReader(file ,”utf-8”);</p>\n<h5 id=\"1-2-Found-reliance-on-default-encoding-in-com-cmcc-aoi-httprequest-service-HttpRequest-sendPost-String-JSONObject-new-java-io-PrintWriter-OutputStream\"><a href=\"#1-2-Found-reliance-on-default-encoding-in-com-cmcc-aoi-httprequest-service-HttpRequest-sendPost-String-JSONObject-new-java-io-PrintWriter-OutputStream\" class=\"headerlink\" title=\"1.2 Found reliance on default encoding in com.cmcc.aoi.httprequest.service.HttpRequest.sendPost(String, JSONObject): new java.io.PrintWriter(OutputStream)\"></a>1.2 Found reliance on default encoding in com.cmcc.aoi.httprequest.service.HttpRequest.sendPost(String, JSONObject): new java.io.PrintWriter(OutputStream)</h5><p>Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.<br>out = new PrintWriter(conn.getOutputStream());</p>\n<p>修改为： out = new PrintWriter(new OutputStreamWriter(conn.getOutputStream(), “utf-8”));</p>\n<h5 id=\"1-3-Found-reliance-on-default-encoding-in-com-cmcc-aoi-selfhelp-action-DeliverWebRequestAction-calculateUserCount-HttpServletRequest-String-getBytes\"><a href=\"#1-3-Found-reliance-on-default-encoding-in-com-cmcc-aoi-selfhelp-action-DeliverWebRequestAction-calculateUserCount-HttpServletRequest-String-getBytes\" class=\"headerlink\" title=\"1.3 Found reliance on default encoding in com.cmcc.aoi.selfhelp.action.DeliverWebRequestAction.calculateUserCount(HttpServletRequest): String.getBytes()\"></a>1.3 Found reliance on default encoding in com.cmcc.aoi.selfhelp.action.DeliverWebRequestAction.calculateUserCount(HttpServletRequest): String.getBytes()</h5><p>Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.<br>fileName = new String(req.getParameter(“fileName”).getBytes(), “UTF-8”);<br>修改为<br>fileName = new String(req.getParameter(“fileName”).getBytes(“UTF-8”), “UTF-8”);</p>\n<h5 id=\"1-4-Found-reliance-on-default-encoding-in-com-cmcc-aoi-selfhelp-action-servlet-AoeRegAction-report-HttpServletRequest-HttpServletResponse-java-io-ByteArrayOutputStream-toString\"><a href=\"#1-4-Found-reliance-on-default-encoding-in-com-cmcc-aoi-selfhelp-action-servlet-AoeRegAction-report-HttpServletRequest-HttpServletResponse-java-io-ByteArrayOutputStream-toString\" class=\"headerlink\" title=\"1.4 Found reliance on default encoding in com.cmcc.aoi.selfhelp.action.servlet.AoeRegAction.report(HttpServletRequest, HttpServletResponse): java.io.ByteArrayOutputStream.toString()\"></a>1.4 Found reliance on default encoding in com.cmcc.aoi.selfhelp.action.servlet.AoeRegAction.report(HttpServletRequest, HttpServletResponse): java.io.ByteArrayOutputStream.toString()</h5><p>Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.<br>logger.info(“RECV STR: “ + baos.toString());<br>修改为<br>logger.info(“RECV STR: “ + baos.toString(“utf-8”));</p>\n<h5 id=\"1-5-Found-reliance-on-default-encoding-in-com-cmcc-aoi-selfhelp-action-servlet-AoeUploadLogAction-report-HttpServletRequest-HttpServletResponse-new-java-io-FileWriter-File\"><a href=\"#1-5-Found-reliance-on-default-encoding-in-com-cmcc-aoi-selfhelp-action-servlet-AoeUploadLogAction-report-HttpServletRequest-HttpServletResponse-new-java-io-FileWriter-File\" class=\"headerlink\" title=\"1.5 Found reliance on default encoding in com.cmcc.aoi.selfhelp.action.servlet.AoeUploadLogAction.report(HttpServletRequest, HttpServletResponse): new java.io.FileWriter(File)\"></a>1.5 Found reliance on default encoding in com.cmcc.aoi.selfhelp.action.servlet.AoeUploadLogAction.report(HttpServletRequest, HttpServletResponse): new java.io.FileWriter(File)</h5><p>Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.<br>new FileWriter(f).append(baos.toString(“UTF-8”)).close();<br>修改为<br>BufferedWriter out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(f, true)));<br>out.write(baos.toString(“UTF-8”));<br>out.close();</p>\n<p>BufferedWriter bw= new BufferedWriter( new OutputStreamWriter(new FileOutputStream(filePath, true), “utf-8”));</p>\n<h5 id=\"1-6-Found-reliance-on-default-encoding-in-new-com-cmcc-aoi-util-TokenZipFileUtil-String-new-java-io-FileReader-String\"><a href=\"#1-6-Found-reliance-on-default-encoding-in-new-com-cmcc-aoi-util-TokenZipFileUtil-String-new-java-io-FileReader-String\" class=\"headerlink\" title=\"1.6 Found reliance on default encoding in new com.cmcc.aoi.util.TokenZipFileUtil(String): new java.io.FileReader(String)\"></a>1.6 Found reliance on default encoding in new com.cmcc.aoi.util.TokenZipFileUtil(String): new java.io.FileReader(String)</h5><p>Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.<br>FileReader in = new FileReader(file);<br>改为<br>BufferedReader reader = new BufferedReader(new InputStreamReader(newFileInputStream(file), “UTF-8”)); </p>\n<h4 id=\"2-MS-SHOULD-BE-FINAL\"><a href=\"#2-MS-SHOULD-BE-FINAL\" class=\"headerlink\" title=\"2.MS_SHOULD_BE_FINAL\"></a>2.MS_SHOULD_BE_FINAL</h4><p>com.cmcc.aoi.selfhelp.action.DeliverWebRequestAction.logger isn’t final but should be<br>This static field public but not final, and could be changed by malicious code or by accident from another package. The field could be made final to avoid this vulnerability.</p>\n<p>protected static   Logger logger = LoggerFactory.getLogger(DeliverWebRequestAction.class);<br>修改为 protected static final Logger logger = LoggerFactory.getLogger(DeliverWebRequestAction.class);</p>\n<h4 id=\"3-DLS-DEAD-LOCAL-STORE\"><a href=\"#3-DLS-DEAD-LOCAL-STORE\" class=\"headerlink\" title=\"3.DLS_DEAD_LOCAL_STORE\"></a>3.DLS_DEAD_LOCAL_STORE</h4><p>Dead store to s in com.cmcc.aoi.selfhelp.action.DeliverWebRequestAction.textSend(WebSendTextForm, HttpServletRequest)<br>This instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used.<br>Note that Sun’s javac compiler often generates dead stores for final local variables. Because FindBugs is a bytecode-based tool, there is no easy way to eliminate these false positives.<br>ShopMappingDeliver shopMappingDeliver = null;<br>删除即可</p>\n<h4 id=\"4-ST-WRITE-TO-STATIC-FROM-INSTANCE-METHOD\"><a href=\"#4-ST-WRITE-TO-STATIC-FROM-INSTANCE-METHOD\" class=\"headerlink\" title=\"4.ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD\"></a>4.ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD</h4><p>Write to static field com.cmcc.aoi.selfhelp.action.MultipleMediaAoeAction.linkRoot from instance method com.cmcc.aoi.selfhelp.action.MultipleMediaAoeAction.afterPropertiesSet()<br>This instance method writes to a static field. This is tricky to get correct if multiple instances are being manipulated, and generally bad practice.<br>linkRoot = sysConfigService.getDomainName() + “/“;<br>修改改为：<br><figure class=\"highlight plain\"><figcaption><span>static String getLinkRoot() &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">        returnlinkRoot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    publicstaticvoid setLinkRoot(String linkRoot) &#123;</span><br><span class=\"line\">        MultipleMediaAoeAction.linkRoot = linkRoot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   MultipleMediaAoeAction.setLinkRoot(sysConfigService.getDomainName() + &quot;/&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">``` </span><br><span class=\"line\"></span><br><span class=\"line\">#### 5. J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION</span><br><span class=\"line\">Store of non serializable com.cmcc.aoi.selfhelp.action.UploadFileAction$FileUploadStatus into HttpSession in new com.cmcc.aoi.selfhelp.action.UploadFileAction$MyProgressListener(UploadFileAction, HttpServletRequest)</span><br><span class=\"line\">This code seems to be storing a non-serializable object into an HttpSession. If this session is passivated or migrated, an error will result.</span><br><span class=\"line\">修改为 FileUploadStatus implements Serializable</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">#### 6.  RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE</span><br><span class=\"line\">Redundant nullcheck of rtr, which is known to be non-null in com.cmcc.aoi.selfhelp.action.servlet.AoeReportApplistAction.device(HttpServletRequest, HttpServletResponse)</span><br><span class=\"line\">This method contains a redundant check of a known non-null value against the constant null.</span><br><span class=\"line\">```if (rtr != null) &#123;</span><br><span class=\"line\">            Writer writer;</span><br><span class=\"line\">            try &#123;</span><br><span class=\"line\">                writer = response.getWriter();</span><br><span class=\"line\">                if (rtr != null) &#123;</span><br><span class=\"line\">                    try &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">                        String s = JSONUtil.objToJson(rtr);</span><br><span class=\"line\">                        if (LOGGER.isDebugEnabled()) &#123;</span><br><span class=\"line\">                            LOGGER.debug(&quot;SEND STR: &quot; + s);</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                        writer.write(s);</span><br><span class=\"line\">                        writer.flush();</span><br><span class=\"line\">                    &#125; catch (IOException e) &#123;</span><br><span class=\"line\">                        LOGGER.warn(&quot;&quot;, e);</span><br><span class=\"line\">                        if (writer != null) &#123;</span><br><span class=\"line\">                            try &#123;</span><br><span class=\"line\">                                writer.write(JSONUtil.objToJson(rtr));</span><br><span class=\"line\">                            &#125; catch (IOException e1) &#123;</span><br><span class=\"line\">                                LOGGER.warn(&quot;&quot;, e1);</span><br><span class=\"line\">                            &#125;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    response.getWriter().write(&quot;&#123;\\&quot;errorCode\\&quot;:401&#125;&quot;);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; catch (IOException e2) &#123;</span><br><span class=\"line\">                LOGGER.warn(&quot;&quot;, e2);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure></p>\n<p>修改为<br><figure class=\"highlight plain\"><figcaption><span>(rtr !</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    Writer writer;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        writer = response.getWriter();</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">            String s = JSONUtil.objToJson(rtr);</span><br><span class=\"line\">            if (LOGGER.isDebugEnabled()) &#123;</span><br><span class=\"line\">                LOGGER.debug(&quot;SEND STR: &quot; + s);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            writer.write(s);</span><br><span class=\"line\">            writer.flush();</span><br><span class=\"line\">        &#125; catch (IOException e) &#123;</span><br><span class=\"line\">            LOGGER.warn(&quot;&quot;, e);</span><br><span class=\"line\">            if (writer != null) &#123;</span><br><span class=\"line\">                try &#123;</span><br><span class=\"line\">                    writer.write(JSONUtil.objToJson(rtr));</span><br><span class=\"line\">                &#125; catch (IOException e1) &#123;</span><br><span class=\"line\">                    LOGGER.warn(&quot;&quot;, e1);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    &#125; catch (IOException e2) &#123;</span><br><span class=\"line\">        LOGGER.warn(&quot;&quot;, e2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">    response.getWriter().write(&quot;&#123;\\&quot;errorCode\\&quot;:401&#125;&quot;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"7-RU-INVOKE-RUN\"><a href=\"#7-RU-INVOKE-RUN\" class=\"headerlink\" title=\"7. RU_INVOKE_RUN\"></a>7. RU_INVOKE_RUN</h4><p>com.cmcc.aoi.selfhelp.action.servlet.UploadTokensAction$TokenFileThread.run() explicitly invokes run on a thread (did you mean to start it instead?)<br>This method explicitly invokes run() on an object.  In general, classes implement the Runnable interface because they are going to have their run() method invoked in a new thread, in which case Thread.start() is the right method to call.</p>\n<p><code>ti.run();</code><br>修改为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try &#123;</span><br><span class=\"line\">    ti.join();</span><br><span class=\"line\">&#125; catch (InterruptedException e) &#123;</span><br><span class=\"line\">     e.printStackTrace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"8-NM-SAME-SIMPLE-NAME-AS-SUPERCLASS\"><a href=\"#8-NM-SAME-SIMPLE-NAME-AS-SUPERCLASS\" class=\"headerlink\" title=\"8. NM_SAME_SIMPLE_NAME_AS_SUPERCLASS\"></a>8. NM_SAME_SIMPLE_NAME_AS_SUPERCLASS</h4><p>The class name com.cmcc.aoi.selfhelp.dao.BaseDao shadows the simple name of the superclass org.slave4j.orm.hibernate.BaseDao<br>This class has a simple name that is identical to that of its superclass, except that its superclass is in a different package (e.g., alpha.Foo extends beta.Foo). This can be exceptionally confusing, create lots of situations in which you have to look at import statements to resolve references and creates many opportunities to accidentally define methods that do not override methods in their superclasses<br>com.cmcc.aoi.selfhelp.dao.BaseDao<br>修改为<br>com.cmcc.aoi.selfhelp.dao.BasisDao</p>\n<h4 id=\"9-SE-BAD-FIELD-INNER-CLASS\"><a href=\"#9-SE-BAD-FIELD-INNER-CLASS\" class=\"headerlink\" title=\"9. SE_BAD_FIELD_INNER_CLASS\"></a>9. SE_BAD_FIELD_INNER_CLASS</h4><p>com.cmcc.aoi.selfhelp.action.UploadFileAction$FileUploadStatus is serializable but also an inner class of a non-serializable class<br>This Serializable class is an inner class of a non-serializable class. Thus, attempts to serialize it will also attempt to associate instance of the outer class with which it is associated, leading to a runtime error.<br>If possible, making the inner class a static inner class should solve the problem. Making the outer class serializable might also work, but that would mean serializing an instance of the inner class would always also serialize the instance of the outer class, which it often not what you really want.<br>修改外部类<br>UploadFileAction extends BaseAction implements Serializable</p>\n<h4 id=\"10-DM-BOXED-PRIMITIVE-FOR-PARSING\"><a href=\"#10-DM-BOXED-PRIMITIVE-FOR-PARSING\" class=\"headerlink\" title=\"10. DM_BOXED_PRIMITIVE_FOR_PARSING\"></a>10. DM_BOXED_PRIMITIVE_FOR_PARSING</h4><p>Boxing/unboxing to parse a primitive com.cmcc.aoi.selfhelp.dao.StatAppEveryHourDao.findWeekList(String)<br>A boxed primitive is created from a String, just to extract the unboxed primitive value. It is more efficient to just call the static parseXXX method.</p>\n<figure class=\"highlight plain\"><figcaption><span>statAppEveryHour.setAccnumber(Integer.valueOf(String.valueOf(objects[3])));</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">```</span><br><span class=\"line\">修改为</span><br><span class=\"line\"></span><br><span class=\"line\">```statAppEveryHour.setStattime(sdf.parse(String.valueOf(objects[1])));</span><br><span class=\"line\">                    statAppEveryHour</span><br><span class=\"line\">                            .setNewnumber(Integer.parseInt(String.valueOf(objects[2]) != null</span><br><span class=\"line\">                                    &amp;&amp; !&quot;&quot;.equals(String.valueOf(objects[2]))</span><br><span class=\"line\">                                            ? String.valueOf(objects[2]) : &quot;0&quot;));</span><br><span class=\"line\">                    statAppEveryHour</span><br><span class=\"line\">                            .setAccnumber(Integer.parseInt(String.valueOf(objects[3]) != null</span><br><span class=\"line\">                                    &amp;&amp; !&quot;&quot;.equals(String.valueOf(objects[3]))</span><br><span class=\"line\">                                            ? String.valueOf(objects[3]) : &quot;0&quot;));</span><br></pre></td></tr></table></figure>\n<h3 id=\"Normal\"><a href=\"#Normal\" class=\"headerlink\" title=\"Normal\"></a>Normal</h3><h4 id=\"1-SBSC-USE-STRINGBUFFER-CONCATENATION\"><a href=\"#1-SBSC-USE-STRINGBUFFER-CONCATENATION\" class=\"headerlink\" title=\"1.SBSC_USE_STRINGBUFFER_CONCATENATION\"></a>1.SBSC_USE_STRINGBUFFER_CONCATENATION</h4><p>com.cmcc.aoi.httprequest.service.HttpRequest.sendGet(String, String) concatenates strings using + in a loop<br>The method seems to be building a String using concatenation in a loop. In each iteration, the String is converted to a StringBuffer/StringBuilder, appended to, and converted back to a String. This can lead to a cost quadratic in the number of iterations, as the growing string is recopied in each iteration.<br>Better performance can be obtained by using a StringBuffer (or StringBuilder in Java 1.5) explicitly.<br>For example:<br>  // This is bad<br>  String s = “”;<br>  for (int i = 0; i &lt; field.length; ++i) {<br>    s = s + field[i];<br>  }</p>\n<p>  // This is better<br>  StringBuffer buf = new StringBuffer();<br>  for (int i = 0; i &lt; field.length; ++i) {<br>    buf.append(field[i]);<br>  }<br>  String s = buf.toString();</p>\n<h4 id=\"2-WMI-WRONG-MAP-ITERATOR\"><a href=\"#2-WMI-WRONG-MAP-ITERATOR\" class=\"headerlink\" title=\"2. WMI_WRONG_MAP_ITERATOR\"></a>2. WMI_WRONG_MAP_ITERATOR</h4><figure class=\"highlight plain\"><figcaption><span>(String key : map.keySet()) &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">                System.out.println(key + &quot;---&gt;&quot; + map.get(key));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>改为</p>\n<figure class=\"highlight plain\"><figcaption><span>(  Map.Entry<string, list<string=\"\">> entry : map.entrySet()) &#123;</string,></span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">                System.out.println(entry.getKey() + &quot;---&gt;&quot; + entry.getValue());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">``` </span><br><span class=\"line\">#### 3.  EI_EXPOSE_REP</span><br><span class=\"line\">com.cmcc.aoi.selfhelp.entity.Activation.getValidUntil() may expose internal representation by returning Activation.validUntil</span><br><span class=\"line\">Returning a reference to a mutable object value stored in one of the object&apos;s fields exposes the internal representation of the object.  If instances are accessed by untrusted code, and unchecked changes to the mutable object would compromise security or other important properties, you will need to do something different. Returning a new copy of the object is better approach in many situations.</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">    public Date getValidUntil() &#123;</span><br><span class=\"line\">        returnvalidUntil;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">修改为</span><br><span class=\"line\">public Date getValidUntil() &#123;</span><br><span class=\"line\">        if(validUntil == null) &#123;</span><br><span class=\"line\">            returnnull;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return (Date) validUntil.clone();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">#### 4. EI_EXPOSE_REP2</span><br><span class=\"line\">com.cmcc.aoi.selfhelp.entity.Activation.setValidUntil(Date) may expose internal representation by storing an externally mutable object into Activation.validUntil</span><br><span class=\"line\">This code stores a reference to an externally mutable object into the internal representation of the object.  If instances are accessed by untrusted code, and unchecked changes to the mutable object would compromise security or other important properties, you will need to do something different. Storing a copy of the object is better approach in many situations.</span><br><span class=\"line\"></span><br><span class=\"line\">```publicvoid setValidUntil(Date validUntil) &#123;</span><br><span class=\"line\">this.validUntil = validUntil;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>修改为<br><figure class=\"highlight plain\"><figcaption><span>setValidUntil(Date validUntil) &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">        if(validUntil == null) &#123;</span><br><span class=\"line\">            this.validUntil = null;</span><br><span class=\"line\">        &#125;else &#123;</span><br><span class=\"line\">            this.validUntil = (Date) validUntil.clone();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">``` </span><br><span class=\"line\"> </span><br><span class=\"line\">#### 5. BC_VACUOUS_INSTANCEOF</span><br><span class=\"line\">instanceof will always return true for all non-null values in com.cmcc.aoi.selfhelp.entity.AppType.compareTo(AppType), since all com.cmcc.aoi.selfhelp.entity.AppType are instances of com.cmcc.aoi.selfhelp.entity.AppType</span><br><span class=\"line\">This instanceof test will always return true (unless the value being tested is null). Although this is safe, make sure it isn&apos;t an indication of some misunderstanding or some other logic error. If you really want to test the value for being null, perhaps it would be clearer to do better to do a null test rather than an instanceof test.</span><br><span class=\"line\"> </span><br><span class=\"line\">#### 6. MS_MUTABLE_ARRAY</span><br><span class=\"line\">com.cmcc.aoi.selfhelp.entity.DeviceType.CURRENTUSEDDEVICES is a mutable array</span><br><span class=\"line\">A final static field references an array and can be accessed by malicious code or by accident from another package. This code can freely modify the contents of the array.</span><br><span class=\"line\"> </span><br><span class=\"line\">public static final int[] CURRENTUSEDDEVICES = new int []&#123;Device.iOS.ordinal()，Device.Android.ordinal()，Device.WP.ordinal()&#125;；</span><br><span class=\"line\">修改为</span><br><span class=\"line\"> Public &gt; protected</span><br><span class=\"line\"> </span><br><span class=\"line\">#### 7. EQ_COMPARETO_USE_OBJECT_EQUALS</span><br><span class=\"line\">com.cmcc.aoi.selfhelp.entity.AppType defines compareTo(AppType) and uses Object.equals()</span><br><span class=\"line\">This class defines a compareTo(...) method but inherits its equals() method from java.lang.Object. Generally, the value of compareTo should return zero if and only if equals returns true. If this is violated, weird and unpredictable failures will occur in classes such as PriorityQueue. In Java 5 the PriorityQueue.remove method uses the compareTo method, while in Java 6 it uses the equals method.</span><br><span class=\"line\">From the JavaDoc for the compareTo method in the Comparable interface:</span><br><span class=\"line\">It is strongly recommended, but not strictly required that (x.compareTo(y)==0) == (x.equals(y)). Generally speaking, any class that implements the Comparable interface and violates this condition should clearly indicate this fact. The recommended language is &quot;Note: this class has a natural ordering that is inconsistent with equals.&quot;</span><br><span class=\"line\"> </span><br><span class=\"line\">修改</span><br><span class=\"line\">添加 hashcode() 和 equals() 代码即可</span><br><span class=\"line\"> </span><br><span class=\"line\">#### 8. BC_VACUOUS_INSTANCEOF</span><br><span class=\"line\">instanceof will always return true for all non-null values in com.cmcc.aoi.selfhelp.entity.AppType.compareTo(AppType), since all com.cmcc.aoi.selfhelp.entity.AppType are instances of com.cmcc.aoi.selfhelp.entity.AppType</span><br><span class=\"line\">This instanceof test will always return true (unless the value being tested is null). Although this is safe, make sure it isn&apos;t an indication of some misunderstanding or some other logic error. If you really want to test the value for being null, perhaps it would be clearer to do better to do a null test rather than an instanceof test.</span><br><span class=\"line\">  </span><br><span class=\"line\">```@Override</span><br><span class=\"line\">    publicint compareTo(AppType o) &#123;</span><br><span class=\"line\">        if (oinstanceof AppType) &#123;</span><br><span class=\"line\">            AppType p = (AppType) o;</span><br><span class=\"line\">            returnthis.typeId &gt; p.typeId ? 1 : this.typeId == p.typeId ? 0 : -1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">``` </span><br><span class=\"line\"></span><br><span class=\"line\">修改为</span><br><span class=\"line\">  </span><br><span class=\"line\">```@Override</span><br><span class=\"line\">    publicint compareTo(AppType o) &#123;</span><br><span class=\"line\">        if (null != o) &#123;</span><br><span class=\"line\">            AppType p  = (AppType) o ;</span><br><span class=\"line\">            returnthis.typeId &gt; p.typeId ? 1 : this.typeId == p.typeId ? 0 : -1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\"> </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">``` </span><br><span class=\"line\">#### 9. ME_ENUM_FIELD_SETTER</span><br><span class=\"line\">com.cmcc.aoi.selfhelp.dto.ActivationSituation.setSituation(String) unconditionally sets the field situation</span><br><span class=\"line\">This public method declared in public enum unconditionally sets enum field, thus this field can be changed by malicious code or by accident from another package. Though mutable enum fields may be used for lazy initialization, it&apos;s a bad practice to expose them to the outer world. Consider removing this method or declaring it package-private.</span><br><span class=\"line\">    publicvoid setCode(String code) &#123;</span><br><span class=\"line\">        this.code = code;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">修改</span><br><span class=\"line\"> 删除该无用代码</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\">#### 10.  IM_BAD_CHECK_FOR_ODD</span><br><span class=\"line\">Check for oddness that won&apos;t work for negative numbers in com.cmcc.aoi.selfhelp.dto.WebSendTextForm.toDeliverWebRequest()</span><br><span class=\"line\">The code uses x % 2 == 1 to check to see if a value is odd, but this won&apos;t work for negative numbers (e.g., (-5) % 2 == -1). If this code is intending to check for oddness, consider using x &amp; 1 == 1, or x % 2 != 0.</span><br><span class=\"line\"></span><br><span class=\"line\">```DeliverFactory</span><br><span class=\"line\">                                    .createTextOpenApp(this.msgtype, &quot;&quot;, this.content,</span><br><span class=\"line\">                                            this.isRingAndVibrate % 2 == 1,</span><br><span class=\"line\">                                            isRingAndVibrate / 2 &gt;= 1, this.activity)</span><br><span class=\"line\">                                    .toJsonString());</span><br><span class=\"line\"></span><br><span class=\"line\">``` </span><br><span class=\"line\">修改为</span><br><span class=\"line\"></span><br><span class=\"line\">```DeliverFactory</span><br><span class=\"line\">                                    .createTextOpenApp(this.msgtype, &quot;&quot;, this.content,</span><br><span class=\"line\">                                            this.isRingAndVibrate % 2 != 0,</span><br><span class=\"line\">                                            isRingAndVibrate / 2 &gt;= 1, this.activity)</span><br><span class=\"line\">                                    .toJsonString());</span><br><span class=\"line\"></span><br><span class=\"line\">``` </span><br><span class=\"line\"> </span><br><span class=\"line\">#### 11. MS_EXPOSE_REP</span><br><span class=\"line\">Public static com.cmcc.aoi.selfhelp.dict.DeviceSupported.getSupportedDevs() may expose internal representation by returning DeviceSupported.DEVS</span><br><span class=\"line\">A public static method returns a reference to an array that is part of the static state of the class. Any code that calls this method can freely modify the underlying array. One fix is to return a copy of the array.</span><br><span class=\"line\"></span><br><span class=\"line\">```public static Device[] getSupportedDevs() &#123;</span><br><span class=\"line\">        return DEVS;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>修改为</p>\n<figure class=\"highlight plain\"><figcaption><span>Device[] getSupportedDevs() &#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">        return DeviceSupported.DEVS.clone();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">``` </span><br><span class=\"line\">#### 12.URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD</span><br><span class=\"line\">Unread public/protected field: com.cmcc.aoi.selfhelp.dict.OperatorDict.countryCode</span><br><span class=\"line\">This field is never read.  The field is public or protected, so perhaps it is intended to be used with classes not seen as part of the analysis. If not, consider removing it from the class.</span><br><span class=\"line\">publicintcode;</span><br><span class=\"line\">    </span><br><span class=\"line\">```public String enName;</span><br><span class=\"line\">    public String cnName;</span><br><span class=\"line\">    public String countryCode;</span><br><span class=\"line\"> </span><br><span class=\"line\">    public OperatorDict() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    /**</span><br><span class=\"line\">     *</span><br><span class=\"line\">     * @param code</span><br><span class=\"line\">     *            运营商代码,一般是5位</span><br><span class=\"line\">     * @param enName</span><br><span class=\"line\">     *            英文名</span><br><span class=\"line\">     * @param countryCode</span><br><span class=\"line\">     *            国家英文代码</span><br><span class=\"line\">     * @param cnName</span><br><span class=\"line\">     *            中文名</span><br><span class=\"line\">     */</span><br><span class=\"line\">    public OperatorDict(intcode, String enName, String countryCode, String cnName) &#123;</span><br><span class=\"line\">        this.code = code;</span><br><span class=\"line\">        this.enName = enName;</span><br><span class=\"line\">        this.countryCode = countryCode;</span><br><span class=\"line\">        this.cnName = cnName == null ? Integer.toString(code) : cnName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">```修改为</span><br><span class=\"line\">Public  -》 private</span><br><span class=\"line\">  </span><br><span class=\"line\">#### 13. ES_COMPARING_STRINGS_WITH_EQ</span><br><span class=\"line\">Comparison of String objects using == or != in com.cmcc.aoi.selfhelp.entity.Provider.compareTo(Object)</span><br><span class=\"line\">This code compares java.lang.String objects for reference equality using the == or != operators. Unless both strings are either constants in a source file, or have been interned using the String.intern() method, the same string value may be represented by two different String objects. Consider using the equals(Object) method instead.</span><br><span class=\"line\"> </span><br><span class=\"line\">return this.spid.compareTo(p.spid) &gt; 0 ? 1 : this.spid == p.spid ? 0 : -1;</span><br><span class=\"line\">修改为</span><br><span class=\"line\">this.spid.compareTo(p.spid) &gt; 0 ? 1 : this.spid.equals(p.spid) ? 0 : -1;</span><br><span class=\"line\">14.DB_DUPLICATE_BRANCHES</span><br><span class=\"line\">com.cmcc.aoi.selfhelp.dao.ShStatTerminalDao.getListQuery(String, int, Date, Date, boolean, int) uses the same code for two branches</span><br><span class=\"line\">This method uses the same code to implement two branches of a conditional branch. Check to ensure that this isn&apos;t a coding mistake.</span><br><span class=\"line\"></span><br><span class=\"line\">```if (bool) &#123;</span><br><span class=\"line\">                query.setInteger(i++, nodeType);</span><br><span class=\"line\">                query.setInteger(i++, nodeType);</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                query.setInteger(i++, nodeType);</span><br><span class=\"line\">                query.setInteger(i++, nodeType);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">```修改为</span><br><span class=\"line\"></span><br><span class=\"line\">```query.setInteger(i++, nodeType);</span><br><span class=\"line\">query.setInteger(i++, nodeType);</span><br></pre></td></tr></table></figure>\n<h4 id=\"15-SE-COMPARATOR-SHOULD-BE-SERIALIZABLE\"><a href=\"#15-SE-COMPARATOR-SHOULD-BE-SERIALIZABLE\" class=\"headerlink\" title=\"15. SE_COMPARATOR_SHOULD_BE_SERIALIZABLE\"></a>15. SE_COMPARATOR_SHOULD_BE_SERIALIZABLE</h4><p>com.cmcc.aoi.selfhelp.task.entity.StatAppHabitComparator implements Comparator but not Serializable<br>This class implements the Comparator interface. You should consider whether or not it should also implement the Serializable interface. If a comparator is used to construct an ordered collection such as a TreeMap, then the TreeMap will be serializable only if the comparator is also serializable. As most comparators have little or no state, making them serializable is generally easy and good defensive programming.<br>修改为<br>implements Serializable</p>\n<h4 id=\"16-UWF-UNWRITTEN-PUBLIC-OR-PROTECTED-FIELD\"><a href=\"#16-UWF-UNWRITTEN-PUBLIC-OR-PROTECTED-FIELD\" class=\"headerlink\" title=\"16.  UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD\"></a>16.  UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD</h4><p>Unwritten public or protected field: com.cmcc.aoi.selfhelp.task.entity.StatDevice.keyname<br>No writes were seen to this public/protected field.  All reads of it will return the default value. Check for errors (should it have been initialized?), or remove it if it is useless.<br>Public  String keyname;<br>修改为<br>Private  String keyname;</p>\n<h4 id=\"18-RV-RETURN-VALUE-IGNORED-BAD-PRACTICE\"><a href=\"#18-RV-RETURN-VALUE-IGNORED-BAD-PRACTICE\" class=\"headerlink\" title=\"18.  RV_RETURN_VALUE_IGNORED_BAD_PRACTICE\"></a>18.  RV_RETURN_VALUE_IGNORED_BAD_PRACTICE</h4><p>Exceptional return value of java.io.File.mkdirs() ignored in com.cmcc.aoi.util.FileUtil.moveFile(File, String)<br>This method returns a value that is not checked. The return value should be checked since it can indicate an unusual or unexpected function execution. For example, the File.delete() method returns false if the file could not be successfully deleted (rather than throwing an Exception). If you don’t check the result, you won’t notice if the method invocation signals unexpected behavior by returning an atypical return value.<br>tmp.mkdirs()<br>修改为<br>booleanmkdirs = tmp.mkdirs();<br>logger.debug(“debug”,mkdirs);</p>\n<p>REC_CATCH_EXCEPTION<br>Exception is caught when Exception is not thrown in com.cmcc.aoi.selfhelp.task.fileparser.TokenIncrease.parseLine(String[])<br>This method uses a try-catch block that catches Exception objects, but Exception is not thrown within the try block, and RuntimeException is not explicitly caught. It is a common bug pattern to say try { … } catch (Exception e) { something } as a shorthand for catching a number of types of exception each of whose catch blocks is identical, but this construct also accidentally catches RuntimeException as well, masking potential bugs.<br>A better approach is to either explicitly catch the specific exceptions that are thrown, or to explicitly catch RuntimeException exception, rethrow it, and then catch all non-Runtime Exceptions, as shown below:</p>\n<figure class=\"highlight plain\"><figcaption><span>&#123;</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    ...</span><br><span class=\"line\">  &#125; catch (RuntimeException e) &#123;</span><br><span class=\"line\">    throw e;</span><br><span class=\"line\">  &#125; catch (Exception e) &#123;</span><br><span class=\"line\">    ... deal with all non-runtime exceptions ...</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">``` </span><br><span class=\"line\"> </span><br><span class=\"line\">#### 19. ICAST_IDIV_CAST_TO_DOUBLE</span><br><span class=\"line\">Integral division result cast to double or float in com.cmcc.aoi.selfhelp.service.BaseAnalysisService.getInterval(Date, Date, int)</span><br><span class=\"line\">This code casts the result of an integral division (e.g., int or long division) operation to double or float. Doing division on integers truncates the result to the integer value closest to zero. The fact that the result was cast to double suggests that this precision should have been retained. What was probably meant was to cast one or both of the operands to double before performing the division. </span><br><span class=\"line\">```Here is an example:</span><br><span class=\"line\">int x = 2;</span><br><span class=\"line\">int y = 5;</span><br><span class=\"line\">// Wrong: yields result 0.0</span><br><span class=\"line\">double value1 =  x / y;</span><br><span class=\"line\"> </span><br><span class=\"line\">// Right: yields result 0.4</span><br><span class=\"line\">double value2 =  x / (double) y;</span><br></pre></td></tr></table></figure>\n<h2 id=\"FindBugs规则整理\"><a href=\"#FindBugs规则整理\" class=\"headerlink\" title=\"FindBugs规则整理\"></a>FindBugs规则整理</h2><p>FindBugs是基于Bug Patterns概念，查找javabytecode（.class文件）中的潜在bug，主要检查bytecode中的bug patterns，如NullPoint空指针检查、没有合理关闭资源、字符串相同判断错（==，而不是equals）等</p>\n<h3 id=\"一、Security-关于代码安全性防护\"><a href=\"#一、Security-关于代码安全性防护\" class=\"headerlink\" title=\"一、Security 关于代码安全性防护\"></a>一、Security 关于代码安全性防护</h3><p>1.Dm: Hardcoded constant database password (DMI_CONSTANT_DB_PASSWORD)<br>代码中创建DB的密码时采用了写死的密码。<br>2.Dm: Empty database password (DMI_EMPTY_DB_PASSWORD)<br>创建数据库连接时没有为数据库设置密码，这会使数据库没有必要的保护。<br>3.HRS: HTTP cookie formed from untrusted input (HRS_REQUEST_PARAMETER_TO_COOKIE)<br>此代码使用不受信任的HTTP参数构造一个HTTP Cookie。<br>4.HRS: HTTP Response splitting vulnerability (HRS_REQUEST_PARAMETER_TO_HTTP_HEADER)<br>在代码中直接把一个HTTP的参数写入一个HTTP头文件中，它为HTTP的响应暴露了漏洞。<br>5.SQL: Nonconstant string passed to execute method on an SQL statement (SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE)<br>该方法以字符串的形式来调用SQLstatement的execute方法，它似乎是动态生成SQL语句的方法。这会更容易受到SQL注入攻击。<br>6.XSS: JSP reflected cross site scripting vulnerability (XSS_REQUEST_PARAMETER_TO_JSP_WRITER)<br>在代码中在JSP输出中直接写入一个HTTP参数，这会造成一个跨站点的脚本漏洞。</p>\n<h3 id=\"二、Experimental\"><a href=\"#二、Experimental\" class=\"headerlink\" title=\"二、Experimental\"></a>二、Experimental</h3><p>1.LG: Potential lost logger changes due to weak reference in OpenJDK (LG_LOST_LOGGER_DUE_TO_WEAK_REFERENCE)<br>OpenJDK的引入了一种潜在的不兼容问题，特别是，java.util.logging.Logger的行为改变时。它现在使用内部弱引用，而不是强引用。–logger配置改变，它就是丢失对logger的引用，这本是一个合理的变化，但不幸的是一些代码对旧的行为有依赖关系。这意味着，当进行垃圾收集时对logger配置将会丢失。例如：<br>public static void initLogging() throws Exception {<br> Logger logger = Logger.getLogger(“edu.umd.cs”);<br> logger.addHandler(new FileHandler()); // call to change logger configuration<br> logger.setUseParentHandlers(false); // another call to change logger configuration<br>}<br>该方法结束时logger的引用就丢失了，如果你刚刚结束调用initLogging方法后进行垃圾回收，logger的配置将会丢失（因为只有保持记录器弱引用）。<br>public static void main(String[] args) throws Exception {<br> initLogging(); // adds a file handler to the logger<br> System.gc(); // logger configuration lost<br> Logger.getLogger(“edu.umd.cs”).info(“Some message”); // this isn’t logged to the file as expected<br>}<br>2.OBL: Method may fail to clean up stream or resource (OBL_UNSATISFIED_OBLIGATION)<br>这种方法可能无法清除（关闭，处置）一个流，数据库对象，或其他资源需要一个明确的清理行动。<br>一般来说，如果一个方法打开一个流或其他资源，该方法应该使用try / finally块来确保在方法返回之前流或资源已经被清除了。这种错误模式基本上和OS_OPEN_STREAM和ODR_OPEN_DATABASE_RESOURCE错误模式相同，但是是在不同在静态分析技术。我们正为这个错误模式的效用收集反馈意见。</p>\n<h3 id=\"三、Bad-practice代码实现中的一些坏习惯\"><a href=\"#三、Bad-practice代码实现中的一些坏习惯\" class=\"headerlink\" title=\"三、Bad practice代码实现中的一些坏习惯\"></a>三、Bad practice代码实现中的一些坏习惯</h3><p>1.AM: Creates an empty jar file entry (AM_CREATES_EMPTY_JAR_FILE_ENTRY)<br>调用putNextEntry()方法写入新的 jar 文件条目时立即调用closeEntry()方法。这样会造成JarFile条目为空。<br>2.AM: Creates an empty zip file entry (AM_CREATES_EMPTY_ZIP_FILE_ENTRY)<br>调用putNextEntry()方法写入新的 zip 文件条目时立即调用closeEntry()方法。这样会造成ZipFile条目为空。<br>3.BC: Equals method should not assume anything about the type of its argument (BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS)<br>equals(Object o)方法不能对参数o的类型做任何的假设。比较此对象与指定的对象。当且仅当该参数不为 null，并且是表示与此对象相同的类型的对象时，结果才为 true。<br>4.BC: Random object created and used only once (DMI_RANDOM_USED_ONLY_ONCE)<br>随机创建对象只使用过一次就抛弃<br>5.BIT: Check for sign of bitwise operation (BIT_SIGNED_CHECK)<br>检查位操作符运行是否合理<br>((event.detail &amp; SWT.SELECTED) &gt; 0)<br>If SWT.SELECTED is a negative number, this is a candidate for a bug. Even when SWT.SELECTED is not negative, it seems good practice to use ‘!= 0’ instead of ‘&gt; 0’.<br>6.CN: Class implements Cloneable but does not define or use clone method (CN_IDIOM)<br>按照惯例，实现此接口的类应该使用公共方法重写 Object.clone（它是受保护的），以获得有关重写此方法的详细信息。此接口不 包含 clone 方法。因此，因为某个对象实现了此接口就克隆它是不可能的,应该实现此接口的类应该使用公共方法重写 Object.clone<br>7.CN: clone method does not call super.clone() (CN_IDIOM_NO_SUPER_CALL)<br>一个非final类型的类定义了clone()方法而没有调用super.clone()方法。例如：B扩展自A，如果B中clone方法调用了spuer.clone（），而A中的clone没有调用spuer.clone()，就会造成结果类型不准确。要求A的clone方法中调用spuer.clone()方法。<br>8.CN: Class defines clone() but doesn’t implement Cloneable (CN_IMPLEMENTS_CLONE_BUT_NOT_CLONEABLE)<br>类中定义了clone方法但是它没有实现Cloneable接口<br>9.Co: Abstract class defines covariant compareTo() method (CO_ABSTRACT_SELF)<br>抽象类中定义了多个compareTo()方法，正确的是覆写Comparable中的compareTo方法，方法的参数为Object类型，如下例：<br>int compareTo(T o)  比较此对象与指定对象的顺序。<br>10.Co: Covariant compareTo() method defined (CO_SELF_NO_OBJECT)<br>类中定义了多个compareTo()方法，正确的是覆写Comparable中的compareTo方法，方法的参数为Object类型<br>11.DE: Method might drop exception (DE_MIGHT_DROP)<br>方法可能抛出异常<br>12.DE: Method might ignore exception (DE_MIGHT_IGNORE)<br>方法可能忽略异常<br>13.DMI: Don’t use removeAll to clear a collection (DMI_USING_REMOVEALL_TO_CLEAR_COLLECTION)<br>不要用removeAll方法去clear一个集合<br>14.DP: Classloaders should only be created inside doPrivileged block (DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED)<br>类加载器只能建立在特殊的方法体内<br>15.Dm: Method invokes System.exit(…) (DM_EXIT)<br>在方法中调用System.exit(…)语句，考虑用RuntimeException来代替<br>16.Dm: Method invokes dangerous method runFinalizersOnExit (DM_RUN_FINALIZERS_ON_EXIT)<br>在方法中调用了System.runFinalizersOnExit 或者Runtime.runFinalizersOnExit方法，因为这样做是很危险的。<br>17.ES: Comparison of String parameter using == or != (ES_COMPARING_PARAMETER_STRING_WITH_EQ)<br>用==或者!=方法去比较String类型的参数<br>18.ES: Comparison of String objects using == or != (ES_COMPARING_STRINGS_WITH_EQ)<br>用==或者！=去比较String类型的对象<br>19.Eq: Abstract class defines covariant equals() method (EQ_ABSTRACT_SELF)<br>20.Eq: Equals checks for noncompatible operand (EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS)<br>equals方法检查不一致的操作。两个类根本就是父子关系而去调用equals方法去判读对象是否相等。<br>public boolean equals(Object o) {<br>  if (o instanceof Foo)<br>    return name.equals(((Foo)o).name);<br>  else if (o instanceof String)<br>    return name.equals(o);<br>  else return false;<br>21.Eq: Class defines compareTo(…) and uses Object.equals() (EQ_COMPARETO_USE_OBJECT_EQUALS)<br>类中定义了compareTo方法但是继承了Object中的compareTo方法<br>22.Eq: equals method fails for subtypes (EQ_GETCLASS_AND_CLASS_CONSTANT)<br>类中的equals方法可能被子类中的方法所破坏，当使用类似于Foo.class == o.getClass()的判断时考虑用this.getClass() == o.getClass()来替换<br>23.Eq: Covariant equals() method defined (EQ_SELF_NO_OBJECT)<br>类中定义了多个equals方法。正确的做法是覆写Object中的equals方法，它的参数为Object类型的对象。<br>24.FI: Empty finalizer should be deleted (FI_EMPTY)<br>为空的finalizer方法应该删除。一下关于finalizer的内容省略<br>25.GC: Unchecked type in generic call (GC_UNCHECKED_TYPE_IN_GENERIC_CALL)<br>This call to a generic collection method passes an argument while compile type Object where a specific type from the generic type parameters is expected. Thus, neither the standard Java type system nor static analysis can provide useful information on whether the object being passed as a parameter is of an appropriate type.<br>26.HE: Class defines equals() but not hashCode() (HE_EQUALS_NO_HASHCODE)<br>方法定义了equals方法却没有定义hashCode方法<br>27.HE: Class defines hashCode() but not equals() (HE_HASHCODE_NO_EQUALS)<br> 类定义了hashCode方法去没有定义equal方法<br>28.HE: Class defines equals() and uses Object.hashCode() (HE_EQUALS_USE_HASHCODE)<br>一个类覆写了equals方法，没有覆写hashCode方法，使用了Object对象的hashCode方法<br>29.HE: Class inherits equals() and uses Object.hashCode() (HE_INHERITS_EQUALS_USE_HASHCODE)<br>子类继承了父类的equals方法却使用了Object的hashCode方法<br>30.IC: Superclass uses subclass during initialization (IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION)<br>子类在父类未初始化之前使用父类对象实例<br>public class CircularClassInitialization {<br>        static class InnerClassSingleton extends CircularClassInitialization {<br>static InnerClassSingleton singleton = new InnerClassSingleton();<br>        }<br>        static CircularClassInitialization foo = InnerClassSingleton.singleton;<br>}<br>31.IMSE: Dubious catching of IllegalMonitorStateException (IMSE_DONT_CATCH_IMSE)<br>捕捉违法的监控状态异常，例如当没有获取到对象锁时使用其wait和notify方法<br>32.ISC: Needless instantiation of class that only supplies static methods (ISC_INSTANTIATE_STATIC_CLASS)<br>为使用静态方法而创建一个实例对象。调用静态方法时只需要使用类名+静态方法名就可以了。<br>33.It: Iterator next() method can’t throw NoSuchElementException (IT_NO_SUCH_ELEMENT)<br>迭代器的next方法不能够抛出NoSuchElementException<br>34.J2EE: Store of non serializable object into HttpSession (J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION)<br>在HttpSession对象中保存非连续的对象<br>35.JCIP: Fields of immutable classes should be final (JCIP_FIELD_ISNT_FINAL_IN_IMMUTABLE_CLASS)<br> The class is annotated with net.jcip.annotations.Immutable, and the rules for that annotation require that all fields are final. .<br>36.NP: Method with Boolean return type returns explicit null (NP_BOOLEAN_RETURN_NULL)<br>返回值为boolean类型的方法直接返回null，这样会导致空指针异常<br>37.NP: equals() method does not check for null argument (NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT)<br>变量调用equals方法时没有进行是否为null的判断<br>38.NP: toString method may return null (NP_TOSTRING_COULD_RETURN_NULL)<br>toString方法可能返回null<br>39.Nm: Class names should start with an upper case letter (NM_CLASS_NAMING_CONVENTION)<br>类的名称以大写字母名称开头<br>40.Nm: Class is not derived from an Exception, even though it is named as such (NM_CLASS_NOT_EXCEPTION)<br>类的名称中含有Exception但是却不是一个异常类的子类，这种名称会造成混淆<br>41.Nm: Confusing method names (NM_CONFUSING)<br>令人迷惑的方面命名<br>42.Nm: Field names should start with a lower case letter (NM_FIELD_NAMING_CONVENTION)<br>非final类型的字段需要遵循驼峰命名原则<br>43.Nm: Use of identifier that is a keyword in later versions of Java (NM_FUTURE_KEYWORD_USED_AS_IDENTIFIER)<br>验证是否是java预留关键字<br>44.Nm: Use of identifier that is a keyword in later versions of Java (NM_FUTURE_KEYWORD_USED_AS_MEMBER_IDENTIFIER)<br>验证是否时java中的关键字<br>45.Nm: Method names should start with a lower case letter (NM_METHOD_NAMING_CONVENTION)<br>方法名称以小写字母开头<br>46.Nm: Class names shouldn’t shadow simple name of implemented interface (NM_SAME_SIMPLE_NAME_AS_INTERFACE)<br>实现同一接口实现类不能使用相同的名称，即使它们位于不同的包中<br>47.Nm: Class names shouldn’t shadow simple name of superclass (NM_SAME_SIMPLE_NAME_AS_SUPERCLASS)<br>继承同一父类的子类不能使用相同的名称，即使它们位于不同的包中<br>48.Nm: Very confusing method names (but perhaps intentional) (NM_VERY_CONFUSING_INTENTIONAL)<br>很容易混淆的方法命名，例如方法的名称名称使用使用大小写来区别两个不同的方法。<br>49.Nm: Method doesn’t override method in superclass due to wrong package for parameter (NM_WRONG_PACKAGE_INTENTIONAL)<br>由于错误引用了不同包中相同类名的对象而不能够正确的覆写父类中的方法<br>import alpha.Foo;<br>public class A {<br>  public int f(Foo x) { return 17; }<br>}<br>import beta.Foo;<br>public class B extends A {<br>  public int f(Foo x) { return 42; }<br>  public int f(alpha.Foo x) { return 27; }<br>}<br>50.ODR: Method may fail to close database resource (ODR_OPEN_DATABASE_RESOURCE)<br>方法中可能存在关闭数据连接失败的情况<br>51.OS: Method may fail to close stream (OS_OPEN_STREAM)<br>方法中可能存在关闭流失败的情况<br>52.OS: Method may fail to close stream on exception (OS_OPEN_STREAM_EXCEPTION_PATH)<br>方法中可能存在关闭流时出现异常情况<br>53.RC: Suspicious reference comparison to constant (RC_REF_COMPARISON_BAD_PRACTICE)<br>当两者为不同类型的对象时使用equals方法来比较它们的值是否相等，而不是使用==方法。例如比较的两者为java.lang.Integer, java.lang.Float<br>54.RC: Suspicious reference comparison of Boolean values (RC_REF_COMPARISON_BAD_PRACTICE_BOOLEAN)<br>使用== 或者 !=操作符来比较两个 Boolean类型的对象，建议使用equals方法。<br>55.RR: Method ignores results of InputStream.read() (RR_NOT_CHECKED)<br>InputStream.read方法忽略返回的多个字符，如果对结果没有检查就没法正确处理用户读取少量字符请求的情况。<br>56.RR: Method ignores results of InputStream.skip() (SR_NOT_CHECKED)<br>InputStream.skip()方法忽略返回的多个字符，如果对结果没有检查就没法正确处理用户跳过少量字符请求的情况<br>57.RV: Method ignores exceptional return value (RV_RETURN_VALUE_IGNORED_BAD_PRACTICE)<br>方法忽略返回值的异常信息<br>58.SI: Static initializer creates instance before all static final fields assigned (SI_INSTANCE_BEFORE_FINALS_ASSIGNED)<br>在所有的static final字段赋值之前去使用静态初始化的方法创建一个类的实例。<br>59.Se: Non-serializable value stored into instance field of a serializable class (SE_BAD_FIELD_STORE)<br>非序列化的值保存在声明为序列化的的非序列化字段中<br>60.Se: Comparator doesn’t implement Serializable (SE_COMPARATOR_SHOULD_BE_SERIALIZABLE)<br>Comparator接口没有实现Serializable接口<br>61.Se: Serializable inner class (SE_INNER_CLASS)<br>序列化内部类<br>62.Se: serialVersionUID isn’t final (SE_NONFINAL_SERIALVERSIONID)<br>关于UID类的检查内容省略<br>63.Se: Class is Serializable but its superclass doesn’t define a void constructor (SE_NO_SUITABLE_CONSTRUCTOR)<br>子类序列化时父类没有提供一个void的构造函数<br>64.Se: Class is Externalizable but doesn’t define a void constructor (SE_NO_SUITABLE_CONSTRUCTOR_FOR_EXTERNALIZATION)<br>Externalizable 实例类没有定义一个void类型的构造函数<br>65.Se: The readResolve method must be declared with a return type of Object. (SE_READ_RESOLVE_MUST_RETURN_OBJECT)<br>readResolve从流中读取类的一个实例，此方法必须声明返回一个Object类型的对象<br>66.Se: Transient field that isn’t set by deserialization. (SE_TRANSIENT_FIELD_NOT_RESTORED)<br>This class contains a field that is updated at multiple places in the class, thus it seems to be part of the state of the class. However, since the field is marked as transient and not set in readObject or readResolve, it will contain the default value in any deserialized instance of the class.<br>67.SnVI: Class is Serializable, but doesn’t define serialVersionUID (SE_NO_SERIALVERSIONID)<br>一个类实现了Serializable接口但是没有定义serialVersionUID类型的变量。序列化运行时使用一个称为 serialVersionUID 的版本号与每个可序列化类相关联，该序列号在反序列化过程中用于验证序列化对象的发送者和接收者是否为该对象加载了与序列化兼容的类。如果接收者加载的该对象的类的 serialVersionUID 与对应的发送者的类的版本号不同，则反序列化将会导致 InvalidClassException。可序列化类可以通过声明名为 “serialVersionUID” 的字段（该字段必须是静态 (static)、最终 (final) 的 long 型字段）显式声明其自己的 serialVersionUID：<br> ANY-ACCESS-MODIFIER static final long serialVersionUID = 42L;<br>68.UI: Usage of GetResource may be unsafe if class is extended (UI_INHERITANCE_UNSAFE_GETRESOURCE)<br>当一个类被子类继承后不要使用this.getClass().getResource(…)来获取资源</p>\n<h3 id=\"四、Correctness关于代码正确性相关方面的\"><a href=\"#四、Correctness关于代码正确性相关方面的\" class=\"headerlink\" title=\"四、Correctness关于代码正确性相关方面的\"></a>四、Correctness关于代码正确性相关方面的</h3><p>1.BC: Impossible cast (BC_IMPOSSIBLE_CAST)<br>不可能的类转换，执行时会抛出ClassCastException<br>2.BC: Impossible downcast (BC_IMPOSSIBLE_DOWNCAST)<br>父类在向下进行类型转换时抛出ClassCastException<br>3.BC: Impossible downcast of toArray() result (BC_IMPOSSIBLE_DOWNCAST_OF_TOARRAY)<br>集合转换为数组元素时发生的类转换错误。<br>This code is casting the result of calling toArray() on a collection to a type more specific than Object[], as in:<br>String[] getAsArray(Collection<string> c) {<br>  return (String[]) c.toArray();<br>  }<br>This will usually fail by throwing a ClassCastException. The toArray() of almost all collections return an Object[]. They can’t really do anything else, since the Collection object has no reference to the declared generic type of the collection.<br>The correct way to do get an array of a specific type from a collection is to use c.toArray(new String[]); or c.toArray(new String[c.size()]); (the latter is slightly more efficient).<br>4.BC: instanceof will always return false (BC_IMPOSSIBLE_INSTANCEOF)<br>采用instaneof方法进行比较时总是返回false。前提是保证它不是由于某些逻辑错误造成的。<br>5.BIT: Incompatible bit masks (BIT_AND)<br>错误的使用&amp;位操作符，例如(e &amp; C)<br>6.BIT: Check to see if ((…) &amp; 0) == 0 (BIT_AND_ZZ)<br>检查恒等的逻辑错误<br>7.BIT: Incompatible bit masks (BIT_IOR)<br>错误的使用|位操作符，例如(e | C)<br>8.BIT: Check for sign of bitwise operation (BIT_SIGNED_CHECK_HIGH_BIT)<br>检查逻辑运算符操作返回的标识。例如((event.detail &amp; SWT.SELECTED) &gt; 0)，建议采用!=0代替&gt;0<br>9.BOA: Class overrides a method implemented in super class Adapter wrongly (BOA_BADLY_OVERRIDDEN_ADAPTER)<br>子类错误的覆写父类中用于适配监听其他事件的方法，从而导致当触发条件发生时不能被监听者调用<br>10.Bx: Primitive value is unboxed and coerced for ternary operator (BX_UNBOXED_AND_COERCED_FOR_TERNARY_OPERATOR)<br>在三元运算符操作时如果没有对值进行封装或者类型转换。例如：b ? e1 : e2<br>11.DLS: Dead store of class literal (DLS_DEAD_STORE_OF_CLASS_LITERAL)<br>以类的字面名称方式为一个字段赋值后再也没有去使用它，在1.4jdk中它会自动调用静态的初始化方法，而在jdk1.5中却不会去执行。<br>12.DLS: Overwritten increment (DLS_OVERWRITTEN_INCREMENT)<br>覆写增量增加错误i = i++<br>13.DMI: Bad constant value for month (DMI_BAD_MONTH)<br>hashNext方法调用next方法。<br>14.DMI: Collections should not contain themselves (DMI_COLLECTIONS_SHOULD_NOT_CONTAIN_THEMSELVES)<br>集合没有包含他们自己本身。<br>15.DMI: Invocation of hashCode on an array (DMI_INVOKING_HASHCODE_ON_ARRAY)<br>数组直接使用hashCode方法来返回哈希码。<br>int [] a1 = new int[]{1,2,3,4};<br>        System.out.println(a1.hashCode());<br>        System.out.println(java.util.Arrays.hashCode(a1));<br>16.DMI: Double.longBitsToDouble invoked on an int (DMI_LONG_BITS_TO_DOUBLE_INVOKED_ON_INT)<br>17.DMI: Vacuous call to collections (DMI_VACUOUS_SELF_COLLECTION_CALL)<br>集合的调用不能被感知。例如c.containsAll(c)总是返回true，而c.retainAll(c)的返回值不能被感知。<br>18.Dm: Can’t use reflection to check for presence of annotation without runtime retention (DMI_ANNOTATION_IS_NOT_VISIBLE_TO_REFLECTION)<br>Unless an annotation has itself been annotated with @Retention(RetentionPolicy.RUNTIME), the annotation can’t be observed using reflection (e.g., by using the isAnnotationPresent method). .<br>19.Dm: Useless/vacuous call to EasyMock method (DMI_VACUOUS_CALL_TO_EASYMOCK_METHOD)<br>While ScheduledThreadPoolExecutor inherits from ThreadPoolExecutor, a few of the inherited tuning methods are not useful for it. In particular, because it acts as a fixed-sized pool using corePoolSize threads and an unbounded queue, adjustments to maximumPoolSize have no useful effect.<br>20.EC: equals() used to compare array and nonarray (EC_ARRAY_AND_NONARRAY)<br>数组对象使用equals方法和非数组对象进行比较。即使比较的双方都是数组对象也不应该使用equals方法，而应该比较它们的内容是否相等使用java.util.Arrays.equals(Object[], Object[]);<br>21.EC: equals(…) used to compare incompatible arrays (EC_INCOMPATIBLE_ARRAY_COMPARE)<br>使用equls方法去比较类型不相同的数组。例如：String[] and StringBuffer[], or String[] and int[]<br>22.EC: Call to equals() with null argument (EC_NULL_ARG)<br>调用equals的对象为null<br>23.EC: Call to equals() comparing unrelated class and interface (EC_UNRELATED_CLASS_AND_INTERFACE)<br>使用equals方法比较不相关的类和接口<br>24.EC: Call to equals() comparing different interface types (EC_UNRELATED_INTERFACES)<br>调用equals方法比较不同类型的接口<br>25.EC: Call to equals() comparing different types (EC_UNRELATED_TYPES)<br>调用equals方法比较不同类型的类<br>26.EC: Using pointer equality to compare different types (EC_UNRELATED_TYPES_USING_POINTER_EQUALITY)<br>This method uses using pointer equality to compare two references that seem to be of different types. The result of this comparison will always be false at runtime.<br>27.Eq: equals method always returns false (EQ_ALWAYS_FALSE)<br>使用equals方法返回值总是false<br>28.Eq: equals method always returns true (EQ_ALWAYS_TRUE)<br>equals方法返回值总是true<br>29.Eq: equals method compares class names rather than class objects (EQ_COMPARING_CLASS_NAMES)<br>使用equals方法去比较一个类的实例和类的类型<br>30.Eq: Covariant equals() method defined for enum (EQ_DONT_DEFINE_EQUALS_FOR_ENUM)<br>This class defines an enumeration, and equality on enumerations are defined using object identity. Defining a covariant equals method for an enumeration value is exceptionally bad practice, since it would likely result in having two different enumeration values that compare as equals using the covariant enum method, and as not equal when compared normally. Don’t do it.<br>31.Eq: equals() method defined that doesn’t override equals(Object) (EQ_OTHER_NO_OBJECT)<br>类中定义的equals方法时不要覆写equals（Object）方法<br>32.Eq: equals() method defined that doesn’t override Object.equals(Object) (EQ_OTHER_USE_OBJECT)<br>类中定义的equals方法时不要覆写Object中的equals（Object）方法<br>33.Eq: equals method overrides equals in superclass and may not be symmetric (EQ_OVERRIDING_EQUALS_NOT_SYMMETRIC)<br>34.Eq: Covariant equals() method defined, Object.equals(Object) inherited (EQ_SELF_USE_OBJECT)<br>类中定义了一组equals方法，但是都是继承的java.lang.Object class中的equals(Object)方法<br>35.FE: Doomed test for equality to NaN (FE_TEST_IF_EQUAL_TO_NOT_A_NUMBER)<br>This code checks to see if a floating point value is equal to the special Not A Number value (e.g., if (x == Double.NaN)). However, because of the special semantics of NaN, no value is equal to Nan, including NaN. Thus, x == Double.NaN always evaluates to false. To check to see if a value contained in x is the special Not A Number value, use Double.isNaN(x) (or Float.isNaN(x) if x is floating point precision).<br>36.FS: Format string placeholder incompatible with passed argument (VA_FORMAT_STRING_BAD_ARGUMENT)<br>错误使用参数类型来格式化字符串<br>37.FS: The type of a supplied argument doesn’t match format specifier (VA_FORMAT_STRING_BAD_CONVERSION)<br>指定的格式字符串和参数类型不匹配，例如：String.format(“%d”, “1”)<br>38.FS: MessageFormat supplied where printf style format expected (VA_FORMAT_STRING_EXPECTED_MESSAGE_FORMAT_SUPPLIED)<br>但用String的format方法时实际调用了ＭｅｓｓａｇｅＦｏｒｍａｔ中干的格式化方法而引起格式化结果出错。<br>39.FS: More arguments are passed than are actually used in the format string (VA_FORMAT_STRING_EXTRA_ARGUMENTS_PASSED)<br>使用String的format方法时有非法的参数也经过了格式化操作。<br>40.FS: Illegal format string (VA_FORMAT_STRING_ILLEGAL)<br>格式化String对象语句错误<br>41.FS: Format string references missing argument (VA_FORMAT_STRING_MISSING_ARGUMENT)<br>String的format操作缺少必要的参数。<br>42.FS: No previous argument for format string (VA_FORMAT_STRING_NO_PREVIOUS_ARGUMENT)<br>格式字符串定义错误，例如：formatter.format(“%&lt;s %s”, “a”, “b”); 抛出MissingFormatArgumentException异常<br>43.GC: No relationship between generic parameter and method argument (GC_UNRELATED_TYPES)<br>This call to a generic collection method contains an argument with an incompatible class from that of the collection’s parameter (i.e., the type of the argument is neither a supertype nor a subtype of the corresponding generic type argument). Therefore, it is unlikely that the collection contains any objects that are equal to the method argument used here. Most likely, the wrong value is being passed to the method.<br>In general, instances of two unrelated classes are not equal. For example, if the Foo and Bar classes are not related by subtyping, then an instance of Foo should not be equal to an instance of Bar. Among other issues, doing so will likely result in an equals method that is not symmetrical. For example, if you define the Foo class so that a Foo can be equal to a String, your equals method isn’t symmetrical since a String can only be equal to a String.<br>In rare cases, people do define nonsymmetrical equals methods and still manage to make their code work. Although none of the APIs document or guarantee it, it is typically the case that if you check if a Collection<string> contains a Foo, the equals method of argument (e.g., the equals method of the Foo class) used to perform the equality checks.<br>44.HE: Signature declares use of unhashable class in hashed construct (HE_SIGNATURE_DECLARES_HASHING_OF_UNHASHABLE_CLASS)<br>A method, field or class declares a generic signature where a non-hashable class is used in context where a hashable class is required. A class that declares an equals method but inherits a hashCode() method from Object is unhashable, since it doesn’t fulfill the requirement that equal objects have equal hashCodes.<br>45.HE: Use of class without a hashCode() method in a hashed data structure (HE_USE_OF_UNHASHABLE_CLASS)<br>A class defines an equals(Object) method but not a hashCode() method, and thus doesn’t fulfill the requirement that equal objects have equal hashCodes. An instance of this class is used in a hash data structure, making the need to fix this problem of highest importance.<br>46.ICAST: integral value cast to double and then passed to Math.ceil (ICAST_INT_CAST_TO_DOUBLE_PASSED_TO_CEIL)<br>integral的值转换为double后使用了Math.ceil方法<br>47.ICAST: int value cast to float and then passed to Math.round (ICAST_INT_CAST_TO_FLOAT_PASSED_TO_ROUND)<br>int 类型的值转换为float类型之后调用了Math.round方法<br>48.IJU: JUnit assertion in run method will not be noticed by JUnit (IJU_ASSERT_METHOD_INVOKED_FROM_RUN_METHOD)<br>在JUnit中的断言在run方法中不会被告知<br>49.IJU: TestCase declares a bad suite method (IJU_BAD_SUITE_METHOD)<br>在一个JUnit类中声明的一个suite()方法必须声明为<br>public static junit.framework.Test suite()<br>或者<br>public static junit.framework.TestSuite suite()的形式。<br>50.IL: A collection is added to itself (IL_CONTAINER_ADDED_TO_ITSELF)<br>集合本身作为add方法的参数，这样会引起内容溢出。<br>51.IL: An apparent infinite loop (IL_INFINITE_LOOP)<br>方法的自调用引起的死循环<br>52.IM: Integer multiply of result of integer remainder (IM_MULTIPLYING_RESULT_OF_IREM)<br>和整数余数进行乘法运算。例如：i % 60 <em> 1000 是进行(i % 60) </em> 1000运算而不是 i % (60 * 1000)<br>53.INT: Bad comparison of nonnegative value with negative constant (INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE)<br>保证非负数和负数进行比较<br>54.INT: Bad comparison of signed byte (INT_BAD_COMPARISON_WITH_SIGNED_BYTE)<br>比较有符合数，要先把有符号数转换为无符合数再进行比较<br>55.IO: Doomed attempt to append to an object output stream (IO_APPENDING_TO_OBJECT_OUTPUT_STREAM)<br>宣布试图在对象的输出流处添加元素，如果你希望能够添加进一个对象的输出流中必须保证对象的输出流处于打开状态。<br>56.IP: A parameter is dead upon entry to a method but overwritten (IP_PARAMETER_IS_DEAD_BUT_OVERWRITTEN)<br>The initial value of this parameter is ignored, and the parameter is overwritten here. This often indicates a mistaken belief that the write to the parameter will be conveyed back to the caller.<br>传入参数的值被忽略，但是对传入值进行了修改，并返回给了调用者<br>57.MF: Class defines field that masks a superclass field (MF_CLASS_MASKS_FIELD)<br>子类中定义了和父类中同名的字段。在调用时会出错<br>58.MF: Method defines a variable that obscures a field (MF_METHOD_MASKS_FIELD)<br>在方法中定义的局部变量和类变量或者父类变量同名，从而引起字段混淆。<br>59.NP: Null pointer dereference (NP_ALWAYS_NULL)<br>对象赋为null值后 没有被重新赋值<br>60.NP: Null pointer dereference in method on exception path (NP_ALWAYS_NULL_EXCEPTION)<br>A pointer which is null on an exception path is dereferenced here.  This will lead to a NullPointerException when the code is executed.  Note that because FindBugs currently does not prune infeasible exception paths, this may be a false warning.<br>Also note that FindBugs considers the default case of a switch statement to be an exception path, since the default case is often infeasible.<br>空指针引用上调用去除引用方法，将发生空指针异常<br>61.NP: Method does not check for null argument (NP_ARGUMENT_MIGHT_BE_NULL)<br>方法没有判断参数是否为空<br>62.NP: close() invoked on a value that is always null (NP_CLOSING_NULL)<br>一个为空的对象调用close方法<br>63.NP: Null value is guaranteed to be dereferenced (NP_GUARANTEED_DEREF)<br>There is a statement or branch that if executed guarantees that a value is null at this point, and that value that is guaranteed to be dereferenced (except on forward paths involving runtime exceptions).<br>在正常的null判断分支上，对象去除引用操作是受保护的不允许的<br>64.NP: Value is null and guaranteed to be dereferenced on exception path (NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH)<br>There is a statement or branch on an exception path that if executed guarantees that a value is null at this point, and that value that is guaranteed to be dereferenced (except on forward paths involving runtime exceptions).<br>65.NP: Method call passes null to a nonnull parameter (NP_NONNULL_PARAM_VIOLATION)<br>方法中为null的参数没有被重新赋值<br>        void test(){<br>String ss = null;<br>sya(ss);<br>        }<br>        public void sya(String ad){<br>ad.getBytes();<br>        }<br>66.NP: Method may return null, but is declared @NonNull (NP_NONNULL_RETURN_VIOLATION)<br>方法声明了返回值不能为空，但是方法中有可能返回null<br>67.NP: A known null value is checked to see if it is an instance of a type (NP_NULL_INSTANCEOF)<br>检查一个为null的值是否是想要的类型对象，而不是由于粗心或者逻辑错误引起的<br>68.NP: Possible null pointer dereference (NP_NULL_ON_SOME_PATH)<br>对象可能没有重新赋值<br>69.NP: Possible null pointer dereference in method on exception path (NP_NULL_ON_SOME_PATH_EXCEPTION)<br>A reference value which is null on some exception control path is dereferenced here.  This may lead to a NullPointerException when the code is executed.  Note that because FindBugs currently does not prune infeasible exception paths, this may be a false warning.<br>Also note that FindBugs considers the default case of a switch statement to be an exception path, since the default case is often infeasible.<br>在异常null值处理分支调用的方法上，可能存在对象去除引用操作<br>70.NP: Method call passes null for nonnull parameter (NP_NULL_PARAM_DEREF_ALL_TARGETS_DANGEROUS)<br>方法参数中声明为nonnull类型的参数为null<br>void test(){<br>String ss = null;<br>sya(ss);<br>        }<br>        public void sya(@nonnull String ad){<br>ad.getBytes();<br>        }<br>71.NP: Store of null value into field annotated NonNull (NP_STORE_INTO_NONNULL_FIELD)<br>为一个已经声明为不能为null值的属性赋值为null。<br>72.Nm: Class defines equal(Object); should it be equals(Object)? (NM_BAD_EQUAL)<br>类中定义了一个equal方法但是却不是覆写的Object对象的equals方法<br>73.Nm: Class defines hashcode(); should it be hashCode()? (NM_LCASE_HASHCODE)<br>类中定义了一个hashCode方法但是却不是覆写的Object中的hashCode方法<br>74.Nm: Class defines tostring(); should it be toString()? (NM_LCASE_TOSTRING)<br>类中定义了一个toString方法但是却不是覆写的Object中的toString方法<br>75.Nm: Apparent method/constructor confusion (NM_METHOD_CONSTRUCTOR_CONFUSION)<br>构造方法定义混乱，保证一个标准的构造函数。        例如：<br>        SA(){        }<br>        void SA(){<br>        }<br>76.Nm: Very confusing method names (NM_VERY_CONFUSING)<br>混乱的方法命名，如getName和getname方法同时出现的时候<br>77.Nm: Method doesn’t override method in superclass due to wrong package for parameter (NM_WRONG_PACKAGE)<br>方法因为取了不同包中的同名的对象而没有正确覆写父类中的同名方法<br>import alpha.Foo;<br>public class A {<br>  public int f(Foo x) { return 17; }<br>}</string></string></p>\n<p>import beta.Foo;<br>public class B extends A {<br>  public int f(Foo x) { return 42; }<br>}<br>78.QBA: Method assigns boolean literal in boolean expression (QBA_QUESTIONABLE_BOOLEAN_ASSIGNMENT)<br>再if或者while表达式中使用boolean类型的值时应该使用==去判断，而不是采用=操作<br>79.RC: Suspicious reference comparison (RC_REF_COMPARISON)<br>比较两个对象值是否相等时应该采用equals方法，而不是==方法<br>80.RE: Invalid syntax for regular expression (RE_BAD_SYNTAX_FOR_REGULAR_EXPRESSION)<br>对正则表达式使用了错误的语法，会抛出未经检查的异常，表明正则表达式模式中的语法错误。<br>81.RE: File.separator used for regular expression (RE_CANT_USE_FILE_SEPARATOR_AS_REGULAR_EXPRESSION)<br>使用正则表达式使用了错误的文件分隔符，在windows系统中正则表达式不会匹配’\\’而应该使用’\\‘<br>82.RV: Random value from 0 to 1 is coerced to the integer 0 (RV_01_TO_INT)<br>从0到1随机值被强制为整数值0。在强制得到一个整数之前，你可能想得到多个随机值。或使用Random.nextInt（n）的方法。<br>83.RV: Bad attempt to compute absolute value of signed 32-bit hashcode (RV_ABSOLUTE_VALUE_OF_HASHCODE)<br>此代码生成一个哈希码，然后计算该哈希码的绝对值。如果哈希码是Integer.MIN_VALUE的，那么结果将是负数（因为Math.abs（Integer.MIN_VALUE的）== Integer.MIN_VALUE的）。<br>在2^ 32值之外字符串有一个Integer.MIN_VALUE的hashCode包括“polygenelubricants”，“GydZG_”和“，”DESIGNING WORKHOUSES “。<br>84.RV: Bad attempt to compute absolute value of signed 32-bit random integer (RV_ABSOLUTE_VALUE_OF_RANDOM_INT)<br>此代码生成一个随机的符号整数，然后计算该随机整数的绝对值。如果随机数生成数绝对值为Integer.MIN_VALUE的，那么结果将是负数（因为Math.abs（Integer.MIN_VALUE的）== Integer.MIN_VALUE的）。<br>85.RV: Exception created and dropped rather than thrown (RV_EXCEPTION_NOT_THROWN)<br>此代码创建一个异常（或错误）的对象，但不会用它做任何事情。例如：if (x &lt; 0)<br>  new IllegalArgumentException(“x must be nonnegative”);<br>这可能是程序员的意图抛出创建的异常：<br>if (x &lt; 0)<br>  throw new IllegalArgumentException(“x must be nonnegative”);<br>86.RV: Method ignores return value (RV_RETURN_VALUE_IGNORED)<br>该方法的返回值应该进行检查。这种警告通常出现在调用一个不可变对象的方法，认为它更新了对象的值。例如：String dateString = getHeaderField(name);<br>dateString.trim();<br>程序员似乎以为trim（）方法将更新dateString引用的字符串。但由于字符串是不可改变的，trim（）函数返回一个新字符串值，在这里它是被忽略了。该代码应更正：<br>String dateString = getHeaderField(name);<br>dateString = dateString.trim();<br>87.RpC: Repeated conditional tests (RpC_REPEATED_CONDITIONAL_TEST)<br>该代码包含对同一个条件试验了两次，两边完全一样例如：（如X == 0 | | x == 0）。可能第二次出现是打算判断别的不同条件（如X == 0 | | y== 0）。<br>88.SA: Double assignment of field (SA_FIELD_DOUBLE_ASSIGNMENT)<br>方法中的字段包含了双重任务，例如：<br> int x;<br>  public void foo() {<br>   x = x = 17;<br>  }<br>这种为变量赋值是无用的，并可能表明一个逻辑错误或拼写错误。<br>89.SA: Self assignment of field (SA_FIELD_SELF_ASSIGNMENT)<br>方法中包含自己对自己赋值的字段。例如：<br>int x;<br>  public void foo() {<br>    x = x;<br>  }<br>90.SA: Self comparison of field with itself (SA_FIELD_SELF_COMPARISON)<br>字段自己进行自比较可能表明错误或逻辑错误。<br>91.SA: Self comparison of value with itself (SA_LOCAL_SELF_COMPARISON)<br>方法中对一个局部变量自身进行比较运算，并可说明错误或逻辑错误。请确保您是比较正确的事情。<br>92.SA: Nonsensical self computation involving a variable (e.g., x &amp; x) (SA_LOCAL_SELF_COMPUTATION)<br>此方法对同一变量执行了荒谬的计算（如x&amp;x或x-x）操作。由于计算的性质，这一行动似乎没有意义，并可能表明错误或逻辑错误。<br>93.SF: Dead store due to switch statement fall through (SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH)<br>在swtich中先前的case值因为swtich执行失败而被覆写，这就像是忘记使用break推出或者没有使用return语句放回先前的值一样。<br>94.SF: Dead store due to switch statement fall through to throw (SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH_TO_THROW)<br>在swtich中因为出现异常而忽略了对case值的保存。<br>95.SIC: Deadly embrace of non-static inner class and thread local (SIC_THREADLOCAL_DEADLY_EMBRACE)<br>如果是一个静态内部类。实际上，在内部类和当前线程有死锁的可能。由于内部类不是静态的，它保留了对外部类的引用。如果线程包含对一个内部类实例的引用，那么内外实例的实例都可以被获取，这样就不具备垃圾会回收的资格。<br>96.SIO: Unnecessary type check done using instanceof operator (SIO_SUPERFLUOUS_INSTANCEOF)<br>在进行instanceof操作时进行没有必要的类型检查<br>97.STI: Unneeded use of currentThread() call, to call interrupted() (STI_INTERRUPTED_ON_CURRENTTHREAD)<br>此方法调用Thread.currentThread（）调用，只需调用interrupted（）方法。由于interrupted（）是一个静态方法， Thread.interrupted（）更简单易用。<br>98.STI: Static Thread.interrupted() method invoked on thread instance (STI_INTERRUPTED_ON_UNKNOWNTHREAD)<br>调用不是当前线程对象的Thread.interrupted()方法，由于interrupted（）方法是静态的，interrupted方法将会调用一个和作者原计划不同的对象。<br>99.Se: Method must be private in order for serialization to work (SE_METHOD_MUST_BE_PRIVATE)<br>这个类实现了Serializable接口，并定义自定义序列化的方法/反序列化。但由于这种方法不能声明为private，将被序列化/反序列化的API忽略掉。<br>100.Se: The readResolve method must not be declared as a static method. (SE_READ_RESOLVE_IS_STATIC)<br>为使readResolve方法得到序列化机制的识别，不能作为一个静态方法来声明。<br>101.UMAC: Uncallable method defined in anonymous class (UMAC_UNCALLABLE_METHOD_OF_ANONYMOUS_CLASS)<br>在匿名类中定义了一个既没有覆写超类中方法也不能直接调用的方法。因为在其他类的方法不能直接引用匿名类声明的方法，似乎这种方法不能被调用，这种方法可能只是没有任何作用的代码，但也可能覆写超类中声明。<br>102.UR: Uninitialized read of field in constructor (UR_UNINIT_READ)<br>此构造方法中使用了一个尚未赋值的字段或属性。<br>        String a;<br>        public SA() {<br>String abc = a;<br>System.out.println(abc);<br>        }<br>103.UR: Uninitialized read of field method called from constructor of superclass (UR_UNINIT_READ_CALLED_FROM_SUPER_CONSTRUCTOR)<br>方法被超类的构造函数调用时，在当前类中的字段或属性还没有被初始化。例如：<br>abstract class A {<br>  int hashCode;<br>  abstract Object getValue();<br>  A() {<br>    hashCode = getValue().hashCode();<br>    }<br>  }<br>class B extends A {<br>  Object value;<br>  B(Object v) {<br>    this.value = v;<br>    }<br>  Object getValue() {<br>    return value;<br>  }<br>  }<br>当B是创建时，A的构造函数将在B为value赋值之前触发，然而在A的初始化方法调用getValue方法时value这个变量还没有被初始化。<br>104.USELESS_STRING: Invocation of toString on an array (DMI_INVOKING_TOSTRING_ON_ANONYMOUS_ARRAY)<br>该代码调用上匿名数组的toString（）方法，产生的结果形如[@ 16f0472并没有实际的意义。考虑使用Arrays.toString方法来转换成可读的字符串，提供该数组的内容数组。例如：<br>String[] a = { “a” };<br>System.out.println(a.toString());<br>//正确的使用为<br>System.out.println(Arrays.toString(a));<br>105.USELESS_STRING: Invocation of toString on an array (DMI_INVOKING_TOSTRING_ON_ARRAY)<br>该代码调用上数组的toString（）方法，产生的结果形如[@ 16f0472并不能显示数组的真实内容。考虑使用Arrays.toString方法来转换成可读的字符串，提供该数组的内容数组<br>106.UwF: Field only ever set to null (UWF_NULL_FIELD)<br>字段的值总是为null值，所有读取该字段的值都为null。检查错误，如果它确实没有用就删除掉。<br>107.UwF: Unwritten field (UWF_UNWRITTEN_FIELD<br>此字段是永远不会写入值。所有读取将返回默认值。检查错误（如果它被初始化？），如果它确实没有用就删除掉。</p>\n<h3 id=\"五：Performance关于代码性能相关方面的\"><a href=\"#五：Performance关于代码性能相关方面的\" class=\"headerlink\" title=\"五：Performance关于代码性能相关方面的\"></a>五：Performance关于代码性能相关方面的</h3><p>1.Bx: Primitive value is boxed and then immediately unboxed (BX_BOXING_IMMEDIATELY_UNBOXED)<br>对原始值进行装箱，然后立即取消装箱。这可能是在一个未要求装箱的地方进行了手动装箱，从而迫使编译器进行立即撤消装箱的操作<br>2.Bx: Primitive value is boxed then unboxed to perform primitive coercion (BX_BOXING_IMMEDIATELY_UNBOXED_TO_PERFORM_COERCION)<br>对原始值进行装箱然后立即把它强制转换为另外一种原始类型。例如：<br>new Double(d).intValue()应该直接进行强制转换例如：(int) d<br>3.Bx: Method allocates a boxed primitive just to call toString (DM_BOXED_PRIMITIVE_TOSTRING)<br>仅仅为了调用封装类的toString()而对原始类型进行封装操作。比这种方法更有效的是调用封装类的toString(…)方法例如：<br>new Integer(1).toString()    替换为   Integer.toString(1)<br>new Long(1).toString()    替换为   Long.toString(1)<br>new Float(1.0).toString()    替换为   Float.toString(1.0)<br>new Double(1.0).toString()    替换为   Double.toString(1.0)<br>new Byte(1).toString()    替换为   Byte.toString(1)<br>new Short(1).toString()    替换为   Short.toString(1)<br>new Boolean(true).toString()    替换为   Boolean.toString(true)<br>4.Bx: Method invokes inefficient floating-point Number constructor; use static valueOf instead (DM_FP_NUMBER_CTOR)<br>使用new Double(double)方法总是会创建一个新的对象，然而使用Double.valueOf(double)方法可以把值保存在编辑器或者class library、JVM中。使用存储值的方式来避免对象的分配可以或得更好的代码性能<br>除非类必须符合Java 1.5以前的JVM，否则请使用自动装箱或valueOf（）方法创建Double和Float实例。<br>5.Bx: Method invokes inefficient Number constructor; use static valueOf instead (DM_NUMBER_CTOR)<br>使用new Integer(int)方法总是会创建一个新的对象，然而使用Integer.valueOf(int)方法可以把值保存在编辑器或者class library、JVM中。使用存储值的方式来避免对象的分配可以或得更好的代码性能<br>除非类必须符合Java 1.5以前的JVM，否则请使用自动装箱或valueOf（）方法创建Long, Integer, Short, Character, Byte实例。<br>6.Dm: The equals and hashCode methods of URL are blocking (DMI_BLOCKING_METHODS_ON_URL)<br>使用equals和hashCode方法来对url进行资源标识符解析时会引起堵塞。考虑使用java.net.URI来代替。<br>7.Dm: Maps and sets of URLs can be performance hogs (DMI_COLLECTION_OF_URLS)<br>方法或者字段使用url的map/set集合。因为equals方法或者hashCode方法来进行资源标识符解析时都会引起堵塞。考虑使用java.net.URI来代替。<br>8.Dm: Method invokes inefficient Boolean constructor; use Boolean.valueOf(…) instead (DM_BOOLEAN_CTOR)<br>使用new方法创建一个java.lang.Boolean类型能够的实例对象是浪费空间的，因为Boolean对象是不可变的而且只有两个有用的值。使用Boolean.valueOf()或者Java1.5中的自动装箱功能来创建一个Boolean实例。<br>9.Dm: Explicit garbage collection; extremely dubious except in benchmarking code (DM_GC)<br>在代码中显式的调用垃圾回收命名，这样做并不能起作用。在过去，有人在关闭操作或者finalize方法中调用垃圾回收方法导致了很多的性能浪费。这样大规模回收对象时会造成处理器运行缓慢。<br>10.Dm: Use the nextInt method of Random rather than nextDouble to generate a random integer (DM_NEXTINT_VIA_NEXTDOUBLE)<br> 如果r是一个java.util.Random对象，你可以使r.nextInt(n)生成一个0到n-1之前的随机数，而不是使用(int)(r.nextDouble() * n)<br>11.Dm: Method invokes inefficient new String(String) constructor (DM_STRING_CTOR)<br>使用java.lang.String(String)构造函数会浪费内存因为这种构造方式和String作为参数在功能上容易混乱。只是使用String直接作为参数的形式<br>12.Dm: Method invokes toString() method on a String (DM_STRING_TOSTRING)<br>调用String.toString()是多余的操作，只要使用String就可以了。<br>13.Dm: Method invokes inefficient new String() constructor (DM_STRING_VOID_CTOR)<br>使用没有参数的构造方法去创建新的String对象是浪费内存空间的，因为这样创建会和空字符串“”混淆。Java中保证完成相同的构造方法会产生描绘相同的String对象。所以你只要使用空字符串来创建就可以了。<br>14.ITA: Method uses toArray() with zero-length array argument (ITA_INEFFICIENT_TO_ARRAY)<br>当使用集合的toArray()方法时使用数组长度为0的数组作为参数。比这更有效的一种方法是<br>myCollection.toArray(new Foo[myCollection.size()])，如果数组的长度足够大就可以直接把集合中的内容包装到数组中直接返回从而避免了第二次创建一个新的数组来存放集合中值。<br>15.SBSC: Method concatenates strings using + in a loop (SBSC_USE_STRINGBUFFER_CONCATENATION)<br>在循环中构建一个String对象时从性能上讲使用StringBuffer来代替String对象<br>例如：<br>// This is bad<br>  String s = “”;<br>  for (int i = 0; i &lt; field.length; ++i) {<br>    s = s + field[i];<br>  }<br>  // This is better<br>  StringBuffer buf = new StringBuffer();<br>  for (int i = 0; i &lt; field.length; ++i) {<br>    buf.append(field[i]);<br>  }<br>  String s = buf.toString();<br>16.SS: Unread field: should this field be static? (SS_SHOULD_BE_STATIC)<br>类中所包含的final属性字段在编译器中初始化为静态的值。考虑在定义时就把它定义为static类型的。<br>17.UM: Method calls static Math class method on a constant value (UM_UNNECESSARY_MATH)<br>在方法中使用了java.lang.Math的静态方法代替常量来使用，使用常量速度和准确度会更好。 以下为Math中的方法产生的值。<br>Method Parameter<br>abs -any-<br>acos 0.0 or 1.0<br>asin 0.0 or 1.0<br>atan 0.0 or 1.0<br>atan2 0.0 cbrt 0.0 or 1.0<br>ceil -any-<br>cos 0.0<br>cosh 0.0<br>exp 0.0 or 1.0<br>expm1 0.0<br>floor -any-<br>log 0.0 or 1.0<br>log10 0.0 or 1.0<br>rint -any-<br>round -any-<br>sin 0.0<br>sinh 0.0<br>sqrt 0.0 or 1.0<br>tan 0.0<br>tanh 0.0<br>toDegrees 0.0 or 1.0<br>toRadians 0.0<br>18.UPM: Private method is never called (UPM_UNCALLED_PRIVATE_METHOD)<br>定义为Private类型方法从未被调用，应该被删除。<br>19.UrF: Unread field (URF_UNREAD_FIELD)<br>类中定义的属性从未被调用，建议删除。<br>20.UuF: Unused field (UUF_UNUSED_FIELD)<br>类中定义的属性从未被使用，建议删除。<br>21.WMI: Inefficient use of keySet iterator instead of entrySet iterator (WMI_WRONG_MAP_ITERATOR)<br>当方法中接受一个Map类型的参数时，使用keySet的迭代器比使用entrySet的迭代器效率要高。</p>\n<h3 id=\"六：Internationalization关于代码国际化相关方面的\"><a href=\"#六：Internationalization关于代码国际化相关方面的\" class=\"headerlink\" title=\"六：Internationalization关于代码国际化相关方面的\"></a>六：Internationalization关于代码国际化相关方面的</h3><p>Dm: Consider using Locale parameterized version of invoked method (DM_CONVERT_CASE)<br>使用平台默认的编码格式对字符串进行大小写转换，这可能导致国际字符的转换不当。使用以下方式对字符进行转换<br>String.toUpperCase( Locale l )<br>String.toLowerCase( Locale l )</p>\n<h3 id=\"七：Multithreaded-correctness关于代码多线程正确性相关方面的\"><a href=\"#七：Multithreaded-correctness关于代码多线程正确性相关方面的\" class=\"headerlink\" title=\"七：Multithreaded correctness关于代码多线程正确性相关方面的\"></a>七：Multithreaded correctness关于代码多线程正确性相关方面的</h3><p>1.DL: Synchronization on Boolean could lead to deadlock (DL_SYNCHRONIZATION_ON_BOOLEAN)<br>该代码同步一个封装的原始常量，例如一个Boolean类型。<br>private static Boolean inited = Boolean.FALSE;<br>…<br>  synchronized(inited) {<br>    if (!inited) {<br>       init();<br>       inited = Boolean.TRUE;<br>       }<br>     }<br>…<br>由于通常只存在两个布尔对象，此代码可能是同步的其他无关的代码中相同的对象，这时会导致反应迟钝和可能死锁<br>2.DL: Synchronization on boxed primitive could lead to deadlock (DL_SYNCHRONIZATION_ON_BOXED_PRIMITIVE)<br>该代码同步一个封装的原始常量，例如一个Integer类型。<br>private static Integer count = 0;<br>…<br>  synchronized(count) {<br>     count++;<br>     }<br>…<br>由于Integer对象可以共享和保存，此代码可能是同步的其他无关的代码中相同的对象，这时会导致反应迟钝和可能死锁<br>3.DL: Synchronization on interned String could lead to deadlock (DL_SYNCHRONIZATION_ON_SHARED_CONSTANT)<br>同步String类型的常量时，由于它被JVM中多个其他的对象所共有，这样在其他代码中会引起死锁。<br>4.DL: Synchronization on boxed primitive values (DL_SYNCHRONIZATION_ON_UNSHARED_BOXED_PRIMITIVE)<br>同步一个显然不是共有封装的原始值，例如一个Integer类型的对象。例如：<br>private static final Integer fileLock = new Integer(1);<br>…<br>  synchronized(fileLock) {<br>     .. do something ..<br>     }<br>…<br>它最后被定义为以下方式来代替：private static final Object fileLock = new Object();<br>5.Dm: Monitor wait() called on Condition (DM_MONITOR_WAIT_ON_CONDITION)<br>方法中以java.util.concurrent.locks.Condition对象调用wait（）。等待一个条件发生时应该使用在Condition接口中定义的await()方法。<br>6.Dm: A thread was created using the default empty run method (DM_USELESS_THREAD)<br>这个方法没有通过run方法或者具体声明Thread类，也没有通过一个Runnable对象去定义一个线程，而这个线程出来浪费资源却什么也没有去做。<br>7.ESync: Empty synchronized block (ESync_EMPTY_SYNC)<br>该代码包含一个空的同步块：synchronized() {}<br>8.IS: Inconsistent synchronization (IS2_INCONSISTENT_SYNC)<br>不合理的同步<br>9.IS: Field not guarded against concurrent access (IS_FIELD_NOT_GUARDED)<br>域不是良好的同步访问—<br>此字段被标注为net.jcip.annotations.GuardedBy，但可以在某种程度上违反注释而去访问<br>10.JLM: Synchronization performed on Lock (JLM_JSR166_LOCK_MONITORENTER)<br>实现java.util.concurrent.locks.Lock的对象调用了同步的方法。应该这样处理，对象被锁定/解锁时使用acquire（）/ release（）方法而不是使用同步的方法。<br>11.LI: Incorrect lazy initialization of static field (LI_LAZY_INIT_STATIC)<br>静态域不正确的延迟初始化–<br>这种方法包含了一个不同步延迟初始化的非volatile静态字段。因为编译器或处理器可能会重新排列指令，如果该方法可以被多个线程调用，线程不能保证看到一个完全初始化的对象。你可以让字段可变来解决此问题<br>12.LI: Incorrect lazy initialization and update of static field (LI_LAZY_INIT_UPDATE_STATIC)<br>这种方法包含一个不同步延迟初始化的静态字段。之后为字段赋值，对象存储到该位置后进一步更新或访问。字段后尽快让其他线程能够访问。如果该方法的进一步访问该字段为初始化对象提供服务，然后你有一个非常严重的多线程bug，除非别的东西阻止任何其他线程访问存储的对象，直到它完全初始化。<br>即使你有信心，该方法是永远不会被多个线程调用时，在它的值还没有被充分初始化或移动，不把它设定为static字段时它可能会更好。<br>13.ML: Method synchronizes on an updated field (ML_SYNC_ON_UPDATED_FIELD)<br>对象获取一个可变字段时进行同步。这是没有意义的，因为不同的线程可以在不同的对象同步。<br>14.MSF: Mutable servlet field (MSF_MUTABLE_SERVLET_FIELD)<br>一个web服务一般只能创建一个servlet或者jsp的实例（例如：treates是一个单利类），它会被多个线程调用这个实例的方法服务于多个同时的请求。因此使用易变的字段属性产生竞争的情况。<br>15.MWN: Mismatched notify() (MWN_MISMATCHED_NOTIFY)<br>此方法调用Object.notify（）或Object.notifyAll（）而没有获取到该对象的对象锁。调用notify（）或notifyAll（）而没有持有该对象的对象锁，将导致IllegalMonitorStateException异常。<br>16.MWN: Mismatched wait() (MWN_MISMATCHED_WAIT)<br>此方法调用Object.wait()而没有获取到该对象的对象锁。调用wait（）而没有持有该对象的对象锁，将导致IllegalMonitorStateException异常。<br>17.NP: Synchronize and null check on the same field. (NP_SYNC_AND_NULL_CHECK_FIELD)<br>如果代码块是同步的，那么久不可能为空。如果是空，同步时就会抛出NullPointerException异常。最好是在另一个代码块中进行同步。<br>18.No: Using notify() rather than notifyAll() (NO_NOTIFY_NOT_NOTIFYALL)<br>调用notify（）而不是notifyAll（）方法。 Java的监控器通常用于多个条件。调用notify（）只唤醒一个线程，这意味着该线程被唤醒只是满足的当前的唯一条件。<br>19.RS: Class’s readObject() method is synchronized (RS_READOBJECT_SYNC)<br>序列化类中定义了同步的readObject（）。通过定义，反序列化创建的对象只有一个线程可以访问，因此没有必要的readObject（）进行同步。如果的readObject（）方法本身造成对象对另一个线程可见，那么这本身就是不好的编码方式。<br>20.Ru: Invokes run on a thread (did you mean to start it instead?) (RU_INVOKE_RUN)<br>这种方法显式调用一个对象的run（）。一般来说，类是实现Runnable接口的，因为在一个新的线程他们将有自己的run（）方法，在这种情况下Thread.start（）方法调用是正确的。<br>21.SC: Constructor invokes Thread.start() (SC_START_IN_CTOR)<br>在构造函数中启动一个线程。如果类曾经被子类扩展过，那么这很可能是错的，因为线程将在子类构造之前开始启动。<br>22.SP: Method spins on field (SP_SPIN_ON_FIELD)<br>方法无限循环读取一个字段。编译器可合法悬挂宣读循环，变成一个无限循环的代码。这个类应该改变，所以使用适当的同步（包括等待和通知要求）<br>23.STCAL: Call to static Calendar (STCAL_INVOKE_ON_STATIC_CALENDAR_INSTANCE)<br>即使JavaDoc对此不包含暗示，而Calendars本身在多线程中使用就是不安全的。探测器发现当调用Calendars的实例时将会获得一个静态对象。<br>Calendar rightNow = Calendar.getInstance();<br>24.STCAL: Call to static DateFormat (STCAL_INVOKE_ON_STATIC_DATE_FORMAT_INSTANCE)<br>在官方的JavaDoc，DateFormats多线程使用本事就是不安全的。探测器发现调用一个DateFormat的实例将会获得一个静态对象。<br>myString = DateFormat.getDateInstance().format(myDate);<br>25.STCAL: Static Calendar (STCAL_STATIC_CALENDAR_INSTANCE)<br>Calendar在多线程中本身就是不安全的，如果在线程范围中共享一个Calendarde 实例而不使用一个同步的方法在应用中就会出现一些奇怪的行为。在sun.util.calendar.BaseCalendar.getCalendarDateFromFixedDate()中会抛出ArrayIndexOutOfBoundsExceptions or IndexOutOfBoundsExceptions异常。<br>26.STCAL: Static DateFormat (STCAL_STATIC_SIMPLE_DATE_FORMAT_INSTANCE)<br>DateFormat 在多线程中本身就是不安全的，如果在线程范围中共享一个DateFormat的实例而不使用一个同步的方法在应用中就会出现一些奇怪的行为。<br>27.SWL: Method calls Thread.sleep() with a lock held (SWL_SLEEP_WITH_LOCK_HELD)<br>当持有对象时调用Thread.sleep（）。这可能会导致很差的性能和可扩展性，或陷入死锁，因为其他线程可能正在等待获得锁。调用wait（）是一个更好的主意，释放对象的持有以允许其他线程运行。<br>28.UG: Unsynchronized get method, synchronized set method (UG_SYNC_SET_UNSYNC_GET)<br>这个类包含类似命名的get和set方法。在set方法是同步方法和get方法是非同步方法。这可能会导致在运行时的不正确行为，因为调用的get方法不一定返回对象一致状态。 GET方法应该同步。<br>29.UL: Method does not release lock on all paths (UL_UNRELEASED_LOCK)<br>方法获得了当前的对象所，但是在方法中始终没有释放它。一个正确的示例如下：<br>  Lock l = …;<br>    l.lock();<br>    try {<br>        // do something<br>    } finally {<br>        l.unlock();<br>    }<br>30.UL: Method does not release lock on all exception paths (UL_UNRELEASED_LOCK_EXCEPTION_PATH)<br>方法获得了当前的对象所，但是在所有的异常处理中始终没有释放它。一个正确的示例如下：<br>  Lock l = …;<br>    l.lock();<br>    try {<br>        // do something<br>    } finally {<br>        l.unlock();<br>    }<br>31.UW: Unconditional wait (UW_UNCOND_WAIT)<br>方法中包含调用java.lang.Object.wait（），而却没有放到条件流程控制中。该代码应确认条件尚未满足之前等待;先前任何通知将被忽略。<br>32.VO: A volatile reference to an array doesn’t treat the array elements as volatile (VO_VOLATILE_REFERENCE_TO_ARRAY)<br>声明一个变量引用数组，这可能不是你想要的。如果一个变量引用数组，那么对引用数组的读和写都是不安全的，但是数组元素不是变量。取得数组的变量值你可以使用java.util.concurrent包中的数组的原子性特性<br>33.WL: Sychronization on getClass rather than class literal (WL_USING_GETCLASS_RATHER_THAN_CLASS_LITERAL)<br>实例的方法中同步this.getClass()，如果这个类有子类集合，那么子类集合中的对象将会在这个类的各个子类上进行同步，这不是我们想要的效果，我们只要同步当前的类对象而不包含它的所有子类，可以同步类名.getClass()。例如，java.awt.Label的代码：<br>     private static final String base = “label”;<br>     private static int nameCounter = 0;<br>     String constructComponentName() {<br>        synchronized (getClass()) {<br>            return base + nameCounter++;<br>        }<br>     }<br>Label中的子类集合不可能在同一个子对象上进行同步，替换上面的方法为：<br>    private static final String base = “label”;<br>     private static int nameCounter = 0;<br>     String constructComponentName() {<br>        synchronized (Label.class) {<br>            return base + nameCounter++;<br>        }<br>     }<br>34.WS: Class’s writeObject() method is synchronized but nothing else is (WS_WRITEOBJECT_SYNC)<br>这个类有一个writeObject（）方法是同步的，但是这个类中没有其他的同步方法。<br>35.Wa: Condition.await() not in loop (WA_AWAIT_NOT_IN_LOOP)<br>方法没有在循环中调用java.util.concurrent.await()。如果对象是用于多种条件，打算调用wait()方法的条件可能不是实际发生的。<br>36.Wa: Wait not in loop (WA_NOT_IN_LOOP)<br>这种方法包含调用java.lang.Object.wait（），而这并不是一个循环。如果监视器用于多个条件，打算调用wait()方法的条件可能不是实际发生的。</p>\n<h3 id=\"八：Malicious-codevulnerability关于恶意破坏代码相关方面的\"><a href=\"#八：Malicious-codevulnerability关于恶意破坏代码相关方面的\" class=\"headerlink\" title=\"八：Malicious codevulnerability关于恶意破坏代码相关方面的\"></a>八：Malicious codevulnerability关于恶意破坏代码相关方面的</h3><p>1.EI: May expose internal representation by returning reference to mutable object (EI_EXPOSE_REP)<br>返回一个易变对象引用并把它保存在对象字段中时会暴露对象内部的字段描述，如果接受不守信任的代码访问或者没有检查就去改变易变对象的会涉及对象的安全和其他重要属性的安全。返回一个对象的新副本，在很多情况下更好的办法。<br>2.EI2: May expose internal representation by incorporating reference to mutable object (EI_EXPOSE_REP2)<br>此代码把外部可变对象引用存储到对象的内部表示。如果实例受到不信任的代码的访问和没有检查的变化危及对象和重要属性的安全。存储一个对象的副本，在很多情况下是更好的办法。<br>3.FI: Finalizer should be protected, not public (FI_PUBLIC_SHOULD_BE_PROTECTED)<br>一个类中的finalize（）方法必须声明为protected，而不能为public类型<br>4.MS: Public static method may expose internal representation by returning array (MS_EXPOSE_REP)<br>一个public类型的静态方法返回一个数组，可能引用内部属性的暴露。任何代码调用此方法都可以自由修改底层数组。一个解决办法是返回一个数组的副本。<br>5.MS: Field should be both final and package protected (MS_FINAL_PKGPROTECT)<br>一个静态字段可能被恶意代码或另外一个包所改变的。字段可以放到protected包中也可以定义为final类型的以避免此问题。<br>6.MS: Field is a mutable array (MS_MUTABLE_ARRAY)<br>一个定义为final类型的静态字段引用一个数组时它可以被恶意代码或在另其他包中所使用。这些代码可以自由修改数组的内容。<br>7.MS: Field is a mutable Hashtable (MS_MUTABLE_HASHTABLE)<br>一个定义为final类型的静态字段引用一个Hashtable时可以被恶意代码或者在其他包中被调用，这些方法可以修改Hashtable的值。<br>8.MS: Field should be moved out of an interface and made package protected (MS_OOI_PKGPROTECT)<br>将域尽量不要定义在接口中，并声明为包保护<br>在接口中定义了一个final类型的静态字段，如数组或哈希表等易变对象。这些对象可以被恶意代码或者在其他包中被调用，为了解决这个问题，需要把它定义到一个具体的实体类中并且声明为保护类型以避免这种错误。<br>9.MS: Field should be package protected (MS_PKGPROTECT)<br>一个静态字段是可以改变的恶意代码或其他的包访问修改。可以把这种类型的字段声明为final类型的以防止这种错误。</p>\n<h3 id=\"十：Dodgy关于代码运行期安全方面的\"><a href=\"#十：Dodgy关于代码运行期安全方面的\" class=\"headerlink\" title=\"十：Dodgy关于代码运行期安全方面的\"></a>十：Dodgy关于代码运行期安全方面的</h3><p>1.XSS: Servlet reflected cross site scripting vulnerability (XSS_REQUEST_PARAMETER_TO_SEND_ERROR)<br>在代码中在Servlet输出中直接写入一个HTTP参数，这会造成一个跨站点的脚本漏洞。<br>2.XSS: Servlet reflected cross site scripting vulnerability (XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER)<br>代码直接写入参数的HTTP服务器错误页（使用HttpServletResponse.sendError）。表达了类似的不受信任的输入会引起跨站点脚本漏洞。<br>3.BC: Questionable cast to abstract collection (BC_BAD_CAST_TO_ABSTRACT_COLLECTION)<br>在代码投把一个集合强制类型转换为一个抽象的集合（如list，set或map）。保证该对象类型和将要转换的类型是一致的。如果你只是想要便利一个集合，那么你就不必将它转换为Set或List。<br>4.BC: Questionable cast to concrete collection (BC_BAD_CAST_TO_CONCRETE_COLLECTION)<br>代码把抽象的集合（如List，Set，或Collection）强制转换为具体落实类型（如一个ArrayList或HashSet）。这可能不正确，也可能使您的代码很脆弱，因为它使得难以在今后的切换指向其他具体实现。除非你有特别理由这样做，否则只需要使用抽象的集合类。<br>5.BC: Unchecked/unconfirmed cast (BC_UNCONFIRMED_CAST)<br>强制类型转换操作没有经过验证，而且不是所有的此种类型装换过的类都可以再强制类型转换为原类型。在代码中需要进行逻辑判断以保证可以进行这样的操作。<br>6.BC: instanceof will always return true (BC_VACUOUS_INSTANCEOF)<br>instanceof测试将始终返回真（除非被测试的值为空）。虽然这是安全，确保它是不是说明一些误解或其他一些逻辑错误。如果你真的想测试是空的价值，也许会更清楚这样做的更好空试验，而不是一个instanceof测试。<br>7.BSHIFT: Unsigned right shift cast to short/byte (ICAST_QUESTIONABLE_UNSIGNED_RIGHT_SHIFT)<br>无符号数右移后进行转换为short或者byte类型时可能会丢弃掉高位的值，这样的结果就是有符合数和无符号数无法区分（这取决于移位大小）<br>8.CI: Class is final but declares protected field (CI_CONFUSED_INHERITANCE)<br>这个类被声明为final的，而是字段属性却声明为保护类型的。由于是final类，它不能再被继承，而再声明为保护类型的很容易造成混淆。为了从外部能正确的使用它应该把它们声明为private或者public类型。<br>9.DB: Method uses the same code for two branches (DB_DUPLICATE_BRANCHES)<br>此方法使用相同的代码，以实现两个有条件的分支。检查以确保这是不是一个编码错误。<br>10.DB: Method uses the same code for two switch clauses (DB_DUPLICATE_SWITCH_CLAUSES)<br>他的方法使用相同的代码来实现两个switch的声明条款。这可能是重复代码的情况，但可能也显示出编码的错误。<br>11.DLS: Dead store to local variable (DLS_DEAD_LOCAL_STORE)<br>该指令为局部变量赋值，但在其后的没有对她做任何使用。通常，这表明一个错误，因为值从未使用过。<br>12.DLS: Useless assignment in return statement (DLS_DEAD_LOCAL_STORE_IN_RETURN)<br>本声明把一个局部变量放到方法的返回语句中。这对于方法中局部变量来说是没有意思的。<br>13.DLS: Dead store of null to local variable (DLS_DEAD_LOCAL_STORE_OF_NULL)<br>把一个本地变量赋值为null值，并且再也没有对这个变量做任何的操作。这样可能是为了垃圾回收，而是Java SE 6.0，这已不再需要。<br>14.DMI: Code contains a hard coded reference to an absolute pathname (DMI_HARDCODED_ABSOLUTE_FILENAME)<br>此代码包含文件对象为一个绝对路径名（例如，新的文件（“/ home/dannyc/workspace/j2ee/src/share/com/sun/enterprise/deployment”）;<br>15.DMI: Non serializable object written to ObjectOutput (DMI_NONSERIALIZABLE_OBJECT_WRITTEN)<br>代码中让一个非序列化的对象出现在ObjectOutput.writeObject()方法中，这样会引起一个错误。<br>16.DMI: Invocation of substring(0), which returns the original value (DMI_USELESS_SUBSTRING)<br>此代码调用了subString(0)方法，它将返回原来的值。<br>17.Eq: Class doesn’t override equals in superclass (EQ_DOESNT_OVERRIDE_EQUALS)<br>子类定义了一个新的equals方法但是却不是覆写了父类本省的equals()方法。<br>18.FE: Test for floating point equality (FE_FLOATING_POINT_EQUALITY)<br>此操作比较两个浮点值是否相等。由于浮点运算可能会涉及到舍入，计算float和double值可能不准确。如果要求值必须准确，如货币值，可以考虑使用固定精度类型，如BigDecimal类型的值来比较<br>19.FS: Non-Boolean argument formatted using %b format specifier (VA_FORMAT_STRING_BAD_CONVERSION_TO_BOOLEAN)<br>使用%b去格式化Boolean类型的值不正确的但是它不会抛出异常，任何非空的值都会输出true，任何为空的值都会输出false<br>20.IC: Initialization circularity (IC_INIT_CIRCULARITY)<br>在引用两个相互调用为环状static方法去初始化一个实例时是错误的。<br>21.ICAST: integral division result cast to double or float (ICAST_IDIV_CAST_TO_DOUBLE)<br>整形数除法强制转换为double或者float类型。<br>int x = 2;<br>int y = 5;<br>// Wrong: yields result 0.0<br>double value1 =  x / y;<br>// Right: yields result 0.4<br>double value2 =  x / (double) y;<br>22.ICAST: Result of integer multiplication cast to long (ICAST_INTEGER_MULTIPLY_CAST_TO_LONG)<br>整形数做乘法运算结果转换为long值时如果采用<br>long convertDaysToMilliseconds(int days) { return 1000<em>3600</em>24<em>days; } 结果会因为超出整形的范围而出错。<br>如果使用：<br>long convertDaysToMilliseconds(int days) { return 1000L</em>3600<em>24</em>days; }<br>或者：<br>static final long MILLISECONDS_PER_DAY = 24L<em>3600</em>1000;<br>        long convertDaysToMilliseconds(int days) { return days * MILLISECONDS_PER_DAY; }<br>都可以避免此问题。<br>23.IM: Computation of average could overflow (IM_AVERAGE_COMPUTATION_COULD_OVERFLOW)<br>代码中使用x % 2 == 1的方法去验证运算是否存在余数的情况，但是如果出现负数的情况就不起作用了。使用x &amp; 1 == 1, or x % 2 != 0来代替<br>24.INT: Vacuous comparison of integer value (INT_VACUOUS_COMPARISON)<br>整形数进行比较结果总是不变。例如：x &lt;= Integer.MAX_VALUE<br>25.MTIA: Class extends Servlet class and uses instance variables (MTIA_SUSPECT_SERVLET_INSTANCE_FIELD)<br>这个类扩展从Servlet类，并使用实例的成员变量。由于只有一个Servlet类的实例，并在多线程方式使用，这种模式有可能存在问题。考虑只使用方法的局部变量。<br>26.MTIA: Class extends Struts Action class and uses instance variables (MTIA_SUSPECT_STRUTS_INSTANCE_FIELD)<br>类扩展自Struts的Action类并使用这个实例的成员变量，因为在Struts框架中只存在一个Action实例对象并且使用在多线程的情况下很可能会出现问题。<br>27.NP: Dereference of the result of readLine() without nullcheck (NP_DEREFERENCE_OF_READLINE_VALUE)<br>对readLine()的结果值没有进行判空操作就去重新赋值，这样的操作可以会抛出空指针异常。<br>28.NP: Immediate dereference of the result of readLine() (NP_IMMEDIATE_DEREFERENCE_OF_READLINE)<br>对readLine()的结果立即赋值，这样的操作可以会抛出空指针异常。<br>29.NP: Possible null pointer dereference due to return value of called method (NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE)<br>方法的返回值没有进行是否为空的检查就重新赋值，这样可能会出现空指针异常。<br>30.NP: Parameter must be nonnull but is marked as nullable (NP_PARAMETER_MUST_BE_NONNULL_BUT_MARKED_AS_NULLABLE)<br>参数值在任何情况下都不能为空，但是有明确的注释它可以为空。<br>31.NS: Potentially dangerous use of non-short-circuit logic (NS_DANGEROUS_NON_SHORT_CIRCUIT)<br>代码中使用（&amp; or |）代替（&amp;&amp; or ||）操作，这会造成潜在的危险。<br>32.NS: Questionable use of non-short-circuit logic (NS_NON_SHORT_CIRCUIT)<br>代码中使用（&amp; or |）代替（&amp;&amp; or ||）操作，会引起不安全的操作<br>33.PZLA: Consider returning a zero length array rather than null (PZLA_PREFER_ZERO_LENGTH_ARRAYS)<br>考虑返回一个零长度的数组，而不是null值<br>34.QF: Complicated, subtle or wrong increment in for-loop (QF_QUESTIONABLE_FOR_LOOP)<br>确定这个循环是正确的变量递增，看起来，另一个变量被初始化，检查的循环。这是由于for循环中太复杂的定义造成的。<br>35.RCN: Redundant comparison of non-null value to null (RCN_REDUNDANT_COMPARISON_OF_NULL_AND_NONNULL_VALUE)<br>方法中包含一个不能为空的赋值还包含一个可以为空的赋值。冗余比较非空值为空。<br>36.RCN: Redundant comparison of two null values (RCN_REDUNDANT_COMPARISON_TWO_NULL_VALUES)<br>方法中对两个null值进行比较<br>37.RCN: Redundant nullcheck of value known to be non-null (RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE)<br>方法中对不为空的值进行为空的判断。<br>38.REC: Exception is caught when Exception is not thrown (REC_CATCH_EXCEPTION)<br>在try/catch块中捕获异常，但是异常没有在try语句中抛出而RuntimeException又没有明确的被捕获<br>39.RI: Class implements same interface as superclass (RI_REDUNDANT_INTERFACES)<br>子类和父类都实现了同一个接口，这种定义是多余的。<br>40.RV: Method discards result of readLine after checking if it is nonnull (RV_DONT_JUST_NULL_CHECK_READLINE)<br>readLine方法的结果不为空时被抛弃<br>41.RV: Remainder of 32-bit signed random integer (RV_REM_OF_RANDOM_INT)<br>此代码生成一个随机的符号整数，然后计算另一个值的。由于随机数可以是负数，所以其余操作的结果也可以是负面的。考虑使用Random.nextInt（int）方法代替。<br>42.SA: Double assignment of local variable (SA_LOCAL_DOUBLE_ASSIGNMENT)<br>为一个局部变量两次赋值，这样是没有意义的。例如：<br>public void foo() {<br>    int x,y;<br>    x = x = 17;<br>  }<br>43.SA: Self assignment of local variable (SA_LOCAL_SELF_ASSIGNMENT)<br>局部变量使用自身给自己赋值<br>public void foo() {<br>    int x = 3;<br>    x = x;<br>  }<br>44.SF: Switch statement found where one case falls through to the next case (SF_SWITCH_FALLTHROUGH)<br>Switch语句中一个分支执行后又执行了下一个分支。通常case后面要跟break 或者return语句来跳出。<br>45.SF: Switch statement found where default case is missing (SF_SWITCH_NO_DEFAULT)<br>Switch没有默认情况下执行的case语句。<br>46.Se: private readResolve method not inherited by subclasses (SE_PRIVATE_READ_RESOLVE_NOT_INHERITED)<br>声明为private的序列化方法被子类继承<br>47.UCF: Useless control flow (UCF_USELESS_CONTROL_FLOW)<br>没有任何作用的条件语句。<br>if (argv.length == 0) {<br>        // TODO: handle this case<br>        }<br>48.UCF: Useless control flow to next line (UCF_USELESS_CONTROL_FLOW_NEXT_LINE)<br>无效的条件控制语句，注意if (argv.length == 1);以“;”结尾，下面的语句无论是否满足都会运行。<br>if (argv.length == 1);<br>        System.out.println(“Hello, “ + argv[0]);<br>49.UwF: Field not initialized in constructor (UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR)<br>字段从来没有在任何构造函数初始化，对象被创建后值为空。如果该字段未被定义就重新赋值会产生一个空指针异常。<br>50.XFB: Method directly allocates a specific implementation of xml interfaces (XFB_XML_FACTORY_BYPASS)<br>方法自定义了一种XML接口的实现类。最好是使用官方提供的工厂类来创建这些对象，以便可以在运行期中改变。例如：<br>javax.xml.parsers.DocumentBuilderFactory<br>javax.xml.parsers.SAXParserFactory<br>javax.xml.transform.TransformerFactory<br>org.w3c.dom.Document.createXXXX</p>\n"},{"title":"个人精进|读书笔记——《卖掉法拉利的高僧》","date":"2018-07-07T10:03:41.000Z","_content":"\n这是一部有方法的个人价值实现指南。故事以对话的方式讲述，在审视自我的过程中，重新发现想要的生活。\n\n刚开始看到这个书名时，感觉是一本精彩的小说，这么少的文字，被翻译成70多种语言，一定很有意义，就试着读了读。读了之后才发现这是一本实践性很强的自我价值实现指导书，里边有非常具体的方法论及使用方法，同时被里边的故事吸引了。\n\n本书通过瑜伽师拉曼一个寓言，来讲解充满丰富精神内涵的七项品质，这个寓言里，包含了人生的奥妙。下面就开始吧。\n\n“闭上眼睛，在脑海中浮现出以下画面……”\n你坐在一个漂亮的、郁郁葱葱的花园当中。花园里满眼都是你所见过的最引人陶醉的鲜花。四周极度寂静，了无声息。品味这花园带给你的快乐，想象自己有大把的时间来欣赏这片自然的绿洲。若你向四周环顾，就会看到，在这个神奇花园的中心伫立着一座高耸的、六层高的红色灯塔。 \n突然，花园里的静默被一阵嘈杂的吱吱嘎嘎声打破，灯塔底部的门被打开了。跌跌撞撞地走出来一个两米七高、四百公斤重的日本相扑选手，他是在不经意间闯进花园中心的。 \n“下面就更有意思了，”朱利安哧哧笑着说，“那个日本相扑选手几乎全身赤裸，只有私处覆盖着多股丝线织成的粉色带子。” \n然后这个相扑选手开始在花园里走来走去。他找到了一个闪闪发亮的金质秒表，不知是谁很多年以前遗留在那儿的。他不小心踩在秒表上，“砰”的一声巨响，结结实实地摔倒在地上。这个相扑选手变得毫无知觉，无声无息地躺在那里。就在你觉得他就要咽下最后一口气的时候，他慢慢地苏醒过来了，可能是因为受到附近那些黄玫瑰芬芳的刺激。仿佛吸收了新的能量似的，这个选手一跃而起，下意识地往左边望去。他被眼前的一幕惊呆了： \n透过花园边上的灌木丛，他看到一条蜿蜒曲折的林间小路，路上覆盖着数不清的闪闪发光的钻石。仿佛有一股神奇的力量，他渐渐地被吸引，顺着那条路慢慢地走了过去。就是这条路把他带上了充满无尽快乐和无上幸福的大道上。 \n\n**基于以上故事，引出的七个品质**\n# 花园，代表心智\n心智的控制要通过心理调节才能奏效\n\n不管你的生活中发生了什么样的变故，你都一直有权利选择自己对待事件的反应态度。当你养成了在每件事情当中都认真寻找积极因素的习惯时，你的人生就会变得鲜活有趣，生活就会升华到最高境界。\n\n**你的外在世界其实就是内心世界的外显。通过控制自己的想法，控制你对人生中每件事情的反应，你就能够开始掌控自己的命运。**\n\n我要郑重地建议你，不要动不动就贸然判断一件事情究竟是积极的，还是消极的。你最好先去经历它们，赞美它们并认真从中学习。生活中的每件事都会教你一些东西。它们是你完善内在世界和外在世界的力量。如果没有它们，你就会停滞不前。想一想它们在你生命中起到的作用吧。大部分人的生活之所以经历了突飞猛进的成长，起因都是因为遭遇到最具有挑战性的人生经历。假如结果让你有些出乎意料，也许会让你感到微微的失望，这个时候你就好好地想想自然的法则吧，因为它总是会确保在一扇门关闭的同时打开另一扇门。所以说，失败中潜藏着成功，挑战与机遇同在。一旦你把这个原则持之以恒地应用到你的日常生活中，以此为标准，努力训练自己的心智，积极地看待每件事情，善于从中汲取力量，那你就会永远忘却那些不必要的烦恼。你将不再是逝去的时光的囚徒，而将成为规划自己未来的设计师。\n\n**除此之外，我还应该做些什么呢？**\n首先，**开始依靠你的想象力而不是记忆力来过日子。**\n我想说的就是，要想释放你心智的、身体的和灵魂的潜能，首先就得学会扩展自己的想象力。你看，事情通常都会发生两次：第一次是在头脑中形成；接下来才会在现实中发生。我把这个过程称之为‘蓝图’，因为你周围发生的任何事情都来源于你脑中的蓝图。要是你学会了控制自己的想法，学会了生动地想象所有你期望的东西，蛰伏在你身体内的意志力就会渐渐苏醒。你就能够释放出心智中真正的潜力，从而创造出一种神奇的生活。从今天晚上开始，你就可以尝试努力忘掉过去的一切，大胆地想象比现实状况好得多的生活，去想象生命中最好的境界。你会为梦想的结果而感到惊讶。 \n\n**获取幸福的奥秘其实很简单：**找到你内心中最喜欢做的事情，然后把自己所有的精力都集中到那个方向，然后付出自己最大的努力。如果你对我们这个世界上最幸福、最健康、最心满意足的人做一个抽样调查，你就会发现，他们中的每个人都寻找到了生命中属于自己的热情，然后用一生的时间去追求它。这种使命感在某种程度上还可以为其他人服务。一旦你把自己的心智能量和生命力全都集中在了你所热爱的追求上，你的生活就会变得丰富多彩，目标的实现也会变得轻松而愉快，就像你在车库边哼着小曲边贴壁纸一样，充满了闲适的乐趣。\n\n湿婆神的智者每天都要花时间静思默想，不仅思考自己身在何处，还要思考自己将去何方。他们每天都在思考，最重要的是，他们尤其重视如何通过思考指导自己不断进步，哪怕这种进步看起来是如此的微不足道。因为他们知道，只要每一天都获得一些微小的进步，那么日积月累就会产生持久而有效的成果，反过来就会引起精神世界的巨大改观。\n\n## 玫瑰之心\n“有一种控制心智的方法要远远地胜过其他方法。这是瑜伽师拉曼钟爱的方法，也是在他教给我的所有方法中最好的一个。在接受了这项指导以后，我仅仅练习了21天，就感到精力旺盛，比我在青壮年时期都更加热情饱满、活力四射。这个练习法已经有四千多年的历史了，它的名字叫作‘玫瑰之心’。” \n“‘玫瑰之心’？很文雅的名字嘛。能不能给我讲得再具体些呢？” \n“**你用这个方法进行练习时，只需要准备一朵鲜艳的玫瑰和一处安静的地方。自然的环境当然最好，不过在一个安静的房间里也可以做得很好。一开始，你要集中注意力凝视玫瑰的花心，这就是它的心脏。瑜伽师拉曼告诉过我，所谓一花一世界，一朵玫瑰花如同一个生命：在路上你会遇到尖刺，但是如果你有信心，坚信自己的梦想会实现，最终就会越过那些尖刺，进入灿烂的鲜花世界。你要学会目不转睛地凝视着这朵玫瑰，感觉它的颜色、质地和模样，深深地呼吸它的芬芳，头脑中浮想着那些无限美好的事物。在这个过程中，别的念头会悄悄溜进来，慢慢侵入你的心智，分散你的注意。这是没有经受过特别训练的心智的特征。不过你不必为此担心，这种状况将很快就得到改善。你只需要把注意力再次返回到花心点上来。很快，你的心智就会因为经受了成千上百次的训练而变得强大有力。**” \n“要做的只有这么多吗？听起来确实再简单不过了。” \n“这就是这个方法的优点，约翰，”朱利安回答说，“不过，**这个方法必须每天坚持做才会起效。在开始的几天里，你会感到这种练习看上去容易，做起来却有很大的难度，也许你连5分钟都坚持不到。这也说明我们大部分人的生活节奏太快，都好像得了躁狂症一般，真正的安宁和沉默仿佛是宇宙之外的东西，让人感到很不舒服。**  很多人听到‘玫瑰之心’的建议之后都会说他们没有时间坐下来盯着一朵花傻乎乎地看上半天。有趣的是，也是这帮人还会向我诉苦说，他们没有时间享受孩子的笑声，也没有时间光着脚在雨中漫步。这些人们总是抱怨说他们太忙了，没有时间过那种闲适的生活。他们甚至没有时间去结交新朋友，因为建立友谊也是要占用大量时间和精力的。” \n\n“**要学习持之以恒的信念，花越来越长的时间去感知花心**，”朱利安继续用他低沉的声音说，“**也许在一两个星期以后，你就差不多可以在这个练习中坚持到20分钟，而不让自己的思想分散到其他的事情上去。这将是你修心养性并有所获得的第一个标志，你夺回了心智的控制权。你命令它关注哪个事物，它就会把注意力集中到哪个事物上去。那时，心智就成了最好的仆人，可以为你完成许多不可思议的事情。记住，不是你控制心智，就是它反过来控制你。**” \n\n\n## 静思默想\n湿婆神的智者每天都要花时间静思默想，不仅思考自己身在何处，还要思考自己将去何方。他们每天都在思考，最重要的是，他们尤其重视如何通过思考指导自己不断进步，哪怕这种进步看起来是如此的微不足道。因为他们知道，只要每一天都获得一些微小的进步，那么日积月累就会产生持久而有效的成果，反过来就会引起精神世界的巨大改观。\n\n最少每天抽出10分钟也是可以的。\n\n## 对立思维法\n在消除内心烦恼和其他负面情绪方面，还有一项特别有效的技巧。这项技巧建立在瑜伽师拉曼称之为‘对立思维法’的基础之上。**在伟大的自然法则下，大脑在同一时间只能拥有一个想法。**\n因此，任何人都可以在短暂的时间内很轻松地创造出一种积极、有新意的思维。过程简单而直接：如果有一个令人不快的想法在头脑中占据了主要的位置，就马上试着用一个鼓舞人心的想法去替代它。你的头脑就好比一个非常巨大的幻灯放映机，出现在头脑中的每一个念头都仿佛一张幻灯片。每当银幕上出现了令人不悦的画面，就用最快的速度拿起一张内容积极的幻灯片去替换掉它。\n\n## 湖水的秘密\n每件事情都会发生两次，第一次发生在头脑中，第二次是在现实中得到印证。我已经意识到思想也是现实，是物质性的信息，当我们把思想散播出来，其实也就改变了现实的世界。我也曾经对你说过，如果你希望在外部世界中获得显著的改善，首先就得从内在精神世界的改善开始，要学会改变你自身的思想与品格。 \n“喜马拉雅山上的智者有一个很好的办法来确保他们思想的纯净，而且有益于身心的发展。这个方法在把人的内在愿望转化为现实力量方面也显得极为高效，尽管它很简单。而且这个方法对任何人都有效。无论是汲汲于扩充人生财富的年轻律师，还是希望丰富家庭生活的妈妈，或者是希望完成更多销售量的推销员，都可以从这个方法中受益。智者给它命名为‘湖水的秘密’。在训练这个方法时，智者早晨四点钟就起床洗漱了，因为他们认为清晨时光之中包含着神秘的要素，他们可以从中感受到宇宙的脉动。这些智者沿着陡峭而狭窄的山路缓缓行走，这些道路最终把他们引向河流的下游。他们到那儿以后，就顺着一条几乎看不出来的小径继续走，两边是伟岸的青松和异样繁茂的鲜花。他们就这样一直走到一片开阔的空旷地。空地边上是一汪青绿色的湖水，这时水鸟还在沉睡，四周一片寂静。那种安静平和的情景仿若仙境。智者告诉我说，这个湖在很早很早以前就已经是他们祖先的朋友了。” \n“**‘湖水的秘密’是什么？**”我不耐烦地打断了他的话。 \n朱利安不急不躁地解释说，**智者会观察平静的湖水，想象他们的梦想化为现实。湖水如同一面命运的镜子，所有的欲望都能够完整地投射于其上。如果他们希望在生活中养成训练有素的良好习惯，他们会想象出自己在凌晨起床的样子，一丝不苟地完成他们严格的身体养生锻炼，时间在静默无声地提高个人意志力量的过程中悄悄流逝。如果他们想要寻找更多的快乐，就会满怀喜悦地注视着湖面，想象自己毫无节制地大笑的模样，或者回想自己遇到兄弟姊妹时在脸上浮现出的发自内心的微笑。如果他们寻求勇气，就会想象自己在面对危机和挑战的时刻是如何非常有力地行动着。而湖水就像一位仁厚的智者给他们以巨大的支持。中国人所说的“仁者乐山，智者乐水”，也许就是这个意思。** \n“还有一次瑜伽师拉曼悄悄对我说，当他还是个孩子的时候其实也非常缺乏自信心，因为他比同龄男孩的个头要小得多。虽然他们的教养都很好，依然能够态度温和地对待他，可在自卑感的暗示下，他还是变成了一个害羞的、没有安全感的人。为了弥补这个欠缺，拉曼独自来到那个天堂似的所在，把湖面当作内心映像的屏幕，尽力想象他所希望成为的那种人的形象。有些天里他看到自己成为了强有力的领导者，坐在高高的殿堂上，声音宏亮而果断地发号施令。而另外一些时候，他会看到自己老年的形象：一个博学的智者，具有无限的内在潜力和坚韧的性格。所有他希望在自己的生命中能够拥有的美德，他全部都在湖面上先看到了。 \n“通过几个月时间的静观，瑜伽师拉曼真的成为了他在意念中看到自己想要成为的那种人。你看，约翰，心智就这样通过头脑的想象产生了巨大的效果。**内心的图像可以影响到你的自我想象，而你的自我想象又会影响你在感觉、行动和进取方面的方式。**如果你的自我想象告诉你，你太年轻，成为不了一名成功的律师，或者你年纪太大，改不掉那些坏习惯，那么你就永远不能实现这些目标。如果你的自我想象告诉你说，要过一种丰富的、有目标的生活，要有良好的健康状态和幸福感，这些不仅是为了你自己，也是为了身边人们的幸福，那么这类预言最终会成为你的现实。 \n“而且，当你在头脑的屏幕上播放这些令人欢欣鼓舞的图像时，良好的变化就会开始显现在你的生命里。爱因斯坦曾说过，想象力比知识更加重要。**每天你都得抽出一些时间来进行冥想，即使只有短短的几分钟，也要有意练习创造性的想象。**在这一刻，尽可以把自己视作自己希望成为的那种人，不管这个形象是一位大法官，还是一个好父亲，或者是社区里的一个好居民。”\n “我知道，这一定是一个非常古老但是也非常有效的办法。我的孩子在看《哈里・波特》，里面有一面魔镜，波特照镜子的时候看到了他父母的模样，而他的好朋友红头发的荣恩照镜子时看到的却是自己成为了全校国际象棋冠军的时刻。镜子折射出的形象往往是自己最渴望见到的模样，畅销书就是这样感动我们的，不是吗？”我毫无顾忌地说出自己的想法。“还有啊，我一定要找到一汪特殊的湖水才能练习‘湖水的秘密’这个方法吗？我一定要每天一大早跑到郊外去苦思冥想吗？”我忍不住继续问，“你知道，这对生活在都市中的人来说简直是天方夜谭啊。” \n “你不必这么循规蹈矩。**‘湖水的奥秘’只是智者对这个古老技巧给出的一个称呼而已，其目的是要用积极的想象来影响心智，并不是让你拘泥于其中。你可以根据自身情况灵活机动地作出调整，比如在自己的客厅里，甚至就在办公室里来练习这个方法。只要你真的想这么做，那么随时随地都可以。**你可以试一试，先关紧房门，关掉手机，闭上眼睛，然后慢慢地做几次深呼吸。两三分钟之后你就会注意到，你真的开始感到周身放松。接下来，在头脑里想象出所有你希望的东西，想要拥有的，或者想要达到的。如果你想成为世界上最好的父亲，就想着自己正在开怀大笑，你的孩子们正围着你快乐地玩耍，而你呢，则不厌其烦地解答他们各种各样匪夷所思的问题。你还可以想象自己举止优雅、充满爱心的样子。通过这种方法，先在头脑中演练自己的形象，等到相仿的场景在现实的情境中真的出现时，你就可以完全施展自己的潜能了。 \n “想象自己形象的方法可以适用于很多种情况。你可以利用它来使自己在法庭辩论中更富有逻辑，你可以利用它来改善自己的人际关系，当然你也可以借此发掘自己的精神潜能。持之以恒地使用这种方法还会带给你社会声望的回报，以及丰厚的物质收获，如果你觉得这些东西对你很重要。**如果你觉得生活中缺少了什么，那是因为你的头脑中并没有这种东西。记住，要在头脑中留住美好的画面。一旦你开始练习这种方法，它就会让你彻底领会到心智所具有的神奇威力，开启大脑的潜力，它实现你生命中一切渴望的东西。**” \n “瑜伽师拉曼和与他居住在一起的**智者都经常提到一句老话，这句话世代相传，流传至今。我很幸运在这个对我们两个来说都很重要的夜晚将这句话转告给你。话是这么说的：“凌驾于他人之上毫无尊贵可言；真正的尊贵是超越以往的自我。’如果你想达到我真正达到的那个境界，与你认为有意义的东西并驾齐驱的话，你就必须首先和自己赛跑，向自己发起挑战。何必在意别人怎么议论你呢？最关键的是你自己的想法。只要你能够确定自己的所作所为是正确的，就不要总是去在意他人的眼光，那样会让你变得畏首畏尾。你要告诉自己，你可以做任何你想做的事情，只要你的良知和内心都认为它是对的。千万不要为自己做了正确的事情而感到害羞。根据你所认为的好坏标准来作决定，然后毫不犹豫地坚持这种看法与做法。一定记住，千万不要堕入那种器量狭隘的计较之中，把自己的自尊和别人的非议评判作比较。就像瑜伽师拉曼倡导的那样，‘你在思考他人的梦想时耗费掉的每一分钟，都会将你到达自己梦想的时刻向后推迟一分钟。’**”\n现在已经是半夜十二点零七分了。和平常不一样的是，我丝毫也没有感觉到疲惫。当我把这种感觉告诉朱利安时，他又一次露出恬静的微笑：“你已经学会了另一种开启生命的方法。就大部分人来说，疲惫是心智匮乏的产物。没有梦想、没有方向感的人所过的生活常常是碌碌无为、疲惫不堪的。让我给你举一个例子。你有没有这样的体验，比如整整一个下午待在办公室里，强迫自己阅读那些干巴巴的案情报告。很快，你的心智就开始溜号，然后你也逐渐地睡意蒙眬起来？” \n“有时候的确是这个样子的。”我回答说，其实内心并不愿承认，但事实上这恰恰正是我目前的工作常态。“当然，我们大多数人都会在遵循惯例、按部就班的工作中感到昏昏欲睡。” \n“可是，如果有一个朋友打电话来，问你想不想晚上出来一起看场棒球比赛，或者请你为他的周末高尔夫球比赛出谋划策，我敢说你一下子就精神起来了，任何疲惫的痕迹都一股脑儿地飞到爪哇国去了。我说得对吧？” \n“我承认确实如此，尊敬的顾问先生。”面对朱利安我只好讲实话，当然也故意用一种油腔滑调的语气来掩盖自己被人窥破心思时的不安。 \n朱利安从我的语气中知道他抓住了问题的关键，于是他更来劲了。“所以，你的疲惫不是别的，无非是匮乏的心智的产物。你的心智养成了坏习惯，当你从事一项单调而冗长的工作时，心智就成了挡路石。很明显，今天晚上你被我讲的故事吸引住了，开始对我希望与你分享的智慧感兴趣。**记住，你的兴趣爱好和心智注意力都会给你的日常生活带来源源不断的活力。在这个晚上，你的心智既不再关注过去，也不再关注未来，它就聚焦在当下，聚焦在我们的话题上。如果你经常把心智引向当前的生活，你就一定会得到无尽的活力，不管钟表上指示的时间是深夜十点钟还是十二点钟。**” \n\n# 灯塔，代表目标\n在花园的中央伫立着一座明亮的灯塔。这个象征提醒你记起另一条启示生命奥义的古老原则：**生命的目的就是有目的地生活。**那些真正开悟了的人们知道他们将要从生活中得到什么，比如情感的、物质的、身体的，或者是精神的。他们把先后的顺序排列得清清楚楚，经过严密的统筹安排之后，生活中每个方面的目标都会发挥出类似于灯塔那样的作用，在海面上风起浪涌的时候会给你指引航向，为你提供安全的避难所。你看，约翰，只要彻底地改变了人生的进取方向，任何人都可以将自己的生活来个焕然一新的改变。但是如果你根本不知道你从哪儿来，又要到哪里去，那你又怎么可能知道自己什么时候会到达那个不知所终的地方呢？\n\n“生命真是太奇妙了，”瑜伽师拉曼大发感慨，“人们可能会认为一个人工作得越少，就越有机会体验到闲适的幸福。然而并非如此，或者说这是片面地理解了幸福的含义。**一言以蔽之，幸福的真正源泉就是一个词：成就。**永恒的幸福来自于为了完成目标而进行的脚踏实地的工作，来自于在接近人生目标的过程中持之以恒的努力。只要点燃潜藏在内心中的火焰，它就会创造出一个令你我无法想象的新世界。我知道这听起来多多少少有点讽刺，因为我不辞辛苦离开自己以事业成就为本位的社会，艰难跋涉了几千里路，向居住在喜马拉雅山高峰上的神秘智者请教，希望得到关于幸福的永恒奥秘，却听说孜孜以求的幸福奥秘在于成就，可事实的确如此。\n\n成就并不一定需要用物质来衡量。就我个人而言，我的目标就在于获得内心安宁，学会控制自我，学会了悟人生。如果直到生命的尽头，我还是不能达到以上这些目标，我相信我会死不瞑目，因为我没有抵达自己的圆满状态。\n\n我的意思其实很简单。当你已经明确知道在你的一生当中最希望达到的目标是什么，不管这些目标是物质的、情感的、身体的还是精神的，你都要为抵达这一目标而倾注大量的时间与精力，只有这样才能最终体验到永恒的欢悦。你的生命将和我的生命一样充满快乐，而且你将逐渐看到自己的梦想一步步演变成为光灿灿的现实。但是这一切的前提在于，你必须首先了解自己，制订出明确的人生目标，然后通过持续不懈的努力把它转化为现实。我们称其为“达摩”，这是一句梵语，意思是‘生命的目标’。\n\n**很多人在发现了自己存在的真正目标之后马上放弃了限制自己人性发展的工作，即便这项工作为他们赢得了巨大成功和丰厚的物质回报。**这的确像是一场冒险，伴随着对自我的研究和灵魂的探索，你要学会不断地丢弃一些身外之物。可是也不能完全将它说成是一项冒险，因为在发现自我和人生的使命方面原本没有什么风险可言——在智者看来，发现自我这项工作本身就是人生体验中相当重要的一个环节。自我认知是开启人生的DNA生命链，它的确是生命中最关键的东西。\n\n我的达摩相当简单：无私地帮助他人，丝毫不考虑任何回报。记住，你不能在呼呼大睡中发现人生真正的快乐。同样，在游乐场或者像个游手好闲的人那样恣意消磨时光，也不可能抵达人生的真知。正如本杰明・迪斯雷利[3] 说的那样：**“成功的秘密在于不屈不挠地坚持自己的目标。’你所寻求的幸福是从有价值的目标中得来的，你付出所有的精力去争取成功，每天、每小时都努力地去接近这个目标。这是永恒哲理在现实生活中的应用，它规定了哪些事情是最重要的，永远不能被另外一些不重要的事情掩盖掉。在瑜伽师拉曼的寓言里出现的灯塔会一直提醒你，制订明确而有意义的目标有多重要，以及实现这些目标需要怎样的力量。**\n\n确立目标是最基本的出发点。制订出你的方向和目标，就可以把创造力的潜能加以放大释放，最终促使你踏上通向目标实现的道路。信不信由你，瑜伽师拉曼和其他智者都热衷于不断设定目标*。\n\n把我所有的智慧都和你分享。今天的这个例子就是为了进一步说明在人生中设立一个明确目标，以及清楚地知道你将往哪里去的重要性。你刚才见到的那一幕就说明了这个最为重要的原则：**你一定不可能命中你根本看不见的目标。人们用去整整一生的时间来希望自己变得更加幸福，活得更有活力，拥有更加丰沛的激情，然而他们没有发现这个重要原则。你要学会，每个月抽出10分钟的时间，把自己的目标写出来，仔细地想一想生活的意义何在、人生根本目的何在。设立一个明确的目标可以让你的人生过得与众不同。你会变得更加丰富，更加愉快，拥有更加不可思议的精力。**\n\n任何一个希望同时提高自己的内心品质和外在条件的人都要学会定期拿出一张白纸，认真地在上面写下自己的人生目标。\n## 一页纸在上面写出自己的目标\n此前我已经告诉过你，我们的头脑中平均每天会出现60,000个想法，然而这些想法太多了，多得你自己都容易迷失在欲望的丛林中。这个时候，在一张纸上写出你的愿望和目标就显得尤为关键。这一举动意味着你给潜意识的幽昧丛林中插上了一杆红旗，让这个想法比其余的59,999个想法突出得多。你的心智因此就像雷达一样，开始寻找一切机会去实现你的愿望。这个过程的确非常有效，可惜我们当中的绝大部分人对此视而不见。\n\n愿望成真，一共需要有五个步骤\n第一步是要对自己预期的结果有清楚而具体的认识。第二步是制造一种积极的压力来鼓舞自己。相对来说，第三步是非常简单的，那就是绝对不要好高骛远，设立一些不合时宜的目标。当你决心将人生和某一个目标相连，就意味着你必须给它设定一个明确的最终实现期限。这就如同你在为庭审准备大量的卷宗，你的注意力会一直集中在法官身上，因为他将决定庭审的日程安排。相反，其他人的话对你似乎没有任何影响。\n让我们回到达到目的、实现目标的五步法上面吧。一旦你对未来的结果有了一个非常清晰的成形设想，也为此创造出了一点积极的压力，并划定了最后实现的期限，甚至当众许下了完成它的诺言，那么接下来要做的一个步骤就是瑜伽师拉曼称之为‘神奇的21天法则’的方法了。\n最后我所说的就是，在你实现自己目标的过程中，一定要确保自己随时处在兴致盎然的状态。永远也不要忘记纵情狂欢的重要性，永远也不要忽视在所有的生命中都能看到精致的美丽。今天，以及你我一起分享智慧的这一刻都是上天的恩赐。保持你昂扬的精神、愉快的心情和好奇心。随时都要密切关注自己的毕生事业，随时都准备好要给予别人无私的帮助。宇宙对万物都一视同仁，这也是大自然的真理法则之一\n\n\n## 热情\n热情。这个词汇你一定要始终牢记在头脑里面。热情是实现梦想最根本的动力源泉。在我们这个碌碌无为的社会中，生命的热情早已经消失了。有的时候我们之所以什么也不愿意做，那是因为我们喜欢这样一直待着。而当我们开始动手做事情的时候，则是因为我们感到不得不做，只好没精打采地应付差事。这就是制造痛苦恶性循环的公式。不过我现在说的并不是那种浪漫的热情，尽管那也是促进成功、振奋人生的要素之一。我现在所说的是对生活的热情。每天早晨醒来时就要不停地对自己加油鼓劲，让自己浑身活力充沛，快乐无拘。热情是你工作中的加油站，热情的火焰越烧越旺，那么通向自信与成功的道路就越光明。你很快就会有丰厚的物质收获，同样还会获得精神上的巨大回报。\n\n## 禅悟\n意思是指不间断的、永不尽头的提升。\n\n怎么用来丰富智者的生活呢？\n**外在的成功首先开始于内在的成功。如果你确实想要改善自己的外在世界，不管这种外在世界指的是你的健康，你的人际关系，还是你的财产状况，你都必须先努力提升自己的内心世界。最有效的途径就是持续不断地进行改善自我的实践与练习。掌握自我就是掌握人生的DNA密码。**\n\n中国古老的智者曾经说过：“道在屎溺中。’意思就是说宏大的人生哲理其实恰恰隐藏在看似平淡的日常生活细节之中。\n\n在我们这个社会里，我们都太轻易地把无知看作是缺陷。然而，那些表现出自己缺乏知识，希望找到指引的人其实并不需要感到害羞，因为他们比其他人更早地意识到自己的问题，也就能够去更早地发现通向开悟的道路。你提出这个问题证明你非常诚实，让我看出来你的确愿意接受新理念。要知道在我们目前的这个社会里，改变是最强大的动力。大部分平庸的人害怕改变，而智慧的人则拥抱它的威力。禅悟代表的东方修行传统着重讲的是起步者的心智：那些敞开自己的头脑，随时准备接受新观念的人——也就是那些总是让自己的杯子空空如也的人——总是会在成就和满足感的方面达到更高的水平。千万不要羞于提出哪怕是最基本的问题。提问是获得正确知识的最有效的途径。\n\n当我说到提升你的内心世界时，我只是简单地描绘了一下自我改善和个体发展的功效，并告诉你这是你能够为自己做的最有价值的事。或许你会觉得太忙了，没有时间花在自己身上，当然也无须奢谈什么改变。如果你这么想，那就大错而特错了。你要知道，当你把自己培养成一个纪律严明、活力充沛，充满乐观情绪的人时，你就可以在外部世界中拥有所有的东西，做所有你想做的事情。当你对自己的能力和不屈不挠的精神产生了深刻的自信，那么任何东西要想成为阻挡你胜利的拦路石，那真的就是螳臂当车了。在控制自我心智上多花些时间，时刻关注自己的身体，丰富自己的灵魂，都会使你的生活会变得更加丰富，更有生命力。许多年以前，斯多葛学派的爱比克泰德就曾经说过：“一个不能控制自己的人就不是自由人。\n\n**禅的本意是静虑、冥想，悟与迷对称，指觉醒、觉悟。悟是意义的转化、精神的转化、生命的转化，含有解脱的意义。禅是修持方式，悟则是修持结果，两者是有区别的。但是东方的禅宗学人却把禅由坐禅静思变为日常行事，由心理平衡变为生命体验，这就从根本上改变了禅的内涵。东方的禅宗学人还认为觉悟要由日常行事来体现，由生命体验来提升。禅与悟是不可分的，悟必须通过禅来获得，禅没有悟也就不成其为禅。没有禅就没有悟，没有悟也就没有禅。**\n\n接下来我开始思考究竟能够从哪些方面来提高自己的修养。让我一项一项地来看看吧。第一，定期的锻炼可以给我带来活力，这样我才能够保持健康良好的体格与心态。第二，控制我的坏脾气，不要随便打断别人的谈话。如果能够改正这些毛病，可能会在人际关系方面给我和妻子、孩子以及同事的相处带来意想不到的好处。第三，改掉忧虑的坏习惯。这可以带给我心智上的安宁和平静的幸福感。第四……我越想越兴奋，因为我发现在我身上能够进行改善的地方实在太多了，可这些我以前却从来没有注意过。 \n\n## 建立人格力量、培养心智和充满勇气地去生活\n他耐心地谈到建立人格力量、培养心智和充满勇气地去生活具有多么重要的地位。他告诉我说：“这三种品质不仅可以让人拥有高尚的生活，而且可以使他的生活中充满成就感、满足感和内心的安宁。勇气这个宝贵的品质是每个人都可以培养得到的，它在经久不息的跋涉中带给你巨大的回报。**” \n  “**勇气和自我领导、自我发展又有什么关系呢？**”我大声问他。 \n  “**勇气使你敢于正视自己，与自己的惰性赛跑。勇气使你敢于去做所有你认为是对的事情。勇气使你能够控制自我，在其他人失败的地方仍旧支撑你继续坚持下去。最终，你拥有勇气的多寡程度决定了你可以获得的成就的总量，这是一个有趣的正比例关系。它能够使你确切地从自己的生活中看到所有不同寻常的奇迹。另外，我还想告诉你，能够掌控自我的人都是拥有非凡勇气的人。\n## 心智、身体和灵魂\n在我的新生活里也就更加信奉禅悟的哲学，让心智、身体和灵魂都持续地、永不休止地获得自然的点化，在丰富心性的过程中不断提高。朱利安这样说。 \n为什么这些天以来我听到这么多次‘心智’‘身体’和‘灵魂’之类的词语？你要是不稍微解释一下，我还真拐不过弯来。\n  “**这三个词语是你作为人的天赋中非常重要的三部分。简单地说，它们三者之间是相辅相成的关系。比如不锻炼身体，仅仅注重于提高心智，就只会得到非常空洞的胜利。如果你把心智和身体能力都提升到了最高水平，却没有认真地丰富自己的灵魂，会使自己感到异常地空虚，无法获得满足感。但是一旦你用出所有的力量来释放本性中这三个部分所有潜能的话，你就会在人生突然开悟的那一刻享受到神圣的狂喜。\n## 人们在艰难地进入未知区域的时候会变得最为强大\n首先我必须和你一起分享一个实际的例子。请你摆出俯卧撑的姿势来。当然，依你现在的身材，你还能趴下吗？”朱利安不失时机地揶揄了我一下。 \n  “天哪，朱利安变成军事训练官了。”我暗自想着。出于好奇，也是为了像朱利安所说的“保持我的杯子空空如也”，我只有老老实实地照办。 \n  “现在，使出全身的力量做俯卧撑，不要停下来，直到你确定自己彻底没劲为止。让我们数一数你到底还能够做几个。”朱利安在一旁笑着说。我的天，他只差手里再握一只秒表了。 我挣扎着做起了俯卧撑。多少年了，我那肥胖的身躯从来都没有进行过这么多的运动，除了有那么屈指可数的几次，我和孩子们一起走到最近的一家麦当劳快餐店，或者和我的法律界同行们一边漫步一边打一轮高尔夫球。最初的15个俯卧撑完全像是垂死挣扎。我开始暗自抱怨这个闷热的夏季，黎明之前的气温依然使得我大汗淋漓。然而，我已经下定决心，坚决不要显出任何虚弱的迹象，坚持下去，直到我的虚荣心和手臂一起无法坚持的时候再停下。 \n  不过我的虚荣心显然没有那么坚强。在做到第23个的时候我放弃了努力，结结实实地趴在地上。 \n  “不行了，朱利安。”我一边喘气一边忍不住抱怨起来，“这简直是要杀了我。你这是打算干什么？” \n  “你确定自己一个也做不起来了吗？”朱利安的表情十分严肃，丝毫没有开玩笑的意思。 \n  “我确定。算啦，让我喘口气吧。我唯一的感觉就是，我再动一动就会造成一次心脏病突然发作。那时你一定记着打急救电话啊。” \n  “再做10个。然后你就可以休息了。”朱利安命令道，他的口气似乎没有商量的余地。 \n  “你说话不算数！”我愤愤不平地抗议道。然而为了能够获得朱利安的教导，我只好咬着牙坚持继续做下去。1个……2个……5个……8个……最后总算做了10个。我连翻身的力气都没有了，直接趴在地板上，觉得天都快要塌下来了。这时，耳边响起朱利安清晰的声音： \n  “瑜伽师拉曼和我在一起分享他的特别寓言的那个晚上，我也像你这样经受了训练。不过，唯一的区别在于我做的俯卧撑是你的好几倍。”朱利安说。“当我体力不支趴在冰冷的地板上的时候，拉曼镇静地对我说，痛苦是最伟大的老师。” \n  “痛苦是最伟大的老师？从这样枯燥的身体练习中究竟能够学到什么呢？”我气喘吁吁地问他，丝毫也不掩饰我的抱怨之情。 \n  “瑜伽师拉曼，还有所有居住在喜马拉雅山上的智者在这个问题上都保持了完全一致的看法。他们认为，**人们在艰难地进入未知区域的时候会变得最为强大。**” \n  “好吧。我相信你的话是有道理的。但是这和俯卧撑有什么关系呢？又有什么理由让我非得做这么多俯卧撑不可呢？” \n  “当你做了23个俯卧撑之后，你告诉我力气用完了，一个也做不起来了。我相信你对我说的话，在你的意识表层中，那真的是你的极限。然而，当我一定要求你再多做几个，你听从了我的话以后就又多做了10个俯卧撑。这说明了什么呢？” \n  朱利安不等我回答，紧接着给出了答案：“**这说明潜伏在你身体里的力量还有很多，只不过平时它们都在沉睡状态，缺乏足够的刺激将它们一一激活。一旦这些力量醒来，一旦你发现了自身力量源泉的时候，你就会发现自己其实比预想的要强大得多。其实类似的事情在生活中也是屡见不鲜的。比如报纸上会登载一条新闻说，某人因矿难而被深埋在地下半月之久，却能够依靠强大的求生意志而存活下来。或者说一个人从高空坠落，因为掌握好了身体的平衡感而幸免于死。相信你一定读到过这些新闻，不过你通常是把它们当作茶余饭后的街头怪谈，却没有冷静下来仔细想想其中的一些奥妙。这是关于生命的奥妙**。 \n  “**当我还是瑜伽师拉曼的学生时，他向我解释了这个基本原理：“生命中唯一的极限是你自己给自己设下的。’当你勇于从惰性的圈子中跳出来，打破陈规，向未知领域探索，你就开始释放本性中的潜能了。这是走向自我控制的第一步。当你把自己的极限推得更远，就像你在这次小小的示例中做的这样，你就会不断地开发出心智和体力的潜能，那是你从来不曾想、也不敢想的东西。而事实上，你原本有足够的能力去获得它。**” \n  \n“太棒了。”我心想。突然，我记起了在最近看过的一本书里说，普通人的个人才能只有很微小的部分得到了利用，如果每个人都把自己沉睡的才能唤醒，那每个人都将是天才。“我很想知道，如果我们学会运用能力中其余那些沉睡的部分，我们又能做出什么呢？” \n这个问题让朱利安有些为难。他挠了挠头，想了一下，然后回答道：“你刚才实践了‘禅悟’的技巧，相信我，这种技巧每天都可以使你进步。也许以下这些方面是你近期要努力的事情。 \n“**努力提高自己的心智，改善身体的健康状况，让自己能够随时做到聚精会神。做那些让你感到恐惧的事情，这样就可以消除心魔，开始拥有无限的精力和无边的热忱**。 \n“**你还要学会融入大自然，认真观察日出时的动人情景，也可以试着在雨中自由舞蹈。** \n“**你要坚守自己的目标，每天都朝这个方向行进，这样才能真正成为你梦想成为的那种人。 **\n\n“**不要害怕出错，要鼓足勇气做你一直想做的事情，而不是自欺欺人地找借口拖延，嫌自己太年轻或者太年老，太贫穷或者太富裕。** \n“**准备好过一种目标远大，精神活跃的生活。在东方，人们常常会说，机会总是留给有准备的人。而我则深信，生活也偏爱有准备的人。**” \n**朱利安继续他热情洋溢的谈话，好像是一所大学课堂上的哲学老师。“认真分析生活中那些阻碍你的因素，然后想方设法去克服它。从多方面好好反省自己，比如你是不是害怕演讲，或者在人际关系上有麻烦？你是不是缺乏积极的人生态度，或者需要更多的精力？接着列出一份详细的目录，将自己的弱点一一登记在案，然后有的放矢地改正它们。在工作中容易得到满足感的人们往往比不思进取的人更加深思熟虑。把时间花在寻根究底上，就可以让你明白自己和所希望的生活之间的差距究竟有多远，还要对眼下的生活状态了若指掌。” \n“一旦你看到了自己的弱点所在，那下一步的工作就是要直接面对它们，向自己的恐惧心理开战。中国有句俗话叫作‘怕处有鬼’，人们通常会被自己臆想出来的怪物吓傻了。恐惧只不过是你自己在头脑中制造出来的怪物，是一连串的负面意识。所以，要克服自己的心理痼疾。如果你惧怕当众演讲，就专门签约进行20场演讲，哪怕你要为此支付主办方一定的费用。如果你固守陈规，害怕开展新业务，或者想逃避不愉快的人际关系，那就专门给自己制造这方面的挑战环节。只要你迈出第一步，后面的路就好走了。当你像一只蝴蝶从蛹中破茧而出的时候，那将是你在这么多年以来第一次尝到真正的自由的滋味。\n\n恐惧是一种条件反射，如果你不留神的话，它很快就会把生命力、创造力和精神都消耗殆尽。一旦恐惧满怀恶意地探出它丑陋的脑袋，你就应该一下子把它击垮。最有效的办法就是去做让自己感到害怕的事情，借此完全了解恐惧的内在结构。当你进入了恐惧的内部，就会发现它不过是源于你自己的胡思乱想。就像任何其他人创造出来的东西一样，把它揭穿就像把它创造出来一样简单。你可以学着有系统、有方法地查明底细，看清楚蛰伏在你心智深处的每一种恐惧到底都是什么，而后再一一击破。长此以往就会带来无限的信心、幸福和内心的安宁。**” \n\n**“真的有人拥有无所畏惧的心灵吗？”我问他。\n“问得好。我将毫不犹豫地断然回答：‘是的！’喜马拉雅山上的智者个个都毫无畏惧。你可以从他们走路的样子上看出这一点，可以从他们的谈吐内容上听出来这一点，也可以在深深凝视他们双眼时发现这一点。其实生活中有很多这样的例子，电影《勇敢的心》你看过吧？” \n朱利安顿了顿，接着凑近我说：“我再给你说点别的，约翰。” \n“什么啊？”我问他，心中对他刚才讲到的事情充满了好奇。 \n“**我也曾一度胆小如鼠。对此我心知肚明，因此就打算进行一次自我清理，找到天生的意志力和无限的潜能。后来我找到了胆小的根源，正是因为这么多年来一直忽略自我以及思想发展的不平衡阻碍了我的发展。我再告诉你一件事。当你把恐惧从头脑中彻底驱逐出去之后，你就会变得更年轻，也变得更有活力。**” \n\n“啊哈，**古老的身心联系**。\n\n\n## 迎着弱点和恐惧直面而上\n另外一条非常有效的法则，我也时常会想到它。我觉得，当你走在引导自我和控制自我的道路上时，这条法则对你而言将是无价之宝。每当我想要投机取巧的时候，它就会批评我，给我以上进心。这一人生哲学可以简单地归纳为：行事高效的人和死气沉沉的人之间的最大区别在于，前者会去做后者不喜欢做的事——尽管他们可能也不愿意去做。** \n“**真正开悟的人，每天都可以体味到深沉的幸福感，随时准备着为了长久的满足而放弃短暂的快乐。他们就这样迎着弱点和恐惧直面而上，即便有时因为深陷未知的领域而感到极大的不自在也无所谓。他们下定决心，要依靠‘禅悟’的智慧来生活，永不间断地提高人生的各个层面。过去曾阻碍他们获得快乐、健康和富有的恐惧也会败下阵来。\n## 幸福要通过对一个有价值目标的渐进实现才能得到\n我最喜欢的教授给我讲过的一个古老故事。 \n有一天晚上，一位父亲在办公室工作了一整天以后开始拿着报纸看，想享一会儿清闲。可他的儿子很想玩，就一直缠着爸爸。最后，这位父亲被搞得不耐烦了，气呼呼地扯下一张地球画报，撕成了一大把小小碎片。“来吧，儿子，过来把它们重新拼在一起。”他说着，希望这一招可以让孩子忙上好一阵子，以便自己可以从容地看完手中的报纸。 \n让他大吃一惊的是，还不到一分钟，他的儿子就兴冲冲地带着一张拼贴无误的图片回来了。当这位目瞪口呆的父亲问儿子是怎样完成这个拼地图的壮举时，儿子笑得甜甜的，轻松地回答说：“爸爸，在这张地球图片的反面是一个人的图片，只要我把这个人拼在一起了，世界地图也就完整了。” \n“真是棒极了。”我不由得赞叹起来。 \n“你看，约翰，从喜马拉雅山上的智者到哈佛法学院的教授，在我认识的最有智慧的人当中，似乎每个人都洞悉了幸福公式的要领。\n\n幸福要通过对一个有价值目标的渐进实现才能得到。当你在做自己全心全意热爱着的事情时，就一定会感到深深的满足。\n\n## 做你喜欢的事情，需要很大\n\n我不妨再说得明确点，约翰。做你喜欢的事情，需要很大的勇气。它意味着你为了当演员要放弃手边正在做的工作，在不那么重要的事情上少花些时间，留下时间给更有意义的事情。它要求你离开习以为常的规律，也就是抛弃惰性，勇于创新。这种变化在最初的时候总会有些让人难以适应，而且具有一定的风险。但请一定记住我前面反复说的话，这正是走向快乐人生的起点。\n\n一个人究竟应该怎样鼓起勇气呢？\n这也像刚才故事里所说的：只要你可以控制自己，你的世界就没问题了。只要你能控制自己的心智、身体和品质，幸福和富裕就奇迹般地来到你的生命中。但是，你每天都要在自我完善上花一些时间，哪怕只有10到15分钟。\n\n# 相扑选手，注意‘禅悟’的提示者\n这位肌肉发达的大块头就是不断提醒我们注意‘禅悟’的提示者。这个词在日语中的意思就是持续的自我发展和进步。\n\n我已经明白了自己的心智其实是那么神奇，宝贵的潜能又将创造怎样的奇迹。我已经学会了非常高效的技巧，可以把能量集中到我的愿望和梦想上。我已经知道在生命中树立明确目标的重要性，要在我人生、职业和精神世界的每一个方面都设立非常清楚的目标。现在我已经完全接受了那个自我掌控的古老法则：“禅悟”\n\n\n## 活力生活的十个招数\n### 孤独的习惯\n第一个办法被智者称作‘孤独的习惯’。所要求的无非是你在每天的日程表上划出来一段时间，这段时间用来保持自我的宁静，哪怕是一段强制性的自我宁静。\n\n这段时间少则15分钟，多则50分钟。在此期间你要感受沉默的力量，要渐渐领悟到你究竟是谁。\n\n把‘孤独的习惯’想成是灵魂长途跋涉中的短暂休息。它的目的就在于获得自我更新的机会，通过独自一人沉浸在美丽的沉默当中来实现。” \n\n“沉默有什么特别之处吗？**” \n“问得好。**沉默和宁静把你和内部世界的创造力源泉联结在一起，解放所有智力的束缚。你看，约翰，心智好比一汪湖水。在我们这个嘈杂的世界上，大部分人的头脑里都安静不下来，因为我们的内心充满混乱。然而，只要你肯每天花一点时间来静心沉默，心智也就会变得平静如镜。内在的安宁会带来丰厚的回报，包括健康舒适的感觉，内在心态的平和以及无穷的精力。你甚至会睡得更香，而且在日复一日的劳作中享受到自我更新的平衡感。\n\n“我应该到哪里去寻找这一刻的安静呢？” \n“从理论上说，你可以在任何地方，无论是在卧室还是在办公室。关键是要找到一个真正安静的地方——而且环境要很优美。” \n“为什么必须是优美的环境呢？” \n“**优美的环境能够慰藉不安的灵魂，”朱利安解释说，深深地叹了一口气，“一束玫瑰，或者仅仅是一支孤零零的水仙，都会很好地改善你的情绪，让你得到非常有益的放松。说得更理想化一点，你应该在“个人避难所”中尽情享受这样的优美。我突然想到了一句东方禅语：菩提本无树，明镜亦非台，本来无一物，何处惹尘埃。**” \n“什么，什么？” \n“**简单说来，就是你为了自己的心智得到扩展，为了提升自己的精神境界，要学会把一个地方变成密室。这可能是你家中的空余房间，或者仅仅是一间小公寓中的安静角落。问题是你要给自己的更新行动保留一个相对固定的空间，一个静静地等待你到来的地方。**” \n“我喜欢这种说法。我想如果我在下班回家以后有了一个安静的地方可去，就会大大改变一切。我可以在那儿先待上一会儿，缓冲一下，消除一天当中的压力。这可能让我对周围的人更加有耐心。” \n“**这就涉及另外一个重要的问题。如果你每天都在同一时间来练习孤独静处的习惯，效果才会是最好的。**” \n“为什么？” \n“**因为它会作为一个习惯进入你的日常生活，成为一个有机组成的部分。如果在每天的同一时刻都来练习它，每日按时到来的静默很快就成为不容忽略的习惯。而积极的人生习惯将最终引导你到达目标。**” \n“还有别的吗？” \n“是的。**如果有可能的话，每天都和大自然谈谈心。在树林里做个短短的散步，或者哪怕是到后院，在你的西红柿苗圃里花上几分钟去浇水施肥，都会把你和安静的源泉重新连在一起。或许现在想一想这些事情就能让你的内心恢复平静。和大自然在一起，会激发你自身无穷的智慧。这种自我认知可以在自我潜力的方向上持之以恒地推动你的进步。别忘了这一点。**”朱利安建议道。他的声音因为充满热情而慢慢提高，无论如何也听不出来是一夜未眠的人。 \n“这一招对你有效吗，朱利安？” \n“绝对有效。在阳光尚未跃出地平线的时候，我就早早起床，做的第一件事就是走到我的‘个人避难所’。那是我在练习‘玫瑰之心’时发现的，后来一直秘密地使用着。有时候我静默地沉思冥想几个小时。有的时候也许只需花费10分钟。结果大致相似：我获得了一种内在和谐的深刻感受，以及无限的身体精力。\n\n### 体格锻炼的习惯\n“关于**如何养护身体。**” \n“什么？” \n“很简单。**体格锻炼的习惯是基于一个基本原理：你只有通过养护身体才能进而养护心智。给身体做好充分地准备，才会给心智做好相应的准备。训练好了身体，才会训练好心智。你没有听东方的哲学家常常说什么‘天将降大任于斯人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为，所以动心忍性，曾益其所不能。’抽出一个整天，通过健身训练来滋养盛放心灵的殿堂。让身体活起来，让血液沸腾起来。你知道吗？一周有168个小时呢。**” \n“不，知道得不那么确切。” \n“这是真的。其中至少有5个小时应该投入在某种方式的身体活动上。喜马拉雅山上的智者一直从事着一种古老的瑜伽训练，借此来唤醒身体内的潜能。天长日久，他们变得强壮有力，生机勃勃。这些身体超群的人很特别，**他们常常在村子中央倒立，以此来保持年轻。**” \n\n“那些智者还做过别的什么来养护身体吗？” \n“**瑜伽师拉曼和他的兄弟姐妹们都相信，精力充沛地在自然的环境中散步，不管是在高高的山路上，还是在茂密的森林深处，这些都将有助于缓解疲劳，修复身体内部的细微差错，以及恢复人体活力。要是天气太差，没法散步，他们就会在小屋中的密室里锻炼。他们可能会忘记吃一顿饭，但是决不可能忘记每天的练习。**” “他们的茅屋中有什么东西？跑步机吗？”我开玩笑说。 \n“当然不是。他们有时候练习瑜伽。有时候他们会做双手或者单手直立的俯卧撑。开始我还很好奇，后来我渐渐意识到他们做什么其实并不重要。他们虽然姿势不同，但目的却是一致的，那就是充分活动身体，让四周的新鲜空气在肺部畅通地流淌，也让血脉贯通起来。” \n“呼吸新鲜空气会有什么用呢？” \n“我要借用瑜伽师拉曼最爱说的一句话来回答你：**“适当的呼吸就等于适当的生活。**’” \n“呼吸有这么重要吗？”我奇怪地问道。 \n“当我到那儿之后，智者很快就教会了我如何使自己获得两倍甚至三倍精力的捷径，我也因此学会了进行有效的呼吸方法。” \n“可是难道我们不懂得呼吸吗？这连新生的婴儿都会呀！” \n“不完全是这样，约翰。**我们中的大部分人都只是知道怎么呼吸才可以活下去，却不知道怎样通过呼吸来让自己更有活力。这是完全不同的两个层面的问题，前一个是生存问题，后一个是生活问题。大部分人的呼吸都太浅了，这样我们就不能吸入足够的氧气，导致我们的身体不能处在最佳的状态。**” \n“听上去，正确的呼吸还包含着很多科学知识呢。” \n“确实如此。那些智者是这样对待呼吸的：**通过有效的呼吸吸入更多的氧气，释放体内储藏的精力，从而达到活力收放自如的自然状态。**” \n“好啊，那么我应该从哪里开始呢？” \n“**事实上非常简单。每天两到三次，花一二分钟来深呼吸，使空气能够深深地渗透到你身体内的每一个细胞。**” \n“*我怎么才知道自己的呼吸变得有效了？*” \n“**嗯，当你使用正确呼吸方法的时候，你的腹部会稍稍鼓出来一点。这个迹象说明你开始从腹部呼吸了，这就很好。现在试试看……嗯，挺不错。瑜伽师拉曼教我的一个方法是，把双手扣在肚子上感受起伏。如果我吸气的时候肚子鼓起来了，我的呼吸技巧就算是达标了。**” \n### 生命滋养法\n那就是‘生命滋养法’。在我做律师的那些日子里，我每天的食谱都是固定的，主要是牛排、油炸食品还有其他形形色色的垃圾食品。虽然我总是在城里最好的餐馆吃饭，可还是感到身体里面塞满了垃圾。那时候我并不特别清楚，这就是让我感到不愉快的主要原因之一。**”\n“真的吗？” \n“是的。一份糟糕的食谱对你的生命有着显著的影响。它抽干你的脑力和体力，它影响你的情绪，还会扰乱你的逻辑能力。瑜伽师拉曼是这样说的：“**你在滋养身体的同时，就是在养育心智。**’” \n“那么我猜你改变了食谱喽？” \n“**我已经彻底改变了自己的餐饮习惯，比如我从来不喝有色素与人工添加剂的饮料，也不再光顾快餐食品店。不久之后，控制饮食的效果就出现了，我的感觉和相貌发生了令人惊异的变化。以前我总是以为，我之所以那么死气沉沉主要是因为工作中的压力和疲劳，而且上了年纪以后身体渐渐不中用了。到了喜马拉雅山上，我才发现我的昏睡懒散其实是因为自己给身体内注入的动力燃料实在是太低劣了。**” \n“那些智者靠吃什么东西来保持青春和愉快呢？” \n“**吃新鲜的食物。**”他的回答很简明。 \n“啊？” \n“**答案就是新鲜的食物。它指的就是没有死去的东西。**” \n“说说呀，朱利安。哪些东西属于新鲜的食物？”我急躁地问他。 \n“**说得简单点，所谓的新鲜食物就是在自然当中吐故纳新的食物，是通过太阳、空气、土壤和水之间的相互作用中而产生的。我要告诉你的是一种蔬菜食谱。只要你能保证在盘子里堆满蔬菜、水果和谷物，然后就可能长命百岁。**” \n“真的有可能吗？” \n“生活在喜马拉雅山顶的大部分智者都已经有一百多岁了，而且看不出有任何衰老的迹象。就在上个星期，我在报纸上读到了一篇报道，大体说一群人生活在中国东海冲绳群岛中一个小岛上。研究者之所以关注这个小岛是因为被一个事实给震惊了：这个岛上聚居着世上最大的百岁老人群落。” \n“这些研究者发现了什么长寿诀窍没有？” \n“**结果是，素食是他们长寿的主要秘诀。**” \n“但是这种食谱健康吗？你知道素食可不一定能够提供足够的气力。请注意，我可还是个忙忙碌碌的律师，朱利安。我总不至于为了长寿而饿昏在庭审现场吧。” \n“不必担心，**这是一个充分自然的、人性化设计的食谱。它会让你有生气，有活力，而且极其健康。智者已经依靠这个食谱生活了数千年。他们称之为‘悦性食物’，也可以叫作‘纯净饮食’。**既然你最关心力量，那我想提醒你注意，地球上最强有力的动物，从大猩猩到大象，它们都是不折不扣的素食主义者。然而你知道吗？一头大猩猩的力量可比一个男人大30倍。” \n“真的不可思议啊。谢谢你告诉我这则趣闻。” \n“看，智者并不是走极端的人。**相反我们现代人却是常常执迷不悟。智者所有的智慧都建立在一条古老的法则上，那就是‘生活适度，做事中庸。’因此，如果你喜欢吃肉，当然还可以继续吃，智者也不会阻拦你。只是你要明白一点，你是在吞下已经死去了的东西。如果可以，尽量少吃红肉，因为红肉很难消化。你的消化系统在整个身体里面是消耗能量最多的部分，非常有价值的精力就这样被肉类食品毫无必要地消耗掉了。你有没有这样的体验，当你中午吃了一份牛排大餐之后，你很快会觉得自己的嘴巴里充满了不洁的味道，不断地打饱嗝儿。接下来，你就会觉得昏昏欲睡，整个人好像梦游一样？**” \n“确实如此。”我承认。每次午饭前我会因为饥饿而头昏脑胀，而饱餐一顿后我又会因为吃得太饱而昏昏沉沉。就这样，每天上午的十一点到下午两点都是我工作效率最低的时候。 \n朱利安同情地看了看我，我想他一定联想到我在午饭后睡眼蒙眬的丑态。他接着说：“**难道你没有发现我目前的变化吗？建议你给自己的能量标准做个对比，在吃完一份牛排和一盘色拉之后，你的感觉一样吗？如果你不希望一下子就变成一个地地道道的素食主义者，那么至少要在每顿饭里加一道色拉，用水果代替甜点。即便这一点微小的改变也会为你的生活质量带来巨大的改变。**\n### 扩展知识法\n第四招被称作‘扩展知识法’。**它是一个**关于终身学习，为了给自己和周围的人造福的理念。**” \n“听起来好像那句老话‘知识就是力量’，是不是？” \n“它的内涵更加丰富，约翰。知识不仅仅是潜在的力量。因为力量是显而易见的，而你必须进入实践的层面。大部分人在特定的情况下，或者在生活遇到困难时，都明白应该怎么去做。问题在于他们不是天天都这样，没有在使用知识和实现梦想方面持续地加以努力。扩展知识法的宗旨就是成为生活虔诚的学生。而更为主要的是，它要求你把教室里学到的知识顺利地应用到现实生活中去。\n\n\n“瑜伽师拉曼和其他智者是怎样应用这个方法的？” \n“在日常使用中，他们有很多辅助的方法可以和‘扩展知识法’配套使用。最重要的一个技巧也是最简单的。今天你就可以开始试一试。” \n“不会花很多时间吧？” \n朱利安颔首微笑。“我和你分享的这些策略、方法和小技巧都会使你变得比以前更加能干，更加高效。不要捡了芝麻，丢了西瓜。想一想那些说自己太忙，顾不得在电脑上备份文件的人吧。一旦他们的机器出了意外，几个月以来的重要工作都将毁于一旦，他们就会捶胸顿足，遗憾自己为什么没有每天花一点点时间去保存文件。你明白我的意思了吗？” \n“就是说**要先弄明白生命中的主次关系，不要本末倒置？**” \n“**完全正确。努力使你的生活挣脱时间表的束缚。把精神集中到你的良知和内心告诉你要去做的事情上。当你开始探知自我，并且开始把自己的时间花在提高心智、身体和个性的品质上，你很快就会感到自己的体内仿佛存在着一个领航员似的，他会随时告诉你哪些事情值得去做，而且会带来最丰厚、最有价值的回报。你将不再会为钟表上的时间感到焦虑，而是开始尽情享受生命内在的律动。**” \n“啊，我明白了。那么接下来你要教给我的**那个简单的辅助办法是什么？**” \n“**定期读书。每天读书30分钟会给你带来意想不到的结果。但是我必须提醒你，不要碰到什么就读什么。你一定要仔细拣选才行，因为它们将要进入你丰饶的心智花园。它一定得是非常有营养的物质，否则将会适得其反。它们要帮助你改善自我，而且还要提升你的生命品质。**” \n\n“那些智者平常喜欢读什么书呢？” \n“**他们在醒来以后，就会花很多时间去阅读古人留下来的教诲。他们对这些哲学著作如饥似渴。迄今我还记得那些非常俊美的人们坐在小竹椅上阅读外形奇怪、装帧精美的书，脸上和唇边都洋溢着淡淡的微笑。正是在那里我真正意识到了书本的力量，知道了‘书本是智慧最好的朋友’这个道理。” **\n“那么我应该开始阅读我能够找到的所有好书吗？” \n“可以说是，但又不是。\n”他这样模棱两可地回答我。“我从来都会支持你尽己所能地去读书。但是要记住，有些书只需要浅尝辄止，有些书却需要细细咀嚼，有一些需要辨证学习，而另一些则值得完全吸收。这让我想起另外一个问题。” \n“你是不是饿了？冰箱里还有些酸奶。” \n“不是，约翰，”朱利安笑了，“我只不过想要告诉你，**一定要善于从伟大的书籍中获得最为精华的部分。你必须要好好地研究它，而不仅仅限于阅读。深入全面地研究它，就像你研读你的重要委托人给你的案子那样。切实地考虑它，和它相互切磋，成为伙伴。智者在广泛的阅读中，会把很多书读上10到15遍。在他们眼中，伟大的书籍就像是神赐的圣书。**” \n“哎哟！读书真的这么重要啊？” \n“**每天坚持读书30分钟，会给你的生活带来可喜的变化。因为你很快就会发现，有那么广博的知识宝库供你选择使用。你会变得谈吐不凡，思维敏捷，文思泉涌。你曾经遇到的每一个问题的答案都会历历在册，信手拈来。如果你想要成为一名更为出色的律师、父亲或者恋人，都会有相应的书籍知识帮你快速达到目的，避免走弯路。你在人生中犯下的所有错误都已经被前人们尝试过，因此你也将会很快找到改正的方案。你是不是真的以为你所面对的挑战都是独一无二的？**” \n“老实说，我从来没有这样想过，朱利安。但是我理解你所说的，而且我知道你是对的。” \n“**任何一个人遇到过的任何问题，在他的生命之前都已经被前人遭遇过了，而且不止一次，”朱利安断言道，“更重要的是，答案和解决办法都已经在书页上记下来了，就看你会不会发现它。养成正确阅读的习惯，学习前辈的珍贵经验，他们成功的策略会帮助你从容面对生命中遭遇的种种挑战。你会为发生在人生中的点滴进步而感到惊奇的。**” \n“什么样的书才是‘正确的好书’？”我追问着，很快就体会到朱利安的意见确实很不错。 \n“这个要留给你自己来判断，我的朋友。就我个人而言，自打我从东方回来以后，就把一天中最好的时光花在了阅读上。当然，每个人兴趣不同，我最感兴趣的是那些我所钦佩的男男女女的人物传记和大量的智慧之作。” \n“你能不能为我这个还算得上勤奋工作的人列出一些有用的推荐篇目呢？”我一边说，一边难为情地笑了一下。 \n“没问题。**比如你可以从伟大的本杰明・富兰克林的传记中获益颇多。我觉得你还可以从圣雄甘地的传记中发现很多成长的动力，那本书的名字叫作《甘地自传》。我还建议你读读赫尔曼・黑塞[7] 写的《悉达多》，还有马可・奥勒留[8] 写的实践性很强的书，以及塞涅卡[9] 的一些著作。你甚至还可以读一读拿破仑・希尔的《思考致富》。上个星期我认真地读了这本书，觉得真是回味深远。**” \n\n\n\n书只是帮助你发现早已存在于自身之内的东西。这是一种唤醒，一种提示。这就是启蒙，如一束光照亮你的人生。我在经过了那么多的旅行和探险之后，最终发现我其实是走完了一个循环，回到了我还是孩子时的出发点。但是现在，我非常了解自己，知道我是谁，我也知道自己最终会成为怎样的人。**” \n “所以说‘知识扩展法’就是大量读书，探索外界的丰富知识？” \n “你只说对了一部分。因为在眼下一天只读30分钟书，你的理解也仅此而已。随着你对书籍的爱好与日俱增，其他意想不到的东西自然也会到来。”朱利安的话里暗含着玄机。\n\n### 个人反思法\n它的名字是‘个人反思法’。那些智者都坚信内在沉思的力量。通过一定时间的沉思来了解自我，就可能步入生命的另一个维度，这也许是你从来都不知道自己还具有的更高维度。\n\n其实说到根本上，个人反思不过是一种思考的习惯。\n\n对，是富兰克林。每天晚上在完成了一天的高效率工作之后，他一回到家里就会躲在一个安静的角落里，反思这一天的行为处世。他会反思他的全部行为，看其中哪些属于积极而富有建设性的，哪些属于消极而需要及时修正的。当他清楚地知道白天里犯下了什么错误时，他就会迅速采取措施进行改进，沿着自我控制的道路前进。等到以后再遇到类似的情况，他就会心知肚明，游刃有余。智者也是这样做的。每天晚上，他们都会躲进小棚屋里的清净角落，那里铺满了芳香的玫瑰花瓣，他们坐下来陷入深深的沉思。瑜伽师拉曼还会把他的一天经历写在日记里。\n\n“他写下来的都是些什么事？”我好奇地问。 \n “**首先他会列出当天所有做过的事情，从早晨的身体锻炼，到他和其他智者之间的交流，再到他到森林里去找木柴和新鲜食物的经历。很有趣的是，他还会写下来在这一天里曾经在头脑中出现过的各种念头。**” \n “这样做岂不是难了点儿？我根本记不起来5分钟以前自己曾经想过什么，更不要说12个小时以前的想法了。” \n “如果你每天都坚持做同样的练习就不会觉得难了。任何一个人都可以获得在我身上发生的改变，任何人。真正的问题是，有太多的人都饱受令人讨厌的疾病的折磨，这种疾病叫‘借口’。” \n “我想我可能也染上了这种疾病。”我完全明白我聪明的朋友在说什么。 \n “别再找借口了，只管去做就好了！”朱利安提高声音说道，他的语调中充满了坚定的力量。 \n “做什么？” \n “**花时间去认真思考，并在生活中养成定期进行自我反省的良好习惯。有时候瑜伽师拉曼会将笔记纸的一页从中对折一下，把当天所有做过的事情、想到过的念头都写在一栏里，然后在另外一栏里作出相应的评价。当他面对书面记录下的行为和想法时，他会扪心自问，它们在本质上究竟是不是积极的。如果是积极的，他就决定继续为此付出宝贵的精力，因为从长远来看，它们会给他带来巨大的收益。**” \n\n我认为现在你已经发现了‘个人反思法’的神奇力量。通过审视自己做过的事情，仔细反省自己是如何度过一天的。你要注意归纳自己在一天内一共出现了几种想法，这样一来你就给自己提供一个进步的标准。要在明天实现进步的唯一途径就是知道今天做了哪些错事，并且知道如何来加以改进。\n\n只有人类才会走出自我的阴影，并且能够分析他所做的事情中哪些是正确的，哪些是错误的。一条狗做不到这一点，一只鸟也不会这么做，就连聪明的猴子也不可能。但是你可以。这就是‘自我反思法’的根本宗旨，在每天的生活和整个人生当中，辨明什么是正确的，什么是错误的，然后尽快着手完善自己。\n\n\n### 早早醒来法\n“**我在遥远的喜马拉雅山上得到的最有用的一个建议就是，和太阳一起起床，然后成功地开始新的一天。我们大部分人的睡眠时间都比实际的需求要多得多。其实普通人睡六个小时就可以起床了——这已经足够他保持健康和思维的机敏了。睡眠无非一种习惯，像其他习惯一样，你可以训练自己达到你所希望的成果。试一试，能不能在这一个环节中睡得少一些。**” \n “可是，如果我起床太早了的话，我真的会感到精疲力竭。”我说。 \n “在刚开始的几天里，你可能会感到疲倦。我也曾有同感。你甚至有可能在练习早些起床的第一个星期里一直有这样的疲劳感。不过，请把这看成是为了得到长期的巨大收益而付出的短暂的、少量的痛苦。在你确立一个新习惯的时候当然会多多少少感到有些不舒服。这就像你穿上了一双新鞋子——刚开始穿上的时候觉得有点疼，很快就很惬意了。正像我此前告诉你的那样，痛苦往往是个人成长的前奏。别害怕起早。相反，接受它。” \n “好吧，我喜欢这个训练自己早点起床的观念。可是先得让我问问你，**‘早’起意味着几点钟起？**” \n “又是一个好问题。这跟时间没有关系。就像我到现在为止和你分享的各种方法一样，都是要你按照认为正确的标准去做。记住瑜伽师拉曼的警告：“凡事不可过分，处处都要适度。’” \n “日出时起床，这听起来已经很过分啦。” \n “实际上并不过分。几乎没有什么比一天当中新射出的第一缕阳光更加光辉灿烂的了。智者坚信，阳光是来自上苍的礼物。尽管他们都很小心，不过多地暴露在阳光下，但是他们会定期做日光浴，还经常在阳光明媚的清晨顽皮地舞蹈。我完全相信这是他们保持长寿的另一个秘诀。” \n “你也做日光浴吗？”我问。 \n “当然做。阳光使我恢复活力。当我感到劳累时，阳光会让我高兴起来。在东方古老的文化里，太阳被认为与灵魂相连。人们崇拜太阳，因为太阳让庄稼和他们的精神一起丰收。阳光可以释放你的生命力，恢复情感和身体上的活力。它是一位令人心情愉快的医生，不过前提是你适当地接触它。唉，我又跑题了。我们讨论的是早点起床，每天坚持。” \n “哈哈。我怎么才能把这个习惯纳入日常的生活？” \n “**这里有两个简便易行的小诀窍。首先，千万别忘了，重要的是睡眠的质量而非睡眠的数量。在不受干扰的情况下沉沉地睡上六个小时要比时常被打断的十个小时睡眠好得多。睡眠的目的在于让你的身体得到休息，这个自然的生理过程可以修复、重建你的身体，减少日常消耗带来的压力和挣扎，使你的身体恢复自然的状态。很多智者的习惯都基于这一原则。举个例子来看，瑜伽师拉曼在晚上八点以后就再也不吃东西了。他说消化活动及其附带的生理活动会降低他的睡眠质量。智者还有另一个习惯，睡觉之前他们会在轻柔的竖琴乐声中冥想。**” \n “这种行为的原因是什么？” \n “让我来问问你，约翰。每天晚上睡觉之前你会做些什么？” \n “我和詹妮一起看新闻节目，我知道这和大部分人做的事情一样。” “我就知道。”朱利安回答，眼睛中有奇异的闪光。 \n “我不明白。在睡觉以前看上一点新闻有什么错的？” \n “**你睡觉之前的10分钟，还有醒来之前的10分钟，都会在你的潜意识里留下长久的影响。在这两个时间段，你应该只向你的头脑输入最愉悦、最安静的想法。**” \n “瞧你说的，人的头脑听起来就跟电脑似的。” \n “**这么来看待头脑也不失为一种好办法——你输入的东西就是将要产出的东西。更加重要的事实是，程序员只有你一个人。通过决定让哪些念头进入头脑，你也就可以明确地知道哪些念头将会产生出来。所以在你去睡觉之前，不要看什么新闻，不要和任何人争吵，也不要在脑海中回顾一天的所作所为。放松，如果你喜欢的话，慢慢地喝一杯花茶，听一点轻柔的古典音乐，做好准备，让自己渐渐滑入甜美的熟睡中。**” \n “有道理。睡得越好，睡得越少。” \n “确实如此。**一定要记住古老的21天法则：如果你连续21天做一件事情，它就会确定成为你的习惯。所以，在你因为感到不舒服而放弃早起的行为前，你要坚持三个星期。**到了那时，早起就成为了你生活的一部分。在很短的时期内，你就能够轻轻松松地在早晨五点半，甚至是五点钟起床，准备好领略新一天到来时的壮丽场景了。”\n  “好吧，那么如果说，我现在每天都是五点半起床的话，我又该做些什么呢？” \n  “**从你问的问题就可以看出你确实是在思考，我的朋友。对此我很欣赏。起床之后，你可以做很多事情。要在头脑里面时刻记住的基本原则是，好好开始新的一天是非常重要的。就像我曾建议过的，在你醒来以后的十分钟内，最先进入到脑海里的念头和最先着手的行为，往往会在接下来的一天中产生非常明显的效果。**” \n  “此话当真？” \n  “当然。**去想那些积极的念头；对你所拥有的一切做感恩祈祷；感谢你要感谢的人；倾听一些伟大的音乐；看太阳升起。兴之所至的时候，你还可以去自然环境中散步。实际上，智者还常常让自己开怀大笑，不管是不是有高兴事，这不过是为了让快乐在清晨便开始流动。**” \n  “朱利安，我尽力使自己的头脑能够接受你的讲解——而且我想你也会承认，作为一个初学者我做得已经很不错了。可是，就算是对一群生活在喜马拉雅山高峰上的高僧来说，那样的事情听起来也真的太奇怪了。” \n  “其实不足为奇。你猜一猜，一般来说，一个四岁的孩子一天要大笑几次？” \n  “谁知道呢！” \n  “我知道，一共三百次。嗨，你不要做出这么惊讶的表情。现在再猜猜看，在我们的社会中一个成年人在一天之内会大笑几次？” \n  “五十次？”我猜测着。 \n  “勉勉强强十五次，”朱利安回答道，微笑中充满胜利感。“你明白我的意思了吧？**大笑是灵魂的良药。如果你能对着镜子开怀大笑几分钟，即使你并不喜欢这样做，你也会忍不住感到很奇妙。威廉・詹姆斯说过：‘我们不是因为快乐才笑，而是因为笑才感到快乐。’所以，让你的一天从快乐开始。大笑，玩耍，为你拥有的一切感恩。由此，每一天都会变得极其有意义。**” \n  “那么你是如何积极地开始自己的一天呢？” \n  “说实话，我已经养成了一套非常系统的晨练方式，包括所有的内容，从练习‘玫瑰之心’到喝几杯鲜榨水果汁。但是有一个方法我特别要和你一起分享。” \n  “听起来很重要嘛。” \n  “是很重要。**你在刚醒来以后，就到你那个‘个人避难所’去，静下心来，集中精神，然后问自己这个问题：“如果今天就是生命里的最后一天，我将做些什么？’答案就在于准确理解这个问题的含义。在头脑里列出来所有你想做的事情，你想打电话的人们，以及你想享受的时刻。想象你自己正在兴致高昂地完成这些事情。想象自己对待家庭、朋友和完全陌生的人的样子。如果今天就是你活在这个星球上的最后一日，想象自己该怎样度过这珍贵的一天。正如我早先告诉你的，当你在度过每一天时都像对待生命的最后一天那样，你的生活将会焕发出奇异的色彩。** \n### 音乐法\n智者很热爱他们的音乐。音乐就像太阳一样给予他们同样的精神鼓舞。音乐让他们开怀大笑，让他们闻之起舞，应和歌唱。它对你也会起到同样的作用。千万别忘了音乐的力量。每天在音乐上花一点时间，哪怕只是在你驱车上班的路上听几首轻音乐也好。当你觉得消沉或者疲倦，演奏一会儿音乐吧。这是我所知道的最有效的动力之一。\n### 口语练习法\n**第八招的名字叫‘口语练习法’。智者有成套的‘真言’供他们在早、中、晚念诵。他们对我说这个练习非常有效果，可以帮助他们保持专注，变得更强壮和幸福。 **” \n  “‘真言’是什么？”我问。 \n  “**真言就是一连串能够产生积极影响的话语。在梵语里面，‘man’的意思是心智，‘tra’的意思是解脱束缚。因此真言‘mantra’这个词语指的就是对心智有计划的解放。而且请你相信我，约翰，真言是达到这一目的的非常有效的方法。**” \n  “那么你在日常生活中也练习说真言吗？” \n  “我当然也是这样。无论我走到什么地方，它们都是我最忠实的同伴。不管我是坐在长途巴士上，在走去图书馆的路上，还是穿过一个公园观察着周遭的世界，我总是通过诵读真言来肯定我生命中所有美好的东西。” \n  “所以真言是口头的？” \n  \n  “**也不一定非要说出来。写出来的形式也一样很有效。但是我发现，大声背诵真言会对我的精神起到奇妙的效果。当我觉得需要动力支持时，就会重复说‘我有创造力，有自制力，有精力’这句真言二百到三百次。如果要保持高度的自信，我就会重复说，‘我很强壮，很能干，很镇静。’我甚至还使用这些真言来保持我的青春和活力。**”朱利安坦言道。 \n  “一句真言又怎么能够让你保持年轻呢？” \n  “**语言会长久地作用于心智。这是一种古老的心理暗示法，并且屡试不爽。无论是写下来还是说出来，它们都会产生强有力的影响。你对别人说什么很重要，但更重要的是你对自己说什么。**” \n  “自言自语吗？” \n  “对呀，**你每天怎样想的，你就是什么样的。你每天对自己说什么，就会变成什么样子。如果你说你又衰老、又劳累，这句话就会在你的外在世界中显形。如果你说自己很虚弱，缺乏热情，这也会成为你现实中的特点。但是，假如你说你很健康，很活跃，充满活力，那么你的生活将得到改变。想想那些身患绝症却依然乐观向上的人们吧，他们就是通过有效的心理暗示为自己争得了珍贵的生命时光。**” \n  朱利安略微休息了一下，然后接着说：“**你看，你对自己说出的话语影响到你的自我形象的想象，而你的自我想象又将决定你会采取什么样的行动。举个例子说，如果你想象的自我形象是一个没有信心去做任何有价值的事情的人，你所能采取的就不过是与这个特点相似的行动。如果你想象自己是一个充满活力，无所畏惧的人，同样，你所有的行为都会和这一品质相适应。在某种程度上，你的自我形象想象就是对于自我的长久预言。**” \n  “怎么会是这样呢？” \n  “**如果你相信自己做不到什么事情，比如说，无法找到一个完美的伴侣或者无法过上没有压力的生活，你的信念就会影响你的自我想象。反过来，你的自我想象也会阻止你采取行动去找到一个完美的伴侣或是为自己创造出一种平静的生活。事实上，它会妨碍你在这个方向上作出的任何努力。**” \n  “为什么会这样呢？” \n  “**很简单。你的自我想象其实是某种心理控制。它绝不会允许你在与它不相一致的方式上行事。但是好在你可以改变自我想象，就像你改变人生中其他的方面一样。真言就是完成这一目标的有效方式。**” \n  “而且啊，当我改变内在世界的时候，也就改变了外在世界。”我发自内心地说。 \n\n### 个性调试法\n**活力人生的第九招。这个方法是‘个性调试法’。它是我们刚才讨论的自我想象概念的分支。简而言之，这个方法是要求你每天循序渐进地塑造自己的性格。这一过程将影响到你对自我的看法和所采取的行动。你所进行的行为会集中起来，渐渐形成你自己的固定习惯，而你的习惯将会决定你的命运。瑜伽师拉曼对此说得很明了：‘你种下一粒思想，就收获一个行动；种下一个行动，就收获一种习惯；种下一种习惯，就收获一种性格；种下一种性格，就收获了整个命运。**’” \n  “我应该做些什么事情来塑造自己的性格呢？” \n  “你可以做任何可以培养美德的事情。在你问我何谓‘美德’之前，先让我澄清一下这个概念。**喜马拉雅山的智者相信，有德行的人生才是意义丰富的人生。所以他们用一系列的古老原则来支配自己的行动。**” \n  “但是我记得你曾经说过，**他们是用自己的目标来支配人生？**” \n  “是的，基本上差不多，但是他们的生活愿望在某种意义上还与这些原则相协调，那是他们的祖先在几千年前就已经深深植入他们心灵的。” \n  “那些原则是什么，朱利安？”我问。 \n  “**简单地说就是：勤劳、慈爱、谦逊、耐心、诚实和勇敢。如果你的行动和这些原则完全相符，你就会感到内在深深的和谐与安宁。依照这种原则来生活无疑会将引领你走上精神世界的成功。这是因为你所做的事情都是正确的。你将按照和自然法则以及宇宙法则相一致的方式来行事。你开始吸收另一个维度上的精力，或者称之为更高的力量。这同时也意味着你的生活将从庸常进入超凡境界，开始体味人生存在的神圣感。这也是毕生启蒙的第一步。**” \n  “你有过这样的经验吗？”我问。 \n  “有过，而且我相信你也会有的。做正确的事情。依照和你的真实性格相匹配的方式来行动。正直地行事。接受内心的指引。如此一来，其他的事情也会自然而然地好起来。约翰，你永远都不会孤独。”朱利安回答。 \n  “你这话是什么意思？” \n  “也许我下一次再解释给你听吧，眼下我们不能总是跑题。**你得记住，必须每天做一些小事来培养自己的品格。正如爱默生说的那样：‘品格高于才智。一个伟大的灵魂不仅善于思考，更善于生活。’如果你按照我刚才提到的那些方法来做事，你就会塑造出高尚的品格。如果你不这样做，真正的幸福就会弃你远去。**”\n  \n###   化简法\n这个方法要求你过一种简单的生活。就像瑜伽师拉曼所说的，‘一个人千万不要生活在肤浅事物中。集中精力于那些最重要的、有意义的事情。这样，你的生活将会清晰有条理，有价值而且格外安宁。这一点我可以向你保证。\n\n怎样养成化简的习惯？\n要学会做减法，我们的生活本来已经够复杂的了，不要总是给自己找不痛快。就像我吧，我不再穿昂贵的衣服，我戒掉了一天看六份报纸的瘾，我不再需要让自己随叫随到，我变成了一个素食主义者而且吃得比以前少。从根本上说，我削减了自己的需要。东方的智者曾经有过精辟的总结：‘有容乃大，无欲则刚’。这话多有用啊。你看，约翰，除非你削减自己的需要，否则你永远不会得到满足。你会一直像拉斯维加斯赌场中急红了眼的赌徒，守在轮盘赌转盘前面期待着‘再转一次’，不停地祷告，盼着你的幸运号码马上到来。你会一直想要得到比现在拥有的更多的东西。可事实怎么样，相信不用我再赘言了。\n\n如果我想把‘化简法’纳入自己的生活，我应该做哪些事情？\n\n “你能做的事情太多了。即使是小事情也能带来改变。” \n  “比如说？” \n  “**电话响起的时候不要每次都慌慌张张地去接听，或许是人家打错了电话；不要在阅读垃圾信件上浪费时间，因为你看后即忘；不再每星期在外面吃三次饭，那样你会变得大腹便便；放弃你的高尔夫会员资格，花更多的时间和孩子们待在一起；一周之内有一天不看手表，你要学会告诉自己：“少了我，地球照样转动’；每过几天就去看一次日出，感受大自然的神奇；把你的手机卖掉，不要成为别人随叫随到的奴役……还要我继续说下去吗？**”朱利安反问道。 \n\n\n我向你担保，通过练习这些策略和方法，你会从那一刻起，在一个月之内看到显著的提高。你在生活中的各个方面都将会有更多精力，更少烦恼，更多创造力，更小压力。我前面也已经说过了，智者的方法不是速成型的，肯定没有驱虫药的功效那么神奇。它们都是古老的修行传统，为了你今后生活的宁静，你需要天天练习。如果你停下来一段时间，就会发现自己又逐渐回到旧日的道路上去了。\n \n## 精神\n我向你解释的那些秘诀会让你在生活中创造出所希望的一切。但是那些智者的哲学视野要远远高于我们所能看到的地方。到目前为止我教给你的都是非常实用的知识。但是你一定要明白，在我列出的种种原则之下，其实还涌动着许多潜在的精神力量。也就是东方哲人所说的那句‘言有尽而意无穷’。如果你不理解我所说的这些话，不要太担心了。只要你肯听进去，再好好地想上一会儿，之后就会慢慢地理解和接受了。**” \n  “学生做好准备的时候，老师就会出现，是吗？” \n  “正是这样，”朱利安说，露出笑容，“你一直学得很快。” \n  “好吧，**让我们来听听精神的部分**，”我充满活力地说，根本没有注意现在已经快早上五点半了。 \n  “**想象一下，你现在正栖息于日月天空之下，生活在宇宙的所有奇妙之间。创造这些奇迹的智慧就与把你创造出来的那种力量完全相同。你身边的任何东西都是来自同一个地方，我们本是一体，万物皆为一体。” \n  “我不确定自己是否明白你的意思。” \n  “地球上每一种活着的生物，地球上每一件看似静止的事物其实都有自己的灵魂。所有的灵魂都汇成一个，那就是宇宙的灵魂。就像是一滴水融入大海，汇成海洋的波浪彭湃。同样，我们也能够从大海中感受到那一滴水的生命律动。你看，约翰，当你养护自己的心智和精神时，你的确也是在滋养宇宙的灵魂。而当你提高了自我，也就是在提高所有存在于你四周的生命。当你有勇气不断接近梦想的方向，你也就开始利用宇宙的力量。正如我此前已经告诉你的，生命回报给你所要求得到的任何东西。它一直在侧耳谛听。**” \n  “所以说自我控制和‘禅悟’都将通过帮助自己而对别人有所帮助？” \n  “可以这样说。当你丰富自己的心智头脑，养护自己的身体以及滋养自己的精神时，你都会逐渐确切地理解我所说的这些。” \n  “朱利安。我知道你讲得很好。但是自我控制对于一个体重97公斤重，在发展客户上花费的时间远远多于自我发展的时间的男人来说，无论如何都是过高的奢望啊。如果我失败了，会发生什么事？” \n  “**失败是不必费心去尝试的，没有什么大不了。横亘在人们和梦想之间的唯一事物就是对失败的恐惧，然而恐惧又是任何成功都不可缺少的。失败可以检验我们的毅力，让我们得到不断的成长。它给我们教训，并且引导我们走向启蒙的道路。东方的先哲曾经说过，每一支射中公牛眼睛的利箭，都是一百次失误的结果。这就是要求我们明白一个道理：从失去的机会中不断获益，不要害怕失败。失败是你的朋友。**”\n\n\n“让我拥抱失败吗？”我半信半疑地问。 \n  “**宇宙青睐勇敢者。一旦当你下定决心要把自己的人生提高到最高的层次上，你灵魂的力量就会指引你方向。瑜伽师拉曼相信，每一个人的命运在他出生的那一刻就已经铺展开了。这条道路将一直通向一个盛满瑰丽宝藏的奇妙所在。每个人都能够培养起走上这条道路的勇气，这是人的天赋。他给我讲过一个故事，在此我想转述给你听。**” \n  **以前，在古老的印度，有一个邪恶的巨人拥有一座可以远眺大海的辉煌城堡。在巨人去打仗的很多年里，附近村子里的孩子们常常跑到巨人美丽的花园里，非常快乐地玩耍。有一天，巨人回来了，把所有的小孩子都赶出了他的花园。“谁也不许再来！”他一边高喊，一边怒气冲冲地把橡木大门“砰”的一声关上。后来他围着花园建起了一道高大的大理石墙，把孩子们都挡在花园外面。 \n  寒冷的冬天到来了，这在印度是再自然不过的，而那个巨人盼望着温暖早早回来。不久，春天造访了巨人城堡下方的村子，但是冬天的寒冷魔爪依旧拒绝离开他的花园。有一天，巨人闻到了春天的芬芳，感到了太阳穿过窗子照耀进来的温暖。“春天终于回来了！”他大声喊着，跑到他的花园里去了。可是巨人没有想到映入眼帘的是那样一幅场景。村里的孩子们不知用了什么方法终于翻进了城堡，正在花园里高兴地玩儿。正是由于他们的到来，花园从冰封的冻土变成了富饶的土地，盛开着玫瑰、水仙和紫兰花。 \n  所有的孩子都开心地哈哈大笑，除了一个孩子以外。在眼角的余光里，巨人瞥见一个很小的小孩，他比其他孩子个子小得多。他因为没有力气翻过墙头进花园去玩，眼泪从脸上流下来。巨人为那个孩子感到难过，而且在他的一生中，他第一次为自己的恶行感到悔恨。“我要帮助这个孩子。”他说，向他跑过去。当其他的孩子看见巨人出来时，他们都感到害怕得要命，跑出了花园。但是那个个头很小的孩子还站在那儿。“我要杀死巨人，”他结结巴巴地说，“我要保卫我们的游乐场。” \n  巨人走近小孩子，他张开双臂。“我是你的朋友，”他说，“我来帮助你翻过墙头到花园里去。现在它是你的花园了。”这个小孩子，现在成了孩子群中的英雄。他感到很高兴，把自己一直戴在脖子上的金项链送给了巨人。“这是我的幸运护身符，”他说，“我希望你来拥有它。” \n  从那一天起，孩子们一直在巨人美丽的花园里玩耍。但是那个最受巨人宠爱的勇敢小孩子却再也没有回来过。时间一天天过去，巨人生病了，越来越虚弱。孩子们还继续在花园里面玩儿，可是巨人再也没有力气和他们作伴了。在那些安静的日子里，巨人最想念的就是那个小孩子。 \n  一天，在特别寒冷的冬季里，巨人从他的窗子里向外看了一眼，看到一个堪称奇迹的景象：尽管大部分花园都被白雪覆盖，在花园的正中却站立着一株漂亮的玫瑰花树，上面开满颜色各异的鲜花。就在玫瑰花树的旁边，站着巨人最喜爱的那个小孩子。小孩子笑得非常甜美。巨人快乐得手舞足蹈，冲出去拥抱了孩子。“这么多年你去哪儿了，我的小伙伴？我一直都在想念你。” \n  孩子的回答却意味深长：“很多年以前你把我托过了墙头，让我进入你漂亮的花园。现在，我来带你去我的花园。”那天晚些时候，当孩子们再来看望巨人时，他们发现他已经躺在地上去世了，而他的身上从头到脚覆盖着上千朵美丽的玫瑰花。 \n  “只管让自己勇敢起来，约翰，就像那个小小的孩子。站稳你的脚跟，追随自己的梦想，它们会引领你找到自己的命运。跟随你的命运，它将带你领略宇宙的奇妙，带你进入一个满是玫瑰的神秘花园。” \n  当我抬头看向朱利安，打算告诉他这个故事对我的触动有多么深时，我看到了极其震惊的场面：这个曾经把一生中最好的时光都花在追名逐利上的坚如磐石的律师，在这一刻竟然泪流满面**。 \n \n# 粉色带子，代表意志力\n那条粉色的带子用来提醒你记起，在建构起一个更加丰富、幸福和开明的人生中自我控制和纪律所具有的作用。在我遇到的所有人当中，我的那些智者导师无疑是最健康、最安详、最有满足感的一群人。同时他们还是最有纪律性的人。智者教育我说，自律的美德就像那条遮在关键部位上的粉色带子。你有没有花时间研究过一条多股编织的粉色带子，约翰？**” \n“这个我似乎不太感兴趣。”我咧嘴一笑。 \n“好吧，**有机会好好看上一看。你会发现上面连着很多细小的钢丝，彼此首尾相连。如果单独来看，每一根都很脆弱，不结实。但是一旦把它们合在一起，就要比单根线要结实得多，最后这股带子变得比钢绳铁索还坚韧。自我控制和意志力就与这个道理相类似。为了建起钢铁般的意志，最不可缺少的一个环节，就是坚持做微不足道的小事情，以此来培养自我约束的优良品质。持之以恒，一个小作为累积在另一些更小的作为之上，最终就能像核聚变一样，产生出充沛的内驱力。” \n朱利安意味深长地看了看我，接着说：“也许有一句古老的非洲谚语最能说明这个道理：‘把蜘蛛网一股一股地连起来，就能捆住一头凶猛的狮子。’当你将自己的意志力释放出来，你就变成了自我世界的主人。当你不断练习古老的自我支配的技巧，就不再会有高得让你跨不过去的障碍，也不再会有难得让你无法克服的挑战，更不再会有紧张得让你无法平息的危机。自我约束会在人生最磕磕绊绊的时候向你提供心智中储备的无穷能力，保证你可以继续坚持下去，直到胜利。**” \n“**我还必须告诉你一个事实，缺乏意志力将会导致各种不同的心理疾病。这是已经为医学界所证明了的。”朱利安突然又补充说。“如果你饱受意志力缺乏之苦，就要首先尽快改变这一现状。充沛的意志力和纪律性是坚强的性格和多彩人生的主要缔造者。在强大的意志力的支持下，你能够兑现你的诺言。你可以每天坚持在早晨五点钟起床，通过冥想来培养自己的心智。或是在寒冷冬季里的一天，尽管你很留恋被窝的温暖，但强大的意志力还是让你起床到树林中散步，借此滋养自己的精神。在受到别人无礼的指责时，强大的意志力让你保持冷静和沉默。面对突发事件，强大的意志力促使你能够连续克服难关，不断实现自己的梦想。简而言之，正是意志力源源不断地提供内在的激情与力量，让你信守对他人的承诺，而且更重要的是，信守对自己的承诺。\n\n意志力是一种优秀的品质，人生将因此而变得热情似火，变得宁静而致远。\n\n\n\n艰难时日里就是这段话帮助了我。我希望在你遇到苦难的时候，它也能让你的心灵得到慰藉。这段话说的是： \n通过铁一般的纪律，你会铸造出勇敢而平和的性格；通过意志与美德的培养，你一定会达到人生最高的理想境界，你会生活在美好、快乐和生机盎然的天堂世界。如果没有这些，你就会像遗失了指南针的水手一样彷徨失路，最终与船只一起沉没。\n\n\n\n你是说，只要进行了正确的训练和适当的准备，我就能达到像圣雄甘地那样高超的意志力水平？” \n“为什么非要像别人呢，约翰？**其实每个人都是不一样的。瑜伽师拉曼教给我最基本的原则是，真正开悟了的人们绝不以与别人相似为荣。他们更乐意成为新型自我的开创者。不要跟别人赛跑，你要和自己赛跑。”朱利安回答说**。 \n“**当你有了自我控制的能力时，你就会下决心去做你一直想做的事情。对你来说，可能是去参加马拉松长跑训练，掌握橡皮艇冲浪的技巧，甚至是放弃法律职业而成为一位艺术家。无论你的梦想是物质上的富足还是精神上的丰富，我都不会对你指手画脚。我只是想要告诉你，如果你能开启沉睡着的意志力，一切尽在你的掌握之中。” \n朱利安补充说：“在你的生活中，进行自我控制以及加强纪律性还会带给你巨大的自由感。单单这一点就足以引发巨大的变化。\n\n“你的意思是？” \n“**大部分人都是自由的。他们可以去想去的地方，做他们喜欢做的事情。但是有更多的人仍旧是冲动的奴隶。他们消极被动，习惯于见招拆招，却并不具有前瞻性。打个比喻，这些人就像被浪花冲上海岸的泡沫，任凭海潮把它们推向任何方向。当他们正和家人在一起时，如果有同事打电话说有急事，他们就会立刻赶过去，从不停下来想想，到底哪件事情对他们的人生目标来说更重要。所以就我的观察经验来说，无论是在西方还是东方，这种人都拥有自由的权利，却没有享受到真正的自由。在他们身上缺乏一种至关紧要的元素：从看似紧急的情况中选择正确的事情的自由。**” \n\n\n“培养意志力能够给我带来更多的自由吗？” \n**“自由好比一所齐整的房子，你一砖一瓦把它垒起来。你要放上去的第一块砖就是意志力。这个品质可以激励你在任何情况下去做正确的事情。它给你提供精力和勇气，让你过上所期望的生活，而不是成为生活的奴隶。**” \n朱利安还列出了培养意志力能带来的其他很多实际好处。 \n“信不信由你，**培养你的意志力量可以让你消除忧虑的习惯，让你保持健康，给你带来比以往多得多的精力。要知道，约翰，自我控制实际上就是心智控制。意志是心理力量的统帅。如果你掌握了心智，也就掌握了你的人生。对心智的控制源于你能够控制每一个出现在你头脑中的想法。如果你能够把所有软弱的念头都清理出去，仅仅注意那些积极美好的念头，那么积极美好的行为也将相继而来。这样你的人生中也会很快变得积极而美好**。\n\n“这儿有一个例子。假设说你的个人发展目标之一是每天早晨六点半起床，然后围着你家后面的公园跑步。让我们假定现在正处于严寒当中，你的闹钟铃声把你从恬静的沉睡中唤醒。你的第一反应就是按下闹铃的按钮，然后接着呼呼大睡，心想明天再去真正实行你的锻炼计划。这种状况拖了好久好久，直到你觉得自己太老了，健身计划对你已经太不现实了，于是就放弃了你的计划。” \n“你太了解我了。”我诚恳地说。 \n“现在让我们来考虑另一种情形。还是在严冬时节，早晨的时候突然铃声大作，你产生了继续待在床上的想法。为了不再成为习惯的奴隶，你开始用更加强大的意志力去战胜它们。你开始在头脑里想象，如果你的体形好到极致，那将是一种什么样子，会有什么感觉，会做什么事情。当你在办公室里信步走过的时候，你会听到同事们的大声恭维你匀称而良好的身材。你不断想象定期的锻炼计划能够让你达到的目标。你再也不会说出庭了一天之后就累得什么也不愿意做，最终只能在电视机前打发晚上的时间。你的生活中将充满了活力、热情和意义。”\n\n\n“但是假如我这样做了，还是想回去睡觉，不出去锻炼呢？” \n“最初的几天当然会有一点困难，你更容易回到旧习惯中去。但是瑜伽师拉曼特别坚信一条古老的法则：积极总是能战胜消极。所以，如果你能够继续向那些多年来渐渐蚕食掉你的软弱思想作斗争，最终这些思想会像自知不受欢迎的访客一样灰溜溜地不告而别。” \n“你是想要告诉我思想也是一种实际存在的东西？” \n“是的，而且它完全在你的控制之中。思考积极的想法和消极的念头一样容易，然而效果大相径庭。” \n“**那么为什么还有那么多人在忧虑，在关注我们这个世界上的负面信息？**” \n“**因为他们还没有学会自我控制的技巧，不会限制思考的方向。在我曾经交谈过的人群当中，有很多人都根本没有想过，自己竟然还有力量去掌控生活中每天、每分、每秒出现的每一个想法。他们相信思想不过是偶然发生的，却根本没有认识到，如果你不花时间去控制自己的想法，它们反过来就会控制你。这是一场控制与反控制的战争，可能很漫长，甚至会终其一生。如果你能够把注意力集中在美好的事物上，借助真正的意志力拒绝那些负面思想出现，我向你保证，它们很快就会卷铺盖离开了。**” \n“所以，如果我想要拥有内在的力量，能够早些起床，少吃饭、多读书，不忧虑、更热情，我要做的就是将意志的力量全部发挥出来净化我的思想。” \n“**当你控制了你的思想，你就控制了自己的心智。当你控制了自己的心智，你就控制了自己的人生。一旦你能够完全控制自己生活，你就成为了自己命运的主人。**” \n\n\n## 培养意志力的方案\n### 重复一些简单的语句：真言/创造性想象\n尽管只有为数不多的喜马拉雅山上的智者知道这些真言，但是它们已经历经了五千余年时光的磨炼。瑜伽师拉曼告诉我，如果不断念诵它们，就可以在很短的时间内培养起自我控制能力和内在的意志力。记住，语言具有巨大的影响力和暗示效果，词语就是自身力量的文字体现。在你的头脑里装满充满希望的话语，你就会变得信心十足；在你的头脑里装上善良的话语；你就会变得善良而开朗；在你的头脑里装上勇敢的话语，你就会富有勇气。话语就是力量。**”朱利安总结说。 \n“好吧，我洗耳恭听。” \n“**我建议你每天把这句真言至少重复三十遍：“我比外表看起来更强大，世界上所有的力量都在我的身体里。’它会在你的生活中带来持久的改变。要是想让这句话迅速起效，就把这句话和我前面告诉过你的创造性想象的练习结合起来。比如说，去找一个安静的地方。坐在那里闭上双眼，不要分散心神，保持身体静止不动，因为意志薄弱者最明显的一个特征就是身体闲不下来。然后大声重复这句真言，一遍又一遍地重复。在你做这些的时候，把自己看作是一个遵守纪律、意志坚定的人，能够完全控制自己的心智、身体和精神。在内心里想自己要像甘地和特蕾莎修女在面对艰难时刻的所作所为那样行事。随后产生的效果一定会让你大吃一惊的。”朱利安信誓旦旦地说**\n\n## 两个方法\n### 试着去做你不喜欢做的事情\n第一件事就是试着去做那些你不喜欢做的事情。对你来说，这些事情可能很简单，比如早晨起来叠被子，步行上班而不是驾车去。通过养成尽力而为的习惯，你会很快改变顺从软弱和冲动的毛病。**” \n“不用则废？” \n“完全正确。为了塑造意志力和内在力量，你首先要使用它。你越是努力培养内在约束的胚芽，就会让它成熟得越快，让你更快地看到你所希望的结果。” \n### 沉默的誓约\n实际上那种誓约就是这样的，约翰。那些推崇这一方法的西藏喇嘛相信，长时间的完全的噤声有助于提高一个人的内在自律性。**” \n“这是怎样做到的？” \n“**从原理上说，通过一天的沉默不语，你可以使你的意志完成你命令它做的事情。每当想要说话的念头出现，你就立刻抑制这个冲动，继续保持安静。你看，意志本身不会产生任何想法。它等待着接受你的引导，刺激它采取行动。你越能控制自己，意志的力量也就越强大。问题是大部分人根本就没有使用他们的意志力。**” \n“为什么会这样？”我问。 \n“**也许是因为大部分人认为他们根本就没有意志力。他们为这种明显的软弱怨天尤人，却不从自己身上找原因。那些火暴脾气的人会对你说：‘我抑制不住呀，我的父亲也是这个样子。’那些过度焦虑的人会对你说：‘不是我的错，我的工作压力太大了。’那些整日酣睡的人会说：‘我能怎么样呢？我的身体需要每晚十个小时的睡眠。’这些缺乏自我负责能力的人从不知道，在我们每个人的体内都沉睡着不可思议的潜能，期待着受到鼓舞，然后转化为具体的行动。当你渐渐了解古老的自然法则，知道它们支配着宇宙的运转以及所有生活在其中的生命，你就会明白成为你想成为的人是你天赋的权利，你有能力改变你所处的环境。同样，你有能力摆脱过去时光的束缚，让自己得到前所未有的自由。为了达到这一目的，你必须成为意志的主人。\n# 金秒表，代表时间\n原来是一个缩微型的沙漏，用褐色的玻璃和一小块檀木底座制成。看到我略带惊讶的表情，迪维笑了笑，温和地告诉我，每一个智者在孩提时期都收到过一件同样的器具。‘尽管我们身无长物，过着纯粹、朴素的生活，但是我们尊崇时间，并且注意到它在一刻不停地流逝。这只小小的沙漏是对我们每个生命一刻不停走向死亡的提醒，提醒我们在向目标接近的过程中，过一种充实的生活和有所创造的日子是多么重要。因为，正如人不可能同时踏入第二条河流之中，人也不可能返回来，重新开始同一次生命的历程。’**” \n“那么，这些生活在喜马拉雅山上的高僧也重视时间吗？” \n“他们中的每一个人都深知时间的重要性。**他们每个人都培养起了我所说的‘时间意识’。你瞧我们已经明白地意识到，时间就像沙粒一样从我们的指缝中毫不留情地漏下去，不再复还。那些早年就能够明智地利用时间的人会收获一个丰富的、多产的、心满意足的人生。而与此相反，那些从来没有感受到‘掌握时间就是掌握生命’这一原则的人，永远也不会发现他们本性中其实曾经拥有着巨大的潜能。时间是最伟大的神，也是最公平的分配者。无论我们是特权者还是贫苦阶层，无论是生活在得克萨斯还是生活在东京，我们都被分配到一天二十四小时的时间，谁也不多一秒钟，谁也不少一秒钟。而最终真正能把创建了杰出人生的大人物和随波逐流的庸才区分开的，恰恰是他们对时间的不同使用方式，简而言之，就是不同的时间观念。**” \n“但是我曾经听我父亲说过，正是最忙碌的人才最有空闲。你对此怎么评价？” \n“我赞同。忙碌的、能干的人总是能够高效地使用他们的时间——他们必须要生存下去。但是，成为一名最优异的时间安排者，却并不意味着必须把自己变成一个彻头彻尾的工作狂。相反，有效的时间控制能够让你有更多的空闲去做自己喜欢的，真正有意义的事情。控制好时间才能控制好人生，所以要好好守护时间。记住，这是不可再生的资源。” \n“那我现在就给我的表上好发条。”我们一起笑了起来。 \n“让我再给你举一个例子吧，”朱利安提出建议，“**让我们假设这是星期一的早晨，你的时间表上排满了约见、会议和庭审出席的日程。往常，你会在早晨六点半就起床，一口吞下一杯速溶咖啡，飞奔着赶去工作，然后昏天黑地地度过了非常紧迫的一天。好，接下来让我们假设有一次，你在星期天的晚上抽出了十五分钟的时间来计划自己的安排。或者说为了更加高效，让我们假设你在平静的周日上午抽出了一个小时来安排整个一周的生活。在你的每日计划表中，你标出什么时候会见客户，什么时候你要做法律研究，还有什么时候你要回一些重要的电话。最重要的是，在一个星期之内，你把在个人、社会和精神方面的发展目标也都列入了你的记事本。这个简单的举动是保持生活节奏平衡的奥秘。通过在每天的日程表上锁定生活中所有最至关重要的方面，你可以确保这一个星期的生活过得充实又有条不紊。**” \n“你是不是建议我从每天繁忙的工作中抽出一点时间来休息，然后去公园里散步或者躲到一个地方沉思冥想？” \n“是的。你为什么非要那么严格地遵守惯例呢？你为什么一定要像其他人一样用同样的方式行事呢？**走你自己的路好了，不要在乎别人怎么看，关键是要让自己觉得舒服自然。你为什么不提前一个小时开始工作，这样就可以有足够的闲暇在中午的时候放下手头的工作，到办公室附近的美丽公园里平心静气地散步。还有，为什么不在一周刚刚开始的时候就向工作里投入更多的时间与精力，这样就可以在周五下班之前早早收尾，然后快快乐乐地带上孩子去动物园玩一会儿。还有，为什么不在一个星期内抽出两天的时间在家里工作，这样就可以更多地照顾家庭。我说的所有这些都是为了让你更有创造性地作出一周的计划，合理地安排时间，当然并不是非如此不可。一定要把时间列在你首要关注的核心位置上，它会让你明白，人生中最有意义的事情决不应该为了最不重要的事情而作出无谓的牺牲。**” \n\n忙碌并不是借口。真正的问题是，你要随时问自己，你究竟在忙些什么？我从那些年老的智者那里学会了一条伟大的法则：你在一生中获得的80％的成果，常常来自于你仅仅花了20％的时间来完成的事情。瑜伽师拉曼把它叫作‘古老的二八法则’。\n\n你的意思是指，那些‘高效能’的时间就是指我花在提高自己法律知识上的时间，和我的客户一起丰富人际关系的时间，还有为了成为更能干的律师而投入的时间？” \n“是的，还有你为了培养亲情而和詹妮以及孩子们一起度过的那些时间。” 朱利安的回答相当肯定，然后他又做了一个补充：“还有花在自然中的时间，这是你对自己有幸拥有的一切而表示感恩的时间，也是用来更新你的心智、身体和精神空间的时间。以上这些都是‘高效能’的行为，帮助你得以从容规划出一个值得度过的人生。当然，有一些无效的时间付出是你没有办法避免的。我的意思是说，设法将自己的时间尽量多地投入在这些有意义的行为上。古希腊的哲人早就说过：‘已经得到启蒙的人最先获得生命的动力。’这就是控制时间的秘诀。\n\n那么就尽量学着去简化你的生活吧，”朱利安同情地建议我，“把减法应用在生活的每个方面。这样做以后，你就可以有时间去欣赏美好的、奇妙的事物。最难过的事情是我们任何一个人都不能为了领略到更多的美好而把自己的生命向后推延。我常常会有一种时不我待的悲伤。然而，有太多的人梦想在遥远的将来能看到神奇的玫瑰，却不去看一眼长在自家后院里的花朵。这真是一个莫大的悲剧。\n## 把时间花在精肉部位\n生活就像一长条熏猪肉，”我插话说，“为了有效掌握你的时间，就必须把肥的、瘦的细细地区分开来。” \n\n“说得好极了，约翰，你真讲到点子上了。尽管我的素食主义立场告诉我不应该选取这样一个禁忌性的话题，不过说老实话，我还是很喜欢这个比喻。**尽管有些粗俗，但你的确一语道破了机关。当你把时间和珍贵的心智精力投入到精肉部位以后，就没有时间在肥肉问题上浪费那些无谓的时间了。这就是你的生活从平庸变为非凡的关键。**\n## 要学会说‘不’\n你的话让我想到另外一个问题。别让他人窃取你的时间，要警惕无处不在的时间窃贼。**在你哄孩子睡觉，或者刚刚在心爱的椅子上坐下开始读一本你早已如雷贯耳的惊悚类小说时，总是有些人会在这个时候打来电话，然后天南海北地和你胡侃一通，然而他们不知所云的所谓高见早已将你的兴致破坏得面目全非。他们这类人专门会在某个特定时刻敲开你的办公室，然后赖在那里高谈阔论。而那时你好不容易才从疯狂忙碌的一天中抽出几分钟来，想一个人静静地待一会儿，喘上一口气，清理一下思路。这些情形听起来还熟悉吗？” \n“太常见了，朱利安，你说的一点也不错。我相信，以前你受到的骚扰比我更甚，因为你比我更有名气。不过，这些人似乎总是很难拒绝的，我感觉如果直接请他们离开或者紧闭房门是不礼貌的。”我向朱利安说出自己的心事。 \n“**你必须学会不留情面，才能真正履行自己的时间规划。要学会说‘不’，要有勇气对生活中的琐事断然说‘不’，只有这样，你才会有力量对那些重要的大事说‘好吧’。当你需要花费几个小时来专攻一个大案件的时候，当然要关紧办公室的门，连秘书都是非请莫入。记着我告诉你的话，不要每次电话一响你就去接听。这要看你是否方便，而不是看其他人的方便。要将主动权牢牢掌握在自己的手中。很讽刺的是，当他们发现你是一个惜时如金的人时，不但不会非议你的‘无礼’，相反会对你更加尊敬。他们会觉得你的时间很宝贵，因此就会重视你的时间安排，也不会无端地打扰你，从而还你一份清静。**” \n## 拖延时间又该怎么解决？\n我总是把不喜欢做的事情不断地、不断地向后推延，要到非做不可的地步才怏怏地动手。可是另一方面我又把大量的时间花在浏览垃圾信件、翻阅成堆的过期法律杂志上。也许我这样做只是为了消磨时间？” \n“消磨时间只是一种说法。实际上，**人的本性是趋利避害的。你不喜欢做一些事情，因此你的天性就会传达一种负面的情绪。但你同时又知道，这些事情如果不及时处理，那结果就会更糟糕，这个时候现实理性又会逼迫你及早动手。于是痛苦就产生了。但是就像我早先说过的，这个世界上最能干高产的人具有做好任何事情的习惯，哪怕这些事情可能是他们不喜欢做的，而不能干的人却养成了不做事的习惯。**” \n我不再答话，开始深刻反思刚才听到的话。**也许拖延并不是我个人的问题，或许只是因为我的生活变得太复杂了，而朱利安一下子就抓住了我的关键。 **\n\n“**瑜伽师拉曼告诉我说，那些掌握了时间的人生活会更加简单。匆忙、狂热的节奏并不是人类本性的趋向。他坚信并一直向我重申，只有那些做事高效并为自己设有明确目标的人才能得到永恒的幸福。这就是我所学到的智慧中最令人着迷的地方。它使我的工作优质而高产，同时又能够完全满足精神上的渴望。在某些时候，工作反倒成为了游戏。**” \n\n## 打一个小盹儿\n我喜欢在下午的时候打一个小盹儿。我感到这能使我保持活力充沛，更新精力，有蓬勃的朝气。我想可以这么说，我需要美容觉。\n## 临终心态\n迪维在送给我这个小沙漏时还给了我几条忠告，我永远也不会忘记。” \n“她说了什么？” \n“**她告诉我，种树的最佳时间是四十年前，其次就是今天。不要浪费生命里的任何一分钟。要有一种临终心态。**” \n“你再说一遍？”我问他，朱利安采用的生动词语使我惊呆了。\n“什么叫临终心态？” \n“**这是东方哲学中的一种生命观，也可以称其为‘向死而生’。这是你看待人生的新角度。它会提醒你，也许今天就是生命的最后一日，所以好好享用吧。**” \n“哈，如果你想知道我的真实感觉，朱利安，那我就老老实实地告诉你，这个话题我觉得很可怕啊，它让我想到了死亡。” \n“**确实如此，这就是生命的哲理。当你抱着这种临终心态，你会把生命中的每一天都当成最后一天。想象一下，每天早晨醒来以后，问自己一个简单的问题：“如果今天是我生命的最后一日，我将会做些什么？’接下来，考虑你将如何对待自己的家庭、同事，乃至你根本不认识的人们。想一想你将多么能干，多么振奋，在你手中，每一时刻的价值都实现了最大化。单单是这个临终问题就拥有改变人生的力量。它会让你每天都活力充沛，在做每件事时都带着丰富的热情和开朗的精神。你会开始注意那些一度被你不断拖延的、意义深远的事情，而不会在那些把你拖入危机和深渊之中的琐屑小事上无谓地浪费时间。” \n朱利安继续说：“鞭策自己去做更多的事，体验到更多的新鲜事物，促使你把精力用在扩展自己的梦想上。对，扩展你的梦想。不要安于碌碌无为的人生。既然你在心智的源泉中拥有如此无限的潜力，就要敢于让‘伟大’这个词和自己的生命联系起来。这是你的天赋权利。*\n## 表现得好像你不可能失败\n有一个简单的方法，可以为很多人消除意志消沉的苦恼，这种苦恼的确会让人感到非常难受**。” \n“我的杯子正空着呢。”我虚心地说。 \n“**表现得好像你不可能失败，这样你的成功就有保证了。把所有觉得不能达到目标的想法都从头脑中清除出去，无论是物质方面的，还是精神方面的。勇敢点，不要给自己的想象设限。不要成为过去记忆的奴隶，而是要做未来的设计师。从此，你就不再是从前的自己了。\n## 奉献是人生的终极目标\n在印度有一句古老的谚语：‘我们不是有着精神体验的生命存在，而是有着生命经验的精神存在。’通过长时间的修行和游历，我想现在可以说，我真正理解了自己在宇宙中的角色。我终于在自我的镜像之中看到了我是谁。我不再处于世界当中，世界在我的心中。那种体验是什么样的呢？我也描绘不出来。这样吧，我给你诵念东方哲人的两句诗：君掌盛无边，刹那含永劫。**” \n“我觉得我必须好好考虑一会儿你刚才说的那句话，尤其是最后那两句诗。你知道，我在大学里最害怕文学与语法修辞类的考试。”我老老实实地说，因为我真的不太理解朱利安说的话。 \n“当然。我理解，我的朋友，总有一天你会理解我所说的一切。如果你能够按照我告诉你的方法去做，认真练习我向你提供的诸多技巧，你就一定会在启蒙的道路上不断前进。你将慢慢掌握支配自我的技巧，而且你也将发现自己生命的意义到底是什么：那不过是永恒图景上的一点微光。而且你也将逐渐明白你究竟是谁，知道人生中的终极目标是什么。” \n“**那目标是什么呢？”我越来越有好奇心了。 \n“当然是奉献。无论你的房子有多么大，或者你开的汽车有多么炫目，但是你在生命结束的时候都不能将它们带入坟墓，唯一相伴的只有自己的良心。所以，你要时刻侧耳倾听自己良心的声音，让良知引导你。它知道什么是对的，它会告诉你，你的使命就是无私地帮助他人。这就是我的人生漫游经历带给我的最大的收获。眼下，我有非常多的人要去会面，为他们服务、治疗。我的使命就是把智者的古老智慧传播给所有需要学习它的人们。这就是我的目的。**” \n# 玫瑰花，代表无私地帮助别人 \n我和你分享的品质中最不可缺少的一条，约翰，就是这个：无论你取得怎样的成就，无论你拥有了多少套夏季别墅，无论你家的车道上泊着几辆高档小汽车，你的人生质量还是要归结到你所作出的贡献的质量上来。**” \n“这是不是和瑜伽师拉曼的寓言里那些鲜艳的黄玫瑰多少有点关系？” \n“当然有关系。**这些花会提醒你想起一句古老的中国谚语：送人玫瑰，手留余香。这句谚语的意思很清楚——当你致力于提高别人的生活时，在这个过程中你也间接地提高了自己的人生品质。如果你每天都有意地随时随地做出一些善举，你自己的人生也将因此而变得更加丰富，更加有意义。为了培养日常生活中的神圣感和尊严感，从现在开始就用各种方式帮助他人吧。**” \n“你是不是在建议我多去参加一些志愿者活动？” \n“嗯，**应该说那是一个良好的开端。但是我所说的比参加志愿者活动这个具体的事件具有更多的哲学性。我是在建议你，你要对自己在这个星球上要扮演的角色采取一种新的理解‘范式’。**” \n“你又把我搞糊涂了。拜托你把‘范式’解释得清楚一点，我实在不熟悉这个词。”我请求道。 \n“**简单来说，范式就是人们通常看待生活境况和生命过程的一种方式。有些悲观主义的人把人生看成一只半空的杯子，而乐观主义者则视之为半满的杯子。你看，‘半空’与‘半满’，对于同一种存在的境况竟然有不同的解释，这就是因为观察者采用的范式不一样。范式从根本上说就是一面透镜，你要通过它来观察人生历程中各种事件，无论是对外在世界还是内在世界。**” \n“因此当你建议我采用一种新的范式来看我的人生意义，是不是说我应该换一种眼光？” \n“**在一定程度上是这样的。为了显著提高你的生活品质，你必须针对自己为什么会在地球的这一处地方生活而不是那一处地方生活找出一个原因。你必须认识到，正如你两手空空来到这个世上一样，你注定是要两手空空地离开的。在这种情况下，只有一个真正的原因说明你身在此地的存在价值。**” \n“那会是什么？” \n“**把自己无私地奉献给他人，通过有意义的工作方式来作出应有的贡献。**”朱利安回答说。\n“我并不是说你不能享受你的生活，或者说你必须放弃自己的法律事业，然后有意让自己的生活变得穷困潦倒，好像只有这样才能全身心地投入到无私服务社会的行动中去——虽然我最近常常见到一大批散尽家财、投身慈善事业的人，而且看上去他们个个都心满意足——你要明白，我们的世界目前正处于大变革当中。” \n“大变革？”我有些迷惑不解了。 \n“**是的，大变革。对比一下过去30年和今天的生活，你就会发现人们对于意义与价值的理解发生了翻天覆地的变化，人们开始用钱换取人生意义。比如过去的律师只会按照委托人钱包的尺寸来做出是与否的判断，而现在则不同了，真正的律师会按照人们对他人的责任大小和爱心的大小来作出自己的判断。教师们辞去稳定又保险的大学工作，为生活在城乡结合部的贫困孩子无偿提供义务素质教育。在这个大变革的时代里，有良知的人们已经听到了呼唤价值改变的铃声，人们已经重新认识到自己生存的目的。这一目的无法用金钱和社会地位来衡量，而且他们已经得到了帮助自己去实现这个目的的特殊天赋。**” \n“究竟是什么特殊天赋？” \n“**确切地说，就是我花了整整一个晚上来告诉你的那些因素：丰富的心智，无穷的精力，无限的创造力，坚强的意志力和内心的安宁。而现在你要做的就是勇敢地开启这些宝藏，在日常生活为了公众的利益而使用它们**。\n\n\n## 摆脱自我的枷锁\n那么**怎样才可以开始做好事呢？**” \n“**做好事不分时间先后、事情大小，你可以随时随地将自己的爱心传递给别人。再稍微抽象一些，那我的回答也很简单，就是把‘做好事’这种理念放在改变自己人生观、世界观的首要位置上，这样你就可以不再把自己看成是一个简单的个体，而会开始把自己看作是集体洪流中生动鲜活的一分子。**” \n“那么我是不是得变得再善良点儿，再温柔点儿？” \n“要知道，你能做的最崇高的事情就是给予。”朱利安双手伸向空中。 \n“**东方的智者将这个过程叫作‘摆脱自我的枷锁’，就是要你丢掉自我意识，开始关注更高的目标。也许这在某种程度上意味着你要向周围的人付出更多的时间和精力，尽管它们是你最有价值的两种资源。**” \n“资源？”我有些不解地问。 \n“对，是资源，”朱利安再次露出耐心的微笑，“如果按照最高标准来要求的话，可能是你抽出一年当中休假的时间，毫无报偿地为街区里的穷人做义工；如果按照最低标准来要求的话，可能是在交通极端堵塞的时刻，不再骂骂咧咧，不再抢着见缝插针，而是摆一摆手，让车流中别的车子先开走。” \n“哦，听起来像个交通警察在给我上课，朱利安。”我想起下班路上一到塞车时候就灌满满街道的喇叭疯响，不由得有些烦躁。 \n“哈，朋友，安静点。**听起来是有些老生常谈，但是在我所有领会到的道理中有一条非常重要——只有当你开始努力让世界变得更加美好，你的生活才会因此向更好的方向上推进。我崇敬的智者瑜伽师拉曼说过：在我们出生的时候，世界一片欢腾而我们哇哇大哭；如果我们一生的时间都在帮助别人，在为世界变得更美好的工作中度过了一生，那么等到我们死去的时候，世界在哭泣，而我们却很欢喜。**” \n## 每天做好事\n他们不过是需要有一点良知的火花来点亮同情的蜡烛。丰富的同情心和日常的善行会使你的人生更加丰富。每天早上在鸟鸣中醒来时，先别忙着起床，躺在温暖的枕头上抽出一点时间来考虑一下，在这即将开始的一天当中，你将为别人做哪些好事。你可以赞美那些对自己失去了信心的人，赞美那些最不指望得到赞美的人，给陷入困境的朋友送去温暖，还可以向家里的亲人们表示自己的感激和爱意。所有这些加起来，不就构成了更加美好的生活吗？而说到了友谊，你一定要不断维护它。一个拥有三个铁哥们儿的人其实是非常富有的。\n\n我得承认，我的内心已经完全被朱利安的话征服了，不过我还是故作轻松地和他打趣：“在中国话里这就叫作‘一个好汉三个帮’对吗？” \n朱利安对我竟然知道一句中国的谚语表示惊奇，不过他还是点点头赞许了我。“是啊，朋友给生活中增添了欢乐、兴趣和美丽。没有什么比和一个老朋友在一起开怀大笑更能让人恢复青春活力了。当你在工作上有了点成就，就开始狂妄自大，太拿自己当回事的时候，朋友的良言会帮助你保持谦卑。当生活给你带来了小小的挫折，你以为世界末日就要到来时，好朋友会一如既往地守在那里给你帮助。就以我为例吧，当我还是一名忙忙碌碌的律师的时候，我几乎没有时间交朋友，当然那些生意上的伙伴不算。在经过了长期与世隔绝的生活之后，在这个世俗的社会里，我是彻彻底底的孤家寡人了——除了你以外，约翰。我找不到一个人来陪伴自己去森林里远足，因为他们每个人都舒舒服服地待在温柔醉人的睡眠安乐窝里。当我读完了一本非常精彩的、深深地打动了我的书以后，却找不到人可以与我一起分享，我甚至连一个可以一起争辩讨论的朋友都没有。当金秋的阳光温暖了我的心扉，让我满怀欣喜的时候，我找不到一个值得信任的朋友可以敞开灵魂去倾诉。” \n朱利安很快控制住了自己的情绪，也许他很快便想起了住在喜马拉雅山顶的那些智者。他们不仅是他的老师，也是他的朋友，甚至从某种意义上说已经成为他的家人了。 \n“不过，我没有时间让自己深陷于遗憾情绪的负面影响。**我的智者导师们一直在教育我说：“对于开悟的人来说，每个黎明都将是崭新的一天。**’” \n# 钻石，代表活在当下 \n我基本上同意你的观点。我们确实应当对那些能够激发兴趣的目标表示出孜孜以求的积极态度，因为这是确保个人成就感的根源。但是还不止与此，你要记住，幸福是一场旅行，不是目的地。因此，你要时刻提醒自己，要为了今天的生活质量而活着——再也不会有另外一天会和今天一样了。”朱利安说，双手安详地交叠在一起。 **\n “在瑜伽师拉曼的寓言里，这个道理的象征物就是那条铺满钻石的小路吧？”我问他。 \n \n “是的，”朱利安的回答简洁而明快，“**那位高大的相扑选手走在钻石小路上，最终获得永恒的满足感和欢乐。就像他一样，只要你明白你当前所走的道路也铺满了钻石和其他诸多无价珍宝，那么你也能够拥有你想要获得的生活。不要再把时间过多地花在纵情享乐之中，因为人生更多地是由那些微小的快乐组成。尽管你常常忽视它们的存在，但正是它们在浸润着你的内心世界，让你变得善良而乐观，无私而勇敢。我的朋友，好好地享受围绕在你身边的美丽和圣洁吧，这些神奇之物全靠你自己去发现。**” \n “你的意思是不是说我应该先停下来，不再给未来的人生设置远大目标，而是要把注意力转移到当前的生活中来？” \n “当然不是这个意思，”朱利安斩钉截铁地回答，“**正如我在前面和你说过的那样，面向未来的目标和梦想非常重要，这在每一个真正成功的人生当中都是不可缺少的。正是因为怀有对未来事物的热望，才让你每天早晨坚持从热被窝中迅速爬起来，并且在一天的工作中保持着饱满的精神和注意力。树立人生的目标，就意味着给你的生活加油。我的意思只是说，不要为了成就就放弃快乐。不要把那些可以带给你幸福感和满足感的事情推迟到以后再去做。今天，就是今天就要活得畅快淋漓，而不是苦苦等到赢了体育彩票或者终于熬到退休以后。千万不要把生活中的幸福向后推迟，因为再晚可能就没有机会了。**” \n 朱利安站了起来，开始在起居室里来来回回地踱步。这时候他似乎又恢复了大律师的样子，在即将结束一场热情洋溢的辩论时作最后陈词。 “不要再自欺欺人，以为只要你为律师事务所再多雇用几个初出茅庐的律师来减轻工作负担，你就会马上变成一个更爱你的妻子，肯为家庭付出的好丈夫。”他的最后陈词和以往一样精彩，我看着此时的朱利安，竟然有些恍惚，觉得他从来都没有离开似的。但是他坚定的声音把我再次拉回眼前。 \n “**不要自欺欺人，以为只要银行户头上有了足够大的数目，自己就自然会有更多的自由时间，可以为所欲为，放肆起来。不要试图让自己想象，只要有了钱有了闲，你就会开始丰富自己的心智，开始关心自己的身体，开始滋养自己的灵魂。这些都是自欺欺人，我们都很明白这一点。今天，就是今天，是你享受多年来努力成果的时候。今天就是抓住眼前一刻，度过充实人生的时候。今天就是抛开忧虑的想象，让心中的梦想跃然成真的时候。而且，在你为自己创造幸福的时候，请你千万、千万不要忘记家庭给予你的丰厚馈赠。**” \n\n\n“我不敢肯定自己完全理解你的意思了，朱利安。”我没有跟上他的语言跳跃。 \n “**和自己孩子一起经历童年。**”非常简单的回答背后似乎隐藏了什么。 \n “嗯哼？”我小声咕哝了一句，在这句似是而非的话面前仍然摸不着头脑。 \n “**在人的一生中，几乎没有什么事能比你和孩子们一起分享童年更有意义了。如果你在第一个阶段里就忘了和孩子相伴，又怎么可能走向此后的幸福呢？然而，要是你根本没有时间没有能力来创造一个家庭，那么就算你拥有了整个街区当中最大的房子又有什么好处呢？如果你的孩子们根本就不知道给他们生命的父亲是谁，那么就算你名满全国，当上了炙手可热的第一辩护律师又有什么用处呢？我知道我说的是什么。**\n ”朱利安用我们的职业举例子，我感到他的声音因为激动而微微有些发颤。 朱利安的最后一句话使我感到困惑。我所了解的朱利安是一个超级明星律师，每天周旋在珠光宝气和灯红酒绿之中。他和红极一时的时装模特在豪华酒店里的浪漫约会，和他在法庭上滔滔不绝的辩论技术一样广为人知。这个做了多年花花公子的百万富翁怎么可能知道如何做好一位父亲？他又怎么可能知道我每天都要面对的挣扎，想要做好每一个角色要求的每一件事，在家里我得是一个了不起的父亲，出门以后我得是一个成功的大律师？所有这些琐碎的烦恼，朱利安怎么可能知道？我虽然这样想着，却尽量掩饰自己的怀疑，但是敏感的朱利安还是凭着直觉发现了我的想法。 \n “也许你不知道，我确实了解一些关于孩子的事情。”他温和地说，渐渐从刚才的律师状态恢复了他智者的模样。 \n “不过，说句实话，我还一直以为你没有孩子，是现代城市里人见人爱的钻石王老五，至少在你认输辞职之前，我们一直这样认为。你知道的，有多少女实习生为了进入你的办公室大耍花样？有多少……” \n “稍等，稍等，”朱利安竖起手掌做了个暂停的手势。\n “老朋友，你对我的了解从12小时前才开始，对不对？” \n 我看了看他，朱利安脸上的确没有矫揉造作的羞涩。有一种人，无论男女，一听到自己很受异性的欢迎就故意加以否认，但是脸上得意的神态完全暴露出内心的浅薄。朱利安脸上仍然是一潭秋水般的平静。 \n 他继续说道：“人们都知道我过着一种节奏快、心情飘的生活方式，同事们以为我那样的人生应该很过瘾吧。我也曾经这样认为，直到我明白那只不过是自欺欺人的幻象。\n ”这时竟然有一丝苦笑出现在他平和的脸上，“你知道我是结过婚的。” \n “是的。”我清了清喉咙。 然后，朱利安在开口前顿了一下，很像一个孩子正准备向最好的朋友吐露内心中隐藏最深的秘密。\n “但是，你不知道的是我曾经有一个小女儿。她是我最心爱的宝贝，是我一生中见过的最精致最可爱的小精灵。那个时候，我很像我们第一次见面时候的你，自高自大，野心勃勃，而且满怀着希望。我似乎很幸运，拥有世界上每个人想要得到的一切。所有认识我的人都纷纷夸我前程远大，羡慕我有一个美艳惊人的妻子和可爱极了的女儿。然而，当生活看起来非常完美的时候，幸福马上就又离我远去了。” \n 这是第一次，从朱利安踏入我的家门以后，忧伤第一次完全吞没了他欢乐的神色。一滴眼泪从他晒黑的脸颊上滑落，落在他天鹅绒般柔软的宝石红长袍上。我张口结舌，不知怎样安慰，因为我已经完全被老朋友的真情流露惊呆了。 \n “你不必继续讲下去，朱利安。”我同情地建议说，把一只胳膊搭在他的肩膀上去，希望能够安慰他。 \n “不，我要说，约翰，请听我说吧。在我过去认识的所有人当中，你是最信守承诺的，也是我最信任的。正如我所说过的那样，你常常让我回想起我自己年轻的时候。说真的，即使是现在，你的身上还有很多东西吸引着我。但是我知道一定要告诉你，用我自己的教训来告诉你，如果你继续按照现行的生活方式去生活，总有一天你明白其实这样是在自找苦吃。我来到这里就是为了向你表明，世上有那么多奇迹等待着你去探索，还有那么多美好的时刻等待着你去品味。 \n “那个夺去我女儿生命的喝醉酒的司机，在太阳都为之哭泣的10月的一个下午，不仅仅夺去了一条珍贵的生命——而是两条。自从我的女儿意外去世后，我的生活也打了死结。我开始在办公室里度过每一分钟清醒的时间，愚蠢地希望我的法律事业能够成为破碎心灵中的痛苦的替代品。有些日子，我甚至就睡在办公室里的长沙发上，因为我害怕回到家去，害怕回到那个还残留着那么多甜蜜回忆的家。我的妻子，从我读法学院的时候就一直陪伴着我的伴侣，后来也离开了。她说我的心里只有工作，这简直是压倒我的最后一根稻草。在痛苦、逃避、更痛苦的恶性循环中，我的健康越发糟糕，名声也变得不可收拾，我眼看自己一天天陷入声名狼藉的生活。那就是我们初次见面时我的生活状态，你眼中的同情向我证明我的回忆是准确的。的确，金钱可以买来的东西我一样也不缺，但那是我出卖了灵魂以后换回来的，我真的这样做了，交出我的灵魂。”朱利安激动地说着，声音仍然是哽咽的。 \n “所以你对我说‘和孩子一起分享童年的时光’，其实是让我每天都抽出时间观察他们的成长和发展变化。是这样，对不对？\n ”我怎么能够不同情面前这个痛苦的朋友呢。 “当时我们开车送她去参加她最好的朋友的生日聚会。即使到今天，她离开我已经二十七年了，但是只要能够再次听到女儿的咯咯笑声，只要能够再和她一起玩儿捉迷藏的游戏，就像我们俩经常在我家后院里玩的那样，我愿意付出一切代价！”朱利安捂住了脸，大口喘息着。 \n “是的，我明白，我明白。”我不知怎样安慰他。 \n “**我最喜欢把她抱在怀里，温柔地梳理她的金色卷发。她离开以后，把我的心也带走了。尽管我在喜马拉雅山上找到了开启心智和自我掌控的方法，我的人生因为找到了新的意义而重新振作起来，但是在我度过的所有日子中，没有一天不在头脑的静默回忆中看到我可爱的小女儿的粉红小脸。你也有这么好的孩子，约翰。不要为了几棵树木而失去了整片森林。你能够给予孩子们的最好馈赠就是你的爱和关心。像第一天见到他们那样去重新认识他们。一定要让他们明白，他们对于你来说，要比职场事业中过眼云烟般的名利回报重要得多。不久之后他们就会长大，就会一个个离你而去，去建立自己的家庭和生活，去建立自己人生中的失落和幸福。到那时候你再表白你对他们的珍惜就太迟了，时间一去不复返。**” \n 毫无疑问，朱利安拨动了我心底最深处的那根弦。我猜我在有些时候已经隐隐约约察觉到了，我的工作狂心态正在慢慢地瓦解着我和家庭的联系。这种瓦解就像是余烟缭绕的火苗，静静地燃烧，缓慢地积攒力量，直到有一天向四面八方爆发出毁灭性的能量。我知道孩子们需要我，我也知道内心中我多么眷恋他们，尽管我们谁都没有对彼此说过这样的话。我需要朱利安的提醒。时间飞逝，孩子们长大得太快了。我已经记不起来，我和儿子安迪最后一次在清新的周日早晨，偷偷地跑到他的祖父最喜欢的钓鱼池边度过一天的确切时候了。曾经有一段时间我们一起快乐地度过每个周末。而现在，这个由来已久的习惯简直就像是别人回忆中的故事了。 我越想越感到内心沉重。安迪在学校里的钢琴独奏会，圣诞节的化妆演出，还有他的少年棒球联赛，我一个都没参加，都被我用来换取事业上晋职升迁了。那么安迪的心中会怎么想呢？天哪，他千万不要以为我把工作看的比他更重要啊！ \n “我都做了些什么啊？”我抱着头苦苦思索。我的确已经身不由己地滑到了朱利安所描述的灾难的边缘。好吧，接下来，我决心要改变一切。 \n** “幸福犹如一场没有终点的旅程，”朱利安继续说，他的声音已经滤去了刚才的感伤和波动，再一次因为饱含热情而高昂起来，“这也是你给自己创造的一次机会。你可以一直顺着那条铺满钻石的曲折小路向前走，也可以继续草草挥霍所剩的时间，追求彩虹尽头的那一坛黄金，最终却发现这不过是一场空。欣赏每一天中的任何一个不同的时刻吧，因为今天才是你完全拥有的一天。**” \n “每个人都能学会‘活在当下’吗？”我问道。 \n “当然。无论你目前的境遇怎么样，你都可以训练自己，学会欣赏并且珍惜生命和家庭的馈赠，在每一天的生活中都使自己的存在充满了珍宝般的价值。” \n “但是这是不是有点太过于乐观了？要是有谁在一场糟糕的商业交易中损失了一切，他该怎么办？我们不仅是说他们的经济破产了，而且指的是他们精神上也完全垮掉了。” \n “唉，”朱利安轻轻叹息，“**我就是希望人们知道，你在银行户头上有多少存款，或者你住的房子是大是小，根本就和你能不能带着欢乐的情绪和好奇心去生活毫无关系。这个世界上开心的穷光蛋不多，可闷闷不乐的百万富翁到处都是。如果你学会在一天里抽出5分钟来练习感恩的艺术，你就会得到一直在寻找的丰富生活。就连你在举例中说到的那些人也可以发现，生活中其实还有很多东西值得他们去一再感恩，即使他们遭遇到了可怕的经济困境和精神困境。让我们去问问他，是不是还拥有自己的健康，是不是还有可爱的家庭和社交中的好口碑？他难道不以在这个伟大的国家里拥有公民资格而感到幸福吗？他的头顶上难道不是还有一方遮风挡雨的屋顶吗？也许他不再拥有成功时的霸气，不再有事业顺利时的大笔财富，不能重复一掷千金的气概，不能随心所欲地签支票购买所有感兴趣的东西。然而，还有另外一些财富是他应该用一生的时间来感恩的。我们都有很多需要感恩的东西。即使是阳光灿烂的夏天里，一只鸟儿在你的落地长窗前面婉转啼鸣，一个睿智的人也会认出来它们其实是上天赐予的馈赠。记住，约翰，生活并不总是给你想要的东西，却永远会给你需要的东西。**” \n\n我们都有命里注定要去完成的事情。当你发现更高的目标，投入所有的精力时，你的才能将会迸发出来，幸福会充满你的生活。一旦你认识到你的使命，无论是成为一位成绩突出的教育孩子们的老师，还是做一个灵感丰富创作惊人的艺术家，所有的愿望都会轻而易举地被实现。你甚至都不必先去尝试。不瞒你说，我觉得你越是先去尝试，在目标实现之前所花的准备时间也就越长。相反的是，只要你跟随梦想的道路，所有在期望中想要获得的东西都一定会纷至沓来。它将引领着你走向神圣的终点。这就是我所说的铸就命运的含义。\n\n## 极乐世界？\n不幸的是，约翰，你听到彼得的故事，还有那根奇妙的魔法线仅仅是一个故事，一个神话故事。而我们此时正生活在一个绝对现实的世界里，根本没有第二次机会让你重新来过一遍，去实现圆满的人生。今天，唯有今天才是你领受生活馈赠的时机——在还不是太晚之前。约翰，让这新的一天成为你人生中的分界线，你在这一天完完全全下定决心，把所有的精力都集中在对你来说是真正重要的事情上。你要下定决心，在那些可以使你的生活具有更有意义的事情上多花些时间。对生命中特殊的时刻心存敬畏，为它们的蕴含而沉醉。做那些你一直想要做的事情。去爬你一直想要去攀登的高山，或者去学一种乐器，自己做一支曲子，写一首歌词。在大雨天冲出去跳舞，或者另起炉灶从事一门新职业。学会热爱音乐，聆听音乐和鉴赏音乐，学会一门新的外语，重新点燃童年的欢乐时光。不要出于成功的考虑就把幸福向后推延。相反的是，开始学会欣赏过程中的美，重新振作你的精神，认识你的灵魂并且开始爱护它。这就是通向极乐世界的道路。” **\n  \n ** “极乐世界？**听起来像佛教里的词语？”我重复着。 \n  “**极乐世界不单单是佛教里的词语。喜马拉雅山上的智者相信，真正开悟了的灵魂要前往的最终目的地是一个名叫极乐世界的地方。事实上，它不仅仅是一个地方，智者相信极乐世界是一种状态，人们可以超越此前他们所知道的一切。在极乐世界中，一切都是可能的。那里没有苦难，生命的舞蹈奔放到了极致，神圣而完美。在抵达极乐世界的途中，智者感到自己正在走向天堂。这就是他们人生中的最终目标。”朱利安总结说，他的脸笼罩在安宁之中，简直就是天使的模样**。 \n  “**我们之所以在这里都是出于某些特定的原因，”他预言般的继续总结着，“静心思考真正召唤你的是什么，想一想你将怎样帮助他人。不要再做惯性和惰性的奴隶，不要再拿贷款作为不快乐的借口。今天，用人生真正的意义点亮你的生命火花，让它明亮地熊熊燃烧起来。开始练习我和你分享的那些道理和方法，去做你能做的一切。当你感到内心里非常渴望尝到极乐世界果实的滋味时，那一时刻就会自然来临。**”朱利安眼睛里的光芒使他看上去像一位神殿里的预言祭祀。 \n\n## 开悟\n“会有一些微小的迹象出现，向你显示极乐世界的入口。你开始注意到身边每一件事物当中蕴含的神圣性：比如一束月光的完美，炎热夏季里湛蓝的天空所具有的吸引力，雏菊盛开时的芬芳，或者小孩子淘气的大笑声。\n  ”我听出他的语气中充满鼓励。 “朱利安，我向你保证，你和我在一起度过的时间不会白白浪费掉。我准备让自己完全按照智者的智慧来用心地生活，而且我将信守承诺，把我从你那里分享来的所有知识，和那些可能会从中受益的人们一起温习。我说这些话是发自内心的。我向你保证。\n  ”我真诚地说道，感到内心里激情涌动。 “把智者的丰富智慧统统传播给身边所有的人们吧。他们很快就会从中受益，提升他们的生活品质，就像你提升了自己的生活品质一样。而且还要记住，要享受过程本身，沿途和终点一样美好。” \n  我请朱利安继续说下去。他说：“瑜伽师拉曼是一个非常伟大的讲故事的人，但是有一个故事在他讲给我的所有故事当中显得与众不同。现在我可以讲给你听吗？” \n  “当然好啊，你知道我一直在聆听你的每一句话。” \n  “很多年以前，在古老的印度，有一位王侯准备为他的妻子修建一座宏大的建筑，作为他对妻子的深爱和感情的象征。这个王侯想创造出一种世界上从来都不曾见到过的建筑结构，它将在月光照耀下的夜晚里微微放光，让世世代代的人们都因为仰慕而特地赶来朝拜。于是，他的工匠们每天都忍受着酷暑骄阳，一砖一瓦地劳作。每过一天，结构就更加清楚一点，越来越像一座丰碑，也越来越像爱的灯塔，直指蔚蓝色的印度天空。最后，在经过了日复一日的20年的重复劳作之后，这座完全用白色大理石建成的宫殿终于竣工了。你猜一猜我说的是什么？” \n  “我对印度的文明几乎一无所知。”我老老实实地承认。 \n  “就是泰姬陵。”朱利安回答我说，“我的意思很简单。这个星球上的每个人都是一个奇迹。从某种意义上来说，我们中的每一个人都是天才，都是英雄。我们中的每一个人都有潜力取得超凡的成就，取得巨大的幸福感和永恒的满足感，所需要的只是朝着我们梦想的方向踏实前行。就像泰姬陵的建筑过程一样，在简单重复的劳动中整整耗时20年。**一个充满生命的奇迹就是这样日复一日，一砖一瓦建成的。小的成功会通向大的胜利。微小的、循序渐进的变化将会在一起形成积极的习惯。而后，积极的习惯会带来好的成果。积极的成果则会激励你继续朝着更加伟大的个人目标去努力。开始像对待生命中最后一天那样过好每一天的生活。从今天开始，多多学习，多多大笑，去做你真正喜欢做的事情。不要逃避自己的命运，更不要否定自己的命运。因为和存在于你自身中的那些珍贵的东西相比，那些身前身后的浮云名利根本都是无关紧要的。**” \n\n如上是内容摘要，如果想更细的了解，可以购买相应的图书。这个内容是需要不段实践才能看到效果。加油吧，共同探索。\n\n","source":"_posts/读书/《卖掉法拉利的高僧》摘要 .md","raw":"---\ntitle: 个人精进|读书笔记——《卖掉法拉利的高僧》\ndate: 2018-07-07 18:03:41\ntags: [读书]\ncategories: [读书]\n---\n\n这是一部有方法的个人价值实现指南。故事以对话的方式讲述，在审视自我的过程中，重新发现想要的生活。\n\n刚开始看到这个书名时，感觉是一本精彩的小说，这么少的文字，被翻译成70多种语言，一定很有意义，就试着读了读。读了之后才发现这是一本实践性很强的自我价值实现指导书，里边有非常具体的方法论及使用方法，同时被里边的故事吸引了。\n\n本书通过瑜伽师拉曼一个寓言，来讲解充满丰富精神内涵的七项品质，这个寓言里，包含了人生的奥妙。下面就开始吧。\n\n“闭上眼睛，在脑海中浮现出以下画面……”\n你坐在一个漂亮的、郁郁葱葱的花园当中。花园里满眼都是你所见过的最引人陶醉的鲜花。四周极度寂静，了无声息。品味这花园带给你的快乐，想象自己有大把的时间来欣赏这片自然的绿洲。若你向四周环顾，就会看到，在这个神奇花园的中心伫立着一座高耸的、六层高的红色灯塔。 \n突然，花园里的静默被一阵嘈杂的吱吱嘎嘎声打破，灯塔底部的门被打开了。跌跌撞撞地走出来一个两米七高、四百公斤重的日本相扑选手，他是在不经意间闯进花园中心的。 \n“下面就更有意思了，”朱利安哧哧笑着说，“那个日本相扑选手几乎全身赤裸，只有私处覆盖着多股丝线织成的粉色带子。” \n然后这个相扑选手开始在花园里走来走去。他找到了一个闪闪发亮的金质秒表，不知是谁很多年以前遗留在那儿的。他不小心踩在秒表上，“砰”的一声巨响，结结实实地摔倒在地上。这个相扑选手变得毫无知觉，无声无息地躺在那里。就在你觉得他就要咽下最后一口气的时候，他慢慢地苏醒过来了，可能是因为受到附近那些黄玫瑰芬芳的刺激。仿佛吸收了新的能量似的，这个选手一跃而起，下意识地往左边望去。他被眼前的一幕惊呆了： \n透过花园边上的灌木丛，他看到一条蜿蜒曲折的林间小路，路上覆盖着数不清的闪闪发光的钻石。仿佛有一股神奇的力量，他渐渐地被吸引，顺着那条路慢慢地走了过去。就是这条路把他带上了充满无尽快乐和无上幸福的大道上。 \n\n**基于以上故事，引出的七个品质**\n# 花园，代表心智\n心智的控制要通过心理调节才能奏效\n\n不管你的生活中发生了什么样的变故，你都一直有权利选择自己对待事件的反应态度。当你养成了在每件事情当中都认真寻找积极因素的习惯时，你的人生就会变得鲜活有趣，生活就会升华到最高境界。\n\n**你的外在世界其实就是内心世界的外显。通过控制自己的想法，控制你对人生中每件事情的反应，你就能够开始掌控自己的命运。**\n\n我要郑重地建议你，不要动不动就贸然判断一件事情究竟是积极的，还是消极的。你最好先去经历它们，赞美它们并认真从中学习。生活中的每件事都会教你一些东西。它们是你完善内在世界和外在世界的力量。如果没有它们，你就会停滞不前。想一想它们在你生命中起到的作用吧。大部分人的生活之所以经历了突飞猛进的成长，起因都是因为遭遇到最具有挑战性的人生经历。假如结果让你有些出乎意料，也许会让你感到微微的失望，这个时候你就好好地想想自然的法则吧，因为它总是会确保在一扇门关闭的同时打开另一扇门。所以说，失败中潜藏着成功，挑战与机遇同在。一旦你把这个原则持之以恒地应用到你的日常生活中，以此为标准，努力训练自己的心智，积极地看待每件事情，善于从中汲取力量，那你就会永远忘却那些不必要的烦恼。你将不再是逝去的时光的囚徒，而将成为规划自己未来的设计师。\n\n**除此之外，我还应该做些什么呢？**\n首先，**开始依靠你的想象力而不是记忆力来过日子。**\n我想说的就是，要想释放你心智的、身体的和灵魂的潜能，首先就得学会扩展自己的想象力。你看，事情通常都会发生两次：第一次是在头脑中形成；接下来才会在现实中发生。我把这个过程称之为‘蓝图’，因为你周围发生的任何事情都来源于你脑中的蓝图。要是你学会了控制自己的想法，学会了生动地想象所有你期望的东西，蛰伏在你身体内的意志力就会渐渐苏醒。你就能够释放出心智中真正的潜力，从而创造出一种神奇的生活。从今天晚上开始，你就可以尝试努力忘掉过去的一切，大胆地想象比现实状况好得多的生活，去想象生命中最好的境界。你会为梦想的结果而感到惊讶。 \n\n**获取幸福的奥秘其实很简单：**找到你内心中最喜欢做的事情，然后把自己所有的精力都集中到那个方向，然后付出自己最大的努力。如果你对我们这个世界上最幸福、最健康、最心满意足的人做一个抽样调查，你就会发现，他们中的每个人都寻找到了生命中属于自己的热情，然后用一生的时间去追求它。这种使命感在某种程度上还可以为其他人服务。一旦你把自己的心智能量和生命力全都集中在了你所热爱的追求上，你的生活就会变得丰富多彩，目标的实现也会变得轻松而愉快，就像你在车库边哼着小曲边贴壁纸一样，充满了闲适的乐趣。\n\n湿婆神的智者每天都要花时间静思默想，不仅思考自己身在何处，还要思考自己将去何方。他们每天都在思考，最重要的是，他们尤其重视如何通过思考指导自己不断进步，哪怕这种进步看起来是如此的微不足道。因为他们知道，只要每一天都获得一些微小的进步，那么日积月累就会产生持久而有效的成果，反过来就会引起精神世界的巨大改观。\n\n## 玫瑰之心\n“有一种控制心智的方法要远远地胜过其他方法。这是瑜伽师拉曼钟爱的方法，也是在他教给我的所有方法中最好的一个。在接受了这项指导以后，我仅仅练习了21天，就感到精力旺盛，比我在青壮年时期都更加热情饱满、活力四射。这个练习法已经有四千多年的历史了，它的名字叫作‘玫瑰之心’。” \n“‘玫瑰之心’？很文雅的名字嘛。能不能给我讲得再具体些呢？” \n“**你用这个方法进行练习时，只需要准备一朵鲜艳的玫瑰和一处安静的地方。自然的环境当然最好，不过在一个安静的房间里也可以做得很好。一开始，你要集中注意力凝视玫瑰的花心，这就是它的心脏。瑜伽师拉曼告诉过我，所谓一花一世界，一朵玫瑰花如同一个生命：在路上你会遇到尖刺，但是如果你有信心，坚信自己的梦想会实现，最终就会越过那些尖刺，进入灿烂的鲜花世界。你要学会目不转睛地凝视着这朵玫瑰，感觉它的颜色、质地和模样，深深地呼吸它的芬芳，头脑中浮想着那些无限美好的事物。在这个过程中，别的念头会悄悄溜进来，慢慢侵入你的心智，分散你的注意。这是没有经受过特别训练的心智的特征。不过你不必为此担心，这种状况将很快就得到改善。你只需要把注意力再次返回到花心点上来。很快，你的心智就会因为经受了成千上百次的训练而变得强大有力。**” \n“要做的只有这么多吗？听起来确实再简单不过了。” \n“这就是这个方法的优点，约翰，”朱利安回答说，“不过，**这个方法必须每天坚持做才会起效。在开始的几天里，你会感到这种练习看上去容易，做起来却有很大的难度，也许你连5分钟都坚持不到。这也说明我们大部分人的生活节奏太快，都好像得了躁狂症一般，真正的安宁和沉默仿佛是宇宙之外的东西，让人感到很不舒服。**  很多人听到‘玫瑰之心’的建议之后都会说他们没有时间坐下来盯着一朵花傻乎乎地看上半天。有趣的是，也是这帮人还会向我诉苦说，他们没有时间享受孩子的笑声，也没有时间光着脚在雨中漫步。这些人们总是抱怨说他们太忙了，没有时间过那种闲适的生活。他们甚至没有时间去结交新朋友，因为建立友谊也是要占用大量时间和精力的。” \n\n“**要学习持之以恒的信念，花越来越长的时间去感知花心**，”朱利安继续用他低沉的声音说，“**也许在一两个星期以后，你就差不多可以在这个练习中坚持到20分钟，而不让自己的思想分散到其他的事情上去。这将是你修心养性并有所获得的第一个标志，你夺回了心智的控制权。你命令它关注哪个事物，它就会把注意力集中到哪个事物上去。那时，心智就成了最好的仆人，可以为你完成许多不可思议的事情。记住，不是你控制心智，就是它反过来控制你。**” \n\n\n## 静思默想\n湿婆神的智者每天都要花时间静思默想，不仅思考自己身在何处，还要思考自己将去何方。他们每天都在思考，最重要的是，他们尤其重视如何通过思考指导自己不断进步，哪怕这种进步看起来是如此的微不足道。因为他们知道，只要每一天都获得一些微小的进步，那么日积月累就会产生持久而有效的成果，反过来就会引起精神世界的巨大改观。\n\n最少每天抽出10分钟也是可以的。\n\n## 对立思维法\n在消除内心烦恼和其他负面情绪方面，还有一项特别有效的技巧。这项技巧建立在瑜伽师拉曼称之为‘对立思维法’的基础之上。**在伟大的自然法则下，大脑在同一时间只能拥有一个想法。**\n因此，任何人都可以在短暂的时间内很轻松地创造出一种积极、有新意的思维。过程简单而直接：如果有一个令人不快的想法在头脑中占据了主要的位置，就马上试着用一个鼓舞人心的想法去替代它。你的头脑就好比一个非常巨大的幻灯放映机，出现在头脑中的每一个念头都仿佛一张幻灯片。每当银幕上出现了令人不悦的画面，就用最快的速度拿起一张内容积极的幻灯片去替换掉它。\n\n## 湖水的秘密\n每件事情都会发生两次，第一次发生在头脑中，第二次是在现实中得到印证。我已经意识到思想也是现实，是物质性的信息，当我们把思想散播出来，其实也就改变了现实的世界。我也曾经对你说过，如果你希望在外部世界中获得显著的改善，首先就得从内在精神世界的改善开始，要学会改变你自身的思想与品格。 \n“喜马拉雅山上的智者有一个很好的办法来确保他们思想的纯净，而且有益于身心的发展。这个方法在把人的内在愿望转化为现实力量方面也显得极为高效，尽管它很简单。而且这个方法对任何人都有效。无论是汲汲于扩充人生财富的年轻律师，还是希望丰富家庭生活的妈妈，或者是希望完成更多销售量的推销员，都可以从这个方法中受益。智者给它命名为‘湖水的秘密’。在训练这个方法时，智者早晨四点钟就起床洗漱了，因为他们认为清晨时光之中包含着神秘的要素，他们可以从中感受到宇宙的脉动。这些智者沿着陡峭而狭窄的山路缓缓行走，这些道路最终把他们引向河流的下游。他们到那儿以后，就顺着一条几乎看不出来的小径继续走，两边是伟岸的青松和异样繁茂的鲜花。他们就这样一直走到一片开阔的空旷地。空地边上是一汪青绿色的湖水，这时水鸟还在沉睡，四周一片寂静。那种安静平和的情景仿若仙境。智者告诉我说，这个湖在很早很早以前就已经是他们祖先的朋友了。” \n“**‘湖水的秘密’是什么？**”我不耐烦地打断了他的话。 \n朱利安不急不躁地解释说，**智者会观察平静的湖水，想象他们的梦想化为现实。湖水如同一面命运的镜子，所有的欲望都能够完整地投射于其上。如果他们希望在生活中养成训练有素的良好习惯，他们会想象出自己在凌晨起床的样子，一丝不苟地完成他们严格的身体养生锻炼，时间在静默无声地提高个人意志力量的过程中悄悄流逝。如果他们想要寻找更多的快乐，就会满怀喜悦地注视着湖面，想象自己毫无节制地大笑的模样，或者回想自己遇到兄弟姊妹时在脸上浮现出的发自内心的微笑。如果他们寻求勇气，就会想象自己在面对危机和挑战的时刻是如何非常有力地行动着。而湖水就像一位仁厚的智者给他们以巨大的支持。中国人所说的“仁者乐山，智者乐水”，也许就是这个意思。** \n“还有一次瑜伽师拉曼悄悄对我说，当他还是个孩子的时候其实也非常缺乏自信心，因为他比同龄男孩的个头要小得多。虽然他们的教养都很好，依然能够态度温和地对待他，可在自卑感的暗示下，他还是变成了一个害羞的、没有安全感的人。为了弥补这个欠缺，拉曼独自来到那个天堂似的所在，把湖面当作内心映像的屏幕，尽力想象他所希望成为的那种人的形象。有些天里他看到自己成为了强有力的领导者，坐在高高的殿堂上，声音宏亮而果断地发号施令。而另外一些时候，他会看到自己老年的形象：一个博学的智者，具有无限的内在潜力和坚韧的性格。所有他希望在自己的生命中能够拥有的美德，他全部都在湖面上先看到了。 \n“通过几个月时间的静观，瑜伽师拉曼真的成为了他在意念中看到自己想要成为的那种人。你看，约翰，心智就这样通过头脑的想象产生了巨大的效果。**内心的图像可以影响到你的自我想象，而你的自我想象又会影响你在感觉、行动和进取方面的方式。**如果你的自我想象告诉你，你太年轻，成为不了一名成功的律师，或者你年纪太大，改不掉那些坏习惯，那么你就永远不能实现这些目标。如果你的自我想象告诉你说，要过一种丰富的、有目标的生活，要有良好的健康状态和幸福感，这些不仅是为了你自己，也是为了身边人们的幸福，那么这类预言最终会成为你的现实。 \n“而且，当你在头脑的屏幕上播放这些令人欢欣鼓舞的图像时，良好的变化就会开始显现在你的生命里。爱因斯坦曾说过，想象力比知识更加重要。**每天你都得抽出一些时间来进行冥想，即使只有短短的几分钟，也要有意练习创造性的想象。**在这一刻，尽可以把自己视作自己希望成为的那种人，不管这个形象是一位大法官，还是一个好父亲，或者是社区里的一个好居民。”\n “我知道，这一定是一个非常古老但是也非常有效的办法。我的孩子在看《哈里・波特》，里面有一面魔镜，波特照镜子的时候看到了他父母的模样，而他的好朋友红头发的荣恩照镜子时看到的却是自己成为了全校国际象棋冠军的时刻。镜子折射出的形象往往是自己最渴望见到的模样，畅销书就是这样感动我们的，不是吗？”我毫无顾忌地说出自己的想法。“还有啊，我一定要找到一汪特殊的湖水才能练习‘湖水的秘密’这个方法吗？我一定要每天一大早跑到郊外去苦思冥想吗？”我忍不住继续问，“你知道，这对生活在都市中的人来说简直是天方夜谭啊。” \n “你不必这么循规蹈矩。**‘湖水的奥秘’只是智者对这个古老技巧给出的一个称呼而已，其目的是要用积极的想象来影响心智，并不是让你拘泥于其中。你可以根据自身情况灵活机动地作出调整，比如在自己的客厅里，甚至就在办公室里来练习这个方法。只要你真的想这么做，那么随时随地都可以。**你可以试一试，先关紧房门，关掉手机，闭上眼睛，然后慢慢地做几次深呼吸。两三分钟之后你就会注意到，你真的开始感到周身放松。接下来，在头脑里想象出所有你希望的东西，想要拥有的，或者想要达到的。如果你想成为世界上最好的父亲，就想着自己正在开怀大笑，你的孩子们正围着你快乐地玩耍，而你呢，则不厌其烦地解答他们各种各样匪夷所思的问题。你还可以想象自己举止优雅、充满爱心的样子。通过这种方法，先在头脑中演练自己的形象，等到相仿的场景在现实的情境中真的出现时，你就可以完全施展自己的潜能了。 \n “想象自己形象的方法可以适用于很多种情况。你可以利用它来使自己在法庭辩论中更富有逻辑，你可以利用它来改善自己的人际关系，当然你也可以借此发掘自己的精神潜能。持之以恒地使用这种方法还会带给你社会声望的回报，以及丰厚的物质收获，如果你觉得这些东西对你很重要。**如果你觉得生活中缺少了什么，那是因为你的头脑中并没有这种东西。记住，要在头脑中留住美好的画面。一旦你开始练习这种方法，它就会让你彻底领会到心智所具有的神奇威力，开启大脑的潜力，它实现你生命中一切渴望的东西。**” \n “瑜伽师拉曼和与他居住在一起的**智者都经常提到一句老话，这句话世代相传，流传至今。我很幸运在这个对我们两个来说都很重要的夜晚将这句话转告给你。话是这么说的：“凌驾于他人之上毫无尊贵可言；真正的尊贵是超越以往的自我。’如果你想达到我真正达到的那个境界，与你认为有意义的东西并驾齐驱的话，你就必须首先和自己赛跑，向自己发起挑战。何必在意别人怎么议论你呢？最关键的是你自己的想法。只要你能够确定自己的所作所为是正确的，就不要总是去在意他人的眼光，那样会让你变得畏首畏尾。你要告诉自己，你可以做任何你想做的事情，只要你的良知和内心都认为它是对的。千万不要为自己做了正确的事情而感到害羞。根据你所认为的好坏标准来作决定，然后毫不犹豫地坚持这种看法与做法。一定记住，千万不要堕入那种器量狭隘的计较之中，把自己的自尊和别人的非议评判作比较。就像瑜伽师拉曼倡导的那样，‘你在思考他人的梦想时耗费掉的每一分钟，都会将你到达自己梦想的时刻向后推迟一分钟。’**”\n现在已经是半夜十二点零七分了。和平常不一样的是，我丝毫也没有感觉到疲惫。当我把这种感觉告诉朱利安时，他又一次露出恬静的微笑：“你已经学会了另一种开启生命的方法。就大部分人来说，疲惫是心智匮乏的产物。没有梦想、没有方向感的人所过的生活常常是碌碌无为、疲惫不堪的。让我给你举一个例子。你有没有这样的体验，比如整整一个下午待在办公室里，强迫自己阅读那些干巴巴的案情报告。很快，你的心智就开始溜号，然后你也逐渐地睡意蒙眬起来？” \n“有时候的确是这个样子的。”我回答说，其实内心并不愿承认，但事实上这恰恰正是我目前的工作常态。“当然，我们大多数人都会在遵循惯例、按部就班的工作中感到昏昏欲睡。” \n“可是，如果有一个朋友打电话来，问你想不想晚上出来一起看场棒球比赛，或者请你为他的周末高尔夫球比赛出谋划策，我敢说你一下子就精神起来了，任何疲惫的痕迹都一股脑儿地飞到爪哇国去了。我说得对吧？” \n“我承认确实如此，尊敬的顾问先生。”面对朱利安我只好讲实话，当然也故意用一种油腔滑调的语气来掩盖自己被人窥破心思时的不安。 \n朱利安从我的语气中知道他抓住了问题的关键，于是他更来劲了。“所以，你的疲惫不是别的，无非是匮乏的心智的产物。你的心智养成了坏习惯，当你从事一项单调而冗长的工作时，心智就成了挡路石。很明显，今天晚上你被我讲的故事吸引住了，开始对我希望与你分享的智慧感兴趣。**记住，你的兴趣爱好和心智注意力都会给你的日常生活带来源源不断的活力。在这个晚上，你的心智既不再关注过去，也不再关注未来，它就聚焦在当下，聚焦在我们的话题上。如果你经常把心智引向当前的生活，你就一定会得到无尽的活力，不管钟表上指示的时间是深夜十点钟还是十二点钟。**” \n\n# 灯塔，代表目标\n在花园的中央伫立着一座明亮的灯塔。这个象征提醒你记起另一条启示生命奥义的古老原则：**生命的目的就是有目的地生活。**那些真正开悟了的人们知道他们将要从生活中得到什么，比如情感的、物质的、身体的，或者是精神的。他们把先后的顺序排列得清清楚楚，经过严密的统筹安排之后，生活中每个方面的目标都会发挥出类似于灯塔那样的作用，在海面上风起浪涌的时候会给你指引航向，为你提供安全的避难所。你看，约翰，只要彻底地改变了人生的进取方向，任何人都可以将自己的生活来个焕然一新的改变。但是如果你根本不知道你从哪儿来，又要到哪里去，那你又怎么可能知道自己什么时候会到达那个不知所终的地方呢？\n\n“生命真是太奇妙了，”瑜伽师拉曼大发感慨，“人们可能会认为一个人工作得越少，就越有机会体验到闲适的幸福。然而并非如此，或者说这是片面地理解了幸福的含义。**一言以蔽之，幸福的真正源泉就是一个词：成就。**永恒的幸福来自于为了完成目标而进行的脚踏实地的工作，来自于在接近人生目标的过程中持之以恒的努力。只要点燃潜藏在内心中的火焰，它就会创造出一个令你我无法想象的新世界。我知道这听起来多多少少有点讽刺，因为我不辞辛苦离开自己以事业成就为本位的社会，艰难跋涉了几千里路，向居住在喜马拉雅山高峰上的神秘智者请教，希望得到关于幸福的永恒奥秘，却听说孜孜以求的幸福奥秘在于成就，可事实的确如此。\n\n成就并不一定需要用物质来衡量。就我个人而言，我的目标就在于获得内心安宁，学会控制自我，学会了悟人生。如果直到生命的尽头，我还是不能达到以上这些目标，我相信我会死不瞑目，因为我没有抵达自己的圆满状态。\n\n我的意思其实很简单。当你已经明确知道在你的一生当中最希望达到的目标是什么，不管这些目标是物质的、情感的、身体的还是精神的，你都要为抵达这一目标而倾注大量的时间与精力，只有这样才能最终体验到永恒的欢悦。你的生命将和我的生命一样充满快乐，而且你将逐渐看到自己的梦想一步步演变成为光灿灿的现实。但是这一切的前提在于，你必须首先了解自己，制订出明确的人生目标，然后通过持续不懈的努力把它转化为现实。我们称其为“达摩”，这是一句梵语，意思是‘生命的目标’。\n\n**很多人在发现了自己存在的真正目标之后马上放弃了限制自己人性发展的工作，即便这项工作为他们赢得了巨大成功和丰厚的物质回报。**这的确像是一场冒险，伴随着对自我的研究和灵魂的探索，你要学会不断地丢弃一些身外之物。可是也不能完全将它说成是一项冒险，因为在发现自我和人生的使命方面原本没有什么风险可言——在智者看来，发现自我这项工作本身就是人生体验中相当重要的一个环节。自我认知是开启人生的DNA生命链，它的确是生命中最关键的东西。\n\n我的达摩相当简单：无私地帮助他人，丝毫不考虑任何回报。记住，你不能在呼呼大睡中发现人生真正的快乐。同样，在游乐场或者像个游手好闲的人那样恣意消磨时光，也不可能抵达人生的真知。正如本杰明・迪斯雷利[3] 说的那样：**“成功的秘密在于不屈不挠地坚持自己的目标。’你所寻求的幸福是从有价值的目标中得来的，你付出所有的精力去争取成功，每天、每小时都努力地去接近这个目标。这是永恒哲理在现实生活中的应用，它规定了哪些事情是最重要的，永远不能被另外一些不重要的事情掩盖掉。在瑜伽师拉曼的寓言里出现的灯塔会一直提醒你，制订明确而有意义的目标有多重要，以及实现这些目标需要怎样的力量。**\n\n确立目标是最基本的出发点。制订出你的方向和目标，就可以把创造力的潜能加以放大释放，最终促使你踏上通向目标实现的道路。信不信由你，瑜伽师拉曼和其他智者都热衷于不断设定目标*。\n\n把我所有的智慧都和你分享。今天的这个例子就是为了进一步说明在人生中设立一个明确目标，以及清楚地知道你将往哪里去的重要性。你刚才见到的那一幕就说明了这个最为重要的原则：**你一定不可能命中你根本看不见的目标。人们用去整整一生的时间来希望自己变得更加幸福，活得更有活力，拥有更加丰沛的激情，然而他们没有发现这个重要原则。你要学会，每个月抽出10分钟的时间，把自己的目标写出来，仔细地想一想生活的意义何在、人生根本目的何在。设立一个明确的目标可以让你的人生过得与众不同。你会变得更加丰富，更加愉快，拥有更加不可思议的精力。**\n\n任何一个希望同时提高自己的内心品质和外在条件的人都要学会定期拿出一张白纸，认真地在上面写下自己的人生目标。\n## 一页纸在上面写出自己的目标\n此前我已经告诉过你，我们的头脑中平均每天会出现60,000个想法，然而这些想法太多了，多得你自己都容易迷失在欲望的丛林中。这个时候，在一张纸上写出你的愿望和目标就显得尤为关键。这一举动意味着你给潜意识的幽昧丛林中插上了一杆红旗，让这个想法比其余的59,999个想法突出得多。你的心智因此就像雷达一样，开始寻找一切机会去实现你的愿望。这个过程的确非常有效，可惜我们当中的绝大部分人对此视而不见。\n\n愿望成真，一共需要有五个步骤\n第一步是要对自己预期的结果有清楚而具体的认识。第二步是制造一种积极的压力来鼓舞自己。相对来说，第三步是非常简单的，那就是绝对不要好高骛远，设立一些不合时宜的目标。当你决心将人生和某一个目标相连，就意味着你必须给它设定一个明确的最终实现期限。这就如同你在为庭审准备大量的卷宗，你的注意力会一直集中在法官身上，因为他将决定庭审的日程安排。相反，其他人的话对你似乎没有任何影响。\n让我们回到达到目的、实现目标的五步法上面吧。一旦你对未来的结果有了一个非常清晰的成形设想，也为此创造出了一点积极的压力，并划定了最后实现的期限，甚至当众许下了完成它的诺言，那么接下来要做的一个步骤就是瑜伽师拉曼称之为‘神奇的21天法则’的方法了。\n最后我所说的就是，在你实现自己目标的过程中，一定要确保自己随时处在兴致盎然的状态。永远也不要忘记纵情狂欢的重要性，永远也不要忽视在所有的生命中都能看到精致的美丽。今天，以及你我一起分享智慧的这一刻都是上天的恩赐。保持你昂扬的精神、愉快的心情和好奇心。随时都要密切关注自己的毕生事业，随时都准备好要给予别人无私的帮助。宇宙对万物都一视同仁，这也是大自然的真理法则之一\n\n\n## 热情\n热情。这个词汇你一定要始终牢记在头脑里面。热情是实现梦想最根本的动力源泉。在我们这个碌碌无为的社会中，生命的热情早已经消失了。有的时候我们之所以什么也不愿意做，那是因为我们喜欢这样一直待着。而当我们开始动手做事情的时候，则是因为我们感到不得不做，只好没精打采地应付差事。这就是制造痛苦恶性循环的公式。不过我现在说的并不是那种浪漫的热情，尽管那也是促进成功、振奋人生的要素之一。我现在所说的是对生活的热情。每天早晨醒来时就要不停地对自己加油鼓劲，让自己浑身活力充沛，快乐无拘。热情是你工作中的加油站，热情的火焰越烧越旺，那么通向自信与成功的道路就越光明。你很快就会有丰厚的物质收获，同样还会获得精神上的巨大回报。\n\n## 禅悟\n意思是指不间断的、永不尽头的提升。\n\n怎么用来丰富智者的生活呢？\n**外在的成功首先开始于内在的成功。如果你确实想要改善自己的外在世界，不管这种外在世界指的是你的健康，你的人际关系，还是你的财产状况，你都必须先努力提升自己的内心世界。最有效的途径就是持续不断地进行改善自我的实践与练习。掌握自我就是掌握人生的DNA密码。**\n\n中国古老的智者曾经说过：“道在屎溺中。’意思就是说宏大的人生哲理其实恰恰隐藏在看似平淡的日常生活细节之中。\n\n在我们这个社会里，我们都太轻易地把无知看作是缺陷。然而，那些表现出自己缺乏知识，希望找到指引的人其实并不需要感到害羞，因为他们比其他人更早地意识到自己的问题，也就能够去更早地发现通向开悟的道路。你提出这个问题证明你非常诚实，让我看出来你的确愿意接受新理念。要知道在我们目前的这个社会里，改变是最强大的动力。大部分平庸的人害怕改变，而智慧的人则拥抱它的威力。禅悟代表的东方修行传统着重讲的是起步者的心智：那些敞开自己的头脑，随时准备接受新观念的人——也就是那些总是让自己的杯子空空如也的人——总是会在成就和满足感的方面达到更高的水平。千万不要羞于提出哪怕是最基本的问题。提问是获得正确知识的最有效的途径。\n\n当我说到提升你的内心世界时，我只是简单地描绘了一下自我改善和个体发展的功效，并告诉你这是你能够为自己做的最有价值的事。或许你会觉得太忙了，没有时间花在自己身上，当然也无须奢谈什么改变。如果你这么想，那就大错而特错了。你要知道，当你把自己培养成一个纪律严明、活力充沛，充满乐观情绪的人时，你就可以在外部世界中拥有所有的东西，做所有你想做的事情。当你对自己的能力和不屈不挠的精神产生了深刻的自信，那么任何东西要想成为阻挡你胜利的拦路石，那真的就是螳臂当车了。在控制自我心智上多花些时间，时刻关注自己的身体，丰富自己的灵魂，都会使你的生活会变得更加丰富，更有生命力。许多年以前，斯多葛学派的爱比克泰德就曾经说过：“一个不能控制自己的人就不是自由人。\n\n**禅的本意是静虑、冥想，悟与迷对称，指觉醒、觉悟。悟是意义的转化、精神的转化、生命的转化，含有解脱的意义。禅是修持方式，悟则是修持结果，两者是有区别的。但是东方的禅宗学人却把禅由坐禅静思变为日常行事，由心理平衡变为生命体验，这就从根本上改变了禅的内涵。东方的禅宗学人还认为觉悟要由日常行事来体现，由生命体验来提升。禅与悟是不可分的，悟必须通过禅来获得，禅没有悟也就不成其为禅。没有禅就没有悟，没有悟也就没有禅。**\n\n接下来我开始思考究竟能够从哪些方面来提高自己的修养。让我一项一项地来看看吧。第一，定期的锻炼可以给我带来活力，这样我才能够保持健康良好的体格与心态。第二，控制我的坏脾气，不要随便打断别人的谈话。如果能够改正这些毛病，可能会在人际关系方面给我和妻子、孩子以及同事的相处带来意想不到的好处。第三，改掉忧虑的坏习惯。这可以带给我心智上的安宁和平静的幸福感。第四……我越想越兴奋，因为我发现在我身上能够进行改善的地方实在太多了，可这些我以前却从来没有注意过。 \n\n## 建立人格力量、培养心智和充满勇气地去生活\n他耐心地谈到建立人格力量、培养心智和充满勇气地去生活具有多么重要的地位。他告诉我说：“这三种品质不仅可以让人拥有高尚的生活，而且可以使他的生活中充满成就感、满足感和内心的安宁。勇气这个宝贵的品质是每个人都可以培养得到的，它在经久不息的跋涉中带给你巨大的回报。**” \n  “**勇气和自我领导、自我发展又有什么关系呢？**”我大声问他。 \n  “**勇气使你敢于正视自己，与自己的惰性赛跑。勇气使你敢于去做所有你认为是对的事情。勇气使你能够控制自我，在其他人失败的地方仍旧支撑你继续坚持下去。最终，你拥有勇气的多寡程度决定了你可以获得的成就的总量，这是一个有趣的正比例关系。它能够使你确切地从自己的生活中看到所有不同寻常的奇迹。另外，我还想告诉你，能够掌控自我的人都是拥有非凡勇气的人。\n## 心智、身体和灵魂\n在我的新生活里也就更加信奉禅悟的哲学，让心智、身体和灵魂都持续地、永不休止地获得自然的点化，在丰富心性的过程中不断提高。朱利安这样说。 \n为什么这些天以来我听到这么多次‘心智’‘身体’和‘灵魂’之类的词语？你要是不稍微解释一下，我还真拐不过弯来。\n  “**这三个词语是你作为人的天赋中非常重要的三部分。简单地说，它们三者之间是相辅相成的关系。比如不锻炼身体，仅仅注重于提高心智，就只会得到非常空洞的胜利。如果你把心智和身体能力都提升到了最高水平，却没有认真地丰富自己的灵魂，会使自己感到异常地空虚，无法获得满足感。但是一旦你用出所有的力量来释放本性中这三个部分所有潜能的话，你就会在人生突然开悟的那一刻享受到神圣的狂喜。\n## 人们在艰难地进入未知区域的时候会变得最为强大\n首先我必须和你一起分享一个实际的例子。请你摆出俯卧撑的姿势来。当然，依你现在的身材，你还能趴下吗？”朱利安不失时机地揶揄了我一下。 \n  “天哪，朱利安变成军事训练官了。”我暗自想着。出于好奇，也是为了像朱利安所说的“保持我的杯子空空如也”，我只有老老实实地照办。 \n  “现在，使出全身的力量做俯卧撑，不要停下来，直到你确定自己彻底没劲为止。让我们数一数你到底还能够做几个。”朱利安在一旁笑着说。我的天，他只差手里再握一只秒表了。 我挣扎着做起了俯卧撑。多少年了，我那肥胖的身躯从来都没有进行过这么多的运动，除了有那么屈指可数的几次，我和孩子们一起走到最近的一家麦当劳快餐店，或者和我的法律界同行们一边漫步一边打一轮高尔夫球。最初的15个俯卧撑完全像是垂死挣扎。我开始暗自抱怨这个闷热的夏季，黎明之前的气温依然使得我大汗淋漓。然而，我已经下定决心，坚决不要显出任何虚弱的迹象，坚持下去，直到我的虚荣心和手臂一起无法坚持的时候再停下。 \n  不过我的虚荣心显然没有那么坚强。在做到第23个的时候我放弃了努力，结结实实地趴在地上。 \n  “不行了，朱利安。”我一边喘气一边忍不住抱怨起来，“这简直是要杀了我。你这是打算干什么？” \n  “你确定自己一个也做不起来了吗？”朱利安的表情十分严肃，丝毫没有开玩笑的意思。 \n  “我确定。算啦，让我喘口气吧。我唯一的感觉就是，我再动一动就会造成一次心脏病突然发作。那时你一定记着打急救电话啊。” \n  “再做10个。然后你就可以休息了。”朱利安命令道，他的口气似乎没有商量的余地。 \n  “你说话不算数！”我愤愤不平地抗议道。然而为了能够获得朱利安的教导，我只好咬着牙坚持继续做下去。1个……2个……5个……8个……最后总算做了10个。我连翻身的力气都没有了，直接趴在地板上，觉得天都快要塌下来了。这时，耳边响起朱利安清晰的声音： \n  “瑜伽师拉曼和我在一起分享他的特别寓言的那个晚上，我也像你这样经受了训练。不过，唯一的区别在于我做的俯卧撑是你的好几倍。”朱利安说。“当我体力不支趴在冰冷的地板上的时候，拉曼镇静地对我说，痛苦是最伟大的老师。” \n  “痛苦是最伟大的老师？从这样枯燥的身体练习中究竟能够学到什么呢？”我气喘吁吁地问他，丝毫也不掩饰我的抱怨之情。 \n  “瑜伽师拉曼，还有所有居住在喜马拉雅山上的智者在这个问题上都保持了完全一致的看法。他们认为，**人们在艰难地进入未知区域的时候会变得最为强大。**” \n  “好吧。我相信你的话是有道理的。但是这和俯卧撑有什么关系呢？又有什么理由让我非得做这么多俯卧撑不可呢？” \n  “当你做了23个俯卧撑之后，你告诉我力气用完了，一个也做不起来了。我相信你对我说的话，在你的意识表层中，那真的是你的极限。然而，当我一定要求你再多做几个，你听从了我的话以后就又多做了10个俯卧撑。这说明了什么呢？” \n  朱利安不等我回答，紧接着给出了答案：“**这说明潜伏在你身体里的力量还有很多，只不过平时它们都在沉睡状态，缺乏足够的刺激将它们一一激活。一旦这些力量醒来，一旦你发现了自身力量源泉的时候，你就会发现自己其实比预想的要强大得多。其实类似的事情在生活中也是屡见不鲜的。比如报纸上会登载一条新闻说，某人因矿难而被深埋在地下半月之久，却能够依靠强大的求生意志而存活下来。或者说一个人从高空坠落，因为掌握好了身体的平衡感而幸免于死。相信你一定读到过这些新闻，不过你通常是把它们当作茶余饭后的街头怪谈，却没有冷静下来仔细想想其中的一些奥妙。这是关于生命的奥妙**。 \n  “**当我还是瑜伽师拉曼的学生时，他向我解释了这个基本原理：“生命中唯一的极限是你自己给自己设下的。’当你勇于从惰性的圈子中跳出来，打破陈规，向未知领域探索，你就开始释放本性中的潜能了。这是走向自我控制的第一步。当你把自己的极限推得更远，就像你在这次小小的示例中做的这样，你就会不断地开发出心智和体力的潜能，那是你从来不曾想、也不敢想的东西。而事实上，你原本有足够的能力去获得它。**” \n  \n“太棒了。”我心想。突然，我记起了在最近看过的一本书里说，普通人的个人才能只有很微小的部分得到了利用，如果每个人都把自己沉睡的才能唤醒，那每个人都将是天才。“我很想知道，如果我们学会运用能力中其余那些沉睡的部分，我们又能做出什么呢？” \n这个问题让朱利安有些为难。他挠了挠头，想了一下，然后回答道：“你刚才实践了‘禅悟’的技巧，相信我，这种技巧每天都可以使你进步。也许以下这些方面是你近期要努力的事情。 \n“**努力提高自己的心智，改善身体的健康状况，让自己能够随时做到聚精会神。做那些让你感到恐惧的事情，这样就可以消除心魔，开始拥有无限的精力和无边的热忱**。 \n“**你还要学会融入大自然，认真观察日出时的动人情景，也可以试着在雨中自由舞蹈。** \n“**你要坚守自己的目标，每天都朝这个方向行进，这样才能真正成为你梦想成为的那种人。 **\n\n“**不要害怕出错，要鼓足勇气做你一直想做的事情，而不是自欺欺人地找借口拖延，嫌自己太年轻或者太年老，太贫穷或者太富裕。** \n“**准备好过一种目标远大，精神活跃的生活。在东方，人们常常会说，机会总是留给有准备的人。而我则深信，生活也偏爱有准备的人。**” \n**朱利安继续他热情洋溢的谈话，好像是一所大学课堂上的哲学老师。“认真分析生活中那些阻碍你的因素，然后想方设法去克服它。从多方面好好反省自己，比如你是不是害怕演讲，或者在人际关系上有麻烦？你是不是缺乏积极的人生态度，或者需要更多的精力？接着列出一份详细的目录，将自己的弱点一一登记在案，然后有的放矢地改正它们。在工作中容易得到满足感的人们往往比不思进取的人更加深思熟虑。把时间花在寻根究底上，就可以让你明白自己和所希望的生活之间的差距究竟有多远，还要对眼下的生活状态了若指掌。” \n“一旦你看到了自己的弱点所在，那下一步的工作就是要直接面对它们，向自己的恐惧心理开战。中国有句俗话叫作‘怕处有鬼’，人们通常会被自己臆想出来的怪物吓傻了。恐惧只不过是你自己在头脑中制造出来的怪物，是一连串的负面意识。所以，要克服自己的心理痼疾。如果你惧怕当众演讲，就专门签约进行20场演讲，哪怕你要为此支付主办方一定的费用。如果你固守陈规，害怕开展新业务，或者想逃避不愉快的人际关系，那就专门给自己制造这方面的挑战环节。只要你迈出第一步，后面的路就好走了。当你像一只蝴蝶从蛹中破茧而出的时候，那将是你在这么多年以来第一次尝到真正的自由的滋味。\n\n恐惧是一种条件反射，如果你不留神的话，它很快就会把生命力、创造力和精神都消耗殆尽。一旦恐惧满怀恶意地探出它丑陋的脑袋，你就应该一下子把它击垮。最有效的办法就是去做让自己感到害怕的事情，借此完全了解恐惧的内在结构。当你进入了恐惧的内部，就会发现它不过是源于你自己的胡思乱想。就像任何其他人创造出来的东西一样，把它揭穿就像把它创造出来一样简单。你可以学着有系统、有方法地查明底细，看清楚蛰伏在你心智深处的每一种恐惧到底都是什么，而后再一一击破。长此以往就会带来无限的信心、幸福和内心的安宁。**” \n\n**“真的有人拥有无所畏惧的心灵吗？”我问他。\n“问得好。我将毫不犹豫地断然回答：‘是的！’喜马拉雅山上的智者个个都毫无畏惧。你可以从他们走路的样子上看出这一点，可以从他们的谈吐内容上听出来这一点，也可以在深深凝视他们双眼时发现这一点。其实生活中有很多这样的例子，电影《勇敢的心》你看过吧？” \n朱利安顿了顿，接着凑近我说：“我再给你说点别的，约翰。” \n“什么啊？”我问他，心中对他刚才讲到的事情充满了好奇。 \n“**我也曾一度胆小如鼠。对此我心知肚明，因此就打算进行一次自我清理，找到天生的意志力和无限的潜能。后来我找到了胆小的根源，正是因为这么多年来一直忽略自我以及思想发展的不平衡阻碍了我的发展。我再告诉你一件事。当你把恐惧从头脑中彻底驱逐出去之后，你就会变得更年轻，也变得更有活力。**” \n\n“啊哈，**古老的身心联系**。\n\n\n## 迎着弱点和恐惧直面而上\n另外一条非常有效的法则，我也时常会想到它。我觉得，当你走在引导自我和控制自我的道路上时，这条法则对你而言将是无价之宝。每当我想要投机取巧的时候，它就会批评我，给我以上进心。这一人生哲学可以简单地归纳为：行事高效的人和死气沉沉的人之间的最大区别在于，前者会去做后者不喜欢做的事——尽管他们可能也不愿意去做。** \n“**真正开悟的人，每天都可以体味到深沉的幸福感，随时准备着为了长久的满足而放弃短暂的快乐。他们就这样迎着弱点和恐惧直面而上，即便有时因为深陷未知的领域而感到极大的不自在也无所谓。他们下定决心，要依靠‘禅悟’的智慧来生活，永不间断地提高人生的各个层面。过去曾阻碍他们获得快乐、健康和富有的恐惧也会败下阵来。\n## 幸福要通过对一个有价值目标的渐进实现才能得到\n我最喜欢的教授给我讲过的一个古老故事。 \n有一天晚上，一位父亲在办公室工作了一整天以后开始拿着报纸看，想享一会儿清闲。可他的儿子很想玩，就一直缠着爸爸。最后，这位父亲被搞得不耐烦了，气呼呼地扯下一张地球画报，撕成了一大把小小碎片。“来吧，儿子，过来把它们重新拼在一起。”他说着，希望这一招可以让孩子忙上好一阵子，以便自己可以从容地看完手中的报纸。 \n让他大吃一惊的是，还不到一分钟，他的儿子就兴冲冲地带着一张拼贴无误的图片回来了。当这位目瞪口呆的父亲问儿子是怎样完成这个拼地图的壮举时，儿子笑得甜甜的，轻松地回答说：“爸爸，在这张地球图片的反面是一个人的图片，只要我把这个人拼在一起了，世界地图也就完整了。” \n“真是棒极了。”我不由得赞叹起来。 \n“你看，约翰，从喜马拉雅山上的智者到哈佛法学院的教授，在我认识的最有智慧的人当中，似乎每个人都洞悉了幸福公式的要领。\n\n幸福要通过对一个有价值目标的渐进实现才能得到。当你在做自己全心全意热爱着的事情时，就一定会感到深深的满足。\n\n## 做你喜欢的事情，需要很大\n\n我不妨再说得明确点，约翰。做你喜欢的事情，需要很大的勇气。它意味着你为了当演员要放弃手边正在做的工作，在不那么重要的事情上少花些时间，留下时间给更有意义的事情。它要求你离开习以为常的规律，也就是抛弃惰性，勇于创新。这种变化在最初的时候总会有些让人难以适应，而且具有一定的风险。但请一定记住我前面反复说的话，这正是走向快乐人生的起点。\n\n一个人究竟应该怎样鼓起勇气呢？\n这也像刚才故事里所说的：只要你可以控制自己，你的世界就没问题了。只要你能控制自己的心智、身体和品质，幸福和富裕就奇迹般地来到你的生命中。但是，你每天都要在自我完善上花一些时间，哪怕只有10到15分钟。\n\n# 相扑选手，注意‘禅悟’的提示者\n这位肌肉发达的大块头就是不断提醒我们注意‘禅悟’的提示者。这个词在日语中的意思就是持续的自我发展和进步。\n\n我已经明白了自己的心智其实是那么神奇，宝贵的潜能又将创造怎样的奇迹。我已经学会了非常高效的技巧，可以把能量集中到我的愿望和梦想上。我已经知道在生命中树立明确目标的重要性，要在我人生、职业和精神世界的每一个方面都设立非常清楚的目标。现在我已经完全接受了那个自我掌控的古老法则：“禅悟”\n\n\n## 活力生活的十个招数\n### 孤独的习惯\n第一个办法被智者称作‘孤独的习惯’。所要求的无非是你在每天的日程表上划出来一段时间，这段时间用来保持自我的宁静，哪怕是一段强制性的自我宁静。\n\n这段时间少则15分钟，多则50分钟。在此期间你要感受沉默的力量，要渐渐领悟到你究竟是谁。\n\n把‘孤独的习惯’想成是灵魂长途跋涉中的短暂休息。它的目的就在于获得自我更新的机会，通过独自一人沉浸在美丽的沉默当中来实现。” \n\n“沉默有什么特别之处吗？**” \n“问得好。**沉默和宁静把你和内部世界的创造力源泉联结在一起，解放所有智力的束缚。你看，约翰，心智好比一汪湖水。在我们这个嘈杂的世界上，大部分人的头脑里都安静不下来，因为我们的内心充满混乱。然而，只要你肯每天花一点时间来静心沉默，心智也就会变得平静如镜。内在的安宁会带来丰厚的回报，包括健康舒适的感觉，内在心态的平和以及无穷的精力。你甚至会睡得更香，而且在日复一日的劳作中享受到自我更新的平衡感。\n\n“我应该到哪里去寻找这一刻的安静呢？” \n“从理论上说，你可以在任何地方，无论是在卧室还是在办公室。关键是要找到一个真正安静的地方——而且环境要很优美。” \n“为什么必须是优美的环境呢？” \n“**优美的环境能够慰藉不安的灵魂，”朱利安解释说，深深地叹了一口气，“一束玫瑰，或者仅仅是一支孤零零的水仙，都会很好地改善你的情绪，让你得到非常有益的放松。说得更理想化一点，你应该在“个人避难所”中尽情享受这样的优美。我突然想到了一句东方禅语：菩提本无树，明镜亦非台，本来无一物，何处惹尘埃。**” \n“什么，什么？” \n“**简单说来，就是你为了自己的心智得到扩展，为了提升自己的精神境界，要学会把一个地方变成密室。这可能是你家中的空余房间，或者仅仅是一间小公寓中的安静角落。问题是你要给自己的更新行动保留一个相对固定的空间，一个静静地等待你到来的地方。**” \n“我喜欢这种说法。我想如果我在下班回家以后有了一个安静的地方可去，就会大大改变一切。我可以在那儿先待上一会儿，缓冲一下，消除一天当中的压力。这可能让我对周围的人更加有耐心。” \n“**这就涉及另外一个重要的问题。如果你每天都在同一时间来练习孤独静处的习惯，效果才会是最好的。**” \n“为什么？” \n“**因为它会作为一个习惯进入你的日常生活，成为一个有机组成的部分。如果在每天的同一时刻都来练习它，每日按时到来的静默很快就成为不容忽略的习惯。而积极的人生习惯将最终引导你到达目标。**” \n“还有别的吗？” \n“是的。**如果有可能的话，每天都和大自然谈谈心。在树林里做个短短的散步，或者哪怕是到后院，在你的西红柿苗圃里花上几分钟去浇水施肥，都会把你和安静的源泉重新连在一起。或许现在想一想这些事情就能让你的内心恢复平静。和大自然在一起，会激发你自身无穷的智慧。这种自我认知可以在自我潜力的方向上持之以恒地推动你的进步。别忘了这一点。**”朱利安建议道。他的声音因为充满热情而慢慢提高，无论如何也听不出来是一夜未眠的人。 \n“这一招对你有效吗，朱利安？” \n“绝对有效。在阳光尚未跃出地平线的时候，我就早早起床，做的第一件事就是走到我的‘个人避难所’。那是我在练习‘玫瑰之心’时发现的，后来一直秘密地使用着。有时候我静默地沉思冥想几个小时。有的时候也许只需花费10分钟。结果大致相似：我获得了一种内在和谐的深刻感受，以及无限的身体精力。\n\n### 体格锻炼的习惯\n“关于**如何养护身体。**” \n“什么？” \n“很简单。**体格锻炼的习惯是基于一个基本原理：你只有通过养护身体才能进而养护心智。给身体做好充分地准备，才会给心智做好相应的准备。训练好了身体，才会训练好心智。你没有听东方的哲学家常常说什么‘天将降大任于斯人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为，所以动心忍性，曾益其所不能。’抽出一个整天，通过健身训练来滋养盛放心灵的殿堂。让身体活起来，让血液沸腾起来。你知道吗？一周有168个小时呢。**” \n“不，知道得不那么确切。” \n“这是真的。其中至少有5个小时应该投入在某种方式的身体活动上。喜马拉雅山上的智者一直从事着一种古老的瑜伽训练，借此来唤醒身体内的潜能。天长日久，他们变得强壮有力，生机勃勃。这些身体超群的人很特别，**他们常常在村子中央倒立，以此来保持年轻。**” \n\n“那些智者还做过别的什么来养护身体吗？” \n“**瑜伽师拉曼和他的兄弟姐妹们都相信，精力充沛地在自然的环境中散步，不管是在高高的山路上，还是在茂密的森林深处，这些都将有助于缓解疲劳，修复身体内部的细微差错，以及恢复人体活力。要是天气太差，没法散步，他们就会在小屋中的密室里锻炼。他们可能会忘记吃一顿饭，但是决不可能忘记每天的练习。**” “他们的茅屋中有什么东西？跑步机吗？”我开玩笑说。 \n“当然不是。他们有时候练习瑜伽。有时候他们会做双手或者单手直立的俯卧撑。开始我还很好奇，后来我渐渐意识到他们做什么其实并不重要。他们虽然姿势不同，但目的却是一致的，那就是充分活动身体，让四周的新鲜空气在肺部畅通地流淌，也让血脉贯通起来。” \n“呼吸新鲜空气会有什么用呢？” \n“我要借用瑜伽师拉曼最爱说的一句话来回答你：**“适当的呼吸就等于适当的生活。**’” \n“呼吸有这么重要吗？”我奇怪地问道。 \n“当我到那儿之后，智者很快就教会了我如何使自己获得两倍甚至三倍精力的捷径，我也因此学会了进行有效的呼吸方法。” \n“可是难道我们不懂得呼吸吗？这连新生的婴儿都会呀！” \n“不完全是这样，约翰。**我们中的大部分人都只是知道怎么呼吸才可以活下去，却不知道怎样通过呼吸来让自己更有活力。这是完全不同的两个层面的问题，前一个是生存问题，后一个是生活问题。大部分人的呼吸都太浅了，这样我们就不能吸入足够的氧气，导致我们的身体不能处在最佳的状态。**” \n“听上去，正确的呼吸还包含着很多科学知识呢。” \n“确实如此。那些智者是这样对待呼吸的：**通过有效的呼吸吸入更多的氧气，释放体内储藏的精力，从而达到活力收放自如的自然状态。**” \n“好啊，那么我应该从哪里开始呢？” \n“**事实上非常简单。每天两到三次，花一二分钟来深呼吸，使空气能够深深地渗透到你身体内的每一个细胞。**” \n“*我怎么才知道自己的呼吸变得有效了？*” \n“**嗯，当你使用正确呼吸方法的时候，你的腹部会稍稍鼓出来一点。这个迹象说明你开始从腹部呼吸了，这就很好。现在试试看……嗯，挺不错。瑜伽师拉曼教我的一个方法是，把双手扣在肚子上感受起伏。如果我吸气的时候肚子鼓起来了，我的呼吸技巧就算是达标了。**” \n### 生命滋养法\n那就是‘生命滋养法’。在我做律师的那些日子里，我每天的食谱都是固定的，主要是牛排、油炸食品还有其他形形色色的垃圾食品。虽然我总是在城里最好的餐馆吃饭，可还是感到身体里面塞满了垃圾。那时候我并不特别清楚，这就是让我感到不愉快的主要原因之一。**”\n“真的吗？” \n“是的。一份糟糕的食谱对你的生命有着显著的影响。它抽干你的脑力和体力，它影响你的情绪，还会扰乱你的逻辑能力。瑜伽师拉曼是这样说的：“**你在滋养身体的同时，就是在养育心智。**’” \n“那么我猜你改变了食谱喽？” \n“**我已经彻底改变了自己的餐饮习惯，比如我从来不喝有色素与人工添加剂的饮料，也不再光顾快餐食品店。不久之后，控制饮食的效果就出现了，我的感觉和相貌发生了令人惊异的变化。以前我总是以为，我之所以那么死气沉沉主要是因为工作中的压力和疲劳，而且上了年纪以后身体渐渐不中用了。到了喜马拉雅山上，我才发现我的昏睡懒散其实是因为自己给身体内注入的动力燃料实在是太低劣了。**” \n“那些智者靠吃什么东西来保持青春和愉快呢？” \n“**吃新鲜的食物。**”他的回答很简明。 \n“啊？” \n“**答案就是新鲜的食物。它指的就是没有死去的东西。**” \n“说说呀，朱利安。哪些东西属于新鲜的食物？”我急躁地问他。 \n“**说得简单点，所谓的新鲜食物就是在自然当中吐故纳新的食物，是通过太阳、空气、土壤和水之间的相互作用中而产生的。我要告诉你的是一种蔬菜食谱。只要你能保证在盘子里堆满蔬菜、水果和谷物，然后就可能长命百岁。**” \n“真的有可能吗？” \n“生活在喜马拉雅山顶的大部分智者都已经有一百多岁了，而且看不出有任何衰老的迹象。就在上个星期，我在报纸上读到了一篇报道，大体说一群人生活在中国东海冲绳群岛中一个小岛上。研究者之所以关注这个小岛是因为被一个事实给震惊了：这个岛上聚居着世上最大的百岁老人群落。” \n“这些研究者发现了什么长寿诀窍没有？” \n“**结果是，素食是他们长寿的主要秘诀。**” \n“但是这种食谱健康吗？你知道素食可不一定能够提供足够的气力。请注意，我可还是个忙忙碌碌的律师，朱利安。我总不至于为了长寿而饿昏在庭审现场吧。” \n“不必担心，**这是一个充分自然的、人性化设计的食谱。它会让你有生气，有活力，而且极其健康。智者已经依靠这个食谱生活了数千年。他们称之为‘悦性食物’，也可以叫作‘纯净饮食’。**既然你最关心力量，那我想提醒你注意，地球上最强有力的动物，从大猩猩到大象，它们都是不折不扣的素食主义者。然而你知道吗？一头大猩猩的力量可比一个男人大30倍。” \n“真的不可思议啊。谢谢你告诉我这则趣闻。” \n“看，智者并不是走极端的人。**相反我们现代人却是常常执迷不悟。智者所有的智慧都建立在一条古老的法则上，那就是‘生活适度，做事中庸。’因此，如果你喜欢吃肉，当然还可以继续吃，智者也不会阻拦你。只是你要明白一点，你是在吞下已经死去了的东西。如果可以，尽量少吃红肉，因为红肉很难消化。你的消化系统在整个身体里面是消耗能量最多的部分，非常有价值的精力就这样被肉类食品毫无必要地消耗掉了。你有没有这样的体验，当你中午吃了一份牛排大餐之后，你很快会觉得自己的嘴巴里充满了不洁的味道，不断地打饱嗝儿。接下来，你就会觉得昏昏欲睡，整个人好像梦游一样？**” \n“确实如此。”我承认。每次午饭前我会因为饥饿而头昏脑胀，而饱餐一顿后我又会因为吃得太饱而昏昏沉沉。就这样，每天上午的十一点到下午两点都是我工作效率最低的时候。 \n朱利安同情地看了看我，我想他一定联想到我在午饭后睡眼蒙眬的丑态。他接着说：“**难道你没有发现我目前的变化吗？建议你给自己的能量标准做个对比，在吃完一份牛排和一盘色拉之后，你的感觉一样吗？如果你不希望一下子就变成一个地地道道的素食主义者，那么至少要在每顿饭里加一道色拉，用水果代替甜点。即便这一点微小的改变也会为你的生活质量带来巨大的改变。**\n### 扩展知识法\n第四招被称作‘扩展知识法’。**它是一个**关于终身学习，为了给自己和周围的人造福的理念。**” \n“听起来好像那句老话‘知识就是力量’，是不是？” \n“它的内涵更加丰富，约翰。知识不仅仅是潜在的力量。因为力量是显而易见的，而你必须进入实践的层面。大部分人在特定的情况下，或者在生活遇到困难时，都明白应该怎么去做。问题在于他们不是天天都这样，没有在使用知识和实现梦想方面持续地加以努力。扩展知识法的宗旨就是成为生活虔诚的学生。而更为主要的是，它要求你把教室里学到的知识顺利地应用到现实生活中去。\n\n\n“瑜伽师拉曼和其他智者是怎样应用这个方法的？” \n“在日常使用中，他们有很多辅助的方法可以和‘扩展知识法’配套使用。最重要的一个技巧也是最简单的。今天你就可以开始试一试。” \n“不会花很多时间吧？” \n朱利安颔首微笑。“我和你分享的这些策略、方法和小技巧都会使你变得比以前更加能干，更加高效。不要捡了芝麻，丢了西瓜。想一想那些说自己太忙，顾不得在电脑上备份文件的人吧。一旦他们的机器出了意外，几个月以来的重要工作都将毁于一旦，他们就会捶胸顿足，遗憾自己为什么没有每天花一点点时间去保存文件。你明白我的意思了吗？” \n“就是说**要先弄明白生命中的主次关系，不要本末倒置？**” \n“**完全正确。努力使你的生活挣脱时间表的束缚。把精神集中到你的良知和内心告诉你要去做的事情上。当你开始探知自我，并且开始把自己的时间花在提高心智、身体和个性的品质上，你很快就会感到自己的体内仿佛存在着一个领航员似的，他会随时告诉你哪些事情值得去做，而且会带来最丰厚、最有价值的回报。你将不再会为钟表上的时间感到焦虑，而是开始尽情享受生命内在的律动。**” \n“啊，我明白了。那么接下来你要教给我的**那个简单的辅助办法是什么？**” \n“**定期读书。每天读书30分钟会给你带来意想不到的结果。但是我必须提醒你，不要碰到什么就读什么。你一定要仔细拣选才行，因为它们将要进入你丰饶的心智花园。它一定得是非常有营养的物质，否则将会适得其反。它们要帮助你改善自我，而且还要提升你的生命品质。**” \n\n“那些智者平常喜欢读什么书呢？” \n“**他们在醒来以后，就会花很多时间去阅读古人留下来的教诲。他们对这些哲学著作如饥似渴。迄今我还记得那些非常俊美的人们坐在小竹椅上阅读外形奇怪、装帧精美的书，脸上和唇边都洋溢着淡淡的微笑。正是在那里我真正意识到了书本的力量，知道了‘书本是智慧最好的朋友’这个道理。” **\n“那么我应该开始阅读我能够找到的所有好书吗？” \n“可以说是，但又不是。\n”他这样模棱两可地回答我。“我从来都会支持你尽己所能地去读书。但是要记住，有些书只需要浅尝辄止，有些书却需要细细咀嚼，有一些需要辨证学习，而另一些则值得完全吸收。这让我想起另外一个问题。” \n“你是不是饿了？冰箱里还有些酸奶。” \n“不是，约翰，”朱利安笑了，“我只不过想要告诉你，**一定要善于从伟大的书籍中获得最为精华的部分。你必须要好好地研究它，而不仅仅限于阅读。深入全面地研究它，就像你研读你的重要委托人给你的案子那样。切实地考虑它，和它相互切磋，成为伙伴。智者在广泛的阅读中，会把很多书读上10到15遍。在他们眼中，伟大的书籍就像是神赐的圣书。**” \n“哎哟！读书真的这么重要啊？” \n“**每天坚持读书30分钟，会给你的生活带来可喜的变化。因为你很快就会发现，有那么广博的知识宝库供你选择使用。你会变得谈吐不凡，思维敏捷，文思泉涌。你曾经遇到的每一个问题的答案都会历历在册，信手拈来。如果你想要成为一名更为出色的律师、父亲或者恋人，都会有相应的书籍知识帮你快速达到目的，避免走弯路。你在人生中犯下的所有错误都已经被前人们尝试过，因此你也将会很快找到改正的方案。你是不是真的以为你所面对的挑战都是独一无二的？**” \n“老实说，我从来没有这样想过，朱利安。但是我理解你所说的，而且我知道你是对的。” \n“**任何一个人遇到过的任何问题，在他的生命之前都已经被前人遭遇过了，而且不止一次，”朱利安断言道，“更重要的是，答案和解决办法都已经在书页上记下来了，就看你会不会发现它。养成正确阅读的习惯，学习前辈的珍贵经验，他们成功的策略会帮助你从容面对生命中遭遇的种种挑战。你会为发生在人生中的点滴进步而感到惊奇的。**” \n“什么样的书才是‘正确的好书’？”我追问着，很快就体会到朱利安的意见确实很不错。 \n“这个要留给你自己来判断，我的朋友。就我个人而言，自打我从东方回来以后，就把一天中最好的时光花在了阅读上。当然，每个人兴趣不同，我最感兴趣的是那些我所钦佩的男男女女的人物传记和大量的智慧之作。” \n“你能不能为我这个还算得上勤奋工作的人列出一些有用的推荐篇目呢？”我一边说，一边难为情地笑了一下。 \n“没问题。**比如你可以从伟大的本杰明・富兰克林的传记中获益颇多。我觉得你还可以从圣雄甘地的传记中发现很多成长的动力，那本书的名字叫作《甘地自传》。我还建议你读读赫尔曼・黑塞[7] 写的《悉达多》，还有马可・奥勒留[8] 写的实践性很强的书，以及塞涅卡[9] 的一些著作。你甚至还可以读一读拿破仑・希尔的《思考致富》。上个星期我认真地读了这本书，觉得真是回味深远。**” \n\n\n\n书只是帮助你发现早已存在于自身之内的东西。这是一种唤醒，一种提示。这就是启蒙，如一束光照亮你的人生。我在经过了那么多的旅行和探险之后，最终发现我其实是走完了一个循环，回到了我还是孩子时的出发点。但是现在，我非常了解自己，知道我是谁，我也知道自己最终会成为怎样的人。**” \n “所以说‘知识扩展法’就是大量读书，探索外界的丰富知识？” \n “你只说对了一部分。因为在眼下一天只读30分钟书，你的理解也仅此而已。随着你对书籍的爱好与日俱增，其他意想不到的东西自然也会到来。”朱利安的话里暗含着玄机。\n\n### 个人反思法\n它的名字是‘个人反思法’。那些智者都坚信内在沉思的力量。通过一定时间的沉思来了解自我，就可能步入生命的另一个维度，这也许是你从来都不知道自己还具有的更高维度。\n\n其实说到根本上，个人反思不过是一种思考的习惯。\n\n对，是富兰克林。每天晚上在完成了一天的高效率工作之后，他一回到家里就会躲在一个安静的角落里，反思这一天的行为处世。他会反思他的全部行为，看其中哪些属于积极而富有建设性的，哪些属于消极而需要及时修正的。当他清楚地知道白天里犯下了什么错误时，他就会迅速采取措施进行改进，沿着自我控制的道路前进。等到以后再遇到类似的情况，他就会心知肚明，游刃有余。智者也是这样做的。每天晚上，他们都会躲进小棚屋里的清净角落，那里铺满了芳香的玫瑰花瓣，他们坐下来陷入深深的沉思。瑜伽师拉曼还会把他的一天经历写在日记里。\n\n“他写下来的都是些什么事？”我好奇地问。 \n “**首先他会列出当天所有做过的事情，从早晨的身体锻炼，到他和其他智者之间的交流，再到他到森林里去找木柴和新鲜食物的经历。很有趣的是，他还会写下来在这一天里曾经在头脑中出现过的各种念头。**” \n “这样做岂不是难了点儿？我根本记不起来5分钟以前自己曾经想过什么，更不要说12个小时以前的想法了。” \n “如果你每天都坚持做同样的练习就不会觉得难了。任何一个人都可以获得在我身上发生的改变，任何人。真正的问题是，有太多的人都饱受令人讨厌的疾病的折磨，这种疾病叫‘借口’。” \n “我想我可能也染上了这种疾病。”我完全明白我聪明的朋友在说什么。 \n “别再找借口了，只管去做就好了！”朱利安提高声音说道，他的语调中充满了坚定的力量。 \n “做什么？” \n “**花时间去认真思考，并在生活中养成定期进行自我反省的良好习惯。有时候瑜伽师拉曼会将笔记纸的一页从中对折一下，把当天所有做过的事情、想到过的念头都写在一栏里，然后在另外一栏里作出相应的评价。当他面对书面记录下的行为和想法时，他会扪心自问，它们在本质上究竟是不是积极的。如果是积极的，他就决定继续为此付出宝贵的精力，因为从长远来看，它们会给他带来巨大的收益。**” \n\n我认为现在你已经发现了‘个人反思法’的神奇力量。通过审视自己做过的事情，仔细反省自己是如何度过一天的。你要注意归纳自己在一天内一共出现了几种想法，这样一来你就给自己提供一个进步的标准。要在明天实现进步的唯一途径就是知道今天做了哪些错事，并且知道如何来加以改进。\n\n只有人类才会走出自我的阴影，并且能够分析他所做的事情中哪些是正确的，哪些是错误的。一条狗做不到这一点，一只鸟也不会这么做，就连聪明的猴子也不可能。但是你可以。这就是‘自我反思法’的根本宗旨，在每天的生活和整个人生当中，辨明什么是正确的，什么是错误的，然后尽快着手完善自己。\n\n\n### 早早醒来法\n“**我在遥远的喜马拉雅山上得到的最有用的一个建议就是，和太阳一起起床，然后成功地开始新的一天。我们大部分人的睡眠时间都比实际的需求要多得多。其实普通人睡六个小时就可以起床了——这已经足够他保持健康和思维的机敏了。睡眠无非一种习惯，像其他习惯一样，你可以训练自己达到你所希望的成果。试一试，能不能在这一个环节中睡得少一些。**” \n “可是，如果我起床太早了的话，我真的会感到精疲力竭。”我说。 \n “在刚开始的几天里，你可能会感到疲倦。我也曾有同感。你甚至有可能在练习早些起床的第一个星期里一直有这样的疲劳感。不过，请把这看成是为了得到长期的巨大收益而付出的短暂的、少量的痛苦。在你确立一个新习惯的时候当然会多多少少感到有些不舒服。这就像你穿上了一双新鞋子——刚开始穿上的时候觉得有点疼，很快就很惬意了。正像我此前告诉你的那样，痛苦往往是个人成长的前奏。别害怕起早。相反，接受它。” \n “好吧，我喜欢这个训练自己早点起床的观念。可是先得让我问问你，**‘早’起意味着几点钟起？**” \n “又是一个好问题。这跟时间没有关系。就像我到现在为止和你分享的各种方法一样，都是要你按照认为正确的标准去做。记住瑜伽师拉曼的警告：“凡事不可过分，处处都要适度。’” \n “日出时起床，这听起来已经很过分啦。” \n “实际上并不过分。几乎没有什么比一天当中新射出的第一缕阳光更加光辉灿烂的了。智者坚信，阳光是来自上苍的礼物。尽管他们都很小心，不过多地暴露在阳光下，但是他们会定期做日光浴，还经常在阳光明媚的清晨顽皮地舞蹈。我完全相信这是他们保持长寿的另一个秘诀。” \n “你也做日光浴吗？”我问。 \n “当然做。阳光使我恢复活力。当我感到劳累时，阳光会让我高兴起来。在东方古老的文化里，太阳被认为与灵魂相连。人们崇拜太阳，因为太阳让庄稼和他们的精神一起丰收。阳光可以释放你的生命力，恢复情感和身体上的活力。它是一位令人心情愉快的医生，不过前提是你适当地接触它。唉，我又跑题了。我们讨论的是早点起床，每天坚持。” \n “哈哈。我怎么才能把这个习惯纳入日常的生活？” \n “**这里有两个简便易行的小诀窍。首先，千万别忘了，重要的是睡眠的质量而非睡眠的数量。在不受干扰的情况下沉沉地睡上六个小时要比时常被打断的十个小时睡眠好得多。睡眠的目的在于让你的身体得到休息，这个自然的生理过程可以修复、重建你的身体，减少日常消耗带来的压力和挣扎，使你的身体恢复自然的状态。很多智者的习惯都基于这一原则。举个例子来看，瑜伽师拉曼在晚上八点以后就再也不吃东西了。他说消化活动及其附带的生理活动会降低他的睡眠质量。智者还有另一个习惯，睡觉之前他们会在轻柔的竖琴乐声中冥想。**” \n “这种行为的原因是什么？” \n “让我来问问你，约翰。每天晚上睡觉之前你会做些什么？” \n “我和詹妮一起看新闻节目，我知道这和大部分人做的事情一样。” “我就知道。”朱利安回答，眼睛中有奇异的闪光。 \n “我不明白。在睡觉以前看上一点新闻有什么错的？” \n “**你睡觉之前的10分钟，还有醒来之前的10分钟，都会在你的潜意识里留下长久的影响。在这两个时间段，你应该只向你的头脑输入最愉悦、最安静的想法。**” \n “瞧你说的，人的头脑听起来就跟电脑似的。” \n “**这么来看待头脑也不失为一种好办法——你输入的东西就是将要产出的东西。更加重要的事实是，程序员只有你一个人。通过决定让哪些念头进入头脑，你也就可以明确地知道哪些念头将会产生出来。所以在你去睡觉之前，不要看什么新闻，不要和任何人争吵，也不要在脑海中回顾一天的所作所为。放松，如果你喜欢的话，慢慢地喝一杯花茶，听一点轻柔的古典音乐，做好准备，让自己渐渐滑入甜美的熟睡中。**” \n “有道理。睡得越好，睡得越少。” \n “确实如此。**一定要记住古老的21天法则：如果你连续21天做一件事情，它就会确定成为你的习惯。所以，在你因为感到不舒服而放弃早起的行为前，你要坚持三个星期。**到了那时，早起就成为了你生活的一部分。在很短的时期内，你就能够轻轻松松地在早晨五点半，甚至是五点钟起床，准备好领略新一天到来时的壮丽场景了。”\n  “好吧，那么如果说，我现在每天都是五点半起床的话，我又该做些什么呢？” \n  “**从你问的问题就可以看出你确实是在思考，我的朋友。对此我很欣赏。起床之后，你可以做很多事情。要在头脑里面时刻记住的基本原则是，好好开始新的一天是非常重要的。就像我曾建议过的，在你醒来以后的十分钟内，最先进入到脑海里的念头和最先着手的行为，往往会在接下来的一天中产生非常明显的效果。**” \n  “此话当真？” \n  “当然。**去想那些积极的念头；对你所拥有的一切做感恩祈祷；感谢你要感谢的人；倾听一些伟大的音乐；看太阳升起。兴之所至的时候，你还可以去自然环境中散步。实际上，智者还常常让自己开怀大笑，不管是不是有高兴事，这不过是为了让快乐在清晨便开始流动。**” \n  “朱利安，我尽力使自己的头脑能够接受你的讲解——而且我想你也会承认，作为一个初学者我做得已经很不错了。可是，就算是对一群生活在喜马拉雅山高峰上的高僧来说，那样的事情听起来也真的太奇怪了。” \n  “其实不足为奇。你猜一猜，一般来说，一个四岁的孩子一天要大笑几次？” \n  “谁知道呢！” \n  “我知道，一共三百次。嗨，你不要做出这么惊讶的表情。现在再猜猜看，在我们的社会中一个成年人在一天之内会大笑几次？” \n  “五十次？”我猜测着。 \n  “勉勉强强十五次，”朱利安回答道，微笑中充满胜利感。“你明白我的意思了吧？**大笑是灵魂的良药。如果你能对着镜子开怀大笑几分钟，即使你并不喜欢这样做，你也会忍不住感到很奇妙。威廉・詹姆斯说过：‘我们不是因为快乐才笑，而是因为笑才感到快乐。’所以，让你的一天从快乐开始。大笑，玩耍，为你拥有的一切感恩。由此，每一天都会变得极其有意义。**” \n  “那么你是如何积极地开始自己的一天呢？” \n  “说实话，我已经养成了一套非常系统的晨练方式，包括所有的内容，从练习‘玫瑰之心’到喝几杯鲜榨水果汁。但是有一个方法我特别要和你一起分享。” \n  “听起来很重要嘛。” \n  “是很重要。**你在刚醒来以后，就到你那个‘个人避难所’去，静下心来，集中精神，然后问自己这个问题：“如果今天就是生命里的最后一天，我将做些什么？’答案就在于准确理解这个问题的含义。在头脑里列出来所有你想做的事情，你想打电话的人们，以及你想享受的时刻。想象你自己正在兴致高昂地完成这些事情。想象自己对待家庭、朋友和完全陌生的人的样子。如果今天就是你活在这个星球上的最后一日，想象自己该怎样度过这珍贵的一天。正如我早先告诉你的，当你在度过每一天时都像对待生命的最后一天那样，你的生活将会焕发出奇异的色彩。** \n### 音乐法\n智者很热爱他们的音乐。音乐就像太阳一样给予他们同样的精神鼓舞。音乐让他们开怀大笑，让他们闻之起舞，应和歌唱。它对你也会起到同样的作用。千万别忘了音乐的力量。每天在音乐上花一点时间，哪怕只是在你驱车上班的路上听几首轻音乐也好。当你觉得消沉或者疲倦，演奏一会儿音乐吧。这是我所知道的最有效的动力之一。\n### 口语练习法\n**第八招的名字叫‘口语练习法’。智者有成套的‘真言’供他们在早、中、晚念诵。他们对我说这个练习非常有效果，可以帮助他们保持专注，变得更强壮和幸福。 **” \n  “‘真言’是什么？”我问。 \n  “**真言就是一连串能够产生积极影响的话语。在梵语里面，‘man’的意思是心智，‘tra’的意思是解脱束缚。因此真言‘mantra’这个词语指的就是对心智有计划的解放。而且请你相信我，约翰，真言是达到这一目的的非常有效的方法。**” \n  “那么你在日常生活中也练习说真言吗？” \n  “我当然也是这样。无论我走到什么地方，它们都是我最忠实的同伴。不管我是坐在长途巴士上，在走去图书馆的路上，还是穿过一个公园观察着周遭的世界，我总是通过诵读真言来肯定我生命中所有美好的东西。” \n  “所以真言是口头的？” \n  \n  “**也不一定非要说出来。写出来的形式也一样很有效。但是我发现，大声背诵真言会对我的精神起到奇妙的效果。当我觉得需要动力支持时，就会重复说‘我有创造力，有自制力，有精力’这句真言二百到三百次。如果要保持高度的自信，我就会重复说，‘我很强壮，很能干，很镇静。’我甚至还使用这些真言来保持我的青春和活力。**”朱利安坦言道。 \n  “一句真言又怎么能够让你保持年轻呢？” \n  “**语言会长久地作用于心智。这是一种古老的心理暗示法，并且屡试不爽。无论是写下来还是说出来，它们都会产生强有力的影响。你对别人说什么很重要，但更重要的是你对自己说什么。**” \n  “自言自语吗？” \n  “对呀，**你每天怎样想的，你就是什么样的。你每天对自己说什么，就会变成什么样子。如果你说你又衰老、又劳累，这句话就会在你的外在世界中显形。如果你说自己很虚弱，缺乏热情，这也会成为你现实中的特点。但是，假如你说你很健康，很活跃，充满活力，那么你的生活将得到改变。想想那些身患绝症却依然乐观向上的人们吧，他们就是通过有效的心理暗示为自己争得了珍贵的生命时光。**” \n  朱利安略微休息了一下，然后接着说：“**你看，你对自己说出的话语影响到你的自我形象的想象，而你的自我想象又将决定你会采取什么样的行动。举个例子说，如果你想象的自我形象是一个没有信心去做任何有价值的事情的人，你所能采取的就不过是与这个特点相似的行动。如果你想象自己是一个充满活力，无所畏惧的人，同样，你所有的行为都会和这一品质相适应。在某种程度上，你的自我形象想象就是对于自我的长久预言。**” \n  “怎么会是这样呢？” \n  “**如果你相信自己做不到什么事情，比如说，无法找到一个完美的伴侣或者无法过上没有压力的生活，你的信念就会影响你的自我想象。反过来，你的自我想象也会阻止你采取行动去找到一个完美的伴侣或是为自己创造出一种平静的生活。事实上，它会妨碍你在这个方向上作出的任何努力。**” \n  “为什么会这样呢？” \n  “**很简单。你的自我想象其实是某种心理控制。它绝不会允许你在与它不相一致的方式上行事。但是好在你可以改变自我想象，就像你改变人生中其他的方面一样。真言就是完成这一目标的有效方式。**” \n  “而且啊，当我改变内在世界的时候，也就改变了外在世界。”我发自内心地说。 \n\n### 个性调试法\n**活力人生的第九招。这个方法是‘个性调试法’。它是我们刚才讨论的自我想象概念的分支。简而言之，这个方法是要求你每天循序渐进地塑造自己的性格。这一过程将影响到你对自我的看法和所采取的行动。你所进行的行为会集中起来，渐渐形成你自己的固定习惯，而你的习惯将会决定你的命运。瑜伽师拉曼对此说得很明了：‘你种下一粒思想，就收获一个行动；种下一个行动，就收获一种习惯；种下一种习惯，就收获一种性格；种下一种性格，就收获了整个命运。**’” \n  “我应该做些什么事情来塑造自己的性格呢？” \n  “你可以做任何可以培养美德的事情。在你问我何谓‘美德’之前，先让我澄清一下这个概念。**喜马拉雅山的智者相信，有德行的人生才是意义丰富的人生。所以他们用一系列的古老原则来支配自己的行动。**” \n  “但是我记得你曾经说过，**他们是用自己的目标来支配人生？**” \n  “是的，基本上差不多，但是他们的生活愿望在某种意义上还与这些原则相协调，那是他们的祖先在几千年前就已经深深植入他们心灵的。” \n  “那些原则是什么，朱利安？”我问。 \n  “**简单地说就是：勤劳、慈爱、谦逊、耐心、诚实和勇敢。如果你的行动和这些原则完全相符，你就会感到内在深深的和谐与安宁。依照这种原则来生活无疑会将引领你走上精神世界的成功。这是因为你所做的事情都是正确的。你将按照和自然法则以及宇宙法则相一致的方式来行事。你开始吸收另一个维度上的精力，或者称之为更高的力量。这同时也意味着你的生活将从庸常进入超凡境界，开始体味人生存在的神圣感。这也是毕生启蒙的第一步。**” \n  “你有过这样的经验吗？”我问。 \n  “有过，而且我相信你也会有的。做正确的事情。依照和你的真实性格相匹配的方式来行动。正直地行事。接受内心的指引。如此一来，其他的事情也会自然而然地好起来。约翰，你永远都不会孤独。”朱利安回答。 \n  “你这话是什么意思？” \n  “也许我下一次再解释给你听吧，眼下我们不能总是跑题。**你得记住，必须每天做一些小事来培养自己的品格。正如爱默生说的那样：‘品格高于才智。一个伟大的灵魂不仅善于思考，更善于生活。’如果你按照我刚才提到的那些方法来做事，你就会塑造出高尚的品格。如果你不这样做，真正的幸福就会弃你远去。**”\n  \n###   化简法\n这个方法要求你过一种简单的生活。就像瑜伽师拉曼所说的，‘一个人千万不要生活在肤浅事物中。集中精力于那些最重要的、有意义的事情。这样，你的生活将会清晰有条理，有价值而且格外安宁。这一点我可以向你保证。\n\n怎样养成化简的习惯？\n要学会做减法，我们的生活本来已经够复杂的了，不要总是给自己找不痛快。就像我吧，我不再穿昂贵的衣服，我戒掉了一天看六份报纸的瘾，我不再需要让自己随叫随到，我变成了一个素食主义者而且吃得比以前少。从根本上说，我削减了自己的需要。东方的智者曾经有过精辟的总结：‘有容乃大，无欲则刚’。这话多有用啊。你看，约翰，除非你削减自己的需要，否则你永远不会得到满足。你会一直像拉斯维加斯赌场中急红了眼的赌徒，守在轮盘赌转盘前面期待着‘再转一次’，不停地祷告，盼着你的幸运号码马上到来。你会一直想要得到比现在拥有的更多的东西。可事实怎么样，相信不用我再赘言了。\n\n如果我想把‘化简法’纳入自己的生活，我应该做哪些事情？\n\n “你能做的事情太多了。即使是小事情也能带来改变。” \n  “比如说？” \n  “**电话响起的时候不要每次都慌慌张张地去接听，或许是人家打错了电话；不要在阅读垃圾信件上浪费时间，因为你看后即忘；不再每星期在外面吃三次饭，那样你会变得大腹便便；放弃你的高尔夫会员资格，花更多的时间和孩子们待在一起；一周之内有一天不看手表，你要学会告诉自己：“少了我，地球照样转动’；每过几天就去看一次日出，感受大自然的神奇；把你的手机卖掉，不要成为别人随叫随到的奴役……还要我继续说下去吗？**”朱利安反问道。 \n\n\n我向你担保，通过练习这些策略和方法，你会从那一刻起，在一个月之内看到显著的提高。你在生活中的各个方面都将会有更多精力，更少烦恼，更多创造力，更小压力。我前面也已经说过了，智者的方法不是速成型的，肯定没有驱虫药的功效那么神奇。它们都是古老的修行传统，为了你今后生活的宁静，你需要天天练习。如果你停下来一段时间，就会发现自己又逐渐回到旧日的道路上去了。\n \n## 精神\n我向你解释的那些秘诀会让你在生活中创造出所希望的一切。但是那些智者的哲学视野要远远高于我们所能看到的地方。到目前为止我教给你的都是非常实用的知识。但是你一定要明白，在我列出的种种原则之下，其实还涌动着许多潜在的精神力量。也就是东方哲人所说的那句‘言有尽而意无穷’。如果你不理解我所说的这些话，不要太担心了。只要你肯听进去，再好好地想上一会儿，之后就会慢慢地理解和接受了。**” \n  “学生做好准备的时候，老师就会出现，是吗？” \n  “正是这样，”朱利安说，露出笑容，“你一直学得很快。” \n  “好吧，**让我们来听听精神的部分**，”我充满活力地说，根本没有注意现在已经快早上五点半了。 \n  “**想象一下，你现在正栖息于日月天空之下，生活在宇宙的所有奇妙之间。创造这些奇迹的智慧就与把你创造出来的那种力量完全相同。你身边的任何东西都是来自同一个地方，我们本是一体，万物皆为一体。” \n  “我不确定自己是否明白你的意思。” \n  “地球上每一种活着的生物，地球上每一件看似静止的事物其实都有自己的灵魂。所有的灵魂都汇成一个，那就是宇宙的灵魂。就像是一滴水融入大海，汇成海洋的波浪彭湃。同样，我们也能够从大海中感受到那一滴水的生命律动。你看，约翰，当你养护自己的心智和精神时，你的确也是在滋养宇宙的灵魂。而当你提高了自我，也就是在提高所有存在于你四周的生命。当你有勇气不断接近梦想的方向，你也就开始利用宇宙的力量。正如我此前已经告诉你的，生命回报给你所要求得到的任何东西。它一直在侧耳谛听。**” \n  “所以说自我控制和‘禅悟’都将通过帮助自己而对别人有所帮助？” \n  “可以这样说。当你丰富自己的心智头脑，养护自己的身体以及滋养自己的精神时，你都会逐渐确切地理解我所说的这些。” \n  “朱利安。我知道你讲得很好。但是自我控制对于一个体重97公斤重，在发展客户上花费的时间远远多于自我发展的时间的男人来说，无论如何都是过高的奢望啊。如果我失败了，会发生什么事？” \n  “**失败是不必费心去尝试的，没有什么大不了。横亘在人们和梦想之间的唯一事物就是对失败的恐惧，然而恐惧又是任何成功都不可缺少的。失败可以检验我们的毅力，让我们得到不断的成长。它给我们教训，并且引导我们走向启蒙的道路。东方的先哲曾经说过，每一支射中公牛眼睛的利箭，都是一百次失误的结果。这就是要求我们明白一个道理：从失去的机会中不断获益，不要害怕失败。失败是你的朋友。**”\n\n\n“让我拥抱失败吗？”我半信半疑地问。 \n  “**宇宙青睐勇敢者。一旦当你下定决心要把自己的人生提高到最高的层次上，你灵魂的力量就会指引你方向。瑜伽师拉曼相信，每一个人的命运在他出生的那一刻就已经铺展开了。这条道路将一直通向一个盛满瑰丽宝藏的奇妙所在。每个人都能够培养起走上这条道路的勇气，这是人的天赋。他给我讲过一个故事，在此我想转述给你听。**” \n  **以前，在古老的印度，有一个邪恶的巨人拥有一座可以远眺大海的辉煌城堡。在巨人去打仗的很多年里，附近村子里的孩子们常常跑到巨人美丽的花园里，非常快乐地玩耍。有一天，巨人回来了，把所有的小孩子都赶出了他的花园。“谁也不许再来！”他一边高喊，一边怒气冲冲地把橡木大门“砰”的一声关上。后来他围着花园建起了一道高大的大理石墙，把孩子们都挡在花园外面。 \n  寒冷的冬天到来了，这在印度是再自然不过的，而那个巨人盼望着温暖早早回来。不久，春天造访了巨人城堡下方的村子，但是冬天的寒冷魔爪依旧拒绝离开他的花园。有一天，巨人闻到了春天的芬芳，感到了太阳穿过窗子照耀进来的温暖。“春天终于回来了！”他大声喊着，跑到他的花园里去了。可是巨人没有想到映入眼帘的是那样一幅场景。村里的孩子们不知用了什么方法终于翻进了城堡，正在花园里高兴地玩儿。正是由于他们的到来，花园从冰封的冻土变成了富饶的土地，盛开着玫瑰、水仙和紫兰花。 \n  所有的孩子都开心地哈哈大笑，除了一个孩子以外。在眼角的余光里，巨人瞥见一个很小的小孩，他比其他孩子个子小得多。他因为没有力气翻过墙头进花园去玩，眼泪从脸上流下来。巨人为那个孩子感到难过，而且在他的一生中，他第一次为自己的恶行感到悔恨。“我要帮助这个孩子。”他说，向他跑过去。当其他的孩子看见巨人出来时，他们都感到害怕得要命，跑出了花园。但是那个个头很小的孩子还站在那儿。“我要杀死巨人，”他结结巴巴地说，“我要保卫我们的游乐场。” \n  巨人走近小孩子，他张开双臂。“我是你的朋友，”他说，“我来帮助你翻过墙头到花园里去。现在它是你的花园了。”这个小孩子，现在成了孩子群中的英雄。他感到很高兴，把自己一直戴在脖子上的金项链送给了巨人。“这是我的幸运护身符，”他说，“我希望你来拥有它。” \n  从那一天起，孩子们一直在巨人美丽的花园里玩耍。但是那个最受巨人宠爱的勇敢小孩子却再也没有回来过。时间一天天过去，巨人生病了，越来越虚弱。孩子们还继续在花园里面玩儿，可是巨人再也没有力气和他们作伴了。在那些安静的日子里，巨人最想念的就是那个小孩子。 \n  一天，在特别寒冷的冬季里，巨人从他的窗子里向外看了一眼，看到一个堪称奇迹的景象：尽管大部分花园都被白雪覆盖，在花园的正中却站立着一株漂亮的玫瑰花树，上面开满颜色各异的鲜花。就在玫瑰花树的旁边，站着巨人最喜爱的那个小孩子。小孩子笑得非常甜美。巨人快乐得手舞足蹈，冲出去拥抱了孩子。“这么多年你去哪儿了，我的小伙伴？我一直都在想念你。” \n  孩子的回答却意味深长：“很多年以前你把我托过了墙头，让我进入你漂亮的花园。现在，我来带你去我的花园。”那天晚些时候，当孩子们再来看望巨人时，他们发现他已经躺在地上去世了，而他的身上从头到脚覆盖着上千朵美丽的玫瑰花。 \n  “只管让自己勇敢起来，约翰，就像那个小小的孩子。站稳你的脚跟，追随自己的梦想，它们会引领你找到自己的命运。跟随你的命运，它将带你领略宇宙的奇妙，带你进入一个满是玫瑰的神秘花园。” \n  当我抬头看向朱利安，打算告诉他这个故事对我的触动有多么深时，我看到了极其震惊的场面：这个曾经把一生中最好的时光都花在追名逐利上的坚如磐石的律师，在这一刻竟然泪流满面**。 \n \n# 粉色带子，代表意志力\n那条粉色的带子用来提醒你记起，在建构起一个更加丰富、幸福和开明的人生中自我控制和纪律所具有的作用。在我遇到的所有人当中，我的那些智者导师无疑是最健康、最安详、最有满足感的一群人。同时他们还是最有纪律性的人。智者教育我说，自律的美德就像那条遮在关键部位上的粉色带子。你有没有花时间研究过一条多股编织的粉色带子，约翰？**” \n“这个我似乎不太感兴趣。”我咧嘴一笑。 \n“好吧，**有机会好好看上一看。你会发现上面连着很多细小的钢丝，彼此首尾相连。如果单独来看，每一根都很脆弱，不结实。但是一旦把它们合在一起，就要比单根线要结实得多，最后这股带子变得比钢绳铁索还坚韧。自我控制和意志力就与这个道理相类似。为了建起钢铁般的意志，最不可缺少的一个环节，就是坚持做微不足道的小事情，以此来培养自我约束的优良品质。持之以恒，一个小作为累积在另一些更小的作为之上，最终就能像核聚变一样，产生出充沛的内驱力。” \n朱利安意味深长地看了看我，接着说：“也许有一句古老的非洲谚语最能说明这个道理：‘把蜘蛛网一股一股地连起来，就能捆住一头凶猛的狮子。’当你将自己的意志力释放出来，你就变成了自我世界的主人。当你不断练习古老的自我支配的技巧，就不再会有高得让你跨不过去的障碍，也不再会有难得让你无法克服的挑战，更不再会有紧张得让你无法平息的危机。自我约束会在人生最磕磕绊绊的时候向你提供心智中储备的无穷能力，保证你可以继续坚持下去，直到胜利。**” \n“**我还必须告诉你一个事实，缺乏意志力将会导致各种不同的心理疾病。这是已经为医学界所证明了的。”朱利安突然又补充说。“如果你饱受意志力缺乏之苦，就要首先尽快改变这一现状。充沛的意志力和纪律性是坚强的性格和多彩人生的主要缔造者。在强大的意志力的支持下，你能够兑现你的诺言。你可以每天坚持在早晨五点钟起床，通过冥想来培养自己的心智。或是在寒冷冬季里的一天，尽管你很留恋被窝的温暖，但强大的意志力还是让你起床到树林中散步，借此滋养自己的精神。在受到别人无礼的指责时，强大的意志力让你保持冷静和沉默。面对突发事件，强大的意志力促使你能够连续克服难关，不断实现自己的梦想。简而言之，正是意志力源源不断地提供内在的激情与力量，让你信守对他人的承诺，而且更重要的是，信守对自己的承诺。\n\n意志力是一种优秀的品质，人生将因此而变得热情似火，变得宁静而致远。\n\n\n\n艰难时日里就是这段话帮助了我。我希望在你遇到苦难的时候，它也能让你的心灵得到慰藉。这段话说的是： \n通过铁一般的纪律，你会铸造出勇敢而平和的性格；通过意志与美德的培养，你一定会达到人生最高的理想境界，你会生活在美好、快乐和生机盎然的天堂世界。如果没有这些，你就会像遗失了指南针的水手一样彷徨失路，最终与船只一起沉没。\n\n\n\n你是说，只要进行了正确的训练和适当的准备，我就能达到像圣雄甘地那样高超的意志力水平？” \n“为什么非要像别人呢，约翰？**其实每个人都是不一样的。瑜伽师拉曼教给我最基本的原则是，真正开悟了的人们绝不以与别人相似为荣。他们更乐意成为新型自我的开创者。不要跟别人赛跑，你要和自己赛跑。”朱利安回答说**。 \n“**当你有了自我控制的能力时，你就会下决心去做你一直想做的事情。对你来说，可能是去参加马拉松长跑训练，掌握橡皮艇冲浪的技巧，甚至是放弃法律职业而成为一位艺术家。无论你的梦想是物质上的富足还是精神上的丰富，我都不会对你指手画脚。我只是想要告诉你，如果你能开启沉睡着的意志力，一切尽在你的掌握之中。” \n朱利安补充说：“在你的生活中，进行自我控制以及加强纪律性还会带给你巨大的自由感。单单这一点就足以引发巨大的变化。\n\n“你的意思是？” \n“**大部分人都是自由的。他们可以去想去的地方，做他们喜欢做的事情。但是有更多的人仍旧是冲动的奴隶。他们消极被动，习惯于见招拆招，却并不具有前瞻性。打个比喻，这些人就像被浪花冲上海岸的泡沫，任凭海潮把它们推向任何方向。当他们正和家人在一起时，如果有同事打电话说有急事，他们就会立刻赶过去，从不停下来想想，到底哪件事情对他们的人生目标来说更重要。所以就我的观察经验来说，无论是在西方还是东方，这种人都拥有自由的权利，却没有享受到真正的自由。在他们身上缺乏一种至关紧要的元素：从看似紧急的情况中选择正确的事情的自由。**” \n\n\n“培养意志力能够给我带来更多的自由吗？” \n**“自由好比一所齐整的房子，你一砖一瓦把它垒起来。你要放上去的第一块砖就是意志力。这个品质可以激励你在任何情况下去做正确的事情。它给你提供精力和勇气，让你过上所期望的生活，而不是成为生活的奴隶。**” \n朱利安还列出了培养意志力能带来的其他很多实际好处。 \n“信不信由你，**培养你的意志力量可以让你消除忧虑的习惯，让你保持健康，给你带来比以往多得多的精力。要知道，约翰，自我控制实际上就是心智控制。意志是心理力量的统帅。如果你掌握了心智，也就掌握了你的人生。对心智的控制源于你能够控制每一个出现在你头脑中的想法。如果你能够把所有软弱的念头都清理出去，仅仅注意那些积极美好的念头，那么积极美好的行为也将相继而来。这样你的人生中也会很快变得积极而美好**。\n\n“这儿有一个例子。假设说你的个人发展目标之一是每天早晨六点半起床，然后围着你家后面的公园跑步。让我们假定现在正处于严寒当中，你的闹钟铃声把你从恬静的沉睡中唤醒。你的第一反应就是按下闹铃的按钮，然后接着呼呼大睡，心想明天再去真正实行你的锻炼计划。这种状况拖了好久好久，直到你觉得自己太老了，健身计划对你已经太不现实了，于是就放弃了你的计划。” \n“你太了解我了。”我诚恳地说。 \n“现在让我们来考虑另一种情形。还是在严冬时节，早晨的时候突然铃声大作，你产生了继续待在床上的想法。为了不再成为习惯的奴隶，你开始用更加强大的意志力去战胜它们。你开始在头脑里想象，如果你的体形好到极致，那将是一种什么样子，会有什么感觉，会做什么事情。当你在办公室里信步走过的时候，你会听到同事们的大声恭维你匀称而良好的身材。你不断想象定期的锻炼计划能够让你达到的目标。你再也不会说出庭了一天之后就累得什么也不愿意做，最终只能在电视机前打发晚上的时间。你的生活中将充满了活力、热情和意义。”\n\n\n“但是假如我这样做了，还是想回去睡觉，不出去锻炼呢？” \n“最初的几天当然会有一点困难，你更容易回到旧习惯中去。但是瑜伽师拉曼特别坚信一条古老的法则：积极总是能战胜消极。所以，如果你能够继续向那些多年来渐渐蚕食掉你的软弱思想作斗争，最终这些思想会像自知不受欢迎的访客一样灰溜溜地不告而别。” \n“你是想要告诉我思想也是一种实际存在的东西？” \n“是的，而且它完全在你的控制之中。思考积极的想法和消极的念头一样容易，然而效果大相径庭。” \n“**那么为什么还有那么多人在忧虑，在关注我们这个世界上的负面信息？**” \n“**因为他们还没有学会自我控制的技巧，不会限制思考的方向。在我曾经交谈过的人群当中，有很多人都根本没有想过，自己竟然还有力量去掌控生活中每天、每分、每秒出现的每一个想法。他们相信思想不过是偶然发生的，却根本没有认识到，如果你不花时间去控制自己的想法，它们反过来就会控制你。这是一场控制与反控制的战争，可能很漫长，甚至会终其一生。如果你能够把注意力集中在美好的事物上，借助真正的意志力拒绝那些负面思想出现，我向你保证，它们很快就会卷铺盖离开了。**” \n“所以，如果我想要拥有内在的力量，能够早些起床，少吃饭、多读书，不忧虑、更热情，我要做的就是将意志的力量全部发挥出来净化我的思想。” \n“**当你控制了你的思想，你就控制了自己的心智。当你控制了自己的心智，你就控制了自己的人生。一旦你能够完全控制自己生活，你就成为了自己命运的主人。**” \n\n\n## 培养意志力的方案\n### 重复一些简单的语句：真言/创造性想象\n尽管只有为数不多的喜马拉雅山上的智者知道这些真言，但是它们已经历经了五千余年时光的磨炼。瑜伽师拉曼告诉我，如果不断念诵它们，就可以在很短的时间内培养起自我控制能力和内在的意志力。记住，语言具有巨大的影响力和暗示效果，词语就是自身力量的文字体现。在你的头脑里装满充满希望的话语，你就会变得信心十足；在你的头脑里装上善良的话语；你就会变得善良而开朗；在你的头脑里装上勇敢的话语，你就会富有勇气。话语就是力量。**”朱利安总结说。 \n“好吧，我洗耳恭听。” \n“**我建议你每天把这句真言至少重复三十遍：“我比外表看起来更强大，世界上所有的力量都在我的身体里。’它会在你的生活中带来持久的改变。要是想让这句话迅速起效，就把这句话和我前面告诉过你的创造性想象的练习结合起来。比如说，去找一个安静的地方。坐在那里闭上双眼，不要分散心神，保持身体静止不动，因为意志薄弱者最明显的一个特征就是身体闲不下来。然后大声重复这句真言，一遍又一遍地重复。在你做这些的时候，把自己看作是一个遵守纪律、意志坚定的人，能够完全控制自己的心智、身体和精神。在内心里想自己要像甘地和特蕾莎修女在面对艰难时刻的所作所为那样行事。随后产生的效果一定会让你大吃一惊的。”朱利安信誓旦旦地说**\n\n## 两个方法\n### 试着去做你不喜欢做的事情\n第一件事就是试着去做那些你不喜欢做的事情。对你来说，这些事情可能很简单，比如早晨起来叠被子，步行上班而不是驾车去。通过养成尽力而为的习惯，你会很快改变顺从软弱和冲动的毛病。**” \n“不用则废？” \n“完全正确。为了塑造意志力和内在力量，你首先要使用它。你越是努力培养内在约束的胚芽，就会让它成熟得越快，让你更快地看到你所希望的结果。” \n### 沉默的誓约\n实际上那种誓约就是这样的，约翰。那些推崇这一方法的西藏喇嘛相信，长时间的完全的噤声有助于提高一个人的内在自律性。**” \n“这是怎样做到的？” \n“**从原理上说，通过一天的沉默不语，你可以使你的意志完成你命令它做的事情。每当想要说话的念头出现，你就立刻抑制这个冲动，继续保持安静。你看，意志本身不会产生任何想法。它等待着接受你的引导，刺激它采取行动。你越能控制自己，意志的力量也就越强大。问题是大部分人根本就没有使用他们的意志力。**” \n“为什么会这样？”我问。 \n“**也许是因为大部分人认为他们根本就没有意志力。他们为这种明显的软弱怨天尤人，却不从自己身上找原因。那些火暴脾气的人会对你说：‘我抑制不住呀，我的父亲也是这个样子。’那些过度焦虑的人会对你说：‘不是我的错，我的工作压力太大了。’那些整日酣睡的人会说：‘我能怎么样呢？我的身体需要每晚十个小时的睡眠。’这些缺乏自我负责能力的人从不知道，在我们每个人的体内都沉睡着不可思议的潜能，期待着受到鼓舞，然后转化为具体的行动。当你渐渐了解古老的自然法则，知道它们支配着宇宙的运转以及所有生活在其中的生命，你就会明白成为你想成为的人是你天赋的权利，你有能力改变你所处的环境。同样，你有能力摆脱过去时光的束缚，让自己得到前所未有的自由。为了达到这一目的，你必须成为意志的主人。\n# 金秒表，代表时间\n原来是一个缩微型的沙漏，用褐色的玻璃和一小块檀木底座制成。看到我略带惊讶的表情，迪维笑了笑，温和地告诉我，每一个智者在孩提时期都收到过一件同样的器具。‘尽管我们身无长物，过着纯粹、朴素的生活，但是我们尊崇时间，并且注意到它在一刻不停地流逝。这只小小的沙漏是对我们每个生命一刻不停走向死亡的提醒，提醒我们在向目标接近的过程中，过一种充实的生活和有所创造的日子是多么重要。因为，正如人不可能同时踏入第二条河流之中，人也不可能返回来，重新开始同一次生命的历程。’**” \n“那么，这些生活在喜马拉雅山上的高僧也重视时间吗？” \n“他们中的每一个人都深知时间的重要性。**他们每个人都培养起了我所说的‘时间意识’。你瞧我们已经明白地意识到，时间就像沙粒一样从我们的指缝中毫不留情地漏下去，不再复还。那些早年就能够明智地利用时间的人会收获一个丰富的、多产的、心满意足的人生。而与此相反，那些从来没有感受到‘掌握时间就是掌握生命’这一原则的人，永远也不会发现他们本性中其实曾经拥有着巨大的潜能。时间是最伟大的神，也是最公平的分配者。无论我们是特权者还是贫苦阶层，无论是生活在得克萨斯还是生活在东京，我们都被分配到一天二十四小时的时间，谁也不多一秒钟，谁也不少一秒钟。而最终真正能把创建了杰出人生的大人物和随波逐流的庸才区分开的，恰恰是他们对时间的不同使用方式，简而言之，就是不同的时间观念。**” \n“但是我曾经听我父亲说过，正是最忙碌的人才最有空闲。你对此怎么评价？” \n“我赞同。忙碌的、能干的人总是能够高效地使用他们的时间——他们必须要生存下去。但是，成为一名最优异的时间安排者，却并不意味着必须把自己变成一个彻头彻尾的工作狂。相反，有效的时间控制能够让你有更多的空闲去做自己喜欢的，真正有意义的事情。控制好时间才能控制好人生，所以要好好守护时间。记住，这是不可再生的资源。” \n“那我现在就给我的表上好发条。”我们一起笑了起来。 \n“让我再给你举一个例子吧，”朱利安提出建议，“**让我们假设这是星期一的早晨，你的时间表上排满了约见、会议和庭审出席的日程。往常，你会在早晨六点半就起床，一口吞下一杯速溶咖啡，飞奔着赶去工作，然后昏天黑地地度过了非常紧迫的一天。好，接下来让我们假设有一次，你在星期天的晚上抽出了十五分钟的时间来计划自己的安排。或者说为了更加高效，让我们假设你在平静的周日上午抽出了一个小时来安排整个一周的生活。在你的每日计划表中，你标出什么时候会见客户，什么时候你要做法律研究，还有什么时候你要回一些重要的电话。最重要的是，在一个星期之内，你把在个人、社会和精神方面的发展目标也都列入了你的记事本。这个简单的举动是保持生活节奏平衡的奥秘。通过在每天的日程表上锁定生活中所有最至关重要的方面，你可以确保这一个星期的生活过得充实又有条不紊。**” \n“你是不是建议我从每天繁忙的工作中抽出一点时间来休息，然后去公园里散步或者躲到一个地方沉思冥想？” \n“是的。你为什么非要那么严格地遵守惯例呢？你为什么一定要像其他人一样用同样的方式行事呢？**走你自己的路好了，不要在乎别人怎么看，关键是要让自己觉得舒服自然。你为什么不提前一个小时开始工作，这样就可以有足够的闲暇在中午的时候放下手头的工作，到办公室附近的美丽公园里平心静气地散步。还有，为什么不在一周刚刚开始的时候就向工作里投入更多的时间与精力，这样就可以在周五下班之前早早收尾，然后快快乐乐地带上孩子去动物园玩一会儿。还有，为什么不在一个星期内抽出两天的时间在家里工作，这样就可以更多地照顾家庭。我说的所有这些都是为了让你更有创造性地作出一周的计划，合理地安排时间，当然并不是非如此不可。一定要把时间列在你首要关注的核心位置上，它会让你明白，人生中最有意义的事情决不应该为了最不重要的事情而作出无谓的牺牲。**” \n\n忙碌并不是借口。真正的问题是，你要随时问自己，你究竟在忙些什么？我从那些年老的智者那里学会了一条伟大的法则：你在一生中获得的80％的成果，常常来自于你仅仅花了20％的时间来完成的事情。瑜伽师拉曼把它叫作‘古老的二八法则’。\n\n你的意思是指，那些‘高效能’的时间就是指我花在提高自己法律知识上的时间，和我的客户一起丰富人际关系的时间，还有为了成为更能干的律师而投入的时间？” \n“是的，还有你为了培养亲情而和詹妮以及孩子们一起度过的那些时间。” 朱利安的回答相当肯定，然后他又做了一个补充：“还有花在自然中的时间，这是你对自己有幸拥有的一切而表示感恩的时间，也是用来更新你的心智、身体和精神空间的时间。以上这些都是‘高效能’的行为，帮助你得以从容规划出一个值得度过的人生。当然，有一些无效的时间付出是你没有办法避免的。我的意思是说，设法将自己的时间尽量多地投入在这些有意义的行为上。古希腊的哲人早就说过：‘已经得到启蒙的人最先获得生命的动力。’这就是控制时间的秘诀。\n\n那么就尽量学着去简化你的生活吧，”朱利安同情地建议我，“把减法应用在生活的每个方面。这样做以后，你就可以有时间去欣赏美好的、奇妙的事物。最难过的事情是我们任何一个人都不能为了领略到更多的美好而把自己的生命向后推延。我常常会有一种时不我待的悲伤。然而，有太多的人梦想在遥远的将来能看到神奇的玫瑰，却不去看一眼长在自家后院里的花朵。这真是一个莫大的悲剧。\n## 把时间花在精肉部位\n生活就像一长条熏猪肉，”我插话说，“为了有效掌握你的时间，就必须把肥的、瘦的细细地区分开来。” \n\n“说得好极了，约翰，你真讲到点子上了。尽管我的素食主义立场告诉我不应该选取这样一个禁忌性的话题，不过说老实话，我还是很喜欢这个比喻。**尽管有些粗俗，但你的确一语道破了机关。当你把时间和珍贵的心智精力投入到精肉部位以后，就没有时间在肥肉问题上浪费那些无谓的时间了。这就是你的生活从平庸变为非凡的关键。**\n## 要学会说‘不’\n你的话让我想到另外一个问题。别让他人窃取你的时间，要警惕无处不在的时间窃贼。**在你哄孩子睡觉，或者刚刚在心爱的椅子上坐下开始读一本你早已如雷贯耳的惊悚类小说时，总是有些人会在这个时候打来电话，然后天南海北地和你胡侃一通，然而他们不知所云的所谓高见早已将你的兴致破坏得面目全非。他们这类人专门会在某个特定时刻敲开你的办公室，然后赖在那里高谈阔论。而那时你好不容易才从疯狂忙碌的一天中抽出几分钟来，想一个人静静地待一会儿，喘上一口气，清理一下思路。这些情形听起来还熟悉吗？” \n“太常见了，朱利安，你说的一点也不错。我相信，以前你受到的骚扰比我更甚，因为你比我更有名气。不过，这些人似乎总是很难拒绝的，我感觉如果直接请他们离开或者紧闭房门是不礼貌的。”我向朱利安说出自己的心事。 \n“**你必须学会不留情面，才能真正履行自己的时间规划。要学会说‘不’，要有勇气对生活中的琐事断然说‘不’，只有这样，你才会有力量对那些重要的大事说‘好吧’。当你需要花费几个小时来专攻一个大案件的时候，当然要关紧办公室的门，连秘书都是非请莫入。记着我告诉你的话，不要每次电话一响你就去接听。这要看你是否方便，而不是看其他人的方便。要将主动权牢牢掌握在自己的手中。很讽刺的是，当他们发现你是一个惜时如金的人时，不但不会非议你的‘无礼’，相反会对你更加尊敬。他们会觉得你的时间很宝贵，因此就会重视你的时间安排，也不会无端地打扰你，从而还你一份清静。**” \n## 拖延时间又该怎么解决？\n我总是把不喜欢做的事情不断地、不断地向后推延，要到非做不可的地步才怏怏地动手。可是另一方面我又把大量的时间花在浏览垃圾信件、翻阅成堆的过期法律杂志上。也许我这样做只是为了消磨时间？” \n“消磨时间只是一种说法。实际上，**人的本性是趋利避害的。你不喜欢做一些事情，因此你的天性就会传达一种负面的情绪。但你同时又知道，这些事情如果不及时处理，那结果就会更糟糕，这个时候现实理性又会逼迫你及早动手。于是痛苦就产生了。但是就像我早先说过的，这个世界上最能干高产的人具有做好任何事情的习惯，哪怕这些事情可能是他们不喜欢做的，而不能干的人却养成了不做事的习惯。**” \n我不再答话，开始深刻反思刚才听到的话。**也许拖延并不是我个人的问题，或许只是因为我的生活变得太复杂了，而朱利安一下子就抓住了我的关键。 **\n\n“**瑜伽师拉曼告诉我说，那些掌握了时间的人生活会更加简单。匆忙、狂热的节奏并不是人类本性的趋向。他坚信并一直向我重申，只有那些做事高效并为自己设有明确目标的人才能得到永恒的幸福。这就是我所学到的智慧中最令人着迷的地方。它使我的工作优质而高产，同时又能够完全满足精神上的渴望。在某些时候，工作反倒成为了游戏。**” \n\n## 打一个小盹儿\n我喜欢在下午的时候打一个小盹儿。我感到这能使我保持活力充沛，更新精力，有蓬勃的朝气。我想可以这么说，我需要美容觉。\n## 临终心态\n迪维在送给我这个小沙漏时还给了我几条忠告，我永远也不会忘记。” \n“她说了什么？” \n“**她告诉我，种树的最佳时间是四十年前，其次就是今天。不要浪费生命里的任何一分钟。要有一种临终心态。**” \n“你再说一遍？”我问他，朱利安采用的生动词语使我惊呆了。\n“什么叫临终心态？” \n“**这是东方哲学中的一种生命观，也可以称其为‘向死而生’。这是你看待人生的新角度。它会提醒你，也许今天就是生命的最后一日，所以好好享用吧。**” \n“哈，如果你想知道我的真实感觉，朱利安，那我就老老实实地告诉你，这个话题我觉得很可怕啊，它让我想到了死亡。” \n“**确实如此，这就是生命的哲理。当你抱着这种临终心态，你会把生命中的每一天都当成最后一天。想象一下，每天早晨醒来以后，问自己一个简单的问题：“如果今天是我生命的最后一日，我将会做些什么？’接下来，考虑你将如何对待自己的家庭、同事，乃至你根本不认识的人们。想一想你将多么能干，多么振奋，在你手中，每一时刻的价值都实现了最大化。单单是这个临终问题就拥有改变人生的力量。它会让你每天都活力充沛，在做每件事时都带着丰富的热情和开朗的精神。你会开始注意那些一度被你不断拖延的、意义深远的事情，而不会在那些把你拖入危机和深渊之中的琐屑小事上无谓地浪费时间。” \n朱利安继续说：“鞭策自己去做更多的事，体验到更多的新鲜事物，促使你把精力用在扩展自己的梦想上。对，扩展你的梦想。不要安于碌碌无为的人生。既然你在心智的源泉中拥有如此无限的潜力，就要敢于让‘伟大’这个词和自己的生命联系起来。这是你的天赋权利。*\n## 表现得好像你不可能失败\n有一个简单的方法，可以为很多人消除意志消沉的苦恼，这种苦恼的确会让人感到非常难受**。” \n“我的杯子正空着呢。”我虚心地说。 \n“**表现得好像你不可能失败，这样你的成功就有保证了。把所有觉得不能达到目标的想法都从头脑中清除出去，无论是物质方面的，还是精神方面的。勇敢点，不要给自己的想象设限。不要成为过去记忆的奴隶，而是要做未来的设计师。从此，你就不再是从前的自己了。\n## 奉献是人生的终极目标\n在印度有一句古老的谚语：‘我们不是有着精神体验的生命存在，而是有着生命经验的精神存在。’通过长时间的修行和游历，我想现在可以说，我真正理解了自己在宇宙中的角色。我终于在自我的镜像之中看到了我是谁。我不再处于世界当中，世界在我的心中。那种体验是什么样的呢？我也描绘不出来。这样吧，我给你诵念东方哲人的两句诗：君掌盛无边，刹那含永劫。**” \n“我觉得我必须好好考虑一会儿你刚才说的那句话，尤其是最后那两句诗。你知道，我在大学里最害怕文学与语法修辞类的考试。”我老老实实地说，因为我真的不太理解朱利安说的话。 \n“当然。我理解，我的朋友，总有一天你会理解我所说的一切。如果你能够按照我告诉你的方法去做，认真练习我向你提供的诸多技巧，你就一定会在启蒙的道路上不断前进。你将慢慢掌握支配自我的技巧，而且你也将发现自己生命的意义到底是什么：那不过是永恒图景上的一点微光。而且你也将逐渐明白你究竟是谁，知道人生中的终极目标是什么。” \n“**那目标是什么呢？”我越来越有好奇心了。 \n“当然是奉献。无论你的房子有多么大，或者你开的汽车有多么炫目，但是你在生命结束的时候都不能将它们带入坟墓，唯一相伴的只有自己的良心。所以，你要时刻侧耳倾听自己良心的声音，让良知引导你。它知道什么是对的，它会告诉你，你的使命就是无私地帮助他人。这就是我的人生漫游经历带给我的最大的收获。眼下，我有非常多的人要去会面，为他们服务、治疗。我的使命就是把智者的古老智慧传播给所有需要学习它的人们。这就是我的目的。**” \n# 玫瑰花，代表无私地帮助别人 \n我和你分享的品质中最不可缺少的一条，约翰，就是这个：无论你取得怎样的成就，无论你拥有了多少套夏季别墅，无论你家的车道上泊着几辆高档小汽车，你的人生质量还是要归结到你所作出的贡献的质量上来。**” \n“这是不是和瑜伽师拉曼的寓言里那些鲜艳的黄玫瑰多少有点关系？” \n“当然有关系。**这些花会提醒你想起一句古老的中国谚语：送人玫瑰，手留余香。这句谚语的意思很清楚——当你致力于提高别人的生活时，在这个过程中你也间接地提高了自己的人生品质。如果你每天都有意地随时随地做出一些善举，你自己的人生也将因此而变得更加丰富，更加有意义。为了培养日常生活中的神圣感和尊严感，从现在开始就用各种方式帮助他人吧。**” \n“你是不是在建议我多去参加一些志愿者活动？” \n“嗯，**应该说那是一个良好的开端。但是我所说的比参加志愿者活动这个具体的事件具有更多的哲学性。我是在建议你，你要对自己在这个星球上要扮演的角色采取一种新的理解‘范式’。**” \n“你又把我搞糊涂了。拜托你把‘范式’解释得清楚一点，我实在不熟悉这个词。”我请求道。 \n“**简单来说，范式就是人们通常看待生活境况和生命过程的一种方式。有些悲观主义的人把人生看成一只半空的杯子，而乐观主义者则视之为半满的杯子。你看，‘半空’与‘半满’，对于同一种存在的境况竟然有不同的解释，这就是因为观察者采用的范式不一样。范式从根本上说就是一面透镜，你要通过它来观察人生历程中各种事件，无论是对外在世界还是内在世界。**” \n“因此当你建议我采用一种新的范式来看我的人生意义，是不是说我应该换一种眼光？” \n“**在一定程度上是这样的。为了显著提高你的生活品质，你必须针对自己为什么会在地球的这一处地方生活而不是那一处地方生活找出一个原因。你必须认识到，正如你两手空空来到这个世上一样，你注定是要两手空空地离开的。在这种情况下，只有一个真正的原因说明你身在此地的存在价值。**” \n“那会是什么？” \n“**把自己无私地奉献给他人，通过有意义的工作方式来作出应有的贡献。**”朱利安回答说。\n“我并不是说你不能享受你的生活，或者说你必须放弃自己的法律事业，然后有意让自己的生活变得穷困潦倒，好像只有这样才能全身心地投入到无私服务社会的行动中去——虽然我最近常常见到一大批散尽家财、投身慈善事业的人，而且看上去他们个个都心满意足——你要明白，我们的世界目前正处于大变革当中。” \n“大变革？”我有些迷惑不解了。 \n“**是的，大变革。对比一下过去30年和今天的生活，你就会发现人们对于意义与价值的理解发生了翻天覆地的变化，人们开始用钱换取人生意义。比如过去的律师只会按照委托人钱包的尺寸来做出是与否的判断，而现在则不同了，真正的律师会按照人们对他人的责任大小和爱心的大小来作出自己的判断。教师们辞去稳定又保险的大学工作，为生活在城乡结合部的贫困孩子无偿提供义务素质教育。在这个大变革的时代里，有良知的人们已经听到了呼唤价值改变的铃声，人们已经重新认识到自己生存的目的。这一目的无法用金钱和社会地位来衡量，而且他们已经得到了帮助自己去实现这个目的的特殊天赋。**” \n“究竟是什么特殊天赋？” \n“**确切地说，就是我花了整整一个晚上来告诉你的那些因素：丰富的心智，无穷的精力，无限的创造力，坚强的意志力和内心的安宁。而现在你要做的就是勇敢地开启这些宝藏，在日常生活为了公众的利益而使用它们**。\n\n\n## 摆脱自我的枷锁\n那么**怎样才可以开始做好事呢？**” \n“**做好事不分时间先后、事情大小，你可以随时随地将自己的爱心传递给别人。再稍微抽象一些，那我的回答也很简单，就是把‘做好事’这种理念放在改变自己人生观、世界观的首要位置上，这样你就可以不再把自己看成是一个简单的个体，而会开始把自己看作是集体洪流中生动鲜活的一分子。**” \n“那么我是不是得变得再善良点儿，再温柔点儿？” \n“要知道，你能做的最崇高的事情就是给予。”朱利安双手伸向空中。 \n“**东方的智者将这个过程叫作‘摆脱自我的枷锁’，就是要你丢掉自我意识，开始关注更高的目标。也许这在某种程度上意味着你要向周围的人付出更多的时间和精力，尽管它们是你最有价值的两种资源。**” \n“资源？”我有些不解地问。 \n“对，是资源，”朱利安再次露出耐心的微笑，“如果按照最高标准来要求的话，可能是你抽出一年当中休假的时间，毫无报偿地为街区里的穷人做义工；如果按照最低标准来要求的话，可能是在交通极端堵塞的时刻，不再骂骂咧咧，不再抢着见缝插针，而是摆一摆手，让车流中别的车子先开走。” \n“哦，听起来像个交通警察在给我上课，朱利安。”我想起下班路上一到塞车时候就灌满满街道的喇叭疯响，不由得有些烦躁。 \n“哈，朋友，安静点。**听起来是有些老生常谈，但是在我所有领会到的道理中有一条非常重要——只有当你开始努力让世界变得更加美好，你的生活才会因此向更好的方向上推进。我崇敬的智者瑜伽师拉曼说过：在我们出生的时候，世界一片欢腾而我们哇哇大哭；如果我们一生的时间都在帮助别人，在为世界变得更美好的工作中度过了一生，那么等到我们死去的时候，世界在哭泣，而我们却很欢喜。**” \n## 每天做好事\n他们不过是需要有一点良知的火花来点亮同情的蜡烛。丰富的同情心和日常的善行会使你的人生更加丰富。每天早上在鸟鸣中醒来时，先别忙着起床，躺在温暖的枕头上抽出一点时间来考虑一下，在这即将开始的一天当中，你将为别人做哪些好事。你可以赞美那些对自己失去了信心的人，赞美那些最不指望得到赞美的人，给陷入困境的朋友送去温暖，还可以向家里的亲人们表示自己的感激和爱意。所有这些加起来，不就构成了更加美好的生活吗？而说到了友谊，你一定要不断维护它。一个拥有三个铁哥们儿的人其实是非常富有的。\n\n我得承认，我的内心已经完全被朱利安的话征服了，不过我还是故作轻松地和他打趣：“在中国话里这就叫作‘一个好汉三个帮’对吗？” \n朱利安对我竟然知道一句中国的谚语表示惊奇，不过他还是点点头赞许了我。“是啊，朋友给生活中增添了欢乐、兴趣和美丽。没有什么比和一个老朋友在一起开怀大笑更能让人恢复青春活力了。当你在工作上有了点成就，就开始狂妄自大，太拿自己当回事的时候，朋友的良言会帮助你保持谦卑。当生活给你带来了小小的挫折，你以为世界末日就要到来时，好朋友会一如既往地守在那里给你帮助。就以我为例吧，当我还是一名忙忙碌碌的律师的时候，我几乎没有时间交朋友，当然那些生意上的伙伴不算。在经过了长期与世隔绝的生活之后，在这个世俗的社会里，我是彻彻底底的孤家寡人了——除了你以外，约翰。我找不到一个人来陪伴自己去森林里远足，因为他们每个人都舒舒服服地待在温柔醉人的睡眠安乐窝里。当我读完了一本非常精彩的、深深地打动了我的书以后，却找不到人可以与我一起分享，我甚至连一个可以一起争辩讨论的朋友都没有。当金秋的阳光温暖了我的心扉，让我满怀欣喜的时候，我找不到一个值得信任的朋友可以敞开灵魂去倾诉。” \n朱利安很快控制住了自己的情绪，也许他很快便想起了住在喜马拉雅山顶的那些智者。他们不仅是他的老师，也是他的朋友，甚至从某种意义上说已经成为他的家人了。 \n“不过，我没有时间让自己深陷于遗憾情绪的负面影响。**我的智者导师们一直在教育我说：“对于开悟的人来说，每个黎明都将是崭新的一天。**’” \n# 钻石，代表活在当下 \n我基本上同意你的观点。我们确实应当对那些能够激发兴趣的目标表示出孜孜以求的积极态度，因为这是确保个人成就感的根源。但是还不止与此，你要记住，幸福是一场旅行，不是目的地。因此，你要时刻提醒自己，要为了今天的生活质量而活着——再也不会有另外一天会和今天一样了。”朱利安说，双手安详地交叠在一起。 **\n “在瑜伽师拉曼的寓言里，这个道理的象征物就是那条铺满钻石的小路吧？”我问他。 \n \n “是的，”朱利安的回答简洁而明快，“**那位高大的相扑选手走在钻石小路上，最终获得永恒的满足感和欢乐。就像他一样，只要你明白你当前所走的道路也铺满了钻石和其他诸多无价珍宝，那么你也能够拥有你想要获得的生活。不要再把时间过多地花在纵情享乐之中，因为人生更多地是由那些微小的快乐组成。尽管你常常忽视它们的存在，但正是它们在浸润着你的内心世界，让你变得善良而乐观，无私而勇敢。我的朋友，好好地享受围绕在你身边的美丽和圣洁吧，这些神奇之物全靠你自己去发现。**” \n “你的意思是不是说我应该先停下来，不再给未来的人生设置远大目标，而是要把注意力转移到当前的生活中来？” \n “当然不是这个意思，”朱利安斩钉截铁地回答，“**正如我在前面和你说过的那样，面向未来的目标和梦想非常重要，这在每一个真正成功的人生当中都是不可缺少的。正是因为怀有对未来事物的热望，才让你每天早晨坚持从热被窝中迅速爬起来，并且在一天的工作中保持着饱满的精神和注意力。树立人生的目标，就意味着给你的生活加油。我的意思只是说，不要为了成就就放弃快乐。不要把那些可以带给你幸福感和满足感的事情推迟到以后再去做。今天，就是今天就要活得畅快淋漓，而不是苦苦等到赢了体育彩票或者终于熬到退休以后。千万不要把生活中的幸福向后推迟，因为再晚可能就没有机会了。**” \n 朱利安站了起来，开始在起居室里来来回回地踱步。这时候他似乎又恢复了大律师的样子，在即将结束一场热情洋溢的辩论时作最后陈词。 “不要再自欺欺人，以为只要你为律师事务所再多雇用几个初出茅庐的律师来减轻工作负担，你就会马上变成一个更爱你的妻子，肯为家庭付出的好丈夫。”他的最后陈词和以往一样精彩，我看着此时的朱利安，竟然有些恍惚，觉得他从来都没有离开似的。但是他坚定的声音把我再次拉回眼前。 \n “**不要自欺欺人，以为只要银行户头上有了足够大的数目，自己就自然会有更多的自由时间，可以为所欲为，放肆起来。不要试图让自己想象，只要有了钱有了闲，你就会开始丰富自己的心智，开始关心自己的身体，开始滋养自己的灵魂。这些都是自欺欺人，我们都很明白这一点。今天，就是今天，是你享受多年来努力成果的时候。今天就是抓住眼前一刻，度过充实人生的时候。今天就是抛开忧虑的想象，让心中的梦想跃然成真的时候。而且，在你为自己创造幸福的时候，请你千万、千万不要忘记家庭给予你的丰厚馈赠。**” \n\n\n“我不敢肯定自己完全理解你的意思了，朱利安。”我没有跟上他的语言跳跃。 \n “**和自己孩子一起经历童年。**”非常简单的回答背后似乎隐藏了什么。 \n “嗯哼？”我小声咕哝了一句，在这句似是而非的话面前仍然摸不着头脑。 \n “**在人的一生中，几乎没有什么事能比你和孩子们一起分享童年更有意义了。如果你在第一个阶段里就忘了和孩子相伴，又怎么可能走向此后的幸福呢？然而，要是你根本没有时间没有能力来创造一个家庭，那么就算你拥有了整个街区当中最大的房子又有什么好处呢？如果你的孩子们根本就不知道给他们生命的父亲是谁，那么就算你名满全国，当上了炙手可热的第一辩护律师又有什么用处呢？我知道我说的是什么。**\n ”朱利安用我们的职业举例子，我感到他的声音因为激动而微微有些发颤。 朱利安的最后一句话使我感到困惑。我所了解的朱利安是一个超级明星律师，每天周旋在珠光宝气和灯红酒绿之中。他和红极一时的时装模特在豪华酒店里的浪漫约会，和他在法庭上滔滔不绝的辩论技术一样广为人知。这个做了多年花花公子的百万富翁怎么可能知道如何做好一位父亲？他又怎么可能知道我每天都要面对的挣扎，想要做好每一个角色要求的每一件事，在家里我得是一个了不起的父亲，出门以后我得是一个成功的大律师？所有这些琐碎的烦恼，朱利安怎么可能知道？我虽然这样想着，却尽量掩饰自己的怀疑，但是敏感的朱利安还是凭着直觉发现了我的想法。 \n “也许你不知道，我确实了解一些关于孩子的事情。”他温和地说，渐渐从刚才的律师状态恢复了他智者的模样。 \n “不过，说句实话，我还一直以为你没有孩子，是现代城市里人见人爱的钻石王老五，至少在你认输辞职之前，我们一直这样认为。你知道的，有多少女实习生为了进入你的办公室大耍花样？有多少……” \n “稍等，稍等，”朱利安竖起手掌做了个暂停的手势。\n “老朋友，你对我的了解从12小时前才开始，对不对？” \n 我看了看他，朱利安脸上的确没有矫揉造作的羞涩。有一种人，无论男女，一听到自己很受异性的欢迎就故意加以否认，但是脸上得意的神态完全暴露出内心的浅薄。朱利安脸上仍然是一潭秋水般的平静。 \n 他继续说道：“人们都知道我过着一种节奏快、心情飘的生活方式，同事们以为我那样的人生应该很过瘾吧。我也曾经这样认为，直到我明白那只不过是自欺欺人的幻象。\n ”这时竟然有一丝苦笑出现在他平和的脸上，“你知道我是结过婚的。” \n “是的。”我清了清喉咙。 然后，朱利安在开口前顿了一下，很像一个孩子正准备向最好的朋友吐露内心中隐藏最深的秘密。\n “但是，你不知道的是我曾经有一个小女儿。她是我最心爱的宝贝，是我一生中见过的最精致最可爱的小精灵。那个时候，我很像我们第一次见面时候的你，自高自大，野心勃勃，而且满怀着希望。我似乎很幸运，拥有世界上每个人想要得到的一切。所有认识我的人都纷纷夸我前程远大，羡慕我有一个美艳惊人的妻子和可爱极了的女儿。然而，当生活看起来非常完美的时候，幸福马上就又离我远去了。” \n 这是第一次，从朱利安踏入我的家门以后，忧伤第一次完全吞没了他欢乐的神色。一滴眼泪从他晒黑的脸颊上滑落，落在他天鹅绒般柔软的宝石红长袍上。我张口结舌，不知怎样安慰，因为我已经完全被老朋友的真情流露惊呆了。 \n “你不必继续讲下去，朱利安。”我同情地建议说，把一只胳膊搭在他的肩膀上去，希望能够安慰他。 \n “不，我要说，约翰，请听我说吧。在我过去认识的所有人当中，你是最信守承诺的，也是我最信任的。正如我所说过的那样，你常常让我回想起我自己年轻的时候。说真的，即使是现在，你的身上还有很多东西吸引着我。但是我知道一定要告诉你，用我自己的教训来告诉你，如果你继续按照现行的生活方式去生活，总有一天你明白其实这样是在自找苦吃。我来到这里就是为了向你表明，世上有那么多奇迹等待着你去探索，还有那么多美好的时刻等待着你去品味。 \n “那个夺去我女儿生命的喝醉酒的司机，在太阳都为之哭泣的10月的一个下午，不仅仅夺去了一条珍贵的生命——而是两条。自从我的女儿意外去世后，我的生活也打了死结。我开始在办公室里度过每一分钟清醒的时间，愚蠢地希望我的法律事业能够成为破碎心灵中的痛苦的替代品。有些日子，我甚至就睡在办公室里的长沙发上，因为我害怕回到家去，害怕回到那个还残留着那么多甜蜜回忆的家。我的妻子，从我读法学院的时候就一直陪伴着我的伴侣，后来也离开了。她说我的心里只有工作，这简直是压倒我的最后一根稻草。在痛苦、逃避、更痛苦的恶性循环中，我的健康越发糟糕，名声也变得不可收拾，我眼看自己一天天陷入声名狼藉的生活。那就是我们初次见面时我的生活状态，你眼中的同情向我证明我的回忆是准确的。的确，金钱可以买来的东西我一样也不缺，但那是我出卖了灵魂以后换回来的，我真的这样做了，交出我的灵魂。”朱利安激动地说着，声音仍然是哽咽的。 \n “所以你对我说‘和孩子一起分享童年的时光’，其实是让我每天都抽出时间观察他们的成长和发展变化。是这样，对不对？\n ”我怎么能够不同情面前这个痛苦的朋友呢。 “当时我们开车送她去参加她最好的朋友的生日聚会。即使到今天，她离开我已经二十七年了，但是只要能够再次听到女儿的咯咯笑声，只要能够再和她一起玩儿捉迷藏的游戏，就像我们俩经常在我家后院里玩的那样，我愿意付出一切代价！”朱利安捂住了脸，大口喘息着。 \n “是的，我明白，我明白。”我不知怎样安慰他。 \n “**我最喜欢把她抱在怀里，温柔地梳理她的金色卷发。她离开以后，把我的心也带走了。尽管我在喜马拉雅山上找到了开启心智和自我掌控的方法，我的人生因为找到了新的意义而重新振作起来，但是在我度过的所有日子中，没有一天不在头脑的静默回忆中看到我可爱的小女儿的粉红小脸。你也有这么好的孩子，约翰。不要为了几棵树木而失去了整片森林。你能够给予孩子们的最好馈赠就是你的爱和关心。像第一天见到他们那样去重新认识他们。一定要让他们明白，他们对于你来说，要比职场事业中过眼云烟般的名利回报重要得多。不久之后他们就会长大，就会一个个离你而去，去建立自己的家庭和生活，去建立自己人生中的失落和幸福。到那时候你再表白你对他们的珍惜就太迟了，时间一去不复返。**” \n 毫无疑问，朱利安拨动了我心底最深处的那根弦。我猜我在有些时候已经隐隐约约察觉到了，我的工作狂心态正在慢慢地瓦解着我和家庭的联系。这种瓦解就像是余烟缭绕的火苗，静静地燃烧，缓慢地积攒力量，直到有一天向四面八方爆发出毁灭性的能量。我知道孩子们需要我，我也知道内心中我多么眷恋他们，尽管我们谁都没有对彼此说过这样的话。我需要朱利安的提醒。时间飞逝，孩子们长大得太快了。我已经记不起来，我和儿子安迪最后一次在清新的周日早晨，偷偷地跑到他的祖父最喜欢的钓鱼池边度过一天的确切时候了。曾经有一段时间我们一起快乐地度过每个周末。而现在，这个由来已久的习惯简直就像是别人回忆中的故事了。 我越想越感到内心沉重。安迪在学校里的钢琴独奏会，圣诞节的化妆演出，还有他的少年棒球联赛，我一个都没参加，都被我用来换取事业上晋职升迁了。那么安迪的心中会怎么想呢？天哪，他千万不要以为我把工作看的比他更重要啊！ \n “我都做了些什么啊？”我抱着头苦苦思索。我的确已经身不由己地滑到了朱利安所描述的灾难的边缘。好吧，接下来，我决心要改变一切。 \n** “幸福犹如一场没有终点的旅程，”朱利安继续说，他的声音已经滤去了刚才的感伤和波动，再一次因为饱含热情而高昂起来，“这也是你给自己创造的一次机会。你可以一直顺着那条铺满钻石的曲折小路向前走，也可以继续草草挥霍所剩的时间，追求彩虹尽头的那一坛黄金，最终却发现这不过是一场空。欣赏每一天中的任何一个不同的时刻吧，因为今天才是你完全拥有的一天。**” \n “每个人都能学会‘活在当下’吗？”我问道。 \n “当然。无论你目前的境遇怎么样，你都可以训练自己，学会欣赏并且珍惜生命和家庭的馈赠，在每一天的生活中都使自己的存在充满了珍宝般的价值。” \n “但是这是不是有点太过于乐观了？要是有谁在一场糟糕的商业交易中损失了一切，他该怎么办？我们不仅是说他们的经济破产了，而且指的是他们精神上也完全垮掉了。” \n “唉，”朱利安轻轻叹息，“**我就是希望人们知道，你在银行户头上有多少存款，或者你住的房子是大是小，根本就和你能不能带着欢乐的情绪和好奇心去生活毫无关系。这个世界上开心的穷光蛋不多，可闷闷不乐的百万富翁到处都是。如果你学会在一天里抽出5分钟来练习感恩的艺术，你就会得到一直在寻找的丰富生活。就连你在举例中说到的那些人也可以发现，生活中其实还有很多东西值得他们去一再感恩，即使他们遭遇到了可怕的经济困境和精神困境。让我们去问问他，是不是还拥有自己的健康，是不是还有可爱的家庭和社交中的好口碑？他难道不以在这个伟大的国家里拥有公民资格而感到幸福吗？他的头顶上难道不是还有一方遮风挡雨的屋顶吗？也许他不再拥有成功时的霸气，不再有事业顺利时的大笔财富，不能重复一掷千金的气概，不能随心所欲地签支票购买所有感兴趣的东西。然而，还有另外一些财富是他应该用一生的时间来感恩的。我们都有很多需要感恩的东西。即使是阳光灿烂的夏天里，一只鸟儿在你的落地长窗前面婉转啼鸣，一个睿智的人也会认出来它们其实是上天赐予的馈赠。记住，约翰，生活并不总是给你想要的东西，却永远会给你需要的东西。**” \n\n我们都有命里注定要去完成的事情。当你发现更高的目标，投入所有的精力时，你的才能将会迸发出来，幸福会充满你的生活。一旦你认识到你的使命，无论是成为一位成绩突出的教育孩子们的老师，还是做一个灵感丰富创作惊人的艺术家，所有的愿望都会轻而易举地被实现。你甚至都不必先去尝试。不瞒你说，我觉得你越是先去尝试，在目标实现之前所花的准备时间也就越长。相反的是，只要你跟随梦想的道路，所有在期望中想要获得的东西都一定会纷至沓来。它将引领着你走向神圣的终点。这就是我所说的铸就命运的含义。\n\n## 极乐世界？\n不幸的是，约翰，你听到彼得的故事，还有那根奇妙的魔法线仅仅是一个故事，一个神话故事。而我们此时正生活在一个绝对现实的世界里，根本没有第二次机会让你重新来过一遍，去实现圆满的人生。今天，唯有今天才是你领受生活馈赠的时机——在还不是太晚之前。约翰，让这新的一天成为你人生中的分界线，你在这一天完完全全下定决心，把所有的精力都集中在对你来说是真正重要的事情上。你要下定决心，在那些可以使你的生活具有更有意义的事情上多花些时间。对生命中特殊的时刻心存敬畏，为它们的蕴含而沉醉。做那些你一直想要做的事情。去爬你一直想要去攀登的高山，或者去学一种乐器，自己做一支曲子，写一首歌词。在大雨天冲出去跳舞，或者另起炉灶从事一门新职业。学会热爱音乐，聆听音乐和鉴赏音乐，学会一门新的外语，重新点燃童年的欢乐时光。不要出于成功的考虑就把幸福向后推延。相反的是，开始学会欣赏过程中的美，重新振作你的精神，认识你的灵魂并且开始爱护它。这就是通向极乐世界的道路。” **\n  \n ** “极乐世界？**听起来像佛教里的词语？”我重复着。 \n  “**极乐世界不单单是佛教里的词语。喜马拉雅山上的智者相信，真正开悟了的灵魂要前往的最终目的地是一个名叫极乐世界的地方。事实上，它不仅仅是一个地方，智者相信极乐世界是一种状态，人们可以超越此前他们所知道的一切。在极乐世界中，一切都是可能的。那里没有苦难，生命的舞蹈奔放到了极致，神圣而完美。在抵达极乐世界的途中，智者感到自己正在走向天堂。这就是他们人生中的最终目标。”朱利安总结说，他的脸笼罩在安宁之中，简直就是天使的模样**。 \n  “**我们之所以在这里都是出于某些特定的原因，”他预言般的继续总结着，“静心思考真正召唤你的是什么，想一想你将怎样帮助他人。不要再做惯性和惰性的奴隶，不要再拿贷款作为不快乐的借口。今天，用人生真正的意义点亮你的生命火花，让它明亮地熊熊燃烧起来。开始练习我和你分享的那些道理和方法，去做你能做的一切。当你感到内心里非常渴望尝到极乐世界果实的滋味时，那一时刻就会自然来临。**”朱利安眼睛里的光芒使他看上去像一位神殿里的预言祭祀。 \n\n## 开悟\n“会有一些微小的迹象出现，向你显示极乐世界的入口。你开始注意到身边每一件事物当中蕴含的神圣性：比如一束月光的完美，炎热夏季里湛蓝的天空所具有的吸引力，雏菊盛开时的芬芳，或者小孩子淘气的大笑声。\n  ”我听出他的语气中充满鼓励。 “朱利安，我向你保证，你和我在一起度过的时间不会白白浪费掉。我准备让自己完全按照智者的智慧来用心地生活，而且我将信守承诺，把我从你那里分享来的所有知识，和那些可能会从中受益的人们一起温习。我说这些话是发自内心的。我向你保证。\n  ”我真诚地说道，感到内心里激情涌动。 “把智者的丰富智慧统统传播给身边所有的人们吧。他们很快就会从中受益，提升他们的生活品质，就像你提升了自己的生活品质一样。而且还要记住，要享受过程本身，沿途和终点一样美好。” \n  我请朱利安继续说下去。他说：“瑜伽师拉曼是一个非常伟大的讲故事的人，但是有一个故事在他讲给我的所有故事当中显得与众不同。现在我可以讲给你听吗？” \n  “当然好啊，你知道我一直在聆听你的每一句话。” \n  “很多年以前，在古老的印度，有一位王侯准备为他的妻子修建一座宏大的建筑，作为他对妻子的深爱和感情的象征。这个王侯想创造出一种世界上从来都不曾见到过的建筑结构，它将在月光照耀下的夜晚里微微放光，让世世代代的人们都因为仰慕而特地赶来朝拜。于是，他的工匠们每天都忍受着酷暑骄阳，一砖一瓦地劳作。每过一天，结构就更加清楚一点，越来越像一座丰碑，也越来越像爱的灯塔，直指蔚蓝色的印度天空。最后，在经过了日复一日的20年的重复劳作之后，这座完全用白色大理石建成的宫殿终于竣工了。你猜一猜我说的是什么？” \n  “我对印度的文明几乎一无所知。”我老老实实地承认。 \n  “就是泰姬陵。”朱利安回答我说，“我的意思很简单。这个星球上的每个人都是一个奇迹。从某种意义上来说，我们中的每一个人都是天才，都是英雄。我们中的每一个人都有潜力取得超凡的成就，取得巨大的幸福感和永恒的满足感，所需要的只是朝着我们梦想的方向踏实前行。就像泰姬陵的建筑过程一样，在简单重复的劳动中整整耗时20年。**一个充满生命的奇迹就是这样日复一日，一砖一瓦建成的。小的成功会通向大的胜利。微小的、循序渐进的变化将会在一起形成积极的习惯。而后，积极的习惯会带来好的成果。积极的成果则会激励你继续朝着更加伟大的个人目标去努力。开始像对待生命中最后一天那样过好每一天的生活。从今天开始，多多学习，多多大笑，去做你真正喜欢做的事情。不要逃避自己的命运，更不要否定自己的命运。因为和存在于你自身中的那些珍贵的东西相比，那些身前身后的浮云名利根本都是无关紧要的。**” \n\n如上是内容摘要，如果想更细的了解，可以购买相应的图书。这个内容是需要不段实践才能看到效果。加油吧，共同探索。\n\n","slug":"读书/《卖掉法拉利的高僧》摘要 ","published":1,"updated":"2018-07-17T04:37:49.667Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvop3bqf00cks77r47sen429","content":"<p>这是一部有方法的个人价值实现指南。故事以对话的方式讲述，在审视自我的过程中，重新发现想要的生活。</p>\n<p>刚开始看到这个书名时，感觉是一本精彩的小说，这么少的文字，被翻译成70多种语言，一定很有意义，就试着读了读。读了之后才发现这是一本实践性很强的自我价值实现指导书，里边有非常具体的方法论及使用方法，同时被里边的故事吸引了。</p>\n<p>本书通过瑜伽师拉曼一个寓言，来讲解充满丰富精神内涵的七项品质，这个寓言里，包含了人生的奥妙。下面就开始吧。</p>\n<p>“闭上眼睛，在脑海中浮现出以下画面……”<br>你坐在一个漂亮的、郁郁葱葱的花园当中。花园里满眼都是你所见过的最引人陶醉的鲜花。四周极度寂静，了无声息。品味这花园带给你的快乐，想象自己有大把的时间来欣赏这片自然的绿洲。若你向四周环顾，就会看到，在这个神奇花园的中心伫立着一座高耸的、六层高的红色灯塔。<br>突然，花园里的静默被一阵嘈杂的吱吱嘎嘎声打破，灯塔底部的门被打开了。跌跌撞撞地走出来一个两米七高、四百公斤重的日本相扑选手，他是在不经意间闯进花园中心的。<br>“下面就更有意思了，”朱利安哧哧笑着说，“那个日本相扑选手几乎全身赤裸，只有私处覆盖着多股丝线织成的粉色带子。”<br>然后这个相扑选手开始在花园里走来走去。他找到了一个闪闪发亮的金质秒表，不知是谁很多年以前遗留在那儿的。他不小心踩在秒表上，“砰”的一声巨响，结结实实地摔倒在地上。这个相扑选手变得毫无知觉，无声无息地躺在那里。就在你觉得他就要咽下最后一口气的时候，他慢慢地苏醒过来了，可能是因为受到附近那些黄玫瑰芬芳的刺激。仿佛吸收了新的能量似的，这个选手一跃而起，下意识地往左边望去。他被眼前的一幕惊呆了：<br>透过花园边上的灌木丛，他看到一条蜿蜒曲折的林间小路，路上覆盖着数不清的闪闪发光的钻石。仿佛有一股神奇的力量，他渐渐地被吸引，顺着那条路慢慢地走了过去。就是这条路把他带上了充满无尽快乐和无上幸福的大道上。 </p>\n<p><strong>基于以上故事，引出的七个品质</strong></p>\n<h1 id=\"花园，代表心智\"><a href=\"#花园，代表心智\" class=\"headerlink\" title=\"花园，代表心智\"></a>花园，代表心智</h1><p>心智的控制要通过心理调节才能奏效</p>\n<p>不管你的生活中发生了什么样的变故，你都一直有权利选择自己对待事件的反应态度。当你养成了在每件事情当中都认真寻找积极因素的习惯时，你的人生就会变得鲜活有趣，生活就会升华到最高境界。</p>\n<p><strong>你的外在世界其实就是内心世界的外显。通过控制自己的想法，控制你对人生中每件事情的反应，你就能够开始掌控自己的命运。</strong></p>\n<p>我要郑重地建议你，不要动不动就贸然判断一件事情究竟是积极的，还是消极的。你最好先去经历它们，赞美它们并认真从中学习。生活中的每件事都会教你一些东西。它们是你完善内在世界和外在世界的力量。如果没有它们，你就会停滞不前。想一想它们在你生命中起到的作用吧。大部分人的生活之所以经历了突飞猛进的成长，起因都是因为遭遇到最具有挑战性的人生经历。假如结果让你有些出乎意料，也许会让你感到微微的失望，这个时候你就好好地想想自然的法则吧，因为它总是会确保在一扇门关闭的同时打开另一扇门。所以说，失败中潜藏着成功，挑战与机遇同在。一旦你把这个原则持之以恒地应用到你的日常生活中，以此为标准，努力训练自己的心智，积极地看待每件事情，善于从中汲取力量，那你就会永远忘却那些不必要的烦恼。你将不再是逝去的时光的囚徒，而将成为规划自己未来的设计师。</p>\n<p><strong>除此之外，我还应该做些什么呢？</strong><br>首先，<strong>开始依靠你的想象力而不是记忆力来过日子。</strong><br>我想说的就是，要想释放你心智的、身体的和灵魂的潜能，首先就得学会扩展自己的想象力。你看，事情通常都会发生两次：第一次是在头脑中形成；接下来才会在现实中发生。我把这个过程称之为‘蓝图’，因为你周围发生的任何事情都来源于你脑中的蓝图。要是你学会了控制自己的想法，学会了生动地想象所有你期望的东西，蛰伏在你身体内的意志力就会渐渐苏醒。你就能够释放出心智中真正的潜力，从而创造出一种神奇的生活。从今天晚上开始，你就可以尝试努力忘掉过去的一切，大胆地想象比现实状况好得多的生活，去想象生命中最好的境界。你会为梦想的结果而感到惊讶。 </p>\n<p><strong>获取幸福的奥秘其实很简单：</strong>找到你内心中最喜欢做的事情，然后把自己所有的精力都集中到那个方向，然后付出自己最大的努力。如果你对我们这个世界上最幸福、最健康、最心满意足的人做一个抽样调查，你就会发现，他们中的每个人都寻找到了生命中属于自己的热情，然后用一生的时间去追求它。这种使命感在某种程度上还可以为其他人服务。一旦你把自己的心智能量和生命力全都集中在了你所热爱的追求上，你的生活就会变得丰富多彩，目标的实现也会变得轻松而愉快，就像你在车库边哼着小曲边贴壁纸一样，充满了闲适的乐趣。</p>\n<p>湿婆神的智者每天都要花时间静思默想，不仅思考自己身在何处，还要思考自己将去何方。他们每天都在思考，最重要的是，他们尤其重视如何通过思考指导自己不断进步，哪怕这种进步看起来是如此的微不足道。因为他们知道，只要每一天都获得一些微小的进步，那么日积月累就会产生持久而有效的成果，反过来就会引起精神世界的巨大改观。</p>\n<h2 id=\"玫瑰之心\"><a href=\"#玫瑰之心\" class=\"headerlink\" title=\"玫瑰之心\"></a>玫瑰之心</h2><p>“有一种控制心智的方法要远远地胜过其他方法。这是瑜伽师拉曼钟爱的方法，也是在他教给我的所有方法中最好的一个。在接受了这项指导以后，我仅仅练习了21天，就感到精力旺盛，比我在青壮年时期都更加热情饱满、活力四射。这个练习法已经有四千多年的历史了，它的名字叫作‘玫瑰之心’。”<br>“‘玫瑰之心’？很文雅的名字嘛。能不能给我讲得再具体些呢？”<br>“<strong>你用这个方法进行练习时，只需要准备一朵鲜艳的玫瑰和一处安静的地方。自然的环境当然最好，不过在一个安静的房间里也可以做得很好。一开始，你要集中注意力凝视玫瑰的花心，这就是它的心脏。瑜伽师拉曼告诉过我，所谓一花一世界，一朵玫瑰花如同一个生命：在路上你会遇到尖刺，但是如果你有信心，坚信自己的梦想会实现，最终就会越过那些尖刺，进入灿烂的鲜花世界。你要学会目不转睛地凝视着这朵玫瑰，感觉它的颜色、质地和模样，深深地呼吸它的芬芳，头脑中浮想着那些无限美好的事物。在这个过程中，别的念头会悄悄溜进来，慢慢侵入你的心智，分散你的注意。这是没有经受过特别训练的心智的特征。不过你不必为此担心，这种状况将很快就得到改善。你只需要把注意力再次返回到花心点上来。很快，你的心智就会因为经受了成千上百次的训练而变得强大有力。</strong>”<br>“要做的只有这么多吗？听起来确实再简单不过了。”<br>“这就是这个方法的优点，约翰，”朱利安回答说，“不过，<strong>这个方法必须每天坚持做才会起效。在开始的几天里，你会感到这种练习看上去容易，做起来却有很大的难度，也许你连5分钟都坚持不到。这也说明我们大部分人的生活节奏太快，都好像得了躁狂症一般，真正的安宁和沉默仿佛是宇宙之外的东西，让人感到很不舒服。</strong>  很多人听到‘玫瑰之心’的建议之后都会说他们没有时间坐下来盯着一朵花傻乎乎地看上半天。有趣的是，也是这帮人还会向我诉苦说，他们没有时间享受孩子的笑声，也没有时间光着脚在雨中漫步。这些人们总是抱怨说他们太忙了，没有时间过那种闲适的生活。他们甚至没有时间去结交新朋友，因为建立友谊也是要占用大量时间和精力的。” </p>\n<p>“<strong>要学习持之以恒的信念，花越来越长的时间去感知花心</strong>，”朱利安继续用他低沉的声音说，“<strong>也许在一两个星期以后，你就差不多可以在这个练习中坚持到20分钟，而不让自己的思想分散到其他的事情上去。这将是你修心养性并有所获得的第一个标志，你夺回了心智的控制权。你命令它关注哪个事物，它就会把注意力集中到哪个事物上去。那时，心智就成了最好的仆人，可以为你完成许多不可思议的事情。记住，不是你控制心智，就是它反过来控制你。</strong>” </p>\n<h2 id=\"静思默想\"><a href=\"#静思默想\" class=\"headerlink\" title=\"静思默想\"></a>静思默想</h2><p>湿婆神的智者每天都要花时间静思默想，不仅思考自己身在何处，还要思考自己将去何方。他们每天都在思考，最重要的是，他们尤其重视如何通过思考指导自己不断进步，哪怕这种进步看起来是如此的微不足道。因为他们知道，只要每一天都获得一些微小的进步，那么日积月累就会产生持久而有效的成果，反过来就会引起精神世界的巨大改观。</p>\n<p>最少每天抽出10分钟也是可以的。</p>\n<h2 id=\"对立思维法\"><a href=\"#对立思维法\" class=\"headerlink\" title=\"对立思维法\"></a>对立思维法</h2><p>在消除内心烦恼和其他负面情绪方面，还有一项特别有效的技巧。这项技巧建立在瑜伽师拉曼称之为‘对立思维法’的基础之上。<strong>在伟大的自然法则下，大脑在同一时间只能拥有一个想法。</strong><br>因此，任何人都可以在短暂的时间内很轻松地创造出一种积极、有新意的思维。过程简单而直接：如果有一个令人不快的想法在头脑中占据了主要的位置，就马上试着用一个鼓舞人心的想法去替代它。你的头脑就好比一个非常巨大的幻灯放映机，出现在头脑中的每一个念头都仿佛一张幻灯片。每当银幕上出现了令人不悦的画面，就用最快的速度拿起一张内容积极的幻灯片去替换掉它。</p>\n<h2 id=\"湖水的秘密\"><a href=\"#湖水的秘密\" class=\"headerlink\" title=\"湖水的秘密\"></a>湖水的秘密</h2><p>每件事情都会发生两次，第一次发生在头脑中，第二次是在现实中得到印证。我已经意识到思想也是现实，是物质性的信息，当我们把思想散播出来，其实也就改变了现实的世界。我也曾经对你说过，如果你希望在外部世界中获得显著的改善，首先就得从内在精神世界的改善开始，要学会改变你自身的思想与品格。<br>“喜马拉雅山上的智者有一个很好的办法来确保他们思想的纯净，而且有益于身心的发展。这个方法在把人的内在愿望转化为现实力量方面也显得极为高效，尽管它很简单。而且这个方法对任何人都有效。无论是汲汲于扩充人生财富的年轻律师，还是希望丰富家庭生活的妈妈，或者是希望完成更多销售量的推销员，都可以从这个方法中受益。智者给它命名为‘湖水的秘密’。在训练这个方法时，智者早晨四点钟就起床洗漱了，因为他们认为清晨时光之中包含着神秘的要素，他们可以从中感受到宇宙的脉动。这些智者沿着陡峭而狭窄的山路缓缓行走，这些道路最终把他们引向河流的下游。他们到那儿以后，就顺着一条几乎看不出来的小径继续走，两边是伟岸的青松和异样繁茂的鲜花。他们就这样一直走到一片开阔的空旷地。空地边上是一汪青绿色的湖水，这时水鸟还在沉睡，四周一片寂静。那种安静平和的情景仿若仙境。智者告诉我说，这个湖在很早很早以前就已经是他们祖先的朋友了。”<br>“<strong>‘湖水的秘密’是什么？</strong>”我不耐烦地打断了他的话。<br>朱利安不急不躁地解释说，<strong>智者会观察平静的湖水，想象他们的梦想化为现实。湖水如同一面命运的镜子，所有的欲望都能够完整地投射于其上。如果他们希望在生活中养成训练有素的良好习惯，他们会想象出自己在凌晨起床的样子，一丝不苟地完成他们严格的身体养生锻炼，时间在静默无声地提高个人意志力量的过程中悄悄流逝。如果他们想要寻找更多的快乐，就会满怀喜悦地注视着湖面，想象自己毫无节制地大笑的模样，或者回想自己遇到兄弟姊妹时在脸上浮现出的发自内心的微笑。如果他们寻求勇气，就会想象自己在面对危机和挑战的时刻是如何非常有力地行动着。而湖水就像一位仁厚的智者给他们以巨大的支持。中国人所说的“仁者乐山，智者乐水”，也许就是这个意思。</strong><br>“还有一次瑜伽师拉曼悄悄对我说，当他还是个孩子的时候其实也非常缺乏自信心，因为他比同龄男孩的个头要小得多。虽然他们的教养都很好，依然能够态度温和地对待他，可在自卑感的暗示下，他还是变成了一个害羞的、没有安全感的人。为了弥补这个欠缺，拉曼独自来到那个天堂似的所在，把湖面当作内心映像的屏幕，尽力想象他所希望成为的那种人的形象。有些天里他看到自己成为了强有力的领导者，坐在高高的殿堂上，声音宏亮而果断地发号施令。而另外一些时候，他会看到自己老年的形象：一个博学的智者，具有无限的内在潜力和坚韧的性格。所有他希望在自己的生命中能够拥有的美德，他全部都在湖面上先看到了。<br>“通过几个月时间的静观，瑜伽师拉曼真的成为了他在意念中看到自己想要成为的那种人。你看，约翰，心智就这样通过头脑的想象产生了巨大的效果。<strong>内心的图像可以影响到你的自我想象，而你的自我想象又会影响你在感觉、行动和进取方面的方式。</strong>如果你的自我想象告诉你，你太年轻，成为不了一名成功的律师，或者你年纪太大，改不掉那些坏习惯，那么你就永远不能实现这些目标。如果你的自我想象告诉你说，要过一种丰富的、有目标的生活，要有良好的健康状态和幸福感，这些不仅是为了你自己，也是为了身边人们的幸福，那么这类预言最终会成为你的现实。<br>“而且，当你在头脑的屏幕上播放这些令人欢欣鼓舞的图像时，良好的变化就会开始显现在你的生命里。爱因斯坦曾说过，想象力比知识更加重要。<strong>每天你都得抽出一些时间来进行冥想，即使只有短短的几分钟，也要有意练习创造性的想象。</strong>在这一刻，尽可以把自己视作自己希望成为的那种人，不管这个形象是一位大法官，还是一个好父亲，或者是社区里的一个好居民。”<br> “我知道，这一定是一个非常古老但是也非常有效的办法。我的孩子在看《哈里・波特》，里面有一面魔镜，波特照镜子的时候看到了他父母的模样，而他的好朋友红头发的荣恩照镜子时看到的却是自己成为了全校国际象棋冠军的时刻。镜子折射出的形象往往是自己最渴望见到的模样，畅销书就是这样感动我们的，不是吗？”我毫无顾忌地说出自己的想法。“还有啊，我一定要找到一汪特殊的湖水才能练习‘湖水的秘密’这个方法吗？我一定要每天一大早跑到郊外去苦思冥想吗？”我忍不住继续问，“你知道，这对生活在都市中的人来说简直是天方夜谭啊。”<br> “你不必这么循规蹈矩。<strong>‘湖水的奥秘’只是智者对这个古老技巧给出的一个称呼而已，其目的是要用积极的想象来影响心智，并不是让你拘泥于其中。你可以根据自身情况灵活机动地作出调整，比如在自己的客厅里，甚至就在办公室里来练习这个方法。只要你真的想这么做，那么随时随地都可以。</strong>你可以试一试，先关紧房门，关掉手机，闭上眼睛，然后慢慢地做几次深呼吸。两三分钟之后你就会注意到，你真的开始感到周身放松。接下来，在头脑里想象出所有你希望的东西，想要拥有的，或者想要达到的。如果你想成为世界上最好的父亲，就想着自己正在开怀大笑，你的孩子们正围着你快乐地玩耍，而你呢，则不厌其烦地解答他们各种各样匪夷所思的问题。你还可以想象自己举止优雅、充满爱心的样子。通过这种方法，先在头脑中演练自己的形象，等到相仿的场景在现实的情境中真的出现时，你就可以完全施展自己的潜能了。<br> “想象自己形象的方法可以适用于很多种情况。你可以利用它来使自己在法庭辩论中更富有逻辑，你可以利用它来改善自己的人际关系，当然你也可以借此发掘自己的精神潜能。持之以恒地使用这种方法还会带给你社会声望的回报，以及丰厚的物质收获，如果你觉得这些东西对你很重要。<strong>如果你觉得生活中缺少了什么，那是因为你的头脑中并没有这种东西。记住，要在头脑中留住美好的画面。一旦你开始练习这种方法，它就会让你彻底领会到心智所具有的神奇威力，开启大脑的潜力，它实现你生命中一切渴望的东西。</strong>”<br> “瑜伽师拉曼和与他居住在一起的<strong>智者都经常提到一句老话，这句话世代相传，流传至今。我很幸运在这个对我们两个来说都很重要的夜晚将这句话转告给你。话是这么说的：“凌驾于他人之上毫无尊贵可言；真正的尊贵是超越以往的自我。’如果你想达到我真正达到的那个境界，与你认为有意义的东西并驾齐驱的话，你就必须首先和自己赛跑，向自己发起挑战。何必在意别人怎么议论你呢？最关键的是你自己的想法。只要你能够确定自己的所作所为是正确的，就不要总是去在意他人的眼光，那样会让你变得畏首畏尾。你要告诉自己，你可以做任何你想做的事情，只要你的良知和内心都认为它是对的。千万不要为自己做了正确的事情而感到害羞。根据你所认为的好坏标准来作决定，然后毫不犹豫地坚持这种看法与做法。一定记住，千万不要堕入那种器量狭隘的计较之中，把自己的自尊和别人的非议评判作比较。就像瑜伽师拉曼倡导的那样，‘你在思考他人的梦想时耗费掉的每一分钟，都会将你到达自己梦想的时刻向后推迟一分钟。’</strong>”<br>现在已经是半夜十二点零七分了。和平常不一样的是，我丝毫也没有感觉到疲惫。当我把这种感觉告诉朱利安时，他又一次露出恬静的微笑：“你已经学会了另一种开启生命的方法。就大部分人来说，疲惫是心智匮乏的产物。没有梦想、没有方向感的人所过的生活常常是碌碌无为、疲惫不堪的。让我给你举一个例子。你有没有这样的体验，比如整整一个下午待在办公室里，强迫自己阅读那些干巴巴的案情报告。很快，你的心智就开始溜号，然后你也逐渐地睡意蒙眬起来？”<br>“有时候的确是这个样子的。”我回答说，其实内心并不愿承认，但事实上这恰恰正是我目前的工作常态。“当然，我们大多数人都会在遵循惯例、按部就班的工作中感到昏昏欲睡。”<br>“可是，如果有一个朋友打电话来，问你想不想晚上出来一起看场棒球比赛，或者请你为他的周末高尔夫球比赛出谋划策，我敢说你一下子就精神起来了，任何疲惫的痕迹都一股脑儿地飞到爪哇国去了。我说得对吧？”<br>“我承认确实如此，尊敬的顾问先生。”面对朱利安我只好讲实话，当然也故意用一种油腔滑调的语气来掩盖自己被人窥破心思时的不安。<br>朱利安从我的语气中知道他抓住了问题的关键，于是他更来劲了。“所以，你的疲惫不是别的，无非是匮乏的心智的产物。你的心智养成了坏习惯，当你从事一项单调而冗长的工作时，心智就成了挡路石。很明显，今天晚上你被我讲的故事吸引住了，开始对我希望与你分享的智慧感兴趣。<strong>记住，你的兴趣爱好和心智注意力都会给你的日常生活带来源源不断的活力。在这个晚上，你的心智既不再关注过去，也不再关注未来，它就聚焦在当下，聚焦在我们的话题上。如果你经常把心智引向当前的生活，你就一定会得到无尽的活力，不管钟表上指示的时间是深夜十点钟还是十二点钟。</strong>” </p>\n<h1 id=\"灯塔，代表目标\"><a href=\"#灯塔，代表目标\" class=\"headerlink\" title=\"灯塔，代表目标\"></a>灯塔，代表目标</h1><p>在花园的中央伫立着一座明亮的灯塔。这个象征提醒你记起另一条启示生命奥义的古老原则：<strong>生命的目的就是有目的地生活。</strong>那些真正开悟了的人们知道他们将要从生活中得到什么，比如情感的、物质的、身体的，或者是精神的。他们把先后的顺序排列得清清楚楚，经过严密的统筹安排之后，生活中每个方面的目标都会发挥出类似于灯塔那样的作用，在海面上风起浪涌的时候会给你指引航向，为你提供安全的避难所。你看，约翰，只要彻底地改变了人生的进取方向，任何人都可以将自己的生活来个焕然一新的改变。但是如果你根本不知道你从哪儿来，又要到哪里去，那你又怎么可能知道自己什么时候会到达那个不知所终的地方呢？</p>\n<p>“生命真是太奇妙了，”瑜伽师拉曼大发感慨，“人们可能会认为一个人工作得越少，就越有机会体验到闲适的幸福。然而并非如此，或者说这是片面地理解了幸福的含义。<strong>一言以蔽之，幸福的真正源泉就是一个词：成就。</strong>永恒的幸福来自于为了完成目标而进行的脚踏实地的工作，来自于在接近人生目标的过程中持之以恒的努力。只要点燃潜藏在内心中的火焰，它就会创造出一个令你我无法想象的新世界。我知道这听起来多多少少有点讽刺，因为我不辞辛苦离开自己以事业成就为本位的社会，艰难跋涉了几千里路，向居住在喜马拉雅山高峰上的神秘智者请教，希望得到关于幸福的永恒奥秘，却听说孜孜以求的幸福奥秘在于成就，可事实的确如此。</p>\n<p>成就并不一定需要用物质来衡量。就我个人而言，我的目标就在于获得内心安宁，学会控制自我，学会了悟人生。如果直到生命的尽头，我还是不能达到以上这些目标，我相信我会死不瞑目，因为我没有抵达自己的圆满状态。</p>\n<p>我的意思其实很简单。当你已经明确知道在你的一生当中最希望达到的目标是什么，不管这些目标是物质的、情感的、身体的还是精神的，你都要为抵达这一目标而倾注大量的时间与精力，只有这样才能最终体验到永恒的欢悦。你的生命将和我的生命一样充满快乐，而且你将逐渐看到自己的梦想一步步演变成为光灿灿的现实。但是这一切的前提在于，你必须首先了解自己，制订出明确的人生目标，然后通过持续不懈的努力把它转化为现实。我们称其为“达摩”，这是一句梵语，意思是‘生命的目标’。</p>\n<p><strong>很多人在发现了自己存在的真正目标之后马上放弃了限制自己人性发展的工作，即便这项工作为他们赢得了巨大成功和丰厚的物质回报。</strong>这的确像是一场冒险，伴随着对自我的研究和灵魂的探索，你要学会不断地丢弃一些身外之物。可是也不能完全将它说成是一项冒险，因为在发现自我和人生的使命方面原本没有什么风险可言——在智者看来，发现自我这项工作本身就是人生体验中相当重要的一个环节。自我认知是开启人生的DNA生命链，它的确是生命中最关键的东西。</p>\n<p>我的达摩相当简单：无私地帮助他人，丝毫不考虑任何回报。记住，你不能在呼呼大睡中发现人生真正的快乐。同样，在游乐场或者像个游手好闲的人那样恣意消磨时光，也不可能抵达人生的真知。正如本杰明・迪斯雷利[3] 说的那样：<strong>“成功的秘密在于不屈不挠地坚持自己的目标。’你所寻求的幸福是从有价值的目标中得来的，你付出所有的精力去争取成功，每天、每小时都努力地去接近这个目标。这是永恒哲理在现实生活中的应用，它规定了哪些事情是最重要的，永远不能被另外一些不重要的事情掩盖掉。在瑜伽师拉曼的寓言里出现的灯塔会一直提醒你，制订明确而有意义的目标有多重要，以及实现这些目标需要怎样的力量。</strong></p>\n<p>确立目标是最基本的出发点。制订出你的方向和目标，就可以把创造力的潜能加以放大释放，最终促使你踏上通向目标实现的道路。信不信由你，瑜伽师拉曼和其他智者都热衷于不断设定目标*。</p>\n<p>把我所有的智慧都和你分享。今天的这个例子就是为了进一步说明在人生中设立一个明确目标，以及清楚地知道你将往哪里去的重要性。你刚才见到的那一幕就说明了这个最为重要的原则：<strong>你一定不可能命中你根本看不见的目标。人们用去整整一生的时间来希望自己变得更加幸福，活得更有活力，拥有更加丰沛的激情，然而他们没有发现这个重要原则。你要学会，每个月抽出10分钟的时间，把自己的目标写出来，仔细地想一想生活的意义何在、人生根本目的何在。设立一个明确的目标可以让你的人生过得与众不同。你会变得更加丰富，更加愉快，拥有更加不可思议的精力。</strong></p>\n<p>任何一个希望同时提高自己的内心品质和外在条件的人都要学会定期拿出一张白纸，认真地在上面写下自己的人生目标。</p>\n<h2 id=\"一页纸在上面写出自己的目标\"><a href=\"#一页纸在上面写出自己的目标\" class=\"headerlink\" title=\"一页纸在上面写出自己的目标\"></a>一页纸在上面写出自己的目标</h2><p>此前我已经告诉过你，我们的头脑中平均每天会出现60,000个想法，然而这些想法太多了，多得你自己都容易迷失在欲望的丛林中。这个时候，在一张纸上写出你的愿望和目标就显得尤为关键。这一举动意味着你给潜意识的幽昧丛林中插上了一杆红旗，让这个想法比其余的59,999个想法突出得多。你的心智因此就像雷达一样，开始寻找一切机会去实现你的愿望。这个过程的确非常有效，可惜我们当中的绝大部分人对此视而不见。</p>\n<p>愿望成真，一共需要有五个步骤<br>第一步是要对自己预期的结果有清楚而具体的认识。第二步是制造一种积极的压力来鼓舞自己。相对来说，第三步是非常简单的，那就是绝对不要好高骛远，设立一些不合时宜的目标。当你决心将人生和某一个目标相连，就意味着你必须给它设定一个明确的最终实现期限。这就如同你在为庭审准备大量的卷宗，你的注意力会一直集中在法官身上，因为他将决定庭审的日程安排。相反，其他人的话对你似乎没有任何影响。<br>让我们回到达到目的、实现目标的五步法上面吧。一旦你对未来的结果有了一个非常清晰的成形设想，也为此创造出了一点积极的压力，并划定了最后实现的期限，甚至当众许下了完成它的诺言，那么接下来要做的一个步骤就是瑜伽师拉曼称之为‘神奇的21天法则’的方法了。<br>最后我所说的就是，在你实现自己目标的过程中，一定要确保自己随时处在兴致盎然的状态。永远也不要忘记纵情狂欢的重要性，永远也不要忽视在所有的生命中都能看到精致的美丽。今天，以及你我一起分享智慧的这一刻都是上天的恩赐。保持你昂扬的精神、愉快的心情和好奇心。随时都要密切关注自己的毕生事业，随时都准备好要给予别人无私的帮助。宇宙对万物都一视同仁，这也是大自然的真理法则之一</p>\n<h2 id=\"热情\"><a href=\"#热情\" class=\"headerlink\" title=\"热情\"></a>热情</h2><p>热情。这个词汇你一定要始终牢记在头脑里面。热情是实现梦想最根本的动力源泉。在我们这个碌碌无为的社会中，生命的热情早已经消失了。有的时候我们之所以什么也不愿意做，那是因为我们喜欢这样一直待着。而当我们开始动手做事情的时候，则是因为我们感到不得不做，只好没精打采地应付差事。这就是制造痛苦恶性循环的公式。不过我现在说的并不是那种浪漫的热情，尽管那也是促进成功、振奋人生的要素之一。我现在所说的是对生活的热情。每天早晨醒来时就要不停地对自己加油鼓劲，让自己浑身活力充沛，快乐无拘。热情是你工作中的加油站，热情的火焰越烧越旺，那么通向自信与成功的道路就越光明。你很快就会有丰厚的物质收获，同样还会获得精神上的巨大回报。</p>\n<h2 id=\"禅悟\"><a href=\"#禅悟\" class=\"headerlink\" title=\"禅悟\"></a>禅悟</h2><p>意思是指不间断的、永不尽头的提升。</p>\n<p>怎么用来丰富智者的生活呢？<br><strong>外在的成功首先开始于内在的成功。如果你确实想要改善自己的外在世界，不管这种外在世界指的是你的健康，你的人际关系，还是你的财产状况，你都必须先努力提升自己的内心世界。最有效的途径就是持续不断地进行改善自我的实践与练习。掌握自我就是掌握人生的DNA密码。</strong></p>\n<p>中国古老的智者曾经说过：“道在屎溺中。’意思就是说宏大的人生哲理其实恰恰隐藏在看似平淡的日常生活细节之中。</p>\n<p>在我们这个社会里，我们都太轻易地把无知看作是缺陷。然而，那些表现出自己缺乏知识，希望找到指引的人其实并不需要感到害羞，因为他们比其他人更早地意识到自己的问题，也就能够去更早地发现通向开悟的道路。你提出这个问题证明你非常诚实，让我看出来你的确愿意接受新理念。要知道在我们目前的这个社会里，改变是最强大的动力。大部分平庸的人害怕改变，而智慧的人则拥抱它的威力。禅悟代表的东方修行传统着重讲的是起步者的心智：那些敞开自己的头脑，随时准备接受新观念的人——也就是那些总是让自己的杯子空空如也的人——总是会在成就和满足感的方面达到更高的水平。千万不要羞于提出哪怕是最基本的问题。提问是获得正确知识的最有效的途径。</p>\n<p>当我说到提升你的内心世界时，我只是简单地描绘了一下自我改善和个体发展的功效，并告诉你这是你能够为自己做的最有价值的事。或许你会觉得太忙了，没有时间花在自己身上，当然也无须奢谈什么改变。如果你这么想，那就大错而特错了。你要知道，当你把自己培养成一个纪律严明、活力充沛，充满乐观情绪的人时，你就可以在外部世界中拥有所有的东西，做所有你想做的事情。当你对自己的能力和不屈不挠的精神产生了深刻的自信，那么任何东西要想成为阻挡你胜利的拦路石，那真的就是螳臂当车了。在控制自我心智上多花些时间，时刻关注自己的身体，丰富自己的灵魂，都会使你的生活会变得更加丰富，更有生命力。许多年以前，斯多葛学派的爱比克泰德就曾经说过：“一个不能控制自己的人就不是自由人。</p>\n<p><strong>禅的本意是静虑、冥想，悟与迷对称，指觉醒、觉悟。悟是意义的转化、精神的转化、生命的转化，含有解脱的意义。禅是修持方式，悟则是修持结果，两者是有区别的。但是东方的禅宗学人却把禅由坐禅静思变为日常行事，由心理平衡变为生命体验，这就从根本上改变了禅的内涵。东方的禅宗学人还认为觉悟要由日常行事来体现，由生命体验来提升。禅与悟是不可分的，悟必须通过禅来获得，禅没有悟也就不成其为禅。没有禅就没有悟，没有悟也就没有禅。</strong></p>\n<p>接下来我开始思考究竟能够从哪些方面来提高自己的修养。让我一项一项地来看看吧。第一，定期的锻炼可以给我带来活力，这样我才能够保持健康良好的体格与心态。第二，控制我的坏脾气，不要随便打断别人的谈话。如果能够改正这些毛病，可能会在人际关系方面给我和妻子、孩子以及同事的相处带来意想不到的好处。第三，改掉忧虑的坏习惯。这可以带给我心智上的安宁和平静的幸福感。第四……我越想越兴奋，因为我发现在我身上能够进行改善的地方实在太多了，可这些我以前却从来没有注意过。 </p>\n<h2 id=\"建立人格力量、培养心智和充满勇气地去生活\"><a href=\"#建立人格力量、培养心智和充满勇气地去生活\" class=\"headerlink\" title=\"建立人格力量、培养心智和充满勇气地去生活\"></a>建立人格力量、培养心智和充满勇气地去生活</h2><p>他耐心地谈到建立人格力量、培养心智和充满勇气地去生活具有多么重要的地位。他告诉我说：“这三种品质不仅可以让人拥有高尚的生活，而且可以使他的生活中充满成就感、满足感和内心的安宁。勇气这个宝贵的品质是每个人都可以培养得到的，它在经久不息的跋涉中带给你巨大的回报。<strong>”<br>  “</strong>勇气和自我领导、自我发展又有什么关系呢？<strong>”我大声问他。<br>  “</strong>勇气使你敢于正视自己，与自己的惰性赛跑。勇气使你敢于去做所有你认为是对的事情。勇气使你能够控制自我，在其他人失败的地方仍旧支撑你继续坚持下去。最终，你拥有勇气的多寡程度决定了你可以获得的成就的总量，这是一个有趣的正比例关系。它能够使你确切地从自己的生活中看到所有不同寻常的奇迹。另外，我还想告诉你，能够掌控自我的人都是拥有非凡勇气的人。</p>\n<h2 id=\"心智、身体和灵魂\"><a href=\"#心智、身体和灵魂\" class=\"headerlink\" title=\"心智、身体和灵魂\"></a>心智、身体和灵魂</h2><p>在我的新生活里也就更加信奉禅悟的哲学，让心智、身体和灵魂都持续地、永不休止地获得自然的点化，在丰富心性的过程中不断提高。朱利安这样说。<br>为什么这些天以来我听到这么多次‘心智’‘身体’和‘灵魂’之类的词语？你要是不稍微解释一下，我还真拐不过弯来。<br>  “**这三个词语是你作为人的天赋中非常重要的三部分。简单地说，它们三者之间是相辅相成的关系。比如不锻炼身体，仅仅注重于提高心智，就只会得到非常空洞的胜利。如果你把心智和身体能力都提升到了最高水平，却没有认真地丰富自己的灵魂，会使自己感到异常地空虚，无法获得满足感。但是一旦你用出所有的力量来释放本性中这三个部分所有潜能的话，你就会在人生突然开悟的那一刻享受到神圣的狂喜。</p>\n<h2 id=\"人们在艰难地进入未知区域的时候会变得最为强大\"><a href=\"#人们在艰难地进入未知区域的时候会变得最为强大\" class=\"headerlink\" title=\"人们在艰难地进入未知区域的时候会变得最为强大\"></a>人们在艰难地进入未知区域的时候会变得最为强大</h2><p>首先我必须和你一起分享一个实际的例子。请你摆出俯卧撑的姿势来。当然，依你现在的身材，你还能趴下吗？”朱利安不失时机地揶揄了我一下。<br>  “天哪，朱利安变成军事训练官了。”我暗自想着。出于好奇，也是为了像朱利安所说的“保持我的杯子空空如也”，我只有老老实实地照办。<br>  “现在，使出全身的力量做俯卧撑，不要停下来，直到你确定自己彻底没劲为止。让我们数一数你到底还能够做几个。”朱利安在一旁笑着说。我的天，他只差手里再握一只秒表了。 我挣扎着做起了俯卧撑。多少年了，我那肥胖的身躯从来都没有进行过这么多的运动，除了有那么屈指可数的几次，我和孩子们一起走到最近的一家麦当劳快餐店，或者和我的法律界同行们一边漫步一边打一轮高尔夫球。最初的15个俯卧撑完全像是垂死挣扎。我开始暗自抱怨这个闷热的夏季，黎明之前的气温依然使得我大汗淋漓。然而，我已经下定决心，坚决不要显出任何虚弱的迹象，坚持下去，直到我的虚荣心和手臂一起无法坚持的时候再停下。<br>  不过我的虚荣心显然没有那么坚强。在做到第23个的时候我放弃了努力，结结实实地趴在地上。<br>  “不行了，朱利安。”我一边喘气一边忍不住抱怨起来，“这简直是要杀了我。你这是打算干什么？”<br>  “你确定自己一个也做不起来了吗？”朱利安的表情十分严肃，丝毫没有开玩笑的意思。<br>  “我确定。算啦，让我喘口气吧。我唯一的感觉就是，我再动一动就会造成一次心脏病突然发作。那时你一定记着打急救电话啊。”<br>  “再做10个。然后你就可以休息了。”朱利安命令道，他的口气似乎没有商量的余地。<br>  “你说话不算数！”我愤愤不平地抗议道。然而为了能够获得朱利安的教导，我只好咬着牙坚持继续做下去。1个……2个……5个……8个……最后总算做了10个。我连翻身的力气都没有了，直接趴在地板上，觉得天都快要塌下来了。这时，耳边响起朱利安清晰的声音：<br>  “瑜伽师拉曼和我在一起分享他的特别寓言的那个晚上，我也像你这样经受了训练。不过，唯一的区别在于我做的俯卧撑是你的好几倍。”朱利安说。“当我体力不支趴在冰冷的地板上的时候，拉曼镇静地对我说，痛苦是最伟大的老师。”<br>  “痛苦是最伟大的老师？从这样枯燥的身体练习中究竟能够学到什么呢？”我气喘吁吁地问他，丝毫也不掩饰我的抱怨之情。<br>  “瑜伽师拉曼，还有所有居住在喜马拉雅山上的智者在这个问题上都保持了完全一致的看法。他们认为，<strong>人们在艰难地进入未知区域的时候会变得最为强大。</strong>”<br>  “好吧。我相信你的话是有道理的。但是这和俯卧撑有什么关系呢？又有什么理由让我非得做这么多俯卧撑不可呢？”<br>  “当你做了23个俯卧撑之后，你告诉我力气用完了，一个也做不起来了。我相信你对我说的话，在你的意识表层中，那真的是你的极限。然而，当我一定要求你再多做几个，你听从了我的话以后就又多做了10个俯卧撑。这说明了什么呢？”<br>  朱利安不等我回答，紧接着给出了答案：“<strong>这说明潜伏在你身体里的力量还有很多，只不过平时它们都在沉睡状态，缺乏足够的刺激将它们一一激活。一旦这些力量醒来，一旦你发现了自身力量源泉的时候，你就会发现自己其实比预想的要强大得多。其实类似的事情在生活中也是屡见不鲜的。比如报纸上会登载一条新闻说，某人因矿难而被深埋在地下半月之久，却能够依靠强大的求生意志而存活下来。或者说一个人从高空坠落，因为掌握好了身体的平衡感而幸免于死。相信你一定读到过这些新闻，不过你通常是把它们当作茶余饭后的街头怪谈，却没有冷静下来仔细想想其中的一些奥妙。这是关于生命的奥妙</strong>。<br>  “<strong>当我还是瑜伽师拉曼的学生时，他向我解释了这个基本原理：“生命中唯一的极限是你自己给自己设下的。’当你勇于从惰性的圈子中跳出来，打破陈规，向未知领域探索，你就开始释放本性中的潜能了。这是走向自我控制的第一步。当你把自己的极限推得更远，就像你在这次小小的示例中做的这样，你就会不断地开发出心智和体力的潜能，那是你从来不曾想、也不敢想的东西。而事实上，你原本有足够的能力去获得它。</strong>” </p>\n<p>“太棒了。”我心想。突然，我记起了在最近看过的一本书里说，普通人的个人才能只有很微小的部分得到了利用，如果每个人都把自己沉睡的才能唤醒，那每个人都将是天才。“我很想知道，如果我们学会运用能力中其余那些沉睡的部分，我们又能做出什么呢？”<br>这个问题让朱利安有些为难。他挠了挠头，想了一下，然后回答道：“你刚才实践了‘禅悟’的技巧，相信我，这种技巧每天都可以使你进步。也许以下这些方面是你近期要努力的事情。<br>“<strong>努力提高自己的心智，改善身体的健康状况，让自己能够随时做到聚精会神。做那些让你感到恐惧的事情，这样就可以消除心魔，开始拥有无限的精力和无边的热忱</strong>。<br>“<strong>你还要学会融入大自然，认真观察日出时的动人情景，也可以试着在雨中自由舞蹈。</strong><br>“<strong>你要坚守自己的目标，每天都朝这个方向行进，这样才能真正成为你梦想成为的那种人。 </strong></p>\n<p>“<strong>不要害怕出错，要鼓足勇气做你一直想做的事情，而不是自欺欺人地找借口拖延，嫌自己太年轻或者太年老，太贫穷或者太富裕。</strong><br>“<strong>准备好过一种目标远大，精神活跃的生活。在东方，人们常常会说，机会总是留给有准备的人。而我则深信，生活也偏爱有准备的人。</strong>”<br>**朱利安继续他热情洋溢的谈话，好像是一所大学课堂上的哲学老师。“认真分析生活中那些阻碍你的因素，然后想方设法去克服它。从多方面好好反省自己，比如你是不是害怕演讲，或者在人际关系上有麻烦？你是不是缺乏积极的人生态度，或者需要更多的精力？接着列出一份详细的目录，将自己的弱点一一登记在案，然后有的放矢地改正它们。在工作中容易得到满足感的人们往往比不思进取的人更加深思熟虑。把时间花在寻根究底上，就可以让你明白自己和所希望的生活之间的差距究竟有多远，还要对眼下的生活状态了若指掌。”<br>“一旦你看到了自己的弱点所在，那下一步的工作就是要直接面对它们，向自己的恐惧心理开战。中国有句俗话叫作‘怕处有鬼’，人们通常会被自己臆想出来的怪物吓傻了。恐惧只不过是你自己在头脑中制造出来的怪物，是一连串的负面意识。所以，要克服自己的心理痼疾。如果你惧怕当众演讲，就专门签约进行20场演讲，哪怕你要为此支付主办方一定的费用。如果你固守陈规，害怕开展新业务，或者想逃避不愉快的人际关系，那就专门给自己制造这方面的挑战环节。只要你迈出第一步，后面的路就好走了。当你像一只蝴蝶从蛹中破茧而出的时候，那将是你在这么多年以来第一次尝到真正的自由的滋味。</p>\n<p>恐惧是一种条件反射，如果你不留神的话，它很快就会把生命力、创造力和精神都消耗殆尽。一旦恐惧满怀恶意地探出它丑陋的脑袋，你就应该一下子把它击垮。最有效的办法就是去做让自己感到害怕的事情，借此完全了解恐惧的内在结构。当你进入了恐惧的内部，就会发现它不过是源于你自己的胡思乱想。就像任何其他人创造出来的东西一样，把它揭穿就像把它创造出来一样简单。你可以学着有系统、有方法地查明底细，看清楚蛰伏在你心智深处的每一种恐惧到底都是什么，而后再一一击破。长此以往就会带来无限的信心、幸福和内心的安宁。**” </p>\n<p><strong>“真的有人拥有无所畏惧的心灵吗？”我问他。<br>“问得好。我将毫不犹豫地断然回答：‘是的！’喜马拉雅山上的智者个个都毫无畏惧。你可以从他们走路的样子上看出这一点，可以从他们的谈吐内容上听出来这一点，也可以在深深凝视他们双眼时发现这一点。其实生活中有很多这样的例子，电影《勇敢的心》你看过吧？”<br>朱利安顿了顿，接着凑近我说：“我再给你说点别的，约翰。”<br>“什么啊？”我问他，心中对他刚才讲到的事情充满了好奇。<br>“</strong>我也曾一度胆小如鼠。对此我心知肚明，因此就打算进行一次自我清理，找到天生的意志力和无限的潜能。后来我找到了胆小的根源，正是因为这么多年来一直忽略自我以及思想发展的不平衡阻碍了我的发展。我再告诉你一件事。当你把恐惧从头脑中彻底驱逐出去之后，你就会变得更年轻，也变得更有活力。**” </p>\n<p>“啊哈，<strong>古老的身心联系</strong>。</p>\n<h2 id=\"迎着弱点和恐惧直面而上\"><a href=\"#迎着弱点和恐惧直面而上\" class=\"headerlink\" title=\"迎着弱点和恐惧直面而上\"></a>迎着弱点和恐惧直面而上</h2><p>另外一条非常有效的法则，我也时常会想到它。我觉得，当你走在引导自我和控制自我的道路上时，这条法则对你而言将是无价之宝。每当我想要投机取巧的时候，它就会批评我，给我以上进心。这一人生哲学可以简单地归纳为：行事高效的人和死气沉沉的人之间的最大区别在于，前者会去做后者不喜欢做的事——尽管他们可能也不愿意去做。<strong><br>“</strong>真正开悟的人，每天都可以体味到深沉的幸福感，随时准备着为了长久的满足而放弃短暂的快乐。他们就这样迎着弱点和恐惧直面而上，即便有时因为深陷未知的领域而感到极大的不自在也无所谓。他们下定决心，要依靠‘禅悟’的智慧来生活，永不间断地提高人生的各个层面。过去曾阻碍他们获得快乐、健康和富有的恐惧也会败下阵来。</p>\n<h2 id=\"幸福要通过对一个有价值目标的渐进实现才能得到\"><a href=\"#幸福要通过对一个有价值目标的渐进实现才能得到\" class=\"headerlink\" title=\"幸福要通过对一个有价值目标的渐进实现才能得到\"></a>幸福要通过对一个有价值目标的渐进实现才能得到</h2><p>我最喜欢的教授给我讲过的一个古老故事。<br>有一天晚上，一位父亲在办公室工作了一整天以后开始拿着报纸看，想享一会儿清闲。可他的儿子很想玩，就一直缠着爸爸。最后，这位父亲被搞得不耐烦了，气呼呼地扯下一张地球画报，撕成了一大把小小碎片。“来吧，儿子，过来把它们重新拼在一起。”他说着，希望这一招可以让孩子忙上好一阵子，以便自己可以从容地看完手中的报纸。<br>让他大吃一惊的是，还不到一分钟，他的儿子就兴冲冲地带着一张拼贴无误的图片回来了。当这位目瞪口呆的父亲问儿子是怎样完成这个拼地图的壮举时，儿子笑得甜甜的，轻松地回答说：“爸爸，在这张地球图片的反面是一个人的图片，只要我把这个人拼在一起了，世界地图也就完整了。”<br>“真是棒极了。”我不由得赞叹起来。<br>“你看，约翰，从喜马拉雅山上的智者到哈佛法学院的教授，在我认识的最有智慧的人当中，似乎每个人都洞悉了幸福公式的要领。</p>\n<p>幸福要通过对一个有价值目标的渐进实现才能得到。当你在做自己全心全意热爱着的事情时，就一定会感到深深的满足。</p>\n<h2 id=\"做你喜欢的事情，需要很大\"><a href=\"#做你喜欢的事情，需要很大\" class=\"headerlink\" title=\"做你喜欢的事情，需要很大\"></a>做你喜欢的事情，需要很大</h2><p>我不妨再说得明确点，约翰。做你喜欢的事情，需要很大的勇气。它意味着你为了当演员要放弃手边正在做的工作，在不那么重要的事情上少花些时间，留下时间给更有意义的事情。它要求你离开习以为常的规律，也就是抛弃惰性，勇于创新。这种变化在最初的时候总会有些让人难以适应，而且具有一定的风险。但请一定记住我前面反复说的话，这正是走向快乐人生的起点。</p>\n<p>一个人究竟应该怎样鼓起勇气呢？<br>这也像刚才故事里所说的：只要你可以控制自己，你的世界就没问题了。只要你能控制自己的心智、身体和品质，幸福和富裕就奇迹般地来到你的生命中。但是，你每天都要在自我完善上花一些时间，哪怕只有10到15分钟。</p>\n<h1 id=\"相扑选手，注意‘禅悟’的提示者\"><a href=\"#相扑选手，注意‘禅悟’的提示者\" class=\"headerlink\" title=\"相扑选手，注意‘禅悟’的提示者\"></a>相扑选手，注意‘禅悟’的提示者</h1><p>这位肌肉发达的大块头就是不断提醒我们注意‘禅悟’的提示者。这个词在日语中的意思就是持续的自我发展和进步。</p>\n<p>我已经明白了自己的心智其实是那么神奇，宝贵的潜能又将创造怎样的奇迹。我已经学会了非常高效的技巧，可以把能量集中到我的愿望和梦想上。我已经知道在生命中树立明确目标的重要性，要在我人生、职业和精神世界的每一个方面都设立非常清楚的目标。现在我已经完全接受了那个自我掌控的古老法则：“禅悟”</p>\n<h2 id=\"活力生活的十个招数\"><a href=\"#活力生活的十个招数\" class=\"headerlink\" title=\"活力生活的十个招数\"></a>活力生活的十个招数</h2><h3 id=\"孤独的习惯\"><a href=\"#孤独的习惯\" class=\"headerlink\" title=\"孤独的习惯\"></a>孤独的习惯</h3><p>第一个办法被智者称作‘孤独的习惯’。所要求的无非是你在每天的日程表上划出来一段时间，这段时间用来保持自我的宁静，哪怕是一段强制性的自我宁静。</p>\n<p>这段时间少则15分钟，多则50分钟。在此期间你要感受沉默的力量，要渐渐领悟到你究竟是谁。</p>\n<p>把‘孤独的习惯’想成是灵魂长途跋涉中的短暂休息。它的目的就在于获得自我更新的机会，通过独自一人沉浸在美丽的沉默当中来实现。” </p>\n<p>“沉默有什么特别之处吗？<strong>”<br>“问得好。</strong>沉默和宁静把你和内部世界的创造力源泉联结在一起，解放所有智力的束缚。你看，约翰，心智好比一汪湖水。在我们这个嘈杂的世界上，大部分人的头脑里都安静不下来，因为我们的内心充满混乱。然而，只要你肯每天花一点时间来静心沉默，心智也就会变得平静如镜。内在的安宁会带来丰厚的回报，包括健康舒适的感觉，内在心态的平和以及无穷的精力。你甚至会睡得更香，而且在日复一日的劳作中享受到自我更新的平衡感。</p>\n<p>“我应该到哪里去寻找这一刻的安静呢？”<br>“从理论上说，你可以在任何地方，无论是在卧室还是在办公室。关键是要找到一个真正安静的地方——而且环境要很优美。”<br>“为什么必须是优美的环境呢？”<br>“<strong>优美的环境能够慰藉不安的灵魂，”朱利安解释说，深深地叹了一口气，“一束玫瑰，或者仅仅是一支孤零零的水仙，都会很好地改善你的情绪，让你得到非常有益的放松。说得更理想化一点，你应该在“个人避难所”中尽情享受这样的优美。我突然想到了一句东方禅语：菩提本无树，明镜亦非台，本来无一物，何处惹尘埃。</strong>”<br>“什么，什么？”<br>“<strong>简单说来，就是你为了自己的心智得到扩展，为了提升自己的精神境界，要学会把一个地方变成密室。这可能是你家中的空余房间，或者仅仅是一间小公寓中的安静角落。问题是你要给自己的更新行动保留一个相对固定的空间，一个静静地等待你到来的地方。</strong>”<br>“我喜欢这种说法。我想如果我在下班回家以后有了一个安静的地方可去，就会大大改变一切。我可以在那儿先待上一会儿，缓冲一下，消除一天当中的压力。这可能让我对周围的人更加有耐心。”<br>“<strong>这就涉及另外一个重要的问题。如果你每天都在同一时间来练习孤独静处的习惯，效果才会是最好的。</strong>”<br>“为什么？”<br>“<strong>因为它会作为一个习惯进入你的日常生活，成为一个有机组成的部分。如果在每天的同一时刻都来练习它，每日按时到来的静默很快就成为不容忽略的习惯。而积极的人生习惯将最终引导你到达目标。</strong>”<br>“还有别的吗？”<br>“是的。<strong>如果有可能的话，每天都和大自然谈谈心。在树林里做个短短的散步，或者哪怕是到后院，在你的西红柿苗圃里花上几分钟去浇水施肥，都会把你和安静的源泉重新连在一起。或许现在想一想这些事情就能让你的内心恢复平静。和大自然在一起，会激发你自身无穷的智慧。这种自我认知可以在自我潜力的方向上持之以恒地推动你的进步。别忘了这一点。</strong>”朱利安建议道。他的声音因为充满热情而慢慢提高，无论如何也听不出来是一夜未眠的人。<br>“这一招对你有效吗，朱利安？”<br>“绝对有效。在阳光尚未跃出地平线的时候，我就早早起床，做的第一件事就是走到我的‘个人避难所’。那是我在练习‘玫瑰之心’时发现的，后来一直秘密地使用着。有时候我静默地沉思冥想几个小时。有的时候也许只需花费10分钟。结果大致相似：我获得了一种内在和谐的深刻感受，以及无限的身体精力。</p>\n<h3 id=\"体格锻炼的习惯\"><a href=\"#体格锻炼的习惯\" class=\"headerlink\" title=\"体格锻炼的习惯\"></a>体格锻炼的习惯</h3><p>“关于<strong>如何养护身体。</strong>”<br>“什么？”<br>“很简单。<strong>体格锻炼的习惯是基于一个基本原理：你只有通过养护身体才能进而养护心智。给身体做好充分地准备，才会给心智做好相应的准备。训练好了身体，才会训练好心智。你没有听东方的哲学家常常说什么‘天将降大任于斯人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为，所以动心忍性，曾益其所不能。’抽出一个整天，通过健身训练来滋养盛放心灵的殿堂。让身体活起来，让血液沸腾起来。你知道吗？一周有168个小时呢。</strong>”<br>“不，知道得不那么确切。”<br>“这是真的。其中至少有5个小时应该投入在某种方式的身体活动上。喜马拉雅山上的智者一直从事着一种古老的瑜伽训练，借此来唤醒身体内的潜能。天长日久，他们变得强壮有力，生机勃勃。这些身体超群的人很特别，<strong>他们常常在村子中央倒立，以此来保持年轻。</strong>” </p>\n<p>“那些智者还做过别的什么来养护身体吗？”<br>“<strong>瑜伽师拉曼和他的兄弟姐妹们都相信，精力充沛地在自然的环境中散步，不管是在高高的山路上，还是在茂密的森林深处，这些都将有助于缓解疲劳，修复身体内部的细微差错，以及恢复人体活力。要是天气太差，没法散步，他们就会在小屋中的密室里锻炼。他们可能会忘记吃一顿饭，但是决不可能忘记每天的练习。</strong>” “他们的茅屋中有什么东西？跑步机吗？”我开玩笑说。<br>“当然不是。他们有时候练习瑜伽。有时候他们会做双手或者单手直立的俯卧撑。开始我还很好奇，后来我渐渐意识到他们做什么其实并不重要。他们虽然姿势不同，但目的却是一致的，那就是充分活动身体，让四周的新鲜空气在肺部畅通地流淌，也让血脉贯通起来。”<br>“呼吸新鲜空气会有什么用呢？”<br>“我要借用瑜伽师拉曼最爱说的一句话来回答你：<strong>“适当的呼吸就等于适当的生活。</strong>’”<br>“呼吸有这么重要吗？”我奇怪地问道。<br>“当我到那儿之后，智者很快就教会了我如何使自己获得两倍甚至三倍精力的捷径，我也因此学会了进行有效的呼吸方法。”<br>“可是难道我们不懂得呼吸吗？这连新生的婴儿都会呀！”<br>“不完全是这样，约翰。<strong>我们中的大部分人都只是知道怎么呼吸才可以活下去，却不知道怎样通过呼吸来让自己更有活力。这是完全不同的两个层面的问题，前一个是生存问题，后一个是生活问题。大部分人的呼吸都太浅了，这样我们就不能吸入足够的氧气，导致我们的身体不能处在最佳的状态。</strong>”<br>“听上去，正确的呼吸还包含着很多科学知识呢。”<br>“确实如此。那些智者是这样对待呼吸的：<strong>通过有效的呼吸吸入更多的氧气，释放体内储藏的精力，从而达到活力收放自如的自然状态。</strong>”<br>“好啊，那么我应该从哪里开始呢？”<br>“<strong>事实上非常简单。每天两到三次，花一二分钟来深呼吸，使空气能够深深地渗透到你身体内的每一个细胞。</strong>”<br>“<em>我怎么才知道自己的呼吸变得有效了？</em>”<br>“<strong>嗯，当你使用正确呼吸方法的时候，你的腹部会稍稍鼓出来一点。这个迹象说明你开始从腹部呼吸了，这就很好。现在试试看……嗯，挺不错。瑜伽师拉曼教我的一个方法是，把双手扣在肚子上感受起伏。如果我吸气的时候肚子鼓起来了，我的呼吸技巧就算是达标了。</strong>” </p>\n<h3 id=\"生命滋养法\"><a href=\"#生命滋养法\" class=\"headerlink\" title=\"生命滋养法\"></a>生命滋养法</h3><p>那就是‘生命滋养法’。在我做律师的那些日子里，我每天的食谱都是固定的，主要是牛排、油炸食品还有其他形形色色的垃圾食品。虽然我总是在城里最好的餐馆吃饭，可还是感到身体里面塞满了垃圾。那时候我并不特别清楚，这就是让我感到不愉快的主要原因之一。<strong>”<br>“真的吗？”<br>“是的。一份糟糕的食谱对你的生命有着显著的影响。它抽干你的脑力和体力，它影响你的情绪，还会扰乱你的逻辑能力。瑜伽师拉曼是这样说的：“</strong>你在滋养身体的同时，就是在养育心智。<strong>’”<br>“那么我猜你改变了食谱喽？”<br>“</strong>我已经彻底改变了自己的餐饮习惯，比如我从来不喝有色素与人工添加剂的饮料，也不再光顾快餐食品店。不久之后，控制饮食的效果就出现了，我的感觉和相貌发生了令人惊异的变化。以前我总是以为，我之所以那么死气沉沉主要是因为工作中的压力和疲劳，而且上了年纪以后身体渐渐不中用了。到了喜马拉雅山上，我才发现我的昏睡懒散其实是因为自己给身体内注入的动力燃料实在是太低劣了。<strong>”<br>“那些智者靠吃什么东西来保持青春和愉快呢？”<br>“</strong>吃新鲜的食物。<strong>”他的回答很简明。<br>“啊？”<br>“</strong>答案就是新鲜的食物。它指的就是没有死去的东西。<strong>”<br>“说说呀，朱利安。哪些东西属于新鲜的食物？”我急躁地问他。<br>“</strong>说得简单点，所谓的新鲜食物就是在自然当中吐故纳新的食物，是通过太阳、空气、土壤和水之间的相互作用中而产生的。我要告诉你的是一种蔬菜食谱。只要你能保证在盘子里堆满蔬菜、水果和谷物，然后就可能长命百岁。<strong>”<br>“真的有可能吗？”<br>“生活在喜马拉雅山顶的大部分智者都已经有一百多岁了，而且看不出有任何衰老的迹象。就在上个星期，我在报纸上读到了一篇报道，大体说一群人生活在中国东海冲绳群岛中一个小岛上。研究者之所以关注这个小岛是因为被一个事实给震惊了：这个岛上聚居着世上最大的百岁老人群落。”<br>“这些研究者发现了什么长寿诀窍没有？”<br>“</strong>结果是，素食是他们长寿的主要秘诀。<strong>”<br>“但是这种食谱健康吗？你知道素食可不一定能够提供足够的气力。请注意，我可还是个忙忙碌碌的律师，朱利安。我总不至于为了长寿而饿昏在庭审现场吧。”<br>“不必担心，</strong>这是一个充分自然的、人性化设计的食谱。它会让你有生气，有活力，而且极其健康。智者已经依靠这个食谱生活了数千年。他们称之为‘悦性食物’，也可以叫作‘纯净饮食’。<strong>既然你最关心力量，那我想提醒你注意，地球上最强有力的动物，从大猩猩到大象，它们都是不折不扣的素食主义者。然而你知道吗？一头大猩猩的力量可比一个男人大30倍。”<br>“真的不可思议啊。谢谢你告诉我这则趣闻。”<br>“看，智者并不是走极端的人。</strong>相反我们现代人却是常常执迷不悟。智者所有的智慧都建立在一条古老的法则上，那就是‘生活适度，做事中庸。’因此，如果你喜欢吃肉，当然还可以继续吃，智者也不会阻拦你。只是你要明白一点，你是在吞下已经死去了的东西。如果可以，尽量少吃红肉，因为红肉很难消化。你的消化系统在整个身体里面是消耗能量最多的部分，非常有价值的精力就这样被肉类食品毫无必要地消耗掉了。你有没有这样的体验，当你中午吃了一份牛排大餐之后，你很快会觉得自己的嘴巴里充满了不洁的味道，不断地打饱嗝儿。接下来，你就会觉得昏昏欲睡，整个人好像梦游一样？<strong>”<br>“确实如此。”我承认。每次午饭前我会因为饥饿而头昏脑胀，而饱餐一顿后我又会因为吃得太饱而昏昏沉沉。就这样，每天上午的十一点到下午两点都是我工作效率最低的时候。<br>朱利安同情地看了看我，我想他一定联想到我在午饭后睡眼蒙眬的丑态。他接着说：“</strong>难道你没有发现我目前的变化吗？建议你给自己的能量标准做个对比，在吃完一份牛排和一盘色拉之后，你的感觉一样吗？如果你不希望一下子就变成一个地地道道的素食主义者，那么至少要在每顿饭里加一道色拉，用水果代替甜点。即便这一点微小的改变也会为你的生活质量带来巨大的改变。**</p>\n<h3 id=\"扩展知识法\"><a href=\"#扩展知识法\" class=\"headerlink\" title=\"扩展知识法\"></a>扩展知识法</h3><p>第四招被称作‘扩展知识法’。<strong>它是一个</strong>关于终身学习，为了给自己和周围的人造福的理念。**”<br>“听起来好像那句老话‘知识就是力量’，是不是？”<br>“它的内涵更加丰富，约翰。知识不仅仅是潜在的力量。因为力量是显而易见的，而你必须进入实践的层面。大部分人在特定的情况下，或者在生活遇到困难时，都明白应该怎么去做。问题在于他们不是天天都这样，没有在使用知识和实现梦想方面持续地加以努力。扩展知识法的宗旨就是成为生活虔诚的学生。而更为主要的是，它要求你把教室里学到的知识顺利地应用到现实生活中去。</p>\n<p>“瑜伽师拉曼和其他智者是怎样应用这个方法的？”<br>“在日常使用中，他们有很多辅助的方法可以和‘扩展知识法’配套使用。最重要的一个技巧也是最简单的。今天你就可以开始试一试。”<br>“不会花很多时间吧？”<br>朱利安颔首微笑。“我和你分享的这些策略、方法和小技巧都会使你变得比以前更加能干，更加高效。不要捡了芝麻，丢了西瓜。想一想那些说自己太忙，顾不得在电脑上备份文件的人吧。一旦他们的机器出了意外，几个月以来的重要工作都将毁于一旦，他们就会捶胸顿足，遗憾自己为什么没有每天花一点点时间去保存文件。你明白我的意思了吗？”<br>“就是说<strong>要先弄明白生命中的主次关系，不要本末倒置？</strong>”<br>“<strong>完全正确。努力使你的生活挣脱时间表的束缚。把精神集中到你的良知和内心告诉你要去做的事情上。当你开始探知自我，并且开始把自己的时间花在提高心智、身体和个性的品质上，你很快就会感到自己的体内仿佛存在着一个领航员似的，他会随时告诉你哪些事情值得去做，而且会带来最丰厚、最有价值的回报。你将不再会为钟表上的时间感到焦虑，而是开始尽情享受生命内在的律动。</strong>”<br>“啊，我明白了。那么接下来你要教给我的<strong>那个简单的辅助办法是什么？</strong>”<br>“<strong>定期读书。每天读书30分钟会给你带来意想不到的结果。但是我必须提醒你，不要碰到什么就读什么。你一定要仔细拣选才行，因为它们将要进入你丰饶的心智花园。它一定得是非常有营养的物质，否则将会适得其反。它们要帮助你改善自我，而且还要提升你的生命品质。</strong>” </p>\n<p>“那些智者平常喜欢读什么书呢？”<br>“<strong>他们在醒来以后，就会花很多时间去阅读古人留下来的教诲。他们对这些哲学著作如饥似渴。迄今我还记得那些非常俊美的人们坐在小竹椅上阅读外形奇怪、装帧精美的书，脸上和唇边都洋溢着淡淡的微笑。正是在那里我真正意识到了书本的力量，知道了‘书本是智慧最好的朋友’这个道理。” </strong><br>“那么我应该开始阅读我能够找到的所有好书吗？”<br>“可以说是，但又不是。<br>”他这样模棱两可地回答我。“我从来都会支持你尽己所能地去读书。但是要记住，有些书只需要浅尝辄止，有些书却需要细细咀嚼，有一些需要辨证学习，而另一些则值得完全吸收。这让我想起另外一个问题。”<br>“你是不是饿了？冰箱里还有些酸奶。”<br>“不是，约翰，”朱利安笑了，“我只不过想要告诉你，<strong>一定要善于从伟大的书籍中获得最为精华的部分。你必须要好好地研究它，而不仅仅限于阅读。深入全面地研究它，就像你研读你的重要委托人给你的案子那样。切实地考虑它，和它相互切磋，成为伙伴。智者在广泛的阅读中，会把很多书读上10到15遍。在他们眼中，伟大的书籍就像是神赐的圣书。</strong>”<br>“哎哟！读书真的这么重要啊？”<br>“<strong>每天坚持读书30分钟，会给你的生活带来可喜的变化。因为你很快就会发现，有那么广博的知识宝库供你选择使用。你会变得谈吐不凡，思维敏捷，文思泉涌。你曾经遇到的每一个问题的答案都会历历在册，信手拈来。如果你想要成为一名更为出色的律师、父亲或者恋人，都会有相应的书籍知识帮你快速达到目的，避免走弯路。你在人生中犯下的所有错误都已经被前人们尝试过，因此你也将会很快找到改正的方案。你是不是真的以为你所面对的挑战都是独一无二的？</strong>”<br>“老实说，我从来没有这样想过，朱利安。但是我理解你所说的，而且我知道你是对的。”<br>“<strong>任何一个人遇到过的任何问题，在他的生命之前都已经被前人遭遇过了，而且不止一次，”朱利安断言道，“更重要的是，答案和解决办法都已经在书页上记下来了，就看你会不会发现它。养成正确阅读的习惯，学习前辈的珍贵经验，他们成功的策略会帮助你从容面对生命中遭遇的种种挑战。你会为发生在人生中的点滴进步而感到惊奇的。</strong>”<br>“什么样的书才是‘正确的好书’？”我追问着，很快就体会到朱利安的意见确实很不错。<br>“这个要留给你自己来判断，我的朋友。就我个人而言，自打我从东方回来以后，就把一天中最好的时光花在了阅读上。当然，每个人兴趣不同，我最感兴趣的是那些我所钦佩的男男女女的人物传记和大量的智慧之作。”<br>“你能不能为我这个还算得上勤奋工作的人列出一些有用的推荐篇目呢？”我一边说，一边难为情地笑了一下。<br>“没问题。<strong>比如你可以从伟大的本杰明・富兰克林的传记中获益颇多。我觉得你还可以从圣雄甘地的传记中发现很多成长的动力，那本书的名字叫作《甘地自传》。我还建议你读读赫尔曼・黑塞[7] 写的《悉达多》，还有马可・奥勒留[8] 写的实践性很强的书，以及塞涅卡[9] 的一些著作。你甚至还可以读一读拿破仑・希尔的《思考致富》。上个星期我认真地读了这本书，觉得真是回味深远。</strong>” </p>\n<p>书只是帮助你发现早已存在于自身之内的东西。这是一种唤醒，一种提示。这就是启蒙，如一束光照亮你的人生。我在经过了那么多的旅行和探险之后，最终发现我其实是走完了一个循环，回到了我还是孩子时的出发点。但是现在，我非常了解自己，知道我是谁，我也知道自己最终会成为怎样的人。**”<br> “所以说‘知识扩展法’就是大量读书，探索外界的丰富知识？”<br> “你只说对了一部分。因为在眼下一天只读30分钟书，你的理解也仅此而已。随着你对书籍的爱好与日俱增，其他意想不到的东西自然也会到来。”朱利安的话里暗含着玄机。</p>\n<h3 id=\"个人反思法\"><a href=\"#个人反思法\" class=\"headerlink\" title=\"个人反思法\"></a>个人反思法</h3><p>它的名字是‘个人反思法’。那些智者都坚信内在沉思的力量。通过一定时间的沉思来了解自我，就可能步入生命的另一个维度，这也许是你从来都不知道自己还具有的更高维度。</p>\n<p>其实说到根本上，个人反思不过是一种思考的习惯。</p>\n<p>对，是富兰克林。每天晚上在完成了一天的高效率工作之后，他一回到家里就会躲在一个安静的角落里，反思这一天的行为处世。他会反思他的全部行为，看其中哪些属于积极而富有建设性的，哪些属于消极而需要及时修正的。当他清楚地知道白天里犯下了什么错误时，他就会迅速采取措施进行改进，沿着自我控制的道路前进。等到以后再遇到类似的情况，他就会心知肚明，游刃有余。智者也是这样做的。每天晚上，他们都会躲进小棚屋里的清净角落，那里铺满了芳香的玫瑰花瓣，他们坐下来陷入深深的沉思。瑜伽师拉曼还会把他的一天经历写在日记里。</p>\n<p>“他写下来的都是些什么事？”我好奇地问。<br> “<strong>首先他会列出当天所有做过的事情，从早晨的身体锻炼，到他和其他智者之间的交流，再到他到森林里去找木柴和新鲜食物的经历。很有趣的是，他还会写下来在这一天里曾经在头脑中出现过的各种念头。</strong>”<br> “这样做岂不是难了点儿？我根本记不起来5分钟以前自己曾经想过什么，更不要说12个小时以前的想法了。”<br> “如果你每天都坚持做同样的练习就不会觉得难了。任何一个人都可以获得在我身上发生的改变，任何人。真正的问题是，有太多的人都饱受令人讨厌的疾病的折磨，这种疾病叫‘借口’。”<br> “我想我可能也染上了这种疾病。”我完全明白我聪明的朋友在说什么。<br> “别再找借口了，只管去做就好了！”朱利安提高声音说道，他的语调中充满了坚定的力量。<br> “做什么？”<br> “<strong>花时间去认真思考，并在生活中养成定期进行自我反省的良好习惯。有时候瑜伽师拉曼会将笔记纸的一页从中对折一下，把当天所有做过的事情、想到过的念头都写在一栏里，然后在另外一栏里作出相应的评价。当他面对书面记录下的行为和想法时，他会扪心自问，它们在本质上究竟是不是积极的。如果是积极的，他就决定继续为此付出宝贵的精力，因为从长远来看，它们会给他带来巨大的收益。</strong>” </p>\n<p>我认为现在你已经发现了‘个人反思法’的神奇力量。通过审视自己做过的事情，仔细反省自己是如何度过一天的。你要注意归纳自己在一天内一共出现了几种想法，这样一来你就给自己提供一个进步的标准。要在明天实现进步的唯一途径就是知道今天做了哪些错事，并且知道如何来加以改进。</p>\n<p>只有人类才会走出自我的阴影，并且能够分析他所做的事情中哪些是正确的，哪些是错误的。一条狗做不到这一点，一只鸟也不会这么做，就连聪明的猴子也不可能。但是你可以。这就是‘自我反思法’的根本宗旨，在每天的生活和整个人生当中，辨明什么是正确的，什么是错误的，然后尽快着手完善自己。</p>\n<h3 id=\"早早醒来法\"><a href=\"#早早醒来法\" class=\"headerlink\" title=\"早早醒来法\"></a>早早醒来法</h3><p>“<strong>我在遥远的喜马拉雅山上得到的最有用的一个建议就是，和太阳一起起床，然后成功地开始新的一天。我们大部分人的睡眠时间都比实际的需求要多得多。其实普通人睡六个小时就可以起床了——这已经足够他保持健康和思维的机敏了。睡眠无非一种习惯，像其他习惯一样，你可以训练自己达到你所希望的成果。试一试，能不能在这一个环节中睡得少一些。</strong>”<br> “可是，如果我起床太早了的话，我真的会感到精疲力竭。”我说。<br> “在刚开始的几天里，你可能会感到疲倦。我也曾有同感。你甚至有可能在练习早些起床的第一个星期里一直有这样的疲劳感。不过，请把这看成是为了得到长期的巨大收益而付出的短暂的、少量的痛苦。在你确立一个新习惯的时候当然会多多少少感到有些不舒服。这就像你穿上了一双新鞋子——刚开始穿上的时候觉得有点疼，很快就很惬意了。正像我此前告诉你的那样，痛苦往往是个人成长的前奏。别害怕起早。相反，接受它。”<br> “好吧，我喜欢这个训练自己早点起床的观念。可是先得让我问问你，<strong>‘早’起意味着几点钟起？</strong>”<br> “又是一个好问题。这跟时间没有关系。就像我到现在为止和你分享的各种方法一样，都是要你按照认为正确的标准去做。记住瑜伽师拉曼的警告：“凡事不可过分，处处都要适度。’”<br> “日出时起床，这听起来已经很过分啦。”<br> “实际上并不过分。几乎没有什么比一天当中新射出的第一缕阳光更加光辉灿烂的了。智者坚信，阳光是来自上苍的礼物。尽管他们都很小心，不过多地暴露在阳光下，但是他们会定期做日光浴，还经常在阳光明媚的清晨顽皮地舞蹈。我完全相信这是他们保持长寿的另一个秘诀。”<br> “你也做日光浴吗？”我问。<br> “当然做。阳光使我恢复活力。当我感到劳累时，阳光会让我高兴起来。在东方古老的文化里，太阳被认为与灵魂相连。人们崇拜太阳，因为太阳让庄稼和他们的精神一起丰收。阳光可以释放你的生命力，恢复情感和身体上的活力。它是一位令人心情愉快的医生，不过前提是你适当地接触它。唉，我又跑题了。我们讨论的是早点起床，每天坚持。”<br> “哈哈。我怎么才能把这个习惯纳入日常的生活？”<br> “<strong>这里有两个简便易行的小诀窍。首先，千万别忘了，重要的是睡眠的质量而非睡眠的数量。在不受干扰的情况下沉沉地睡上六个小时要比时常被打断的十个小时睡眠好得多。睡眠的目的在于让你的身体得到休息，这个自然的生理过程可以修复、重建你的身体，减少日常消耗带来的压力和挣扎，使你的身体恢复自然的状态。很多智者的习惯都基于这一原则。举个例子来看，瑜伽师拉曼在晚上八点以后就再也不吃东西了。他说消化活动及其附带的生理活动会降低他的睡眠质量。智者还有另一个习惯，睡觉之前他们会在轻柔的竖琴乐声中冥想。</strong>”<br> “这种行为的原因是什么？”<br> “让我来问问你，约翰。每天晚上睡觉之前你会做些什么？”<br> “我和詹妮一起看新闻节目，我知道这和大部分人做的事情一样。” “我就知道。”朱利安回答，眼睛中有奇异的闪光。<br> “我不明白。在睡觉以前看上一点新闻有什么错的？”<br> “<strong>你睡觉之前的10分钟，还有醒来之前的10分钟，都会在你的潜意识里留下长久的影响。在这两个时间段，你应该只向你的头脑输入最愉悦、最安静的想法。</strong>”<br> “瞧你说的，人的头脑听起来就跟电脑似的。”<br> “<strong>这么来看待头脑也不失为一种好办法——你输入的东西就是将要产出的东西。更加重要的事实是，程序员只有你一个人。通过决定让哪些念头进入头脑，你也就可以明确地知道哪些念头将会产生出来。所以在你去睡觉之前，不要看什么新闻，不要和任何人争吵，也不要在脑海中回顾一天的所作所为。放松，如果你喜欢的话，慢慢地喝一杯花茶，听一点轻柔的古典音乐，做好准备，让自己渐渐滑入甜美的熟睡中。</strong>”<br> “有道理。睡得越好，睡得越少。”<br> “确实如此。<strong>一定要记住古老的21天法则：如果你连续21天做一件事情，它就会确定成为你的习惯。所以，在你因为感到不舒服而放弃早起的行为前，你要坚持三个星期。</strong>到了那时，早起就成为了你生活的一部分。在很短的时期内，你就能够轻轻松松地在早晨五点半，甚至是五点钟起床，准备好领略新一天到来时的壮丽场景了。”<br>  “好吧，那么如果说，我现在每天都是五点半起床的话，我又该做些什么呢？”<br>  “<strong>从你问的问题就可以看出你确实是在思考，我的朋友。对此我很欣赏。起床之后，你可以做很多事情。要在头脑里面时刻记住的基本原则是，好好开始新的一天是非常重要的。就像我曾建议过的，在你醒来以后的十分钟内，最先进入到脑海里的念头和最先着手的行为，往往会在接下来的一天中产生非常明显的效果。</strong>”<br>  “此话当真？”<br>  “当然。<strong>去想那些积极的念头；对你所拥有的一切做感恩祈祷；感谢你要感谢的人；倾听一些伟大的音乐；看太阳升起。兴之所至的时候，你还可以去自然环境中散步。实际上，智者还常常让自己开怀大笑，不管是不是有高兴事，这不过是为了让快乐在清晨便开始流动。</strong>”<br>  “朱利安，我尽力使自己的头脑能够接受你的讲解——而且我想你也会承认，作为一个初学者我做得已经很不错了。可是，就算是对一群生活在喜马拉雅山高峰上的高僧来说，那样的事情听起来也真的太奇怪了。”<br>  “其实不足为奇。你猜一猜，一般来说，一个四岁的孩子一天要大笑几次？”<br>  “谁知道呢！”<br>  “我知道，一共三百次。嗨，你不要做出这么惊讶的表情。现在再猜猜看，在我们的社会中一个成年人在一天之内会大笑几次？”<br>  “五十次？”我猜测着。<br>  “勉勉强强十五次，”朱利安回答道，微笑中充满胜利感。“你明白我的意思了吧？<strong>大笑是灵魂的良药。如果你能对着镜子开怀大笑几分钟，即使你并不喜欢这样做，你也会忍不住感到很奇妙。威廉・詹姆斯说过：‘我们不是因为快乐才笑，而是因为笑才感到快乐。’所以，让你的一天从快乐开始。大笑，玩耍，为你拥有的一切感恩。由此，每一天都会变得极其有意义。</strong>”<br>  “那么你是如何积极地开始自己的一天呢？”<br>  “说实话，我已经养成了一套非常系统的晨练方式，包括所有的内容，从练习‘玫瑰之心’到喝几杯鲜榨水果汁。但是有一个方法我特别要和你一起分享。”<br>  “听起来很重要嘛。”<br>  “是很重要。<strong>你在刚醒来以后，就到你那个‘个人避难所’去，静下心来，集中精神，然后问自己这个问题：“如果今天就是生命里的最后一天，我将做些什么？’答案就在于准确理解这个问题的含义。在头脑里列出来所有你想做的事情，你想打电话的人们，以及你想享受的时刻。想象你自己正在兴致高昂地完成这些事情。想象自己对待家庭、朋友和完全陌生的人的样子。如果今天就是你活在这个星球上的最后一日，想象自己该怎样度过这珍贵的一天。正如我早先告诉你的，当你在度过每一天时都像对待生命的最后一天那样，你的生活将会焕发出奇异的色彩。</strong> </p>\n<h3 id=\"音乐法\"><a href=\"#音乐法\" class=\"headerlink\" title=\"音乐法\"></a>音乐法</h3><p>智者很热爱他们的音乐。音乐就像太阳一样给予他们同样的精神鼓舞。音乐让他们开怀大笑，让他们闻之起舞，应和歌唱。它对你也会起到同样的作用。千万别忘了音乐的力量。每天在音乐上花一点时间，哪怕只是在你驱车上班的路上听几首轻音乐也好。当你觉得消沉或者疲倦，演奏一会儿音乐吧。这是我所知道的最有效的动力之一。</p>\n<h3 id=\"口语练习法\"><a href=\"#口语练习法\" class=\"headerlink\" title=\"口语练习法\"></a>口语练习法</h3><p><strong>第八招的名字叫‘口语练习法’。智者有成套的‘真言’供他们在早、中、晚念诵。他们对我说这个练习非常有效果，可以帮助他们保持专注，变得更强壮和幸福。 </strong>”<br>  “‘真言’是什么？”我问。<br>  “<strong>真言就是一连串能够产生积极影响的话语。在梵语里面，‘man’的意思是心智，‘tra’的意思是解脱束缚。因此真言‘mantra’这个词语指的就是对心智有计划的解放。而且请你相信我，约翰，真言是达到这一目的的非常有效的方法。</strong>”<br>  “那么你在日常生活中也练习说真言吗？”<br>  “我当然也是这样。无论我走到什么地方，它们都是我最忠实的同伴。不管我是坐在长途巴士上，在走去图书馆的路上，还是穿过一个公园观察着周遭的世界，我总是通过诵读真言来肯定我生命中所有美好的东西。”<br>  “所以真言是口头的？” </p>\n<p>  “<strong>也不一定非要说出来。写出来的形式也一样很有效。但是我发现，大声背诵真言会对我的精神起到奇妙的效果。当我觉得需要动力支持时，就会重复说‘我有创造力，有自制力，有精力’这句真言二百到三百次。如果要保持高度的自信，我就会重复说，‘我很强壮，很能干，很镇静。’我甚至还使用这些真言来保持我的青春和活力。</strong>”朱利安坦言道。<br>  “一句真言又怎么能够让你保持年轻呢？”<br>  “<strong>语言会长久地作用于心智。这是一种古老的心理暗示法，并且屡试不爽。无论是写下来还是说出来，它们都会产生强有力的影响。你对别人说什么很重要，但更重要的是你对自己说什么。</strong>”<br>  “自言自语吗？”<br>  “对呀，<strong>你每天怎样想的，你就是什么样的。你每天对自己说什么，就会变成什么样子。如果你说你又衰老、又劳累，这句话就会在你的外在世界中显形。如果你说自己很虚弱，缺乏热情，这也会成为你现实中的特点。但是，假如你说你很健康，很活跃，充满活力，那么你的生活将得到改变。想想那些身患绝症却依然乐观向上的人们吧，他们就是通过有效的心理暗示为自己争得了珍贵的生命时光。</strong>”<br>  朱利安略微休息了一下，然后接着说：“<strong>你看，你对自己说出的话语影响到你的自我形象的想象，而你的自我想象又将决定你会采取什么样的行动。举个例子说，如果你想象的自我形象是一个没有信心去做任何有价值的事情的人，你所能采取的就不过是与这个特点相似的行动。如果你想象自己是一个充满活力，无所畏惧的人，同样，你所有的行为都会和这一品质相适应。在某种程度上，你的自我形象想象就是对于自我的长久预言。</strong>”<br>  “怎么会是这样呢？”<br>  “<strong>如果你相信自己做不到什么事情，比如说，无法找到一个完美的伴侣或者无法过上没有压力的生活，你的信念就会影响你的自我想象。反过来，你的自我想象也会阻止你采取行动去找到一个完美的伴侣或是为自己创造出一种平静的生活。事实上，它会妨碍你在这个方向上作出的任何努力。</strong>”<br>  “为什么会这样呢？”<br>  “<strong>很简单。你的自我想象其实是某种心理控制。它绝不会允许你在与它不相一致的方式上行事。但是好在你可以改变自我想象，就像你改变人生中其他的方面一样。真言就是完成这一目标的有效方式。</strong>”<br>  “而且啊，当我改变内在世界的时候，也就改变了外在世界。”我发自内心地说。 </p>\n<h3 id=\"个性调试法\"><a href=\"#个性调试法\" class=\"headerlink\" title=\"个性调试法\"></a>个性调试法</h3><p><strong>活力人生的第九招。这个方法是‘个性调试法’。它是我们刚才讨论的自我想象概念的分支。简而言之，这个方法是要求你每天循序渐进地塑造自己的性格。这一过程将影响到你对自我的看法和所采取的行动。你所进行的行为会集中起来，渐渐形成你自己的固定习惯，而你的习惯将会决定你的命运。瑜伽师拉曼对此说得很明了：‘你种下一粒思想，就收获一个行动；种下一个行动，就收获一种习惯；种下一种习惯，就收获一种性格；种下一种性格，就收获了整个命运。</strong>’”<br>  “我应该做些什么事情来塑造自己的性格呢？”<br>  “你可以做任何可以培养美德的事情。在你问我何谓‘美德’之前，先让我澄清一下这个概念。<strong>喜马拉雅山的智者相信，有德行的人生才是意义丰富的人生。所以他们用一系列的古老原则来支配自己的行动。</strong>”<br>  “但是我记得你曾经说过，<strong>他们是用自己的目标来支配人生？</strong>”<br>  “是的，基本上差不多，但是他们的生活愿望在某种意义上还与这些原则相协调，那是他们的祖先在几千年前就已经深深植入他们心灵的。”<br>  “那些原则是什么，朱利安？”我问。<br>  “<strong>简单地说就是：勤劳、慈爱、谦逊、耐心、诚实和勇敢。如果你的行动和这些原则完全相符，你就会感到内在深深的和谐与安宁。依照这种原则来生活无疑会将引领你走上精神世界的成功。这是因为你所做的事情都是正确的。你将按照和自然法则以及宇宙法则相一致的方式来行事。你开始吸收另一个维度上的精力，或者称之为更高的力量。这同时也意味着你的生活将从庸常进入超凡境界，开始体味人生存在的神圣感。这也是毕生启蒙的第一步。</strong>”<br>  “你有过这样的经验吗？”我问。<br>  “有过，而且我相信你也会有的。做正确的事情。依照和你的真实性格相匹配的方式来行动。正直地行事。接受内心的指引。如此一来，其他的事情也会自然而然地好起来。约翰，你永远都不会孤独。”朱利安回答。<br>  “你这话是什么意思？”<br>  “也许我下一次再解释给你听吧，眼下我们不能总是跑题。<strong>你得记住，必须每天做一些小事来培养自己的品格。正如爱默生说的那样：‘品格高于才智。一个伟大的灵魂不仅善于思考，更善于生活。’如果你按照我刚才提到的那些方法来做事，你就会塑造出高尚的品格。如果你不这样做，真正的幸福就会弃你远去。</strong>”</p>\n<h3 id=\"化简法\"><a href=\"#化简法\" class=\"headerlink\" title=\"化简法\"></a>化简法</h3><p>这个方法要求你过一种简单的生活。就像瑜伽师拉曼所说的，‘一个人千万不要生活在肤浅事物中。集中精力于那些最重要的、有意义的事情。这样，你的生活将会清晰有条理，有价值而且格外安宁。这一点我可以向你保证。</p>\n<p>怎样养成化简的习惯？<br>要学会做减法，我们的生活本来已经够复杂的了，不要总是给自己找不痛快。就像我吧，我不再穿昂贵的衣服，我戒掉了一天看六份报纸的瘾，我不再需要让自己随叫随到，我变成了一个素食主义者而且吃得比以前少。从根本上说，我削减了自己的需要。东方的智者曾经有过精辟的总结：‘有容乃大，无欲则刚’。这话多有用啊。你看，约翰，除非你削减自己的需要，否则你永远不会得到满足。你会一直像拉斯维加斯赌场中急红了眼的赌徒，守在轮盘赌转盘前面期待着‘再转一次’，不停地祷告，盼着你的幸运号码马上到来。你会一直想要得到比现在拥有的更多的东西。可事实怎么样，相信不用我再赘言了。</p>\n<p>如果我想把‘化简法’纳入自己的生活，我应该做哪些事情？</p>\n<p> “你能做的事情太多了。即使是小事情也能带来改变。”<br>  “比如说？”<br>  “<strong>电话响起的时候不要每次都慌慌张张地去接听，或许是人家打错了电话；不要在阅读垃圾信件上浪费时间，因为你看后即忘；不再每星期在外面吃三次饭，那样你会变得大腹便便；放弃你的高尔夫会员资格，花更多的时间和孩子们待在一起；一周之内有一天不看手表，你要学会告诉自己：“少了我，地球照样转动’；每过几天就去看一次日出，感受大自然的神奇；把你的手机卖掉，不要成为别人随叫随到的奴役……还要我继续说下去吗？</strong>”朱利安反问道。 </p>\n<p>我向你担保，通过练习这些策略和方法，你会从那一刻起，在一个月之内看到显著的提高。你在生活中的各个方面都将会有更多精力，更少烦恼，更多创造力，更小压力。我前面也已经说过了，智者的方法不是速成型的，肯定没有驱虫药的功效那么神奇。它们都是古老的修行传统，为了你今后生活的宁静，你需要天天练习。如果你停下来一段时间，就会发现自己又逐渐回到旧日的道路上去了。</p>\n<h2 id=\"精神\"><a href=\"#精神\" class=\"headerlink\" title=\"精神\"></a>精神</h2><p>我向你解释的那些秘诀会让你在生活中创造出所希望的一切。但是那些智者的哲学视野要远远高于我们所能看到的地方。到目前为止我教给你的都是非常实用的知识。但是你一定要明白，在我列出的种种原则之下，其实还涌动着许多潜在的精神力量。也就是东方哲人所说的那句‘言有尽而意无穷’。如果你不理解我所说的这些话，不要太担心了。只要你肯听进去，再好好地想上一会儿，之后就会慢慢地理解和接受了。<strong>”<br>  “学生做好准备的时候，老师就会出现，是吗？”<br>  “正是这样，”朱利安说，露出笑容，“你一直学得很快。”<br>  “好吧，</strong>让我们来听听精神的部分<strong>，”我充满活力地说，根本没有注意现在已经快早上五点半了。<br>  “</strong>想象一下，你现在正栖息于日月天空之下，生活在宇宙的所有奇妙之间。创造这些奇迹的智慧就与把你创造出来的那种力量完全相同。你身边的任何东西都是来自同一个地方，我们本是一体，万物皆为一体。”<br>  “我不确定自己是否明白你的意思。”<br>  “地球上每一种活着的生物，地球上每一件看似静止的事物其实都有自己的灵魂。所有的灵魂都汇成一个，那就是宇宙的灵魂。就像是一滴水融入大海，汇成海洋的波浪彭湃。同样，我们也能够从大海中感受到那一滴水的生命律动。你看，约翰，当你养护自己的心智和精神时，你的确也是在滋养宇宙的灵魂。而当你提高了自我，也就是在提高所有存在于你四周的生命。当你有勇气不断接近梦想的方向，你也就开始利用宇宙的力量。正如我此前已经告诉你的，生命回报给你所要求得到的任何东西。它一直在侧耳谛听。<strong>”<br>  “所以说自我控制和‘禅悟’都将通过帮助自己而对别人有所帮助？”<br>  “可以这样说。当你丰富自己的心智头脑，养护自己的身体以及滋养自己的精神时，你都会逐渐确切地理解我所说的这些。”<br>  “朱利安。我知道你讲得很好。但是自我控制对于一个体重97公斤重，在发展客户上花费的时间远远多于自我发展的时间的男人来说，无论如何都是过高的奢望啊。如果我失败了，会发生什么事？”<br>  “</strong>失败是不必费心去尝试的，没有什么大不了。横亘在人们和梦想之间的唯一事物就是对失败的恐惧，然而恐惧又是任何成功都不可缺少的。失败可以检验我们的毅力，让我们得到不断的成长。它给我们教训，并且引导我们走向启蒙的道路。东方的先哲曾经说过，每一支射中公牛眼睛的利箭，都是一百次失误的结果。这就是要求我们明白一个道理：从失去的机会中不断获益，不要害怕失败。失败是你的朋友。**”</p>\n<p>“让我拥抱失败吗？”我半信半疑地问。<br>  “<strong>宇宙青睐勇敢者。一旦当你下定决心要把自己的人生提高到最高的层次上，你灵魂的力量就会指引你方向。瑜伽师拉曼相信，每一个人的命运在他出生的那一刻就已经铺展开了。这条道路将一直通向一个盛满瑰丽宝藏的奇妙所在。每个人都能够培养起走上这条道路的勇气，这是人的天赋。他给我讲过一个故事，在此我想转述给你听。</strong>”<br>  <strong>以前，在古老的印度，有一个邪恶的巨人拥有一座可以远眺大海的辉煌城堡。在巨人去打仗的很多年里，附近村子里的孩子们常常跑到巨人美丽的花园里，非常快乐地玩耍。有一天，巨人回来了，把所有的小孩子都赶出了他的花园。“谁也不许再来！”他一边高喊，一边怒气冲冲地把橡木大门“砰”的一声关上。后来他围着花园建起了一道高大的大理石墙，把孩子们都挡在花园外面。<br>  寒冷的冬天到来了，这在印度是再自然不过的，而那个巨人盼望着温暖早早回来。不久，春天造访了巨人城堡下方的村子，但是冬天的寒冷魔爪依旧拒绝离开他的花园。有一天，巨人闻到了春天的芬芳，感到了太阳穿过窗子照耀进来的温暖。“春天终于回来了！”他大声喊着，跑到他的花园里去了。可是巨人没有想到映入眼帘的是那样一幅场景。村里的孩子们不知用了什么方法终于翻进了城堡，正在花园里高兴地玩儿。正是由于他们的到来，花园从冰封的冻土变成了富饶的土地，盛开着玫瑰、水仙和紫兰花。<br>  所有的孩子都开心地哈哈大笑，除了一个孩子以外。在眼角的余光里，巨人瞥见一个很小的小孩，他比其他孩子个子小得多。他因为没有力气翻过墙头进花园去玩，眼泪从脸上流下来。巨人为那个孩子感到难过，而且在他的一生中，他第一次为自己的恶行感到悔恨。“我要帮助这个孩子。”他说，向他跑过去。当其他的孩子看见巨人出来时，他们都感到害怕得要命，跑出了花园。但是那个个头很小的孩子还站在那儿。“我要杀死巨人，”他结结巴巴地说，“我要保卫我们的游乐场。”<br>  巨人走近小孩子，他张开双臂。“我是你的朋友，”他说，“我来帮助你翻过墙头到花园里去。现在它是你的花园了。”这个小孩子，现在成了孩子群中的英雄。他感到很高兴，把自己一直戴在脖子上的金项链送给了巨人。“这是我的幸运护身符，”他说，“我希望你来拥有它。”<br>  从那一天起，孩子们一直在巨人美丽的花园里玩耍。但是那个最受巨人宠爱的勇敢小孩子却再也没有回来过。时间一天天过去，巨人生病了，越来越虚弱。孩子们还继续在花园里面玩儿，可是巨人再也没有力气和他们作伴了。在那些安静的日子里，巨人最想念的就是那个小孩子。<br>  一天，在特别寒冷的冬季里，巨人从他的窗子里向外看了一眼，看到一个堪称奇迹的景象：尽管大部分花园都被白雪覆盖，在花园的正中却站立着一株漂亮的玫瑰花树，上面开满颜色各异的鲜花。就在玫瑰花树的旁边，站着巨人最喜爱的那个小孩子。小孩子笑得非常甜美。巨人快乐得手舞足蹈，冲出去拥抱了孩子。“这么多年你去哪儿了，我的小伙伴？我一直都在想念你。”<br>  孩子的回答却意味深长：“很多年以前你把我托过了墙头，让我进入你漂亮的花园。现在，我来带你去我的花园。”那天晚些时候，当孩子们再来看望巨人时，他们发现他已经躺在地上去世了，而他的身上从头到脚覆盖着上千朵美丽的玫瑰花。<br>  “只管让自己勇敢起来，约翰，就像那个小小的孩子。站稳你的脚跟，追随自己的梦想，它们会引领你找到自己的命运。跟随你的命运，它将带你领略宇宙的奇妙，带你进入一个满是玫瑰的神秘花园。”<br>  当我抬头看向朱利安，打算告诉他这个故事对我的触动有多么深时，我看到了极其震惊的场面：这个曾经把一生中最好的时光都花在追名逐利上的坚如磐石的律师，在这一刻竟然泪流满面</strong>。 </p>\n<h1 id=\"粉色带子，代表意志力\"><a href=\"#粉色带子，代表意志力\" class=\"headerlink\" title=\"粉色带子，代表意志力\"></a>粉色带子，代表意志力</h1><p>那条粉色的带子用来提醒你记起，在建构起一个更加丰富、幸福和开明的人生中自我控制和纪律所具有的作用。在我遇到的所有人当中，我的那些智者导师无疑是最健康、最安详、最有满足感的一群人。同时他们还是最有纪律性的人。智者教育我说，自律的美德就像那条遮在关键部位上的粉色带子。你有没有花时间研究过一条多股编织的粉色带子，约翰？<strong>”<br>“这个我似乎不太感兴趣。”我咧嘴一笑。<br>“好吧，</strong>有机会好好看上一看。你会发现上面连着很多细小的钢丝，彼此首尾相连。如果单独来看，每一根都很脆弱，不结实。但是一旦把它们合在一起，就要比单根线要结实得多，最后这股带子变得比钢绳铁索还坚韧。自我控制和意志力就与这个道理相类似。为了建起钢铁般的意志，最不可缺少的一个环节，就是坚持做微不足道的小事情，以此来培养自我约束的优良品质。持之以恒，一个小作为累积在另一些更小的作为之上，最终就能像核聚变一样，产生出充沛的内驱力。”<br>朱利安意味深长地看了看我，接着说：“也许有一句古老的非洲谚语最能说明这个道理：‘把蜘蛛网一股一股地连起来，就能捆住一头凶猛的狮子。’当你将自己的意志力释放出来，你就变成了自我世界的主人。当你不断练习古老的自我支配的技巧，就不再会有高得让你跨不过去的障碍，也不再会有难得让你无法克服的挑战，更不再会有紧张得让你无法平息的危机。自我约束会在人生最磕磕绊绊的时候向你提供心智中储备的无穷能力，保证你可以继续坚持下去，直到胜利。<strong>”<br>“</strong>我还必须告诉你一个事实，缺乏意志力将会导致各种不同的心理疾病。这是已经为医学界所证明了的。”朱利安突然又补充说。“如果你饱受意志力缺乏之苦，就要首先尽快改变这一现状。充沛的意志力和纪律性是坚强的性格和多彩人生的主要缔造者。在强大的意志力的支持下，你能够兑现你的诺言。你可以每天坚持在早晨五点钟起床，通过冥想来培养自己的心智。或是在寒冷冬季里的一天，尽管你很留恋被窝的温暖，但强大的意志力还是让你起床到树林中散步，借此滋养自己的精神。在受到别人无礼的指责时，强大的意志力让你保持冷静和沉默。面对突发事件，强大的意志力促使你能够连续克服难关，不断实现自己的梦想。简而言之，正是意志力源源不断地提供内在的激情与力量，让你信守对他人的承诺，而且更重要的是，信守对自己的承诺。</p>\n<p>意志力是一种优秀的品质，人生将因此而变得热情似火，变得宁静而致远。</p>\n<p>艰难时日里就是这段话帮助了我。我希望在你遇到苦难的时候，它也能让你的心灵得到慰藉。这段话说的是：<br>通过铁一般的纪律，你会铸造出勇敢而平和的性格；通过意志与美德的培养，你一定会达到人生最高的理想境界，你会生活在美好、快乐和生机盎然的天堂世界。如果没有这些，你就会像遗失了指南针的水手一样彷徨失路，最终与船只一起沉没。</p>\n<p>你是说，只要进行了正确的训练和适当的准备，我就能达到像圣雄甘地那样高超的意志力水平？”<br>“为什么非要像别人呢，约翰？<strong>其实每个人都是不一样的。瑜伽师拉曼教给我最基本的原则是，真正开悟了的人们绝不以与别人相似为荣。他们更乐意成为新型自我的开创者。不要跟别人赛跑，你要和自己赛跑。”朱利安回答说</strong>。<br>“**当你有了自我控制的能力时，你就会下决心去做你一直想做的事情。对你来说，可能是去参加马拉松长跑训练，掌握橡皮艇冲浪的技巧，甚至是放弃法律职业而成为一位艺术家。无论你的梦想是物质上的富足还是精神上的丰富，我都不会对你指手画脚。我只是想要告诉你，如果你能开启沉睡着的意志力，一切尽在你的掌握之中。”<br>朱利安补充说：“在你的生活中，进行自我控制以及加强纪律性还会带给你巨大的自由感。单单这一点就足以引发巨大的变化。</p>\n<p>“你的意思是？”<br>“<strong>大部分人都是自由的。他们可以去想去的地方，做他们喜欢做的事情。但是有更多的人仍旧是冲动的奴隶。他们消极被动，习惯于见招拆招，却并不具有前瞻性。打个比喻，这些人就像被浪花冲上海岸的泡沫，任凭海潮把它们推向任何方向。当他们正和家人在一起时，如果有同事打电话说有急事，他们就会立刻赶过去，从不停下来想想，到底哪件事情对他们的人生目标来说更重要。所以就我的观察经验来说，无论是在西方还是东方，这种人都拥有自由的权利，却没有享受到真正的自由。在他们身上缺乏一种至关紧要的元素：从看似紧急的情况中选择正确的事情的自由。</strong>” </p>\n<p>“培养意志力能够给我带来更多的自由吗？”<br><strong>“自由好比一所齐整的房子，你一砖一瓦把它垒起来。你要放上去的第一块砖就是意志力。这个品质可以激励你在任何情况下去做正确的事情。它给你提供精力和勇气，让你过上所期望的生活，而不是成为生活的奴隶。</strong>”<br>朱利安还列出了培养意志力能带来的其他很多实际好处。<br>“信不信由你，<strong>培养你的意志力量可以让你消除忧虑的习惯，让你保持健康，给你带来比以往多得多的精力。要知道，约翰，自我控制实际上就是心智控制。意志是心理力量的统帅。如果你掌握了心智，也就掌握了你的人生。对心智的控制源于你能够控制每一个出现在你头脑中的想法。如果你能够把所有软弱的念头都清理出去，仅仅注意那些积极美好的念头，那么积极美好的行为也将相继而来。这样你的人生中也会很快变得积极而美好</strong>。</p>\n<p>“这儿有一个例子。假设说你的个人发展目标之一是每天早晨六点半起床，然后围着你家后面的公园跑步。让我们假定现在正处于严寒当中，你的闹钟铃声把你从恬静的沉睡中唤醒。你的第一反应就是按下闹铃的按钮，然后接着呼呼大睡，心想明天再去真正实行你的锻炼计划。这种状况拖了好久好久，直到你觉得自己太老了，健身计划对你已经太不现实了，于是就放弃了你的计划。”<br>“你太了解我了。”我诚恳地说。<br>“现在让我们来考虑另一种情形。还是在严冬时节，早晨的时候突然铃声大作，你产生了继续待在床上的想法。为了不再成为习惯的奴隶，你开始用更加强大的意志力去战胜它们。你开始在头脑里想象，如果你的体形好到极致，那将是一种什么样子，会有什么感觉，会做什么事情。当你在办公室里信步走过的时候，你会听到同事们的大声恭维你匀称而良好的身材。你不断想象定期的锻炼计划能够让你达到的目标。你再也不会说出庭了一天之后就累得什么也不愿意做，最终只能在电视机前打发晚上的时间。你的生活中将充满了活力、热情和意义。”</p>\n<p>“但是假如我这样做了，还是想回去睡觉，不出去锻炼呢？”<br>“最初的几天当然会有一点困难，你更容易回到旧习惯中去。但是瑜伽师拉曼特别坚信一条古老的法则：积极总是能战胜消极。所以，如果你能够继续向那些多年来渐渐蚕食掉你的软弱思想作斗争，最终这些思想会像自知不受欢迎的访客一样灰溜溜地不告而别。”<br>“你是想要告诉我思想也是一种实际存在的东西？”<br>“是的，而且它完全在你的控制之中。思考积极的想法和消极的念头一样容易，然而效果大相径庭。”<br>“<strong>那么为什么还有那么多人在忧虑，在关注我们这个世界上的负面信息？</strong>”<br>“<strong>因为他们还没有学会自我控制的技巧，不会限制思考的方向。在我曾经交谈过的人群当中，有很多人都根本没有想过，自己竟然还有力量去掌控生活中每天、每分、每秒出现的每一个想法。他们相信思想不过是偶然发生的，却根本没有认识到，如果你不花时间去控制自己的想法，它们反过来就会控制你。这是一场控制与反控制的战争，可能很漫长，甚至会终其一生。如果你能够把注意力集中在美好的事物上，借助真正的意志力拒绝那些负面思想出现，我向你保证，它们很快就会卷铺盖离开了。</strong>”<br>“所以，如果我想要拥有内在的力量，能够早些起床，少吃饭、多读书，不忧虑、更热情，我要做的就是将意志的力量全部发挥出来净化我的思想。”<br>“<strong>当你控制了你的思想，你就控制了自己的心智。当你控制了自己的心智，你就控制了自己的人生。一旦你能够完全控制自己生活，你就成为了自己命运的主人。</strong>” </p>\n<h2 id=\"培养意志力的方案\"><a href=\"#培养意志力的方案\" class=\"headerlink\" title=\"培养意志力的方案\"></a>培养意志力的方案</h2><h3 id=\"重复一些简单的语句：真言-创造性想象\"><a href=\"#重复一些简单的语句：真言-创造性想象\" class=\"headerlink\" title=\"重复一些简单的语句：真言/创造性想象\"></a>重复一些简单的语句：真言/创造性想象</h3><p>尽管只有为数不多的喜马拉雅山上的智者知道这些真言，但是它们已经历经了五千余年时光的磨炼。瑜伽师拉曼告诉我，如果不断念诵它们，就可以在很短的时间内培养起自我控制能力和内在的意志力。记住，语言具有巨大的影响力和暗示效果，词语就是自身力量的文字体现。在你的头脑里装满充满希望的话语，你就会变得信心十足；在你的头脑里装上善良的话语；你就会变得善良而开朗；在你的头脑里装上勇敢的话语，你就会富有勇气。话语就是力量。<strong>”朱利安总结说。<br>“好吧，我洗耳恭听。”<br>“</strong>我建议你每天把这句真言至少重复三十遍：“我比外表看起来更强大，世界上所有的力量都在我的身体里。’它会在你的生活中带来持久的改变。要是想让这句话迅速起效，就把这句话和我前面告诉过你的创造性想象的练习结合起来。比如说，去找一个安静的地方。坐在那里闭上双眼，不要分散心神，保持身体静止不动，因为意志薄弱者最明显的一个特征就是身体闲不下来。然后大声重复这句真言，一遍又一遍地重复。在你做这些的时候，把自己看作是一个遵守纪律、意志坚定的人，能够完全控制自己的心智、身体和精神。在内心里想自己要像甘地和特蕾莎修女在面对艰难时刻的所作所为那样行事。随后产生的效果一定会让你大吃一惊的。”朱利安信誓旦旦地说**</p>\n<h2 id=\"两个方法\"><a href=\"#两个方法\" class=\"headerlink\" title=\"两个方法\"></a>两个方法</h2><h3 id=\"试着去做你不喜欢做的事情\"><a href=\"#试着去做你不喜欢做的事情\" class=\"headerlink\" title=\"试着去做你不喜欢做的事情\"></a>试着去做你不喜欢做的事情</h3><p>第一件事就是试着去做那些你不喜欢做的事情。对你来说，这些事情可能很简单，比如早晨起来叠被子，步行上班而不是驾车去。通过养成尽力而为的习惯，你会很快改变顺从软弱和冲动的毛病。**”<br>“不用则废？”<br>“完全正确。为了塑造意志力和内在力量，你首先要使用它。你越是努力培养内在约束的胚芽，就会让它成熟得越快，让你更快地看到你所希望的结果。” </p>\n<h3 id=\"沉默的誓约\"><a href=\"#沉默的誓约\" class=\"headerlink\" title=\"沉默的誓约\"></a>沉默的誓约</h3><p>实际上那种誓约就是这样的，约翰。那些推崇这一方法的西藏喇嘛相信，长时间的完全的噤声有助于提高一个人的内在自律性。<strong>”<br>“这是怎样做到的？”<br>“</strong>从原理上说，通过一天的沉默不语，你可以使你的意志完成你命令它做的事情。每当想要说话的念头出现，你就立刻抑制这个冲动，继续保持安静。你看，意志本身不会产生任何想法。它等待着接受你的引导，刺激它采取行动。你越能控制自己，意志的力量也就越强大。问题是大部分人根本就没有使用他们的意志力。<strong>”<br>“为什么会这样？”我问。<br>“</strong>也许是因为大部分人认为他们根本就没有意志力。他们为这种明显的软弱怨天尤人，却不从自己身上找原因。那些火暴脾气的人会对你说：‘我抑制不住呀，我的父亲也是这个样子。’那些过度焦虑的人会对你说：‘不是我的错，我的工作压力太大了。’那些整日酣睡的人会说：‘我能怎么样呢？我的身体需要每晚十个小时的睡眠。’这些缺乏自我负责能力的人从不知道，在我们每个人的体内都沉睡着不可思议的潜能，期待着受到鼓舞，然后转化为具体的行动。当你渐渐了解古老的自然法则，知道它们支配着宇宙的运转以及所有生活在其中的生命，你就会明白成为你想成为的人是你天赋的权利，你有能力改变你所处的环境。同样，你有能力摆脱过去时光的束缚，让自己得到前所未有的自由。为了达到这一目的，你必须成为意志的主人。</p>\n<h1 id=\"金秒表，代表时间\"><a href=\"#金秒表，代表时间\" class=\"headerlink\" title=\"金秒表，代表时间\"></a>金秒表，代表时间</h1><p>原来是一个缩微型的沙漏，用褐色的玻璃和一小块檀木底座制成。看到我略带惊讶的表情，迪维笑了笑，温和地告诉我，每一个智者在孩提时期都收到过一件同样的器具。‘尽管我们身无长物，过着纯粹、朴素的生活，但是我们尊崇时间，并且注意到它在一刻不停地流逝。这只小小的沙漏是对我们每个生命一刻不停走向死亡的提醒，提醒我们在向目标接近的过程中，过一种充实的生活和有所创造的日子是多么重要。因为，正如人不可能同时踏入第二条河流之中，人也不可能返回来，重新开始同一次生命的历程。’<strong>”<br>“那么，这些生活在喜马拉雅山上的高僧也重视时间吗？”<br>“他们中的每一个人都深知时间的重要性。</strong>他们每个人都培养起了我所说的‘时间意识’。你瞧我们已经明白地意识到，时间就像沙粒一样从我们的指缝中毫不留情地漏下去，不再复还。那些早年就能够明智地利用时间的人会收获一个丰富的、多产的、心满意足的人生。而与此相反，那些从来没有感受到‘掌握时间就是掌握生命’这一原则的人，永远也不会发现他们本性中其实曾经拥有着巨大的潜能。时间是最伟大的神，也是最公平的分配者。无论我们是特权者还是贫苦阶层，无论是生活在得克萨斯还是生活在东京，我们都被分配到一天二十四小时的时间，谁也不多一秒钟，谁也不少一秒钟。而最终真正能把创建了杰出人生的大人物和随波逐流的庸才区分开的，恰恰是他们对时间的不同使用方式，简而言之，就是不同的时间观念。<strong>”<br>“但是我曾经听我父亲说过，正是最忙碌的人才最有空闲。你对此怎么评价？”<br>“我赞同。忙碌的、能干的人总是能够高效地使用他们的时间——他们必须要生存下去。但是，成为一名最优异的时间安排者，却并不意味着必须把自己变成一个彻头彻尾的工作狂。相反，有效的时间控制能够让你有更多的空闲去做自己喜欢的，真正有意义的事情。控制好时间才能控制好人生，所以要好好守护时间。记住，这是不可再生的资源。”<br>“那我现在就给我的表上好发条。”我们一起笑了起来。<br>“让我再给你举一个例子吧，”朱利安提出建议，“</strong>让我们假设这是星期一的早晨，你的时间表上排满了约见、会议和庭审出席的日程。往常，你会在早晨六点半就起床，一口吞下一杯速溶咖啡，飞奔着赶去工作，然后昏天黑地地度过了非常紧迫的一天。好，接下来让我们假设有一次，你在星期天的晚上抽出了十五分钟的时间来计划自己的安排。或者说为了更加高效，让我们假设你在平静的周日上午抽出了一个小时来安排整个一周的生活。在你的每日计划表中，你标出什么时候会见客户，什么时候你要做法律研究，还有什么时候你要回一些重要的电话。最重要的是，在一个星期之内，你把在个人、社会和精神方面的发展目标也都列入了你的记事本。这个简单的举动是保持生活节奏平衡的奥秘。通过在每天的日程表上锁定生活中所有最至关重要的方面，你可以确保这一个星期的生活过得充实又有条不紊。<strong>”<br>“你是不是建议我从每天繁忙的工作中抽出一点时间来休息，然后去公园里散步或者躲到一个地方沉思冥想？”<br>“是的。你为什么非要那么严格地遵守惯例呢？你为什么一定要像其他人一样用同样的方式行事呢？</strong>走你自己的路好了，不要在乎别人怎么看，关键是要让自己觉得舒服自然。你为什么不提前一个小时开始工作，这样就可以有足够的闲暇在中午的时候放下手头的工作，到办公室附近的美丽公园里平心静气地散步。还有，为什么不在一周刚刚开始的时候就向工作里投入更多的时间与精力，这样就可以在周五下班之前早早收尾，然后快快乐乐地带上孩子去动物园玩一会儿。还有，为什么不在一个星期内抽出两天的时间在家里工作，这样就可以更多地照顾家庭。我说的所有这些都是为了让你更有创造性地作出一周的计划，合理地安排时间，当然并不是非如此不可。一定要把时间列在你首要关注的核心位置上，它会让你明白，人生中最有意义的事情决不应该为了最不重要的事情而作出无谓的牺牲。**” </p>\n<p>忙碌并不是借口。真正的问题是，你要随时问自己，你究竟在忙些什么？我从那些年老的智者那里学会了一条伟大的法则：你在一生中获得的80％的成果，常常来自于你仅仅花了20％的时间来完成的事情。瑜伽师拉曼把它叫作‘古老的二八法则’。</p>\n<p>你的意思是指，那些‘高效能’的时间就是指我花在提高自己法律知识上的时间，和我的客户一起丰富人际关系的时间，还有为了成为更能干的律师而投入的时间？”<br>“是的，还有你为了培养亲情而和詹妮以及孩子们一起度过的那些时间。” 朱利安的回答相当肯定，然后他又做了一个补充：“还有花在自然中的时间，这是你对自己有幸拥有的一切而表示感恩的时间，也是用来更新你的心智、身体和精神空间的时间。以上这些都是‘高效能’的行为，帮助你得以从容规划出一个值得度过的人生。当然，有一些无效的时间付出是你没有办法避免的。我的意思是说，设法将自己的时间尽量多地投入在这些有意义的行为上。古希腊的哲人早就说过：‘已经得到启蒙的人最先获得生命的动力。’这就是控制时间的秘诀。</p>\n<p>那么就尽量学着去简化你的生活吧，”朱利安同情地建议我，“把减法应用在生活的每个方面。这样做以后，你就可以有时间去欣赏美好的、奇妙的事物。最难过的事情是我们任何一个人都不能为了领略到更多的美好而把自己的生命向后推延。我常常会有一种时不我待的悲伤。然而，有太多的人梦想在遥远的将来能看到神奇的玫瑰，却不去看一眼长在自家后院里的花朵。这真是一个莫大的悲剧。</p>\n<h2 id=\"把时间花在精肉部位\"><a href=\"#把时间花在精肉部位\" class=\"headerlink\" title=\"把时间花在精肉部位\"></a>把时间花在精肉部位</h2><p>生活就像一长条熏猪肉，”我插话说，“为了有效掌握你的时间，就必须把肥的、瘦的细细地区分开来。” </p>\n<p>“说得好极了，约翰，你真讲到点子上了。尽管我的素食主义立场告诉我不应该选取这样一个禁忌性的话题，不过说老实话，我还是很喜欢这个比喻。<strong>尽管有些粗俗，但你的确一语道破了机关。当你把时间和珍贵的心智精力投入到精肉部位以后，就没有时间在肥肉问题上浪费那些无谓的时间了。这就是你的生活从平庸变为非凡的关键。</strong></p>\n<h2 id=\"要学会说‘不’\"><a href=\"#要学会说‘不’\" class=\"headerlink\" title=\"要学会说‘不’\"></a>要学会说‘不’</h2><p>你的话让我想到另外一个问题。别让他人窃取你的时间，要警惕无处不在的时间窃贼。<strong>在你哄孩子睡觉，或者刚刚在心爱的椅子上坐下开始读一本你早已如雷贯耳的惊悚类小说时，总是有些人会在这个时候打来电话，然后天南海北地和你胡侃一通，然而他们不知所云的所谓高见早已将你的兴致破坏得面目全非。他们这类人专门会在某个特定时刻敲开你的办公室，然后赖在那里高谈阔论。而那时你好不容易才从疯狂忙碌的一天中抽出几分钟来，想一个人静静地待一会儿，喘上一口气，清理一下思路。这些情形听起来还熟悉吗？”<br>“太常见了，朱利安，你说的一点也不错。我相信，以前你受到的骚扰比我更甚，因为你比我更有名气。不过，这些人似乎总是很难拒绝的，我感觉如果直接请他们离开或者紧闭房门是不礼貌的。”我向朱利安说出自己的心事。<br>“</strong>你必须学会不留情面，才能真正履行自己的时间规划。要学会说‘不’，要有勇气对生活中的琐事断然说‘不’，只有这样，你才会有力量对那些重要的大事说‘好吧’。当你需要花费几个小时来专攻一个大案件的时候，当然要关紧办公室的门，连秘书都是非请莫入。记着我告诉你的话，不要每次电话一响你就去接听。这要看你是否方便，而不是看其他人的方便。要将主动权牢牢掌握在自己的手中。很讽刺的是，当他们发现你是一个惜时如金的人时，不但不会非议你的‘无礼’，相反会对你更加尊敬。他们会觉得你的时间很宝贵，因此就会重视你的时间安排，也不会无端地打扰你，从而还你一份清静。**” </p>\n<h2 id=\"拖延时间又该怎么解决？\"><a href=\"#拖延时间又该怎么解决？\" class=\"headerlink\" title=\"拖延时间又该怎么解决？\"></a>拖延时间又该怎么解决？</h2><p>我总是把不喜欢做的事情不断地、不断地向后推延，要到非做不可的地步才怏怏地动手。可是另一方面我又把大量的时间花在浏览垃圾信件、翻阅成堆的过期法律杂志上。也许我这样做只是为了消磨时间？”<br>“消磨时间只是一种说法。实际上，<strong>人的本性是趋利避害的。你不喜欢做一些事情，因此你的天性就会传达一种负面的情绪。但你同时又知道，这些事情如果不及时处理，那结果就会更糟糕，这个时候现实理性又会逼迫你及早动手。于是痛苦就产生了。但是就像我早先说过的，这个世界上最能干高产的人具有做好任何事情的习惯，哪怕这些事情可能是他们不喜欢做的，而不能干的人却养成了不做事的习惯。</strong>”<br>我不再答话，开始深刻反思刚才听到的话。<strong>也许拖延并不是我个人的问题，或许只是因为我的生活变得太复杂了，而朱利安一下子就抓住了我的关键。 </strong></p>\n<p>“<strong>瑜伽师拉曼告诉我说，那些掌握了时间的人生活会更加简单。匆忙、狂热的节奏并不是人类本性的趋向。他坚信并一直向我重申，只有那些做事高效并为自己设有明确目标的人才能得到永恒的幸福。这就是我所学到的智慧中最令人着迷的地方。它使我的工作优质而高产，同时又能够完全满足精神上的渴望。在某些时候，工作反倒成为了游戏。</strong>” </p>\n<h2 id=\"打一个小盹儿\"><a href=\"#打一个小盹儿\" class=\"headerlink\" title=\"打一个小盹儿\"></a>打一个小盹儿</h2><p>我喜欢在下午的时候打一个小盹儿。我感到这能使我保持活力充沛，更新精力，有蓬勃的朝气。我想可以这么说，我需要美容觉。</p>\n<h2 id=\"临终心态\"><a href=\"#临终心态\" class=\"headerlink\" title=\"临终心态\"></a>临终心态</h2><p>迪维在送给我这个小沙漏时还给了我几条忠告，我永远也不会忘记。”<br>“她说了什么？”<br>“<strong>她告诉我，种树的最佳时间是四十年前，其次就是今天。不要浪费生命里的任何一分钟。要有一种临终心态。</strong>”<br>“你再说一遍？”我问他，朱利安采用的生动词语使我惊呆了。<br>“什么叫临终心态？”<br>“<strong>这是东方哲学中的一种生命观，也可以称其为‘向死而生’。这是你看待人生的新角度。它会提醒你，也许今天就是生命的最后一日，所以好好享用吧。</strong>”<br>“哈，如果你想知道我的真实感觉，朱利安，那我就老老实实地告诉你，这个话题我觉得很可怕啊，它让我想到了死亡。”<br>“*<em>确实如此，这就是生命的哲理。当你抱着这种临终心态，你会把生命中的每一天都当成最后一天。想象一下，每天早晨醒来以后，问自己一个简单的问题：“如果今天是我生命的最后一日，我将会做些什么？’接下来，考虑你将如何对待自己的家庭、同事，乃至你根本不认识的人们。想一想你将多么能干，多么振奋，在你手中，每一时刻的价值都实现了最大化。单单是这个临终问题就拥有改变人生的力量。它会让你每天都活力充沛，在做每件事时都带着丰富的热情和开朗的精神。你会开始注意那些一度被你不断拖延的、意义深远的事情，而不会在那些把你拖入危机和深渊之中的琐屑小事上无谓地浪费时间。”<br>朱利安继续说：“鞭策自己去做更多的事，体验到更多的新鲜事物，促使你把精力用在扩展自己的梦想上。对，扩展你的梦想。不要安于碌碌无为的人生。既然你在心智的源泉中拥有如此无限的潜力，就要敢于让‘伟大’这个词和自己的生命联系起来。这是你的天赋权利。</em></p>\n<h2 id=\"表现得好像你不可能失败\"><a href=\"#表现得好像你不可能失败\" class=\"headerlink\" title=\"表现得好像你不可能失败\"></a>表现得好像你不可能失败</h2><p>有一个简单的方法，可以为很多人消除意志消沉的苦恼，这种苦恼的确会让人感到非常难受<strong>。”<br>“我的杯子正空着呢。”我虚心地说。<br>“</strong>表现得好像你不可能失败，这样你的成功就有保证了。把所有觉得不能达到目标的想法都从头脑中清除出去，无论是物质方面的，还是精神方面的。勇敢点，不要给自己的想象设限。不要成为过去记忆的奴隶，而是要做未来的设计师。从此，你就不再是从前的自己了。</p>\n<h2 id=\"奉献是人生的终极目标\"><a href=\"#奉献是人生的终极目标\" class=\"headerlink\" title=\"奉献是人生的终极目标\"></a>奉献是人生的终极目标</h2><p>在印度有一句古老的谚语：‘我们不是有着精神体验的生命存在，而是有着生命经验的精神存在。’通过长时间的修行和游历，我想现在可以说，我真正理解了自己在宇宙中的角色。我终于在自我的镜像之中看到了我是谁。我不再处于世界当中，世界在我的心中。那种体验是什么样的呢？我也描绘不出来。这样吧，我给你诵念东方哲人的两句诗：君掌盛无边，刹那含永劫。<strong>”<br>“我觉得我必须好好考虑一会儿你刚才说的那句话，尤其是最后那两句诗。你知道，我在大学里最害怕文学与语法修辞类的考试。”我老老实实地说，因为我真的不太理解朱利安说的话。<br>“当然。我理解，我的朋友，总有一天你会理解我所说的一切。如果你能够按照我告诉你的方法去做，认真练习我向你提供的诸多技巧，你就一定会在启蒙的道路上不断前进。你将慢慢掌握支配自我的技巧，而且你也将发现自己生命的意义到底是什么：那不过是永恒图景上的一点微光。而且你也将逐渐明白你究竟是谁，知道人生中的终极目标是什么。”<br>“</strong>那目标是什么呢？”我越来越有好奇心了。<br>“当然是奉献。无论你的房子有多么大，或者你开的汽车有多么炫目，但是你在生命结束的时候都不能将它们带入坟墓，唯一相伴的只有自己的良心。所以，你要时刻侧耳倾听自己良心的声音，让良知引导你。它知道什么是对的，它会告诉你，你的使命就是无私地帮助他人。这就是我的人生漫游经历带给我的最大的收获。眼下，我有非常多的人要去会面，为他们服务、治疗。我的使命就是把智者的古老智慧传播给所有需要学习它的人们。这就是我的目的。**” </p>\n<h1 id=\"玫瑰花，代表无私地帮助别人\"><a href=\"#玫瑰花，代表无私地帮助别人\" class=\"headerlink\" title=\"玫瑰花，代表无私地帮助别人\"></a>玫瑰花，代表无私地帮助别人</h1><p>我和你分享的品质中最不可缺少的一条，约翰，就是这个：无论你取得怎样的成就，无论你拥有了多少套夏季别墅，无论你家的车道上泊着几辆高档小汽车，你的人生质量还是要归结到你所作出的贡献的质量上来。<strong>”<br>“这是不是和瑜伽师拉曼的寓言里那些鲜艳的黄玫瑰多少有点关系？”<br>“当然有关系。</strong>这些花会提醒你想起一句古老的中国谚语：送人玫瑰，手留余香。这句谚语的意思很清楚——当你致力于提高别人的生活时，在这个过程中你也间接地提高了自己的人生品质。如果你每天都有意地随时随地做出一些善举，你自己的人生也将因此而变得更加丰富，更加有意义。为了培养日常生活中的神圣感和尊严感，从现在开始就用各种方式帮助他人吧。<strong>”<br>“你是不是在建议我多去参加一些志愿者活动？”<br>“嗯，</strong>应该说那是一个良好的开端。但是我所说的比参加志愿者活动这个具体的事件具有更多的哲学性。我是在建议你，你要对自己在这个星球上要扮演的角色采取一种新的理解‘范式’。<strong>”<br>“你又把我搞糊涂了。拜托你把‘范式’解释得清楚一点，我实在不熟悉这个词。”我请求道。<br>“</strong>简单来说，范式就是人们通常看待生活境况和生命过程的一种方式。有些悲观主义的人把人生看成一只半空的杯子，而乐观主义者则视之为半满的杯子。你看，‘半空’与‘半满’，对于同一种存在的境况竟然有不同的解释，这就是因为观察者采用的范式不一样。范式从根本上说就是一面透镜，你要通过它来观察人生历程中各种事件，无论是对外在世界还是内在世界。<strong>”<br>“因此当你建议我采用一种新的范式来看我的人生意义，是不是说我应该换一种眼光？”<br>“</strong>在一定程度上是这样的。为了显著提高你的生活品质，你必须针对自己为什么会在地球的这一处地方生活而不是那一处地方生活找出一个原因。你必须认识到，正如你两手空空来到这个世上一样，你注定是要两手空空地离开的。在这种情况下，只有一个真正的原因说明你身在此地的存在价值。<strong>”<br>“那会是什么？”<br>“</strong>把自己无私地奉献给他人，通过有意义的工作方式来作出应有的贡献。<strong>”朱利安回答说。<br>“我并不是说你不能享受你的生活，或者说你必须放弃自己的法律事业，然后有意让自己的生活变得穷困潦倒，好像只有这样才能全身心地投入到无私服务社会的行动中去——虽然我最近常常见到一大批散尽家财、投身慈善事业的人，而且看上去他们个个都心满意足——你要明白，我们的世界目前正处于大变革当中。”<br>“大变革？”我有些迷惑不解了。<br>“</strong>是的，大变革。对比一下过去30年和今天的生活，你就会发现人们对于意义与价值的理解发生了翻天覆地的变化，人们开始用钱换取人生意义。比如过去的律师只会按照委托人钱包的尺寸来做出是与否的判断，而现在则不同了，真正的律师会按照人们对他人的责任大小和爱心的大小来作出自己的判断。教师们辞去稳定又保险的大学工作，为生活在城乡结合部的贫困孩子无偿提供义务素质教育。在这个大变革的时代里，有良知的人们已经听到了呼唤价值改变的铃声，人们已经重新认识到自己生存的目的。这一目的无法用金钱和社会地位来衡量，而且他们已经得到了帮助自己去实现这个目的的特殊天赋。<strong>”<br>“究竟是什么特殊天赋？”<br>“</strong>确切地说，就是我花了整整一个晚上来告诉你的那些因素：丰富的心智，无穷的精力，无限的创造力，坚强的意志力和内心的安宁。而现在你要做的就是勇敢地开启这些宝藏，在日常生活为了公众的利益而使用它们**。</p>\n<h2 id=\"摆脱自我的枷锁\"><a href=\"#摆脱自我的枷锁\" class=\"headerlink\" title=\"摆脱自我的枷锁\"></a>摆脱自我的枷锁</h2><p>那么<strong>怎样才可以开始做好事呢？</strong>”<br>“<strong>做好事不分时间先后、事情大小，你可以随时随地将自己的爱心传递给别人。再稍微抽象一些，那我的回答也很简单，就是把‘做好事’这种理念放在改变自己人生观、世界观的首要位置上，这样你就可以不再把自己看成是一个简单的个体，而会开始把自己看作是集体洪流中生动鲜活的一分子。</strong>”<br>“那么我是不是得变得再善良点儿，再温柔点儿？”<br>“要知道，你能做的最崇高的事情就是给予。”朱利安双手伸向空中。<br>“<strong>东方的智者将这个过程叫作‘摆脱自我的枷锁’，就是要你丢掉自我意识，开始关注更高的目标。也许这在某种程度上意味着你要向周围的人付出更多的时间和精力，尽管它们是你最有价值的两种资源。</strong>”<br>“资源？”我有些不解地问。<br>“对，是资源，”朱利安再次露出耐心的微笑，“如果按照最高标准来要求的话，可能是你抽出一年当中休假的时间，毫无报偿地为街区里的穷人做义工；如果按照最低标准来要求的话，可能是在交通极端堵塞的时刻，不再骂骂咧咧，不再抢着见缝插针，而是摆一摆手，让车流中别的车子先开走。”<br>“哦，听起来像个交通警察在给我上课，朱利安。”我想起下班路上一到塞车时候就灌满满街道的喇叭疯响，不由得有些烦躁。<br>“哈，朋友，安静点。<strong>听起来是有些老生常谈，但是在我所有领会到的道理中有一条非常重要——只有当你开始努力让世界变得更加美好，你的生活才会因此向更好的方向上推进。我崇敬的智者瑜伽师拉曼说过：在我们出生的时候，世界一片欢腾而我们哇哇大哭；如果我们一生的时间都在帮助别人，在为世界变得更美好的工作中度过了一生，那么等到我们死去的时候，世界在哭泣，而我们却很欢喜。</strong>” </p>\n<h2 id=\"每天做好事\"><a href=\"#每天做好事\" class=\"headerlink\" title=\"每天做好事\"></a>每天做好事</h2><p>他们不过是需要有一点良知的火花来点亮同情的蜡烛。丰富的同情心和日常的善行会使你的人生更加丰富。每天早上在鸟鸣中醒来时，先别忙着起床，躺在温暖的枕头上抽出一点时间来考虑一下，在这即将开始的一天当中，你将为别人做哪些好事。你可以赞美那些对自己失去了信心的人，赞美那些最不指望得到赞美的人，给陷入困境的朋友送去温暖，还可以向家里的亲人们表示自己的感激和爱意。所有这些加起来，不就构成了更加美好的生活吗？而说到了友谊，你一定要不断维护它。一个拥有三个铁哥们儿的人其实是非常富有的。</p>\n<p>我得承认，我的内心已经完全被朱利安的话征服了，不过我还是故作轻松地和他打趣：“在中国话里这就叫作‘一个好汉三个帮’对吗？”<br>朱利安对我竟然知道一句中国的谚语表示惊奇，不过他还是点点头赞许了我。“是啊，朋友给生活中增添了欢乐、兴趣和美丽。没有什么比和一个老朋友在一起开怀大笑更能让人恢复青春活力了。当你在工作上有了点成就，就开始狂妄自大，太拿自己当回事的时候，朋友的良言会帮助你保持谦卑。当生活给你带来了小小的挫折，你以为世界末日就要到来时，好朋友会一如既往地守在那里给你帮助。就以我为例吧，当我还是一名忙忙碌碌的律师的时候，我几乎没有时间交朋友，当然那些生意上的伙伴不算。在经过了长期与世隔绝的生活之后，在这个世俗的社会里，我是彻彻底底的孤家寡人了——除了你以外，约翰。我找不到一个人来陪伴自己去森林里远足，因为他们每个人都舒舒服服地待在温柔醉人的睡眠安乐窝里。当我读完了一本非常精彩的、深深地打动了我的书以后，却找不到人可以与我一起分享，我甚至连一个可以一起争辩讨论的朋友都没有。当金秋的阳光温暖了我的心扉，让我满怀欣喜的时候，我找不到一个值得信任的朋友可以敞开灵魂去倾诉。”<br>朱利安很快控制住了自己的情绪，也许他很快便想起了住在喜马拉雅山顶的那些智者。他们不仅是他的老师，也是他的朋友，甚至从某种意义上说已经成为他的家人了。<br>“不过，我没有时间让自己深陷于遗憾情绪的负面影响。<strong>我的智者导师们一直在教育我说：“对于开悟的人来说，每个黎明都将是崭新的一天。</strong>’” </p>\n<h1 id=\"钻石，代表活在当下\"><a href=\"#钻石，代表活在当下\" class=\"headerlink\" title=\"钻石，代表活在当下\"></a>钻石，代表活在当下</h1><p>我基本上同意你的观点。我们确实应当对那些能够激发兴趣的目标表示出孜孜以求的积极态度，因为这是确保个人成就感的根源。但是还不止与此，你要记住，幸福是一场旅行，不是目的地。因此，你要时刻提醒自己，要为了今天的生活质量而活着——再也不会有另外一天会和今天一样了。”朱利安说，双手安详地交叠在一起。 **<br> “在瑜伽师拉曼的寓言里，这个道理的象征物就是那条铺满钻石的小路吧？”我问他。 </p>\n<p> “是的，”朱利安的回答简洁而明快，“<strong>那位高大的相扑选手走在钻石小路上，最终获得永恒的满足感和欢乐。就像他一样，只要你明白你当前所走的道路也铺满了钻石和其他诸多无价珍宝，那么你也能够拥有你想要获得的生活。不要再把时间过多地花在纵情享乐之中，因为人生更多地是由那些微小的快乐组成。尽管你常常忽视它们的存在，但正是它们在浸润着你的内心世界，让你变得善良而乐观，无私而勇敢。我的朋友，好好地享受围绕在你身边的美丽和圣洁吧，这些神奇之物全靠你自己去发现。</strong>”<br> “你的意思是不是说我应该先停下来，不再给未来的人生设置远大目标，而是要把注意力转移到当前的生活中来？”<br> “当然不是这个意思，”朱利安斩钉截铁地回答，“<strong>正如我在前面和你说过的那样，面向未来的目标和梦想非常重要，这在每一个真正成功的人生当中都是不可缺少的。正是因为怀有对未来事物的热望，才让你每天早晨坚持从热被窝中迅速爬起来，并且在一天的工作中保持着饱满的精神和注意力。树立人生的目标，就意味着给你的生活加油。我的意思只是说，不要为了成就就放弃快乐。不要把那些可以带给你幸福感和满足感的事情推迟到以后再去做。今天，就是今天就要活得畅快淋漓，而不是苦苦等到赢了体育彩票或者终于熬到退休以后。千万不要把生活中的幸福向后推迟，因为再晚可能就没有机会了。</strong>”<br> 朱利安站了起来，开始在起居室里来来回回地踱步。这时候他似乎又恢复了大律师的样子，在即将结束一场热情洋溢的辩论时作最后陈词。 “不要再自欺欺人，以为只要你为律师事务所再多雇用几个初出茅庐的律师来减轻工作负担，你就会马上变成一个更爱你的妻子，肯为家庭付出的好丈夫。”他的最后陈词和以往一样精彩，我看着此时的朱利安，竟然有些恍惚，觉得他从来都没有离开似的。但是他坚定的声音把我再次拉回眼前。<br> “<strong>不要自欺欺人，以为只要银行户头上有了足够大的数目，自己就自然会有更多的自由时间，可以为所欲为，放肆起来。不要试图让自己想象，只要有了钱有了闲，你就会开始丰富自己的心智，开始关心自己的身体，开始滋养自己的灵魂。这些都是自欺欺人，我们都很明白这一点。今天，就是今天，是你享受多年来努力成果的时候。今天就是抓住眼前一刻，度过充实人生的时候。今天就是抛开忧虑的想象，让心中的梦想跃然成真的时候。而且，在你为自己创造幸福的时候，请你千万、千万不要忘记家庭给予你的丰厚馈赠。</strong>” </p>\n<p>“我不敢肯定自己完全理解你的意思了，朱利安。”我没有跟上他的语言跳跃。<br> “<strong>和自己孩子一起经历童年。</strong>”非常简单的回答背后似乎隐藏了什么。<br> “嗯哼？”我小声咕哝了一句，在这句似是而非的话面前仍然摸不着头脑。<br> “<strong>在人的一生中，几乎没有什么事能比你和孩子们一起分享童年更有意义了。如果你在第一个阶段里就忘了和孩子相伴，又怎么可能走向此后的幸福呢？然而，要是你根本没有时间没有能力来创造一个家庭，那么就算你拥有了整个街区当中最大的房子又有什么好处呢？如果你的孩子们根本就不知道给他们生命的父亲是谁，那么就算你名满全国，当上了炙手可热的第一辩护律师又有什么用处呢？我知道我说的是什么。</strong><br> ”朱利安用我们的职业举例子，我感到他的声音因为激动而微微有些发颤。 朱利安的最后一句话使我感到困惑。我所了解的朱利安是一个超级明星律师，每天周旋在珠光宝气和灯红酒绿之中。他和红极一时的时装模特在豪华酒店里的浪漫约会，和他在法庭上滔滔不绝的辩论技术一样广为人知。这个做了多年花花公子的百万富翁怎么可能知道如何做好一位父亲？他又怎么可能知道我每天都要面对的挣扎，想要做好每一个角色要求的每一件事，在家里我得是一个了不起的父亲，出门以后我得是一个成功的大律师？所有这些琐碎的烦恼，朱利安怎么可能知道？我虽然这样想着，却尽量掩饰自己的怀疑，但是敏感的朱利安还是凭着直觉发现了我的想法。<br> “也许你不知道，我确实了解一些关于孩子的事情。”他温和地说，渐渐从刚才的律师状态恢复了他智者的模样。<br> “不过，说句实话，我还一直以为你没有孩子，是现代城市里人见人爱的钻石王老五，至少在你认输辞职之前，我们一直这样认为。你知道的，有多少女实习生为了进入你的办公室大耍花样？有多少……”<br> “稍等，稍等，”朱利安竖起手掌做了个暂停的手势。<br> “老朋友，你对我的了解从12小时前才开始，对不对？”<br> 我看了看他，朱利安脸上的确没有矫揉造作的羞涩。有一种人，无论男女，一听到自己很受异性的欢迎就故意加以否认，但是脸上得意的神态完全暴露出内心的浅薄。朱利安脸上仍然是一潭秋水般的平静。<br> 他继续说道：“人们都知道我过着一种节奏快、心情飘的生活方式，同事们以为我那样的人生应该很过瘾吧。我也曾经这样认为，直到我明白那只不过是自欺欺人的幻象。<br> ”这时竟然有一丝苦笑出现在他平和的脸上，“你知道我是结过婚的。”<br> “是的。”我清了清喉咙。 然后，朱利安在开口前顿了一下，很像一个孩子正准备向最好的朋友吐露内心中隐藏最深的秘密。<br> “但是，你不知道的是我曾经有一个小女儿。她是我最心爱的宝贝，是我一生中见过的最精致最可爱的小精灵。那个时候，我很像我们第一次见面时候的你，自高自大，野心勃勃，而且满怀着希望。我似乎很幸运，拥有世界上每个人想要得到的一切。所有认识我的人都纷纷夸我前程远大，羡慕我有一个美艳惊人的妻子和可爱极了的女儿。然而，当生活看起来非常完美的时候，幸福马上就又离我远去了。”<br> 这是第一次，从朱利安踏入我的家门以后，忧伤第一次完全吞没了他欢乐的神色。一滴眼泪从他晒黑的脸颊上滑落，落在他天鹅绒般柔软的宝石红长袍上。我张口结舌，不知怎样安慰，因为我已经完全被老朋友的真情流露惊呆了。<br> “你不必继续讲下去，朱利安。”我同情地建议说，把一只胳膊搭在他的肩膀上去，希望能够安慰他。<br> “不，我要说，约翰，请听我说吧。在我过去认识的所有人当中，你是最信守承诺的，也是我最信任的。正如我所说过的那样，你常常让我回想起我自己年轻的时候。说真的，即使是现在，你的身上还有很多东西吸引着我。但是我知道一定要告诉你，用我自己的教训来告诉你，如果你继续按照现行的生活方式去生活，总有一天你明白其实这样是在自找苦吃。我来到这里就是为了向你表明，世上有那么多奇迹等待着你去探索，还有那么多美好的时刻等待着你去品味。<br> “那个夺去我女儿生命的喝醉酒的司机，在太阳都为之哭泣的10月的一个下午，不仅仅夺去了一条珍贵的生命——而是两条。自从我的女儿意外去世后，我的生活也打了死结。我开始在办公室里度过每一分钟清醒的时间，愚蠢地希望我的法律事业能够成为破碎心灵中的痛苦的替代品。有些日子，我甚至就睡在办公室里的长沙发上，因为我害怕回到家去，害怕回到那个还残留着那么多甜蜜回忆的家。我的妻子，从我读法学院的时候就一直陪伴着我的伴侣，后来也离开了。她说我的心里只有工作，这简直是压倒我的最后一根稻草。在痛苦、逃避、更痛苦的恶性循环中，我的健康越发糟糕，名声也变得不可收拾，我眼看自己一天天陷入声名狼藉的生活。那就是我们初次见面时我的生活状态，你眼中的同情向我证明我的回忆是准确的。的确，金钱可以买来的东西我一样也不缺，但那是我出卖了灵魂以后换回来的，我真的这样做了，交出我的灵魂。”朱利安激动地说着，声音仍然是哽咽的。<br> “所以你对我说‘和孩子一起分享童年的时光’，其实是让我每天都抽出时间观察他们的成长和发展变化。是这样，对不对？<br> ”我怎么能够不同情面前这个痛苦的朋友呢。 “当时我们开车送她去参加她最好的朋友的生日聚会。即使到今天，她离开我已经二十七年了，但是只要能够再次听到女儿的咯咯笑声，只要能够再和她一起玩儿捉迷藏的游戏，就像我们俩经常在我家后院里玩的那样，我愿意付出一切代价！”朱利安捂住了脸，大口喘息着。<br> “是的，我明白，我明白。”我不知怎样安慰他。<br> “<strong>我最喜欢把她抱在怀里，温柔地梳理她的金色卷发。她离开以后，把我的心也带走了。尽管我在喜马拉雅山上找到了开启心智和自我掌控的方法，我的人生因为找到了新的意义而重新振作起来，但是在我度过的所有日子中，没有一天不在头脑的静默回忆中看到我可爱的小女儿的粉红小脸。你也有这么好的孩子，约翰。不要为了几棵树木而失去了整片森林。你能够给予孩子们的最好馈赠就是你的爱和关心。像第一天见到他们那样去重新认识他们。一定要让他们明白，他们对于你来说，要比职场事业中过眼云烟般的名利回报重要得多。不久之后他们就会长大，就会一个个离你而去，去建立自己的家庭和生活，去建立自己人生中的失落和幸福。到那时候你再表白你对他们的珍惜就太迟了，时间一去不复返。</strong>”<br> 毫无疑问，朱利安拨动了我心底最深处的那根弦。我猜我在有些时候已经隐隐约约察觉到了，我的工作狂心态正在慢慢地瓦解着我和家庭的联系。这种瓦解就像是余烟缭绕的火苗，静静地燃烧，缓慢地积攒力量，直到有一天向四面八方爆发出毁灭性的能量。我知道孩子们需要我，我也知道内心中我多么眷恋他们，尽管我们谁都没有对彼此说过这样的话。我需要朱利安的提醒。时间飞逝，孩子们长大得太快了。我已经记不起来，我和儿子安迪最后一次在清新的周日早晨，偷偷地跑到他的祖父最喜欢的钓鱼池边度过一天的确切时候了。曾经有一段时间我们一起快乐地度过每个周末。而现在，这个由来已久的习惯简直就像是别人回忆中的故事了。 我越想越感到内心沉重。安迪在学校里的钢琴独奏会，圣诞节的化妆演出，还有他的少年棒球联赛，我一个都没参加，都被我用来换取事业上晋职升迁了。那么安迪的心中会怎么想呢？天哪，他千万不要以为我把工作看的比他更重要啊！<br> “我都做了些什么啊？”我抱着头苦苦思索。我的确已经身不由己地滑到了朱利安所描述的灾难的边缘。好吧，接下来，我决心要改变一切。<br><strong> “幸福犹如一场没有终点的旅程，”朱利安继续说，他的声音已经滤去了刚才的感伤和波动，再一次因为饱含热情而高昂起来，“这也是你给自己创造的一次机会。你可以一直顺着那条铺满钻石的曲折小路向前走，也可以继续草草挥霍所剩的时间，追求彩虹尽头的那一坛黄金，最终却发现这不过是一场空。欣赏每一天中的任何一个不同的时刻吧，因为今天才是你完全拥有的一天。</strong>”<br> “每个人都能学会‘活在当下’吗？”我问道。<br> “当然。无论你目前的境遇怎么样，你都可以训练自己，学会欣赏并且珍惜生命和家庭的馈赠，在每一天的生活中都使自己的存在充满了珍宝般的价值。”<br> “但是这是不是有点太过于乐观了？要是有谁在一场糟糕的商业交易中损失了一切，他该怎么办？我们不仅是说他们的经济破产了，而且指的是他们精神上也完全垮掉了。”<br> “唉，”朱利安轻轻叹息，“<strong>我就是希望人们知道，你在银行户头上有多少存款，或者你住的房子是大是小，根本就和你能不能带着欢乐的情绪和好奇心去生活毫无关系。这个世界上开心的穷光蛋不多，可闷闷不乐的百万富翁到处都是。如果你学会在一天里抽出5分钟来练习感恩的艺术，你就会得到一直在寻找的丰富生活。就连你在举例中说到的那些人也可以发现，生活中其实还有很多东西值得他们去一再感恩，即使他们遭遇到了可怕的经济困境和精神困境。让我们去问问他，是不是还拥有自己的健康，是不是还有可爱的家庭和社交中的好口碑？他难道不以在这个伟大的国家里拥有公民资格而感到幸福吗？他的头顶上难道不是还有一方遮风挡雨的屋顶吗？也许他不再拥有成功时的霸气，不再有事业顺利时的大笔财富，不能重复一掷千金的气概，不能随心所欲地签支票购买所有感兴趣的东西。然而，还有另外一些财富是他应该用一生的时间来感恩的。我们都有很多需要感恩的东西。即使是阳光灿烂的夏天里，一只鸟儿在你的落地长窗前面婉转啼鸣，一个睿智的人也会认出来它们其实是上天赐予的馈赠。记住，约翰，生活并不总是给你想要的东西，却永远会给你需要的东西。</strong>” </p>\n<p>我们都有命里注定要去完成的事情。当你发现更高的目标，投入所有的精力时，你的才能将会迸发出来，幸福会充满你的生活。一旦你认识到你的使命，无论是成为一位成绩突出的教育孩子们的老师，还是做一个灵感丰富创作惊人的艺术家，所有的愿望都会轻而易举地被实现。你甚至都不必先去尝试。不瞒你说，我觉得你越是先去尝试，在目标实现之前所花的准备时间也就越长。相反的是，只要你跟随梦想的道路，所有在期望中想要获得的东西都一定会纷至沓来。它将引领着你走向神圣的终点。这就是我所说的铸就命运的含义。</p>\n<h2 id=\"极乐世界？\"><a href=\"#极乐世界？\" class=\"headerlink\" title=\"极乐世界？\"></a>极乐世界？</h2><p>不幸的是，约翰，你听到彼得的故事，还有那根奇妙的魔法线仅仅是一个故事，一个神话故事。而我们此时正生活在一个绝对现实的世界里，根本没有第二次机会让你重新来过一遍，去实现圆满的人生。今天，唯有今天才是你领受生活馈赠的时机——在还不是太晚之前。约翰，让这新的一天成为你人生中的分界线，你在这一天完完全全下定决心，把所有的精力都集中在对你来说是真正重要的事情上。你要下定决心，在那些可以使你的生活具有更有意义的事情上多花些时间。对生命中特殊的时刻心存敬畏，为它们的蕴含而沉醉。做那些你一直想要做的事情。去爬你一直想要去攀登的高山，或者去学一种乐器，自己做一支曲子，写一首歌词。在大雨天冲出去跳舞，或者另起炉灶从事一门新职业。学会热爱音乐，聆听音乐和鉴赏音乐，学会一门新的外语，重新点燃童年的欢乐时光。不要出于成功的考虑就把幸福向后推延。相反的是，开始学会欣赏过程中的美，重新振作你的精神，认识你的灵魂并且开始爱护它。这就是通向极乐世界的道路。” **</p>\n<p> <strong> “极乐世界？</strong>听起来像佛教里的词语？”我重复着。<br>  “<strong>极乐世界不单单是佛教里的词语。喜马拉雅山上的智者相信，真正开悟了的灵魂要前往的最终目的地是一个名叫极乐世界的地方。事实上，它不仅仅是一个地方，智者相信极乐世界是一种状态，人们可以超越此前他们所知道的一切。在极乐世界中，一切都是可能的。那里没有苦难，生命的舞蹈奔放到了极致，神圣而完美。在抵达极乐世界的途中，智者感到自己正在走向天堂。这就是他们人生中的最终目标。”朱利安总结说，他的脸笼罩在安宁之中，简直就是天使的模样</strong>。<br>  “<strong>我们之所以在这里都是出于某些特定的原因，”他预言般的继续总结着，“静心思考真正召唤你的是什么，想一想你将怎样帮助他人。不要再做惯性和惰性的奴隶，不要再拿贷款作为不快乐的借口。今天，用人生真正的意义点亮你的生命火花，让它明亮地熊熊燃烧起来。开始练习我和你分享的那些道理和方法，去做你能做的一切。当你感到内心里非常渴望尝到极乐世界果实的滋味时，那一时刻就会自然来临。</strong>”朱利安眼睛里的光芒使他看上去像一位神殿里的预言祭祀。 </p>\n<h2 id=\"开悟\"><a href=\"#开悟\" class=\"headerlink\" title=\"开悟\"></a>开悟</h2><p>“会有一些微小的迹象出现，向你显示极乐世界的入口。你开始注意到身边每一件事物当中蕴含的神圣性：比如一束月光的完美，炎热夏季里湛蓝的天空所具有的吸引力，雏菊盛开时的芬芳，或者小孩子淘气的大笑声。<br>  ”我听出他的语气中充满鼓励。 “朱利安，我向你保证，你和我在一起度过的时间不会白白浪费掉。我准备让自己完全按照智者的智慧来用心地生活，而且我将信守承诺，把我从你那里分享来的所有知识，和那些可能会从中受益的人们一起温习。我说这些话是发自内心的。我向你保证。<br>  ”我真诚地说道，感到内心里激情涌动。 “把智者的丰富智慧统统传播给身边所有的人们吧。他们很快就会从中受益，提升他们的生活品质，就像你提升了自己的生活品质一样。而且还要记住，要享受过程本身，沿途和终点一样美好。”<br>  我请朱利安继续说下去。他说：“瑜伽师拉曼是一个非常伟大的讲故事的人，但是有一个故事在他讲给我的所有故事当中显得与众不同。现在我可以讲给你听吗？”<br>  “当然好啊，你知道我一直在聆听你的每一句话。”<br>  “很多年以前，在古老的印度，有一位王侯准备为他的妻子修建一座宏大的建筑，作为他对妻子的深爱和感情的象征。这个王侯想创造出一种世界上从来都不曾见到过的建筑结构，它将在月光照耀下的夜晚里微微放光，让世世代代的人们都因为仰慕而特地赶来朝拜。于是，他的工匠们每天都忍受着酷暑骄阳，一砖一瓦地劳作。每过一天，结构就更加清楚一点，越来越像一座丰碑，也越来越像爱的灯塔，直指蔚蓝色的印度天空。最后，在经过了日复一日的20年的重复劳作之后，这座完全用白色大理石建成的宫殿终于竣工了。你猜一猜我说的是什么？”<br>  “我对印度的文明几乎一无所知。”我老老实实地承认。<br>  “就是泰姬陵。”朱利安回答我说，“我的意思很简单。这个星球上的每个人都是一个奇迹。从某种意义上来说，我们中的每一个人都是天才，都是英雄。我们中的每一个人都有潜力取得超凡的成就，取得巨大的幸福感和永恒的满足感，所需要的只是朝着我们梦想的方向踏实前行。就像泰姬陵的建筑过程一样，在简单重复的劳动中整整耗时20年。<strong>一个充满生命的奇迹就是这样日复一日，一砖一瓦建成的。小的成功会通向大的胜利。微小的、循序渐进的变化将会在一起形成积极的习惯。而后，积极的习惯会带来好的成果。积极的成果则会激励你继续朝着更加伟大的个人目标去努力。开始像对待生命中最后一天那样过好每一天的生活。从今天开始，多多学习，多多大笑，去做你真正喜欢做的事情。不要逃避自己的命运，更不要否定自己的命运。因为和存在于你自身中的那些珍贵的东西相比，那些身前身后的浮云名利根本都是无关紧要的。</strong>” </p>\n<p>如上是内容摘要，如果想更细的了解，可以购买相应的图书。这个内容是需要不段实践才能看到效果。加油吧，共同探索。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这是一部有方法的个人价值实现指南。故事以对话的方式讲述，在审视自我的过程中，重新发现想要的生活。</p>\n<p>刚开始看到这个书名时，感觉是一本精彩的小说，这么少的文字，被翻译成70多种语言，一定很有意义，就试着读了读。读了之后才发现这是一本实践性很强的自我价值实现指导书，里边有非常具体的方法论及使用方法，同时被里边的故事吸引了。</p>\n<p>本书通过瑜伽师拉曼一个寓言，来讲解充满丰富精神内涵的七项品质，这个寓言里，包含了人生的奥妙。下面就开始吧。</p>\n<p>“闭上眼睛，在脑海中浮现出以下画面……”<br>你坐在一个漂亮的、郁郁葱葱的花园当中。花园里满眼都是你所见过的最引人陶醉的鲜花。四周极度寂静，了无声息。品味这花园带给你的快乐，想象自己有大把的时间来欣赏这片自然的绿洲。若你向四周环顾，就会看到，在这个神奇花园的中心伫立着一座高耸的、六层高的红色灯塔。<br>突然，花园里的静默被一阵嘈杂的吱吱嘎嘎声打破，灯塔底部的门被打开了。跌跌撞撞地走出来一个两米七高、四百公斤重的日本相扑选手，他是在不经意间闯进花园中心的。<br>“下面就更有意思了，”朱利安哧哧笑着说，“那个日本相扑选手几乎全身赤裸，只有私处覆盖着多股丝线织成的粉色带子。”<br>然后这个相扑选手开始在花园里走来走去。他找到了一个闪闪发亮的金质秒表，不知是谁很多年以前遗留在那儿的。他不小心踩在秒表上，“砰”的一声巨响，结结实实地摔倒在地上。这个相扑选手变得毫无知觉，无声无息地躺在那里。就在你觉得他就要咽下最后一口气的时候，他慢慢地苏醒过来了，可能是因为受到附近那些黄玫瑰芬芳的刺激。仿佛吸收了新的能量似的，这个选手一跃而起，下意识地往左边望去。他被眼前的一幕惊呆了：<br>透过花园边上的灌木丛，他看到一条蜿蜒曲折的林间小路，路上覆盖着数不清的闪闪发光的钻石。仿佛有一股神奇的力量，他渐渐地被吸引，顺着那条路慢慢地走了过去。就是这条路把他带上了充满无尽快乐和无上幸福的大道上。 </p>\n<p><strong>基于以上故事，引出的七个品质</strong></p>\n<h1 id=\"花园，代表心智\"><a href=\"#花园，代表心智\" class=\"headerlink\" title=\"花园，代表心智\"></a>花园，代表心智</h1><p>心智的控制要通过心理调节才能奏效</p>\n<p>不管你的生活中发生了什么样的变故，你都一直有权利选择自己对待事件的反应态度。当你养成了在每件事情当中都认真寻找积极因素的习惯时，你的人生就会变得鲜活有趣，生活就会升华到最高境界。</p>\n<p><strong>你的外在世界其实就是内心世界的外显。通过控制自己的想法，控制你对人生中每件事情的反应，你就能够开始掌控自己的命运。</strong></p>\n<p>我要郑重地建议你，不要动不动就贸然判断一件事情究竟是积极的，还是消极的。你最好先去经历它们，赞美它们并认真从中学习。生活中的每件事都会教你一些东西。它们是你完善内在世界和外在世界的力量。如果没有它们，你就会停滞不前。想一想它们在你生命中起到的作用吧。大部分人的生活之所以经历了突飞猛进的成长，起因都是因为遭遇到最具有挑战性的人生经历。假如结果让你有些出乎意料，也许会让你感到微微的失望，这个时候你就好好地想想自然的法则吧，因为它总是会确保在一扇门关闭的同时打开另一扇门。所以说，失败中潜藏着成功，挑战与机遇同在。一旦你把这个原则持之以恒地应用到你的日常生活中，以此为标准，努力训练自己的心智，积极地看待每件事情，善于从中汲取力量，那你就会永远忘却那些不必要的烦恼。你将不再是逝去的时光的囚徒，而将成为规划自己未来的设计师。</p>\n<p><strong>除此之外，我还应该做些什么呢？</strong><br>首先，<strong>开始依靠你的想象力而不是记忆力来过日子。</strong><br>我想说的就是，要想释放你心智的、身体的和灵魂的潜能，首先就得学会扩展自己的想象力。你看，事情通常都会发生两次：第一次是在头脑中形成；接下来才会在现实中发生。我把这个过程称之为‘蓝图’，因为你周围发生的任何事情都来源于你脑中的蓝图。要是你学会了控制自己的想法，学会了生动地想象所有你期望的东西，蛰伏在你身体内的意志力就会渐渐苏醒。你就能够释放出心智中真正的潜力，从而创造出一种神奇的生活。从今天晚上开始，你就可以尝试努力忘掉过去的一切，大胆地想象比现实状况好得多的生活，去想象生命中最好的境界。你会为梦想的结果而感到惊讶。 </p>\n<p><strong>获取幸福的奥秘其实很简单：</strong>找到你内心中最喜欢做的事情，然后把自己所有的精力都集中到那个方向，然后付出自己最大的努力。如果你对我们这个世界上最幸福、最健康、最心满意足的人做一个抽样调查，你就会发现，他们中的每个人都寻找到了生命中属于自己的热情，然后用一生的时间去追求它。这种使命感在某种程度上还可以为其他人服务。一旦你把自己的心智能量和生命力全都集中在了你所热爱的追求上，你的生活就会变得丰富多彩，目标的实现也会变得轻松而愉快，就像你在车库边哼着小曲边贴壁纸一样，充满了闲适的乐趣。</p>\n<p>湿婆神的智者每天都要花时间静思默想，不仅思考自己身在何处，还要思考自己将去何方。他们每天都在思考，最重要的是，他们尤其重视如何通过思考指导自己不断进步，哪怕这种进步看起来是如此的微不足道。因为他们知道，只要每一天都获得一些微小的进步，那么日积月累就会产生持久而有效的成果，反过来就会引起精神世界的巨大改观。</p>\n<h2 id=\"玫瑰之心\"><a href=\"#玫瑰之心\" class=\"headerlink\" title=\"玫瑰之心\"></a>玫瑰之心</h2><p>“有一种控制心智的方法要远远地胜过其他方法。这是瑜伽师拉曼钟爱的方法，也是在他教给我的所有方法中最好的一个。在接受了这项指导以后，我仅仅练习了21天，就感到精力旺盛，比我在青壮年时期都更加热情饱满、活力四射。这个练习法已经有四千多年的历史了，它的名字叫作‘玫瑰之心’。”<br>“‘玫瑰之心’？很文雅的名字嘛。能不能给我讲得再具体些呢？”<br>“<strong>你用这个方法进行练习时，只需要准备一朵鲜艳的玫瑰和一处安静的地方。自然的环境当然最好，不过在一个安静的房间里也可以做得很好。一开始，你要集中注意力凝视玫瑰的花心，这就是它的心脏。瑜伽师拉曼告诉过我，所谓一花一世界，一朵玫瑰花如同一个生命：在路上你会遇到尖刺，但是如果你有信心，坚信自己的梦想会实现，最终就会越过那些尖刺，进入灿烂的鲜花世界。你要学会目不转睛地凝视着这朵玫瑰，感觉它的颜色、质地和模样，深深地呼吸它的芬芳，头脑中浮想着那些无限美好的事物。在这个过程中，别的念头会悄悄溜进来，慢慢侵入你的心智，分散你的注意。这是没有经受过特别训练的心智的特征。不过你不必为此担心，这种状况将很快就得到改善。你只需要把注意力再次返回到花心点上来。很快，你的心智就会因为经受了成千上百次的训练而变得强大有力。</strong>”<br>“要做的只有这么多吗？听起来确实再简单不过了。”<br>“这就是这个方法的优点，约翰，”朱利安回答说，“不过，<strong>这个方法必须每天坚持做才会起效。在开始的几天里，你会感到这种练习看上去容易，做起来却有很大的难度，也许你连5分钟都坚持不到。这也说明我们大部分人的生活节奏太快，都好像得了躁狂症一般，真正的安宁和沉默仿佛是宇宙之外的东西，让人感到很不舒服。</strong>  很多人听到‘玫瑰之心’的建议之后都会说他们没有时间坐下来盯着一朵花傻乎乎地看上半天。有趣的是，也是这帮人还会向我诉苦说，他们没有时间享受孩子的笑声，也没有时间光着脚在雨中漫步。这些人们总是抱怨说他们太忙了，没有时间过那种闲适的生活。他们甚至没有时间去结交新朋友，因为建立友谊也是要占用大量时间和精力的。” </p>\n<p>“<strong>要学习持之以恒的信念，花越来越长的时间去感知花心</strong>，”朱利安继续用他低沉的声音说，“<strong>也许在一两个星期以后，你就差不多可以在这个练习中坚持到20分钟，而不让自己的思想分散到其他的事情上去。这将是你修心养性并有所获得的第一个标志，你夺回了心智的控制权。你命令它关注哪个事物，它就会把注意力集中到哪个事物上去。那时，心智就成了最好的仆人，可以为你完成许多不可思议的事情。记住，不是你控制心智，就是它反过来控制你。</strong>” </p>\n<h2 id=\"静思默想\"><a href=\"#静思默想\" class=\"headerlink\" title=\"静思默想\"></a>静思默想</h2><p>湿婆神的智者每天都要花时间静思默想，不仅思考自己身在何处，还要思考自己将去何方。他们每天都在思考，最重要的是，他们尤其重视如何通过思考指导自己不断进步，哪怕这种进步看起来是如此的微不足道。因为他们知道，只要每一天都获得一些微小的进步，那么日积月累就会产生持久而有效的成果，反过来就会引起精神世界的巨大改观。</p>\n<p>最少每天抽出10分钟也是可以的。</p>\n<h2 id=\"对立思维法\"><a href=\"#对立思维法\" class=\"headerlink\" title=\"对立思维法\"></a>对立思维法</h2><p>在消除内心烦恼和其他负面情绪方面，还有一项特别有效的技巧。这项技巧建立在瑜伽师拉曼称之为‘对立思维法’的基础之上。<strong>在伟大的自然法则下，大脑在同一时间只能拥有一个想法。</strong><br>因此，任何人都可以在短暂的时间内很轻松地创造出一种积极、有新意的思维。过程简单而直接：如果有一个令人不快的想法在头脑中占据了主要的位置，就马上试着用一个鼓舞人心的想法去替代它。你的头脑就好比一个非常巨大的幻灯放映机，出现在头脑中的每一个念头都仿佛一张幻灯片。每当银幕上出现了令人不悦的画面，就用最快的速度拿起一张内容积极的幻灯片去替换掉它。</p>\n<h2 id=\"湖水的秘密\"><a href=\"#湖水的秘密\" class=\"headerlink\" title=\"湖水的秘密\"></a>湖水的秘密</h2><p>每件事情都会发生两次，第一次发生在头脑中，第二次是在现实中得到印证。我已经意识到思想也是现实，是物质性的信息，当我们把思想散播出来，其实也就改变了现实的世界。我也曾经对你说过，如果你希望在外部世界中获得显著的改善，首先就得从内在精神世界的改善开始，要学会改变你自身的思想与品格。<br>“喜马拉雅山上的智者有一个很好的办法来确保他们思想的纯净，而且有益于身心的发展。这个方法在把人的内在愿望转化为现实力量方面也显得极为高效，尽管它很简单。而且这个方法对任何人都有效。无论是汲汲于扩充人生财富的年轻律师，还是希望丰富家庭生活的妈妈，或者是希望完成更多销售量的推销员，都可以从这个方法中受益。智者给它命名为‘湖水的秘密’。在训练这个方法时，智者早晨四点钟就起床洗漱了，因为他们认为清晨时光之中包含着神秘的要素，他们可以从中感受到宇宙的脉动。这些智者沿着陡峭而狭窄的山路缓缓行走，这些道路最终把他们引向河流的下游。他们到那儿以后，就顺着一条几乎看不出来的小径继续走，两边是伟岸的青松和异样繁茂的鲜花。他们就这样一直走到一片开阔的空旷地。空地边上是一汪青绿色的湖水，这时水鸟还在沉睡，四周一片寂静。那种安静平和的情景仿若仙境。智者告诉我说，这个湖在很早很早以前就已经是他们祖先的朋友了。”<br>“<strong>‘湖水的秘密’是什么？</strong>”我不耐烦地打断了他的话。<br>朱利安不急不躁地解释说，<strong>智者会观察平静的湖水，想象他们的梦想化为现实。湖水如同一面命运的镜子，所有的欲望都能够完整地投射于其上。如果他们希望在生活中养成训练有素的良好习惯，他们会想象出自己在凌晨起床的样子，一丝不苟地完成他们严格的身体养生锻炼，时间在静默无声地提高个人意志力量的过程中悄悄流逝。如果他们想要寻找更多的快乐，就会满怀喜悦地注视着湖面，想象自己毫无节制地大笑的模样，或者回想自己遇到兄弟姊妹时在脸上浮现出的发自内心的微笑。如果他们寻求勇气，就会想象自己在面对危机和挑战的时刻是如何非常有力地行动着。而湖水就像一位仁厚的智者给他们以巨大的支持。中国人所说的“仁者乐山，智者乐水”，也许就是这个意思。</strong><br>“还有一次瑜伽师拉曼悄悄对我说，当他还是个孩子的时候其实也非常缺乏自信心，因为他比同龄男孩的个头要小得多。虽然他们的教养都很好，依然能够态度温和地对待他，可在自卑感的暗示下，他还是变成了一个害羞的、没有安全感的人。为了弥补这个欠缺，拉曼独自来到那个天堂似的所在，把湖面当作内心映像的屏幕，尽力想象他所希望成为的那种人的形象。有些天里他看到自己成为了强有力的领导者，坐在高高的殿堂上，声音宏亮而果断地发号施令。而另外一些时候，他会看到自己老年的形象：一个博学的智者，具有无限的内在潜力和坚韧的性格。所有他希望在自己的生命中能够拥有的美德，他全部都在湖面上先看到了。<br>“通过几个月时间的静观，瑜伽师拉曼真的成为了他在意念中看到自己想要成为的那种人。你看，约翰，心智就这样通过头脑的想象产生了巨大的效果。<strong>内心的图像可以影响到你的自我想象，而你的自我想象又会影响你在感觉、行动和进取方面的方式。</strong>如果你的自我想象告诉你，你太年轻，成为不了一名成功的律师，或者你年纪太大，改不掉那些坏习惯，那么你就永远不能实现这些目标。如果你的自我想象告诉你说，要过一种丰富的、有目标的生活，要有良好的健康状态和幸福感，这些不仅是为了你自己，也是为了身边人们的幸福，那么这类预言最终会成为你的现实。<br>“而且，当你在头脑的屏幕上播放这些令人欢欣鼓舞的图像时，良好的变化就会开始显现在你的生命里。爱因斯坦曾说过，想象力比知识更加重要。<strong>每天你都得抽出一些时间来进行冥想，即使只有短短的几分钟，也要有意练习创造性的想象。</strong>在这一刻，尽可以把自己视作自己希望成为的那种人，不管这个形象是一位大法官，还是一个好父亲，或者是社区里的一个好居民。”<br> “我知道，这一定是一个非常古老但是也非常有效的办法。我的孩子在看《哈里・波特》，里面有一面魔镜，波特照镜子的时候看到了他父母的模样，而他的好朋友红头发的荣恩照镜子时看到的却是自己成为了全校国际象棋冠军的时刻。镜子折射出的形象往往是自己最渴望见到的模样，畅销书就是这样感动我们的，不是吗？”我毫无顾忌地说出自己的想法。“还有啊，我一定要找到一汪特殊的湖水才能练习‘湖水的秘密’这个方法吗？我一定要每天一大早跑到郊外去苦思冥想吗？”我忍不住继续问，“你知道，这对生活在都市中的人来说简直是天方夜谭啊。”<br> “你不必这么循规蹈矩。<strong>‘湖水的奥秘’只是智者对这个古老技巧给出的一个称呼而已，其目的是要用积极的想象来影响心智，并不是让你拘泥于其中。你可以根据自身情况灵活机动地作出调整，比如在自己的客厅里，甚至就在办公室里来练习这个方法。只要你真的想这么做，那么随时随地都可以。</strong>你可以试一试，先关紧房门，关掉手机，闭上眼睛，然后慢慢地做几次深呼吸。两三分钟之后你就会注意到，你真的开始感到周身放松。接下来，在头脑里想象出所有你希望的东西，想要拥有的，或者想要达到的。如果你想成为世界上最好的父亲，就想着自己正在开怀大笑，你的孩子们正围着你快乐地玩耍，而你呢，则不厌其烦地解答他们各种各样匪夷所思的问题。你还可以想象自己举止优雅、充满爱心的样子。通过这种方法，先在头脑中演练自己的形象，等到相仿的场景在现实的情境中真的出现时，你就可以完全施展自己的潜能了。<br> “想象自己形象的方法可以适用于很多种情况。你可以利用它来使自己在法庭辩论中更富有逻辑，你可以利用它来改善自己的人际关系，当然你也可以借此发掘自己的精神潜能。持之以恒地使用这种方法还会带给你社会声望的回报，以及丰厚的物质收获，如果你觉得这些东西对你很重要。<strong>如果你觉得生活中缺少了什么，那是因为你的头脑中并没有这种东西。记住，要在头脑中留住美好的画面。一旦你开始练习这种方法，它就会让你彻底领会到心智所具有的神奇威力，开启大脑的潜力，它实现你生命中一切渴望的东西。</strong>”<br> “瑜伽师拉曼和与他居住在一起的<strong>智者都经常提到一句老话，这句话世代相传，流传至今。我很幸运在这个对我们两个来说都很重要的夜晚将这句话转告给你。话是这么说的：“凌驾于他人之上毫无尊贵可言；真正的尊贵是超越以往的自我。’如果你想达到我真正达到的那个境界，与你认为有意义的东西并驾齐驱的话，你就必须首先和自己赛跑，向自己发起挑战。何必在意别人怎么议论你呢？最关键的是你自己的想法。只要你能够确定自己的所作所为是正确的，就不要总是去在意他人的眼光，那样会让你变得畏首畏尾。你要告诉自己，你可以做任何你想做的事情，只要你的良知和内心都认为它是对的。千万不要为自己做了正确的事情而感到害羞。根据你所认为的好坏标准来作决定，然后毫不犹豫地坚持这种看法与做法。一定记住，千万不要堕入那种器量狭隘的计较之中，把自己的自尊和别人的非议评判作比较。就像瑜伽师拉曼倡导的那样，‘你在思考他人的梦想时耗费掉的每一分钟，都会将你到达自己梦想的时刻向后推迟一分钟。’</strong>”<br>现在已经是半夜十二点零七分了。和平常不一样的是，我丝毫也没有感觉到疲惫。当我把这种感觉告诉朱利安时，他又一次露出恬静的微笑：“你已经学会了另一种开启生命的方法。就大部分人来说，疲惫是心智匮乏的产物。没有梦想、没有方向感的人所过的生活常常是碌碌无为、疲惫不堪的。让我给你举一个例子。你有没有这样的体验，比如整整一个下午待在办公室里，强迫自己阅读那些干巴巴的案情报告。很快，你的心智就开始溜号，然后你也逐渐地睡意蒙眬起来？”<br>“有时候的确是这个样子的。”我回答说，其实内心并不愿承认，但事实上这恰恰正是我目前的工作常态。“当然，我们大多数人都会在遵循惯例、按部就班的工作中感到昏昏欲睡。”<br>“可是，如果有一个朋友打电话来，问你想不想晚上出来一起看场棒球比赛，或者请你为他的周末高尔夫球比赛出谋划策，我敢说你一下子就精神起来了，任何疲惫的痕迹都一股脑儿地飞到爪哇国去了。我说得对吧？”<br>“我承认确实如此，尊敬的顾问先生。”面对朱利安我只好讲实话，当然也故意用一种油腔滑调的语气来掩盖自己被人窥破心思时的不安。<br>朱利安从我的语气中知道他抓住了问题的关键，于是他更来劲了。“所以，你的疲惫不是别的，无非是匮乏的心智的产物。你的心智养成了坏习惯，当你从事一项单调而冗长的工作时，心智就成了挡路石。很明显，今天晚上你被我讲的故事吸引住了，开始对我希望与你分享的智慧感兴趣。<strong>记住，你的兴趣爱好和心智注意力都会给你的日常生活带来源源不断的活力。在这个晚上，你的心智既不再关注过去，也不再关注未来，它就聚焦在当下，聚焦在我们的话题上。如果你经常把心智引向当前的生活，你就一定会得到无尽的活力，不管钟表上指示的时间是深夜十点钟还是十二点钟。</strong>” </p>\n<h1 id=\"灯塔，代表目标\"><a href=\"#灯塔，代表目标\" class=\"headerlink\" title=\"灯塔，代表目标\"></a>灯塔，代表目标</h1><p>在花园的中央伫立着一座明亮的灯塔。这个象征提醒你记起另一条启示生命奥义的古老原则：<strong>生命的目的就是有目的地生活。</strong>那些真正开悟了的人们知道他们将要从生活中得到什么，比如情感的、物质的、身体的，或者是精神的。他们把先后的顺序排列得清清楚楚，经过严密的统筹安排之后，生活中每个方面的目标都会发挥出类似于灯塔那样的作用，在海面上风起浪涌的时候会给你指引航向，为你提供安全的避难所。你看，约翰，只要彻底地改变了人生的进取方向，任何人都可以将自己的生活来个焕然一新的改变。但是如果你根本不知道你从哪儿来，又要到哪里去，那你又怎么可能知道自己什么时候会到达那个不知所终的地方呢？</p>\n<p>“生命真是太奇妙了，”瑜伽师拉曼大发感慨，“人们可能会认为一个人工作得越少，就越有机会体验到闲适的幸福。然而并非如此，或者说这是片面地理解了幸福的含义。<strong>一言以蔽之，幸福的真正源泉就是一个词：成就。</strong>永恒的幸福来自于为了完成目标而进行的脚踏实地的工作，来自于在接近人生目标的过程中持之以恒的努力。只要点燃潜藏在内心中的火焰，它就会创造出一个令你我无法想象的新世界。我知道这听起来多多少少有点讽刺，因为我不辞辛苦离开自己以事业成就为本位的社会，艰难跋涉了几千里路，向居住在喜马拉雅山高峰上的神秘智者请教，希望得到关于幸福的永恒奥秘，却听说孜孜以求的幸福奥秘在于成就，可事实的确如此。</p>\n<p>成就并不一定需要用物质来衡量。就我个人而言，我的目标就在于获得内心安宁，学会控制自我，学会了悟人生。如果直到生命的尽头，我还是不能达到以上这些目标，我相信我会死不瞑目，因为我没有抵达自己的圆满状态。</p>\n<p>我的意思其实很简单。当你已经明确知道在你的一生当中最希望达到的目标是什么，不管这些目标是物质的、情感的、身体的还是精神的，你都要为抵达这一目标而倾注大量的时间与精力，只有这样才能最终体验到永恒的欢悦。你的生命将和我的生命一样充满快乐，而且你将逐渐看到自己的梦想一步步演变成为光灿灿的现实。但是这一切的前提在于，你必须首先了解自己，制订出明确的人生目标，然后通过持续不懈的努力把它转化为现实。我们称其为“达摩”，这是一句梵语，意思是‘生命的目标’。</p>\n<p><strong>很多人在发现了自己存在的真正目标之后马上放弃了限制自己人性发展的工作，即便这项工作为他们赢得了巨大成功和丰厚的物质回报。</strong>这的确像是一场冒险，伴随着对自我的研究和灵魂的探索，你要学会不断地丢弃一些身外之物。可是也不能完全将它说成是一项冒险，因为在发现自我和人生的使命方面原本没有什么风险可言——在智者看来，发现自我这项工作本身就是人生体验中相当重要的一个环节。自我认知是开启人生的DNA生命链，它的确是生命中最关键的东西。</p>\n<p>我的达摩相当简单：无私地帮助他人，丝毫不考虑任何回报。记住，你不能在呼呼大睡中发现人生真正的快乐。同样，在游乐场或者像个游手好闲的人那样恣意消磨时光，也不可能抵达人生的真知。正如本杰明・迪斯雷利[3] 说的那样：<strong>“成功的秘密在于不屈不挠地坚持自己的目标。’你所寻求的幸福是从有价值的目标中得来的，你付出所有的精力去争取成功，每天、每小时都努力地去接近这个目标。这是永恒哲理在现实生活中的应用，它规定了哪些事情是最重要的，永远不能被另外一些不重要的事情掩盖掉。在瑜伽师拉曼的寓言里出现的灯塔会一直提醒你，制订明确而有意义的目标有多重要，以及实现这些目标需要怎样的力量。</strong></p>\n<p>确立目标是最基本的出发点。制订出你的方向和目标，就可以把创造力的潜能加以放大释放，最终促使你踏上通向目标实现的道路。信不信由你，瑜伽师拉曼和其他智者都热衷于不断设定目标*。</p>\n<p>把我所有的智慧都和你分享。今天的这个例子就是为了进一步说明在人生中设立一个明确目标，以及清楚地知道你将往哪里去的重要性。你刚才见到的那一幕就说明了这个最为重要的原则：<strong>你一定不可能命中你根本看不见的目标。人们用去整整一生的时间来希望自己变得更加幸福，活得更有活力，拥有更加丰沛的激情，然而他们没有发现这个重要原则。你要学会，每个月抽出10分钟的时间，把自己的目标写出来，仔细地想一想生活的意义何在、人生根本目的何在。设立一个明确的目标可以让你的人生过得与众不同。你会变得更加丰富，更加愉快，拥有更加不可思议的精力。</strong></p>\n<p>任何一个希望同时提高自己的内心品质和外在条件的人都要学会定期拿出一张白纸，认真地在上面写下自己的人生目标。</p>\n<h2 id=\"一页纸在上面写出自己的目标\"><a href=\"#一页纸在上面写出自己的目标\" class=\"headerlink\" title=\"一页纸在上面写出自己的目标\"></a>一页纸在上面写出自己的目标</h2><p>此前我已经告诉过你，我们的头脑中平均每天会出现60,000个想法，然而这些想法太多了，多得你自己都容易迷失在欲望的丛林中。这个时候，在一张纸上写出你的愿望和目标就显得尤为关键。这一举动意味着你给潜意识的幽昧丛林中插上了一杆红旗，让这个想法比其余的59,999个想法突出得多。你的心智因此就像雷达一样，开始寻找一切机会去实现你的愿望。这个过程的确非常有效，可惜我们当中的绝大部分人对此视而不见。</p>\n<p>愿望成真，一共需要有五个步骤<br>第一步是要对自己预期的结果有清楚而具体的认识。第二步是制造一种积极的压力来鼓舞自己。相对来说，第三步是非常简单的，那就是绝对不要好高骛远，设立一些不合时宜的目标。当你决心将人生和某一个目标相连，就意味着你必须给它设定一个明确的最终实现期限。这就如同你在为庭审准备大量的卷宗，你的注意力会一直集中在法官身上，因为他将决定庭审的日程安排。相反，其他人的话对你似乎没有任何影响。<br>让我们回到达到目的、实现目标的五步法上面吧。一旦你对未来的结果有了一个非常清晰的成形设想，也为此创造出了一点积极的压力，并划定了最后实现的期限，甚至当众许下了完成它的诺言，那么接下来要做的一个步骤就是瑜伽师拉曼称之为‘神奇的21天法则’的方法了。<br>最后我所说的就是，在你实现自己目标的过程中，一定要确保自己随时处在兴致盎然的状态。永远也不要忘记纵情狂欢的重要性，永远也不要忽视在所有的生命中都能看到精致的美丽。今天，以及你我一起分享智慧的这一刻都是上天的恩赐。保持你昂扬的精神、愉快的心情和好奇心。随时都要密切关注自己的毕生事业，随时都准备好要给予别人无私的帮助。宇宙对万物都一视同仁，这也是大自然的真理法则之一</p>\n<h2 id=\"热情\"><a href=\"#热情\" class=\"headerlink\" title=\"热情\"></a>热情</h2><p>热情。这个词汇你一定要始终牢记在头脑里面。热情是实现梦想最根本的动力源泉。在我们这个碌碌无为的社会中，生命的热情早已经消失了。有的时候我们之所以什么也不愿意做，那是因为我们喜欢这样一直待着。而当我们开始动手做事情的时候，则是因为我们感到不得不做，只好没精打采地应付差事。这就是制造痛苦恶性循环的公式。不过我现在说的并不是那种浪漫的热情，尽管那也是促进成功、振奋人生的要素之一。我现在所说的是对生活的热情。每天早晨醒来时就要不停地对自己加油鼓劲，让自己浑身活力充沛，快乐无拘。热情是你工作中的加油站，热情的火焰越烧越旺，那么通向自信与成功的道路就越光明。你很快就会有丰厚的物质收获，同样还会获得精神上的巨大回报。</p>\n<h2 id=\"禅悟\"><a href=\"#禅悟\" class=\"headerlink\" title=\"禅悟\"></a>禅悟</h2><p>意思是指不间断的、永不尽头的提升。</p>\n<p>怎么用来丰富智者的生活呢？<br><strong>外在的成功首先开始于内在的成功。如果你确实想要改善自己的外在世界，不管这种外在世界指的是你的健康，你的人际关系，还是你的财产状况，你都必须先努力提升自己的内心世界。最有效的途径就是持续不断地进行改善自我的实践与练习。掌握自我就是掌握人生的DNA密码。</strong></p>\n<p>中国古老的智者曾经说过：“道在屎溺中。’意思就是说宏大的人生哲理其实恰恰隐藏在看似平淡的日常生活细节之中。</p>\n<p>在我们这个社会里，我们都太轻易地把无知看作是缺陷。然而，那些表现出自己缺乏知识，希望找到指引的人其实并不需要感到害羞，因为他们比其他人更早地意识到自己的问题，也就能够去更早地发现通向开悟的道路。你提出这个问题证明你非常诚实，让我看出来你的确愿意接受新理念。要知道在我们目前的这个社会里，改变是最强大的动力。大部分平庸的人害怕改变，而智慧的人则拥抱它的威力。禅悟代表的东方修行传统着重讲的是起步者的心智：那些敞开自己的头脑，随时准备接受新观念的人——也就是那些总是让自己的杯子空空如也的人——总是会在成就和满足感的方面达到更高的水平。千万不要羞于提出哪怕是最基本的问题。提问是获得正确知识的最有效的途径。</p>\n<p>当我说到提升你的内心世界时，我只是简单地描绘了一下自我改善和个体发展的功效，并告诉你这是你能够为自己做的最有价值的事。或许你会觉得太忙了，没有时间花在自己身上，当然也无须奢谈什么改变。如果你这么想，那就大错而特错了。你要知道，当你把自己培养成一个纪律严明、活力充沛，充满乐观情绪的人时，你就可以在外部世界中拥有所有的东西，做所有你想做的事情。当你对自己的能力和不屈不挠的精神产生了深刻的自信，那么任何东西要想成为阻挡你胜利的拦路石，那真的就是螳臂当车了。在控制自我心智上多花些时间，时刻关注自己的身体，丰富自己的灵魂，都会使你的生活会变得更加丰富，更有生命力。许多年以前，斯多葛学派的爱比克泰德就曾经说过：“一个不能控制自己的人就不是自由人。</p>\n<p><strong>禅的本意是静虑、冥想，悟与迷对称，指觉醒、觉悟。悟是意义的转化、精神的转化、生命的转化，含有解脱的意义。禅是修持方式，悟则是修持结果，两者是有区别的。但是东方的禅宗学人却把禅由坐禅静思变为日常行事，由心理平衡变为生命体验，这就从根本上改变了禅的内涵。东方的禅宗学人还认为觉悟要由日常行事来体现，由生命体验来提升。禅与悟是不可分的，悟必须通过禅来获得，禅没有悟也就不成其为禅。没有禅就没有悟，没有悟也就没有禅。</strong></p>\n<p>接下来我开始思考究竟能够从哪些方面来提高自己的修养。让我一项一项地来看看吧。第一，定期的锻炼可以给我带来活力，这样我才能够保持健康良好的体格与心态。第二，控制我的坏脾气，不要随便打断别人的谈话。如果能够改正这些毛病，可能会在人际关系方面给我和妻子、孩子以及同事的相处带来意想不到的好处。第三，改掉忧虑的坏习惯。这可以带给我心智上的安宁和平静的幸福感。第四……我越想越兴奋，因为我发现在我身上能够进行改善的地方实在太多了，可这些我以前却从来没有注意过。 </p>\n<h2 id=\"建立人格力量、培养心智和充满勇气地去生活\"><a href=\"#建立人格力量、培养心智和充满勇气地去生活\" class=\"headerlink\" title=\"建立人格力量、培养心智和充满勇气地去生活\"></a>建立人格力量、培养心智和充满勇气地去生活</h2><p>他耐心地谈到建立人格力量、培养心智和充满勇气地去生活具有多么重要的地位。他告诉我说：“这三种品质不仅可以让人拥有高尚的生活，而且可以使他的生活中充满成就感、满足感和内心的安宁。勇气这个宝贵的品质是每个人都可以培养得到的，它在经久不息的跋涉中带给你巨大的回报。<strong>”<br>  “</strong>勇气和自我领导、自我发展又有什么关系呢？<strong>”我大声问他。<br>  “</strong>勇气使你敢于正视自己，与自己的惰性赛跑。勇气使你敢于去做所有你认为是对的事情。勇气使你能够控制自我，在其他人失败的地方仍旧支撑你继续坚持下去。最终，你拥有勇气的多寡程度决定了你可以获得的成就的总量，这是一个有趣的正比例关系。它能够使你确切地从自己的生活中看到所有不同寻常的奇迹。另外，我还想告诉你，能够掌控自我的人都是拥有非凡勇气的人。</p>\n<h2 id=\"心智、身体和灵魂\"><a href=\"#心智、身体和灵魂\" class=\"headerlink\" title=\"心智、身体和灵魂\"></a>心智、身体和灵魂</h2><p>在我的新生活里也就更加信奉禅悟的哲学，让心智、身体和灵魂都持续地、永不休止地获得自然的点化，在丰富心性的过程中不断提高。朱利安这样说。<br>为什么这些天以来我听到这么多次‘心智’‘身体’和‘灵魂’之类的词语？你要是不稍微解释一下，我还真拐不过弯来。<br>  “**这三个词语是你作为人的天赋中非常重要的三部分。简单地说，它们三者之间是相辅相成的关系。比如不锻炼身体，仅仅注重于提高心智，就只会得到非常空洞的胜利。如果你把心智和身体能力都提升到了最高水平，却没有认真地丰富自己的灵魂，会使自己感到异常地空虚，无法获得满足感。但是一旦你用出所有的力量来释放本性中这三个部分所有潜能的话，你就会在人生突然开悟的那一刻享受到神圣的狂喜。</p>\n<h2 id=\"人们在艰难地进入未知区域的时候会变得最为强大\"><a href=\"#人们在艰难地进入未知区域的时候会变得最为强大\" class=\"headerlink\" title=\"人们在艰难地进入未知区域的时候会变得最为强大\"></a>人们在艰难地进入未知区域的时候会变得最为强大</h2><p>首先我必须和你一起分享一个实际的例子。请你摆出俯卧撑的姿势来。当然，依你现在的身材，你还能趴下吗？”朱利安不失时机地揶揄了我一下。<br>  “天哪，朱利安变成军事训练官了。”我暗自想着。出于好奇，也是为了像朱利安所说的“保持我的杯子空空如也”，我只有老老实实地照办。<br>  “现在，使出全身的力量做俯卧撑，不要停下来，直到你确定自己彻底没劲为止。让我们数一数你到底还能够做几个。”朱利安在一旁笑着说。我的天，他只差手里再握一只秒表了。 我挣扎着做起了俯卧撑。多少年了，我那肥胖的身躯从来都没有进行过这么多的运动，除了有那么屈指可数的几次，我和孩子们一起走到最近的一家麦当劳快餐店，或者和我的法律界同行们一边漫步一边打一轮高尔夫球。最初的15个俯卧撑完全像是垂死挣扎。我开始暗自抱怨这个闷热的夏季，黎明之前的气温依然使得我大汗淋漓。然而，我已经下定决心，坚决不要显出任何虚弱的迹象，坚持下去，直到我的虚荣心和手臂一起无法坚持的时候再停下。<br>  不过我的虚荣心显然没有那么坚强。在做到第23个的时候我放弃了努力，结结实实地趴在地上。<br>  “不行了，朱利安。”我一边喘气一边忍不住抱怨起来，“这简直是要杀了我。你这是打算干什么？”<br>  “你确定自己一个也做不起来了吗？”朱利安的表情十分严肃，丝毫没有开玩笑的意思。<br>  “我确定。算啦，让我喘口气吧。我唯一的感觉就是，我再动一动就会造成一次心脏病突然发作。那时你一定记着打急救电话啊。”<br>  “再做10个。然后你就可以休息了。”朱利安命令道，他的口气似乎没有商量的余地。<br>  “你说话不算数！”我愤愤不平地抗议道。然而为了能够获得朱利安的教导，我只好咬着牙坚持继续做下去。1个……2个……5个……8个……最后总算做了10个。我连翻身的力气都没有了，直接趴在地板上，觉得天都快要塌下来了。这时，耳边响起朱利安清晰的声音：<br>  “瑜伽师拉曼和我在一起分享他的特别寓言的那个晚上，我也像你这样经受了训练。不过，唯一的区别在于我做的俯卧撑是你的好几倍。”朱利安说。“当我体力不支趴在冰冷的地板上的时候，拉曼镇静地对我说，痛苦是最伟大的老师。”<br>  “痛苦是最伟大的老师？从这样枯燥的身体练习中究竟能够学到什么呢？”我气喘吁吁地问他，丝毫也不掩饰我的抱怨之情。<br>  “瑜伽师拉曼，还有所有居住在喜马拉雅山上的智者在这个问题上都保持了完全一致的看法。他们认为，<strong>人们在艰难地进入未知区域的时候会变得最为强大。</strong>”<br>  “好吧。我相信你的话是有道理的。但是这和俯卧撑有什么关系呢？又有什么理由让我非得做这么多俯卧撑不可呢？”<br>  “当你做了23个俯卧撑之后，你告诉我力气用完了，一个也做不起来了。我相信你对我说的话，在你的意识表层中，那真的是你的极限。然而，当我一定要求你再多做几个，你听从了我的话以后就又多做了10个俯卧撑。这说明了什么呢？”<br>  朱利安不等我回答，紧接着给出了答案：“<strong>这说明潜伏在你身体里的力量还有很多，只不过平时它们都在沉睡状态，缺乏足够的刺激将它们一一激活。一旦这些力量醒来，一旦你发现了自身力量源泉的时候，你就会发现自己其实比预想的要强大得多。其实类似的事情在生活中也是屡见不鲜的。比如报纸上会登载一条新闻说，某人因矿难而被深埋在地下半月之久，却能够依靠强大的求生意志而存活下来。或者说一个人从高空坠落，因为掌握好了身体的平衡感而幸免于死。相信你一定读到过这些新闻，不过你通常是把它们当作茶余饭后的街头怪谈，却没有冷静下来仔细想想其中的一些奥妙。这是关于生命的奥妙</strong>。<br>  “<strong>当我还是瑜伽师拉曼的学生时，他向我解释了这个基本原理：“生命中唯一的极限是你自己给自己设下的。’当你勇于从惰性的圈子中跳出来，打破陈规，向未知领域探索，你就开始释放本性中的潜能了。这是走向自我控制的第一步。当你把自己的极限推得更远，就像你在这次小小的示例中做的这样，你就会不断地开发出心智和体力的潜能，那是你从来不曾想、也不敢想的东西。而事实上，你原本有足够的能力去获得它。</strong>” </p>\n<p>“太棒了。”我心想。突然，我记起了在最近看过的一本书里说，普通人的个人才能只有很微小的部分得到了利用，如果每个人都把自己沉睡的才能唤醒，那每个人都将是天才。“我很想知道，如果我们学会运用能力中其余那些沉睡的部分，我们又能做出什么呢？”<br>这个问题让朱利安有些为难。他挠了挠头，想了一下，然后回答道：“你刚才实践了‘禅悟’的技巧，相信我，这种技巧每天都可以使你进步。也许以下这些方面是你近期要努力的事情。<br>“<strong>努力提高自己的心智，改善身体的健康状况，让自己能够随时做到聚精会神。做那些让你感到恐惧的事情，这样就可以消除心魔，开始拥有无限的精力和无边的热忱</strong>。<br>“<strong>你还要学会融入大自然，认真观察日出时的动人情景，也可以试着在雨中自由舞蹈。</strong><br>“<strong>你要坚守自己的目标，每天都朝这个方向行进，这样才能真正成为你梦想成为的那种人。 </strong></p>\n<p>“<strong>不要害怕出错，要鼓足勇气做你一直想做的事情，而不是自欺欺人地找借口拖延，嫌自己太年轻或者太年老，太贫穷或者太富裕。</strong><br>“<strong>准备好过一种目标远大，精神活跃的生活。在东方，人们常常会说，机会总是留给有准备的人。而我则深信，生活也偏爱有准备的人。</strong>”<br>**朱利安继续他热情洋溢的谈话，好像是一所大学课堂上的哲学老师。“认真分析生活中那些阻碍你的因素，然后想方设法去克服它。从多方面好好反省自己，比如你是不是害怕演讲，或者在人际关系上有麻烦？你是不是缺乏积极的人生态度，或者需要更多的精力？接着列出一份详细的目录，将自己的弱点一一登记在案，然后有的放矢地改正它们。在工作中容易得到满足感的人们往往比不思进取的人更加深思熟虑。把时间花在寻根究底上，就可以让你明白自己和所希望的生活之间的差距究竟有多远，还要对眼下的生活状态了若指掌。”<br>“一旦你看到了自己的弱点所在，那下一步的工作就是要直接面对它们，向自己的恐惧心理开战。中国有句俗话叫作‘怕处有鬼’，人们通常会被自己臆想出来的怪物吓傻了。恐惧只不过是你自己在头脑中制造出来的怪物，是一连串的负面意识。所以，要克服自己的心理痼疾。如果你惧怕当众演讲，就专门签约进行20场演讲，哪怕你要为此支付主办方一定的费用。如果你固守陈规，害怕开展新业务，或者想逃避不愉快的人际关系，那就专门给自己制造这方面的挑战环节。只要你迈出第一步，后面的路就好走了。当你像一只蝴蝶从蛹中破茧而出的时候，那将是你在这么多年以来第一次尝到真正的自由的滋味。</p>\n<p>恐惧是一种条件反射，如果你不留神的话，它很快就会把生命力、创造力和精神都消耗殆尽。一旦恐惧满怀恶意地探出它丑陋的脑袋，你就应该一下子把它击垮。最有效的办法就是去做让自己感到害怕的事情，借此完全了解恐惧的内在结构。当你进入了恐惧的内部，就会发现它不过是源于你自己的胡思乱想。就像任何其他人创造出来的东西一样，把它揭穿就像把它创造出来一样简单。你可以学着有系统、有方法地查明底细，看清楚蛰伏在你心智深处的每一种恐惧到底都是什么，而后再一一击破。长此以往就会带来无限的信心、幸福和内心的安宁。**” </p>\n<p><strong>“真的有人拥有无所畏惧的心灵吗？”我问他。<br>“问得好。我将毫不犹豫地断然回答：‘是的！’喜马拉雅山上的智者个个都毫无畏惧。你可以从他们走路的样子上看出这一点，可以从他们的谈吐内容上听出来这一点，也可以在深深凝视他们双眼时发现这一点。其实生活中有很多这样的例子，电影《勇敢的心》你看过吧？”<br>朱利安顿了顿，接着凑近我说：“我再给你说点别的，约翰。”<br>“什么啊？”我问他，心中对他刚才讲到的事情充满了好奇。<br>“</strong>我也曾一度胆小如鼠。对此我心知肚明，因此就打算进行一次自我清理，找到天生的意志力和无限的潜能。后来我找到了胆小的根源，正是因为这么多年来一直忽略自我以及思想发展的不平衡阻碍了我的发展。我再告诉你一件事。当你把恐惧从头脑中彻底驱逐出去之后，你就会变得更年轻，也变得更有活力。**” </p>\n<p>“啊哈，<strong>古老的身心联系</strong>。</p>\n<h2 id=\"迎着弱点和恐惧直面而上\"><a href=\"#迎着弱点和恐惧直面而上\" class=\"headerlink\" title=\"迎着弱点和恐惧直面而上\"></a>迎着弱点和恐惧直面而上</h2><p>另外一条非常有效的法则，我也时常会想到它。我觉得，当你走在引导自我和控制自我的道路上时，这条法则对你而言将是无价之宝。每当我想要投机取巧的时候，它就会批评我，给我以上进心。这一人生哲学可以简单地归纳为：行事高效的人和死气沉沉的人之间的最大区别在于，前者会去做后者不喜欢做的事——尽管他们可能也不愿意去做。<strong><br>“</strong>真正开悟的人，每天都可以体味到深沉的幸福感，随时准备着为了长久的满足而放弃短暂的快乐。他们就这样迎着弱点和恐惧直面而上，即便有时因为深陷未知的领域而感到极大的不自在也无所谓。他们下定决心，要依靠‘禅悟’的智慧来生活，永不间断地提高人生的各个层面。过去曾阻碍他们获得快乐、健康和富有的恐惧也会败下阵来。</p>\n<h2 id=\"幸福要通过对一个有价值目标的渐进实现才能得到\"><a href=\"#幸福要通过对一个有价值目标的渐进实现才能得到\" class=\"headerlink\" title=\"幸福要通过对一个有价值目标的渐进实现才能得到\"></a>幸福要通过对一个有价值目标的渐进实现才能得到</h2><p>我最喜欢的教授给我讲过的一个古老故事。<br>有一天晚上，一位父亲在办公室工作了一整天以后开始拿着报纸看，想享一会儿清闲。可他的儿子很想玩，就一直缠着爸爸。最后，这位父亲被搞得不耐烦了，气呼呼地扯下一张地球画报，撕成了一大把小小碎片。“来吧，儿子，过来把它们重新拼在一起。”他说着，希望这一招可以让孩子忙上好一阵子，以便自己可以从容地看完手中的报纸。<br>让他大吃一惊的是，还不到一分钟，他的儿子就兴冲冲地带着一张拼贴无误的图片回来了。当这位目瞪口呆的父亲问儿子是怎样完成这个拼地图的壮举时，儿子笑得甜甜的，轻松地回答说：“爸爸，在这张地球图片的反面是一个人的图片，只要我把这个人拼在一起了，世界地图也就完整了。”<br>“真是棒极了。”我不由得赞叹起来。<br>“你看，约翰，从喜马拉雅山上的智者到哈佛法学院的教授，在我认识的最有智慧的人当中，似乎每个人都洞悉了幸福公式的要领。</p>\n<p>幸福要通过对一个有价值目标的渐进实现才能得到。当你在做自己全心全意热爱着的事情时，就一定会感到深深的满足。</p>\n<h2 id=\"做你喜欢的事情，需要很大\"><a href=\"#做你喜欢的事情，需要很大\" class=\"headerlink\" title=\"做你喜欢的事情，需要很大\"></a>做你喜欢的事情，需要很大</h2><p>我不妨再说得明确点，约翰。做你喜欢的事情，需要很大的勇气。它意味着你为了当演员要放弃手边正在做的工作，在不那么重要的事情上少花些时间，留下时间给更有意义的事情。它要求你离开习以为常的规律，也就是抛弃惰性，勇于创新。这种变化在最初的时候总会有些让人难以适应，而且具有一定的风险。但请一定记住我前面反复说的话，这正是走向快乐人生的起点。</p>\n<p>一个人究竟应该怎样鼓起勇气呢？<br>这也像刚才故事里所说的：只要你可以控制自己，你的世界就没问题了。只要你能控制自己的心智、身体和品质，幸福和富裕就奇迹般地来到你的生命中。但是，你每天都要在自我完善上花一些时间，哪怕只有10到15分钟。</p>\n<h1 id=\"相扑选手，注意‘禅悟’的提示者\"><a href=\"#相扑选手，注意‘禅悟’的提示者\" class=\"headerlink\" title=\"相扑选手，注意‘禅悟’的提示者\"></a>相扑选手，注意‘禅悟’的提示者</h1><p>这位肌肉发达的大块头就是不断提醒我们注意‘禅悟’的提示者。这个词在日语中的意思就是持续的自我发展和进步。</p>\n<p>我已经明白了自己的心智其实是那么神奇，宝贵的潜能又将创造怎样的奇迹。我已经学会了非常高效的技巧，可以把能量集中到我的愿望和梦想上。我已经知道在生命中树立明确目标的重要性，要在我人生、职业和精神世界的每一个方面都设立非常清楚的目标。现在我已经完全接受了那个自我掌控的古老法则：“禅悟”</p>\n<h2 id=\"活力生活的十个招数\"><a href=\"#活力生活的十个招数\" class=\"headerlink\" title=\"活力生活的十个招数\"></a>活力生活的十个招数</h2><h3 id=\"孤独的习惯\"><a href=\"#孤独的习惯\" class=\"headerlink\" title=\"孤独的习惯\"></a>孤独的习惯</h3><p>第一个办法被智者称作‘孤独的习惯’。所要求的无非是你在每天的日程表上划出来一段时间，这段时间用来保持自我的宁静，哪怕是一段强制性的自我宁静。</p>\n<p>这段时间少则15分钟，多则50分钟。在此期间你要感受沉默的力量，要渐渐领悟到你究竟是谁。</p>\n<p>把‘孤独的习惯’想成是灵魂长途跋涉中的短暂休息。它的目的就在于获得自我更新的机会，通过独自一人沉浸在美丽的沉默当中来实现。” </p>\n<p>“沉默有什么特别之处吗？<strong>”<br>“问得好。</strong>沉默和宁静把你和内部世界的创造力源泉联结在一起，解放所有智力的束缚。你看，约翰，心智好比一汪湖水。在我们这个嘈杂的世界上，大部分人的头脑里都安静不下来，因为我们的内心充满混乱。然而，只要你肯每天花一点时间来静心沉默，心智也就会变得平静如镜。内在的安宁会带来丰厚的回报，包括健康舒适的感觉，内在心态的平和以及无穷的精力。你甚至会睡得更香，而且在日复一日的劳作中享受到自我更新的平衡感。</p>\n<p>“我应该到哪里去寻找这一刻的安静呢？”<br>“从理论上说，你可以在任何地方，无论是在卧室还是在办公室。关键是要找到一个真正安静的地方——而且环境要很优美。”<br>“为什么必须是优美的环境呢？”<br>“<strong>优美的环境能够慰藉不安的灵魂，”朱利安解释说，深深地叹了一口气，“一束玫瑰，或者仅仅是一支孤零零的水仙，都会很好地改善你的情绪，让你得到非常有益的放松。说得更理想化一点，你应该在“个人避难所”中尽情享受这样的优美。我突然想到了一句东方禅语：菩提本无树，明镜亦非台，本来无一物，何处惹尘埃。</strong>”<br>“什么，什么？”<br>“<strong>简单说来，就是你为了自己的心智得到扩展，为了提升自己的精神境界，要学会把一个地方变成密室。这可能是你家中的空余房间，或者仅仅是一间小公寓中的安静角落。问题是你要给自己的更新行动保留一个相对固定的空间，一个静静地等待你到来的地方。</strong>”<br>“我喜欢这种说法。我想如果我在下班回家以后有了一个安静的地方可去，就会大大改变一切。我可以在那儿先待上一会儿，缓冲一下，消除一天当中的压力。这可能让我对周围的人更加有耐心。”<br>“<strong>这就涉及另外一个重要的问题。如果你每天都在同一时间来练习孤独静处的习惯，效果才会是最好的。</strong>”<br>“为什么？”<br>“<strong>因为它会作为一个习惯进入你的日常生活，成为一个有机组成的部分。如果在每天的同一时刻都来练习它，每日按时到来的静默很快就成为不容忽略的习惯。而积极的人生习惯将最终引导你到达目标。</strong>”<br>“还有别的吗？”<br>“是的。<strong>如果有可能的话，每天都和大自然谈谈心。在树林里做个短短的散步，或者哪怕是到后院，在你的西红柿苗圃里花上几分钟去浇水施肥，都会把你和安静的源泉重新连在一起。或许现在想一想这些事情就能让你的内心恢复平静。和大自然在一起，会激发你自身无穷的智慧。这种自我认知可以在自我潜力的方向上持之以恒地推动你的进步。别忘了这一点。</strong>”朱利安建议道。他的声音因为充满热情而慢慢提高，无论如何也听不出来是一夜未眠的人。<br>“这一招对你有效吗，朱利安？”<br>“绝对有效。在阳光尚未跃出地平线的时候，我就早早起床，做的第一件事就是走到我的‘个人避难所’。那是我在练习‘玫瑰之心’时发现的，后来一直秘密地使用着。有时候我静默地沉思冥想几个小时。有的时候也许只需花费10分钟。结果大致相似：我获得了一种内在和谐的深刻感受，以及无限的身体精力。</p>\n<h3 id=\"体格锻炼的习惯\"><a href=\"#体格锻炼的习惯\" class=\"headerlink\" title=\"体格锻炼的习惯\"></a>体格锻炼的习惯</h3><p>“关于<strong>如何养护身体。</strong>”<br>“什么？”<br>“很简单。<strong>体格锻炼的习惯是基于一个基本原理：你只有通过养护身体才能进而养护心智。给身体做好充分地准备，才会给心智做好相应的准备。训练好了身体，才会训练好心智。你没有听东方的哲学家常常说什么‘天将降大任于斯人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为，所以动心忍性，曾益其所不能。’抽出一个整天，通过健身训练来滋养盛放心灵的殿堂。让身体活起来，让血液沸腾起来。你知道吗？一周有168个小时呢。</strong>”<br>“不，知道得不那么确切。”<br>“这是真的。其中至少有5个小时应该投入在某种方式的身体活动上。喜马拉雅山上的智者一直从事着一种古老的瑜伽训练，借此来唤醒身体内的潜能。天长日久，他们变得强壮有力，生机勃勃。这些身体超群的人很特别，<strong>他们常常在村子中央倒立，以此来保持年轻。</strong>” </p>\n<p>“那些智者还做过别的什么来养护身体吗？”<br>“<strong>瑜伽师拉曼和他的兄弟姐妹们都相信，精力充沛地在自然的环境中散步，不管是在高高的山路上，还是在茂密的森林深处，这些都将有助于缓解疲劳，修复身体内部的细微差错，以及恢复人体活力。要是天气太差，没法散步，他们就会在小屋中的密室里锻炼。他们可能会忘记吃一顿饭，但是决不可能忘记每天的练习。</strong>” “他们的茅屋中有什么东西？跑步机吗？”我开玩笑说。<br>“当然不是。他们有时候练习瑜伽。有时候他们会做双手或者单手直立的俯卧撑。开始我还很好奇，后来我渐渐意识到他们做什么其实并不重要。他们虽然姿势不同，但目的却是一致的，那就是充分活动身体，让四周的新鲜空气在肺部畅通地流淌，也让血脉贯通起来。”<br>“呼吸新鲜空气会有什么用呢？”<br>“我要借用瑜伽师拉曼最爱说的一句话来回答你：<strong>“适当的呼吸就等于适当的生活。</strong>’”<br>“呼吸有这么重要吗？”我奇怪地问道。<br>“当我到那儿之后，智者很快就教会了我如何使自己获得两倍甚至三倍精力的捷径，我也因此学会了进行有效的呼吸方法。”<br>“可是难道我们不懂得呼吸吗？这连新生的婴儿都会呀！”<br>“不完全是这样，约翰。<strong>我们中的大部分人都只是知道怎么呼吸才可以活下去，却不知道怎样通过呼吸来让自己更有活力。这是完全不同的两个层面的问题，前一个是生存问题，后一个是生活问题。大部分人的呼吸都太浅了，这样我们就不能吸入足够的氧气，导致我们的身体不能处在最佳的状态。</strong>”<br>“听上去，正确的呼吸还包含着很多科学知识呢。”<br>“确实如此。那些智者是这样对待呼吸的：<strong>通过有效的呼吸吸入更多的氧气，释放体内储藏的精力，从而达到活力收放自如的自然状态。</strong>”<br>“好啊，那么我应该从哪里开始呢？”<br>“<strong>事实上非常简单。每天两到三次，花一二分钟来深呼吸，使空气能够深深地渗透到你身体内的每一个细胞。</strong>”<br>“<em>我怎么才知道自己的呼吸变得有效了？</em>”<br>“<strong>嗯，当你使用正确呼吸方法的时候，你的腹部会稍稍鼓出来一点。这个迹象说明你开始从腹部呼吸了，这就很好。现在试试看……嗯，挺不错。瑜伽师拉曼教我的一个方法是，把双手扣在肚子上感受起伏。如果我吸气的时候肚子鼓起来了，我的呼吸技巧就算是达标了。</strong>” </p>\n<h3 id=\"生命滋养法\"><a href=\"#生命滋养法\" class=\"headerlink\" title=\"生命滋养法\"></a>生命滋养法</h3><p>那就是‘生命滋养法’。在我做律师的那些日子里，我每天的食谱都是固定的，主要是牛排、油炸食品还有其他形形色色的垃圾食品。虽然我总是在城里最好的餐馆吃饭，可还是感到身体里面塞满了垃圾。那时候我并不特别清楚，这就是让我感到不愉快的主要原因之一。<strong>”<br>“真的吗？”<br>“是的。一份糟糕的食谱对你的生命有着显著的影响。它抽干你的脑力和体力，它影响你的情绪，还会扰乱你的逻辑能力。瑜伽师拉曼是这样说的：“</strong>你在滋养身体的同时，就是在养育心智。<strong>’”<br>“那么我猜你改变了食谱喽？”<br>“</strong>我已经彻底改变了自己的餐饮习惯，比如我从来不喝有色素与人工添加剂的饮料，也不再光顾快餐食品店。不久之后，控制饮食的效果就出现了，我的感觉和相貌发生了令人惊异的变化。以前我总是以为，我之所以那么死气沉沉主要是因为工作中的压力和疲劳，而且上了年纪以后身体渐渐不中用了。到了喜马拉雅山上，我才发现我的昏睡懒散其实是因为自己给身体内注入的动力燃料实在是太低劣了。<strong>”<br>“那些智者靠吃什么东西来保持青春和愉快呢？”<br>“</strong>吃新鲜的食物。<strong>”他的回答很简明。<br>“啊？”<br>“</strong>答案就是新鲜的食物。它指的就是没有死去的东西。<strong>”<br>“说说呀，朱利安。哪些东西属于新鲜的食物？”我急躁地问他。<br>“</strong>说得简单点，所谓的新鲜食物就是在自然当中吐故纳新的食物，是通过太阳、空气、土壤和水之间的相互作用中而产生的。我要告诉你的是一种蔬菜食谱。只要你能保证在盘子里堆满蔬菜、水果和谷物，然后就可能长命百岁。<strong>”<br>“真的有可能吗？”<br>“生活在喜马拉雅山顶的大部分智者都已经有一百多岁了，而且看不出有任何衰老的迹象。就在上个星期，我在报纸上读到了一篇报道，大体说一群人生活在中国东海冲绳群岛中一个小岛上。研究者之所以关注这个小岛是因为被一个事实给震惊了：这个岛上聚居着世上最大的百岁老人群落。”<br>“这些研究者发现了什么长寿诀窍没有？”<br>“</strong>结果是，素食是他们长寿的主要秘诀。<strong>”<br>“但是这种食谱健康吗？你知道素食可不一定能够提供足够的气力。请注意，我可还是个忙忙碌碌的律师，朱利安。我总不至于为了长寿而饿昏在庭审现场吧。”<br>“不必担心，</strong>这是一个充分自然的、人性化设计的食谱。它会让你有生气，有活力，而且极其健康。智者已经依靠这个食谱生活了数千年。他们称之为‘悦性食物’，也可以叫作‘纯净饮食’。<strong>既然你最关心力量，那我想提醒你注意，地球上最强有力的动物，从大猩猩到大象，它们都是不折不扣的素食主义者。然而你知道吗？一头大猩猩的力量可比一个男人大30倍。”<br>“真的不可思议啊。谢谢你告诉我这则趣闻。”<br>“看，智者并不是走极端的人。</strong>相反我们现代人却是常常执迷不悟。智者所有的智慧都建立在一条古老的法则上，那就是‘生活适度，做事中庸。’因此，如果你喜欢吃肉，当然还可以继续吃，智者也不会阻拦你。只是你要明白一点，你是在吞下已经死去了的东西。如果可以，尽量少吃红肉，因为红肉很难消化。你的消化系统在整个身体里面是消耗能量最多的部分，非常有价值的精力就这样被肉类食品毫无必要地消耗掉了。你有没有这样的体验，当你中午吃了一份牛排大餐之后，你很快会觉得自己的嘴巴里充满了不洁的味道，不断地打饱嗝儿。接下来，你就会觉得昏昏欲睡，整个人好像梦游一样？<strong>”<br>“确实如此。”我承认。每次午饭前我会因为饥饿而头昏脑胀，而饱餐一顿后我又会因为吃得太饱而昏昏沉沉。就这样，每天上午的十一点到下午两点都是我工作效率最低的时候。<br>朱利安同情地看了看我，我想他一定联想到我在午饭后睡眼蒙眬的丑态。他接着说：“</strong>难道你没有发现我目前的变化吗？建议你给自己的能量标准做个对比，在吃完一份牛排和一盘色拉之后，你的感觉一样吗？如果你不希望一下子就变成一个地地道道的素食主义者，那么至少要在每顿饭里加一道色拉，用水果代替甜点。即便这一点微小的改变也会为你的生活质量带来巨大的改变。**</p>\n<h3 id=\"扩展知识法\"><a href=\"#扩展知识法\" class=\"headerlink\" title=\"扩展知识法\"></a>扩展知识法</h3><p>第四招被称作‘扩展知识法’。<strong>它是一个</strong>关于终身学习，为了给自己和周围的人造福的理念。**”<br>“听起来好像那句老话‘知识就是力量’，是不是？”<br>“它的内涵更加丰富，约翰。知识不仅仅是潜在的力量。因为力量是显而易见的，而你必须进入实践的层面。大部分人在特定的情况下，或者在生活遇到困难时，都明白应该怎么去做。问题在于他们不是天天都这样，没有在使用知识和实现梦想方面持续地加以努力。扩展知识法的宗旨就是成为生活虔诚的学生。而更为主要的是，它要求你把教室里学到的知识顺利地应用到现实生活中去。</p>\n<p>“瑜伽师拉曼和其他智者是怎样应用这个方法的？”<br>“在日常使用中，他们有很多辅助的方法可以和‘扩展知识法’配套使用。最重要的一个技巧也是最简单的。今天你就可以开始试一试。”<br>“不会花很多时间吧？”<br>朱利安颔首微笑。“我和你分享的这些策略、方法和小技巧都会使你变得比以前更加能干，更加高效。不要捡了芝麻，丢了西瓜。想一想那些说自己太忙，顾不得在电脑上备份文件的人吧。一旦他们的机器出了意外，几个月以来的重要工作都将毁于一旦，他们就会捶胸顿足，遗憾自己为什么没有每天花一点点时间去保存文件。你明白我的意思了吗？”<br>“就是说<strong>要先弄明白生命中的主次关系，不要本末倒置？</strong>”<br>“<strong>完全正确。努力使你的生活挣脱时间表的束缚。把精神集中到你的良知和内心告诉你要去做的事情上。当你开始探知自我，并且开始把自己的时间花在提高心智、身体和个性的品质上，你很快就会感到自己的体内仿佛存在着一个领航员似的，他会随时告诉你哪些事情值得去做，而且会带来最丰厚、最有价值的回报。你将不再会为钟表上的时间感到焦虑，而是开始尽情享受生命内在的律动。</strong>”<br>“啊，我明白了。那么接下来你要教给我的<strong>那个简单的辅助办法是什么？</strong>”<br>“<strong>定期读书。每天读书30分钟会给你带来意想不到的结果。但是我必须提醒你，不要碰到什么就读什么。你一定要仔细拣选才行，因为它们将要进入你丰饶的心智花园。它一定得是非常有营养的物质，否则将会适得其反。它们要帮助你改善自我，而且还要提升你的生命品质。</strong>” </p>\n<p>“那些智者平常喜欢读什么书呢？”<br>“<strong>他们在醒来以后，就会花很多时间去阅读古人留下来的教诲。他们对这些哲学著作如饥似渴。迄今我还记得那些非常俊美的人们坐在小竹椅上阅读外形奇怪、装帧精美的书，脸上和唇边都洋溢着淡淡的微笑。正是在那里我真正意识到了书本的力量，知道了‘书本是智慧最好的朋友’这个道理。” </strong><br>“那么我应该开始阅读我能够找到的所有好书吗？”<br>“可以说是，但又不是。<br>”他这样模棱两可地回答我。“我从来都会支持你尽己所能地去读书。但是要记住，有些书只需要浅尝辄止，有些书却需要细细咀嚼，有一些需要辨证学习，而另一些则值得完全吸收。这让我想起另外一个问题。”<br>“你是不是饿了？冰箱里还有些酸奶。”<br>“不是，约翰，”朱利安笑了，“我只不过想要告诉你，<strong>一定要善于从伟大的书籍中获得最为精华的部分。你必须要好好地研究它，而不仅仅限于阅读。深入全面地研究它，就像你研读你的重要委托人给你的案子那样。切实地考虑它，和它相互切磋，成为伙伴。智者在广泛的阅读中，会把很多书读上10到15遍。在他们眼中，伟大的书籍就像是神赐的圣书。</strong>”<br>“哎哟！读书真的这么重要啊？”<br>“<strong>每天坚持读书30分钟，会给你的生活带来可喜的变化。因为你很快就会发现，有那么广博的知识宝库供你选择使用。你会变得谈吐不凡，思维敏捷，文思泉涌。你曾经遇到的每一个问题的答案都会历历在册，信手拈来。如果你想要成为一名更为出色的律师、父亲或者恋人，都会有相应的书籍知识帮你快速达到目的，避免走弯路。你在人生中犯下的所有错误都已经被前人们尝试过，因此你也将会很快找到改正的方案。你是不是真的以为你所面对的挑战都是独一无二的？</strong>”<br>“老实说，我从来没有这样想过，朱利安。但是我理解你所说的，而且我知道你是对的。”<br>“<strong>任何一个人遇到过的任何问题，在他的生命之前都已经被前人遭遇过了，而且不止一次，”朱利安断言道，“更重要的是，答案和解决办法都已经在书页上记下来了，就看你会不会发现它。养成正确阅读的习惯，学习前辈的珍贵经验，他们成功的策略会帮助你从容面对生命中遭遇的种种挑战。你会为发生在人生中的点滴进步而感到惊奇的。</strong>”<br>“什么样的书才是‘正确的好书’？”我追问着，很快就体会到朱利安的意见确实很不错。<br>“这个要留给你自己来判断，我的朋友。就我个人而言，自打我从东方回来以后，就把一天中最好的时光花在了阅读上。当然，每个人兴趣不同，我最感兴趣的是那些我所钦佩的男男女女的人物传记和大量的智慧之作。”<br>“你能不能为我这个还算得上勤奋工作的人列出一些有用的推荐篇目呢？”我一边说，一边难为情地笑了一下。<br>“没问题。<strong>比如你可以从伟大的本杰明・富兰克林的传记中获益颇多。我觉得你还可以从圣雄甘地的传记中发现很多成长的动力，那本书的名字叫作《甘地自传》。我还建议你读读赫尔曼・黑塞[7] 写的《悉达多》，还有马可・奥勒留[8] 写的实践性很强的书，以及塞涅卡[9] 的一些著作。你甚至还可以读一读拿破仑・希尔的《思考致富》。上个星期我认真地读了这本书，觉得真是回味深远。</strong>” </p>\n<p>书只是帮助你发现早已存在于自身之内的东西。这是一种唤醒，一种提示。这就是启蒙，如一束光照亮你的人生。我在经过了那么多的旅行和探险之后，最终发现我其实是走完了一个循环，回到了我还是孩子时的出发点。但是现在，我非常了解自己，知道我是谁，我也知道自己最终会成为怎样的人。**”<br> “所以说‘知识扩展法’就是大量读书，探索外界的丰富知识？”<br> “你只说对了一部分。因为在眼下一天只读30分钟书，你的理解也仅此而已。随着你对书籍的爱好与日俱增，其他意想不到的东西自然也会到来。”朱利安的话里暗含着玄机。</p>\n<h3 id=\"个人反思法\"><a href=\"#个人反思法\" class=\"headerlink\" title=\"个人反思法\"></a>个人反思法</h3><p>它的名字是‘个人反思法’。那些智者都坚信内在沉思的力量。通过一定时间的沉思来了解自我，就可能步入生命的另一个维度，这也许是你从来都不知道自己还具有的更高维度。</p>\n<p>其实说到根本上，个人反思不过是一种思考的习惯。</p>\n<p>对，是富兰克林。每天晚上在完成了一天的高效率工作之后，他一回到家里就会躲在一个安静的角落里，反思这一天的行为处世。他会反思他的全部行为，看其中哪些属于积极而富有建设性的，哪些属于消极而需要及时修正的。当他清楚地知道白天里犯下了什么错误时，他就会迅速采取措施进行改进，沿着自我控制的道路前进。等到以后再遇到类似的情况，他就会心知肚明，游刃有余。智者也是这样做的。每天晚上，他们都会躲进小棚屋里的清净角落，那里铺满了芳香的玫瑰花瓣，他们坐下来陷入深深的沉思。瑜伽师拉曼还会把他的一天经历写在日记里。</p>\n<p>“他写下来的都是些什么事？”我好奇地问。<br> “<strong>首先他会列出当天所有做过的事情，从早晨的身体锻炼，到他和其他智者之间的交流，再到他到森林里去找木柴和新鲜食物的经历。很有趣的是，他还会写下来在这一天里曾经在头脑中出现过的各种念头。</strong>”<br> “这样做岂不是难了点儿？我根本记不起来5分钟以前自己曾经想过什么，更不要说12个小时以前的想法了。”<br> “如果你每天都坚持做同样的练习就不会觉得难了。任何一个人都可以获得在我身上发生的改变，任何人。真正的问题是，有太多的人都饱受令人讨厌的疾病的折磨，这种疾病叫‘借口’。”<br> “我想我可能也染上了这种疾病。”我完全明白我聪明的朋友在说什么。<br> “别再找借口了，只管去做就好了！”朱利安提高声音说道，他的语调中充满了坚定的力量。<br> “做什么？”<br> “<strong>花时间去认真思考，并在生活中养成定期进行自我反省的良好习惯。有时候瑜伽师拉曼会将笔记纸的一页从中对折一下，把当天所有做过的事情、想到过的念头都写在一栏里，然后在另外一栏里作出相应的评价。当他面对书面记录下的行为和想法时，他会扪心自问，它们在本质上究竟是不是积极的。如果是积极的，他就决定继续为此付出宝贵的精力，因为从长远来看，它们会给他带来巨大的收益。</strong>” </p>\n<p>我认为现在你已经发现了‘个人反思法’的神奇力量。通过审视自己做过的事情，仔细反省自己是如何度过一天的。你要注意归纳自己在一天内一共出现了几种想法，这样一来你就给自己提供一个进步的标准。要在明天实现进步的唯一途径就是知道今天做了哪些错事，并且知道如何来加以改进。</p>\n<p>只有人类才会走出自我的阴影，并且能够分析他所做的事情中哪些是正确的，哪些是错误的。一条狗做不到这一点，一只鸟也不会这么做，就连聪明的猴子也不可能。但是你可以。这就是‘自我反思法’的根本宗旨，在每天的生活和整个人生当中，辨明什么是正确的，什么是错误的，然后尽快着手完善自己。</p>\n<h3 id=\"早早醒来法\"><a href=\"#早早醒来法\" class=\"headerlink\" title=\"早早醒来法\"></a>早早醒来法</h3><p>“<strong>我在遥远的喜马拉雅山上得到的最有用的一个建议就是，和太阳一起起床，然后成功地开始新的一天。我们大部分人的睡眠时间都比实际的需求要多得多。其实普通人睡六个小时就可以起床了——这已经足够他保持健康和思维的机敏了。睡眠无非一种习惯，像其他习惯一样，你可以训练自己达到你所希望的成果。试一试，能不能在这一个环节中睡得少一些。</strong>”<br> “可是，如果我起床太早了的话，我真的会感到精疲力竭。”我说。<br> “在刚开始的几天里，你可能会感到疲倦。我也曾有同感。你甚至有可能在练习早些起床的第一个星期里一直有这样的疲劳感。不过，请把这看成是为了得到长期的巨大收益而付出的短暂的、少量的痛苦。在你确立一个新习惯的时候当然会多多少少感到有些不舒服。这就像你穿上了一双新鞋子——刚开始穿上的时候觉得有点疼，很快就很惬意了。正像我此前告诉你的那样，痛苦往往是个人成长的前奏。别害怕起早。相反，接受它。”<br> “好吧，我喜欢这个训练自己早点起床的观念。可是先得让我问问你，<strong>‘早’起意味着几点钟起？</strong>”<br> “又是一个好问题。这跟时间没有关系。就像我到现在为止和你分享的各种方法一样，都是要你按照认为正确的标准去做。记住瑜伽师拉曼的警告：“凡事不可过分，处处都要适度。’”<br> “日出时起床，这听起来已经很过分啦。”<br> “实际上并不过分。几乎没有什么比一天当中新射出的第一缕阳光更加光辉灿烂的了。智者坚信，阳光是来自上苍的礼物。尽管他们都很小心，不过多地暴露在阳光下，但是他们会定期做日光浴，还经常在阳光明媚的清晨顽皮地舞蹈。我完全相信这是他们保持长寿的另一个秘诀。”<br> “你也做日光浴吗？”我问。<br> “当然做。阳光使我恢复活力。当我感到劳累时，阳光会让我高兴起来。在东方古老的文化里，太阳被认为与灵魂相连。人们崇拜太阳，因为太阳让庄稼和他们的精神一起丰收。阳光可以释放你的生命力，恢复情感和身体上的活力。它是一位令人心情愉快的医生，不过前提是你适当地接触它。唉，我又跑题了。我们讨论的是早点起床，每天坚持。”<br> “哈哈。我怎么才能把这个习惯纳入日常的生活？”<br> “<strong>这里有两个简便易行的小诀窍。首先，千万别忘了，重要的是睡眠的质量而非睡眠的数量。在不受干扰的情况下沉沉地睡上六个小时要比时常被打断的十个小时睡眠好得多。睡眠的目的在于让你的身体得到休息，这个自然的生理过程可以修复、重建你的身体，减少日常消耗带来的压力和挣扎，使你的身体恢复自然的状态。很多智者的习惯都基于这一原则。举个例子来看，瑜伽师拉曼在晚上八点以后就再也不吃东西了。他说消化活动及其附带的生理活动会降低他的睡眠质量。智者还有另一个习惯，睡觉之前他们会在轻柔的竖琴乐声中冥想。</strong>”<br> “这种行为的原因是什么？”<br> “让我来问问你，约翰。每天晚上睡觉之前你会做些什么？”<br> “我和詹妮一起看新闻节目，我知道这和大部分人做的事情一样。” “我就知道。”朱利安回答，眼睛中有奇异的闪光。<br> “我不明白。在睡觉以前看上一点新闻有什么错的？”<br> “<strong>你睡觉之前的10分钟，还有醒来之前的10分钟，都会在你的潜意识里留下长久的影响。在这两个时间段，你应该只向你的头脑输入最愉悦、最安静的想法。</strong>”<br> “瞧你说的，人的头脑听起来就跟电脑似的。”<br> “<strong>这么来看待头脑也不失为一种好办法——你输入的东西就是将要产出的东西。更加重要的事实是，程序员只有你一个人。通过决定让哪些念头进入头脑，你也就可以明确地知道哪些念头将会产生出来。所以在你去睡觉之前，不要看什么新闻，不要和任何人争吵，也不要在脑海中回顾一天的所作所为。放松，如果你喜欢的话，慢慢地喝一杯花茶，听一点轻柔的古典音乐，做好准备，让自己渐渐滑入甜美的熟睡中。</strong>”<br> “有道理。睡得越好，睡得越少。”<br> “确实如此。<strong>一定要记住古老的21天法则：如果你连续21天做一件事情，它就会确定成为你的习惯。所以，在你因为感到不舒服而放弃早起的行为前，你要坚持三个星期。</strong>到了那时，早起就成为了你生活的一部分。在很短的时期内，你就能够轻轻松松地在早晨五点半，甚至是五点钟起床，准备好领略新一天到来时的壮丽场景了。”<br>  “好吧，那么如果说，我现在每天都是五点半起床的话，我又该做些什么呢？”<br>  “<strong>从你问的问题就可以看出你确实是在思考，我的朋友。对此我很欣赏。起床之后，你可以做很多事情。要在头脑里面时刻记住的基本原则是，好好开始新的一天是非常重要的。就像我曾建议过的，在你醒来以后的十分钟内，最先进入到脑海里的念头和最先着手的行为，往往会在接下来的一天中产生非常明显的效果。</strong>”<br>  “此话当真？”<br>  “当然。<strong>去想那些积极的念头；对你所拥有的一切做感恩祈祷；感谢你要感谢的人；倾听一些伟大的音乐；看太阳升起。兴之所至的时候，你还可以去自然环境中散步。实际上，智者还常常让自己开怀大笑，不管是不是有高兴事，这不过是为了让快乐在清晨便开始流动。</strong>”<br>  “朱利安，我尽力使自己的头脑能够接受你的讲解——而且我想你也会承认，作为一个初学者我做得已经很不错了。可是，就算是对一群生活在喜马拉雅山高峰上的高僧来说，那样的事情听起来也真的太奇怪了。”<br>  “其实不足为奇。你猜一猜，一般来说，一个四岁的孩子一天要大笑几次？”<br>  “谁知道呢！”<br>  “我知道，一共三百次。嗨，你不要做出这么惊讶的表情。现在再猜猜看，在我们的社会中一个成年人在一天之内会大笑几次？”<br>  “五十次？”我猜测着。<br>  “勉勉强强十五次，”朱利安回答道，微笑中充满胜利感。“你明白我的意思了吧？<strong>大笑是灵魂的良药。如果你能对着镜子开怀大笑几分钟，即使你并不喜欢这样做，你也会忍不住感到很奇妙。威廉・詹姆斯说过：‘我们不是因为快乐才笑，而是因为笑才感到快乐。’所以，让你的一天从快乐开始。大笑，玩耍，为你拥有的一切感恩。由此，每一天都会变得极其有意义。</strong>”<br>  “那么你是如何积极地开始自己的一天呢？”<br>  “说实话，我已经养成了一套非常系统的晨练方式，包括所有的内容，从练习‘玫瑰之心’到喝几杯鲜榨水果汁。但是有一个方法我特别要和你一起分享。”<br>  “听起来很重要嘛。”<br>  “是很重要。<strong>你在刚醒来以后，就到你那个‘个人避难所’去，静下心来，集中精神，然后问自己这个问题：“如果今天就是生命里的最后一天，我将做些什么？’答案就在于准确理解这个问题的含义。在头脑里列出来所有你想做的事情，你想打电话的人们，以及你想享受的时刻。想象你自己正在兴致高昂地完成这些事情。想象自己对待家庭、朋友和完全陌生的人的样子。如果今天就是你活在这个星球上的最后一日，想象自己该怎样度过这珍贵的一天。正如我早先告诉你的，当你在度过每一天时都像对待生命的最后一天那样，你的生活将会焕发出奇异的色彩。</strong> </p>\n<h3 id=\"音乐法\"><a href=\"#音乐法\" class=\"headerlink\" title=\"音乐法\"></a>音乐法</h3><p>智者很热爱他们的音乐。音乐就像太阳一样给予他们同样的精神鼓舞。音乐让他们开怀大笑，让他们闻之起舞，应和歌唱。它对你也会起到同样的作用。千万别忘了音乐的力量。每天在音乐上花一点时间，哪怕只是在你驱车上班的路上听几首轻音乐也好。当你觉得消沉或者疲倦，演奏一会儿音乐吧。这是我所知道的最有效的动力之一。</p>\n<h3 id=\"口语练习法\"><a href=\"#口语练习法\" class=\"headerlink\" title=\"口语练习法\"></a>口语练习法</h3><p><strong>第八招的名字叫‘口语练习法’。智者有成套的‘真言’供他们在早、中、晚念诵。他们对我说这个练习非常有效果，可以帮助他们保持专注，变得更强壮和幸福。 </strong>”<br>  “‘真言’是什么？”我问。<br>  “<strong>真言就是一连串能够产生积极影响的话语。在梵语里面，‘man’的意思是心智，‘tra’的意思是解脱束缚。因此真言‘mantra’这个词语指的就是对心智有计划的解放。而且请你相信我，约翰，真言是达到这一目的的非常有效的方法。</strong>”<br>  “那么你在日常生活中也练习说真言吗？”<br>  “我当然也是这样。无论我走到什么地方，它们都是我最忠实的同伴。不管我是坐在长途巴士上，在走去图书馆的路上，还是穿过一个公园观察着周遭的世界，我总是通过诵读真言来肯定我生命中所有美好的东西。”<br>  “所以真言是口头的？” </p>\n<p>  “<strong>也不一定非要说出来。写出来的形式也一样很有效。但是我发现，大声背诵真言会对我的精神起到奇妙的效果。当我觉得需要动力支持时，就会重复说‘我有创造力，有自制力，有精力’这句真言二百到三百次。如果要保持高度的自信，我就会重复说，‘我很强壮，很能干，很镇静。’我甚至还使用这些真言来保持我的青春和活力。</strong>”朱利安坦言道。<br>  “一句真言又怎么能够让你保持年轻呢？”<br>  “<strong>语言会长久地作用于心智。这是一种古老的心理暗示法，并且屡试不爽。无论是写下来还是说出来，它们都会产生强有力的影响。你对别人说什么很重要，但更重要的是你对自己说什么。</strong>”<br>  “自言自语吗？”<br>  “对呀，<strong>你每天怎样想的，你就是什么样的。你每天对自己说什么，就会变成什么样子。如果你说你又衰老、又劳累，这句话就会在你的外在世界中显形。如果你说自己很虚弱，缺乏热情，这也会成为你现实中的特点。但是，假如你说你很健康，很活跃，充满活力，那么你的生活将得到改变。想想那些身患绝症却依然乐观向上的人们吧，他们就是通过有效的心理暗示为自己争得了珍贵的生命时光。</strong>”<br>  朱利安略微休息了一下，然后接着说：“<strong>你看，你对自己说出的话语影响到你的自我形象的想象，而你的自我想象又将决定你会采取什么样的行动。举个例子说，如果你想象的自我形象是一个没有信心去做任何有价值的事情的人，你所能采取的就不过是与这个特点相似的行动。如果你想象自己是一个充满活力，无所畏惧的人，同样，你所有的行为都会和这一品质相适应。在某种程度上，你的自我形象想象就是对于自我的长久预言。</strong>”<br>  “怎么会是这样呢？”<br>  “<strong>如果你相信自己做不到什么事情，比如说，无法找到一个完美的伴侣或者无法过上没有压力的生活，你的信念就会影响你的自我想象。反过来，你的自我想象也会阻止你采取行动去找到一个完美的伴侣或是为自己创造出一种平静的生活。事实上，它会妨碍你在这个方向上作出的任何努力。</strong>”<br>  “为什么会这样呢？”<br>  “<strong>很简单。你的自我想象其实是某种心理控制。它绝不会允许你在与它不相一致的方式上行事。但是好在你可以改变自我想象，就像你改变人生中其他的方面一样。真言就是完成这一目标的有效方式。</strong>”<br>  “而且啊，当我改变内在世界的时候，也就改变了外在世界。”我发自内心地说。 </p>\n<h3 id=\"个性调试法\"><a href=\"#个性调试法\" class=\"headerlink\" title=\"个性调试法\"></a>个性调试法</h3><p><strong>活力人生的第九招。这个方法是‘个性调试法’。它是我们刚才讨论的自我想象概念的分支。简而言之，这个方法是要求你每天循序渐进地塑造自己的性格。这一过程将影响到你对自我的看法和所采取的行动。你所进行的行为会集中起来，渐渐形成你自己的固定习惯，而你的习惯将会决定你的命运。瑜伽师拉曼对此说得很明了：‘你种下一粒思想，就收获一个行动；种下一个行动，就收获一种习惯；种下一种习惯，就收获一种性格；种下一种性格，就收获了整个命运。</strong>’”<br>  “我应该做些什么事情来塑造自己的性格呢？”<br>  “你可以做任何可以培养美德的事情。在你问我何谓‘美德’之前，先让我澄清一下这个概念。<strong>喜马拉雅山的智者相信，有德行的人生才是意义丰富的人生。所以他们用一系列的古老原则来支配自己的行动。</strong>”<br>  “但是我记得你曾经说过，<strong>他们是用自己的目标来支配人生？</strong>”<br>  “是的，基本上差不多，但是他们的生活愿望在某种意义上还与这些原则相协调，那是他们的祖先在几千年前就已经深深植入他们心灵的。”<br>  “那些原则是什么，朱利安？”我问。<br>  “<strong>简单地说就是：勤劳、慈爱、谦逊、耐心、诚实和勇敢。如果你的行动和这些原则完全相符，你就会感到内在深深的和谐与安宁。依照这种原则来生活无疑会将引领你走上精神世界的成功。这是因为你所做的事情都是正确的。你将按照和自然法则以及宇宙法则相一致的方式来行事。你开始吸收另一个维度上的精力，或者称之为更高的力量。这同时也意味着你的生活将从庸常进入超凡境界，开始体味人生存在的神圣感。这也是毕生启蒙的第一步。</strong>”<br>  “你有过这样的经验吗？”我问。<br>  “有过，而且我相信你也会有的。做正确的事情。依照和你的真实性格相匹配的方式来行动。正直地行事。接受内心的指引。如此一来，其他的事情也会自然而然地好起来。约翰，你永远都不会孤独。”朱利安回答。<br>  “你这话是什么意思？”<br>  “也许我下一次再解释给你听吧，眼下我们不能总是跑题。<strong>你得记住，必须每天做一些小事来培养自己的品格。正如爱默生说的那样：‘品格高于才智。一个伟大的灵魂不仅善于思考，更善于生活。’如果你按照我刚才提到的那些方法来做事，你就会塑造出高尚的品格。如果你不这样做，真正的幸福就会弃你远去。</strong>”</p>\n<h3 id=\"化简法\"><a href=\"#化简法\" class=\"headerlink\" title=\"化简法\"></a>化简法</h3><p>这个方法要求你过一种简单的生活。就像瑜伽师拉曼所说的，‘一个人千万不要生活在肤浅事物中。集中精力于那些最重要的、有意义的事情。这样，你的生活将会清晰有条理，有价值而且格外安宁。这一点我可以向你保证。</p>\n<p>怎样养成化简的习惯？<br>要学会做减法，我们的生活本来已经够复杂的了，不要总是给自己找不痛快。就像我吧，我不再穿昂贵的衣服，我戒掉了一天看六份报纸的瘾，我不再需要让自己随叫随到，我变成了一个素食主义者而且吃得比以前少。从根本上说，我削减了自己的需要。东方的智者曾经有过精辟的总结：‘有容乃大，无欲则刚’。这话多有用啊。你看，约翰，除非你削减自己的需要，否则你永远不会得到满足。你会一直像拉斯维加斯赌场中急红了眼的赌徒，守在轮盘赌转盘前面期待着‘再转一次’，不停地祷告，盼着你的幸运号码马上到来。你会一直想要得到比现在拥有的更多的东西。可事实怎么样，相信不用我再赘言了。</p>\n<p>如果我想把‘化简法’纳入自己的生活，我应该做哪些事情？</p>\n<p> “你能做的事情太多了。即使是小事情也能带来改变。”<br>  “比如说？”<br>  “<strong>电话响起的时候不要每次都慌慌张张地去接听，或许是人家打错了电话；不要在阅读垃圾信件上浪费时间，因为你看后即忘；不再每星期在外面吃三次饭，那样你会变得大腹便便；放弃你的高尔夫会员资格，花更多的时间和孩子们待在一起；一周之内有一天不看手表，你要学会告诉自己：“少了我，地球照样转动’；每过几天就去看一次日出，感受大自然的神奇；把你的手机卖掉，不要成为别人随叫随到的奴役……还要我继续说下去吗？</strong>”朱利安反问道。 </p>\n<p>我向你担保，通过练习这些策略和方法，你会从那一刻起，在一个月之内看到显著的提高。你在生活中的各个方面都将会有更多精力，更少烦恼，更多创造力，更小压力。我前面也已经说过了，智者的方法不是速成型的，肯定没有驱虫药的功效那么神奇。它们都是古老的修行传统，为了你今后生活的宁静，你需要天天练习。如果你停下来一段时间，就会发现自己又逐渐回到旧日的道路上去了。</p>\n<h2 id=\"精神\"><a href=\"#精神\" class=\"headerlink\" title=\"精神\"></a>精神</h2><p>我向你解释的那些秘诀会让你在生活中创造出所希望的一切。但是那些智者的哲学视野要远远高于我们所能看到的地方。到目前为止我教给你的都是非常实用的知识。但是你一定要明白，在我列出的种种原则之下，其实还涌动着许多潜在的精神力量。也就是东方哲人所说的那句‘言有尽而意无穷’。如果你不理解我所说的这些话，不要太担心了。只要你肯听进去，再好好地想上一会儿，之后就会慢慢地理解和接受了。<strong>”<br>  “学生做好准备的时候，老师就会出现，是吗？”<br>  “正是这样，”朱利安说，露出笑容，“你一直学得很快。”<br>  “好吧，</strong>让我们来听听精神的部分<strong>，”我充满活力地说，根本没有注意现在已经快早上五点半了。<br>  “</strong>想象一下，你现在正栖息于日月天空之下，生活在宇宙的所有奇妙之间。创造这些奇迹的智慧就与把你创造出来的那种力量完全相同。你身边的任何东西都是来自同一个地方，我们本是一体，万物皆为一体。”<br>  “我不确定自己是否明白你的意思。”<br>  “地球上每一种活着的生物，地球上每一件看似静止的事物其实都有自己的灵魂。所有的灵魂都汇成一个，那就是宇宙的灵魂。就像是一滴水融入大海，汇成海洋的波浪彭湃。同样，我们也能够从大海中感受到那一滴水的生命律动。你看，约翰，当你养护自己的心智和精神时，你的确也是在滋养宇宙的灵魂。而当你提高了自我，也就是在提高所有存在于你四周的生命。当你有勇气不断接近梦想的方向，你也就开始利用宇宙的力量。正如我此前已经告诉你的，生命回报给你所要求得到的任何东西。它一直在侧耳谛听。<strong>”<br>  “所以说自我控制和‘禅悟’都将通过帮助自己而对别人有所帮助？”<br>  “可以这样说。当你丰富自己的心智头脑，养护自己的身体以及滋养自己的精神时，你都会逐渐确切地理解我所说的这些。”<br>  “朱利安。我知道你讲得很好。但是自我控制对于一个体重97公斤重，在发展客户上花费的时间远远多于自我发展的时间的男人来说，无论如何都是过高的奢望啊。如果我失败了，会发生什么事？”<br>  “</strong>失败是不必费心去尝试的，没有什么大不了。横亘在人们和梦想之间的唯一事物就是对失败的恐惧，然而恐惧又是任何成功都不可缺少的。失败可以检验我们的毅力，让我们得到不断的成长。它给我们教训，并且引导我们走向启蒙的道路。东方的先哲曾经说过，每一支射中公牛眼睛的利箭，都是一百次失误的结果。这就是要求我们明白一个道理：从失去的机会中不断获益，不要害怕失败。失败是你的朋友。**”</p>\n<p>“让我拥抱失败吗？”我半信半疑地问。<br>  “<strong>宇宙青睐勇敢者。一旦当你下定决心要把自己的人生提高到最高的层次上，你灵魂的力量就会指引你方向。瑜伽师拉曼相信，每一个人的命运在他出生的那一刻就已经铺展开了。这条道路将一直通向一个盛满瑰丽宝藏的奇妙所在。每个人都能够培养起走上这条道路的勇气，这是人的天赋。他给我讲过一个故事，在此我想转述给你听。</strong>”<br>  <strong>以前，在古老的印度，有一个邪恶的巨人拥有一座可以远眺大海的辉煌城堡。在巨人去打仗的很多年里，附近村子里的孩子们常常跑到巨人美丽的花园里，非常快乐地玩耍。有一天，巨人回来了，把所有的小孩子都赶出了他的花园。“谁也不许再来！”他一边高喊，一边怒气冲冲地把橡木大门“砰”的一声关上。后来他围着花园建起了一道高大的大理石墙，把孩子们都挡在花园外面。<br>  寒冷的冬天到来了，这在印度是再自然不过的，而那个巨人盼望着温暖早早回来。不久，春天造访了巨人城堡下方的村子，但是冬天的寒冷魔爪依旧拒绝离开他的花园。有一天，巨人闻到了春天的芬芳，感到了太阳穿过窗子照耀进来的温暖。“春天终于回来了！”他大声喊着，跑到他的花园里去了。可是巨人没有想到映入眼帘的是那样一幅场景。村里的孩子们不知用了什么方法终于翻进了城堡，正在花园里高兴地玩儿。正是由于他们的到来，花园从冰封的冻土变成了富饶的土地，盛开着玫瑰、水仙和紫兰花。<br>  所有的孩子都开心地哈哈大笑，除了一个孩子以外。在眼角的余光里，巨人瞥见一个很小的小孩，他比其他孩子个子小得多。他因为没有力气翻过墙头进花园去玩，眼泪从脸上流下来。巨人为那个孩子感到难过，而且在他的一生中，他第一次为自己的恶行感到悔恨。“我要帮助这个孩子。”他说，向他跑过去。当其他的孩子看见巨人出来时，他们都感到害怕得要命，跑出了花园。但是那个个头很小的孩子还站在那儿。“我要杀死巨人，”他结结巴巴地说，“我要保卫我们的游乐场。”<br>  巨人走近小孩子，他张开双臂。“我是你的朋友，”他说，“我来帮助你翻过墙头到花园里去。现在它是你的花园了。”这个小孩子，现在成了孩子群中的英雄。他感到很高兴，把自己一直戴在脖子上的金项链送给了巨人。“这是我的幸运护身符，”他说，“我希望你来拥有它。”<br>  从那一天起，孩子们一直在巨人美丽的花园里玩耍。但是那个最受巨人宠爱的勇敢小孩子却再也没有回来过。时间一天天过去，巨人生病了，越来越虚弱。孩子们还继续在花园里面玩儿，可是巨人再也没有力气和他们作伴了。在那些安静的日子里，巨人最想念的就是那个小孩子。<br>  一天，在特别寒冷的冬季里，巨人从他的窗子里向外看了一眼，看到一个堪称奇迹的景象：尽管大部分花园都被白雪覆盖，在花园的正中却站立着一株漂亮的玫瑰花树，上面开满颜色各异的鲜花。就在玫瑰花树的旁边，站着巨人最喜爱的那个小孩子。小孩子笑得非常甜美。巨人快乐得手舞足蹈，冲出去拥抱了孩子。“这么多年你去哪儿了，我的小伙伴？我一直都在想念你。”<br>  孩子的回答却意味深长：“很多年以前你把我托过了墙头，让我进入你漂亮的花园。现在，我来带你去我的花园。”那天晚些时候，当孩子们再来看望巨人时，他们发现他已经躺在地上去世了，而他的身上从头到脚覆盖着上千朵美丽的玫瑰花。<br>  “只管让自己勇敢起来，约翰，就像那个小小的孩子。站稳你的脚跟，追随自己的梦想，它们会引领你找到自己的命运。跟随你的命运，它将带你领略宇宙的奇妙，带你进入一个满是玫瑰的神秘花园。”<br>  当我抬头看向朱利安，打算告诉他这个故事对我的触动有多么深时，我看到了极其震惊的场面：这个曾经把一生中最好的时光都花在追名逐利上的坚如磐石的律师，在这一刻竟然泪流满面</strong>。 </p>\n<h1 id=\"粉色带子，代表意志力\"><a href=\"#粉色带子，代表意志力\" class=\"headerlink\" title=\"粉色带子，代表意志力\"></a>粉色带子，代表意志力</h1><p>那条粉色的带子用来提醒你记起，在建构起一个更加丰富、幸福和开明的人生中自我控制和纪律所具有的作用。在我遇到的所有人当中，我的那些智者导师无疑是最健康、最安详、最有满足感的一群人。同时他们还是最有纪律性的人。智者教育我说，自律的美德就像那条遮在关键部位上的粉色带子。你有没有花时间研究过一条多股编织的粉色带子，约翰？<strong>”<br>“这个我似乎不太感兴趣。”我咧嘴一笑。<br>“好吧，</strong>有机会好好看上一看。你会发现上面连着很多细小的钢丝，彼此首尾相连。如果单独来看，每一根都很脆弱，不结实。但是一旦把它们合在一起，就要比单根线要结实得多，最后这股带子变得比钢绳铁索还坚韧。自我控制和意志力就与这个道理相类似。为了建起钢铁般的意志，最不可缺少的一个环节，就是坚持做微不足道的小事情，以此来培养自我约束的优良品质。持之以恒，一个小作为累积在另一些更小的作为之上，最终就能像核聚变一样，产生出充沛的内驱力。”<br>朱利安意味深长地看了看我，接着说：“也许有一句古老的非洲谚语最能说明这个道理：‘把蜘蛛网一股一股地连起来，就能捆住一头凶猛的狮子。’当你将自己的意志力释放出来，你就变成了自我世界的主人。当你不断练习古老的自我支配的技巧，就不再会有高得让你跨不过去的障碍，也不再会有难得让你无法克服的挑战，更不再会有紧张得让你无法平息的危机。自我约束会在人生最磕磕绊绊的时候向你提供心智中储备的无穷能力，保证你可以继续坚持下去，直到胜利。<strong>”<br>“</strong>我还必须告诉你一个事实，缺乏意志力将会导致各种不同的心理疾病。这是已经为医学界所证明了的。”朱利安突然又补充说。“如果你饱受意志力缺乏之苦，就要首先尽快改变这一现状。充沛的意志力和纪律性是坚强的性格和多彩人生的主要缔造者。在强大的意志力的支持下，你能够兑现你的诺言。你可以每天坚持在早晨五点钟起床，通过冥想来培养自己的心智。或是在寒冷冬季里的一天，尽管你很留恋被窝的温暖，但强大的意志力还是让你起床到树林中散步，借此滋养自己的精神。在受到别人无礼的指责时，强大的意志力让你保持冷静和沉默。面对突发事件，强大的意志力促使你能够连续克服难关，不断实现自己的梦想。简而言之，正是意志力源源不断地提供内在的激情与力量，让你信守对他人的承诺，而且更重要的是，信守对自己的承诺。</p>\n<p>意志力是一种优秀的品质，人生将因此而变得热情似火，变得宁静而致远。</p>\n<p>艰难时日里就是这段话帮助了我。我希望在你遇到苦难的时候，它也能让你的心灵得到慰藉。这段话说的是：<br>通过铁一般的纪律，你会铸造出勇敢而平和的性格；通过意志与美德的培养，你一定会达到人生最高的理想境界，你会生活在美好、快乐和生机盎然的天堂世界。如果没有这些，你就会像遗失了指南针的水手一样彷徨失路，最终与船只一起沉没。</p>\n<p>你是说，只要进行了正确的训练和适当的准备，我就能达到像圣雄甘地那样高超的意志力水平？”<br>“为什么非要像别人呢，约翰？<strong>其实每个人都是不一样的。瑜伽师拉曼教给我最基本的原则是，真正开悟了的人们绝不以与别人相似为荣。他们更乐意成为新型自我的开创者。不要跟别人赛跑，你要和自己赛跑。”朱利安回答说</strong>。<br>“**当你有了自我控制的能力时，你就会下决心去做你一直想做的事情。对你来说，可能是去参加马拉松长跑训练，掌握橡皮艇冲浪的技巧，甚至是放弃法律职业而成为一位艺术家。无论你的梦想是物质上的富足还是精神上的丰富，我都不会对你指手画脚。我只是想要告诉你，如果你能开启沉睡着的意志力，一切尽在你的掌握之中。”<br>朱利安补充说：“在你的生活中，进行自我控制以及加强纪律性还会带给你巨大的自由感。单单这一点就足以引发巨大的变化。</p>\n<p>“你的意思是？”<br>“<strong>大部分人都是自由的。他们可以去想去的地方，做他们喜欢做的事情。但是有更多的人仍旧是冲动的奴隶。他们消极被动，习惯于见招拆招，却并不具有前瞻性。打个比喻，这些人就像被浪花冲上海岸的泡沫，任凭海潮把它们推向任何方向。当他们正和家人在一起时，如果有同事打电话说有急事，他们就会立刻赶过去，从不停下来想想，到底哪件事情对他们的人生目标来说更重要。所以就我的观察经验来说，无论是在西方还是东方，这种人都拥有自由的权利，却没有享受到真正的自由。在他们身上缺乏一种至关紧要的元素：从看似紧急的情况中选择正确的事情的自由。</strong>” </p>\n<p>“培养意志力能够给我带来更多的自由吗？”<br><strong>“自由好比一所齐整的房子，你一砖一瓦把它垒起来。你要放上去的第一块砖就是意志力。这个品质可以激励你在任何情况下去做正确的事情。它给你提供精力和勇气，让你过上所期望的生活，而不是成为生活的奴隶。</strong>”<br>朱利安还列出了培养意志力能带来的其他很多实际好处。<br>“信不信由你，<strong>培养你的意志力量可以让你消除忧虑的习惯，让你保持健康，给你带来比以往多得多的精力。要知道，约翰，自我控制实际上就是心智控制。意志是心理力量的统帅。如果你掌握了心智，也就掌握了你的人生。对心智的控制源于你能够控制每一个出现在你头脑中的想法。如果你能够把所有软弱的念头都清理出去，仅仅注意那些积极美好的念头，那么积极美好的行为也将相继而来。这样你的人生中也会很快变得积极而美好</strong>。</p>\n<p>“这儿有一个例子。假设说你的个人发展目标之一是每天早晨六点半起床，然后围着你家后面的公园跑步。让我们假定现在正处于严寒当中，你的闹钟铃声把你从恬静的沉睡中唤醒。你的第一反应就是按下闹铃的按钮，然后接着呼呼大睡，心想明天再去真正实行你的锻炼计划。这种状况拖了好久好久，直到你觉得自己太老了，健身计划对你已经太不现实了，于是就放弃了你的计划。”<br>“你太了解我了。”我诚恳地说。<br>“现在让我们来考虑另一种情形。还是在严冬时节，早晨的时候突然铃声大作，你产生了继续待在床上的想法。为了不再成为习惯的奴隶，你开始用更加强大的意志力去战胜它们。你开始在头脑里想象，如果你的体形好到极致，那将是一种什么样子，会有什么感觉，会做什么事情。当你在办公室里信步走过的时候，你会听到同事们的大声恭维你匀称而良好的身材。你不断想象定期的锻炼计划能够让你达到的目标。你再也不会说出庭了一天之后就累得什么也不愿意做，最终只能在电视机前打发晚上的时间。你的生活中将充满了活力、热情和意义。”</p>\n<p>“但是假如我这样做了，还是想回去睡觉，不出去锻炼呢？”<br>“最初的几天当然会有一点困难，你更容易回到旧习惯中去。但是瑜伽师拉曼特别坚信一条古老的法则：积极总是能战胜消极。所以，如果你能够继续向那些多年来渐渐蚕食掉你的软弱思想作斗争，最终这些思想会像自知不受欢迎的访客一样灰溜溜地不告而别。”<br>“你是想要告诉我思想也是一种实际存在的东西？”<br>“是的，而且它完全在你的控制之中。思考积极的想法和消极的念头一样容易，然而效果大相径庭。”<br>“<strong>那么为什么还有那么多人在忧虑，在关注我们这个世界上的负面信息？</strong>”<br>“<strong>因为他们还没有学会自我控制的技巧，不会限制思考的方向。在我曾经交谈过的人群当中，有很多人都根本没有想过，自己竟然还有力量去掌控生活中每天、每分、每秒出现的每一个想法。他们相信思想不过是偶然发生的，却根本没有认识到，如果你不花时间去控制自己的想法，它们反过来就会控制你。这是一场控制与反控制的战争，可能很漫长，甚至会终其一生。如果你能够把注意力集中在美好的事物上，借助真正的意志力拒绝那些负面思想出现，我向你保证，它们很快就会卷铺盖离开了。</strong>”<br>“所以，如果我想要拥有内在的力量，能够早些起床，少吃饭、多读书，不忧虑、更热情，我要做的就是将意志的力量全部发挥出来净化我的思想。”<br>“<strong>当你控制了你的思想，你就控制了自己的心智。当你控制了自己的心智，你就控制了自己的人生。一旦你能够完全控制自己生活，你就成为了自己命运的主人。</strong>” </p>\n<h2 id=\"培养意志力的方案\"><a href=\"#培养意志力的方案\" class=\"headerlink\" title=\"培养意志力的方案\"></a>培养意志力的方案</h2><h3 id=\"重复一些简单的语句：真言-创造性想象\"><a href=\"#重复一些简单的语句：真言-创造性想象\" class=\"headerlink\" title=\"重复一些简单的语句：真言/创造性想象\"></a>重复一些简单的语句：真言/创造性想象</h3><p>尽管只有为数不多的喜马拉雅山上的智者知道这些真言，但是它们已经历经了五千余年时光的磨炼。瑜伽师拉曼告诉我，如果不断念诵它们，就可以在很短的时间内培养起自我控制能力和内在的意志力。记住，语言具有巨大的影响力和暗示效果，词语就是自身力量的文字体现。在你的头脑里装满充满希望的话语，你就会变得信心十足；在你的头脑里装上善良的话语；你就会变得善良而开朗；在你的头脑里装上勇敢的话语，你就会富有勇气。话语就是力量。<strong>”朱利安总结说。<br>“好吧，我洗耳恭听。”<br>“</strong>我建议你每天把这句真言至少重复三十遍：“我比外表看起来更强大，世界上所有的力量都在我的身体里。’它会在你的生活中带来持久的改变。要是想让这句话迅速起效，就把这句话和我前面告诉过你的创造性想象的练习结合起来。比如说，去找一个安静的地方。坐在那里闭上双眼，不要分散心神，保持身体静止不动，因为意志薄弱者最明显的一个特征就是身体闲不下来。然后大声重复这句真言，一遍又一遍地重复。在你做这些的时候，把自己看作是一个遵守纪律、意志坚定的人，能够完全控制自己的心智、身体和精神。在内心里想自己要像甘地和特蕾莎修女在面对艰难时刻的所作所为那样行事。随后产生的效果一定会让你大吃一惊的。”朱利安信誓旦旦地说**</p>\n<h2 id=\"两个方法\"><a href=\"#两个方法\" class=\"headerlink\" title=\"两个方法\"></a>两个方法</h2><h3 id=\"试着去做你不喜欢做的事情\"><a href=\"#试着去做你不喜欢做的事情\" class=\"headerlink\" title=\"试着去做你不喜欢做的事情\"></a>试着去做你不喜欢做的事情</h3><p>第一件事就是试着去做那些你不喜欢做的事情。对你来说，这些事情可能很简单，比如早晨起来叠被子，步行上班而不是驾车去。通过养成尽力而为的习惯，你会很快改变顺从软弱和冲动的毛病。**”<br>“不用则废？”<br>“完全正确。为了塑造意志力和内在力量，你首先要使用它。你越是努力培养内在约束的胚芽，就会让它成熟得越快，让你更快地看到你所希望的结果。” </p>\n<h3 id=\"沉默的誓约\"><a href=\"#沉默的誓约\" class=\"headerlink\" title=\"沉默的誓约\"></a>沉默的誓约</h3><p>实际上那种誓约就是这样的，约翰。那些推崇这一方法的西藏喇嘛相信，长时间的完全的噤声有助于提高一个人的内在自律性。<strong>”<br>“这是怎样做到的？”<br>“</strong>从原理上说，通过一天的沉默不语，你可以使你的意志完成你命令它做的事情。每当想要说话的念头出现，你就立刻抑制这个冲动，继续保持安静。你看，意志本身不会产生任何想法。它等待着接受你的引导，刺激它采取行动。你越能控制自己，意志的力量也就越强大。问题是大部分人根本就没有使用他们的意志力。<strong>”<br>“为什么会这样？”我问。<br>“</strong>也许是因为大部分人认为他们根本就没有意志力。他们为这种明显的软弱怨天尤人，却不从自己身上找原因。那些火暴脾气的人会对你说：‘我抑制不住呀，我的父亲也是这个样子。’那些过度焦虑的人会对你说：‘不是我的错，我的工作压力太大了。’那些整日酣睡的人会说：‘我能怎么样呢？我的身体需要每晚十个小时的睡眠。’这些缺乏自我负责能力的人从不知道，在我们每个人的体内都沉睡着不可思议的潜能，期待着受到鼓舞，然后转化为具体的行动。当你渐渐了解古老的自然法则，知道它们支配着宇宙的运转以及所有生活在其中的生命，你就会明白成为你想成为的人是你天赋的权利，你有能力改变你所处的环境。同样，你有能力摆脱过去时光的束缚，让自己得到前所未有的自由。为了达到这一目的，你必须成为意志的主人。</p>\n<h1 id=\"金秒表，代表时间\"><a href=\"#金秒表，代表时间\" class=\"headerlink\" title=\"金秒表，代表时间\"></a>金秒表，代表时间</h1><p>原来是一个缩微型的沙漏，用褐色的玻璃和一小块檀木底座制成。看到我略带惊讶的表情，迪维笑了笑，温和地告诉我，每一个智者在孩提时期都收到过一件同样的器具。‘尽管我们身无长物，过着纯粹、朴素的生活，但是我们尊崇时间，并且注意到它在一刻不停地流逝。这只小小的沙漏是对我们每个生命一刻不停走向死亡的提醒，提醒我们在向目标接近的过程中，过一种充实的生活和有所创造的日子是多么重要。因为，正如人不可能同时踏入第二条河流之中，人也不可能返回来，重新开始同一次生命的历程。’<strong>”<br>“那么，这些生活在喜马拉雅山上的高僧也重视时间吗？”<br>“他们中的每一个人都深知时间的重要性。</strong>他们每个人都培养起了我所说的‘时间意识’。你瞧我们已经明白地意识到，时间就像沙粒一样从我们的指缝中毫不留情地漏下去，不再复还。那些早年就能够明智地利用时间的人会收获一个丰富的、多产的、心满意足的人生。而与此相反，那些从来没有感受到‘掌握时间就是掌握生命’这一原则的人，永远也不会发现他们本性中其实曾经拥有着巨大的潜能。时间是最伟大的神，也是最公平的分配者。无论我们是特权者还是贫苦阶层，无论是生活在得克萨斯还是生活在东京，我们都被分配到一天二十四小时的时间，谁也不多一秒钟，谁也不少一秒钟。而最终真正能把创建了杰出人生的大人物和随波逐流的庸才区分开的，恰恰是他们对时间的不同使用方式，简而言之，就是不同的时间观念。<strong>”<br>“但是我曾经听我父亲说过，正是最忙碌的人才最有空闲。你对此怎么评价？”<br>“我赞同。忙碌的、能干的人总是能够高效地使用他们的时间——他们必须要生存下去。但是，成为一名最优异的时间安排者，却并不意味着必须把自己变成一个彻头彻尾的工作狂。相反，有效的时间控制能够让你有更多的空闲去做自己喜欢的，真正有意义的事情。控制好时间才能控制好人生，所以要好好守护时间。记住，这是不可再生的资源。”<br>“那我现在就给我的表上好发条。”我们一起笑了起来。<br>“让我再给你举一个例子吧，”朱利安提出建议，“</strong>让我们假设这是星期一的早晨，你的时间表上排满了约见、会议和庭审出席的日程。往常，你会在早晨六点半就起床，一口吞下一杯速溶咖啡，飞奔着赶去工作，然后昏天黑地地度过了非常紧迫的一天。好，接下来让我们假设有一次，你在星期天的晚上抽出了十五分钟的时间来计划自己的安排。或者说为了更加高效，让我们假设你在平静的周日上午抽出了一个小时来安排整个一周的生活。在你的每日计划表中，你标出什么时候会见客户，什么时候你要做法律研究，还有什么时候你要回一些重要的电话。最重要的是，在一个星期之内，你把在个人、社会和精神方面的发展目标也都列入了你的记事本。这个简单的举动是保持生活节奏平衡的奥秘。通过在每天的日程表上锁定生活中所有最至关重要的方面，你可以确保这一个星期的生活过得充实又有条不紊。<strong>”<br>“你是不是建议我从每天繁忙的工作中抽出一点时间来休息，然后去公园里散步或者躲到一个地方沉思冥想？”<br>“是的。你为什么非要那么严格地遵守惯例呢？你为什么一定要像其他人一样用同样的方式行事呢？</strong>走你自己的路好了，不要在乎别人怎么看，关键是要让自己觉得舒服自然。你为什么不提前一个小时开始工作，这样就可以有足够的闲暇在中午的时候放下手头的工作，到办公室附近的美丽公园里平心静气地散步。还有，为什么不在一周刚刚开始的时候就向工作里投入更多的时间与精力，这样就可以在周五下班之前早早收尾，然后快快乐乐地带上孩子去动物园玩一会儿。还有，为什么不在一个星期内抽出两天的时间在家里工作，这样就可以更多地照顾家庭。我说的所有这些都是为了让你更有创造性地作出一周的计划，合理地安排时间，当然并不是非如此不可。一定要把时间列在你首要关注的核心位置上，它会让你明白，人生中最有意义的事情决不应该为了最不重要的事情而作出无谓的牺牲。**” </p>\n<p>忙碌并不是借口。真正的问题是，你要随时问自己，你究竟在忙些什么？我从那些年老的智者那里学会了一条伟大的法则：你在一生中获得的80％的成果，常常来自于你仅仅花了20％的时间来完成的事情。瑜伽师拉曼把它叫作‘古老的二八法则’。</p>\n<p>你的意思是指，那些‘高效能’的时间就是指我花在提高自己法律知识上的时间，和我的客户一起丰富人际关系的时间，还有为了成为更能干的律师而投入的时间？”<br>“是的，还有你为了培养亲情而和詹妮以及孩子们一起度过的那些时间。” 朱利安的回答相当肯定，然后他又做了一个补充：“还有花在自然中的时间，这是你对自己有幸拥有的一切而表示感恩的时间，也是用来更新你的心智、身体和精神空间的时间。以上这些都是‘高效能’的行为，帮助你得以从容规划出一个值得度过的人生。当然，有一些无效的时间付出是你没有办法避免的。我的意思是说，设法将自己的时间尽量多地投入在这些有意义的行为上。古希腊的哲人早就说过：‘已经得到启蒙的人最先获得生命的动力。’这就是控制时间的秘诀。</p>\n<p>那么就尽量学着去简化你的生活吧，”朱利安同情地建议我，“把减法应用在生活的每个方面。这样做以后，你就可以有时间去欣赏美好的、奇妙的事物。最难过的事情是我们任何一个人都不能为了领略到更多的美好而把自己的生命向后推延。我常常会有一种时不我待的悲伤。然而，有太多的人梦想在遥远的将来能看到神奇的玫瑰，却不去看一眼长在自家后院里的花朵。这真是一个莫大的悲剧。</p>\n<h2 id=\"把时间花在精肉部位\"><a href=\"#把时间花在精肉部位\" class=\"headerlink\" title=\"把时间花在精肉部位\"></a>把时间花在精肉部位</h2><p>生活就像一长条熏猪肉，”我插话说，“为了有效掌握你的时间，就必须把肥的、瘦的细细地区分开来。” </p>\n<p>“说得好极了，约翰，你真讲到点子上了。尽管我的素食主义立场告诉我不应该选取这样一个禁忌性的话题，不过说老实话，我还是很喜欢这个比喻。<strong>尽管有些粗俗，但你的确一语道破了机关。当你把时间和珍贵的心智精力投入到精肉部位以后，就没有时间在肥肉问题上浪费那些无谓的时间了。这就是你的生活从平庸变为非凡的关键。</strong></p>\n<h2 id=\"要学会说‘不’\"><a href=\"#要学会说‘不’\" class=\"headerlink\" title=\"要学会说‘不’\"></a>要学会说‘不’</h2><p>你的话让我想到另外一个问题。别让他人窃取你的时间，要警惕无处不在的时间窃贼。<strong>在你哄孩子睡觉，或者刚刚在心爱的椅子上坐下开始读一本你早已如雷贯耳的惊悚类小说时，总是有些人会在这个时候打来电话，然后天南海北地和你胡侃一通，然而他们不知所云的所谓高见早已将你的兴致破坏得面目全非。他们这类人专门会在某个特定时刻敲开你的办公室，然后赖在那里高谈阔论。而那时你好不容易才从疯狂忙碌的一天中抽出几分钟来，想一个人静静地待一会儿，喘上一口气，清理一下思路。这些情形听起来还熟悉吗？”<br>“太常见了，朱利安，你说的一点也不错。我相信，以前你受到的骚扰比我更甚，因为你比我更有名气。不过，这些人似乎总是很难拒绝的，我感觉如果直接请他们离开或者紧闭房门是不礼貌的。”我向朱利安说出自己的心事。<br>“</strong>你必须学会不留情面，才能真正履行自己的时间规划。要学会说‘不’，要有勇气对生活中的琐事断然说‘不’，只有这样，你才会有力量对那些重要的大事说‘好吧’。当你需要花费几个小时来专攻一个大案件的时候，当然要关紧办公室的门，连秘书都是非请莫入。记着我告诉你的话，不要每次电话一响你就去接听。这要看你是否方便，而不是看其他人的方便。要将主动权牢牢掌握在自己的手中。很讽刺的是，当他们发现你是一个惜时如金的人时，不但不会非议你的‘无礼’，相反会对你更加尊敬。他们会觉得你的时间很宝贵，因此就会重视你的时间安排，也不会无端地打扰你，从而还你一份清静。**” </p>\n<h2 id=\"拖延时间又该怎么解决？\"><a href=\"#拖延时间又该怎么解决？\" class=\"headerlink\" title=\"拖延时间又该怎么解决？\"></a>拖延时间又该怎么解决？</h2><p>我总是把不喜欢做的事情不断地、不断地向后推延，要到非做不可的地步才怏怏地动手。可是另一方面我又把大量的时间花在浏览垃圾信件、翻阅成堆的过期法律杂志上。也许我这样做只是为了消磨时间？”<br>“消磨时间只是一种说法。实际上，<strong>人的本性是趋利避害的。你不喜欢做一些事情，因此你的天性就会传达一种负面的情绪。但你同时又知道，这些事情如果不及时处理，那结果就会更糟糕，这个时候现实理性又会逼迫你及早动手。于是痛苦就产生了。但是就像我早先说过的，这个世界上最能干高产的人具有做好任何事情的习惯，哪怕这些事情可能是他们不喜欢做的，而不能干的人却养成了不做事的习惯。</strong>”<br>我不再答话，开始深刻反思刚才听到的话。<strong>也许拖延并不是我个人的问题，或许只是因为我的生活变得太复杂了，而朱利安一下子就抓住了我的关键。 </strong></p>\n<p>“<strong>瑜伽师拉曼告诉我说，那些掌握了时间的人生活会更加简单。匆忙、狂热的节奏并不是人类本性的趋向。他坚信并一直向我重申，只有那些做事高效并为自己设有明确目标的人才能得到永恒的幸福。这就是我所学到的智慧中最令人着迷的地方。它使我的工作优质而高产，同时又能够完全满足精神上的渴望。在某些时候，工作反倒成为了游戏。</strong>” </p>\n<h2 id=\"打一个小盹儿\"><a href=\"#打一个小盹儿\" class=\"headerlink\" title=\"打一个小盹儿\"></a>打一个小盹儿</h2><p>我喜欢在下午的时候打一个小盹儿。我感到这能使我保持活力充沛，更新精力，有蓬勃的朝气。我想可以这么说，我需要美容觉。</p>\n<h2 id=\"临终心态\"><a href=\"#临终心态\" class=\"headerlink\" title=\"临终心态\"></a>临终心态</h2><p>迪维在送给我这个小沙漏时还给了我几条忠告，我永远也不会忘记。”<br>“她说了什么？”<br>“<strong>她告诉我，种树的最佳时间是四十年前，其次就是今天。不要浪费生命里的任何一分钟。要有一种临终心态。</strong>”<br>“你再说一遍？”我问他，朱利安采用的生动词语使我惊呆了。<br>“什么叫临终心态？”<br>“<strong>这是东方哲学中的一种生命观，也可以称其为‘向死而生’。这是你看待人生的新角度。它会提醒你，也许今天就是生命的最后一日，所以好好享用吧。</strong>”<br>“哈，如果你想知道我的真实感觉，朱利安，那我就老老实实地告诉你，这个话题我觉得很可怕啊，它让我想到了死亡。”<br>“*<em>确实如此，这就是生命的哲理。当你抱着这种临终心态，你会把生命中的每一天都当成最后一天。想象一下，每天早晨醒来以后，问自己一个简单的问题：“如果今天是我生命的最后一日，我将会做些什么？’接下来，考虑你将如何对待自己的家庭、同事，乃至你根本不认识的人们。想一想你将多么能干，多么振奋，在你手中，每一时刻的价值都实现了最大化。单单是这个临终问题就拥有改变人生的力量。它会让你每天都活力充沛，在做每件事时都带着丰富的热情和开朗的精神。你会开始注意那些一度被你不断拖延的、意义深远的事情，而不会在那些把你拖入危机和深渊之中的琐屑小事上无谓地浪费时间。”<br>朱利安继续说：“鞭策自己去做更多的事，体验到更多的新鲜事物，促使你把精力用在扩展自己的梦想上。对，扩展你的梦想。不要安于碌碌无为的人生。既然你在心智的源泉中拥有如此无限的潜力，就要敢于让‘伟大’这个词和自己的生命联系起来。这是你的天赋权利。</em></p>\n<h2 id=\"表现得好像你不可能失败\"><a href=\"#表现得好像你不可能失败\" class=\"headerlink\" title=\"表现得好像你不可能失败\"></a>表现得好像你不可能失败</h2><p>有一个简单的方法，可以为很多人消除意志消沉的苦恼，这种苦恼的确会让人感到非常难受<strong>。”<br>“我的杯子正空着呢。”我虚心地说。<br>“</strong>表现得好像你不可能失败，这样你的成功就有保证了。把所有觉得不能达到目标的想法都从头脑中清除出去，无论是物质方面的，还是精神方面的。勇敢点，不要给自己的想象设限。不要成为过去记忆的奴隶，而是要做未来的设计师。从此，你就不再是从前的自己了。</p>\n<h2 id=\"奉献是人生的终极目标\"><a href=\"#奉献是人生的终极目标\" class=\"headerlink\" title=\"奉献是人生的终极目标\"></a>奉献是人生的终极目标</h2><p>在印度有一句古老的谚语：‘我们不是有着精神体验的生命存在，而是有着生命经验的精神存在。’通过长时间的修行和游历，我想现在可以说，我真正理解了自己在宇宙中的角色。我终于在自我的镜像之中看到了我是谁。我不再处于世界当中，世界在我的心中。那种体验是什么样的呢？我也描绘不出来。这样吧，我给你诵念东方哲人的两句诗：君掌盛无边，刹那含永劫。<strong>”<br>“我觉得我必须好好考虑一会儿你刚才说的那句话，尤其是最后那两句诗。你知道，我在大学里最害怕文学与语法修辞类的考试。”我老老实实地说，因为我真的不太理解朱利安说的话。<br>“当然。我理解，我的朋友，总有一天你会理解我所说的一切。如果你能够按照我告诉你的方法去做，认真练习我向你提供的诸多技巧，你就一定会在启蒙的道路上不断前进。你将慢慢掌握支配自我的技巧，而且你也将发现自己生命的意义到底是什么：那不过是永恒图景上的一点微光。而且你也将逐渐明白你究竟是谁，知道人生中的终极目标是什么。”<br>“</strong>那目标是什么呢？”我越来越有好奇心了。<br>“当然是奉献。无论你的房子有多么大，或者你开的汽车有多么炫目，但是你在生命结束的时候都不能将它们带入坟墓，唯一相伴的只有自己的良心。所以，你要时刻侧耳倾听自己良心的声音，让良知引导你。它知道什么是对的，它会告诉你，你的使命就是无私地帮助他人。这就是我的人生漫游经历带给我的最大的收获。眼下，我有非常多的人要去会面，为他们服务、治疗。我的使命就是把智者的古老智慧传播给所有需要学习它的人们。这就是我的目的。**” </p>\n<h1 id=\"玫瑰花，代表无私地帮助别人\"><a href=\"#玫瑰花，代表无私地帮助别人\" class=\"headerlink\" title=\"玫瑰花，代表无私地帮助别人\"></a>玫瑰花，代表无私地帮助别人</h1><p>我和你分享的品质中最不可缺少的一条，约翰，就是这个：无论你取得怎样的成就，无论你拥有了多少套夏季别墅，无论你家的车道上泊着几辆高档小汽车，你的人生质量还是要归结到你所作出的贡献的质量上来。<strong>”<br>“这是不是和瑜伽师拉曼的寓言里那些鲜艳的黄玫瑰多少有点关系？”<br>“当然有关系。</strong>这些花会提醒你想起一句古老的中国谚语：送人玫瑰，手留余香。这句谚语的意思很清楚——当你致力于提高别人的生活时，在这个过程中你也间接地提高了自己的人生品质。如果你每天都有意地随时随地做出一些善举，你自己的人生也将因此而变得更加丰富，更加有意义。为了培养日常生活中的神圣感和尊严感，从现在开始就用各种方式帮助他人吧。<strong>”<br>“你是不是在建议我多去参加一些志愿者活动？”<br>“嗯，</strong>应该说那是一个良好的开端。但是我所说的比参加志愿者活动这个具体的事件具有更多的哲学性。我是在建议你，你要对自己在这个星球上要扮演的角色采取一种新的理解‘范式’。<strong>”<br>“你又把我搞糊涂了。拜托你把‘范式’解释得清楚一点，我实在不熟悉这个词。”我请求道。<br>“</strong>简单来说，范式就是人们通常看待生活境况和生命过程的一种方式。有些悲观主义的人把人生看成一只半空的杯子，而乐观主义者则视之为半满的杯子。你看，‘半空’与‘半满’，对于同一种存在的境况竟然有不同的解释，这就是因为观察者采用的范式不一样。范式从根本上说就是一面透镜，你要通过它来观察人生历程中各种事件，无论是对外在世界还是内在世界。<strong>”<br>“因此当你建议我采用一种新的范式来看我的人生意义，是不是说我应该换一种眼光？”<br>“</strong>在一定程度上是这样的。为了显著提高你的生活品质，你必须针对自己为什么会在地球的这一处地方生活而不是那一处地方生活找出一个原因。你必须认识到，正如你两手空空来到这个世上一样，你注定是要两手空空地离开的。在这种情况下，只有一个真正的原因说明你身在此地的存在价值。<strong>”<br>“那会是什么？”<br>“</strong>把自己无私地奉献给他人，通过有意义的工作方式来作出应有的贡献。<strong>”朱利安回答说。<br>“我并不是说你不能享受你的生活，或者说你必须放弃自己的法律事业，然后有意让自己的生活变得穷困潦倒，好像只有这样才能全身心地投入到无私服务社会的行动中去——虽然我最近常常见到一大批散尽家财、投身慈善事业的人，而且看上去他们个个都心满意足——你要明白，我们的世界目前正处于大变革当中。”<br>“大变革？”我有些迷惑不解了。<br>“</strong>是的，大变革。对比一下过去30年和今天的生活，你就会发现人们对于意义与价值的理解发生了翻天覆地的变化，人们开始用钱换取人生意义。比如过去的律师只会按照委托人钱包的尺寸来做出是与否的判断，而现在则不同了，真正的律师会按照人们对他人的责任大小和爱心的大小来作出自己的判断。教师们辞去稳定又保险的大学工作，为生活在城乡结合部的贫困孩子无偿提供义务素质教育。在这个大变革的时代里，有良知的人们已经听到了呼唤价值改变的铃声，人们已经重新认识到自己生存的目的。这一目的无法用金钱和社会地位来衡量，而且他们已经得到了帮助自己去实现这个目的的特殊天赋。<strong>”<br>“究竟是什么特殊天赋？”<br>“</strong>确切地说，就是我花了整整一个晚上来告诉你的那些因素：丰富的心智，无穷的精力，无限的创造力，坚强的意志力和内心的安宁。而现在你要做的就是勇敢地开启这些宝藏，在日常生活为了公众的利益而使用它们**。</p>\n<h2 id=\"摆脱自我的枷锁\"><a href=\"#摆脱自我的枷锁\" class=\"headerlink\" title=\"摆脱自我的枷锁\"></a>摆脱自我的枷锁</h2><p>那么<strong>怎样才可以开始做好事呢？</strong>”<br>“<strong>做好事不分时间先后、事情大小，你可以随时随地将自己的爱心传递给别人。再稍微抽象一些，那我的回答也很简单，就是把‘做好事’这种理念放在改变自己人生观、世界观的首要位置上，这样你就可以不再把自己看成是一个简单的个体，而会开始把自己看作是集体洪流中生动鲜活的一分子。</strong>”<br>“那么我是不是得变得再善良点儿，再温柔点儿？”<br>“要知道，你能做的最崇高的事情就是给予。”朱利安双手伸向空中。<br>“<strong>东方的智者将这个过程叫作‘摆脱自我的枷锁’，就是要你丢掉自我意识，开始关注更高的目标。也许这在某种程度上意味着你要向周围的人付出更多的时间和精力，尽管它们是你最有价值的两种资源。</strong>”<br>“资源？”我有些不解地问。<br>“对，是资源，”朱利安再次露出耐心的微笑，“如果按照最高标准来要求的话，可能是你抽出一年当中休假的时间，毫无报偿地为街区里的穷人做义工；如果按照最低标准来要求的话，可能是在交通极端堵塞的时刻，不再骂骂咧咧，不再抢着见缝插针，而是摆一摆手，让车流中别的车子先开走。”<br>“哦，听起来像个交通警察在给我上课，朱利安。”我想起下班路上一到塞车时候就灌满满街道的喇叭疯响，不由得有些烦躁。<br>“哈，朋友，安静点。<strong>听起来是有些老生常谈，但是在我所有领会到的道理中有一条非常重要——只有当你开始努力让世界变得更加美好，你的生活才会因此向更好的方向上推进。我崇敬的智者瑜伽师拉曼说过：在我们出生的时候，世界一片欢腾而我们哇哇大哭；如果我们一生的时间都在帮助别人，在为世界变得更美好的工作中度过了一生，那么等到我们死去的时候，世界在哭泣，而我们却很欢喜。</strong>” </p>\n<h2 id=\"每天做好事\"><a href=\"#每天做好事\" class=\"headerlink\" title=\"每天做好事\"></a>每天做好事</h2><p>他们不过是需要有一点良知的火花来点亮同情的蜡烛。丰富的同情心和日常的善行会使你的人生更加丰富。每天早上在鸟鸣中醒来时，先别忙着起床，躺在温暖的枕头上抽出一点时间来考虑一下，在这即将开始的一天当中，你将为别人做哪些好事。你可以赞美那些对自己失去了信心的人，赞美那些最不指望得到赞美的人，给陷入困境的朋友送去温暖，还可以向家里的亲人们表示自己的感激和爱意。所有这些加起来，不就构成了更加美好的生活吗？而说到了友谊，你一定要不断维护它。一个拥有三个铁哥们儿的人其实是非常富有的。</p>\n<p>我得承认，我的内心已经完全被朱利安的话征服了，不过我还是故作轻松地和他打趣：“在中国话里这就叫作‘一个好汉三个帮’对吗？”<br>朱利安对我竟然知道一句中国的谚语表示惊奇，不过他还是点点头赞许了我。“是啊，朋友给生活中增添了欢乐、兴趣和美丽。没有什么比和一个老朋友在一起开怀大笑更能让人恢复青春活力了。当你在工作上有了点成就，就开始狂妄自大，太拿自己当回事的时候，朋友的良言会帮助你保持谦卑。当生活给你带来了小小的挫折，你以为世界末日就要到来时，好朋友会一如既往地守在那里给你帮助。就以我为例吧，当我还是一名忙忙碌碌的律师的时候，我几乎没有时间交朋友，当然那些生意上的伙伴不算。在经过了长期与世隔绝的生活之后，在这个世俗的社会里，我是彻彻底底的孤家寡人了——除了你以外，约翰。我找不到一个人来陪伴自己去森林里远足，因为他们每个人都舒舒服服地待在温柔醉人的睡眠安乐窝里。当我读完了一本非常精彩的、深深地打动了我的书以后，却找不到人可以与我一起分享，我甚至连一个可以一起争辩讨论的朋友都没有。当金秋的阳光温暖了我的心扉，让我满怀欣喜的时候，我找不到一个值得信任的朋友可以敞开灵魂去倾诉。”<br>朱利安很快控制住了自己的情绪，也许他很快便想起了住在喜马拉雅山顶的那些智者。他们不仅是他的老师，也是他的朋友，甚至从某种意义上说已经成为他的家人了。<br>“不过，我没有时间让自己深陷于遗憾情绪的负面影响。<strong>我的智者导师们一直在教育我说：“对于开悟的人来说，每个黎明都将是崭新的一天。</strong>’” </p>\n<h1 id=\"钻石，代表活在当下\"><a href=\"#钻石，代表活在当下\" class=\"headerlink\" title=\"钻石，代表活在当下\"></a>钻石，代表活在当下</h1><p>我基本上同意你的观点。我们确实应当对那些能够激发兴趣的目标表示出孜孜以求的积极态度，因为这是确保个人成就感的根源。但是还不止与此，你要记住，幸福是一场旅行，不是目的地。因此，你要时刻提醒自己，要为了今天的生活质量而活着——再也不会有另外一天会和今天一样了。”朱利安说，双手安详地交叠在一起。 **<br> “在瑜伽师拉曼的寓言里，这个道理的象征物就是那条铺满钻石的小路吧？”我问他。 </p>\n<p> “是的，”朱利安的回答简洁而明快，“<strong>那位高大的相扑选手走在钻石小路上，最终获得永恒的满足感和欢乐。就像他一样，只要你明白你当前所走的道路也铺满了钻石和其他诸多无价珍宝，那么你也能够拥有你想要获得的生活。不要再把时间过多地花在纵情享乐之中，因为人生更多地是由那些微小的快乐组成。尽管你常常忽视它们的存在，但正是它们在浸润着你的内心世界，让你变得善良而乐观，无私而勇敢。我的朋友，好好地享受围绕在你身边的美丽和圣洁吧，这些神奇之物全靠你自己去发现。</strong>”<br> “你的意思是不是说我应该先停下来，不再给未来的人生设置远大目标，而是要把注意力转移到当前的生活中来？”<br> “当然不是这个意思，”朱利安斩钉截铁地回答，“<strong>正如我在前面和你说过的那样，面向未来的目标和梦想非常重要，这在每一个真正成功的人生当中都是不可缺少的。正是因为怀有对未来事物的热望，才让你每天早晨坚持从热被窝中迅速爬起来，并且在一天的工作中保持着饱满的精神和注意力。树立人生的目标，就意味着给你的生活加油。我的意思只是说，不要为了成就就放弃快乐。不要把那些可以带给你幸福感和满足感的事情推迟到以后再去做。今天，就是今天就要活得畅快淋漓，而不是苦苦等到赢了体育彩票或者终于熬到退休以后。千万不要把生活中的幸福向后推迟，因为再晚可能就没有机会了。</strong>”<br> 朱利安站了起来，开始在起居室里来来回回地踱步。这时候他似乎又恢复了大律师的样子，在即将结束一场热情洋溢的辩论时作最后陈词。 “不要再自欺欺人，以为只要你为律师事务所再多雇用几个初出茅庐的律师来减轻工作负担，你就会马上变成一个更爱你的妻子，肯为家庭付出的好丈夫。”他的最后陈词和以往一样精彩，我看着此时的朱利安，竟然有些恍惚，觉得他从来都没有离开似的。但是他坚定的声音把我再次拉回眼前。<br> “<strong>不要自欺欺人，以为只要银行户头上有了足够大的数目，自己就自然会有更多的自由时间，可以为所欲为，放肆起来。不要试图让自己想象，只要有了钱有了闲，你就会开始丰富自己的心智，开始关心自己的身体，开始滋养自己的灵魂。这些都是自欺欺人，我们都很明白这一点。今天，就是今天，是你享受多年来努力成果的时候。今天就是抓住眼前一刻，度过充实人生的时候。今天就是抛开忧虑的想象，让心中的梦想跃然成真的时候。而且，在你为自己创造幸福的时候，请你千万、千万不要忘记家庭给予你的丰厚馈赠。</strong>” </p>\n<p>“我不敢肯定自己完全理解你的意思了，朱利安。”我没有跟上他的语言跳跃。<br> “<strong>和自己孩子一起经历童年。</strong>”非常简单的回答背后似乎隐藏了什么。<br> “嗯哼？”我小声咕哝了一句，在这句似是而非的话面前仍然摸不着头脑。<br> “<strong>在人的一生中，几乎没有什么事能比你和孩子们一起分享童年更有意义了。如果你在第一个阶段里就忘了和孩子相伴，又怎么可能走向此后的幸福呢？然而，要是你根本没有时间没有能力来创造一个家庭，那么就算你拥有了整个街区当中最大的房子又有什么好处呢？如果你的孩子们根本就不知道给他们生命的父亲是谁，那么就算你名满全国，当上了炙手可热的第一辩护律师又有什么用处呢？我知道我说的是什么。</strong><br> ”朱利安用我们的职业举例子，我感到他的声音因为激动而微微有些发颤。 朱利安的最后一句话使我感到困惑。我所了解的朱利安是一个超级明星律师，每天周旋在珠光宝气和灯红酒绿之中。他和红极一时的时装模特在豪华酒店里的浪漫约会，和他在法庭上滔滔不绝的辩论技术一样广为人知。这个做了多年花花公子的百万富翁怎么可能知道如何做好一位父亲？他又怎么可能知道我每天都要面对的挣扎，想要做好每一个角色要求的每一件事，在家里我得是一个了不起的父亲，出门以后我得是一个成功的大律师？所有这些琐碎的烦恼，朱利安怎么可能知道？我虽然这样想着，却尽量掩饰自己的怀疑，但是敏感的朱利安还是凭着直觉发现了我的想法。<br> “也许你不知道，我确实了解一些关于孩子的事情。”他温和地说，渐渐从刚才的律师状态恢复了他智者的模样。<br> “不过，说句实话，我还一直以为你没有孩子，是现代城市里人见人爱的钻石王老五，至少在你认输辞职之前，我们一直这样认为。你知道的，有多少女实习生为了进入你的办公室大耍花样？有多少……”<br> “稍等，稍等，”朱利安竖起手掌做了个暂停的手势。<br> “老朋友，你对我的了解从12小时前才开始，对不对？”<br> 我看了看他，朱利安脸上的确没有矫揉造作的羞涩。有一种人，无论男女，一听到自己很受异性的欢迎就故意加以否认，但是脸上得意的神态完全暴露出内心的浅薄。朱利安脸上仍然是一潭秋水般的平静。<br> 他继续说道：“人们都知道我过着一种节奏快、心情飘的生活方式，同事们以为我那样的人生应该很过瘾吧。我也曾经这样认为，直到我明白那只不过是自欺欺人的幻象。<br> ”这时竟然有一丝苦笑出现在他平和的脸上，“你知道我是结过婚的。”<br> “是的。”我清了清喉咙。 然后，朱利安在开口前顿了一下，很像一个孩子正准备向最好的朋友吐露内心中隐藏最深的秘密。<br> “但是，你不知道的是我曾经有一个小女儿。她是我最心爱的宝贝，是我一生中见过的最精致最可爱的小精灵。那个时候，我很像我们第一次见面时候的你，自高自大，野心勃勃，而且满怀着希望。我似乎很幸运，拥有世界上每个人想要得到的一切。所有认识我的人都纷纷夸我前程远大，羡慕我有一个美艳惊人的妻子和可爱极了的女儿。然而，当生活看起来非常完美的时候，幸福马上就又离我远去了。”<br> 这是第一次，从朱利安踏入我的家门以后，忧伤第一次完全吞没了他欢乐的神色。一滴眼泪从他晒黑的脸颊上滑落，落在他天鹅绒般柔软的宝石红长袍上。我张口结舌，不知怎样安慰，因为我已经完全被老朋友的真情流露惊呆了。<br> “你不必继续讲下去，朱利安。”我同情地建议说，把一只胳膊搭在他的肩膀上去，希望能够安慰他。<br> “不，我要说，约翰，请听我说吧。在我过去认识的所有人当中，你是最信守承诺的，也是我最信任的。正如我所说过的那样，你常常让我回想起我自己年轻的时候。说真的，即使是现在，你的身上还有很多东西吸引着我。但是我知道一定要告诉你，用我自己的教训来告诉你，如果你继续按照现行的生活方式去生活，总有一天你明白其实这样是在自找苦吃。我来到这里就是为了向你表明，世上有那么多奇迹等待着你去探索，还有那么多美好的时刻等待着你去品味。<br> “那个夺去我女儿生命的喝醉酒的司机，在太阳都为之哭泣的10月的一个下午，不仅仅夺去了一条珍贵的生命——而是两条。自从我的女儿意外去世后，我的生活也打了死结。我开始在办公室里度过每一分钟清醒的时间，愚蠢地希望我的法律事业能够成为破碎心灵中的痛苦的替代品。有些日子，我甚至就睡在办公室里的长沙发上，因为我害怕回到家去，害怕回到那个还残留着那么多甜蜜回忆的家。我的妻子，从我读法学院的时候就一直陪伴着我的伴侣，后来也离开了。她说我的心里只有工作，这简直是压倒我的最后一根稻草。在痛苦、逃避、更痛苦的恶性循环中，我的健康越发糟糕，名声也变得不可收拾，我眼看自己一天天陷入声名狼藉的生活。那就是我们初次见面时我的生活状态，你眼中的同情向我证明我的回忆是准确的。的确，金钱可以买来的东西我一样也不缺，但那是我出卖了灵魂以后换回来的，我真的这样做了，交出我的灵魂。”朱利安激动地说着，声音仍然是哽咽的。<br> “所以你对我说‘和孩子一起分享童年的时光’，其实是让我每天都抽出时间观察他们的成长和发展变化。是这样，对不对？<br> ”我怎么能够不同情面前这个痛苦的朋友呢。 “当时我们开车送她去参加她最好的朋友的生日聚会。即使到今天，她离开我已经二十七年了，但是只要能够再次听到女儿的咯咯笑声，只要能够再和她一起玩儿捉迷藏的游戏，就像我们俩经常在我家后院里玩的那样，我愿意付出一切代价！”朱利安捂住了脸，大口喘息着。<br> “是的，我明白，我明白。”我不知怎样安慰他。<br> “<strong>我最喜欢把她抱在怀里，温柔地梳理她的金色卷发。她离开以后，把我的心也带走了。尽管我在喜马拉雅山上找到了开启心智和自我掌控的方法，我的人生因为找到了新的意义而重新振作起来，但是在我度过的所有日子中，没有一天不在头脑的静默回忆中看到我可爱的小女儿的粉红小脸。你也有这么好的孩子，约翰。不要为了几棵树木而失去了整片森林。你能够给予孩子们的最好馈赠就是你的爱和关心。像第一天见到他们那样去重新认识他们。一定要让他们明白，他们对于你来说，要比职场事业中过眼云烟般的名利回报重要得多。不久之后他们就会长大，就会一个个离你而去，去建立自己的家庭和生活，去建立自己人生中的失落和幸福。到那时候你再表白你对他们的珍惜就太迟了，时间一去不复返。</strong>”<br> 毫无疑问，朱利安拨动了我心底最深处的那根弦。我猜我在有些时候已经隐隐约约察觉到了，我的工作狂心态正在慢慢地瓦解着我和家庭的联系。这种瓦解就像是余烟缭绕的火苗，静静地燃烧，缓慢地积攒力量，直到有一天向四面八方爆发出毁灭性的能量。我知道孩子们需要我，我也知道内心中我多么眷恋他们，尽管我们谁都没有对彼此说过这样的话。我需要朱利安的提醒。时间飞逝，孩子们长大得太快了。我已经记不起来，我和儿子安迪最后一次在清新的周日早晨，偷偷地跑到他的祖父最喜欢的钓鱼池边度过一天的确切时候了。曾经有一段时间我们一起快乐地度过每个周末。而现在，这个由来已久的习惯简直就像是别人回忆中的故事了。 我越想越感到内心沉重。安迪在学校里的钢琴独奏会，圣诞节的化妆演出，还有他的少年棒球联赛，我一个都没参加，都被我用来换取事业上晋职升迁了。那么安迪的心中会怎么想呢？天哪，他千万不要以为我把工作看的比他更重要啊！<br> “我都做了些什么啊？”我抱着头苦苦思索。我的确已经身不由己地滑到了朱利安所描述的灾难的边缘。好吧，接下来，我决心要改变一切。<br><strong> “幸福犹如一场没有终点的旅程，”朱利安继续说，他的声音已经滤去了刚才的感伤和波动，再一次因为饱含热情而高昂起来，“这也是你给自己创造的一次机会。你可以一直顺着那条铺满钻石的曲折小路向前走，也可以继续草草挥霍所剩的时间，追求彩虹尽头的那一坛黄金，最终却发现这不过是一场空。欣赏每一天中的任何一个不同的时刻吧，因为今天才是你完全拥有的一天。</strong>”<br> “每个人都能学会‘活在当下’吗？”我问道。<br> “当然。无论你目前的境遇怎么样，你都可以训练自己，学会欣赏并且珍惜生命和家庭的馈赠，在每一天的生活中都使自己的存在充满了珍宝般的价值。”<br> “但是这是不是有点太过于乐观了？要是有谁在一场糟糕的商业交易中损失了一切，他该怎么办？我们不仅是说他们的经济破产了，而且指的是他们精神上也完全垮掉了。”<br> “唉，”朱利安轻轻叹息，“<strong>我就是希望人们知道，你在银行户头上有多少存款，或者你住的房子是大是小，根本就和你能不能带着欢乐的情绪和好奇心去生活毫无关系。这个世界上开心的穷光蛋不多，可闷闷不乐的百万富翁到处都是。如果你学会在一天里抽出5分钟来练习感恩的艺术，你就会得到一直在寻找的丰富生活。就连你在举例中说到的那些人也可以发现，生活中其实还有很多东西值得他们去一再感恩，即使他们遭遇到了可怕的经济困境和精神困境。让我们去问问他，是不是还拥有自己的健康，是不是还有可爱的家庭和社交中的好口碑？他难道不以在这个伟大的国家里拥有公民资格而感到幸福吗？他的头顶上难道不是还有一方遮风挡雨的屋顶吗？也许他不再拥有成功时的霸气，不再有事业顺利时的大笔财富，不能重复一掷千金的气概，不能随心所欲地签支票购买所有感兴趣的东西。然而，还有另外一些财富是他应该用一生的时间来感恩的。我们都有很多需要感恩的东西。即使是阳光灿烂的夏天里，一只鸟儿在你的落地长窗前面婉转啼鸣，一个睿智的人也会认出来它们其实是上天赐予的馈赠。记住，约翰，生活并不总是给你想要的东西，却永远会给你需要的东西。</strong>” </p>\n<p>我们都有命里注定要去完成的事情。当你发现更高的目标，投入所有的精力时，你的才能将会迸发出来，幸福会充满你的生活。一旦你认识到你的使命，无论是成为一位成绩突出的教育孩子们的老师，还是做一个灵感丰富创作惊人的艺术家，所有的愿望都会轻而易举地被实现。你甚至都不必先去尝试。不瞒你说，我觉得你越是先去尝试，在目标实现之前所花的准备时间也就越长。相反的是，只要你跟随梦想的道路，所有在期望中想要获得的东西都一定会纷至沓来。它将引领着你走向神圣的终点。这就是我所说的铸就命运的含义。</p>\n<h2 id=\"极乐世界？\"><a href=\"#极乐世界？\" class=\"headerlink\" title=\"极乐世界？\"></a>极乐世界？</h2><p>不幸的是，约翰，你听到彼得的故事，还有那根奇妙的魔法线仅仅是一个故事，一个神话故事。而我们此时正生活在一个绝对现实的世界里，根本没有第二次机会让你重新来过一遍，去实现圆满的人生。今天，唯有今天才是你领受生活馈赠的时机——在还不是太晚之前。约翰，让这新的一天成为你人生中的分界线，你在这一天完完全全下定决心，把所有的精力都集中在对你来说是真正重要的事情上。你要下定决心，在那些可以使你的生活具有更有意义的事情上多花些时间。对生命中特殊的时刻心存敬畏，为它们的蕴含而沉醉。做那些你一直想要做的事情。去爬你一直想要去攀登的高山，或者去学一种乐器，自己做一支曲子，写一首歌词。在大雨天冲出去跳舞，或者另起炉灶从事一门新职业。学会热爱音乐，聆听音乐和鉴赏音乐，学会一门新的外语，重新点燃童年的欢乐时光。不要出于成功的考虑就把幸福向后推延。相反的是，开始学会欣赏过程中的美，重新振作你的精神，认识你的灵魂并且开始爱护它。这就是通向极乐世界的道路。” **</p>\n<p> <strong> “极乐世界？</strong>听起来像佛教里的词语？”我重复着。<br>  “<strong>极乐世界不单单是佛教里的词语。喜马拉雅山上的智者相信，真正开悟了的灵魂要前往的最终目的地是一个名叫极乐世界的地方。事实上，它不仅仅是一个地方，智者相信极乐世界是一种状态，人们可以超越此前他们所知道的一切。在极乐世界中，一切都是可能的。那里没有苦难，生命的舞蹈奔放到了极致，神圣而完美。在抵达极乐世界的途中，智者感到自己正在走向天堂。这就是他们人生中的最终目标。”朱利安总结说，他的脸笼罩在安宁之中，简直就是天使的模样</strong>。<br>  “<strong>我们之所以在这里都是出于某些特定的原因，”他预言般的继续总结着，“静心思考真正召唤你的是什么，想一想你将怎样帮助他人。不要再做惯性和惰性的奴隶，不要再拿贷款作为不快乐的借口。今天，用人生真正的意义点亮你的生命火花，让它明亮地熊熊燃烧起来。开始练习我和你分享的那些道理和方法，去做你能做的一切。当你感到内心里非常渴望尝到极乐世界果实的滋味时，那一时刻就会自然来临。</strong>”朱利安眼睛里的光芒使他看上去像一位神殿里的预言祭祀。 </p>\n<h2 id=\"开悟\"><a href=\"#开悟\" class=\"headerlink\" title=\"开悟\"></a>开悟</h2><p>“会有一些微小的迹象出现，向你显示极乐世界的入口。你开始注意到身边每一件事物当中蕴含的神圣性：比如一束月光的完美，炎热夏季里湛蓝的天空所具有的吸引力，雏菊盛开时的芬芳，或者小孩子淘气的大笑声。<br>  ”我听出他的语气中充满鼓励。 “朱利安，我向你保证，你和我在一起度过的时间不会白白浪费掉。我准备让自己完全按照智者的智慧来用心地生活，而且我将信守承诺，把我从你那里分享来的所有知识，和那些可能会从中受益的人们一起温习。我说这些话是发自内心的。我向你保证。<br>  ”我真诚地说道，感到内心里激情涌动。 “把智者的丰富智慧统统传播给身边所有的人们吧。他们很快就会从中受益，提升他们的生活品质，就像你提升了自己的生活品质一样。而且还要记住，要享受过程本身，沿途和终点一样美好。”<br>  我请朱利安继续说下去。他说：“瑜伽师拉曼是一个非常伟大的讲故事的人，但是有一个故事在他讲给我的所有故事当中显得与众不同。现在我可以讲给你听吗？”<br>  “当然好啊，你知道我一直在聆听你的每一句话。”<br>  “很多年以前，在古老的印度，有一位王侯准备为他的妻子修建一座宏大的建筑，作为他对妻子的深爱和感情的象征。这个王侯想创造出一种世界上从来都不曾见到过的建筑结构，它将在月光照耀下的夜晚里微微放光，让世世代代的人们都因为仰慕而特地赶来朝拜。于是，他的工匠们每天都忍受着酷暑骄阳，一砖一瓦地劳作。每过一天，结构就更加清楚一点，越来越像一座丰碑，也越来越像爱的灯塔，直指蔚蓝色的印度天空。最后，在经过了日复一日的20年的重复劳作之后，这座完全用白色大理石建成的宫殿终于竣工了。你猜一猜我说的是什么？”<br>  “我对印度的文明几乎一无所知。”我老老实实地承认。<br>  “就是泰姬陵。”朱利安回答我说，“我的意思很简单。这个星球上的每个人都是一个奇迹。从某种意义上来说，我们中的每一个人都是天才，都是英雄。我们中的每一个人都有潜力取得超凡的成就，取得巨大的幸福感和永恒的满足感，所需要的只是朝着我们梦想的方向踏实前行。就像泰姬陵的建筑过程一样，在简单重复的劳动中整整耗时20年。<strong>一个充满生命的奇迹就是这样日复一日，一砖一瓦建成的。小的成功会通向大的胜利。微小的、循序渐进的变化将会在一起形成积极的习惯。而后，积极的习惯会带来好的成果。积极的成果则会激励你继续朝着更加伟大的个人目标去努力。开始像对待生命中最后一天那样过好每一天的生活。从今天开始，多多学习，多多大笑，去做你真正喜欢做的事情。不要逃避自己的命运，更不要否定自己的命运。因为和存在于你自身中的那些珍贵的东西相比，那些身前身后的浮云名利根本都是无关紧要的。</strong>” </p>\n<p>如上是内容摘要，如果想更细的了解，可以购买相应的图书。这个内容是需要不段实践才能看到效果。加油吧，共同探索。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjvop3bgv0003s77rrxo1rgr2","category_id":"cjvop3bh10005s77rmmvchelx","_id":"cjvop3bh60009s77rglb02ovn"},{"post_id":"cjvop3bis000as77ruv0z53jn","category_id":"cjvop3biv000cs77rtq74aims","_id":"cjvop3bjg0016s77r6ucy4pad"},{"post_id":"cjvop3bis000as77ruv0z53jn","category_id":"cjvop3bja000vs77rk12by62p","_id":"cjvop3bjh001as77rwxoxz7dz"},{"post_id":"cjvop3bit000bs77rjvthhpmu","category_id":"cjvop3biv000cs77rtq74aims","_id":"cjvop3bjn001os77rbgsq5skw"},{"post_id":"cjvop3bit000bs77rjvthhpmu","category_id":"cjvop3bja000vs77rk12by62p","_id":"cjvop3bjo001rs77rsr1r3l2y"},{"post_id":"cjvop3biv000es77rtohlrpap","category_id":"cjvop3biv000cs77rtq74aims","_id":"cjvop3bju0024s77rwt5mzzu7"},{"post_id":"cjvop3biv000es77rtohlrpap","category_id":"cjvop3bja000vs77rk12by62p","_id":"cjvop3bjv0027s77rzj78yjo7"},{"post_id":"cjvop3biw000fs77r401l2hy8","category_id":"cjvop3bj7000qs77rqovv5r0d","_id":"cjvop3bk4002ls77r6yvtdoi4"},{"post_id":"cjvop3biw000fs77r401l2hy8","category_id":"cjvop3bjx002as77rbr5wtxi9","_id":"cjvop3bka002qs77r1cx3fnyo"},{"post_id":"cjvop3bje0013s77rvqpvqltz","category_id":"cjvop3bk1002gs77rnltrg203","_id":"cjvop3bkn0037s77rz8ofnua5"},{"post_id":"cjvop3biz000gs77rgrl02so1","category_id":"cjvop3bjd0012s77r447mhogj","_id":"cjvop3bkp003fs77ra5fw9esl"},{"post_id":"cjvop3biz000gs77rgrl02so1","category_id":"cjvop3bkn0038s77rmt02sd07","_id":"cjvop3bkq003hs77rib1z686a"},{"post_id":"cjvop3bj2000js77riixt08rj","category_id":"cjvop3bj7000qs77rqovv5r0d","_id":"cjvop3bkr003ps77rr3kmbz4s"},{"post_id":"cjvop3bj2000js77riixt08rj","category_id":"cjvop3bkq003js77rskfc8v3i","_id":"cjvop3bks003rs77rs98bh3a2"},{"post_id":"cjvop3bj3000ks77rhjvx7rl1","category_id":"cjvop3bjd0012s77r447mhogj","_id":"cjvop3bkv0044s77r7inrvbv7"},{"post_id":"cjvop3bj3000ks77rhjvx7rl1","category_id":"cjvop3bkt003xs77rwkh5lni7","_id":"cjvop3bkv0046s77r0ik7l4dh"},{"post_id":"cjvop3bjm001ls77rz12rblaw","category_id":"cjvop3bjd0012s77r447mhogj","_id":"cjvop3bkv0048s77rv88fn3y7"},{"post_id":"cjvop3bjm001ls77rz12rblaw","category_id":"cjvop3bku0040s77rnzrd6scb","_id":"cjvop3bkw004as77rs2yoqoph"},{"post_id":"cjvop3bjn001ps77rsmfod9gl","category_id":"cjvop3biv000cs77rtq74aims","_id":"cjvop3bkx004ds77r7sybg3lq"},{"post_id":"cjvop3bjn001ps77rsmfod9gl","category_id":"cjvop3bkv0045s77rjdowso2s","_id":"cjvop3bkx004hs77r0d3x9lf4"},{"post_id":"cjvop3bj5000ns77r1r8phq9t","category_id":"cjvop3bjd0012s77r447mhogj","_id":"cjvop3bkz004ns77rv4oe3xt1"},{"post_id":"cjvop3bj5000ns77r1r8phq9t","category_id":"cjvop3bkx004es77rzs4xsl7p","_id":"cjvop3bkz004ps77rhq8wsn04"},{"post_id":"cjvop3bjr001ws77r0jbev6em","category_id":"cjvop3bj7000qs77rqovv5r0d","_id":"cjvop3bl0004us77rsonajk4y"},{"post_id":"cjvop3bjr001ws77r0jbev6em","category_id":"cjvop3bky004ms77rv80mi0k3","_id":"cjvop3bl0004xs77rksz403p2"},{"post_id":"cjvop3bj7000ps77rtwwzobhp","category_id":"cjvop3bjd0012s77r447mhogj","_id":"cjvop3bl20055s77rovray4td"},{"post_id":"cjvop3bj7000ps77rtwwzobhp","category_id":"cjvop3bl0004ys77rktha3y7g","_id":"cjvop3bl20058s77rbrp0daqg"},{"post_id":"cjvop3bj8000ts77rmqr4oe1n","category_id":"cjvop3bjd0012s77r447mhogj","_id":"cjvop3bl4005gs77ru23nchu7"},{"post_id":"cjvop3bj8000ts77rmqr4oe1n","category_id":"cjvop3bl3005as77rh5qn3nn2","_id":"cjvop3bl4005ks77rm0j3vau7"},{"post_id":"cjvop3bjx002bs77r8yhq8eur","category_id":"cjvop3bl4005fs77rufciu60p","_id":"cjvop3bl4005ms77r8f0pros1"},{"post_id":"cjvop3bj9000us77r8xw2tgy0","category_id":"cjvop3bk1002gs77rnltrg203","_id":"cjvop3bl7005zs77r60bvugfj"},{"post_id":"cjvop3bj9000us77r8xw2tgy0","category_id":"cjvop3bl5005ts77ri1lxxy30","_id":"cjvop3bl70063s77rqx6zgjju"},{"post_id":"cjvop3bk3002ks77rlo0w2c5r","category_id":"cjvop3bl6005ws77ricghei5f","_id":"cjvop3bl80067s77rtnz9nftl"},{"post_id":"cjvop3bja000xs77r286eru1r","category_id":"cjvop3bk1002gs77rnltrg203","_id":"cjvop3bl9006es77r06gckr5q"},{"post_id":"cjvop3bja000xs77r286eru1r","category_id":"cjvop3bl80066s77rgtb1ouyv","_id":"cjvop3bla006gs77rveh95iyx"},{"post_id":"cjvop3bjb000zs77rfz9rcp0c","category_id":"cjvop3bk1002gs77rnltrg203","_id":"cjvop3bld006os77r7r0kic9o"},{"post_id":"cjvop3bjb000zs77rfz9rcp0c","category_id":"cjvop3bl80066s77rgtb1ouyv","_id":"cjvop3bld006qs77rxlplv8oy"},{"post_id":"cjvop3bkj002zs77r09jgoote","category_id":"cjvop3blc006ns77rj4qm5e4o","_id":"cjvop3ble006vs77rnyu46v4r"},{"post_id":"cjvop3bkk0031s77rpumgp7cy","category_id":"cjvop3ble006rs77r6bqxjhw4","_id":"cjvop3blf006zs77rabk24313"},{"post_id":"cjvop3bkl0033s77rc1cm98m9","category_id":"cjvop3blf006ws77rc0g93ckt","_id":"cjvop3blf0072s77r4yapz8ug"},{"post_id":"cjvop3bjf0014s77r54xzc4ba","category_id":"cjvop3bkk0032s77r630w2f8z","_id":"cjvop3blg0078s77rr8oa43wx"},{"post_id":"cjvop3bjf0014s77r54xzc4ba","category_id":"cjvop3blf0070s77rra7cvfsz","_id":"cjvop3blh007as77r83n8ltoj"},{"post_id":"cjvop3bkm0035s77rv7g2xvyu","category_id":"cjvop3blf006ws77rc0g93ckt","_id":"cjvop3blh007bs77rkbl1vv39"},{"post_id":"cjvop3bjg0018s77r6t0yyrvi","category_id":"cjvop3bkk0032s77r630w2f8z","_id":"cjvop3bli007is77r07j5kyeb"},{"post_id":"cjvop3bjg0018s77r6t0yyrvi","category_id":"cjvop3blg0077s77r8voc3ye5","_id":"cjvop3bli007js77r1cb8mdxq"},{"post_id":"cjvop3bji001bs77rnx4mfz0q","category_id":"cjvop3bkk0032s77r630w2f8z","_id":"cjvop3bli007ks77rgpukrpr8"},{"post_id":"cjvop3bji001bs77rnx4mfz0q","category_id":"cjvop3blg0077s77r8voc3ye5","_id":"cjvop3blj007os77rx2i5ei6y"},{"post_id":"cjvop3bjj001fs77rlm5ukqfo","category_id":"cjvop3bkr003ms77rs491m1xk","_id":"cjvop3blj007rs77rrcp0mrde"},{"post_id":"cjvop3bjj001fs77rlm5ukqfo","category_id":"cjvop3bli007hs77rmf2aga6j","_id":"cjvop3blk007us77rf75oz0tm"},{"post_id":"cjvop3bjk001gs77rdhrcfyhi","category_id":"cjvop3bkr003ms77rs491m1xk","_id":"cjvop3blk007ws77r0pcjxlpj"},{"post_id":"cjvop3bjk001gs77rdhrcfyhi","category_id":"cjvop3bli007hs77rmf2aga6j","_id":"cjvop3bll007zs77rwrk60slu"},{"post_id":"cjvop3bjl001js77roqdxkcs3","category_id":"cjvop3bkr003ms77rs491m1xk","_id":"cjvop3blm0080s77rm0ofe2hx"},{"post_id":"cjvop3bjl001js77roqdxkcs3","category_id":"cjvop3bli007hs77rmf2aga6j","_id":"cjvop3blm0084s77rhfzhj5ab"},{"post_id":"cjvop3bjo001ss77rpwrdzclk","category_id":"cjvop3bkv0049s77r9t3jcckb","_id":"cjvop3bln0087s77rprip6tzx"},{"post_id":"cjvop3bjo001ss77rpwrdzclk","category_id":"cjvop3blk007vs77rzzgj4b1o","_id":"cjvop3bln0089s77rvfs1e1or"},{"post_id":"cjvop3bjp001us77rlzgl6vwe","category_id":"cjvop3bkv0049s77r9t3jcckb","_id":"cjvop3blo008cs77rd3ecgm36"},{"post_id":"cjvop3bjp001us77rlzgl6vwe","category_id":"cjvop3blk007vs77rzzgj4b1o","_id":"cjvop3blo008es77r7856n8si"},{"post_id":"cjvop3bjs001zs77r6iaot0eb","category_id":"cjvop3bkv0049s77r9t3jcckb","_id":"cjvop3blo008fs77re5vdpmus"},{"post_id":"cjvop3bjs001zs77r6iaot0eb","category_id":"cjvop3blk007vs77rzzgj4b1o","_id":"cjvop3blp008js77r0vdraur3"},{"post_id":"cjvop3bjt0022s77ruvjd7vwf","category_id":"cjvop3bl0004ts77r5cdlxchh","_id":"cjvop3blp008ls77rhfo86rt2"},{"post_id":"cjvop3bjt0022s77ruvjd7vwf","category_id":"cjvop3blo008bs77rz16qetev","_id":"cjvop3blq008os77rgan9cbfc"},{"post_id":"cjvop3bju0025s77r763vfhjn","category_id":"cjvop3bkv0049s77r9t3jcckb","_id":"cjvop3blq008ps77r95q7iguf"},{"post_id":"cjvop3bju0025s77r763vfhjn","category_id":"cjvop3blk007vs77rzzgj4b1o","_id":"cjvop3blr008ss77rhg6fl6h8"},{"post_id":"cjvop3bjw0028s77r47a8uy2n","category_id":"cjvop3bl20054s77rbnwds7my","_id":"cjvop3blr008us77r0t3f8s8t"},{"post_id":"cjvop3bjw0028s77r47a8uy2n","category_id":"cjvop3blp008ks77rovhd9m1s","_id":"cjvop3blr008xs77rwzhj5pap"},{"post_id":"cjvop3bjz002es77rmbvcu4k0","category_id":"cjvop3bl4005is77rt2x4x5z5","_id":"cjvop3bls008zs77rla17u42o"},{"post_id":"cjvop3bjz002es77rmbvcu4k0","category_id":"cjvop3blq008qs77rlk5hmeej","_id":"cjvop3bls0090s77rd3zacxl2"},{"post_id":"cjvop3bk0002fs77rx237gfb6","category_id":"cjvop3bl20054s77rbnwds7my","_id":"cjvop3bls0091s77r62jjz5rp"},{"post_id":"cjvop3bk0002fs77rx237gfb6","category_id":"cjvop3blp008ks77rovhd9m1s","_id":"cjvop3bls0093s77rh72dlfku"},{"post_id":"cjvop3bk2002is77r8pw39ofr","category_id":"cjvop3bl4005is77rt2x4x5z5","_id":"cjvop3bls0094s77rm6dhh02c"},{"post_id":"cjvop3bk2002is77r8pw39ofr","category_id":"cjvop3bls008ys77r0260syl4","_id":"cjvop3bls0096s77rm72ktmii"},{"post_id":"cjvop3bk5002ps77rqwfrkanj","category_id":"cjvop3bl6005ws77ricghei5f","_id":"cjvop3blt0098s77r7240l1jb"},{"post_id":"cjvop3bk5002ps77rqwfrkanj","category_id":"cjvop3bls0092s77r5ghian5w","_id":"cjvop3blt0099s77rjk1hgvug"},{"post_id":"cjvop3bkb002rs77rytq00fq1","category_id":"cjvop3bl6005ws77ricghei5f","_id":"cjvop3blt009bs77rfq70lyjg"},{"post_id":"cjvop3bkb002rs77rytq00fq1","category_id":"cjvop3bls0092s77r5ghian5w","_id":"cjvop3blu009cs77rx1grdd44"},{"post_id":"cjvop3bkf002ts77r4ip1i3k4","category_id":"cjvop3bl6005ws77ricghei5f","_id":"cjvop3blu009ds77r6v8autqs"},{"post_id":"cjvop3bkf002ts77r4ip1i3k4","category_id":"cjvop3bls0092s77r5ghian5w","_id":"cjvop3blu009es77rj6k5tblj"},{"post_id":"cjvop3bkh002ws77ry6n8aybp","category_id":"cjvop3bl6005ws77ricghei5f","_id":"cjvop3blu009fs77rk52bxlrb"},{"post_id":"cjvop3bkh002ws77ry6n8aybp","category_id":"cjvop3bls0092s77r5ghian5w","_id":"cjvop3blu009gs77rjvuo56cr"},{"post_id":"cjvop3bme009os77rlxs865e7","category_id":"cjvop3bjd0012s77r447mhogj","_id":"cjvop3bmj009ws77r64gyg9hx"},{"post_id":"cjvop3bme009os77rlxs865e7","category_id":"cjvop3bmd009ls77r0disjqid","_id":"cjvop3bmk009zs77rd9t699m8"},{"post_id":"cjvop3bm6009hs77rytufx3f6","category_id":"cjvop3bjd0012s77r447mhogj","_id":"cjvop3bml00a2s77rua7a8583"},{"post_id":"cjvop3bm6009hs77rytufx3f6","category_id":"cjvop3bmd009ls77r0disjqid","_id":"cjvop3bml00a4s77rr21dzuhe"},{"post_id":"cjvop3bma009is77r040esuhr","category_id":"cjvop3bj7000qs77rqovv5r0d","_id":"cjvop3bml00a6s77rs6thf8ke"},{"post_id":"cjvop3bma009is77r040esuhr","category_id":"cjvop3bmh009rs77reolnf8k0","_id":"cjvop3bmm00a9s77rbhiob816"},{"post_id":"cjvop3bmb009ks77r79n0kln0","category_id":"cjvop3bjd0012s77r447mhogj","_id":"cjvop3bmm00acs77rdoqh5vgp"},{"post_id":"cjvop3bmb009ks77r79n0kln0","category_id":"cjvop3bmj009xs77rzjysrd8b","_id":"cjvop3bmm00aes77r7nwr8yjp"},{"post_id":"cjvop3bmf009qs77ruqtqk9sl","category_id":"cjvop3bk1002gs77rnltrg203","_id":"cjvop3bmn00ags77rctzjocjv"},{"post_id":"cjvop3bmf009qs77ruqtqk9sl","category_id":"cjvop3bml00a3s77ry8nqv4gk","_id":"cjvop3bmn00ais77rcgjaleuw"},{"post_id":"cjvop3bmh009ts77rvlmigf6i","category_id":"cjvop3bl6005ws77ricghei5f","_id":"cjvop3bmn00aks77rrphn6tvq"},{"post_id":"cjvop3bmh009ts77rvlmigf6i","category_id":"cjvop3bmm00a8s77r25svqhgg","_id":"cjvop3bmn00als77rq4o67vfx"},{"post_id":"cjvop3bou00ams77r6d7001aq","category_id":"cjvop3bkr003ms77rs491m1xk","_id":"cjvop3bp100aus77ry4kpgp2b"},{"post_id":"cjvop3bou00ams77r6d7001aq","category_id":"cjvop3bli007hs77rmf2aga6j","_id":"cjvop3bp200aws77rlj4wmf9k"},{"post_id":"cjvop3bow00aps77rq879jtqx","category_id":"cjvop3bl0004ts77r5cdlxchh","_id":"cjvop3bp700b5s77r82o5b57e"},{"post_id":"cjvop3bow00aps77rq879jtqx","category_id":"cjvop3bp400ays77rw4fp6r9a","_id":"cjvop3bp800b8s77r7aaux0cc"},{"post_id":"cjvop3boz00ats77r26vmy9le","category_id":"cjvop3bl0004ts77r5cdlxchh","_id":"cjvop3bp800bas77rlvqar2cb"},{"post_id":"cjvop3boz00ats77r26vmy9le","category_id":"cjvop3bp600b2s77r5vmb1iu7","_id":"cjvop3bp900bds77r76rre6uj"},{"post_id":"cjvop3bov00ans77reenqr2jt","category_id":"cjvop3boz00aqs77rh6tc1p36","_id":"cjvop3bpa00bjs77r27ypcjlx"},{"post_id":"cjvop3bov00ans77reenqr2jt","category_id":"cjvop3bp800bbs77r06sj33j4","_id":"cjvop3bpb00bls77r9hxtoh0j"},{"post_id":"cjvop3bp100avs77r3251nccy","category_id":"cjvop3bp700b6s77rtwmfr29p","_id":"cjvop3bpc00bos77rw31fq1hr"},{"post_id":"cjvop3bp100avs77r3251nccy","category_id":"cjvop3bpb00bms77r200ki2pe","_id":"cjvop3bpc00bqs77rwk7sklsd"},{"post_id":"cjvop3bp200axs77rd2uwwwa1","category_id":"cjvop3bp700b6s77rtwmfr29p","_id":"cjvop3bpc00brs77rx9xjap13"},{"post_id":"cjvop3bp200axs77rd2uwwwa1","category_id":"cjvop3bpb00bns77rvdh8gb05","_id":"cjvop3bpc00bss77rb5tlegbv"},{"post_id":"cjvop3bp500b1s77rmvb6z1hi","category_id":"cjvop3bp700b6s77rtwmfr29p","_id":"cjvop3bpd00bts77r7lhocg19"},{"post_id":"cjvop3bp500b1s77rmvb6z1hi","category_id":"cjvop3bpb00bms77r200ki2pe","_id":"cjvop3bpd00bus77rl0yn438e"},{"post_id":"cjvop3bpn00bvs77rjrywdfn6","category_id":"cjvop3bjd0012s77r447mhogj","_id":"cjvop3bpr00c3s77rv7hi31nc"},{"post_id":"cjvop3bpn00bvs77rjrywdfn6","category_id":"cjvop3bpq00bys77r006y7z8g","_id":"cjvop3bpr00c5s77rb1i12y1z"},{"post_id":"cjvop3bpo00bws77rmnbvevcw","category_id":"cjvop3bpq00c0s77rawmesu07","_id":"cjvop3bpr00c6s77r1c0gdks7"},{"post_id":"cjvop3bpz00c7s77rtz4en8ii","category_id":"cjvop3biv000cs77rtq74aims","_id":"cjvop3bq000cas77rqev7cb2r"},{"post_id":"cjvop3bpz00c7s77rtz4en8ii","category_id":"cjvop3bja000vs77rk12by62p","_id":"cjvop3bq000cbs77rbvpuxcv9"},{"post_id":"cjvop3bq300ccs77rcewj5wa8","category_id":"cjvop3bkr003ms77rs491m1xk","_id":"cjvop3bq500cfs77rxu8h3su8"},{"post_id":"cjvop3bq300ccs77rcewj5wa8","category_id":"cjvop3bli007hs77rmf2aga6j","_id":"cjvop3bq500cgs77rmlyqg749"},{"post_id":"cjvop3bqb00chs77rs9ux1h5n","category_id":"cjvop3bpq00c0s77rawmesu07","_id":"cjvop3bqc00cjs77raw41w65c"},{"post_id":"cjvop3bqf00cks77r47sen429","category_id":"cjvop3bqg00cls77rwnb3i6cn","_id":"cjvop3bqg00cos77rjdradc3l"}],"PostTag":[{"post_id":"cjvop3bgv0003s77rrxo1rgr2","tag_id":"cjvop3bh20006s77rkkmo0eu5","_id":"cjvop3bh50008s77rkzsucksx"},{"post_id":"cjvop3bis000as77ruv0z53jn","tag_id":"cjvop3biv000ds77reafvr70l","_id":"cjvop3bj6000os77r03idxdmu"},{"post_id":"cjvop3bis000as77ruv0z53jn","tag_id":"cjvop3bj0000is77rl7qvn2rk","_id":"cjvop3bj7000rs77rqy5636t7"},{"post_id":"cjvop3bit000bs77rjvthhpmu","tag_id":"cjvop3biv000ds77reafvr70l","_id":"cjvop3bjb000ys77r52vuzhfj"},{"post_id":"cjvop3bit000bs77rjvthhpmu","tag_id":"cjvop3bj0000is77rl7qvn2rk","_id":"cjvop3bjc0010s77r6rkql8m8"},{"post_id":"cjvop3biv000es77rtohlrpap","tag_id":"cjvop3biv000ds77reafvr70l","_id":"cjvop3bjh0019s77rf01qc20b"},{"post_id":"cjvop3biv000es77rtohlrpap","tag_id":"cjvop3bj0000is77rl7qvn2rk","_id":"cjvop3bji001cs77rckij9klo"},{"post_id":"cjvop3biw000fs77r401l2hy8","tag_id":"cjvop3bjg0015s77rcwjjkb06","_id":"cjvop3bjm001ks77raegxjgy6"},{"post_id":"cjvop3biw000fs77r401l2hy8","tag_id":"cjvop3bjj001ds77rjmnfkomm","_id":"cjvop3bjn001ms77rv9bgity7"},{"post_id":"cjvop3biz000gs77rgrl02so1","tag_id":"cjvop3bjl001is77r0rm9ln1b","_id":"cjvop3bjr001xs77ro9kambn9"},{"post_id":"cjvop3biz000gs77rgrl02so1","tag_id":"cjvop3bjo001qs77rm6r173mw","_id":"cjvop3bjs0020s77r1fmt104k"},{"post_id":"cjvop3bj2000js77riixt08rj","tag_id":"cjvop3bjg0015s77rcwjjkb06","_id":"cjvop3bjw0029s77rfqxmd5b9"},{"post_id":"cjvop3bj2000js77riixt08rj","tag_id":"cjvop3bjt0021s77r9ynlq5g6","_id":"cjvop3bjy002cs77rt79b12al"},{"post_id":"cjvop3bj3000ks77rhjvx7rl1","tag_id":"cjvop3bjl001is77r0rm9ln1b","_id":"cjvop3bk3002js77rg69onx38"},{"post_id":"cjvop3bj3000ks77rhjvx7rl1","tag_id":"cjvop3bjy002ds77rbqfg9304","_id":"cjvop3bk5002ns77rpoa8xnel"},{"post_id":"cjvop3bj5000ns77r1r8phq9t","tag_id":"cjvop3bjl001is77r0rm9ln1b","_id":"cjvop3bkh002vs77rprie59ch"},{"post_id":"cjvop3bj5000ns77r1r8phq9t","tag_id":"cjvop3bk5002os77rfzq3mgk7","_id":"cjvop3bkj002ys77rq46x8nl1"},{"post_id":"cjvop3bj7000ps77rtwwzobhp","tag_id":"cjvop3bjl001is77r0rm9ln1b","_id":"cjvop3bkn0036s77r6g8f6s2t"},{"post_id":"cjvop3bj7000ps77rtwwzobhp","tag_id":"cjvop3bkj0030s77rzg4xc9ul","_id":"cjvop3bkn0039s77rpotk2s5e"},{"post_id":"cjvop3bj8000ts77rmqr4oe1n","tag_id":"cjvop3bjl001is77r0rm9ln1b","_id":"cjvop3bkp003ds77r2qt4bybd"},{"post_id":"cjvop3bj8000ts77rmqr4oe1n","tag_id":"cjvop3bko003as77rsznqnrbl","_id":"cjvop3bkq003gs77rpg53x54k"},{"post_id":"cjvop3bj9000us77r8xw2tgy0","tag_id":"cjvop3bkp003cs77rvo4f70tg","_id":"cjvop3bkr003ls77rzxhwj36w"},{"post_id":"cjvop3bj9000us77r8xw2tgy0","tag_id":"cjvop3bkq003is77rfos565l2","_id":"cjvop3bkr003ns77r31cf58zg"},{"post_id":"cjvop3bja000xs77r286eru1r","tag_id":"cjvop3bkp003cs77rvo4f70tg","_id":"cjvop3bks003ts77rxv6sgfn3"},{"post_id":"cjvop3bja000xs77r286eru1r","tag_id":"cjvop3bkr003os77rjbo52tjb","_id":"cjvop3bkt003vs77r207cukjo"},{"post_id":"cjvop3bjb000zs77rfz9rcp0c","tag_id":"cjvop3bkp003cs77rvo4f70tg","_id":"cjvop3bku003zs77rfe67c36w"},{"post_id":"cjvop3bjb000zs77rfz9rcp0c","tag_id":"cjvop3bkr003os77rjbo52tjb","_id":"cjvop3bku0041s77rj1ke0mkp"},{"post_id":"cjvop3bje0013s77rvqpvqltz","tag_id":"cjvop3bkp003cs77rvo4f70tg","_id":"cjvop3bkv0043s77r6wk6shk2"},{"post_id":"cjvop3bjf0014s77r54xzc4ba","tag_id":"cjvop3bku0042s77regkak5qd","_id":"cjvop3bkw004cs77rxm9sgo6d"},{"post_id":"cjvop3bjf0014s77r54xzc4ba","tag_id":"cjvop3bkv0047s77rbxqcva9k","_id":"cjvop3bkx004fs77r8npxvplx"},{"post_id":"cjvop3bjg0018s77r6t0yyrvi","tag_id":"cjvop3bku0042s77regkak5qd","_id":"cjvop3bky004is77rwc5vgf1w"},{"post_id":"cjvop3bji001bs77rnx4mfz0q","tag_id":"cjvop3bku0042s77regkak5qd","_id":"cjvop3bky004ls77rhtqey0vu"},{"post_id":"cjvop3bjj001fs77rlm5ukqfo","tag_id":"cjvop3bky004ks77rffxijafy","_id":"cjvop3bkz004ss77riidbffx7"},{"post_id":"cjvop3bjj001fs77rlm5ukqfo","tag_id":"cjvop3bkz004os77rs2nf2hbf","_id":"cjvop3bl0004vs77r29fy0uwg"},{"post_id":"cjvop3bjk001gs77rdhrcfyhi","tag_id":"cjvop3bky004ks77rffxijafy","_id":"cjvop3bl10050s77rrcogr30l"},{"post_id":"cjvop3bjk001gs77rdhrcfyhi","tag_id":"cjvop3bkz004os77rs2nf2hbf","_id":"cjvop3bl10051s77re6fdnjs9"},{"post_id":"cjvop3bjl001js77roqdxkcs3","tag_id":"cjvop3bky004ks77rffxijafy","_id":"cjvop3bl20057s77ra32i1dya"},{"post_id":"cjvop3bjl001js77roqdxkcs3","tag_id":"cjvop3bkz004os77rs2nf2hbf","_id":"cjvop3bl20059s77r2r9jkpy8"},{"post_id":"cjvop3bjm001ls77rz12rblaw","tag_id":"cjvop3bjl001is77r0rm9ln1b","_id":"cjvop3bl3005cs77ruaxe33zg"},{"post_id":"cjvop3bjm001ls77rz12rblaw","tag_id":"cjvop3bl20056s77rgwoeky24","_id":"cjvop3bl3005ds77r94b4etla"},{"post_id":"cjvop3bjn001ps77rsmfod9gl","tag_id":"cjvop3bkp003cs77rvo4f70tg","_id":"cjvop3bl4005js77rswqhfwtx"},{"post_id":"cjvop3bjn001ps77rsmfod9gl","tag_id":"cjvop3bl3005es77rjb9jjhli","_id":"cjvop3bl4005ls77r36d7llqq"},{"post_id":"cjvop3bjo001ss77rpwrdzclk","tag_id":"cjvop3bl4005hs77reyyhbuut","_id":"cjvop3bl5005rs77ri4th5pr4"},{"post_id":"cjvop3bjo001ss77rpwrdzclk","tag_id":"cjvop3bl4005ns77rckd3fc3i","_id":"cjvop3bl5005ss77rq4bx7c9w"},{"post_id":"cjvop3bjp001us77rlzgl6vwe","tag_id":"cjvop3bl4005hs77reyyhbuut","_id":"cjvop3bl6005xs77rlwd1p87u"},{"post_id":"cjvop3bjp001us77rlzgl6vwe","tag_id":"cjvop3bl4005ns77rckd3fc3i","_id":"cjvop3bl6005ys77rhcem0c33"},{"post_id":"cjvop3bjr001ws77r0jbev6em","tag_id":"cjvop3bjg0015s77rcwjjkb06","_id":"cjvop3bl70062s77rz86isr4t"},{"post_id":"cjvop3bjr001ws77r0jbev6em","tag_id":"cjvop3bl6005vs77rh1z8j2fx","_id":"cjvop3bl70064s77rsa7fc7j2"},{"post_id":"cjvop3bjs001zs77r6iaot0eb","tag_id":"cjvop3bl4005hs77reyyhbuut","_id":"cjvop3bl8006as77rr26gd1mt"},{"post_id":"cjvop3bjs001zs77r6iaot0eb","tag_id":"cjvop3bl4005ns77rckd3fc3i","_id":"cjvop3bl9006bs77rr3zabkec"},{"post_id":"cjvop3bjt0022s77ruvjd7vwf","tag_id":"cjvop3bl80068s77rhny2xftm","_id":"cjvop3bla006fs77rozdajj2h"},{"post_id":"cjvop3bju0025s77r763vfhjn","tag_id":"cjvop3bl4005hs77reyyhbuut","_id":"cjvop3blc006ls77rlg9u0jhk"},{"post_id":"cjvop3bju0025s77r763vfhjn","tag_id":"cjvop3bl4005ns77rckd3fc3i","_id":"cjvop3blc006ms77reo2an703"},{"post_id":"cjvop3bjw0028s77r47a8uy2n","tag_id":"cjvop3blc006js77rlc8b9nwb","_id":"cjvop3ble006ts77rl0v2atvu"},{"post_id":"cjvop3bjw0028s77r47a8uy2n","tag_id":"cjvop3bld006ps77rrgo99x2e","_id":"cjvop3ble006us77ry0hagpc2"},{"post_id":"cjvop3bjx002bs77r8yhq8eur","tag_id":"cjvop3ble006ss77rapcz49f6","_id":"cjvop3blf006ys77rdgrsxs9n"},{"post_id":"cjvop3bjz002es77rmbvcu4k0","tag_id":"cjvop3blf006xs77rc7kktsng","_id":"cjvop3blg0075s77rv2f2xgbn"},{"post_id":"cjvop3bjz002es77rmbvcu4k0","tag_id":"cjvop3blf0071s77rve6vtaz9","_id":"cjvop3blg0076s77rmjg1gtxz"},{"post_id":"cjvop3bk0002fs77rx237gfb6","tag_id":"cjvop3blc006js77rlc8b9nwb","_id":"cjvop3bli007es77r9n4fbo2f"},{"post_id":"cjvop3bk0002fs77rx237gfb6","tag_id":"cjvop3bld006ps77rrgo99x2e","_id":"cjvop3bli007fs77r79t84pg9"},{"post_id":"cjvop3bk2002is77r8pw39ofr","tag_id":"cjvop3blf006xs77rc7kktsng","_id":"cjvop3blj007ns77r5gifagmo"},{"post_id":"cjvop3bk2002is77r8pw39ofr","tag_id":"cjvop3bli007gs77rjtlmla43","_id":"cjvop3blj007ps77r67ofrkwf"},{"post_id":"cjvop3bk3002ks77rlo0w2c5r","tag_id":"cjvop3bli007ls77ro85sppoj","_id":"cjvop3blk007ts77rq6qih8bt"},{"post_id":"cjvop3bk5002ps77rqwfrkanj","tag_id":"cjvop3bli007ls77ro85sppoj","_id":"cjvop3bll007ys77re3yx2lfa"},{"post_id":"cjvop3bkb002rs77rytq00fq1","tag_id":"cjvop3bli007ls77ro85sppoj","_id":"cjvop3blm0083s77rz6661j3t"},{"post_id":"cjvop3bkf002ts77r4ip1i3k4","tag_id":"cjvop3bli007ls77ro85sppoj","_id":"cjvop3bln0088s77r5ordjnyg"},{"post_id":"cjvop3bkh002ws77ry6n8aybp","tag_id":"cjvop3bli007ls77ro85sppoj","_id":"cjvop3blo008ds77rvh2oexlh"},{"post_id":"cjvop3bkj002zs77r09jgoote","tag_id":"cjvop3blo008as77runfbbv9y","_id":"cjvop3blp008is77rov14vf8f"},{"post_id":"cjvop3bkk0031s77rpumgp7cy","tag_id":"cjvop3blo008gs77r9p0pbthe","_id":"cjvop3blq008ns77ro99k8852"},{"post_id":"cjvop3bkl0033s77rc1cm98m9","tag_id":"cjvop3blp008ms77rc865jyhi","_id":"cjvop3blr008ts77rcd93sdoq"},{"post_id":"cjvop3bkm0035s77rv7g2xvyu","tag_id":"cjvop3blp008ms77rc865jyhi","_id":"cjvop3blr008ws77rw9jtmyqu"},{"post_id":"cjvop3bm6009hs77rytufx3f6","tag_id":"cjvop3bjl001is77r0rm9ln1b","_id":"cjvop3bmb009js77r8cbojntu"},{"post_id":"cjvop3bm6009hs77rytufx3f6","tag_id":"cjvop3bl20056s77rgwoeky24","_id":"cjvop3bme009ns77rpngbe2vl"},{"post_id":"cjvop3bm6009hs77rytufx3f6","tag_id":"cjvop3bjo001qs77rm6r173mw","_id":"cjvop3bmf009ps77rkyxjigvz"},{"post_id":"cjvop3bme009os77rlxs865e7","tag_id":"cjvop3bjl001is77r0rm9ln1b","_id":"cjvop3bmh009ss77ra05gb5zv"},{"post_id":"cjvop3bme009os77rlxs865e7","tag_id":"cjvop3bjo001qs77rm6r173mw","_id":"cjvop3bmj009vs77r5kwuxel6"},{"post_id":"cjvop3bma009is77r040esuhr","tag_id":"cjvop3bjg0015s77rcwjjkb06","_id":"cjvop3bmk009ys77r6a9eg0ii"},{"post_id":"cjvop3bma009is77r040esuhr","tag_id":"cjvop3bmd009ms77r5ydnhuom","_id":"cjvop3bmk00a1s77rk5butvee"},{"post_id":"cjvop3bmb009ks77r79n0kln0","tag_id":"cjvop3bjl001is77r0rm9ln1b","_id":"cjvop3bml00a7s77rw3u34dud"},{"post_id":"cjvop3bmb009ks77r79n0kln0","tag_id":"cjvop3bmi009us77r2mnue8zn","_id":"cjvop3bmm00aas77ryelz2bty"},{"post_id":"cjvop3bmb009ks77r79n0kln0","tag_id":"cjvop3bmk00a0s77r78zsrnfy","_id":"cjvop3bmm00ads77rsdpfko64"},{"post_id":"cjvop3bmf009qs77ruqtqk9sl","tag_id":"cjvop3bkp003cs77rvo4f70tg","_id":"cjvop3bmn00afs77rvp5l6zjz"},{"post_id":"cjvop3bmf009qs77ruqtqk9sl","tag_id":"cjvop3bml00a5s77rndedu3uk","_id":"cjvop3bmn00ahs77rjplngao6"},{"post_id":"cjvop3bmh009ts77rvlmigf6i","tag_id":"cjvop3bmm00abs77rfugmnn94","_id":"cjvop3bmn00ajs77rj542osqi"},{"post_id":"cjvop3bou00ams77r6d7001aq","tag_id":"cjvop3bky004ks77rffxijafy","_id":"cjvop3bow00aos77r4tjrd0a0"},{"post_id":"cjvop3bou00ams77r6d7001aq","tag_id":"cjvop3bkz004os77rs2nf2hbf","_id":"cjvop3boz00ass77rbqttnt7o"},{"post_id":"cjvop3bov00ans77reenqr2jt","tag_id":"cjvop3boz00ars77rehr0dlkx","_id":"cjvop3bp500b0s77rwmphpbhc"},{"post_id":"cjvop3bow00aps77rq879jtqx","tag_id":"cjvop3bp400azs77rcwt63nzb","_id":"cjvop3bp700b4s77r5l2eyci3"},{"post_id":"cjvop3boz00ats77r26vmy9le","tag_id":"cjvop3bp600b3s77rmr55840w","_id":"cjvop3bp800b9s77rwrplcprz"},{"post_id":"cjvop3bp100avs77r3251nccy","tag_id":"cjvop3bp700b7s77rz3dcpvvo","_id":"cjvop3bp900bes77r1aivlztw"},{"post_id":"cjvop3bp200axs77rd2uwwwa1","tag_id":"cjvop3bp800bcs77rlhzvvjiy","_id":"cjvop3bpa00bhs77r6tivkizm"},{"post_id":"cjvop3bp500b1s77rmvb6z1hi","tag_id":"cjvop3bp700b7s77rz3dcpvvo","_id":"cjvop3bpb00bks77rvxfna6to"},{"post_id":"cjvop3bpn00bvs77rjrywdfn6","tag_id":"cjvop3bjl001is77r0rm9ln1b","_id":"cjvop3bpq00c1s77r8nsisxgr"},{"post_id":"cjvop3bpn00bvs77rjrywdfn6","tag_id":"cjvop3bpp00bxs77rds94s5v0","_id":"cjvop3bpr00c2s77rdfogng00"},{"post_id":"cjvop3bpo00bws77rmnbvevcw","tag_id":"cjvop3bpq00bzs77rmhllu01e","_id":"cjvop3bpr00c4s77rf1ekekfh"},{"post_id":"cjvop3bpz00c7s77rtz4en8ii","tag_id":"cjvop3biv000ds77reafvr70l","_id":"cjvop3bq000c8s77rf7y6axzu"},{"post_id":"cjvop3bpz00c7s77rtz4en8ii","tag_id":"cjvop3bj0000is77rl7qvn2rk","_id":"cjvop3bq000c9s77r01hd973c"},{"post_id":"cjvop3bq300ccs77rcewj5wa8","tag_id":"cjvop3bky004ks77rffxijafy","_id":"cjvop3bq400cds77rxvwixhbx"},{"post_id":"cjvop3bq300ccs77rcewj5wa8","tag_id":"cjvop3bkz004os77rs2nf2hbf","_id":"cjvop3bq400ces77ruqyba08o"},{"post_id":"cjvop3bqb00chs77rs9ux1h5n","tag_id":"cjvop3bpq00bzs77rmhllu01e","_id":"cjvop3bqc00cis77rdtxkk2fs"},{"post_id":"cjvop3bqf00cks77r47sen429","tag_id":"cjvop3bqg00cms77rov5brhdr","_id":"cjvop3bqg00cns77r0yni2ufi"}],"Tag":[{"name":"markdown","_id":"cjvop3bh20006s77rkkmo0eu5"},{"name":"开源项目","_id":"cjvop3biv000ds77reafvr70l"},{"name":"kettle","_id":"cjvop3bj0000is77rl7qvn2rk"},{"name":"分布式","_id":"cjvop3bjg0015s77rcwjjkb06"},{"name":"hbase","_id":"cjvop3bjj001ds77rjmnfkomm"},{"name":"大数据","_id":"cjvop3bjl001is77r0rm9ln1b"},{"name":"hadoop","_id":"cjvop3bjo001qs77rm6r173mw"},{"name":"分布式存储","_id":"cjvop3bjt0021s77r9ynlq5g6"},{"name":"实时分析","_id":"cjvop3bjy002ds77rbqfg9304"},{"name":"流式计算","_id":"cjvop3bk5002os77rfzq3mgk7"},{"name":"hive","_id":"cjvop3bkj0030s77rzg4xc9ul"},{"name":"数据分析","_id":"cjvop3bko003as77rsznqnrbl"},{"name":"java","_id":"cjvop3bkp003cs77rvo4f70tg"},{"name":"jdk源码","_id":"cjvop3bkq003is77rfos565l2"},{"name":"java基础","_id":"cjvop3bkr003os77rjbo52tjb"},{"name":"linux","_id":"cjvop3bku0042s77regkak5qd"},{"name":"网络","_id":"cjvop3bkv0047s77rbxqcva9k"},{"name":"oracle","_id":"cjvop3bky004ks77rffxijafy"},{"name":"数据库","_id":"cjvop3bkz004os77rs2nf2hbf"},{"name":"spark","_id":"cjvop3bl20056s77rgwoeky24"},{"name":"spring","_id":"cjvop3bl3005es77rjb9jjhli"},{"name":"异常","_id":"cjvop3bl4005hs77reyyhbuut"},{"name":"tomcat","_id":"cjvop3bl4005ns77rckd3fc3i"},{"name":"负载均衡","_id":"cjvop3bl6005vs77rh1z8j2fx"},{"name":"tools.博客","_id":"cjvop3bl80068s77rhny2xftm"},{"name":"网络安全","_id":"cjvop3blc006js77rlc8b9nwb"},{"name":"安全小组","_id":"cjvop3bld006ps77rrgo99x2e"},{"name":"服务","_id":"cjvop3ble006ss77rapcz49f6"},{"name":"软件工程","_id":"cjvop3blf006xs77rc7kktsng"},{"name":"算法","_id":"cjvop3blf0071s77rve6vtaz9"},{"name":"设计模式","_id":"cjvop3bli007gs77rjtlmla43"},{"name":"模型设计","_id":"cjvop3bli007ls77ro85sppoj"},{"name":"写作","_id":"cjvop3blo008as77runfbbv9y"},{"name":"广告","_id":"cjvop3blo008gs77r9p0pbthe"},{"name":"方法论","_id":"cjvop3blp008ms77rc865jyhi"},{"name":"分布式计算","_id":"cjvop3bmd009ms77r5ydnhuom"},{"name":"数据仓库","_id":"cjvop3bmi009us77r2mnue8zn"},{"name":"数据采集","_id":"cjvop3bmk00a0s77r78zsrnfy"},{"name":"jms","_id":"cjvop3bml00a5s77rndedu3uk"},{"name":"管理驾驶舱设计","_id":"cjvop3bmm00abs77rfugmnn94"},{"name":"Presto","_id":"cjvop3boz00ars77rehr0dlkx"},{"name":"tools.emacs","_id":"cjvop3bp400azs77rcwt63nzb"},{"name":"tools.vim","_id":"cjvop3bp600b3s77rmr55840w"},{"name":"angular.js","_id":"cjvop3bp700b7s77rz3dcpvvo"},{"name":"react.js","_id":"cjvop3bp800bcs77rlhzvvjiy"},{"name":"kylin","_id":"cjvop3bpp00bxs77rds94s5v0"},{"name":"review","_id":"cjvop3bpq00bzs77rmhllu01e"},{"name":"读书","_id":"cjvop3bqg00cms77rov5brhdr"}]}}