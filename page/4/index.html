<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.2.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=6.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=6.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.2.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="中起之星">
<meta property="og:url" content="http://cenrise.com/page/4/index.html">
<meta property="og:site_name" content="中起之星">
<meta property="og:description" content="个人博客">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="中起之星">
<meta name="twitter:description" content="个人博客">






  <link rel="canonical" href="http://cenrise.com/page/4/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>中起之星</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">中起之星</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">Cenrise</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cenrise.com/2017/04/16/hadoop/Hadoop之分布式存储/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongpo.jia">
      <meta itemprop="description" content="个人博客">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="中起之星">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/16/hadoop/Hadoop之分布式存储/" itemprop="url">
                  分布式存储
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-04-16 23:43:49" itemprop="dateCreated datePublished" datetime="2017-04-16T23:43:49+08:00">2017-04-16</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-08-18 09:44:35" itemprop="dateModified" datetime="2017-08-18T09:44:35+08:00">2017-08-18</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/分布式/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/分布式/分布式存储/" itemprop="url" rel="index"><span itemprop="name">分布式存储</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##Bigtable<br>Bigtable是非关系型数据库，是一个稀疏的、分布式的、持久化存储的多维度排序map。Bigtable设计的目的是快速且可靠地处理PB级别的数据，并且能够部署到上千台机器上。</p>
<p>Bigtable是闭源的，Cloud Bigtable是Google提供的大数据存储云服务。业界相关的Bigtable模型的开源实现为Apache HBase。</p>
<p>##HBase<br>HBase是一个高可靠、高性能、面向列、可伸缩的分布式存储系统，利用HBase技术可以在廉价PC上搭建起大规模结构化存储集群。<br>HBase是Google Bigtable的开源实现，类似于Google Bigtable利用GFS作为其文件存储系统，HBase利用Hadoop HDFS作为其文件存储系统；Google运行MapRecue来处理Bigtable中的海量数据，HBase同样利用Hadoop MapRecue来处理HBase中的海量数据；Google Bigtable利用Chubby作为协同服务，HBase利用Zookeeper作为对应。</p>
<p>###特性：<br>强一致性读写：HBase不是“Eventual Consistentcy（最终一致性）”数据存储，这让它很适合高速计数聚合类任务；<br>自动分片（Automatic sharding）：HBase表通过region分布在集群中，数据增长时，region会自动分割并重新分布；<br>RegionServer自动故障转移<br>Hadoop/HDFS集成：HBase支持开箱即用HDFS作为它的分布式文件系统；<br>MapRecue：HBase通过MapRecue支持大并发处理；<br>Java客户端API：HBase支持易于使用的Java API进行编程访问;<br>Thrift/REST API：HBase也支持Thrift和Rest作为非Java前端访问；<br>Block Cache和Bloom Filter：对于大容量查询优化，HBase支持Block Cache和Bloom Filter;<br>运维管理：HBase支持JMX提供内置网页用于运维。</p>
<p>###HBase应用场景<br>HBase不适合所有场景。<br>首先，确信有足够多数据，如果有上亿或上千亿行数据，HBase是很好的备选。如果只有上千或上百万行，则用传统的RDBMS可能是更好的选择。因为所有数据如果只需要在一两个节点进行存储，会导致集群其他节点闲置。<br>其次，确信可以不依赖于RDBMS的额外特性。例如，列数据类型、第二索引、事务、高级查询语言等<br>最后，确保有足够的硬件。因为HDFS在小于5个数据节点时，基本上体现不出来它的优势。<br>虽然HBase能在单独的笔记本上运行良好，但这应仅当成是开发阶段的配置 。</p>
<p>###HBase的优点<br>列可以动态增加，并且列为空就不存储数据，节省存储空间；<br>HBase可以自动切分数据，使得数据存储自动具有水平扩展功能；<br>HBase可以提供高并发读写操作的支持；<br>与Hadoop MapRecue相结合有利于数据分析；<br>容错性；<br>版权免费；<br>非常灵活的模式设计（或者说没有固定模式的限制）；<br>可以跟Hive集成，使用类SQL查询；<br>自动故障转移；<br>客户端接口易于使用；<br>行级别原子性，即PUT操作一定是完全成功或者完全失败。</p>
<p>###HBase的缺点<br>不能支持条件查询，只支持按照row key来查询；<br>容易产生单点故障（在只使用一个HMaster的时候）；<br>不支持事务；<br>JOIN不是数据库层支持的，而需要用MapRecue；<br>只能在主键上索引和排序；<br>没有内置的身份和权限认证；</p>
<p>###HBase与Hadoop/HDFS的差异<br>HDFS是分布式文件系统，适合保存大文件。官方宣称它并非普通用途的文件系统，不提供文件的个别记录的快速查询。另一方面，HBase基于HDFS，并能够提供大表的记录快速查询和更新。HBase内部将数据放到索引好的“StoreFiles”存储文件中，以便提供高速查询，而存储文件位于HDFS中。</p>
<p>##Cassandra<br>Cassandra是Facebook于2008年7月在Google Code上开源的项目。Cassandra实现了Dynamo风格的副本复制模型和没有单点失效的架构，增加了更加强大的column family数据模型。</p>
<p>##Memcached<br>Memcached可以更好利用内存</p>
<p>##Redis<br>Redis是一个key-value模型的内在数据存储系统。</p>
<p>##MongoDB<br>MongoDB是一个介于关系型数据库和非关系性数据库之间的产品，是非关系型 数据库中功能最丰富、最像关系型 数据库的，旨在为Web应用提供可扩展的高性能数据存储解决方案。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cenrise.com/2017/04/15/kettle/Kettle插件架构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongpo.jia">
      <meta itemprop="description" content="个人博客">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="中起之星">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/15/kettle/Kettle插件架构/" itemprop="url">
                  Kettle插件架构
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-04-15 19:42:49" itemprop="dateCreated datePublished" datetime="2017-04-15T19:42:49+08:00">2017-04-15</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-08-18 09:44:35" itemprop="dateModified" datetime="2017-08-18T09:44:35+08:00">2017-08-18</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/开源项目/" itemprop="url" rel="index"><span itemprop="name">开源项目</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/开源项目/kettle/" itemprop="url" rel="index"><span itemprop="name">kettle</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Kettle插件体系"><a href="#Kettle插件体系" class="headerlink" title="#Kettle插件体系"></a>#Kettle插件体系</h1><p>最近公司内有业务系统到数据中心同步的升级改造需求，从各个业务系统收集增量数据到数据中心的数据仓库平台。因为开发周期短暂，需要快速的响应，开发出可用的产品，所以决定借鉴开源程序Kettle，开发一个文件解析组件，然后利用Kettle平台的大数据组件进行与数据中心大数据平台对接</p>
<p>数据同步部分是：业务系统（RDBMS）-&gt;Kettle(azkaban进行调度)-&gt;数据中心，因为Kettle的增量抽取组件经常出现数据不一致等问题，所以目前已更改为：业务系统（RDBMS）-&gt;OGG（CDC增量抽取）-&gt;数据中心的方式。</p>
<p>本文主要介绍如何扩展Kettle的功能，部分内容来自《Pentaho Kettle解决方案：使用PDI构建开源ETL解决方案》一书，推荐购买阅读。</p>
<h2 id="架构"><a href="#架构" class="headerlink" title="##架构"></a>##架构</h2><p>我们先看Kettle插件架构。<br> <img src="http://i.imgur.com/mLvXMuV.jpg" alt=""><br>从功能上看，Kettle内部的对象和外部插件没有任何区别。因为它们使用的API都是一样的，它们只是在运行时的加载方式不同。<br>从Kettle4以后，Kettle内部有一个插件注册系统，它负责加载各种内部和外部插件。插件有以下两个标识属性。<br><strong>插件类型</strong>：由PluginTypeInterface接口定义。例如StepPluginType、JobEntryPluginType、PartitionerPluginType和RepositoryPluginType。<br><strong>插件ID</strong>：这是一个字符串数组，用来唯一标识一个插件。因为旧的插件可以被新的插件代替，一个插件可以有多个ID。在大多数情况下，插件只使用一个单一的字符串，如TableInput是“表输入”步骤的ID，MYSQL是MySQL数据库类型的ID。<br>当Kettle环境初始化以后，插件注册系统首先加载所有的内部对象，Kettle读取下面的配置文件来加载内部对象，这些配置文件位于Kettle的.jar文件中。<br>     Kettle-steps.xml：内部转换步骤。<br>     Kettle-job-entries.xml：内部作业项。<br>     Kettle-partition-plugins.xml：内部分区类型。<br>     Kettle-database-types.xml：内部数据库类型。<br>     Kettle-repositories.xml：内部资源库类型。</p>
<p>插件注册系统加载了所有的内部对象后，就要搜索可用的外部插件。通过浏览plugins/目录的各个子目录下的.jar文件来完成。它搜索特定的Kettle annotations来判断一个类是否是插件。加载过程将在本章的后面介绍。<br>因为在内部对象加载后才加载插件，所以插件会替代相同ID的已加载的内部对象。例如，你创建了插件，插件的ID是TableInput，就可以替换Kettle标准的“表输入”步骤。这个功能可以让你用插件替换Kettle内置的步骤。可以通过子类继承方式，直接扩展已有步骤的某些功能。</p>
<h2 id="插件类型"><a href="#插件类型" class="headerlink" title="##插件类型"></a>##插件类型</h2><p>Kettle有下面几种插件类型（下面的插件是Kettle4.0的插件类型，新版kettle包含了很多新的插件，比如视图插件、大数据插件等等）。</p>
<ul>
<li>转换步骤插件：在Kettle转换中使用的步骤，用来处理数据行。</li>
</ul>
<ul>
<li>作业项插件：在Kettle作业中使用的作业项，用来实现某个任务。</li>
</ul>
<ul>
<li>分区方法插件：利用输入字段的值指定自己的分区规则。</li>
</ul>
<ul>
<li>数据库类型插件：用来扩展不同的数据库类型。</li>
</ul>
<ul>
<li>资源库类型插件：可以把Kettle元数据保存为自定义类型或格式。</li>
</ul>
<p>说明：除了这些类型，还有Spoon类型的插件，可以把功能扩展到Spoon，本书不介绍这个功能。</p>
<h2 id="转换步骤插件"><a href="#转换步骤插件" class="headerlink" title="##转换步骤插件"></a>##转换步骤插件</h2><p>转换步骤插件包括了四个Java类，这四个类分别实现四个接口。</p>
<ul>
<li>StepMetaInterface：这个接口对外 提供步骤的元数据并处理串行化。</li>
</ul>
<ul>
<li>StepInterface:这个接口根据上面接口提供的元数据，来实现步骤的具体功能。</li>
</ul>
<ul>
<li>StepDataInterface:这个接口用来存储步骤的临时数据、文件句柄等。</li>
</ul>
<ul>
<li>StepDialogInterface:这个接口是Spoon里的图形界面，用来编辑步骤的元数据。</li>
</ul>
<p>接下来，我们介绍这些接口的基本内容。对于每个接口，在一个简单的“Hello World”例子里提供这些类的相应实现。“Hello World”例子将在数据流里增加一个字段，字段名用户可以自定义，字段值是”Hello world!“。最后介绍一下如何部署这个例子。</p>
<h3 id="StepMetaInterface"><a href="#StepMetaInterface" class="headerlink" title="###StepMetaInterface"></a>###StepMetaInterface</h3><p>接口org.pentaho.di.trans.step.StepMetaInterface负责步骤里所有和元数据相关的任务。和元数据相关的工作包括：<br>元数据和XML(或资源库)之间的序列化和反序列化<br>getXML（）和loadXML()<br>saveRep()和readRep()  </p>
<p>描述输出字段<br>getFields()  </p>
<p>检验元数据是否正确<br>Check()  </p>
<p>获取步骤相应的要SQL语句，使步骤可以正确运行<br>getSQLStatements()  </p>
<p>给元数据设置默认值<br>setDefault()  </p>
<p>完成对数据库的影响分析<br>analyseImpact()  </p>
<p>描述各类输入和输出流<br>getStepIOMeta()<br>searchInfoAndTargetSteps()<br>handleStreamSelection()<br>getOptionalStreams()<br>resetStepIoMeta()  </p>
<p>导出元数据资源<br>exportResources()<br>getResourceDependencies()  </p>
<p>描述使用的库<br>getUsedLibraries()  </p>
<p>描述使用的数据库连接<br>getUsedDatabaseConnections()  </p>
<p>描述这个步骤需要的字段（通常是一个数据库表）<br>getRequiredFields()  </p>
<p>描述步骤是否具有某些功能<br>supportsErrorHandling()<br>excludeFromRowLayoutVerification()<br>excludeFromCopyDistributeVerification()  </p>
<p>这个接口里还定义了几个方法来说明这四个接口如何结合到一起。<br>String getDialogClassName():用来描述实现了StepDialogInterface接口的对话框类的名字。如果这个方法返回了null，调用类会根据实现了StepMetaInterface接口的类的类名和包名来自动生成对话框类的名字。<br>SetpInterface getStep():创建一个实现了StepInterface接口的类。<br>StepDataInterface getStepData():创建一个实现了StepDataInterface接口的类。<br>现在我们看看”Hello World”例子里对SetpMetaInterface接口的实现<br>HelloworldStepMeta.java<br>    package org.kettlesolutions.plugin.step.helloworld;</p>
<pre><code>import java.util.List;
import java.util.Map;

import org.pentaho.di.core.CheckResult;
import org.pentaho.di.core.CheckResultInterface;
import org.pentaho.di.core.Const;
import org.pentaho.di.core.Counter;
import org.pentaho.di.core.annotations.Step;
import org.pentaho.di.core.database.DatabaseMeta;
import org.pentaho.di.core.exception.KettleException;
import org.pentaho.di.core.exception.KettleStepException;
import org.pentaho.di.core.exception.KettleXMLException;
import org.pentaho.di.core.row.RowMetaInterface;
import org.pentaho.di.core.row.ValueMeta;
import org.pentaho.di.core.row.ValueMetaInterface;
import org.pentaho.di.core.variables.VariableSpace;
import org.pentaho.di.core.xml.XMLHandler;
import org.pentaho.di.i18n.BaseMessages;
import org.pentaho.di.repository.ObjectId;
import org.pentaho.di.repository.Repository;
import org.pentaho.di.trans.Trans;
import org.pentaho.di.trans.TransMeta;
import org.pentaho.di.trans.step.BaseStepMeta;
import org.pentaho.di.trans.step.StepDataInterface;
import org.pentaho.di.trans.step.StepInterface;
import org.pentaho.di.trans.step.StepMeta;
import org.pentaho.di.trans.step.StepMetaInterface;
import org.w3c.dom.Node;

@Step(
        id=&quot;Helloworld&quot;,
        name=&quot;name&quot;,
        description=&quot;description&quot;,
        categoryDescription=&quot;categoryDescription&quot;, 
        image=&quot;org/kettlesolutions/plugin/step/helloworld/HelloWorld.png&quot;,
        i18nPackageName=&quot;org.kettlesolutions.plugin.step.helloworld&quot;
) 
public class HelloworldStepMeta extends BaseStepMeta implements StepMetaInterface {
    /**
     * PKG变量说明了messages包的位置，在messages包里有各种国际化的资源文件。
     * 在本章后面经常要看到的BaseMessages.getString()方法，就是根据软件的国际化
     * 设置，从不同的文件中获取文字。PKG变量通常位于类的最上方，被国际化图形工具使用，
     * 通过国际化图形工具，国际化人员可以编辑不同的国际化资源文件。所以我们会在很多Kettle
     * 代码里看见这样的结构。
     */
    private static Class&lt;?&gt; PKG = HelloworldStep.class; //for i18n
    public enum Tag {//field_name用于保存用户输入的字段名：保存“Hello，world！&quot;字符串的字段名。
        field_name,
    };

    private String fieldName;

    /**
     * @return the fieldName
     */
    public String getFieldName() {
        return fieldName;
    }

    /**
     * @param fieldName the fieldName to set
     */
    public void setFieldName(String fieldName) {
        this.fieldName = fieldName;
    }

    /**
     * checks parameters, adds result to List&lt;CheckResultInterface&gt;
     * used in Action &gt; Verify transformation
     * 验证用户是否在对话框里输入了字段名，并把验证结果添加到检验转换时出现的问题列表里。（最好
     * 要检验用户输入的所有选项，而不只是容易出错的选项）
     */
    public void check(List&lt;CheckResultInterface&gt; remarks, TransMeta transMeta, StepMeta stepMeta, 
            RowMetaInterface prev, String input[], String output[], RowMetaInterface info) {

        if (Const.isEmpty(fieldName)) {
            CheckResultInterface error = new CheckResult(
                CheckResult.TYPE_RESULT_ERROR, 
                BaseMessages.getString(PKG, &quot;HelloworldMeta.CHECK_ERR_NO_FIELD&quot;), 
                stepMeta
            );
            remarks.add(error);
        } else {
            CheckResultInterface ok = new CheckResult(
                CheckResult.TYPE_RESULT_OK, 
                BaseMessages.getString(PKG, &quot;HelloworldMeta.CHECK_OK_FIELD&quot;), 
                stepMeta
            );
            remarks.add(ok);//把验证结果添加到检验转换时出现的问题列表里。
        }
    }

    /**
     *    creates a new instance of the step (factory)
     * getStep、getStepData和getDialogClassName()方法提供了与这个步骤里其它三个接口之间的桥梁
     这个接口里还定义了几个方法来说明这四个接口如何结合到一起。
    String getDialogClassName():用来描述实现了StepDialogInterace接口的对话框类的名字。如果这个方法返回
                了null，调用类会根据实现了StepMetaInterface接口的类的类名和包名来自动生成对话框类的名字。
    StepInterface getStep():创建一个实现了StepInterface接口的类。
    StepInterface getStepData():创建一个实现了StepDataInterface接口的类。

     */
    public StepInterface getStep(StepMeta stepMeta, StepDataInterface stepDataInterface,
            int copyNr, TransMeta transMeta, Trans trans) {
        return new HelloworldStep(stepMeta, stepDataInterface, copyNr, transMeta, trans);
    }

    /**
     * creates new instance of the step data (factory)
     * getStep、getStepData和getDialogClassName()方法提供了与这个步骤里其它三个接口之间的桥梁
     */
    public StepDataInterface getStepData() {
        return new HelloworldStepData();
    }
    /**
     * getStep、getStepData和getDialogClassName()方法提供了与这个步骤里其它三个接口之间的桥梁
     */
    @Override
    public String getDialogClassName() {
        return HelloworldStepDialog.class.getName();
    }

    /**
     * deserialize from xml 
     * databases = list of available connections
     * counters = list of sequence steps
     * 
     * 下面的四个方法loadXML()、getXML()、readRep()和saveRep()把元数据保存到XML文件或资源库里，
     * 或者从XML文件或资源库读取元数据。保存到文件的方法利用了像XStream（http://xstream.codehaus.org）这
     * 样的XML串行化技术。
     */
    public void loadXML(Node stepDomNode, List&lt;DatabaseMeta&gt; databases,
            Map&lt;String, Counter&gt; sequenceCounters) throws KettleXMLException {
        fieldName = XMLHandler.getTagValue(stepDomNode, Tag.field_name.name());
    }

    /**
     * @Override
     */
    public String getXML() throws KettleException {
        StringBuilder xml = new StringBuilder();
        xml.append(XMLHandler.addTagValue(Tag.field_name.name(), fieldName));
        return xml.toString();
    }

    /**
     * De-serialize from repository (see loadXML)
     */
    public void readRep(Repository repository, ObjectId stepIdInRepository,
            List&lt;DatabaseMeta&gt; databases, Map&lt;String, Counter&gt; sequenceCounters)
            throws KettleException {
        fieldName = repository.getStepAttributeString(stepIdInRepository, Tag.field_name.name());
    }

    /**
     * serialize to repository
     */
    public void saveRep(Repository repository, ObjectId idOfTransformation, ObjectId idOfStep)
            throws KettleException {
        repository.saveStepAttribute(idOfTransformation, idOfStep, Tag.field_name.name(), fieldName);
    }


    /**
     * initiailize parameters to default
     */
    public void setDefault() {
        fieldName = &quot;helloField&quot;;
    }

    /**
     * getFields()方法非常重要，因为它描述了输出数据行的结构。这个方法需要修改inputRowMeta对象，使这个对象和
     * 输出格式匹配。Spoon和后面的步骤都需要知道这个步骤要输出哪些字段。最常见的一种方法，可以给输出的RowMetaInterface对象
     * 添加一个ValueMetaInterface对象。在ValueMetaInterface对象里设置的信息越详细越好，可以设置的信息包括数据类型、长度、
     * 精度、格式掩码，等等。添加的字段描述元信息越多，后面生成的SQL就越准确。
     */
    @Override
    public void getFields(RowMetaInterface inputRowMeta, String name,
            RowMetaInterface[] info, StepMeta nextStep, VariableSpace space)
            throws KettleStepException {
        String realFieldName = space.environmentSubstitute(fieldName);
        //值的元数据使用ValueMetaInterface接口描述数据流里的一个字段。这个接口里定义了字段的名字、数据类型、长度、精度，等等。下面的例子用于创建一个ValueMetaInterface对象。
        ValueMetaInterface field = new ValueMeta(realFieldName, ValueMetaInterface.TYPE_STRING);
        field.setOrigin(name);        
        inputRowMeta.addValueMeta(field);
    }
}
</code></pre><p>代码解析<br>    @Step(<br>            id=”Helloworld”,<br>            name=”name”,<br>            description=”description”,<br>            categoryDescription=”categoryDescription”,<br>            image=”org/kettlesolutions/plugin/step/helloworld/HelloWorld.png”,<br>            i18nPackageName=”org.kettlesolutions.plugin.step.helloworld”<br>    )<br>这段代码里的@Step annotation用来通知Kettle的插件注册系统：这个类是一个步骤类型的插件。在annotation里可以指定插件的ID、图标、国际代的包、本地化的名称、类别、描述。其中后三项是资源文件里的Key，需要在资源文件里设置真正的值。i18nPackageName指定了资源文件的包名，例如我们这个例子的资源文件位于org/kettlesolutions/plugin/step/helloworld/messages目录下，en_US（英语，美国）的本地代资源文件是messages_en_US.properties。我们例子里的这个资源文件的内容是：<br>name=Hello world<br>description=A very simple step that adds a new “Helllo world” field to the incoming stream<br>注意，如果你指定了不存在的分类，Spoon会创建这个分类，并在Spoon的分类树的最上方显示这个分类。<br>最后，annotation里的image标签指定了插件的图标。需要32*32像素的PNG文件，可以使用透明样式。<br>后面的代码行说明这个类实现了StepMetaInterface接口。在BaseStepMeta抽象类里定义了这个接口的很多默认实现，可以直接继承这个抽象类，然后把工作集中在插件特有的功能上。</p>
<pre><code>public class HelloworldStepMeta extends BaseStepMeta implements StepMetaInterface
</code></pre><p>下面的四个方法loadXML()、getXML()、readRep()和saveRep()把元数据保存到XML文件或资源库里，或者从XML文件或资源库读取元数据。保存到文件的方法利用了像XStream（<a href="http://xstream.codehaus.org）这样的XML串行化技术。" target="_blank" rel="noopener">http://xstream.codehaus.org）这样的XML串行化技术。</a></p>
<p>getFields()方法非常重要，因为它描述了输出数据行的结构。这个方法需要修改inputRowMeta对象，使这个对象和输出格式匹配。Spoon和后面的步骤都需要知道这个步骤要输出哪些字段。最常见的一种方法，可以给输出的RowMetaInterface对象添加一个ValueMetaInterface对象。在ValueMetaInterface对象里设置的信息越详细越好，可以设置的信息包括数据类型、长度、精度、格式掩码，等等。添加的字段描述元信息越多，后面生成的SQL就越准确。</p>
<h4 id="值的元数据（Value-Metadata）"><a href="#值的元数据（Value-Metadata）" class="headerlink" title="####值的元数据（Value Metadata）"></a>####值的元数据（Value Metadata）</h4><p>值的元数据使用ValueMetaInterface接口描述数据流里的一个字段。这个接口里定义了字段的名字、数据类型、长度、精度，等等。下面的例子用于创建一个ValueMetaInterface对象。<br>    ValueMetaInterface dateMeta = new ValueMeta(“birthdate”,ValueMetaInterface.TYPE_DATE);<br>这个接口也负责转换数据格式。我们建议使用ValueMetaInterface接口来完成所有数据转换的工作。例如，日期类型的数据，如果想把它转换为dateMeta对象里定义的字符串格式，可以用下面的代码：<br>    //java.util.Date birthdate<br>    String birthDateString = dateMeta.getString(birthdate);<br>ValueMeta类负责转换。因为有ValueMetaInterface进行数据类型的转换，所以你不用再去做额外的数据类型转换的工作。<br>使用ValueMetaInterface接口时还要注意数据对象是否为Null。从上一个步骤可以接收到一个数据对象和一个描述数据对象的ValueMetaInterface对象。我们要检查这个数据对象是否为null，在某些情况下如果数据对象为空是不正确的。例如：<br>数据对象是String类型，有10个空格，Value Metadata需要trim这个字符串。<br>在Value Metadata里已经定义了从文本文件里加载的数据，要延迟转换为字符串。所以数据要由二进制的格式（原始数据格式），转换为字符串格式，然后再转换为其它格式的数据。<br>一般使用下面的方法检查数据对象是否为空：<br>    Boolean n = valueMeta.isNull(valueDate);<br>重要：要保证传给ValueMetaInterface对象的数据是在元数据里定义的数据类型。表23-1说明了  ValueMetaInterface里定义的数据类型和Java数据类型的对应关系。<br>Kettle元数据类型和Java里数据类型的对应关系  </p>
<table><br>    <tr><br>        <th>Value Meta Type</th><br>        <th>Java Class</th><br>    </tr><br>    <tr><br>        <td>ValueMetaInterface.TYPE_STRING</td><br>        <td>Java.lang.String</td><br>    </tr><br>    <tr><br>        <td>ValueMetaInterface.TYPE_DATE</td><br>        <td>Java.util.Date</td><br>    </tr><br>    <tr><br>        <td>ValueMetaInterface.TYPE_BOOLEAN</td><br>        <td>Java.lang.Boolean</td><br>    </tr><br>    <tr><br>        <td>ValueMetaInterface.TYPE_NUMBER</td><br>        <td>Java.lang.Double</td><br>    </tr><br>    <tr><br>        <td>ValueMetaInterface.TYPE_INTEGER</td><br>        <td>Java.lang.Long</td><br>    </tr><br>    <tr><br>        <td>ValueMetaInterface.TYPE_BIGNUMBER</td><br>        <td>Java.math.BigDecimal</td><br>    </tr><br>    <tr><br>        <td>ValueMetaInterface.TYPE_BINARY</td><br>        <td>Byte[]</td><br>    </tr><br></table>


<h4 id="行的元数据（Row-Meatadata）"><a href="#行的元数据（Row-Meatadata）" class="headerlink" title="####行的元数据（Row Meatadata）"></a>####行的元数据（Row Meatadata）</h4><p>行的元数据使用RowMetaInterface接口来描述数据行的元数据，而不是一个列的元数据。实际上，RowMetaInterface的类里包含了一组ValueMetaInterface。另外还包括了一些方法来操作行元数据，倒如查询值、检查值是否存、替换值的元数据等。<br>行的元数据里唯一的规则就是一行里的列的名字必须唯一。当你添加了一个新列时，如果新列的名字和已有列的名字相同，列名后面会自动加上“_2”后缀。如果再加一个同名的列会自动加上”_3“后缀，等等。<br>因为在步骤里通常是和数据行打交道，所以从数据行里直接取数据会更方便。可以使用很多类似于getNumber()、getString()这样的方法直接从数据行取数据。例如，销售数据存储在第四列里，可以用下面的代码获取这个数据：  </p>
<pre><code>Double sales = getInputRowMeta().getNumber(rowData,3);
</code></pre><p>通过索引获取数据是最快的方式。通过indexOfValue()方法可以获取列在一行里的索引。这个方法扫描列数组，速度并不快。所以，如果要处理所有数据行，我们建议只查询一次列索引。一般是在步骤接收到第一行数据时，就查询列索引，将查询到的列索引保存起来，供后面的数据行使用。  </p>
<h3 id="StepDatainterface"><a href="#StepDatainterface" class="headerlink" title="###StepDatainterface"></a>###StepDatainterface</h3><p>实现了org.pentaho.di.trans.step.StepDataInterface接口的类用来维护步骤的执行状态，以及存储临时对象。例如，可以把输出行的元数据、数据库连接、输入输出流等存储到这个对象里。<br>HelloworldStepData.java<br>    package org.kettlesolutions.plugin.step.helloworld;</p>
<p>import org.pentaho.di.core.row.RowMetaInterface;<br>import org.pentaho.di.trans.step.BaseStepData;<br>import org.pentaho.di.trans.step.StepDataInterface;</p>
<p>public class HelloworldStepData extends BaseStepData implements StepDataInterface {</p>
<pre><code>public RowMetaInterface outputRowMeta;
</code></pre><p>}</p>
<h3 id="StepDialogInterface"><a href="#StepDialogInterface" class="headerlink" title="###StepDialogInterface"></a>###StepDialogInterface</h3><p>实现org.pentaho.di.trans.step.StepDialogInterfac接口的类用来提供一个用户界面，用户通过这个界面输入元数据（转换参数）。用户界面就是一个对话框。这个接口里包含了类似open()和setRepository()等的几个简单的方法。    </p>
<h4 id="Eclipse-SWT"><a href="#Eclipse-SWT" class="headerlink" title="####Eclipse SWT"></a>####Eclipse SWT</h4><p>Kettle里使用Eclipse SWT作为界面开发包，所以你也要使用SWT来开发对话框窗口。SWT为不同的操作系统Windows、OS X、Linux和Unix提供了一个抽象层。所以SWT的图形界面和操作系统期货的程序的界面风格非常相近。<br>在开始进行SWT开发之前，建议先访问SWT主面以了解更多的内容<a href="http://www.eclipse/org/swt。在SWT的网站上，你可以了解到SWT能做出什么样的界面效果：" target="_blank" rel="noopener">http://www.eclipse/org/swt。在SWT的网站上，你可以了解到SWT能做出什么样的界面效果：</a><br>SWT控件页，<a href="http://www.eclipse.org/swt/widgets/，给出了你能使用的所有控件。" target="_blank" rel="noopener">http://www.eclipse.org/swt/widgets/，给出了你能使用的所有控件。</a><br>SWT样例页，<a href="http://www.eclipse.org/swt/snippets/，给出了许多代码例子。" target="_blank" rel="noopener">http://www.eclipse.org/swt/snippets/，给出了许多代码例子。</a><br>最好的资源就是Kettle里150个内置步骤的对话框源代码。  </p>
<p>HelloworldStepDialog.java<br>    package org.kettlesolutions.plugin.step.helloworld;</p>
<pre><code>import org.eclipse.swt.SWT;
import org.eclipse.swt.events.ModifyEvent;
import org.eclipse.swt.events.ModifyListener;
import org.eclipse.swt.events.SelectionAdapter;
import org.eclipse.swt.events.SelectionEvent;
import org.eclipse.swt.events.ShellAdapter;
import org.eclipse.swt.events.ShellEvent;
import org.eclipse.swt.layout.FormAttachment;
import org.eclipse.swt.layout.FormData;
import org.eclipse.swt.layout.FormLayout;
import org.eclipse.swt.widgets.Button;
import org.eclipse.swt.widgets.Control;
import org.eclipse.swt.widgets.Display;
import org.eclipse.swt.widgets.Event;
import org.eclipse.swt.widgets.Label;
import org.eclipse.swt.widgets.Listener;
import org.eclipse.swt.widgets.Shell;
import org.eclipse.swt.widgets.Text;
import org.pentaho.di.core.Const;
import org.pentaho.di.i18n.BaseMessages;
import org.pentaho.di.trans.TransMeta;
import org.pentaho.di.trans.step.BaseStepMeta;
import org.pentaho.di.trans.step.StepDialogInterface;
import org.pentaho.di.ui.core.widget.TextVar;
import org.pentaho.di.ui.trans.step.BaseStepDialog;

public class HelloworldStepDialog extends BaseStepDialog implements
        StepDialogInterface {

    private static Class&lt;?&gt; PKG = HelloworldStepMeta.class; // for i18n
                                                            // purposes, needed
                                                            // by Translator2!!
                                                            // $NON-NLS-1$

    private HelloworldStepMeta input;

    private TextVar wFieldname;

    public HelloworldStepDialog(Shell parent, Object baseStepMeta,
            TransMeta transMeta, String stepname) {
        //初始化元数据对象以及步骤对话框的父类
        super(parent, (BaseStepMeta) baseStepMeta, transMeta, stepname);
        input = (HelloworldStepMeta) baseStepMeta;
    }

    public String open() {
        Shell parent = getParent();
        Display display = parent.getDisplay();

        shell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MIN
                | SWT.MAX);
        props.setLook(shell);
        setShellImage(shell, input);

        ModifyListener lsMod = new ModifyListener() {
            public void modifyText(ModifyEvent e) {
                input.setChanged();
            }
        };
        changed = input.hasChanged();

        FormLayout formLayout = new FormLayout();
        formLayout.marginWidth = Const.FORM_MARGIN;
        formLayout.marginHeight = Const.FORM_MARGIN;

        shell.setLayout(formLayout);
        shell.setText(BaseMessages.getString(PKG,
                &quot;HelloworldDialog.Shell.Title&quot;)); //$NON-NLS-1$

        //所有控件的右侧使用一个自定义的百分对对齐。控件之间的间距使用一个常量，常量值是4像素。
        int middle = props.getMiddlePct();
        int margin = Const.MARGIN;

        // Stepname line
        wlStepname = new Label(shell, SWT.RIGHT);
        wlStepname.setText(BaseMessages.getString(PKG,
                &quot;HelloworldDialog.Stepname.Label&quot;)); //$NON-NLS-1$
        props.setLook(wlStepname);
        fdlStepname = new FormData();
        fdlStepname.left = new FormAttachment(0, 0);
        fdlStepname.right = new FormAttachment(middle, -margin);
        fdlStepname.top = new FormAttachment(0, margin);
        wlStepname.setLayoutData(fdlStepname);
        wStepname = new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);
        wStepname.setText(stepname);
        props.setLook(wStepname);
        wStepname.addModifyListener(lsMod);
        fdStepname = new FormData();
        fdStepname.left = new FormAttachment(middle, 0);
        fdStepname.top = new FormAttachment(0, margin);
        fdStepname.right = new FormAttachment(100, 0);
        wStepname.setLayoutData(fdStepname);
        Control lastControl = wStepname;

        // Fieldname line
        //创建一个新的标签控件，控件里文本靠右对齐
        Label wlFieldname = new Label(shell, SWT.RIGHT);
        wlFieldname.setText(BaseMessages.getString(PKG,
                &quot;HelloworldDialog.Fieldname.Label&quot;)); //$NON-NLS-1$
        //下面一行为控件设置用户定义的背景色和字体
        props.setLook(wlFieldname);
        FormData fdlFieldname = new FormData();
        fdlFieldname.left = new FormAttachment(0, 0);
        fdlFieldname.right = new FormAttachment(middle, -margin);
        fdlFieldname.top = new FormAttachment(lastControl, margin);
        wlFieldname.setLayoutData(fdlFieldname);
        wFieldname = new TextVar(transMeta, shell, SWT.SINGLE | SWT.LEFT
                | SWT.BORDER);
        props.setLook(wFieldname);
        wFieldname.addModifyListener(lsMod);
        FormData fdFieldname = new FormData();
        fdFieldname.left = new FormAttachment(middle, 0);
        fdFieldname.top = new FormAttachment(lastControl, margin);
        fdFieldname.right = new FormAttachment(100, 0);
        wFieldname.setLayoutData(fdFieldname);
        lastControl = wFieldname;

        // Some buttons
        wOK = new Button(shell, SWT.PUSH);
        wOK.setText(BaseMessages.getString(PKG, &quot;System.Button.OK&quot;)); //$NON-NLS-1$
        wCancel = new Button(shell, SWT.PUSH);
        wCancel.setText(BaseMessages.getString(PKG, &quot;System.Button.Cancel&quot;)); //$NON-NLS-1$

        setButtonPositions(new Button[] { wOK, wCancel }, margin, lastControl);

        // Add listeners
        lsCancel = new Listener() {
            public void handleEvent(Event e) {
                cancel();
            }
        };
        lsOK = new Listener() {
            public void handleEvent(Event e) {
                ok();
            }
        };

        wCancel.addListener(SWT.Selection, lsCancel);
        wOK.addListener(SWT.Selection, lsOK);

        lsDef = new SelectionAdapter() {
            public void widgetDefaultSelected(SelectionEvent e) {
                ok();
            }
        };

        wStepname.addSelectionListener(lsDef);
        wFieldname.addSelectionListener(lsDef);

        // Detect X or ALT-F4 or something that kills this window...
        shell.addShellListener(new ShellAdapter() {//保证了窗口在非正常关闭时，取消用户的编辑
            public void shellClosed(ShellEvent e) {
                cancel();
            }
        });

        // Populate the data of the controls
        //下面的代码把数据从步骤的元数据对象里复制到窗口的控件里
        getData();

        // Set the shell size, based upon previous time...
        //窗口的大小和位置将根据窗口的自然属性、上次窗口大小和位置，以及显示屏的大小自动设置
        setSize();

        input.setChanged(changed);

        shell.open();
        while (!shell.isDisposed()) {
            if (!display.readAndDispatch())
                display.sleep();
        }
        return stepname;
    }

    /**
     * Copy information from the meta-data input to the dialog fields.
     */
    public void getData() {
        wStepname.selectAll();
        //为了防止用户向控件里输入空值，Kettle提供了一个静态方法来检查宿舍，Const.NVL()
        wFieldname.setText(Const.NVL(input.getFieldName(), &quot;&quot;));
    }

    private void cancel() {
        stepname = null;
        input.setChanged(changed);
        dispose();
    }
    //单击OK把控件里用户输入的数据都写入到步骤的元数据对象中。
    private void ok() {
        if (Const.isEmpty(wStepname.getText()))
            return;

        stepname = wStepname.getText(); // return value

        input.setFieldName(wFieldname.getText());

        dispose();
    }
}
</code></pre><h4 id="窗体布局"><a href="#窗体布局" class="headerlink" title="####窗体布局"></a>####窗体布局</h4><p>如果你看过步骤对话框的源代码，你就会发现窗体类里有很多烦琐的代码。这些代码确保Kettle可以在各种操作系统下以合适的方式展现窗体。可以发现窗体里的大部分代码都和布局以及控件位置有关。<br>FormLayout是SWT里经常看到的布局方式。程序员可以通过FormLayout指定控件的百分比、偏移。下面是我们例子里的窗口布局的代码（HelloworldStepDialog.java）<br>    //创建一个新的标签控件，控件里文本靠右对齐<br>    Label label = new Label(shell, SWT.RIGHT);<br>    label.setText(BaseMessages.getString(PKG,”HelloworldDialog.Fieldname.Label”)); //$NON-NLS-1$<br>    //下面一行为控件设置用户定义的背景色和字体<br>    props.setLook(label);<br>    /**</p>
<pre><code>* 下面几行将标签的左侧和对话框的最左侧对齐，把标签的右侧放在对话框中间（50%）的左侧10个像素
* 的位置。标签的顶部放在距离对话框顶部25个像素的位置。
*/
FormData fdLabel = new FormData();
fdlFieldname.left = new FormAttachment(0, 0);
fdlFieldname.right = new FormAttachment(50, -10);
fdlFieldname.top = new FormAttachment(0, 25);
wlFieldname.setLayoutData(fdLabel);  
</code></pre><p>简而言之，不要感到痛苦；图形用户界面的代码都比较烦琐，但代码并不复杂。  </p>
<h4 id="Kettle-UI元素"><a href="#Kettle-UI元素" class="headerlink" title="####Kettle UI元素"></a>####Kettle UI元素</h4><p>除了标准的SWT组件，还可以使用Kettle自带的一些控件，Kettle开发人员的工作可以更简单一些。Kettle自带的组件包括以下一些。<br>TableView：这是一个数据表格组件，支持排序、选择、键盘快捷键和撤销/重做，以及右键菜单。<br>TextVar：这是一个支持变量的文本输入框，这个输入框的右上角有一个$符号。用户可以通过”Ctrl  +Alt+空格”的方式，在弹出的下拉列表中选择变量。其他功能和普通的文本框相同。<br>ComboVar：标准的组合下拉列表，支持变量。<br>ConditionEditor：过滤行步骤里使用的输入条件控件。<br>另外还有很多常用的对话框帮你完成相应的工作，如下所示:<br>EnterListDialog:从字符串列表里选择一个或多个字符串。左侧显示字符串列表，右侧是选中的字符串，并提供把字符串从左侧移动到右侧的按钮。<br>EnterNumberDialog:用户可以输入数字<br>EnterPasswordDialog:让用户输入密码<br>EnterSelectionDialog:通过高亮显示，从列表里选择多项<br>EnterMappingDialog:输入两组字符串的映射<br>PreviewRowsDialog:在对话框里预览一组数据行。<br>SQLEditor:一个简单的SQL编辑器，可以输入查询和DDL.<br>ErrorDialog:显示异常信息，列出详细的错误栈对话框  </p>
<h4 id="Hello-World例子对话框"><a href="#Hello-World例子对话框" class="headerlink" title="####Hello World例子对话框"></a>####Hello World例子对话框</h4><p>现在我们已经基本了解了SWT以及对话框的布局方式，再看看我们的例子，下面的代码是HelloWorldStepDialog.java里的例子。<br>代码的第一部分是初始化元数据对象以及步骤对话框的父类：<br>    public class HelloworldStepDialog extends BaseStepDialog implements<br>            StepDialogInterface {<br>        private static Class&lt;?&gt; PKG = HelloworldStepMeta.class;<br>        private HelloworldStepMeta input;<br>        private TextVar wFieldname;<br>        public HelloworldStepDialog(Shell parent, Object baseStepMeta,<br>                TransMeta transMeta, String stepname) {<br>            //初始化元数据对象以及步骤对话框的父类<br>            super(parent, (BaseStepMeta) baseStepMeta, transMeta, stepname);<br>            input = (HelloworldStepMeta) baseStepMeta;<br>        }<br>在下面的open()方法里创建对话框里的所有控件。SWT使用事件监听模式，可以为控件创建各种监听方法，以响应控件内容的变化和用户的动作。<br>    public String open() {<br>            Shell parent = getParent();<br>            Display display = parent.getDisplay();<br>            shell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MIN<br>                    | SWT.MAX);<br>            props.setLook(shell);<br>            setShellImage(shell, input);<br>            ModifyListener lsMod = new ModifyListener() {<br>                public void modifyText(ModifyEvent e) {<br>                    input.setChanged();<br>                }<br>            };<br>            changed = input.hasChanged();</p>
<p>下面代码说明窗体里的控件将使用formLayout的布局方式：<br>    FormLayout formLayout = new FormLayout();<br>            formLayout.marginWidth = Const.FORM_MARGIN;<br>            formLayout.marginHeight = Const.FORM_MARGIN;<br>            shell.setLayout(formLayout);<br>所有控件的右侧使用一个自定义的百分比对齐：props.getMiddlePct()；控件之间的间距使用一个常量，常量值是4像素。<br>    shell.setLayout(formLayout);<br>            shell.setText(BaseMessages.getString(PKG,<br>                    “HelloworldDialog.Shell.Title”)); //$NON-NLS-1$<br>            int middle = props.getMiddlePct();<br>            int margin = Const.MARGIN;<br>下面的代码在对话框的最上面添加了一行步骤名称标签和输入文本框：<br>    // Stepname line<br>            wlStepname = new Label(shell, SWT.RIGHT);<br>            wlStepname.setText(BaseMessages.getString(PKG,<br>                    “HelloworldDialog.Stepname.Label”)); //$NON-NLS-1$<br>            props.setLook(wlStepname);<br>            fdlStepname = new FormData();<br>            fdlStepname.left = new FormAttachment(0, 0);<br>            fdlStepname.right = new FormAttachment(middle, -margin);<br>            fdlStepname.top = new FormAttachment(0, margin);<br>            wlStepname.setLayoutData(fdlStepname);<br>            wStepname = new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);<br>            wStepname.setText(stepname);<br>            props.setLook(wStepname);<br>            wStepname.addModifyListener(lsMod);<br>            fdStepname = new FormData();<br>            fdStepname.left = new FormAttachment(middle, 0);<br>            fdStepname.top = new FormAttachment(0, margin);<br>            fdStepname.right = new FormAttachment(100, 0);<br>            wStepname.setLayoutData(fdStepname);<br>            Control lastControl = wStepname;</p>
<p>下面是新增输出列的列名设置的输入框：<br>    // Fieldname line<br>        //创建一个新的标签控件，控件里文本靠右对齐<br>        Label wlFieldname = new Label(shell, SWT.RIGHT);<br>        wlFieldname.setText(BaseMessages.getString(PKG,<br>                “HelloworldDialog.Fieldname.Label”)); //$NON-NLS-1$<br>        //下面一行为控件设置用户定义的背景色和字体<br>        props.setLook(wlFieldname);<br>        FormData fdlFieldname = new FormData();<br>        fdlFieldname.left = new FormAttachment(0, 0);<br>        fdlFieldname.right = new FormAttachment(middle, -margin);<br>        fdlFieldname.top = new FormAttachment(lastControl, margin);<br>        wlFieldname.setLayoutData(fdlFieldname);<br>        wFieldname = new TextVar(transMeta, shell, SWT.SINGLE | SWT.LEFT<br>                | SWT.BORDER);<br>        props.setLook(wFieldname);<br>        wFieldname.addModifyListener(lsMod);<br>        FormData fdFieldname = new FormData();<br>        fdFieldname.left = new FormAttachment(middle, 0);<br>        fdFieldname.top = new FormAttachment(lastControl, margin);<br>        fdFieldname.right = new FormAttachment(100, 0);<br>        wFieldname.setLayoutData(fdFieldname);<br>        lastControl = wFieldname;</p>
<p>然后创建两个按钮，“确认”和“取消”按钮，以及按钮单击事件的监听方法，把按钮放在对话框的最下面：<br>    // Some buttons<br>        wOK = new Button(shell, SWT.PUSH);<br>        wOK.setText(BaseMessages.getString(PKG, “System.Button.OK”)); //$NON-NLS-1$<br>        wCancel = new Button(shell, SWT.PUSH);<br>        wCancel.setText(BaseMessages.getString(PKG, “System.Button.Cancel”)); //$NON-NLS-1$</p>
<pre><code>setButtonPositions(new Button[] { wOK, wCancel }, margin, lastControl);

// Add listeners
lsCancel = new Listener() {
    public void handleEvent(Event e) {
        cancel();
    }
};
lsOK = new Listener() {
    public void handleEvent(Event e) {
        ok();
    }
};
wCancel.addListener(SWT.Selection, lsCancel);
wOK.addListener(SWT.Selection, lsOK);
</code></pre><p>下面的代码做了两件事情，上部代码可以保证当步骤名称或输出字段名称的输入框在编辑状态时，单击“确定”按钮，正在编辑的内容不会丢失；下部的代码保证了窗口在非正常关闭时（没有使用“确定”或“取消”按钮关闭），取消用户的编辑。<br>    lsDef = new SelectionAdapter() {<br>            public void widgetDefaultSelected(SelectionEvent e) {<br>                ok();<br>            }<br>        };</p>
<pre><code>wStepname.addSelectionListener(lsDef);
wFieldname.addSelectionListener(lsDef);

// Detect X or ALT-F4 or something that kills this window...
shell.addShellListener(new ShellAdapter() {//保证了窗口在非正常关闭时，取消用户的编辑
    public void shellClosed(ShellEvent e) {
        cancel();
    }
});
</code></pre><p>下面的代码把数据从步骤的元数据对象里复制到窗口的控件里：<br>    // Populate the data of the controls<br>            getData();<br>窗口的大小和位置将根据窗口的自然属性、上次窗口大小和位置，以及显示屏的大小自动设置。<br>    // Set the shell size, based upon previous time…<br>            //窗口的大小和位置将根据窗口的自然属性、上次窗口大小和位置，以及显示屏的大小自动设置<br>            setSize();<br>            input.setChanged(changed);</p>
<pre><code>    shell.open();
    while (!shell.isDisposed()) {
        if (!display.readAndDispatch())
            display.sleep();
    }
    return stepname;
}
</code></pre><p>为了防止用户身控件里输入空值，Kettle提供了一个静态方法来检查空值，ConstNVL();<br>    /**</p>
<pre><code> * Copy information from the meta-data input to the dialog fields.
 */
public void getData() {
    wStepname.selectAll();
    wFieldname.setText(Const.NVL(input.getFieldName(), &quot;&quot;));
}
</code></pre><p>最后，单击OK按钮后，把控件里用户输入的数据都写入到步骤的元数据对象中：<br>    private void cancel() {<br>            stepname = null;<br>            input.setChanged(changed);<br>            dispose();<br>        }<br>        //单击OK把控件里用户输入的数据都写入到步骤的元数据对象中。<br>        private void ok() {<br>            if (Const.isEmpty(wStepname.getText()))<br>                return;</p>
<pre><code>    stepname = wStepname.getText(); // return value

    input.setFieldName(wFieldname.getText());

    dispose();
}
</code></pre><h3 id="StepInteface"><a href="#StepInteface" class="headerlink" title="###StepInteface"></a>###StepInteface</h3><pre><code>这个类实现了org.pentaho.di.trans.step.StepInterface接口，这个类读取上个步骤传来的数据行，利用StepMetaInterface对象里定义的元数据，逐行转换和处理上个步骤传来的数据行，Kettle引擎直接使用这个接口里的很多方法来执行转换过程，但大部分方法都已经由BaseStep类实现了，通常开发人员只需要重载其中的几个方法。
Init():步骤初始化方法，用来初始化一个步骤。初始化结果是一个true或者false的Boolean值。如果你的步骤没有任何初始化的工作，可以不用重载这个方法。
Dispose():如果有需要释放的资源，可以在dispose()方法里释放，例如可以关闭数据库连接、释放文件、清除缓存等。在转换的最后Kettle引擎会调用这个方法。如果没有需要释放或清除的资源，可以不用重载这个方法。
processRow():这个方法，是步骤实现工作的地方。只要这个方法返回true，转换引擎就会重复调用这个方法。
</code></pre><p>下面是HellWorld例子实现的StepInterface接口（HelloworldStep.java）</p>
<p>HelloworldStep.java<br>    package org.kettlesolutions.plugin.step.helloworld;</p>
<pre><code>import org.pentaho.di.core.exception.KettleException;
import org.pentaho.di.core.row.RowDataUtil;
import org.pentaho.di.trans.Trans;
import org.pentaho.di.trans.TransMeta;
import org.pentaho.di.trans.step.BaseStep;
import org.pentaho.di.trans.step.StepDataInterface;
import org.pentaho.di.trans.step.StepInterface;
import org.pentaho.di.trans.step.StepMeta;
import org.pentaho.di.trans.step.StepMetaInterface;
/**
 * BaseStep抽象类已经实现了接口里的很多方法，我们只要覆盖需要修改的方法即可。
 * @author Administrator
 *
 */
public class HelloworldStep extends BaseStep implements StepInterface {
    /**
     * 类的构造函数通常直接把参数传递给BaseStep父类。由父类里的方法来构造对象，然后可以直接
     * 使用类似transMeta这样的对象。
     * @param stepMeta
     * @param stepDataInterface
     * @param copyNr
     * @param transMeta
     * @param trans
     */
    public HelloworldStep(StepMeta stepMeta, StepDataInterface stepDataInterface,
            int copyNr, TransMeta transMeta, Trans trans) {
        super(stepMeta, stepDataInterface, copyNr, transMeta, trans);
        // TODO Auto-generated constructor stub
    }


    public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException {

        HelloworldStepMeta meta  = (HelloworldStepMeta) smi;
        HelloworldStepData data = (HelloworldStepData) sdi;
        /**
         * getRow()方法从上一个步骤获取一行数据。如果没有更多要获取的数据行，这个方法就会返回null。
         * 如果前面的步骤不能及时提供数据，这个方法就会阻塞，直到有可用的数据行。这样这个步骤的速度就会降低，也会影响
         * 其它步骤的速度。
         */
        Object[] row = getRow();
        if (row==null) {
            /**
             * setOutputDone()方法用来通知其它的步骤，本步骤已经没有输出数据行。下一个步骤如果
             * 再调用getRow()方法就会返回null,转换也不再调用processRow()方法。
             */
            setOutputDone();
            return false;
        }

        if (first) {
            first=false;
            /**
             * 从性能上考虑，getRow()方法不提供数据行的元数据，只提供上个步骤输出的数据。可以使用getInputRowMeta()方法
            获取元数据，元数据只获取一次即可，所以在first代码块里获取元数据。
               如果要把数据传到下一个步骤，要使用putRow()方法。除了输出数据，还要输出RowMetaInterface元数据。
               第一行使用clone()方法把输入行的元数据结构复制给输出行。输出行的元数据结构是在输入行的基础上增加一个字段，但
               构造输出行的元数据结构只能构造一次，因为所有输出数据行的结构都是一样的，产生了输出行以后，元数据结构就不能再变化。
               所以输出行的元数据结构在first代码块里构造。first是一个内部成员，first代码块里的代码只在处理第一行数据时执行。
               下面代码的最后一行，给输出数据增加了一个字段。
             */
            data.outputRowMeta = getInputRowMeta().clone();
            meta.getFields(data.outputRowMeta, getStepname(), null, null, this);
        }
        /**
         * 下面的代码，把数据写入输出流。从性能角度考虑，数据行实现就是Java数组。为了开发方便，可以使用RowDataUtil类提供
         * 的一些静态方法来操作数据。使用RowDatautil静态方法复制数据，还可以提高性能。
         */
        String value = &quot;Hello, world!&quot;;

        Object[] outputRow = RowDataUtil.addValueData(row, getInputRowMeta().size(), value);

        putRow(data.outputRowMeta, outputRow);

        return true;
    }
}
</code></pre><p>解析：<br>public class HelloworldStep extends BaseStep implements StepInterface {<br>BaseStep抽象类已经实现了接口里的很多方法，我们只要覆盖需要修改的方法即可。<br>类的构造函数通常直接把参数传递给BaseStep父类。由父类里的方法来构造对象，然后可以直接使用类似transMeta这样的对象。<br>public HelloworldStep(StepMeta stepMeta, StepDataInterface stepDataInterface,<br>            int copyNr, TransMeta transMeta, Trans trans) {<br>        super(stepMeta, stepDataInterface, copyNr, transMeta, trans);<br>    }<br>getRow()方法从上一个步骤获取一行数据。如果没有更多要获取的数据行，这个方法就会返回null。如果前面的步骤不能及时提供数据，这个方法就会阻塞，直到有可用的数据行。这样这个步骤的速度就会降低，也会影响其它步骤的速度。<br>public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException {<br>        HelloworldStepMeta meta  = (HelloworldStepMeta) smi;<br>        HelloworldStepData data = (HelloworldStepData) sdi;<br>        Object[] row = getRow();<br>        if (row==null) {<br>            setOutputDone();<br>            return false;<br>        }</p>
<pre><code>    if (first) {
        first=false;
        data.outputRowMeta = getInputRowMeta().clone();
        meta.getFields(data.outputRowMeta, getStepname(), null, null, this);
    }
    String value = &quot;Hello, world!&quot;;
    Object[] outputRow = RowDataUtil.addValueData(row, getInputRowMeta().size(), value);

    putRow(data.outputRowMeta, outputRow);

    return true;
}
</code></pre><p>从性能上考虑，getRow()方法不提供数据行的元数据，只提供上个步骤输出的数据。可以使用getInputRowMeta()方法获取元数据，元数据只获取一次即可，所以在first代码块里获取元数据。<br>setOutputDone()方法用来通知其它的步骤，本步骤已经没有输出数据行。下一个步骤如果再调用getRow()方法就会返回null,转换也不再调用processRow()方法。</p>
<pre><code>Object[] row = getRow();
        if (row==null) {
            setOutputDone();
            return false;
        }
</code></pre><p>   如果要把数据传到下一个步骤，要使用putRow()方法。除了输出数据，还要输出RowMetaInterface元数据。<br>    data.outputRowMeta = getInputRowMeta().clone();<br>    meta.getFields(data.outputRowMeta, getStepname(), null, null, this);<br>第一行使用clone()方法把输入行的元数据结构复制给输出行。输出行的元数据结构是在输入行的基础上增加一个字段，但构造输出行的元数据结构只能构造一次，因为所有输出数据行的结构都是一样的，产生了输出行以后，元数据结构就不能再变化。所以输出行的元数据结构在first代码块里构造。first是一个内部成员，first代码块里的代码只在处理第一行数据时执行。下面代码的最后一行，给输出数据增加了一个字段。</p>
<p>下面的代码，把数据写入输出流。<br>        String value = “Hello, world!”;<br>        Object[] outputRow = RowDataUtil.addValueData(row, getInputRowMeta().size(), value);<br>        putRow(data.outputRowMeta, outputRow);<br>从性能角度考虑，数据行实现就是Java数组。为了开发方便，可以使用RowDataUtil类提供的一些静态方法来操作数据。使用RowDatautil静态方法复制数据，还可以提高性能。<br>从指定的步骤读取数据行<br>如果你想从前面的某个指定的步骤读取数据行，例如”流查询“步骤，可以使用getRowFrom()方法。<br>       RowSet rowSet = findInputRowSet(Source Step Name);<br>       Object[] rowData = getRowFrom(rowSet);<br>           还可以通过rowSet对象获得数据行的元数据：<br>       RowMetaInterface rowMeta = rowSet.getRowMeta();<br>把数据行写入指定的步骤<br>如果想把数据写入到某个特定的步骤，例如”过滤“步骤，可以使用putRowTo()方法<br>      RowSet rowSet = findOutputRowSet(Target Step Name);<br>      ….<br>      putRowTo(outputRowMeta,rowData,rowSet);<br>很明显，输入和输出的RowSet对象只需获得一次即可，这样才更有效率。<br>把数据行写入到错误处理步骤<br>如果想让你的步骤支持错误处理，而且元数据类返回的supportErrorHandling()方法返回了true，就可以把数据输出<br>      到错误处理步骤里。下面是使用putError()方法的例子：<br>      Object[] rowData = getRow();<br>      …<br>      try{<br>          …<br>          putRow(…);<br>      }catch(Exception e){<br>          if(getStepMeta().isDoingErrorHandling()){<br>              putError(getInputRowMeta(),rowData,errorCode);<br>          }else{<br>              throw(e);<br>          }<br>      }<br>      从例子里可以看到，这段代码把错误的行数、错误字段名、消息、错误编码都传递给错误处理步骤。<br>      错误处理的其他工作都自动完成了。</p>
<h4 id="识别一个步骤拷贝"><a href="#识别一个步骤拷贝" class="headerlink" title="####识别一个步骤拷贝"></a>####识别一个步骤拷贝</h4><p>因为一个步骤可以有多份拷贝同时执行，有时需要识别出正在使用的是哪个步骤拷贝，可以用下面几个方法。<br>     getCopy():获得拷贝号。拷贝号可以唯一标识出步骤的一个拷贝，拷贝号的聚会范围是0-N，N=getStepMeta().getCopies()-1<br>     getUniqueStepNrAcrossSlaves():获得在集群模式下运行的步骤拷贝号。<br>     getUniqueStepCountAcrossSlaves():获得在集群模式下运行的步骤拷贝总数。<br>     通过这些方法可以把一个步骤的工作分配给多份拷贝去完成。例如”CSV文件输入“和”固定文件输入“步骤里都有并行读取文件的选项，这样可以把读取文件的工作放在多个拷贝里或集群里来完成。</p>
<h4 id="结果反馈"><a href="#结果反馈" class="headerlink" title="####结果反馈"></a>####结果反馈</h4><p>在调用getRow()和putRow()方法时，引擎会自动计算两类度量值，读行数和写行数。这两类度量值可以在界面或日志中记录下来，以监控程序运行的状态。下面几个方法用来操作这两类度量值。<br>    incrementLinesRead():增加从前面步骤读取到的行数。<br>    incrementLinesWritten():增加定稿到后面步骤中的行数。<br>    incrementLinesInput():增加从文件、数据库、网络等资源读取到的行数<br>    incrementLinesOutput:增加写入到文件、数据库、网络等资源的行数。<br>    incrementLinesUpdate():增加更新的行数。<br>    incrementLinesSkipped()：增加跳过的数据行的行数。<br>    incrementLinesRejected():增加拒绝的数据行的行数。<br>    这些度量值用来说明步骤执行的情况。可以在Spoon的转换度量面板里看到，也可以存到日志数据库表里。<br>    使用addResultFile()方法，可以把步骤用到的文件保留下来，保存到结果文件列表里。结果文件列表可以被其它转换或作业项使用。例如，下面的”CSV文件输入“的代码：<br>ResultFile resultFile = new ResultFile(<br>    ResultFile.FILE_TYPE_GENERAL,<br>    fileObject,<br>getTransMeta().getName(),<br>getStepName()<br>);<br>resultFile.setComment(“File was read by a Csv Input step”);<br>addREsultFile(resultFile);</p>
<h4 id="变量替换"><a href="#变量替换" class="headerlink" title="####变量替换"></a>####变量替换</h4><pre><code>如果输入框需要支持变量，可以使用environmentSubstritute()方法获取变量。例如，若想在“Hello World”例子的字段名输入框里使用变量，就要把StepMetaInterface里的getFields()方法修改成下面的语句：
</code></pre><p>String realFiledName = apace. environmentSubstritute(fieldName)；<br>因为步骤本身是一个VariableSpace对象，所以也可以使用下面的语句做变量替换：String value = environmentSubstritute(meta.getSringWithVariables());</p>
<h4 id="Apache-VFS"><a href="#Apache-VFS" class="headerlink" title="####Apache VFS"></a>####Apache VFS</h4><p>Kettle里所有操作文件的步骤，都使用Apache VFS系统的方式操作。Apache VFS不但可以从文件系统读取文件（如java.io.File），还可以从很多其他来源读取文件，如FTP服务器、Z学压缩文件，等 等 。<br>Apache VFS里的FileObject对象提供了文件的抽象层，然后在Kettle的KettleVFS类里还提供了一系列的静态方法，来更方便使用FileObject对象，例如下面的代码 ：  </p>
<pre><code>FileObject fileObject = KettleVFS.getFileObject(“zip:http://www.example.com/archive.zip!file.txt”);
</code></pre><p><code>String value = environmentSubstritute(meta.getSringWithVariables());</code></p>
<p>应该尽可能多地使用KettleVFS,因为它解决了或饶过了很多Apache VFS目前已知的问题。它也增强了SFTP协议。</p>
<h4 id="步骤插件部署"><a href="#步骤插件部署" class="headerlink" title="####步骤插件部署"></a>####步骤插件部署</h4><p>部署之前，要把四个Java源代码文件编译为class文件。把编译好的class文件放到一个Jar包里。可以使用IDE来做这些事情，也可以手工使用ant脚本来做这些事情。<br>.jar文件应该放在Kettle的plugins/steps目录下。也可以使用一个子目录，把所有的依赖的jar包放在插件jar包所在目录的/lib目录下，不必再放Kettle的类路径中（Kettle的libext/目录）已经有了的jar包。另外可以把多个插件放在一个jar包里。<br>如果想在IDE里调试插件，可以把插件元数据类的名字放在Kettle_PLUGIN_CLASSES变量里（一个逗号分隔的列表）。关于这个主题的更多信息，请参考pentaho Wiki:<a href="http://wiki.pentaho.com/display/EAI/How+to+debug+a+Kettle+4+plugin" target="_blank" rel="noopener">http://wiki.pentaho.com/display/EAI/How+to+debug+a+Kettle+4+plugin</a> 。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cenrise.com/2017/04/15/kettle/开源ETL工具-kettle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongpo.jia">
      <meta itemprop="description" content="个人博客">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="中起之星">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/15/kettle/开源ETL工具-kettle/" itemprop="url">
                  开源ETL工具-kettle
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-04-15 14:43:49" itemprop="dateCreated datePublished" datetime="2017-04-15T14:43:49+08:00">2017-04-15</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-08-18 09:44:35" itemprop="dateModified" datetime="2017-08-18T09:44:35+08:00">2017-08-18</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/开源项目/" itemprop="url" rel="index"><span itemprop="name">开源项目</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/开源项目/kettle/" itemprop="url" rel="index"><span itemprop="name">kettle</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#开源ETL工具-kettle<br>说明：本文部分内容参考网络的资料，如果侵权之处请告知一下，不胜感激！</p>
<p>Kettle是Pentaho公司开发的一款ETL产品，以工作流为核心，强调面向解决方案而非工具的，基于java平台的商业智能(Business Intelligence,BI)套件。Kettle的开源协议是LGPL，该协议来自GNU，因功能强大，被FSF(Free Software Foundation)列为首选协议。LGPL协议允许Kettle作为商业（非开源）代码的链接库，使用Kettle的商业代码无须开源。LGPL带来的不仅是Kettle API，你还可以对它进行拓展对外提供商业软件或服务。</p>
<h2 id="ETL是什么"><a href="#ETL是什么" class="headerlink" title="##ETL是什么"></a>##ETL是什么</h2><p>ETL早期作为数据仓库的关键环节，负责将分布的、异构数据源中的数据如关系数据、平面数据文件等抽取到临时中间层后进行清洗、转换、集成，最后加载到数据仓库（Data Warehouse）或数据集市（Data Mart）中，成为联机分析处理（On-Line Analytical Processing，OLAP）、数据挖掘（Data Mining）的基础。</p>
<p>Exract：从多种异构数据源中抽取数据</p>
<p>Transform：经过清洗，统一化和转换</p>
<p>Load：将数据加载到目的数据源中</p>
<h2 id="Kettle产品特点"><a href="#Kettle产品特点" class="headerlink" title="##Kettle产品特点"></a>##Kettle产品特点</h2><p>适用于将多个应用系统的大批量的、异构的数据进行整合，有强大的数据转换功能。<br>高效适配多种类型的异构数据库、文件和应用系统。<br>快速构建复杂数据大集中应用、无需编码。</p>
<p>Kettle构成</p>
<p>TODO以Github上的名词进行定义Spoon，Cart等</p>
<p>左边是集成开发工具（Spoon），可以进行流程的开发、配置、调试、部署、执行(转换、任务)，也可以对运行情况进行监控、对处理过程的日志进行查看、也可以通过接口调用方式进行远程管理。</p>
<p>中间是服务器(Carte)，包括实际执行转换和任务的ETL引擎、监控管理的接口、认证授权接口，还有一个可以拓展的接口。</p>
<p>下面是在开发过程中，用于保存集成开发工具中创建的转换、任务、数据库等项的，资源库包含两类，一个是数据库资源库，一个是文件资源库。</p>
<p>右边个是是第三方平台，可以基于kettle提供的接口实现相应的功能包括状态监控、启停控制、日志查看等功能。</p>
<p>组成部分<br>名称<br>描述<br>Spoon<br>一个基于swt开发的流式处理客户端，用户开发转换、任务、创建数据库、集群、分区等<br>Pan<br>一个独立的命令行程序，支持通过命令行实现界面的功能，如果转换启停、任务启停。状态查看等<br>Kitchen<br>一个独立的命令行程序，用于执行由Spoon编辑的作业。<br>Carte<br>Carte是一个轻量级的Web容器，用于建立专用、远程的ETL Server。</p>
<p>PDI相关术语和概念<br>Job(任务)、Transformation(转换)是kettle的两个最重要的概念。任务做的一件完整的事，包含开始、结束等整个生命周期；而转换是要做这件事的某一个小的功能。比如你要从A数据源中解析数据后放入B数据源，那么你可以创建两个转换，一个是从A数据源加载数据-&gt;处理数据-&gt;放入存储中；另一个是把数据放入B数据源，然后在一个任务中处理他们。</p>
<p>下面我们通过集成开发工具去了解一个转换和任务</p>
<p>Transformation（转换）<br>Transformation（转换)是由step(步骤)和hops(节点连接线)组成，一个转换，可以看成一段数据流，每一个步骤完成一项数据处理的工作，节点连接线用于数据的流动。</p>
<p>转换可以单独运行完成某一项工作，文件的扩展名为.ktr</p>
<p>Steps（步骤）<br>Steps（步骤）是转换的重要组件部分，在Spoon中步骤根据功能分为输入类、输出类、脚本类等，每一个步骤完成一种特定的功能，比如excel输出组件，用于把数据流输出为excel文件格式。参考如下：</p>
<p>Hops（节点连接）<br>Hops（节点连接）是数据传输的通道，用于连接两个步骤，使数据从一个步骤传递到另一个步骤，支持分发、复制等方式。注意数据处理的顺序并不是按照节点连接箭头的顺序，因为第个步骤都是单独的线程。</p>
<p>Jobs（工作）<br>Jobs（工作）是基于工作流模型的，顺序处理。把步骤、转换组织在一起完成一件完整的事情。<br>文件扩展名为.kjb</p>
<p>下载使用<br>kettle下载 目前最新版7.0<br><a href="https://sourceforge.net/projects/pentaho/files/Data%20Integration/" target="_blank" rel="noopener">https://sourceforge.net/projects/pentaho/files/Data%20Integration/</a></p>
<p>下载解压后是一个如：pdi-ce-7.0.0.0-25的文件，目录内容如下</p>
<p>windown下直接双拼Spoon.bat、linux下直接运行./spoon.sh即可。<br>注： could not find the main class:org.pentaho.commons.launcher.Launcher. Program will exit. 表示jdk版本错误 。7.0版本只支持jdk1.8，可以单独配置kettle的jdk，添加配置到系统中即可：<br>名称：PENTAHO_JAVA_HOME<br>值：C:\Program Files\Java\jdk1.8.0_45<br>    mac系统下/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/<br>启动后界面如下</p>
<p>新建转换：快捷键Ctrl+N</p>
<p>首先从核心对象区选择“生成记录组件，编辑：</p>
<p>然后选择Excel输出组件到工作区，创建生成记录步骤到Excel输出步骤的连接线，编辑excel输出目录和字段</p>
<p>最后生成如下，点击运行：</p>
<p>运行后的结果是输出excel文件，并可以查看每个步骤的处理情况，读、写、输入、输出等</p>
<p>其它参考链接<br>kettle源码下载，可以选择各个版本下载，自己编译。<br><a href="https://github.com/pentaho/pentaho-kettle" target="_blank" rel="noopener">https://github.com/pentaho/pentaho-kettle</a><br>大数据插件源码<br><a href="https://github.com/pentaho/big-data-plugin" target="_blank" rel="noopener">https://github.com/pentaho/big-data-plugin</a><br>kettle支持的大数据环境源码，主要是hdp,cdh。<br><a href="https://github.com/pentaho/pentaho-hadoop-shims" target="_blank" rel="noopener">https://github.com/pentaho/pentaho-hadoop-shims</a><br>kettle nexus<br><a href="http://repo.pentaho.org/content/groups/omni/pentaho/" target="_blank" rel="noopener">http://repo.pentaho.org/content/groups/omni/pentaho/</a><br><a href="http://repository.pentaho.org/artifactory/repo/" target="_blank" rel="noopener">http://repository.pentaho.org/artifactory/repo/</a><br>所有组件实现说明<br><a href="http://wiki.pentaho.com/display/EAI/Pentaho+Data+Integration+Steps" target="_blank" rel="noopener">http://wiki.pentaho.com/display/EAI/Pentaho+Data+Integration+Steps</a><br>所有组件测试说明<br><a href="http://wiki.pentaho.com/display/EAI/test" target="_blank" rel="noopener">http://wiki.pentaho.com/display/EAI/test</a><br>帮助<br><a href="http://help.pentaho.com/Documentation" target="_blank" rel="noopener">http://help.pentaho.com/Documentation</a> </p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cenrise.com/2017/04/01/oracle/Oracle网络和数据库连接/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongpo.jia">
      <meta itemprop="description" content="个人博客">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="中起之星">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/01/oracle/Oracle网络和数据库连接/" itemprop="url">
                  Oracle网络和数据库连接
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-04-01 15:30:00" itemprop="dateCreated datePublished" datetime="2017-04-01T15:30:00+08:00">2017-04-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-08-18 09:44:35" itemprop="dateModified" datetime="2017-08-18T09:44:35+08:00">2017-08-18</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据库/oracle/" itemprop="url" rel="index"><span itemprop="name">oracle</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>内容来自《Oracle Database 11g 数据库管理艺术》</p>
<h1 id="网络概念：Oracle网络如何工作"><a href="#网络概念：Oracle网络如何工作" class="headerlink" title="网络概念：Oracle网络如何工作"></a>网络概念：Oracle网络如何工作</h1><p>在希望从客户机（不管是传统客户机还是基于浏览器的客户机）打开数据库会话时，需要通过网络连接到数据库。假如要将台式电脑通过现有网络连接到UNIX服务器上的一个Oracle数据库，则需要在电脑和Oracle数据库（它使用专门的软件）之间构造一个连接方法。需要某种界面来处理会话（在此例子中为SQL*Plus），并且需要某种与业内标准的网络协议（如TCP/IP）通信的方法。<br>为方便配置和管理网络连接，Oracle提供了Oracle Net Services，它是一套在分布式异构计算环境中提供连接方案的组件。Oracle Net Services由Oracle Net、Oracle Net Listener、Oracle Connection Manager、Oracle Net Configuration Assistant和Oracle Net Manager组成。Oracle Net Services软件是在Oracle Database Server或Oracle Client软件安装的过程中自动安装的。<br>Oracle Net是一个初始化、建立及维护客户机和服务器之间的连接的组件。这就是为什么必须在客户机和服务器上都安装Oracle Net的原因。Oracle Net主要由两个组件构成。<br>Oracle Network Foundation Layer：负责建立和维护客户机应用程序与服务器之间的连接，以及它们之间的交换信息。<br>Oracle Protocol Support： 负责映射Transparent Net Substrate（TNS）功能到连接使用的业内标准协议。<br>驻留Oracle数据库的所有服务器还运行一个名为Oracle Net Listener（通常也称为监听器）的服务，其主要功能是监听来自客户机服务登录Oracle数据库的请求。监听器在保证客户机服务具有与数据库匹配的信息（协议、端口和实例名）后，将客户机请求传递到数据库。假如用户名和密码通过认证，则数据库将允许客户机登录。一旦监听器把用户请求交付给数据库，客户机和数据库将直接连接，不再需要监听器的帮助。<br>Oracle提供了基于GUI的大量的实用程序，以帮助配置数据库的网络连接。这些实用程序包括Oracle Connection Manager、Oracle Net Manager和Oracle Net Configuragion Assistant等。这些工具帮助处理所有网络需求。在结束本章学习后，可单击这些程序的图标，开始测试连接的实验。  </p>
<h1 id="Web应用如何连接到Oracle数据库"><a href="#Web应用如何连接到Oracle数据库" class="headerlink" title="Web应用如何连接到Oracle数据库"></a>Web应用如何连接到Oracle数据库</h1><p>为了构造Oracle数据库的一个Internet连接，客户机上的Web浏览器要与Web服务器通信并使用HTTP进行连接请求。Web服务器将此请求传递给一个应用，该应用处理收到的请求并用Oracle Net（配置在数据库服务器和客户机上）与Oracle数据库服务器通信<br>    下面介绍Oracle网络中几个关键的术语  </p>
<h2 id="数据库实例名"><a href="#数据库实例名" class="headerlink" title="数据库实例名"></a>数据库实例名</h2><p>正如所知，Oracle实例由SGA和一组Oracle进程组成。数据库实例名在初始化文件（init.ora）中作为INSTANCE_NAME参数给出。在谈到Oracle SID（System identifier，系统标识符）时，指的是Oracle实例。<br>    通常，每个数据库只有一个与其关联的实例。但在Oracle RAC配置中，单个数据库可关联到多个实例。  </p>
<h2 id="全局数据库名"><a href="#全局数据库名" class="headerlink" title="全局数据库名"></a>全局数据库名</h2><p>全局数据库名唯一地标识一个Oracle数据库，其格式为database_name.database_domain，如sales.us.acme.com。在这个全局数据库中，sales为数据库名，us.acme.com为数据库域。因为相同的域中两个数据库不会有相同的数据库名，所以每个全局数据库名都是唯一的。  </p>
<h2 id="数据库服务名"><a href="#数据库服务名" class="headerlink" title="数据库服务名"></a>数据库服务名</h2><p>对于客户机，数据库在逻辑上简单地表现为一个服务。在服务和数据库之间存在一个多对多的关系，因为一个数据库可被一个或多个服务所代表，每个服务都专用于一组不同的客户机，而一个服务可覆盖不止一个数据库实例。我们在自己的系统中用每个数据库的服务名来标识它，用初始化参数SERVICE_NAMES来指定数据库的服务名。服务名参数值默认为全局数据库名。<br>请注意，一个数据库可由多个服务名来访问。如果希望不同的客户机组访问适合于它们的特定需求的不同数据库，应该这样做。例如，可对相同数据库创建如下两个服务名：<br>Sales.us.acme.com<br>Finance.us.acme.com<br>销售人员使用sales.us.acme.com服务名，而财务人员则使用finance.us.acme.com服务名。  </p>
<h2 id="连接描述符"><a href="#连接描述符" class="headerlink" title="连接描述符"></a>连接描述符</h2><p>为了将电脑连接到世界上的任何数据库服务，需要提供两个信息：<br>    数据库服务名；<br>    地址。<br>Oracle使用术语连接描述符(connect descriptor)来表示数据库连接的两个必需的部分：数据库服务名和地址。连接描述符的地址部分包含三个部分，分别是：连接使用的通信协议、主机名和端口号。<br>了解通信协议有助于保证使用合适的网络协议，以便建立连接。标准的协议为TCP/IP或带SSL（Secure Sockets Layer，安全套接层）的TCP/IP。UNIX服务器上的Oracle连接的标准端口为1521或1526.Windows机器上的默认端口为1521.因为任何主机上的数据库具有唯一服务名，所以一个Oracle数据库服务名和一个主机名将唯一地标识任何数据库。下面是一个典型的连接描述符的例子：<br>(DESCRIPTION<br>(ADDRESS=(PROTOCOL=tcp)(HOST=sales-server)(PORT=1521))<br>(CONNECT_DATA=<br>(SERVICE_NAME=sales.us.acme.com)))<br>在此连接描述符中，ADDRESS行指出网络通信将使用TCP协议。HOST指定UNIX（或Windows）服务器，服务器上的Oracle监听器正监听来自端口1521的连接请求。连接描述符的ADDRESS部分也称为协议地址(protocol address)。<br>希望连接数据库的客户机首先连接到Oracle监听器进程。监听器接收到达的请求并把它们交给数据库服务器。一旦客户机和数据库服务器通过监听器的引导连接上，它们就直接通信，在此客户机连接的通信过程中不再需要监听器。  </p>
<h2 id="连接标识符"><a href="#连接标识符" class="headerlink" title="连接标识符"></a>连接标识符</h2><p>连接标识符（connect identifier）与连接描述符紧密关联。可把连接描述符作为连接标识符，或者可简单地映射一个数据库服务名为一个连接描述符。例如，可以把一个服务名(如sales)映射为11.2.5节所看到的连接描述符。下面是说明映射sales连接标识符的例子。<br>Sales=<br>(DESCRIPTION<br>(ADDRESS=(PROTOCOL=tcp)(HOST=sales-server)(PORT=1521))<br>(CONNECT_DATA=<br>(SERVICE_NAME=sales.us.acme.com)))  </p>
<h2 id="连接串"><a href="#连接串" class="headerlink" title="连接串"></a>连接串</h2><p>通过提供一个连接串(connect string)连接到数据库。连接串包含用户名/密码组合及一个连接标识符。最常见的连接标识符之一是节点服务名，它是一个数据库服务的名字。<br>下面的例子给出一个连接串，它把一个完整的连接描述符作为连接标识符<br>    CONNECT scott/tiger@(DESCRIPTION=<br>    (ADDRESS=(PROTOCOL=tcp)<br>    (HOST=sales-server)<br>    (PORT=1521))<br>    (CONNECT_DATA=<br>    (SERVICE_NAME=sales.us.acme.com)))<br>下面是一个更简单的连接到相同数据库的方法，它使用连接标识符sales：<br>    CONNECT scott/tiger@sales<br>上面两个例子都能连接到sales数据库，但显然第二个连接串（使用sales连接标识符）简单得多。  </p>
<h2 id="使用Oracle网络服务工具"><a href="#使用Oracle网络服务工具" class="headerlink" title="使用Oracle网络服务工具"></a>使用Oracle网络服务工具</h2><p>Oracle Net提供了配置客户机与数据库服务之间的连接的几个GUI和命令行工具。最常用的命令行工具是isnrctl实用程序，它帮助管理Oracle监听器服务。下面是帮助管理Oracle Net Servcies的重要GUI工具。<br>Oracle NCA（Net Configuration Assistant，Oracle网络配置助手）。此工具主要用于在安装中配置网络组件，它允许在配置客户机连接的几个选项（本章稍后介绍这些选项）中进行选择。其便于使用的GUI界面使你能在所选择的任何命名方法下快速配置客户机连接。在UNIX/Linux系统上，可通过从$ORACLE_HOME/bin目录执行netca来启动NCA。在Window系统上，选择Start|Programs|Oracle-HOME_NAME|Configuration and Migration Tools|Net ConfigurationAssistant。<br>Oracle网络配置管理器（Oracle Net Manager）。Oracle Net Manager可在客户机和服务器上运行，它允许配置各种命名方法和监听器。利用此工具，可在本地tnsnames.ora文件或在集中式的OID中配置连接描述符，而且可以方便地增加和修改连接方法。<br>为了从Oracle企业管理器控制台启动Oracle Net Manager，选择Tools|Service Management|Oracle Net Manager。为了在Unix上作为独立的应用启动Oracle Net Manager，在ORACLE_HOME/bin目录执行netmgr。在windown上，选择Start|Programs|Oracle-HOME_NAME|Configuration and Migration Tools|NetManager。<br>Oracle企业管理器（Oracle Enterprise Manager）。Oracle Database 11g中的OEM可以完成Oracle Net Manager能完成的所有任务，但不能跨多个文件系统管理多个Oracle主目录。此外，使用OEM可导出目录命名项到tnsnames.ora文件。<br>Oracle目录管理器（Oracle Directory Manager）。这个功能强大的工具允许创建使用OID必需的各种域和环境。用此工具还可以执行密码策略管理及完成许多Oracle高级安全任务。在UNIX/LINUX系统上，可从$ORACLE_HOME/bin目录执行oidadmin来启动OID。在Window系统上，选择Start|Programs|Oracle-HOME_NAME|Integrated Manager Tools|Oracle Directory Manager。  </p>
<h1 id="即时客户机"><a href="#即时客户机" class="headerlink" title="即时客户机"></a>即时客户机</h1><p>之前说过Oracle客户机安装需要经历常规的Oracle数据库服务器软件安排的所有预备步骤。幸而为连接到Oracle数据库并不总是需要安装完整的Oracle客户机软件。Oracle的新Instant Client（即时客户机）软件允许执行应用程序而不必安装标准的Oracle客户机也不必具有ORACLE_HOME。不需要为访问Oracle数据库的每台机器安装Oracle客户机软件。所有现有的OCI、ODBC和JDBC应用程序都可以使用Instan Client。如果愿意，甚至可以用Instant Client使用SQL<em>Plus。<br>    相对于完整的Oracle客户机，Instant Clients提供以下好处：<br>A. 它是免费的；<br>B. 战胜磁盘空间较少<br>C. 安装更快（5分钟左右）<br>D. 不需要CD<br>E. 它具有Oracle客户机的所有特性，如果有必要甚至包括使用SQL</em>Plus。  </p>
<h1 id="安装Instant-Client"><a href="#安装Instant-Client" class="headerlink" title="安装Instant Client"></a>安装Instant Client</h1><p>以下是安装新Instant Client软件并快速连接到Oracle数据库的步骤。<br>(1) 从OTN Web站点下载Instant Client软件。你必须安装基本的客户机程序包，还可以包括其他高级可选的程序包。此程序包含以下内容：<br>    a) Basic：运行OCI、OCCI和JDBC-OCI应用程序所需的文件。<br>    b) SQL<em>Plus：为用Instant Client运行SQL</em>Plus需要的库和可执行文件。<br>    c) JDBC Supplement：另外支持XA、国际化及JDBC下的RowSet操作。<br>    d) ODBC Supplement：启用带Instant Client的ODBC应用的另外的库（仅对Windows）。<br>    e) SDK：用于Instant Client开发Oracle应用程序所需的其他文件。<br>(2) 将选择的程序包解压到某个目录，将些目录命名为instantclient或其它类似的名称。<br>(3) 在UNIX和Linux系统中，将环境变量LD_LIBRARY_PATH设置为instantclient（从而保证此参数的设置与程序包所有所在的目录名匹配）。在Winddows系统上，将环境变量PATH设置为instantclient。<br>(4) 测试对Oracle服务器的连接。  </p>
<h1 id="监听器和连接"><a href="#监听器和连接" class="headerlink" title="监听器和连接"></a>监听器和连接</h1><p>Oracle监听器是一个只运行在服务器上并监听连接请求的服务。Oracle提供一个名为lsnrctl的实用程序来管理监听器进程。以下是监听器如何配合Oracle网络的概述。<br>a. 数据库用监听器记录关于服务、实例及服务处理器的信息<br>b. 客户机与监听器进行初步连接<br>c. 监听器接收和验证客户机连接请求并把此请求交给数据库服务的服务处理器。一旦交付了客户机请求，监听器在该连接中不再起作用。<br>Listener.ora文件默认位置在UNIX系统上为$ORACLE_HOME/network/admin目录，在Windows系统上为$ORACLE_HOME\network\admin目录，它包含监听器的配置信息。因为监听器服务只运行在服务器上，因此在客户机上没有listener.ora文件。代码清单11-1给出了一个典型的listener.ora文件。<br>Listener中的所有配置参数都具有默认值，不需要手动配置监听器服务。在服务器上创建了第一个数据库后，监听器服务自动启动，并且将监听器配置文件listener.ora放于默认目录中。新数据库创建后，数据库的网络和服务信息自动添加到监听器的配置文件中。实例启动后，数据库自动向监听器注册，并且监听器开始监听对此数据库的连接请求。<br>代码清单11-1 典型的监听器配置文件<br>代码清单11-1 典型的监听器配置文件   </p>
<pre><code>#LISTENRE.ORA Network Configuration file 
/u01/app/oracle/product/11.1.0.6.0/db_1/network/admin/listener.ora
SID_LIST_LISTENER = 
(DESCRIPTION_LIST =
    (DESCRIPTION = 
          (ADDRESS_LIST = 
            (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC4))
        )
        (ADDRESS_LIST = 
            (ADDRESS = (PROTOCOL = TCP)(HOST = NTL-ALAPATISAM)(PORT = 1521))
        )
    )
)
SID_LIST_LISTENER = 
    (SID_LIST = 
    (SID_DESC = 
        (SID_NAME = PLSExtProc)
        (ORACLE_HOME = /u01/app/oracle/product/11.1.0/db_1)
        (PROGRAM = extproc)
    )
    (SID_DESC = 
        (GLOBAL_DBNAME = remorse.world)
        (ORACLE_HOME = /u01/app/oracle/product/11.1.0/db_1)
        (SID_NAME = remorse)
    )
    (SID_DESC = 
        (GLOBAL_DBNAME = finance.world)
        (ORACLE_HOME = /u01/app/oracle/product/11.1.0/db_1)
        (SID_NAME = finance)
    )
)
</code></pre><h2 id="自动服务注册"><a href="#自动服务注册" class="headerlink" title="自动服务注册"></a>自动服务注册</h2><p>Oracle PMON进程负责向监听器动态服务注册新Oracle数据库服务名，也就是说，在创建新Oracle数据库时，它们将自动向监听器服务注册。PMON进程将在每个新数据库在服务器上创建之后更新listener.ora文件。<br>为自动服务注册，ini.ora文件或SPFILE应该包含如下参数：<br>a. SERVICE_NAMES(如sales.us.oracle.com)<br>b. INSTANCE_NAME(如sales)<br>如果不指定SERVICE_NAMES参数的值，它默认为全局数据库名，全局数据库名是DB_NAME和DB_DOMAIN参数的组合。INSTANCE_NAME参数的默认值为Oracle安装或数据库创建时输入的SID。<br>可使用lsnrctl实用程序查看服务器上监听器的状态，如代码清单11-2所示。相应的输出说明监听器启动了多长时间，监听器服务的配置文件位于何处。它还给出监听器为连接请求而监听的数据库的名称。<br>代码清单11-2 使用lsnrctl实用程序查看监听器的状态<br>$ lsnrctl status  </p>
<p>在代码清单11-2的Services Summary部分，相应的状态可具有如下的某个值。<br>a. READY：此实例可接受连接<br>b. BLOCKED：此实例不能接受连接<br>c. UNKNOWN：此实例在listener.ora文件中注册而不是通过动态服务注册，因而不知道其状态  </p>
<h2 id="监听器命令"><a href="#监听器命令" class="headerlink" title="监听器命令"></a>监听器命令</h2><p>在调用lsnrctl实用程序后，除了status命令外还可以执行其他一些重要的命令。例如，service命令允许查看监听器正为连接请求而监控的是什么服务。<br>注解：还可以从Oracle企业管理器的Net Services Administration页面查看监听器服务的状态。<br>代码清单11-2 使用lsnrctl help列出lsnrctl命令<br>$lsnrctl help<br>可以调用lsnrctl实用程序后，使用start命令启动监听器，使用stop命令停业监听器。如果希望从操作系统命令行发布这些命令，可使用lsnrctl start和lsnrctl stop命令执行这两个任务。<br>如果对listener.ora文件做了更改，为使更改起作用的一种方法是重启监听器。另一种安全的方法是重新装载监听信息，包括对监听器配置文件所做的最新更改。Lsnrctl reload命令允许在运行中重新装载监听器，而不用重新启动它。在监听器重装载（甚至是重启）的过程中，当前连接的客户机将继续保持连接，因为监听器已经将连接“交付”给数据库，在客户和数据库服务之间不起作用。<br>注意：我的忠告是，如非绝对有必要，不要修改listener.ora文件，而且对于动态自动服务注册，几乎没有必要修改此文件。不过，有时可能需要修改监听器文件的某些部分，此文件由监听器监控连接请求的所有服务的网络配置信息组成。  </p>
<h2 id="命名和连接"><a href="#命名和连接" class="headerlink" title="命名和连接"></a>命名和连接</h2><p>在前面连接描述符和连接标识符的例子中，使用sales连接标识符来连接sales服务。连接标识符可以是连接描述符本身，也可以是一个能解析为连接描述符的简单名字(如sales)。一般使用的简单连接标识符称为net service name(网络服务名)。因此前面例子中的sales连接标识符就是一个net service name。<br>因为每次进行连接时都需要提供一下完整的连接描述符非常令人厌烦，使用网络服务名是明智的。但这需要维护网络服务名和连接描述信息之间所有映射的一个中心信息库(central repository)，以便Oracle验证这些网络服务名。因此，在一个用户使用网络服务名sales启动连接进程时，Oracle将搜索中心信息库查找sales的连接描述符。找到连接描述符后，Oracle Net会为指定服务器上的数据库初始化一个连接。<br>Oracle允许几种类型的命名信息库，可用下列4种命名方法访问存储在这些位置中的映射信息。<br>a. 本地命令(local naming )：使用存储在每个客户机上的名为tnsnames.ora的文件连接到数据库服务器。<br>b. 简易连接命名(easy connect naming)：允许连接而无需任何服务名配置。<br>c. 外部命名(external naming)：使用第三方命名服务来解析服务名。<br>d. 目录命令(directory naming)：使用一个集中式的符合LDAP的目录服务器来解析服务名。<br>    不管使用何种命名方法，名字解析过程都是相同的。每种命名法都遵循以下步骤将连接描述符解析为网络服务名：<br>i. 选择命令方法—本地、简易连接、外部命名或目录服务命名<br>ii. 映射连接描述符到服务名；<br>iii. 配置客户机以使用步骤1中选择的命名方法  </p>
<h2 id="本地命名方法"><a href="#本地命名方法" class="headerlink" title="本地命名方法"></a>本地命名方法</h2><p>本地命令是建立Oracle连接最简单、最容易的方法。使用这种方法，在名为tnsnames.ora的本地化配置文件中存储服务名及其连接描述符。此文件默认存储在$ORACLE_HOME/network/admin目录中。  </p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cenrise.com/2017/01/01/算法/常用算法概述/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongpo.jia">
      <meta itemprop="description" content="个人博客">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="中起之星">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/01/算法/常用算法概述/" itemprop="url">
                  TODO-常用算法概述
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-01-01 00:00:00" itemprop="dateCreated datePublished" datetime="2017-01-01T00:00:00+08:00">2017-01-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-08-18 09:44:35" itemprop="dateModified" datetime="2017-08-18T09:44:35+08:00">2017-08-18</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/软件工程/" itemprop="url" rel="index"><span itemprop="name">软件工程</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/软件工程/算法/" itemprop="url" rel="index"><span itemprop="name">算法</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#工作内容指导</p>
<p>#安全小组工作范围</p>
<p>#关注的领域</p>
<p>#分类</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cenrise.com/2017/01/01/网络安全/企业安全组/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongpo.jia">
      <meta itemprop="description" content="个人博客">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="中起之星">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/01/网络安全/企业安全组/" itemprop="url">
                  TODO-企业安全组
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-01-01 00:00:00" itemprop="dateCreated datePublished" datetime="2017-01-01T00:00:00+08:00">2017-01-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-08-18 09:44:35" itemprop="dateModified" datetime="2017-08-18T09:44:35+08:00">2017-08-18</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/网络安全/" itemprop="url" rel="index"><span itemprop="name">网络安全</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/网络安全/安全小组/" itemprop="url" rel="index"><span itemprop="name">安全小组</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#工作内容指导</p>
<p>#安全小组工作范围</p>
<p>#关注的领域</p>
<p>#分类</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cenrise.com/2017/01/01/oracle/Oracle数据库系统架构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongpo.jia">
      <meta itemprop="description" content="个人博客">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="中起之星">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/01/oracle/Oracle数据库系统架构/" itemprop="url">
                  TODO-Oracle数据库系统架构
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-01-01 00:00:00" itemprop="dateCreated datePublished" datetime="2017-01-01T00:00:00+08:00">2017-01-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-08-18 09:44:35" itemprop="dateModified" datetime="2017-08-18T09:44:35+08:00">2017-08-18</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据库/oracle/" itemprop="url" rel="index"><span itemprop="name">oracle</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cenrise.com/2017/01/01/oracle/Oracle SQL优化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongpo.jia">
      <meta itemprop="description" content="个人博客">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="中起之星">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/01/oracle/Oracle SQL优化/" itemprop="url">
                  TODO-Oracle SQL优化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-01-01 00:00:00" itemprop="dateCreated datePublished" datetime="2017-01-01T00:00:00+08:00">2017-01-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-08-18 09:44:35" itemprop="dateModified" datetime="2017-08-18T09:44:35+08:00">2017-08-18</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据库/oracle/" itemprop="url" rel="index"><span itemprop="name">oracle</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cenrise.com/2016/09/20/linux/Linux固定IP上网方式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongpo.jia">
      <meta itemprop="description" content="个人博客">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="中起之星">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/09/20/linux/Linux固定IP上网方式/" itemprop="url">
                  固定IP上网方式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-09-20 09:43:49" itemprop="dateCreated datePublished" datetime="2016-09-20T09:43:49+08:00">2016-09-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-08-18 09:44:35" itemprop="dateModified" datetime="2017-08-18T09:44:35+08:00">2017-08-18</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/linux/网络/" itemprop="url" rel="index"><span itemprop="name">网络</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#固定IP上网方式#</p>
<p><strong>1. 修改主机名称：/etc/sysconfig/network</strong><br>NETWORKING=yes<br>HOSTNAME=centos.dm.tsai</p>
<p><strong>2. 设置网络参数：/etc/sysconfig/network-scripts/ifcfg-eth0</strong><br>请记得，这个ifcfg-eth0需与文件内的DEVICE名称设置相同，并且，在这个文件内的所有设置，基本上就是bash的变量设置规则</p>
<p><strong>[root@linux ~]# vi /etc/sysconfig/network-scripts/ifcfg-eth0</strong><br>DEVICE=eth0                    网卡代号，需要ifcfg-eth0相对应<br>BOOTPROTO=static               开机协议，有dhcp及static,这里是static<br>BROADCAST=192.168.1.255        广播地址<br>HWADDR=00:40:D0:13:C3:46       网卡地址<br>IPADDR=192.168.1.13            IP<br>NETMASK=255.255.255.0          子屏蔽网络<br>NETWORK=192.168.1.0           网段，该网段的第一个IP<br>GATEWAY=192.168.1.2           默认路由<br>ONBOOT=yes                  是否开机启动<br>MTU=1500                    最大传输单元的设置值<br>GATEWAYDEV=eth0            主要路由的设备，通常不用设置  </p>
<p>&emsp;&emsp;请注意每个变量（左边的英文）都应该要大写。否则我们的script会误判。关于IP的4个参数（IPADDR、NETMASK、NETWORK、BROADCAST），下面谈谈以下几个重要的设置值.<br>&emsp;&emsp;DEVICE: 这个设置后面接的是设备代号必须与文件名（ifcfg-eht0）的设备代号相同，否则会显示找不到设备名称。<br>&emsp;&emsp;BOOTPROTO：启动该网络接口时，使用何种协议？如果是手动设置IP的环境，请输入static或none，如果是自动取得IP的情况，请输入dhcp。<br>&emsp;&emsp;GATEWAY：代表的是整个主机系统的Default Gateway，所以，设置这个项目时，<strong>请特别留意。不要有重复设置的情况发生。</strong>也就是说，当您有ifcfg-eth0、Ifcfg-eht1等多个文件时，只要在其中一个文件里设置GATEWAY即可。<br>&emsp;&emsp;GATEWAYDEV：如果您不是使用固定的IP作为Gateway，而是使用网络设备作为Gateway（通常Route最常有这样的设置），那也可以使用GATEWAYDEV来设置通信网关设备。不过这个设置项目很少使用。<br>&emsp;&emsp;HWADDR：这是网卡的卡号。记得以前常常在讲，如果有两块一模一样的网卡存在，例如在一台主机上安装两张RealTek网卡，由于是相同的芯片，所以/etc/modprobe.conf内无法指定出明确的eth0与eth1的对应（因为模块使用相同），那么哪一个才是eth0?利用HWADDR指定网卡的卡号，就能够清楚定义出不同网卡的代号了。<br>&emsp;&emsp;事实上，如果想了解每个变量的项目意义时，建议参考/sbin/ifup这个script的内容，script很清楚地记录了每个项目的应用。</p>
<p><strong>3. 启动与关闭网卡：ifup/ifdown</strong><br>启动与关闭网卡的方式有两种，下面分别介绍：<br>[root@linux~]#ifup eth0<br>[root@linux~]#ifdown eth0 </p>
<p>上面的做法是针对eth0来进行启动(ifup)与关闭(ifdown)<br>[root@linux~]# /etc/init.d/network restart</p>
<p>针对这台主机的所有网络接口(包含lo)与通信闸进行重新启动所以网络会停止再连接</p>
<p>[root@linux~]#service network restart;</p>
<p><strong>4. 设置DNS的IP： /etc/resolv.conf</strong><br>这个文件会影响到您是否可以查询到主机名称与IP的对应。通常进行如果设置就可以了。<br>nameServer 168.95.1.1</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cenrise.com/2016/05/22/oracle/Oracle SQL基础知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongpo.jia">
      <meta itemprop="description" content="个人博客">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="中起之星">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/22/oracle/Oracle SQL基础知识/" itemprop="url">
                  Oracle SQL基础知识
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2016-05-22 14:43:49" itemprop="dateCreated datePublished" datetime="2016-05-22T14:43:49+08:00">2016-05-22</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-08-18 09:44:35" itemprop="dateModified" datetime="2017-08-18T09:44:35+08:00">2017-08-18</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据库/oracle/" itemprop="url" rel="index"><span itemprop="name">oracle</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Oracle-SQL基本知识"><a href="#Oracle-SQL基本知识" class="headerlink" title="Oracle SQL基本知识"></a>Oracle SQL基本知识</h2><h3 id="安装数据库"><a href="#安装数据库" class="headerlink" title="安装数据库"></a>安装数据库</h3><h4 id="1）安装Oracle常用问题-常用”用户名-密码“规则-："><a href="#1）安装Oracle常用问题-常用”用户名-密码“规则-：" class="headerlink" title="1）安装Oracle常用问题(常用”用户名/密码“规则)："></a>1）安装Oracle常用问题(常用”用户名/密码“规则)：</h4><p>超级管理员：sys /change_on_install<br>普通管理员：system/manager<br>普通用户：scott/tiger—–&gt;默认是被锁定的<br>大数据用户：sh/sh</p>
<h4 id="2）SQL-DDL…"><a href="#2）SQL-DDL…" class="headerlink" title="2）SQL,DDL…"></a>2）SQL,DDL…</h4><p>SQL：structured query language 结构化查询语言<br>1.file(文件)</p>
<p>SQL:DDL DML TCL DQL DCL<br>DDL(data definition language 数据定义语言): column(列)–structure<br>create table (创建表):<br>列名 data type(数据类型) width(宽度)<br>constraint (约束)      alter table(修改表结构)           drop table(删除表)</p>
<p>DML(data manipulation language 数据操作语言)<br>:row(行)–data<br>insert 增       update 改            delete 删数据,删表里的记录</p>
<p>TCL(transaction control language 事务控制语言)<br>commit(提交)         rollback(回滚)               savepoint(保留点)</p>
<p>DQL(data query language 数据查询语言)<br>select<br>DCL(data control language 数据控制语言)<br>grant(授权)  grant to       revoke(回收权限) revoke from </p>
<h4 id="3）RDBMS关系型数据库管理系统"><a href="#3）RDBMS关系型数据库管理系统" class="headerlink" title="3）RDBMS关系型数据库管理系统"></a>3）RDBMS关系型数据库管理系统</h4><p>RDBMS(relationship database management system 关系型数据库管理系统) software(软件) —&gt;(create database)database—&gt;login in database (登录数据库系统 )—&gt;用SQL操作table</p>
<p>create database 创建空间存储表 (datafile 数据文件)<br>login in database<br>1 远程登录到数据库所在的机器上<br>  192.168.0.20 192.168.0.23 192.168.0.26<br>shell(终端) telnet 192.168.0.20  (跟操作系统建连接)<br>login:openlab<br>password:open123<br>sunv210% shell提示符,执行操作系统命令</p>
<h4 id="4）-登录该机器上的数据库系统"><a href="#4）-登录该机器上的数据库系统" class="headerlink" title="4） 登录该机器上的数据库系统"></a>4） 登录该机器上的数据库系统</h4><p>sunv210% sqlplus (跟数据库建连接)<br>Enter user-name: openlab<br>Enter password:open123<br>SQL&gt;sqlplus openlab/open123<br>SQL&gt; 数据库提示符,执行SQL命令</p>
<h4 id="5）登录的是哪个数据库"><a href="#5）登录的是哪个数据库" class="headerlink" title="5）登录的是哪个数据库"></a>5）登录的是哪个数据库</h4><p>echo $ORACLE_SID(环境变量)&lt;—DBA(database administrator 数据库管理员)<br>查看ORACLE_SID变量的取值,oracle提供<br>通过设置ORACLE_SID变量,sqlplus就知道跟哪个数据库建连接.<br>unix平台<br>%c shell<br>%echo $ORACLE_SID  (tarena)<br>%setenv ORACLE_SID hiloo<br>%setenv ORACLE_SID tarena</p>
<p>$ b shell<br>$ echo $ORACLE_SID  (tarena)<br>$ ORACLE_SID=hiloo<br>$ export ORACLE_SID</p>
<p>windows平台<br>D:>set ORACLE_SID=hiloo (设置环境变量)<br>D:>set ORACLE_SID (查看环境变量)<br>ORACLE_SID=hiloo</p>
<h5 id="数据表信息："><a href="#数据表信息：" class="headerlink" title="数据表信息："></a>数据表信息：</h5><p>dept(表名) department 部门信息   列名<br>deptno 部门号  dname  部门名称      location 位置(地区)<br>create table dept_hiloo<br>(deptno  number(2), dname char(20),  location char(20));<br>insert into dept_hiloo values (10,’developer’,’beijing’);<br>insert into dept_hiloo values (20,’account’,’shanghai’);<br>insert into dept_hiloo values (30,’sales’,’guangzhou’);<br>insert into dept_hiloo values  ( 40,’operations’,’tianjin’);<br>commit;<br>insert成功后的提示:1 rows inserted<br>emp(表名) employee 员工信息    列名<br>empno 员工 ename 员工名字  job   职位   salary  月薪   bonus   奖金<br>hiredate  入职日期  mgr   manager 管理者    deptno  部门号<br>create table emp_hiloo(<br>empno number(4),    ename varchar2(20),  job  varchar2(15),<br>salary number(7,2), bonus number(7,2),  hiredate date,<br> mgr number(4),  deptno number(10));<br>alter session set nls_date_language=’american’;<br>insert into emp_hiloo values (1001,’zhangwuji’,’Manager’,10000,2000,’12-MAR-10’,1005,10);<br>insert into emp_hiloo values (1001,’zhangwuji’,’Manager’,10000,2000,’12-MAR-10’,1005,10);<br>insert into emp_hiloo values (1002,’liucangsong’,’Analyst’,8000,1000, ‘01-APR-11’,1001,10);<br>insert into emp_hiloo values (1003,’liyi’,’Analyst’,9000,1000,’11-APR-10’,1001,10);<br>insertinto emp_hiloo values (1004,’guofurong’,’Programmer’,5000,null,’01-JAN-11’,1001,10);<br>insertintoemp_hiloo values (1005,’zhangsanfeng’,’President’,15000,null,’15-MAY-08’,null,20);<br>insert into emp_hiloo values (1006,’yanxiaoliu’,’Manager’,5000,400,’01-FEB-09’,1005,20);<br>insert into emp_hiloo values (1007,’luwushuang’,’clerk’,3000,500,’01-FEB-06’,1006,20);<br>insert into emp_hiloo values (1008,’huangrong’,’Manager’,5000,500,’1-MAY-09’,1005,30);<br>insert into emp_hiloo values (1009,’weixiaobao’,’salesman’,4000,null,’20-FEB-09’,1008,30);<br>insert into emp_hiloo values (1010,’guojing’,’salesman’,4500,500,’10-MAY-09’,1008,30);<br>报错信息<br>ORA-00955: name is already used by an existing object(名字已经被一个存在的对象使用)<br>错误：ORA-01843:无效的月份（在中文的plsql控制台上月份要写成’10-3月-02’这种形式，必须是一个数字和一个汉语月。也可以把日期改成英文环境，在执行插入前执行alter session set nls_date_language=’american’;就可以 了。</p>
<p>DQL<br>select(选择)<br>源表  结果集<br>1 投影操作 select子句实现<br>2 选择操作 where子句实现<br>3 连接操作<br> 1  select ename,salary<em>12 ann_sal(列别名)<br> 2</em> from emp_hiloo</p>
<p>单引号 表达字符串 ‘’<br>双引号 表达列别名 “”,别名中包含空格,大小写敏感</p>
<h5 id="1）null值的理解"><a href="#1）null值的理解" class="headerlink" title="1）null值的理解"></a>1）null值的理解</h5><p>1 null值出现在算术表达式中,结果必为null,null可以看作无穷大.<br>2 函数(function) nvl功能空值转换函数<br>nvl是函数名,p1,p2是参数,数据类型必须一致,函数本身有返回值<br>nvl(p1,p2)<br>nvl函数实现:<br>if p1 is null then<br>   return p2;<br>else<br>   return p1;<br>end if;</p>
<p>3 若有多个null值,distinct去重时,结果集保留一个null值.<br>4 null = null 不成立 null &lt;&gt; null 不成立<br>5 若用in运算符,集合中有null值跟没有null值结果一致的,结果集中不会出现跟null值有关的记录<br>  若用not in运算符,集合中有null值,这个结果集不包含记录.no rows selected.</p>
<h5 id="2）各个子句的功能"><a href="#2）各个子句的功能" class="headerlink" title="2）各个子句的功能"></a>2）各个子句的功能</h5><p>1 select后面跟列名,列别名,函数,表达式<br>2 select后面的distinct:去重<br>3 where子句<br>  where 条件表达式 (列名 比较运算符 值)<br>表达式 比较运算符 值(尽量不用,为了性能)<br>  where子句中的列为字符类型,放值的位置上不加单引号或加双引号当列名解释,加单引号当字符串解释.<br>  where子句中的列为字符类型,表达具体值时注意字符是大小写敏感的.<br>SQL提供的四个比较运算符<br>肯定形式<br>   between and 区间,范围<br>   in &lt;=&gt; =any  (= or = )(跟集合里的任意一个值相等就满足条件) 集合 离散值<br>   = 单值运算符<br>   in =any 多值运算符<br>   like 像…一样<br>   通配符: %表示0或任意多个字符 <em>任意一个字符<br>   ‘S’ ‘S%’ ‘S</em>‘<br>   is null  如何判断一个列的取值是否为空<br>否定形式<br>= &lt;&gt; != ^=<br>between and   not between and<br>in    not in (&lt;&gt; and &lt;&gt;) &lt;=&gt; &lt;&gt;all(跟集合里的所有值都不能相等)<br>like     not like<br>is null   is not null<br>各个子句的执行顺序<br>from–&gt;where–&gt;select</p>
<h5 id="3）课堂练习"><a href="#3）课堂练习" class="headerlink" title="3）课堂练习"></a>3）课堂练习</h5><p>1 列出每个员工的名字和他的工资<br>  select ename,salary from emp_hiloo;<br>2 列出每个员工的名字和他的职位<br>  select ename,job from emp_hiloo;<br>3 列出每个员工的名字和他的年薪<br> select ename,salary<em>12 ann_sal from emp_hiloo;<br>4 列出每个员工的名字和他一年的总收入<br>  (salary+bonus)</em>12 (15000+null)<em>12=null<br>  select ename,(salary+nvl(bonus,0))</em>12 tol_sal<br>  from emp_hiloo;<br>5 输出结果如下:<br>  zhangwuji is in department 10.<br>  liucangsong is in department 10.<br>  …..<br>  guojing is in department 30.<br>select ename||’is in department’||deptno||’.’employee from emp_hiloo;<br>什么要加employee呢？Employee是列别名为了显示用的。<br>6 列出该公司有哪些职位<br>  select distinct(job) from emp_hiloo;<br>  select distinct job from emp_hiloo;<br>7 列出该公司不同的奖金<br>  select distinct bonus from emp_hiloo;<br>8 各个部门有哪些不同的职位?<br>  select distinct deptno,job from emp_hiloo;<br>  去重方式:deptno和job联合唯一.<br>  distinct之后和from之前的所有列联合唯一.<br>distinct是保证每一行的唯一性而非某一列的唯一性，所以必须紧跟在select后面。<br>所以distinct只能放在select后面，紧跟select不然会报缺失表达式错误。<br>9 哪些员工的工资高于5000?<br>  select ename,salary from emp_hiloo<br>  where salary &gt; 5000;<br>10 列出员工工资高于5000的员工的年薪?<br>  select ename,salary<em>12 from emp_hiloo<br>  where salary &gt; 5000;<br>11 列出员工年薪高于60000的员工的年薪?<br>  select ename,salary</em>12 from emp_hiloo<br>  where salary<em>12&gt; 60000;<br>  select ename,salary</em>12 ann_sal from emp_hiloo<br>  where ann_sal &gt; 60000(错误的写法)<br>  select ename,salary<em>12 from emp_hiloo<br>  where salary &gt; 5000;<br>12 zhangwuji的年薪是多少?<br>select ename,salary</em>12 from emp_hiloo<br>where ename=’zhangwuji’;<br>  哪些员工的职位是Manager?<br>select ename,job from emp_hiloo<br>where job=’Manager’;<br>  哪些员工的职位是clerk?<br>  select ename,job from emp_hiloo<br>  where job = ‘Manager’<br>   select ename,job from emp_hiloo<br>  where job = ‘clerk’(效率高)<br>  clerk的大小写不清楚<br>  函数:upper(),lower()<br>  select ename,job from emp_hiloo<br>  where upper(job) = ‘CLERK’ (通用性好)<br>13 员工工资在5000到10000之间的员工的年薪<br>   select ename,salary<em>12<br>   from emp_hiloo<br>   where salary &gt;= 5000<br>   and   salary &lt;= 10000;<br>   select ename,salary</em>12<br>   from emp_hiloo<br>   where salary between 5000 and 10000;<br>14 哪些员工的工资是5000或10000.<br>   select ename,salary<br>   from emp_hiloo<br>   where salary = 5000<br>   or salary = 10000<br>   select ename,salary<br>   from emp_hiloo<br>   where salary in (5000,10000)<br>   select ename,salary<br>   from emp_hiloo<br>   where salary =any (5000,10000)<br>15 哪个员工的名字的第二个字符是a.<br>   select ename<br>   from emp_hiloo<br>   where ename like ‘<em>a%’;<br>16 哪个员工的名字的第二个字符是</em>.<br>   select ename<br>   from emp_hiloo<br>   where ename like ‘__%’ escape ‘\’;<br>   第一个<em>表示任意一个字符,代表通配符<br>   \</em>必须连起来看,表示下划线本身,escape定义哪个字符可以定义转义’\’<br>17 哪些员工没有奖金?<br>   select ename,bonus<br>   from emp_hiloo<br>   where bonus is null<br>18 哪些员工有奖金?<br>   select ename,bonus<br>   from emp_hiloo<br>   where bonus is not null<br>19哪些员工的工资不是5000也不是10000.<br>  select ename,salary<br>  from emp_hiloo<br>  where salary not in (5000,10000);<br>  select ename,salary<br>  from emp_hiloo<br>  where salary &lt;&gt; 5000<br>  and salary &lt;&gt; 10000</p>
<p>create table emp_hiloo<br>( hiredate date）<br>insert into emp_hiloo values (1001,’zhangwuji’,’Manager’,10000,2000,’12-MAR-10’,1005,10);<br>解决方案：<br>    insert into emp_hiloo values (1001,’zhangwuji’,’Manager’,10000,2000,’12-3月-10’,1005,10);</p>
<h5 id="更改字段名字-mysql、orcle-："><a href="#更改字段名字-mysql、orcle-：" class="headerlink" title="更改字段名字(mysql、orcle)："></a>更改字段名字(mysql、orcle)：</h5><p>Oracle修改表<br>alter table 表名 rename column 原名 to 新名；<br>Mysql:<br>alter table 表名 change column(可写，可不写）原名 新名 字段类型；</p>
<p>ORA-00904：“ANN_SAL”:invalid identifier<br>无效的标识符</p>
<p>index(索引) view(视图) sequence(顺序号/序列号) function(函数)<br>session altered.会话已更改<br>set feed on可以设置一个，显示操作数<br>connet tiger重新建立连接  show user查看当前用户是谁。<br>edit 用记事本编辑  /运行。</p>
<p>###Function (单行、多行)###<br>单行函数:表中的一列作为函数的参数,对于每一条记录函数都有一个返回值.<br>例如:upper lower nvl<br>多行函数：表中的一列作为函数的参数,将记录分组,对于每组数据函数返回一个值.<br>例如:avg</p>
<p>####1）单行函数####<br> 根据处理参数的数据类型分为</p>
<h5 id="1）字符函数-upper-lower"><a href="#1）字符函数-upper-lower" class="headerlink" title="1）字符函数:upper,lower"></a>1）字符函数:upper,lower</h5><h5 id="2）数值函数"><a href="#2）数值函数" class="headerlink" title="2）数值函数:"></a>2）数值函数:</h5><pre><code>round 四舍五入
round(12.345,2)--&gt;12.35
round(12.345,0)=round(12.345)--&gt;12
round(12,345,-1)--&gt;10
trunc 截取
trunc(12.345,2)--&gt;12.34
trunc(12.345,0)=trunc(12.345)--&gt;12
trunc(12,345,-1)--&gt;10
</code></pre><h5 id="3-日期和日期函数"><a href="#3-日期和日期函数" class="headerlink" title="3) 日期和日期函数"></a>3) 日期和日期函数</h5><pre><code>select sysdate from dual
06-SEP-12 DD-MON-RR 
alter session set
  nls_date_format = &apos;yyyy mm dd hh24:mi:ss&apos;
session 会话 connection(连接)
</code></pre><p>   日期类型的数据是用固定的字节7个字节来存储世纪,年,月,日,时,分,秒. 格式敏感<br>   会话级 alter session set nls_date_format<br>   语句级 select to_char(c1日期类型用7个字节来表达，日期类型的数据是用固定的字节7个字节来存储世纪，年，月，日，时，分，秒。四位年的前两位代表世纪20，后两位代表当前年12<br>如果不想修改sql语句运行的话，就需要在执行该语句之前，使用alter session 命令将nls_date_language修改为american，如下：<br>alter session set nls_date_language=’american’    –以英语显示日期<br>如果不想修改sql语句运行的话，就需要在执行该语句之前，使用alter session 命令将</p>
<p>‘01-JAN-08’ 系统做了隐式数据类型转换,调用了to_date函数<br>‘2008-01-01’,用户做显式数据类型转换,自己调用<br>to_date(‘2008-01-01’,’yyyy-mm-dd’),第二个参数是对第一个参数的格式说明.<br>to_char的返回类型是字符类型,把date转换成了字符串类型,所以参数的数据类型是date.to_char函数可以获得日期的任何一部分信息,比如年,月,日等.<br>select c1 from … 系统做了隐式数据类型转换,调用了to_char函数<br>select to_char(c1,.. 用户做显式数据类型转换,自己调用to_char(c1,’yyyy-mm-dd’),第二个参数是对第一个参数的格式说明.<br>日期的运算<br>   日期可以加减一个数值,单位为天.<br>   select sysdate-1,sysdate,sysdate+1 from dual<br>两个日期相减<br>   add_months 按月加 返回类型是date<br>   add_months(sysdate,6)<br>   select add_months(hiredate,6) from emp_hiloo<br>   add_months(sysdate,-6)<br>   months_between()  返回类型是number<br>   months_between(sysdate,hiredate) 两个日期之间相差多少个月<br>select months_between(sysdate,hiredate) from emp_hiloo;<br>   last_day(sysdate) 本月的最后一天</p>
<h5 id="4-转换函数"><a href="#4-转换函数" class="headerlink" title="4) 转换函数"></a>4) 转换函数</h5><p>两个日期相减转换函数<br>to_date  char–&gt;date<br>to_char  date–&gt;char , number –&gt; char<br>to_number  char–&gt;number</p>
<h5 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h5><p>coalesce 类似nvl(oracle专有)<br>nvl(bonus,salary<em>0.1)<br>coalesce(bonus,salary</em>0.1,100)。输出所有员工的奖金，如果没有奖金就按工资的10%发放，如果奖金和工资都没有的临时工，就给100元。<br>不同的记录处理方式不一样时,用case when.<br>case when 条件表达式 then 返回结果<br>else<br>     返回结果<br>end<br>若没有else,当不匹配条件,表达式的返回值为null.<br>case deptno when 10 then(不建议该语法形式)<br>decode跟case when的功能类似.<br>decode(deptno,10,salary<em>1.1,<br>              20,salary</em>1.2,<br>              salary)<br>若没有最后一个参数,函数的返回值为null.<br>select语句<br>order by子句<br>select   from    where<br>order by<br>order by子句是select语句中的最后一个子句.<br>order by salary 缺省是升序 asc<br>order by salary desc 降序<br>order by子句后面可以跟列名,表达式(函数),列别名,在select子句中的位置.<br>ORDER BY 子句<br>ORDER BY 语句用于对结果集进行排序。<br>ORDER BY 语句<br>ORDER BY 语句用于根据指定的列对结果集进行排序。<br>ORDER BY 语句默认按照升序对记录进行排序。<br>如果您希望按照降序对记录进行排序，可以使用 DESC 关键字。<br>原始的表 (用在例子中的)：<br>Orders 表:<br>Company    OrderNumber<br>IBM    3532<br>W3School    2356<br>Apple    4698<br>W3School    6953<br>实例 1<br>以字母顺序显示公司名称：<br>SELECT Company, OrderNumber FROM Orders ORDER BY Company<br>结果：<br>Company    OrderNumber<br>Apple    4698<br>IBM    3532<br>W3School    6953<br>W3School    2356<br>实例 2<br>以字母顺序显示公司名称（Company），并以数字顺序显示顺序号（OrderNumber）：<br>SELECT Company, OrderNumber FROM Orders ORDER BY Company, OrderNumber<br>结果：<br>Company    OrderNumber<br>Apple    4698<br>IBM    3532<br>W3School    2356<br>W3School    6953<br>实例 3<br>以逆字母顺序显示公司名称：<br>SELECT Company, OrderNumber FROM Orders ORDER BY Company DESC<br>结果：<br>Company    OrderNumber<br>W3School    6953<br>W3School    2356<br>IBM    3532<br>Apple    4698<br>实例 4<br>以逆字母顺序显示公司名称，并以数字顺序显示顺序号：<br>SELECT Company, OrderNumber FROM Orders ORDER BY Company DESC, OrderNumber ASC<br>结果：<br>Company    OrderNumber<br>W3School    2356<br>W3School    6953<br>IBM    3532<br>Apple    4698<br>注意：在以上的结果中有两个相等的公司名称 (W3School)。只有这一次，在第一列中有相同的值时，第二列是以升序排列的。如果第一列中有些值为 nulls 时，情况也是这样的。</p>
<h4 id="2-多行函数-哪两个函数里只能放number"><a href="#2-多行函数-哪两个函数里只能放number" class="headerlink" title="2) 多行函数(哪两个函数里只能放number)"></a>2) 多行函数(哪两个函数里只能放number)</h4><p>avg()    平均值  函数的参数只能是number<br>sum()    求和    函数的参数只能是number<br>count()    计数 函数的参数可以是number date 字符<br>        count(*)统计记录,count(bonus)<br>max() 最大值 函数的参数可以是number date 字符<br>min() 最小值 函数的参数可以是number date 字符</p>
<p>组函数的缺省处理方式是处理所有的非空值.<br>avg(bonus) 所有有奖金的员工的平均值<br>count(bonus) 有奖金的员工个数<br>当所有的值都是null,count函数返回0,其他组函数返回null.</p>
<h4 id="3-group-by子句"><a href="#3-group-by子句" class="headerlink" title="3) group by子句"></a>3) group by子句</h4><p>若有group by子句,select后面跟组标识和组函数<br>组标识指group by后面的内容<br>from–&gt;where–&gt;group by–&gt;select–&gt;order by<br>若没有group by子句,select后面只要有一个是组函数,其余的都得是组函数.</p>
<h4 id="having子句"><a href="#having子句" class="headerlink" title="having子句"></a>having子句</h4><p>select deptno,round(avg(salary)) davg<br>from emp_hiloo<br>group by deptno<br>having round(avg(salary))&gt; 5000</p>
<p>from–&gt;where–&gt;group by–&gt;having–&gt;select–&gt;order by </p>
<h4 id="GROUP-BY-语句"><a href="#GROUP-BY-语句" class="headerlink" title="GROUP BY 语句"></a>GROUP BY 语句</h4><p>GROUP BY 语句用于结合合计函数，根据一个或多个列对结果集进行分组。<br>SQL GROUP BY 语法<br>SELECT column_name, aggregate_function(column_name)<br>FROM table_name<br>WHERE column_name operator value<br>GROUP BY column_name<br>SQL GROUP BY 实例<br>我们拥有下面这个 “Orders” 表：<br>O_Id    OrderDate    OrderPrice    Customer<br>1    2008/12/29    1000    Bush<br>2    2008/11/23    1600    Carter<br>3    2008/10/05    700    Bush<br>4    2008/09/28    300    Bush<br>5    2008/08/06    2000    Adams<br>6    2008/07/21    100    Carter<br>现在，我们希望查找每个客户的总金额（总订单）。我们想要使用 GROUP BY 语句对客户进行组合。<br>我们使用下列 SQL 语句：<br>SELECT Customer,SUM(OrderPrice) FROM Orders<br>GROUP BY Customer<br>结果集类似这样：<br>Customer    SUM(OrderPrice)<br>Bush    2000<br>Carter    1700<br>Adams    2000<br>很棒吧，对不对？<br>让我们看一下如果省略 GROUP BY 会出现什么情况：<br>SELECT Customer,SUM(OrderPrice) FROM Orders<br>结果集类似这样：<br>Customer    SUM(OrderPrice)<br>Bush    5700<br>Carter    5700<br>Bush    5700<br>Bush    5700<br>Adams    5700<br>Carter    5700<br>上面的结果集不是我们需要的。<br>那么为什么不能使用上面这条 SELECT 语句呢？解释如下：上面的 SELECT 语句指定了两列（Customer 和 SUM(OrderPrice)）。”SUM(OrderPrice)” 返回一个单独的值（”OrderPrice” 列的总计），而 “Customer” 返回 6 个值（每个值对应 “Orders” 表中的每一行）。因此，我们得不到正确的结果。不过，您已经看到了，GROUP BY 语句解决了这个问题。<br>GROUP BY 一个以上的列<br>我们也可以对一个以上的列应用 GROUP BY 语句，就像这样：<br>SELECT Customer,OrderDate,SUM(OrderPrice) FROM Orders<br>GROUP BY Customer,OrderDate</p>
<h4 id="4-where和having比较"><a href="#4-where和having比较" class="headerlink" title="4) where和having比较"></a>4) where和having比较</h4><p>共同点:都执行在select之前,都有过滤功能<br>区别<br>where执行在having之前<br>where过滤的是记录,任意列名都可以出现在where子句,单行函数可以用在where子句,组函数不能出现在where子句<br>having过滤的是组,组标识可以出现在having子句,其他列名不行,组函数用于having子句,单行函数不可以.</p>
<h5 id="HAVING-子句"><a href="#HAVING-子句" class="headerlink" title="HAVING 子句"></a>HAVING 子句</h5><p>在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与合计函数一起使用。<br>SQL HAVING 语法<br>SELECT column_name, aggregate_function(column_name)<br>FROM table_name<br>WHERE column_name operator value<br>GROUP BY column_name<br>HAVING aggregate_function(column_name) operator value<br>SQL HAVING 实例<br>我们拥有下面这个 “Orders” 表：<br>O_Id    OrderDate    OrderPrice    Customer<br>1    2008/12/29    1000    Bush<br>2    2008/11/23    1600    Carter<br>3    2008/10/05    700    Bush<br>4    2008/09/28    300    Bush<br>5    2008/08/06    2000    Adams<br>6    2008/07/21    100    Carter<br>现在，我们希望查找订单总金额少于 2000 的客户。<br>我们使用如下 SQL 语句：<br>SELECT Customer,SUM(OrderPrice) FROM Orders<br>GROUP BY Customer<br>HAVING SUM(OrderPrice)<2000 1500="" 1700="" 结果集类似：="" customer="" sum(orderprice)="" carter="" 现在我们希望查找客户="" "bush"="" 或="" "adams"="" 拥有超过="" 的订单总金额。="" 我们在="" sql="" 语句中增加了一个普通的="" where="" 子句：="" select="" customer,sum(orderprice)="" from="" orders="" or="" group="" by="" having="">1500<br>结果集：<br>Customer    SUM(OrderPrice)<br>Bush    2000<br>Adams    2000</2000></p>
<h4 id="5-DCL"><a href="#5-DCL" class="headerlink" title="5) DCL"></a>5) DCL</h4><p>connect openlab/open123<br>select count(*) from hiloo.emp_hiloo;</p>
<p>connect hiloo/hiloo123<br>grant select on emp_hiloo to openlab;</p>
<p>connect openlab/open123<br>select count(*) from hilool.emp_hiloo<br>10rows selected</p>
<p>connect hiloo/hiloo123<br>revoke select on emp_hiloo from openlab;</p>
<p>show user<br>select count(*) from hiloo.emp_hiloo</p>
<p>create synonym emp_hiloo for hiloo.emp_hiloo</p>
<h4 id="6-关于null值的讨论"><a href="#6-关于null值的讨论" class="headerlink" title="6) 关于null值的讨论"></a>6) 关于null值的讨论</h4><p>1 case when在没有else和decode少一个参数时,返回null.<br>2order by bonus,asc升序时null值在最后,desc降序时null在最前.<br>3 组函数和null值的关系:1组函数的缺省处理方式是处理所有的非空值.2当所有的值都是null,count函数返回0,其他组函数返回null.<br>4若group by的列有null值,所有的null值分在一组.<br>课堂练习<br>1将每个员工的工资涨12.34567%,用round和trunc分别实现<br>select ename,nvl(trunc(round(salary+salary*0.1234567,2),1),0.0) from emp_hiloo;//自己写的。<br>2 将’2008-01-01’插入表中,<br>  再将’2008 08 08 08:08:08’插入表中<br>insert into test values<br>(to_date(‘01-JAN-08’,’DD-MON-RR’));</p>
<p>3找出3月份入职的员工.<br>select ename,hiredate<br>from emp_hiloo<br>where to_char(hiredate,’mm’) = ‘03’;<br>select ename,hiredate<br>from emp_hiloo<br>where to_char(hiredate,’mm’) = 3;//可以正常输出winXP下<br>‘03’ = 3  —&gt; to_number(‘03’) = 3<br>字符   数值  缺省系统将字符转成数值<br>select ename,hiredate<br>from emp_hiloo<br>where to_char(hiredate,’fmmm’) = ‘03’;(错，未选定行，无输出)</p>
<p>select ename,hiredate<br>from emp_hiloo<br>where to_char(hiredate,’fmmm’) = ‘3’;(对)<br>‘03’ = ‘3’ (错)<br>fm表示去掉前导0或去掉两边的空格.<br>4 zhangsanfeng的mgr上显示boss,其他人不变.<br>select ename,empno,<br>       nvl(to_char(mgr),’boss’) mgr<br>from emp_hiloo<br>函数nvl（“1”，“2”）:如果字符串1是空，就返回字符串”2”</p>
<h4 id="5十分钟之后"><a href="#5十分钟之后" class="headerlink" title="5十分钟之后"></a>5十分钟之后</h4><p> select sysdate,sysdate+1/144 from dual;<br>解释：Oracle 里面,</p>
<p>sysdate + 1 意思是 当前时间 + 1天</p>
<p>sysdate + 1/24  意思是 当前时间 + 1/24天  也就是1小时后</p>
<p>sysdate+1/144  意思是 当前时间 + 1/144天 （1/24<em>6）  也就是10分钟后<br> 6 若员工是10部门的,工资涨10%,20部门工资涨20%,其他员工工资不变.<br>select ename,salary,<br>       case when deptno = 10 then salary</em>1.1<br>            when deptno = 20 then salary*1.2<br>       else<br>            salary<br>       end new_sal<br>from emp_hiloo;</p>
<p>select ename,salary,<br>       decode(deptno,10,salary<em>1.1,<br>                     20,salary</em>1.2,<br>                     salary) new_sal<br>from emp_hiloo;<br>7 列出每个员工的年薪,按年薪降序排列.<br>select ename,salary<em>12<br>from emp_hiloo<br>order by salary desc (好)<br>select ename,salary</em>12<br>from emp_hiloo<br>order by salary<em>12 desc<br>select ename,salary</em>12 n_sal<br>from emp_hiloo<br>order by n_sal desc</p>
<p>select ename,salary<em>12 n_sal from emp_hiloo order by 2 desc;<br>select salary</em>12,ename n_sal from emp_hiloo order by 2 asc;<br>8 列出员工的名字,部门号以及工资,按部门号从小到大的顺序,同一部门的工资按降序排列.<br>select ename,deptno,salary<br>from emp_hiloo<br>order by deptno,salary desc<br>9 列出奖金的平均值,和,个数,最大值,最小值.<br>AVG 函数返回数值列的平均值。NULL 值不包括在计算中<br>select avg(bonus),avg(nvl(bonus,0)),<br>       sum(bonus), sum(nvl(bonus,0)),<br>       count(bonus),count(nvl(bonus,0)),<br>       max(bonus),max(nvl(bonus,0)),<br>       min(bonus),min(nvl(bonus,0))<br>from emp_hiloo<br>10 各个部门的平均工资<br>ROUND 函数用于把数值字段舍入为指定的小数位数。<br>select deptno,round(avg(salary))<br>from emp_hiloo<br>group by deptno<br>11 求10部门的平均工资,只显示平均工资<br>   求10部门的平均工资,显示部门号,平均工资<br>   select round(avg(salary))<br>   from emp_hiloo<br>   where deptno = 10<br>   group by deptno</p>
<p>   select max(deptno),round(avg(salary))<br>   from emp_hiloo<br>   where deptno = 10<br>12各个部门不同职位的平均工资<br>   select deptno,job,round(avg(salary))<br>   from emp_hiloo<br>   group by deptno,job<br>13 每种奖金有多少人?<br>   select bonus,count(empno)<br>   from emp_hiloo<br>   group by bonus<br>14 列出平均工资大于5000的部门的平均工资<br>   select deptno,round(avg(salary))<br>   from emp_hiloo<br>   group by deptno<br>   having round(avg(salary)) &gt; 5000<br>15哪些员工的工资是最低的.<br>  select ename from emp_hiloo<br>  where salary = ( select min(salary)<br>                   from emp_hiloo)<br>报错信息<br>ORA-01861: literal does not match format string<br>文字值不匹配格式串<br>ORA-01722: invalid number 无效的数值 to_number<br>ORA-00937: not a single-group group function 不是一个组函数<br>ORA-00979: not a GROUP BY expression 不是一个group by表达式 GROUP BY expression指跟在group by后面的东西(列名),称之为组标识<br>detail 细节 summary 聚合</p>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>子查询定义<br>在SQL语句中嵌入select语句<br>create table new_tabname<br>as<br>select ename,salary*12 ann_sal from emp_hiloo;<br>新表的结构由select后面的项来决定,new_table包含两列ename,ann_sal.</p>
<h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><p>  非关联子查询<br>    单列子查询<br>    多列子查询<br>  关联子查询</p>
<h5 id="子查询执行"><a href="#子查询执行" class="headerlink" title="子查询执行"></a>子查询执行</h5><p>非关联子查询<br>子查询的表和主查询的表没有建关联<br>先执行子查询(只执行一遍),当返回多条记录,系统会将自动去重的结果返回给主查询,再执行主查询.</p>
<p>关联子查询<br>子查询的表和主查询的表建关联.所谓建关联指主查询表里的列和子查询表里的列写成一个条件表达式.</p>
<p>先执行主查询,判断表里的记录是否应该放入结果集.过程如下:拿到第一条记录,获得了各个列的值,将需要的列值带入子查询,执行后返回的结果再和主查询表里的列做比较,符合条件,该记录放入结果集,否则过滤掉.依次执行主查询表里的每条记录.子查询执行的次数由主查询表里的记录数决定.</p>
<p>1) exists和not exists<br>exists的执行过程<br>从主查询表里拿到第一条记录,按子查询里的关联条件在子查询的表里看是否能找到匹配的记录,当找到第一条匹配的记录后,立即返回(即不需要找出所有匹配的记录),exists条件满足,主查询表里的该记录放入结果集.若按子查询里的关联条件将子查询<br>表里的记录全部检查一遍后没有一条符合条件的记录,此时也返回, exists 条件不满足,主查询表里的该记录不能放入结果集,被过滤掉.</p>
<p>select ename from emp_afei o<br>where exists<br>             (select 1 from emp_afei i<br>              where o.empno = i.mgr)</p>
<h5 id="非关联子查询的分类"><a href="#非关联子查询的分类" class="headerlink" title="非关联子查询的分类"></a>非关联子查询的分类</h5><p>单列子查询<br>select ename,salary<br>from emp_hiloo<br>where salary = (select min(salary)<br>                from emp_hiloo<br>                )<br>多列子查询:按键值对比较<br>select ename,salary,deptno<br>from emp_afei<br>where (deptno,salary) in<br>             (select deptno,round(avg(salary))<br>              from emp_afei<br>              group by deptno)</p>
<p>2) 课堂练习<br>1哪些人是领导?(非关联子查询)<br>如果一个员工的empno能出现在mgr里就说明他是领导.<br>select ename<br>from emp_hiloo<br>where empno in (select mgr from emp_hiloo)<br>select ename<br>fro emp_afei<br>where empno in (1001,1005,1006,1008,null)<br>2 哪些人是员工?<br>他的empno绝对不能出现在mgr中,他的empno跟mgr的出现的所有的值不能相等. &lt;&gt;all<br>select ename<br>from emp_hiloo<br>where empno not in (select mgr from emp_hiloo)<br>select ename<br>fro emp_afei<br>where empno not in (1001,1005,1006,1008,null)<br>select ename<br>from emp_hiloo<br>where empno not in (select mgr from emp_hiloo<br>                    where mgr is not null)</p>
<p>3哪些部门的平均工资比30部门的平均工资高?<br>select deptno,round(avg(salary))<br>from emp_hiloo<br>group by deptno<br>having round(avg(salary)) &gt;<br>                    (select round(avg(salary))<br>                     from emp_hiloo<br>                     where deptno = 30)<br>4哪些员工的工资比zhangwuji的工资高?<br>select ename,salary<br>from emp_afei<br>where salary &gt; (select salary from emp_afei<br>                where ename = ‘zhangwuji’)<br>ERROR at line 3:<br>ORA-01427: single-row subquery returns more than one row<br>单行子查询返回多条记录</p>
<p>比所有人高 &gt; (select max(salary))<br>           &gt;all<br>比任意人高 &gt; (select min(salary)<br>           &gt;any<br>5哪些员工的工资等于本部门的平均工资?<br>select ename,salary,deptno<br>from emp_afei<br>where (deptno,salary) in<br>             (select deptno,round(avg(salary))<br>              from emp_afei<br>              group by deptno)<br>5哪些员工的工资比本部门的平均工资高?<br>select ename,salary,deptno<br>from emp_afei o<br>where salary &gt; (select round(avg(salary))<br>                from emp_afei i<br>                where i.deptno = o.deptno)<br>6哪些人是领导?(关联子查询)<br>select ename from emp_afei o<br>where exists<br>             (select 1 from emp_afei i<br>              where o.empno = i.mgr)<br>7哪些部门有员工?<br>select deptno,dname<br>from dept_afei o<br>where exists (select 1 from emp_afei i<br>              where o.deptno = i.deptno)</p>
<p>3) 课外练习day03am<br>1 zhangwuji的领导是谁,显示名称?<br>2 zangwuji领导谁,显示名称?<br>3 列出devoleper部门有哪些职位?<br>1) 课外练习day04am答案<br>1 zhangwuji的领导是谁,显示名称?<br>  select ename from emp_afei<br>  where empno in<br>        (select mgr from emp_afei<br>                 where ename = ‘zhangwuji’)</p>
<p>zangwuji领导谁,显示名称?</p>
<p> select ename from emp_afei<br> where mgr in (select empno from emp_afei<br>               where ename = ‘zhangwuji’)</p>
<p>3 列出developer部门有哪些职位?<br>  select distinct job from emp_afei<br>  where deptno in<br>           (select deptno from dept_afei<br>            where dname = ‘developer’)</p>
<p>2) 非关联子查询<br>exists和not exists<br>not exists的执行过程<br>从主查询表里拿到第一条记录,按子查询里的关联条件在子查询的表里看是否能找到匹配的记录,当找到第一条匹配的记录后,立即返回(即不需要找出所有匹配的记录),not exists条件不满足,主查询表里的该记录不能放入结果集,被过滤掉.若按子查询里的关联条件将子查询表里的记录全部检查一遍后没有一条符合条件的记录,返回, not exists 条件满足,主查询表里的该记录放入结果集.</p>
<p>对于exists和not exists,在子查询中找到第一条匹配的记录都会立即返回,exists将主查询表里的记录放入结果集,not exsits将主查询表里的记录过滤掉.<br>对于exists和not exists,如果子查询没有返回任何记录,即扫描全部记录后没有一条符合条件的记录,都返回,exists将主查询表里的记录过滤掉,not exists将主查询表里的记录放入结果集.<br>not in ,&lt;&gt; all逻辑上跟not exists等价<br>in ,=any逻辑上跟exists等价</p>
<p>查询形式:集合操作<br>把结果集作为一个集合,结果集必须是同构的,列的个数及数据类型一致</p>
<p>3) 并集  union(去重)/union all(不去重)<br>select ename,deptno,salary,salary<em>1.1 new_sal<br>from emp_afei<br>where deptno = 10<br>union all<br>select ename,deptno,salary,salary</em>1.2 new_sal<br>from emp_afei<br>where deptno = 20<br>union all<br>select ename,deptno,salary,salary new_sal<br>from emp_afei<br>where deptno not in (10,20)</p>
<p>case when和decode可以实现类似功能.</p>
<p>4) 交集  intersect(去重)<br>select job from emp_afei<br>where deptno = 10<br>intersect<br>select job from emp_afei<br>where deptno = 20<br>10部门和20部门都有的职位是哪些?</p>
<p>5) 差  minus(去重)<br>select deptno from dept_afei<br>minus<br>select deptno from emp_afei<br>那些部门没有员工.</p>
<p>6) 多表查询<br>1) 交叉连接 cross join<br>select e.ename,d.dname<br>from emp_afei e cross join dept_afei d<br>结果集产生<br>10*4=40,组合操作,笛卡尔积</p>
<p>2) 内连接 inner join(匹配一个条件)<br>select e.ename,e.deptno,d.deptno,d.dname<br>from emp_afei e join dept_afei d<br>ORA-00905: missing keyword(丢失关键字)</p>
<p>如果把结果集的产生看成双层循环,驱动表是外层循环,匹配表是内层循环.<br>对于内连接哪张表做驱动表,哪张表做匹配表产生出的结果集是一样的,不同的是性能.<br>驱动表在匹配表的匹配情况如下:<br>一条记录找到一条匹配<br>一条记录找到多条匹配<br>一条记录找不到任何匹配.<br>内连接的核心是驱动表的记录要出现在结果集中必须在匹配表中能找到匹配的记录,否则该记录被过滤掉.</p>
<p>3) 内连接查询形式<br>等值连接 on e.deptno = d.deptno<br>两张表有表述同一属性的列,两张表都有deptno列.<br>自连接 on e.mgr = m.empno<br>同一张表的不同列能写成一个表达式,即同一张表的两条记录之间有关系.通过给表起别名的方式,将同一张表的两条记录之间的关系转化成不同表的两条记录之间的关系.<br>4) 外连接<br>外连接 outer join(驱动表的记录一个都不能少的出现在结果集里)<br>from t1 left join t2<br>on t1.c1 = t2.c2(t1驱动表,t2匹配表)<br>外连接结果集=内连接的结果集+t1表中匹配不上的记录和t2表中的null记录的组合<br>from t1 right join t2<br>on t1.c1 = t2.c2(t2驱动表,t1匹配表)<br>外连接结果集=内连接的结果集+t2表中匹配不上的记录和t1表中的null记录的组合<br>from t1 full join t2<br>on t1.c1 = t2.c2<br>外连接结果集=内连接的结果集+t1表中匹配不上的记录和t2表中的null记录的组合+t2表中匹配不上的记录和t1表中的null记录的组合</p>
<p>5) 外连接的应用场景<br>1 某张表的记录全部出现在结果集中,包括匹配不上的.<br>select e.ename,nvl(m.ename,’Boss’)<br>from emp_afei e left join emp_afei m<br>on e.mgr = m.empno<br>2解决否定问题,匹配不上的记录找出来(跟所有的记录都不匹配.)(not in/not exists)<br>外连接 + where 匹配表.主键列 is null<br>select e.ename,d.dname<br>from emp_afei e right join dept_afei d<br>on e.deptno = d.deptno<br>where e.empno is null<br>(解决结果集只包含匹配不上的记录.where子句执行在外连接之后)哪些部门没有员工</p>
<p>select d.dname<br>from emp_afei e right join  dept_afei d<br>on e.deptno = d.deptno<br>and e.ename = ‘zhangwuji’<br>where e.empno is null<br>如果希望在外连接之前过滤匹配表用and子句,如果想在外连接之后通过匹配表里的列过滤外连接的结果集时候用where.<br>过滤驱动表统计用where子句过滤.</p>
<p>6) 课内练习<br>1 哪些部门没有员工(not exists)<br>  select dname from dept_afei o<br>  where not exists<br>        (select 1 from emp_afei i<br>         where o.deptno = i.deptno)<br>2 哪些人是员工?(not exists)<br>  select ename from emp_afei o<br>  where not exists<br>            (select 1 from emp_afei i<br>             where o.empno = i.mgr)<br>他的empno和其他人的mgr相等是不可能存在的.即和所有人的mgr都不相等.<br>not in ,&lt;&gt; all逻辑上跟not exists等价<br>3 列出哪些员工在北京地区上班?<br>思路:确定表,两张表,匹配问题用inner join–&gt;on(匹配条件)–&gt;(对表是否过滤)<br>select e.ename,e.deptno,d.deptno,d.dname<br>from emp_afei e join dept_afei d<br>on e.deptno = d.deptno<br>and d.location = ‘beijing’<br>4zhangwuji在哪个地区上班?<br>select e.ename,d.dname,d.location<br>from emp_afei e join dept_afei d<br>on e.deptno = d.deptno<br>and e.ename = ‘zhangwuji’<br>5列出每个部门有哪些职位?部门名称,职位<br> select distinct d.dname,e.job<br> from emp_afei e join dept_afei d<br> on e.deptno = d.deptno<br> order by d.dname<br>6各个部门的平均工资,列出部门名称,平均工资.<br>select d.dname,round(avg(e.salary)) savg<br>from emp_afei e join dept_afei d<br>on e.deptno = d.deptno<br>group by d.dname<br>select max(d.dname),round(avg(e.salary)) savg<br>from emp_afei e join dept_afei d<br>on e.deptno = d.deptno<br>group by d.deptno<br>select min(deptno),round(avg(salary))<br>from emp_hiloo<br>where deptno = 10<br>7 列出每个员工的名字和他的领导的名字<br>select e.ename employee,<br>       m.ename manager<br>from emp_afei e join emp_afei m<br>on e.mgr = m.empno<br>结果集是9条.<br>e表中有10条记录,其中9条记录找到匹配,zhangsanfeng没匹配<br>m表中有10条记录,其中4条记录找到匹配,4条记录是领导,6条记录找不到匹配,他们是员工.<br>select e.ename employee,<br>       m.ename manager<br>from emp_afei e join emp_afei m<br>on e.mgr = m.empno<br>union all<br>select ename,’Boss’<br>from emp_afei<br>where mgr is null</p>
<p>select e.ename employee,<br>       decode(m.ename,e.ename,’Boss’,<br>                  m.ename)   manager<br>from emp_afei e join emp_afei m<br>on nvl(e.mgr,e.empno) = m.empno</p>
<p>select e.ename,nvl(m.ename,’Boss’)<br>from emp_afei e left join emp_afei m<br>on e.mgr = m.empno<br>10=9+1</p>
<p>8哪些人是领导?<br>select distinct m.ename<br>from emp_afei e join emp_afei m<br>on e.mgr = m.empno<br>9哪些部门没有员工?<br>select e.ename,d.dname<br>from emp_afei e right join dept_afei d<br>on e.deptno = d.deptno<br>where e.empno is null<br>(解决结果集只包含匹配不上的记录.where子句执行在外连接之后)<br>11=10+1<br>如果部门表里的某条记录的deptno在emp表找不到匹配,在内连接中,它被过滤,<br>e表的empno的特性是唯一且非空的(主键约束),居然e.empno is null,说明null是外连接时为了驱动表中那条匹配不上的记录出现在结果集中,在匹配表中模拟的null记录.<br>10哪些人是员工,哪些人不是领导?<br>select e.empno,m.ename<br>from emp_afei e right join emp_afei m<br>on e.mgr = m.empno<br>where e.empno is null</p>
<p>from emp_afei e right join emp_afei m<br>15=9+(10(m表中有10条记录)-4(m表中有4条匹配记录 ))<br>from emp_afei e left join emp_afei m<br>10(结果集)=9+(10(e表中有10条记录)-9(e表中有9条匹配记录))<br>11 哪些部门没有叫zhangwuji的?<br>select d.dname<br>from emp_afei e right join  dept_afei d<br>on e.deptno = d.deptno<br>and e.ename = ‘zhangwuji’<br>where e.empno is null</p>
<p>7) 课外练习(day04)(答案在Day05)<br>1zhangwuji的领导是谁?(表连接)<br>2zhangwuji领导谁?(表连接)<br>3哪些人是领导?(in exists join)<br>4哪些部门没有员工?(not in/not exists/outer join)<br>5哪些人是员工,哪些人不是领导?(not in/not exists/outer join)<br>Day05.txt<br>Grade级别<br>Lowsal最低工资<br>Hisal最高工资<br>Create table salgrade_hiloo(<br>Grade<br>)<br>cross join  inner join   outer join<br>inner join(匹配)<br>  等值连接<br>  自连接<br>  非等值连接<br>outer join(匹配+不匹配)<br>  等值连接</p>
<p>  自连接<br>  非等值连接</p>
<p>所谓非等值连接表示两张表里的列不能写成等值表达式,而是写成between and之类.所以两个表之间有关系是指表里的列可以写成表达式,而不是等值表达式.<br>salgrade<br>grade  级别<br>lowsal 最低工资<br>hisal  最高工资</p>
<p>from后面跟子查询<br>emp,各个部门的平均工资dept_avgsal(depnto,avgsal)<br>select e.ename,e.salary,e.deptno<br>from emp_afei e join<br>      (select deptno,round(avg(salary)) avgsal<br>       from emp_afei<br>       group by deptno) a<br>on e.deptno = a.deptno<br>and e.salary &gt; a.avgsal</p>
<p>各个部门的平均工资,列出部门名称,平均工资<br>select max(d.dname),round(avg(salary))<br>from emp_afei e join dept_afei d<br>on e.deptno = d.deptno<br>group by d.deptno</p>
<p>select d.dname,a.avgsal<br>from dept_afei d join<br>      (select deptno,round(avg(salary)) avgsal<br>       from emp_afei<br>       group by deptno) a<br>on d.deptno = a.depto</p>
<p>DML<br>insert一条记录时,若某些列为null值,有哪些语法实现?<br>insert into tabname values (1,’a’,null,sysdate)<br>insert into tabname(c1,c2,c4)<br>values (1,’a’,sysdate)<br>insert语句的两种语法形式?<br>insert into tabname values () insert一条记录<br>insert into tabname<br>select * from tabname1  insert多条记录<br>连接图解：</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>1) 课外练习答案day04<br>1zhangwuji的领导是谁?(表连接)<br> select m.ename<br> from emp_afei e join emp_afei m<br> on e.mgr = m.empno<br> and m.ename = ‘zhangwuji’<br>2 zhanghangwuji领导谁?(表连接)<br> select e.ename<br> from emp_afei e join emp_afei m<br> on e.mgr = m.empno<br> and m.ename = ‘zhangwuji’<br>3哪些人是领导?(in exists join)<br> select ename from emp_afei<br> where empno in (select mgr from emp_afei)<br> select ename from emp_afei o<br> where exists<br>            (select 1 from emp_afei i<br>             where o.empno = i.mgr)<br> select distinct m.ename<br> from emp_afei e join emp_afei m<br> on e.mgr = m.empno<br>4哪些部门没有员工?(not in/not exists/outer join)<br> select dname from dept_afei<br> where deptno not in<br>               (select deptno from emp_afei)<br> select dname from dept_afei o<br> where not exists<br>             (select 1 from emp_afei i<br>              where o.deptno = i.deptno)<br> select d.dname<br> from emp_afei e right join dept_afei d<br> on e.deptno = d.deptno<br> where e.empno is null<br>5哪些人是员工,哪些人不是领导?(not in/not exists/outer join)<br> select ename from emp_afei<br> where empno not in (<br>               select mgr from emp_afei<br>               where mgr is not null)<br> select ename from emp_afei o<br> where not exists<br>             (select 1 from emp_afei i<br>              where o.empno = i.mgr)<br> select m.ename<br> from emp_afei e right join emp_afei m<br> on e.mgr = m.empno<br> where e.empno is null<br>cross join (笛卡尔积)</p>
<p>rownum 伪列,记录号<br>若用rownum选择出记录,编号必须从1开始.<br>分页问题<br>第一页<br>select rownum,ename<br>from emp_afei<br>where rownum &lt;= 3;<br>第二页<br>select rn,ename<br>from (<br>      select rownum rn,ename<br>      from emp_afei<br>      where rownum &lt;= 6)<br>where rn between 4 and 6<br>排名问题<br>按工资排名的前三条记录<br>select rownum,ename,salary<br>from emp_hiloo<br>where rownum &lt;=3<br>order by salary desc;(错)</p>
<p>select rownum,ename,salary<br>from ( select ename,salary<br>       from emp_afei<br>       order by salary desc)<br>where rownum &lt;= 3</p>
<p>update语句的中set后面的=是什么含义?where后面的=是什么含义?<br>set c1 = null (= 赋值)<br>where c1 = null (= 等号)</p>
<p>update和delete语句中的where子句是什么含义?<br>用来确定对表里的哪些记录要进行update或delete操作,没有where子句多表里的所有记录update或delete<br>update<br>set<br>where c1 = (select …)<br>rename 关键字 17<br>commit</p>
<p>1011 abc 1000 10 ‘clerk’<br>update 1001 1000–&gt;2000<br>delete 1011<br>commit<br>如何编写和运行一个sql脚本(文本文件)<br>1 编辑文件<br>在linux环境下已经编写好了test.sql,做一个鼠标右键的copy</p>
<p>在20,23,26机器上,<br>vi test.sql<br>按a i o进入编辑模式,paste,按esc键,再按:wq!回车</p>
<p>2 运行文件<br>sun-server% sqlplus openlab/open123 @test.sql<br>@表示运行<br>SP2-0310: unable to open file “test.sql”在当前目录下没有test.sql文件<br>sqlplus openlab/open123 ../test.sql</p>
<p>cd ..<br>sun-server% sqlplus openlab/open123 @test.sql</p>
<p>SQL&gt;@test.sql</p>
<p>数据库对象 PL/SQL<br>create or replace function test<br>insert into test values (1,1)<br>            *<br>ERROR at line 1:<br>ORA-04044: procedure(存储过程), function(函数), package(包), or type is not allowed here</p>
<p>事务(transaction 交易)<br>事务里包含的DML语句<br>事务的结束<br>commit 提交,(dml操作的数据入库了)<br>rollback 回滚 撤销(DML操作被取消)<br>sqlplus正常退出=commit<br>DDL语句自动提交<br>开始<br>上一个事务的结束是下一个事务的开始.<br>一致状态<br>数据库的数据被事务改变.<br>oltp online transaction processing联机事务处理系统 高并发系统</p>
<p>事务的隔离级别 read committed(读已经提交了的数据)</p>
<p>如果不commit—–&gt;commit rollback<br>1如果不commit,其他session是看不见你的操作<br>2如果不commit,会阻塞操作同一条记录的事务(session),commit才能释放所有DML加的锁.<br>3如果不commit,系统做DML操作,会将old data放入rollback segment(回滚段) ,所占用的回滚段资源不释放.</p>
<p>DML系统会自动给表及表里的记录加锁<br>表级共享锁<br>行级排他锁<br>    表级共享锁     行级排他锁<br>s1    ok        ok<br>s2    ok        enqueue wait<br>s3    ok        ok</p>
<p>执行DDL语句,系统自动加DDL排他锁<br>SQL&gt; drop table test purge;<br>drop table test purge<br>           *<br>ERROR at line 1:<br>ORA-00054: resource busy(资源忙 test表) and acquire with NOWAIT specified (dml wait,ddl nowait 如果加不上锁,报错退出)</p>
<p>DDL语句<br>字符类型<br>varchar2,必须带宽度, 按字符串的实际长度存,本身的数据是变化,对空格敏感<br>char,可以不带宽度,缺省宽度是1,按字符串的定义长度存,本身的数据是固定长度的.对空格不敏感<br>数值类型</p>
<p>number类型<br>create table test90<br>(c1 number,<br> c2 number(6),<br> c3 number(4,2),<br> c4 number(2,4),<br> c5 number(3,-3))</p>
<p>四舍五入<br>number(6) 表示6为整数 999999<br>number(4,2) 表示小数点后2位,整数位2位 99.99<br>number(2,4) 表示小数点后4位,能填数字的位数是2位 0.0099<br>number(3,-3) 999000 999123–&gt;999000<br>                    999511–&gt;报错</p>
<p>user_tables 是一张系统表,里面记录当前用户所有的表的信息,里面没有记录表的创建日期.<br>user_objects 是一张系统表,里面记录当前用户所有的数据库对象的信息.created的列记录数据库对象(如表)的创建日期.<br>user_tables和user_objects这两张表的关系体现在table_name和object_name都记录的是表名.</p>
<p>data block 数据块,操作数据的最小逻辑(物理)单元,最少读一个block的数据</p>
<p>HWM high water mark 高水位线,表示曾经插入数据的最高位置<br>FTS full table scan 全表扫描,把表里的所有记录读一遍,把HWM之下的所有data block读一遍</p>
<p>truncate table 释放空间,HWM下移<br>delete 不释放空间,HWM不动<br>不适合用delete命令删大表.</p>
<p>课内练习<br>1 列出工资级别为3级,5级的员工<br>  select e.ename,e.salary,s.grade<br>  from emp_afei e join salgrade_afei s<br>  on e.salary between s.lowsal and s.hisal<br>  and s.grade in (3,5)<br>2 列出各个工资级别有多少人?<br>  select s.grade,count(e.empno)<br>  from emp_afei e join salgrade_afei s<br>  on e.salary between s.lowsal and s.hisal<br>  group by s.grade<br>  order by s.grade<br>3 列出各个工资级别有多少人?(包含0级)<br>  select s.grade,count(e.empno)<br>  from emp_afei e right join salgrade_afei s<br>  on e.salary between s.lowsal and s.hisal<br>  group by s.grade<br>  order by s.grade<br>特别注意count不要写*或者s.grade</p>
<p>课外练习day05<br>1按工资排名的第4到第6名员工.</p>
<p>###关键点###<br>课外练习day05答案</p>
<p>按工资排名的第4到第6名员工.<br>select rn,ename,salary<br>from<br>    (select rownum rn,ename,salary<br>     from (select ename,salary<br>           from emp_afei<br>           order by salary desc)<br>     where rownum &lt;= 6<br>    )<br>where rn &gt;= 4 </p>
<p>####1）事务####</p>
<p>####约束 constraint (安检)####<br>primary key(主键)<br>foreign key(外键)<br>unique key (唯一键)<br>not null(非空)<br>check (检查)</p>
<p>主键 (表中不会出现重复记录)<br>列级约束<br>create table test<br>(c1 number(2)<br>    constraint test_c1_pk primary key,<br> c2 number(3))</p>
<pre><code>constraint test_c1_pk primary key,
           *
</code></pre><p>ERROR at line 3:<br>ORA-02264: name already used by an existing constraint (名字被存在的约束使用了)</p>
<p>SQL&gt; select table_name from user_constraints<br>  2  where constraint_name = ‘TEST_C1_PK’;<br>哪张表里有叫TEST_C1_PK这个约束名.</p>
<p>ORA-00001: unique constraint (HILOO(用户名) .TEST_C1_PK) violated(冲突)</p>
<p>PK=UK + NN</p>
<p>表级约束<br>create table test(<br>c1 number(2),<br>c2 number,<br>constraint test_c1_pk primary key(c1)<br>)<br>表中有三列c1,c2,c3,c1和c2做成联合主键<br>create table test(<br>c1 number,<br>c2 number,<br>constraint test_c1_c2_pk primary key(c1,c2),<br>c3 number<br>)<br>没有constraint关键字,系统用自动起名字sys_c数字.</p>
<p>not null<br>create table test<br>(c1 number constraint test_c1_pk primary key,<br> c2 number not null);<br>not null约束没有表级形式</p>
<p>unique (pk)<br>相同点:都要保证唯一性<br>区别:uk允许为null,而且可以多个null值,一个表中只能有一个pk约束,可以有多个uk约束.<br>create table test<br>(c1 number constraint test_c1_pk primary key,<br> c2 number constraint test_c2_uk unique)</p>
<p>create table test(<br>c1 number primary key,<br>c2 number primary key,<br>c3 number unique,<br>c4 number unique)  (报错,一张表只能有一个primary key)</p>
<p>create table test(<br>c1 number constraint test_c1_pk primary key,<br>c2 number constraint test_c2_uk unique,<br>c3 number constraint test_c3_uk unique,<br>c4 number )<br>c2上定义了一个唯一键 c3上定义了一个唯一键</p>
<p>create table test(<br>c1 number constraint test_c1_pk primary key,<br>c2 number,<br>c3 number,<br>constraint test_c2_c3_uk unique (c2,c3),<br>c4 number)<br>c2,c3联合唯一键</p>
<p>check<br>create table test(<br>c1 number(3) constraint test_c1_ck<br>             check (c1 &gt; 100))</p>
<p>create table test(<br>c1 number(3),<br>constraint test_c1_ck check (c1 &gt; 100))</p>
<p>外键<br>parent table(父表)上定义唯一列(pk/uk)<br>child table(子表)上定义外键列(fk)</p>
<p>1 先create parent table(pk/uk),再create child table(fk)<br>2 先insert into parent table,再insert into child table<br>3 先delete from child table,再delete from parent table<br>4 先drop child table,再drop parent table</p>
<p>reference 引用<br>create table parent<br>(c1 number(3))</p>
<p>create table child<br>(c1 number(2) constraint child_c1_pk<br>              primary key,<br> c2 number(3) constraint child_c2_fk<br>              references parent(c1))</p>
<pre><code>references parent(c1))
                  *
</code></pre><p>ERROR at line 5:<br>ORA-02270: no matching unique or primary key for this column-list<br>在c1上没有定义uk或pk</p>
<p>alter table parent<br>add constraint parent_c1_pk primary key(c1);<br>给c1列增加主键约束</p>
<p>insert into child values (1,1)<br>ORA-02291: integrity constraint(完整性约束) (HILOO.CHILD_C2_FK) violated - parent key not found (父键值没发现)<br>违反fk约束</p>
<p>insert into parent values (1);<br>insert into child values (1,1)</p>
<p>delete from parent where c1 = 1;<br>ORA-02292: integrity constraint (HILOO.CHILD_C2_FK) violated - child record<br>found(子记录被发现)</p>
<p>delete from child where c2 = 1;<br>delete from parent where c1 = 1;</p>
<p>drop table parent purge;<br>ORA-02449: unique/primary keys in table referenced by foreign keys<br>在parent table上的pk/uk正在fk所引用</p>
<p>drop table child purge;<br>drop table parent purge;</p>
<p>drop table parent cascade constraints purge;<br>cascade constraints 级联约束,child table本身没被删除,只是先把子表上的fk约束删除,再删parent table.</p>
<p>表级约束<br>create table child<br>(c1 number(2) constraint child_c1_pk<br>              primary key,<br> c2 number(3),<br> constraint child_c2_fk foreign key(c2)<br>            references parent(c1)<br>)</p>
<p>外键约束另外两种定义方法<br>create table child1<br>(c1 number(2) constraint child1_c1_pk<br>              primary key,<br> c2 number(3) constraint child1_c2_fk<br>              references parent(c1)<br>              on delete cascade)<br>on delete cascade :级联删除会影响到对parent table的删除,先delete from child1,再delete from<br>parent</p>
<p>delete from parent where c1 = 1;<br>create table child2<br>(c1 number(2) constraint child2_c1_pk<br>              primary key,<br> c2 number(3) constraint child2_c2_fk<br>              references parent(c1)<br>              on delete set null)</p>
<p>delete from parent where c1 = 1<br>等价于以下操作<br>SQL&gt; update child2 set c2 = null<br>  2  where c2 = 1;<br>SQL&gt; delete from parent where c1 = 1;</p>
<p>table<br>DDL(数据类型 约束)<br>transaction (包含一堆DML)</p>
<p>4000<br>100<br>1000<br>3100</p>
<p>视图(view)<br>create table test_t1<br>as<br>select <em> from test<br>where c1 = 1;<br>create or replace view test_v1<br>as<br>select </em> from test<br>where c1 = 1;<br>desc test_v1<br>selelct * from test_v1</p>
<p>insert into test values (1,3);<br>select <em> from test_v1 (1,3)<br>insert into test_v1 values (1,4)<br>select </em> from test_v1;<br>select <em> from test;<br>insert into test_v1 values (2,3);<br>select </em> from test_v1;(没有)<br>select * from test;(2,3)</p>
<p>drop table test purge;<br>select * from test_v1;<br>SQL&gt; desc test_v1<br>ERROR:<br>ORA-24372: invalid object for describe<br>无法描述无效对象的结构</p>
<p>SQL&gt; select text from user_views<br>  2  where view_name = ‘TEST_V1’;</p>
<h2 id="TEXT"><a href="#TEXT" class="headerlink" title="TEXT"></a>TEXT</h2><p>select “C1”,”C2” from test<br>where c1 = 1</p>
<p>view是一条select语句. select语句中包含的表为源表.通过view对源表做DML操作.</p>
<p>view作用<br>1 create view (deptno = 30)<br>  grant view to user<br>  限定用户查询的数据 子集<br>2 简化查询语句<br>3 create view beijing<br>  as<br>  select <em> from haidian<br>  union all<br>  select </em> from xicheng<br>…<br>  超集<br>view的类型<br>1 简单view (DML)<br>2 复杂view  (不能DML)</p>
<p>create or replace view avgscore_v<br>select s.name,a.avgscore<br>from student s,<br>     (select sid,round(avg(score)) avgscore<br>      from stu_cour<br>      group by sid) a<br>on s.id = a.sid</p>
<p>view的约束<br>create or replace view test_ck<br>as<br>select * from test<br>where c1 = 1<br>with check option;<br>c1=2,违反where条件,2,3记录insert时报错</p>
<p>create or replace view test_ro<br>as<br>select * from test<br>where c1 = 1<br>with read only;<br>只读视图</p>
<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>create index test_c1_idx<br>on test(c1);<br>对索引不能做desc,select,DML操作<br>rowid 代表一条记录的物理位置<br>属于哪个数据对象(table)<br>属于哪个数据文件的<br>属于数据文件的第几个数据块<br>属于数据块里的第几条记录</p>
<h4 id="index的结构"><a href="#index的结构" class="headerlink" title="index的结构"></a>index的结构</h4><p>index记录rowid<br>index的结构是一棵平衡树,有三类数据块组成,根节点,分支节点,叶子节点,数据块的数据是排序的.根节点和分支节点用于导航,里面记录下一级节点的物理位置以及该节点包含的数据范围.叶子节点里记录的是index entry(索引项),由key值和rowid组成,key值是建索引的列在每条记录上的取值,rowid是记录的物理位置,所有的叶子节点做成双向链表(升序/降序),适用于范围查询.<br>用索引查询的路线图,从根节点出发,找相应的分支节点,叶子节点,最后要找到index entry,通过rowid定位<br>表里所需要的数据块,避免了全表扫描.</p>
<p>索引为什么提高查询效率,为select语句<br>有效地降低了读取数据块的数量.读取数据块,一种从文件里读,物理读 physical read,一种从内存读,逻辑读 logical read /buffer gets</p>
<p>建索引代价<br>空间,DML变慢</p>
<h4 id="哪些列适合建索引"><a href="#哪些列适合建索引" class="headerlink" title="哪些列适合建索引"></a>哪些列适合建索引</h4><p>1 经常出现在where子句的列<br>2 pk/uk列<br>3 经常出现在表连接的列<br>4 fk列 parent.pk列 = child.fk列<br>5 经常用于group by,order by的列<br>7 where c1 is null(全表扫描),索引里不记null值,<br> 该列有大量null值,找not null值用索引会快</p>
<h4 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h4><p>非唯一性索引,提高查询效率<br>唯一性索引,解决唯一性.等价建唯一性约束<br>create unique index test_c2_idx<br>on test(c2);</p>
<p>insert into test (c2) values (1)<br>*<br>ERROR at line 1:<br>ORA-00001: unique constraint(HILOO.TEST_C2_IDX ) violated</p>
<p>联合索引<br>create index test_c1_c2_idx<br>on test(c1,c2)<br>where c1 = 1 and c2 = 1</p>
<p>select ename from emp_hiloo<br>where salary<em>12 &gt; 60000<br>where salary &gt; 5000<br>如果salary建索引,where salary &gt; 5000(用),where salary</em>12 &gt; 60000(不能用)</p>
<p>where upper(ename) = ‘ZHANGWUJI’</p>
<p>where c1 = 100 c1是varchar2类型<br>where to_number(c1) = 100</p>
<p>where ename like ‘a%’<br>where substr(ename,1,1) = ‘a’</p>
<p>deptno not in (20,30)<br>depotno in (10)</p>
<h4 id="函数索引"><a href="#函数索引" class="headerlink" title="函数索引"></a>函数索引</h4><p>create index test_c1_funidx<br>on test(round(c1));<br>where round(c1) = 10</p>
<p>create index student_name_idx<br>on student(name);</p>
<h4 id="序列号"><a href="#序列号" class="headerlink" title="序列号"></a>序列号</h4><p>sequence<br>为table里的主键服务,产生主键值<br>唯一值产生器<br>sequence_name.nextval</p>
<p>为student表的id建sequence<br>insert into student(student_id.nextval…<br>为course表的id建sequence<br>insert into course (course_id.nextval…</p>
<p>创建序列如下：<br>create sequence SEQ_TEST100<br>minvalue 1<br>maxvalue 999999999999999999999999999<br>start with 11<br>increment by 1<br>cache 10;</p>
<p>函数<br>create or replace function dept_avgsal<br>(p_deptno number) –定义参数,数据类型不能有宽度<br>return number    –定义函数的返回类型<br>is<br>  v_salary emp_hiloo.salary%type;     –变量v_salary 的类型跟表emp_hiloo里的salary的类型定义一致<br>begin<br>  select round(avg(salary)) into v_salary<br>  from emp_hiloo<br>  where deptno = p_deptno;    –select当且仅当返回一条记录用select into语法,表示把select语句的执行结果赋值给v_salary<br>  return v_salary;       –返回函数值<br>end;<br>.不运行,回到SQL&gt;下<br>/表示运行<br>show error<br>SQL&gt; select dept_avgsal(10) from dual;</p>
<p>练习<br>用语法实现多对多关系<br>student<br>id pk<br>name not null</p>
<p>course<br>id pk<br>name not null</p>
<p>stu_cour<br>sid fk –&gt;student(id)<br>cid fk –&gt;course(id)<br>pk(sid,cid)<br>score check <a href="between and">0,100</a> </p>
<h4 id="数据库日期比较"><a href="#数据库日期比较" class="headerlink" title="数据库日期比较"></a>数据库日期比较</h4><p>Sql代码：<br>1    timesten内存数据库比较日期是不是同一天,低效的方法<br>2    to_char(create_date,’yyyymmdd’)=to_char(sysdate NUMTODSINTERVAL(60<em>60</em>24,’SECOND’),’yyyymmdd’)<br>3    oracle 数据库低效的方法<br>4    to_char(create_date,’yyyymmdd’)=to_char(sysdate-1,’yyyymmdd’)<br>5    2个数据库通用高效的方法<br>6    trunc(create_date)=trunc(sysdate)-NUMTODSINTERVAL(1,’DAY’)<br>查找数据库里的表，索引等<br>支持oracle的模糊查询如select * from user_tables where table_name like ‘%_PROJECT’;查表名以PROJECT结尾的表（注：区别大小写）<br>查所有用户的表在all_tables<br>主键名称、外键在all_constraints<br>索引在all_indexes<br>但主键也会成为索引，所以主键也会在all_indexes里面。<br>具体需要的字段可以DESC下这几个view，dba登陆的话可以把all换成dba。</p>
<p>查询用户表的索引(非聚集索引):<br>select * from user_indexes<br>where uniqueness = ‘NONUNIQUE’</p>
<p>查询用户表的主键(聚集索引):<br>select * from user_indexes<br>where uniqueness = ‘UNIQUE’</p>
<p>1、    查找表的所有索引（包括索引名，类型，构成列）：<br>select t.<em>,i.index_type from user_ind_columns t,user_indexes i where t.index_name = i.index_name and t.table_name = i.table_name and t.table_name = 要查询的表<br>2、查找表的主键（包括名称，构成列）：<br>select cu.</em> from user_cons_columns cu, user_constraints au where cu.constraint_name = au.constraint_name and au.constraint_type = ‘P’ and au.table_name = 要查询的表<br>3、查找表的唯一性约束（包括名称，构成列）：<br>select column_name from user_cons_columns cu, user_constraints au where cu.constraint_name = au.constraint_name and au.constraint_type = ‘U’ and au.table_name = 要查询的表<br>4、查找表的外键（包括名称，引用表的表名和对应的键名，下面是分成多步查询）：<br>select <em> from user_constraints c where c.constraint_type = ‘R’ and c.table_name = 要查询的表<br>查询外键约束的列名：<br>select </em> from user_cons_columns cl where cl.constraint_name = 外键名称<br>查询引用表的键的列名：<br>select <em> from user_cons_columns cl where cl.constraint_name = 外键引用表的键名<br>5、查询表的所有列及其属性<br>select t.</em>,c.COMMENTS from user_tab_columns t,user_col_comments c where t.table_name = c.table_name and t.column_name = c.column_name and t.table_name = 要查询的表</p>
<p>####数据唯一Id：####</p>
<ol>
<li>用Oracle来生成UUID，做法很简单，如下：select sys_guid() from dual;数据类型是 raw(16) 有32个字符。<br>create table test_guid3(<br>id varchar(50)<br>)<br>select * from test_guid3;<br>insert into test_guid3(id) values(sys_guid())</li>
</ol>
<hr>
<pre><code>1000 7CD5B7769DF75CEFE034080020825436
1100 7CD5B7769DF85CEFE034080020825436
1200 7CD5B7769DF95CEFE034080020825436
1300 7CD5B7769DFA5CEFE034080020825436
</code></pre><h3 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h3><h4 id="Oracle的方案（Schema）和用户（User）的区别"><a href="#Oracle的方案（Schema）和用户（User）的区别" class="headerlink" title="Oracle的方案（Schema）和用户（User）的区别"></a>Oracle的方案（Schema）和用户（User）的区别</h4><p>从定义中我们可以看出方案（Schema）为数据库对象的集合，为了区分各个集合，我们需要给这个集合起个名字，这些名字就是我们在企业管理器的方案下看到的许多类似用户名的节点，这些类似用户名的节点其实就是一个schema，schema里面包含了各种对象如tables, views, sequences, stored procedures, synonyms, indexes, clusters, and database links。</p>
<p>   一个用户一般对应一个schema,该用户的schema名等于用户名，并作为该用户缺省schema。这也就是我们在企业管理器的方案下看到schema名都为数据库用户名的原因。Oracle数据库中不能新创建一个schema，要想创建一个schema，只能通过创建一个用户的方法解决(Oracle中虽然有create schema语句，但是它并不是用来创建一个schema的)，在创建一个用户的同时为这个用户创建一个与用户名同名的schem并作为该用户的缺省shcema。即schema的个数同user的个数相同，而且schema名字同user名字一一对应并且相同，所有我们可以称schema为user的别名，虽然这样说并不准确，但是更容易理解一些。</p>
<p>   一个用户有一个缺省的schema，其schema名就等于用户名，当然一个用户还可以使用其他的schema。如果我们访问一个表时，没有指明该表属于哪一个schema中的，系统就会自动给我们在表上加上缺省的sheman名。比如我们在访问数据库时，访问scott用户下的emp表，通过select <em> from emp; 其实，这sql语句的完整写法为select </em> from scott.emp。在数据库中一个对象的完整名称为schema.object，而不属user.object。类似如果我们在创建对象时不指定该对象的schema，在该对象的schema为用户的缺省schema。这就像一个用户有一个缺省的表空间，但是该用户还可以使用其他的表空间，如果我们在创建对象时不指定表空间，则对象存储在缺省表空间中，要想让对象存储在其他表空间中，我们需要在创建对象时指定该对象的表空间。</p>
<p>   oracle中的schema就是指一个用户下所有对象的集合，schema本身不能理解成一个对象，oracle并没有提供创建schema的语法，schema也并不是在创建user时就创建，而是在该用户下创建第一个对象之后schema也随之产生，只要user下存在对象，schema就一定存在，user下如果不存在对象，schema也不存在；这一点类似于temp tablespace group，另外也可以通过oem来观察，如果创建一个新用户，该用户下如果没有对象则schema不存在，如果创建一个对象则和用户同名的schema也随之产生。</p>
<p>####Oracle中User与Schema的简单理解####<br>技术积累（126）<br>版权声明：本文为博主原创文章，未经博主允许不得转载。<br>方案（Schema）为数据库对象的集合，为了区分各个集合，我们需要给这个集合起个名字，这些名字就是我们在企业管理器的方案下看到的许多类似用户名的节点，这些类似用户名的节点其实就是一个schema，schema里面包含了各种对象如tables, views, sequences, stored procedures, synonyms, indexes, clusters, and database links。  一个用户一般对应一个schema,该用户的schema名等于用户名，并作为该用户缺省schema。<br>SQL Server中的Schema<br>SQL Server中一个用户有一个缺省的schema，其schema名就等于用户名，这也就是我们在企业管理器的方案下看到schema名都为数据库用户名的原因。当然一个用户还可以使用其他的schema。如果我们访问一个表时，没有指明该表属于哪一个schema中的，系统就会自动给我们在表上加上缺省的sheman名。比如我们在访问数据库时，访问scott用户下的emp表，通过select <em> from emp; 其实，这sql语句的完整写法为select </em> from scott.emp。在数据库中一个对象的完整名称为schema.object，而不属user.object。类似如果我们在创建对象时不指定该对象的schema，在该对象的schema为用户的缺省schema。这就像一个用户有一个缺省的表空间，但是该用户还可以使用其他的表空间，如果我们在创建对象时不指定表空间，则对象存储在缺省表空间中，要想让对象存储在其他表空间中，我们需要在创建对象时指定该对象的表空间。</p>
<p>Oracle中的Schema<br>Oracle中的schema就是指一个用户下所有对象的集合，schema本身不能理解成一个对象，oracle并没有提供创建schema的语法，schema也并不是在创建user时就创建，而是在该用户下创建第一个对象之后schema也随之产生，只要user下存在对象，schema就一定存在，user下如果不存在对象，schema也不存在；如果创建一个新用户，该用户下如果没有对象则schema不存在，如果创建一个对象则和用户同名的schema也随之产生。实际上在使用上，shcema与user完全一样，没有什么区别，在出现schema名的地方也可以出现user名。</p>
<p>Tablspace<br>逻辑上用来放objects,，这是个逻辑概念，本质上是一个或者多个数据文件的集合，物理上对应磁盘上的数据文件或者裸设备。</p>
<p>数据文件<br>具体存储数据的物理文件，是一个物理概念。一个数据文件只能属于一个表空间，一个表空间可以包含一个或多个数据文件。一个数据库由多个表空间组成，一个表空间只能属于一个数据库。</p>
<p>下边是源自网络的一个形象的比喻<br>我们可以把Database看作是一个大仓库，仓库分了很多很多的房间，Schema就是其中的房间，一个Schema代表一个房间，Table可以看作是每个Schema中的床，Table（床）被放入每个房间中，不能放置在房间之外，那岂不是晚上睡觉无家可归了，然后床上可以放置很多物品，就好比 Table上可以放置很多列和行一样，数据库中存储数据的基本单元是Table，现实中每个仓库放置物品的基本单位就是床， User就是每个Schema的主人，（所以Schema包含的是Object，而不是User），user和schema是一一对应的，每个user在没有特别指定下只能使用自己schema（房间）的东西，如果一个user想使用其他schema（房间）的东西，那就要看那个schema（房间）的user（主人）有没有给你这个权限了，或者看这个仓库的老大（DBA）有没有给你这个权限了。换句话说，如果你是某个仓库的主人，那么这个仓库的使用权和仓库中的所有东西都是你的（包括房间），你有完全的操作权，可以扔掉不用的东西从每个房间，也可以放置一些有用的东西到某一个房间，你还可以给每个User分配具体的权限，也就是他到某一个房间能做些什么，是只能看（Read-Only），还是可以像主人一样有所有的控制权（R/W），这个就要看这个User所对应的角色Role了。</p>
<h4 id="oracle的schema的含义"><a href="#oracle的schema的含义" class="headerlink" title="oracle的schema的含义"></a>oracle的schema的含义</h4><p>在现在做的Kraft Catalyst 项目中，Cransoft其中有一个功能就是schema refresh. 一直不理解schema什么意思，也曾经和同事讨论过，当时同事就给我举过一个例子，下面会详细说的。其实schema是Oracle中的，其他数据库中不知道有没有这个概念。<br>首先,可以先看一下schema和user的定义：<br>A schema is a collection of database objects (used by a user).<br>Schema objects are the logical structures that directly refer to the database’s data.<br>A user is a name defined in the database that can connect to and access objects.<br>Schemas and users help database administrators manage database security.<br>从中我们可以看出,schema为数据库对象的集合，为了区分各个集合，需要给这个集合起个名字，这些名字就是在企业管理器的方案下看到的许多类似用户名的节点，这些类似用户名的节点其实就是一个schema。<br>schema里面包含了各种对象如tables, views, sequences, stored procedures, synonyms, indexes, clusters, and database links。<br>一个用户一般对应一个schema，该用户的schema名等于用户名，并作为该用户缺省schema。这也就是在企业管理器的方案下看到schema名都为数据库用户名的原因。<br>Oracle数据库中不能新创建一个schema，要想创建一个schema，只能通过创建一个用户的方法解决(Oracle中虽然有create schema语句，但是它并不是用来创建一个schema的)。在创建一个用户的同时，为这个用户创建一个与用户名同名的schem并作为该用户的缺省 shcema。即schema的个数同user的个数相同，而且schema名字同user名字一一 对应并且相同，所有我们可以称schema为user的别名，虽然这样说并不准确，但是更容易理解一些。<br>一个用户有一个缺省的schema，其schema名就等于用户名，当然一个用户还可以使用其他的schema。如果我们访问一个表时，没有指明该表属于 哪一个schema中的，系统就会自动给我们在表上加上缺省的sheman名。比如我们在访问数据库时，访问scott用户下的emp表，通过 select <em> from emp; 其实，这sql语句的完整写法为select </em> from scott.emp。在数据库中一个对象的完整名称为schema.object，而不属user.object。类似如果我们在创建对象时不指定该对象 的schema，在该对象的schema为用户的缺省schema。这就像一个用户有一个缺省的表空间，但是该用户还可以使用其他的表空间，如果我们在创 建对象时不指定表空间，则对象存储在缺省表空间中，要想让对象存储在其他表空间中，需要在创建对象时指定该对象的表空间。<br>有人举了个很生动的例子，来说明Database、User、Schema、Tables、Col、Row等之间的关系<br>“可以把Database看作是一个大仓库，仓库分了很多很多的房间，Schema就是其中的房间，一个Schema代表一个房间，Table可以看作是每个Schema中的床，Table（床）就被放入每个房间中，不能放置在房间之外，那岂不是晚上睡觉无家可归了。<br>然后床上可以放置很多物品，就好比Table上可以放置很多列和行一样，数据库中存储数据的基本单元是Table，现实中每个仓库放置物品的基本单位就是床， User就是每个Schema的主人（所以Schema包含的是Object，而不是User）。<br>其实User是对应与数据库的（即User是每个对应数据库的主人），既然有操作数据库（仓库）的权利，就肯定有操作数据库中每个Schema（房间）的 权利，就是说每个数据库映射的User有每个Schema（房间）的钥匙，换句话说，如果他是某个仓库的主人，那么这个仓库的使用权和仓库中的所有东西都 是他的（包括房间），他有完全的操作权，可以扔掉不用的东西从每个房间，也可以放置一些有用的东西到某一个房间。还可以给User分配具体的权限，也就是 他到某一个房间能做些什么，是只能看（Read-Only），还是可以像主人一样有所有的控制权（R/W），这个就要看这个User所对应的角色Role 了”<br>从定义中我们可以看出schema为数据库对象的集合，为了区分各个集合，我们需要给这个集合起个名字，这些名字就是我们在企业管理器的方案下看到的许多类似用户名的节点，这些类似用户名的节点其实就是一个schema，schema里面包含了各种对象如tables, views, sequences, stored procedures, synonyms, indexes, clusters, and database links。<br>一个用户一般对应一个schema,该用户的schema名等于用户名，并作为该用户缺省schema。这也就是我们在企业管理器的方案下看到schema名都为数据库用户名的原因。Oracle数据库中不能新创建一个schema，要想创建一个schema，只能通过创建一个用户的方法解决(Oracle中虽然有create schema语句，但是它并不是用来创建一个schema的)，在创建一个用户的同时为这个用户创建一个与用户名同名的schem并作为该用户的缺省shcema。即schema的个数同user的个数相同，而且schema名字同user名字一一 对应并且相同，所有我们可以称schema为user的别名，虽然这样说并不准确，但是更容易理解一些。<br>一个用户有一个缺省的schema，其schema名就等于用户名，当然一个用户还可以使用其他的schema。如果我们访问一个表时，没有指明该表属于哪一个schema中的，系统就会自动给我们在表上加上缺省的sheman名。比如我们在访问数据库时，访问scott用户下的emp表，通过select <em> from emp; 其实，这sql语句的完整写法为select </em> from scott.emp。在数据库中一个对象的完整名称为schema.object，而不属user.object。类似如果我们在创建对象时不指定该对象的schema，在该对象的schema为用户的缺省schema。这就像一个用户有一个缺省的表空间，但是该用户还可以使用其他的表空间，如果我们在创建对象时不指定表空间，则对象存储在缺省表空间中，要想让对象存储在其他表空间中，我们需要在创建对象时指定该对象的表空间。<br>咳，说了这么多，给大家举个例子，否则，一切枯燥无味！<br>SQL&gt; Gruant dba to scott<br>SQL&gt; create table test(name char(10));<br>Table created.<br>SQL&gt; create table system.test(name char(10));<br>Table created.<br>SQL&gt; insert into test values(‘scott’);<br>1 row created.<br>SQL&gt; insert into system.test values(‘system’);<br>1 row created.<br>SQL&gt; commit;<br>Commit complete.<br>SQL&gt; conn system/manager<br>Connected.<br>SQL&gt; select * from test;</p>
<h2 id="NAME"><a href="#NAME" class="headerlink" title="NAME"></a>NAME</h2><p>system<br>SQL&gt; ALTER SESSION SET CURRENT_SCHEMA = scott; –改变用户缺省schema名<br>Session altered.<br>SQL&gt; select * from test;</p>
<h2 id="NAME-1"><a href="#NAME-1" class="headerlink" title="NAME"></a>NAME</h2><p>scott<br>SQL&gt; select owner ,table_name from dba_tables where table_name=upper(‘test’);<br>OWNER TABLE_NAME</p>
<hr>
<p>SCOTT TEST<br>SYSTEM TEST<br>–上面这个查询就是我说将schema作为user的别名的依据。实际上在使用上，shcema与user完全一样，没有什么区别，在出现schema名的地方也可以出现user名。<br>表空间：<br>一个表空间就是一片磁盘区域,他又一个或者多个磁盘文件组成,一个表空间可以容纳许多表、索引或者簇等<br>  每个表空间又一个预制的打一磁盘区域称为初始区间（initial   extent）用完这个区间厚在用下一个，知道用完表空间，这时候需要对表空间进行扩展，增加数据文件或者扩大已经存在的数据文件</p>
<p>instance是一大坨内存sga,pga….和后台的进程smon pmon…..组成的一个大的应用。<br>schema就是一个用户和他下面的所有对象。。<br>tablspace 逻辑上用来放objects.物理上对应磁盘上的数据文件或者裸设备。<br> 在Oracle中，结合逻辑存储与物理存储的概念，我们可以这样来理解数据库、表空间、SCHEMA、数据文件这些概念：<br>      数据库是一个大圈，里面圈着的是表空间，表空间里面是数据文件，那么schema是什么呢？schema是一个逻辑概念，是一个集合，但schema并不是一个对象，oracle也并没有提供创建schema的语法。<br>schema：<br>      一般而言，一个用户就对应一个schema,该用户的schema名等于用户名，并作为该用户缺省schema，用户是不能创建schema的，schema在创建用户的时候创建，并可以指定用户的各种表空间（这点与PostgreSQL是不同，PostgreSQL是可以创建schema并指派给某个用户）。当前连接到数据库上的用户创建的所有数据库对象默认都属于这个schema（即在不指明schema的情况下），比如若用户scott连接到数据库，然后create table test(id int not null)创建表，那么这个表被创建在了scott这个schema中；但若这样create kanon.table test(id int not null)的话，这个表被创建在了kanon这个schema中，当然前提是权限允许。<br>      创建用户的方法是这样的：<br>      create user 用户名 identified by 密码<br>      default tablespace 表空间名<br>      temporary tablespace 表空间名<br>      quota 限额  （建议创建的时候指明表空间名）<br>由此来看，schema是一个逻辑概念。<br>      但一定要注意一点：schema好像并不是在创建user时就创建的，而是在该用户创建了第一个对象之后才将schema真正创建的，只有user下存在对象，他对应的schema才会存在，如果user下不存在任何对象了，schema也就不存在了；</p>
<p>数据库：<br>     在oracle中，数据库是由表空间来组成的，而表空间里面是具体的物理文件—数据文件。我们可以创建数据库并为其指定各种表空间。</p>
<p>表空间：<br>     这是个逻辑概念，本质上是一个或者多个数据文件的集合。</p>
<p>数据文件：<br>     具体存储数据的物理文件，是一个物理概念。<br>     一个数据文件只能属于一个表空间，一个表空间可以包含一个或多个数据文件。一个数据库由多个表空间组成，一个表空间只能属于一个数据库。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="dongpo.jia" />
            
              <p class="site-author-name" itemprop="name">dongpo.jia</p>
              <p class="site-description motion-element" itemprop="description">个人博客</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">47</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">42</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">39</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dongpo.jia</span>

  

  
</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.2.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.2.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.2.0"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
