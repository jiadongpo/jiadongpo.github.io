<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.2.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=6.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=6.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.2.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="中起之星">
<meta property="og:url" content="http://cenrise.com/page/4/index.html">
<meta property="og:site_name" content="中起之星">
<meta property="og:description" content="个人博客">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="中起之星">
<meta name="twitter:description" content="个人博客">






  <link rel="canonical" href="http://cenrise.com/page/4/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>中起之星</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">中起之星</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">Cenrise</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cenrise.com/2017/04/16/hadoop/数据分析软件分类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongpo.jia">
      <meta itemprop="description" content="个人博客">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="中起之星">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/16/hadoop/数据分析软件分类/" itemprop="url">
                  数据分析软件分类
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-04-16 23:43:49" itemprop="dateCreated datePublished" datetime="2017-04-16T23:43:49+08:00">2017-04-16</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-08-18 09:44:35" itemprop="dateModified" datetime="2017-08-18T09:44:35+08:00">2017-08-18</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/大数据/" itemprop="url" rel="index"><span itemprop="name">大数据</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/大数据/数据分析/" itemprop="url" rel="index"><span itemprop="name">数据分析</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#数据分析软件分类<br>下面介绍一些适合大数据分析的存储数据库，或者面向大数据分析，适用于TB级以上的数据库存储和分析任务。分为如下几类介绍：<br>1.商业数据库<br>2.开源时序数据库<br>3.开源计算框架<br>4.开源SQL on hadoop<br>5.云端数据分析SaaS  </p>
<p>##商业软件<br>商业数据库软件种类繁多，但是真正能支持TB级别以上的数据存储和分析并不多，下面介绍几个有特点、支持大数据的商用数据库。  </p>
<p>###HP Vertica<br>Vertica公司成立于2005年，创立者为数据库巨擘Michael Stonebraker。2011成Vertica被惠普收购。Vertica是能够提供高效数据存储和快速查询数据存储数据库实时分析平台，还支持大规模并行 处理（MPP）。产品广泛应用于高端数据营销、互联网客户分析处理，数据达到PB级别。<br>Vertical特点如下：<br>面向列的存储<br>灵活的压缩算法，根据数据的排序性和基数决定压缩算法。<br>高可用数据库和查询<br>MPP架构，分布式存储和任务负载，Shared nothing架构。<br>支持标准SQL查询、ODBC/JDBC等..<br>支持Projection（数据投射）功能。</p>
<p>###Oracle Exadata<br>Oracle Exadata是数据库发展史上一个人传奇，它是数据库软件和最新硬件的完美结合。它提供最快、最可靠的数据库平台，不仅支持常规的数据库应用，也支持联机分析处理（OLAP）和数据仓库（DW）的场景。<br>Oracle Exadata采用了多种最新的硬件技术，例如40GB的InfiniBan网络</p>
<p>###Teradata<br>Teradata（天睿）公司是专注于大数据分析、数据仓库和整合营销管理解决方案的供应商。Teradata采用纯粹的Shared noting架构，支持MPP。对于多维度的查询更加灵活，专注于数据仓库的应用领域。  </p>
<p>##时序数据库<br>时序数据库用于记录过去时间的各个数据点的信息，典型的应用是服务器的各种性能指标，例如CPU、内存使用情况等 。目前时序数据库也广泛应用于各种传感器的数据收集分析工作中，这些数据的收集都有一个特点，就是对时间的依赖非常大，每天产生的数据量非常大，因此定入的量非常大，一般的关系型数据库无法满足这些场景。因此，时序数据库在设计上需要支持高吞吐、高效数据压缩，支持历史查询、分布式部署等。</p>
<p>###1.OpenTSDB<br>OpenTSDB是一个开源的时序数据库，支持存储千亿的数据点，并提供精确查询功能。它采用Java语言编写，通过基于HBaser存储实现横向扩展。</p>
<p>###2.InfluxDB<br>InfluxDB采用GoLang语言开发，也是一个开源应用，社区非常活跃。其技术特点包含：支持任意数量的列，支持方便、强大的查询语言，集成了数据采集、存储和可视化功能。</p>
<p>##开源分布式计算平台<br>一个是Hadoop，另一个是Spark，这里就不一一介绍了。</p>
<p>##开源分析数据库</p>
<p>###Kylin<br>Kylin是Apache开源的开源分布式分析引擎。<br>与Kylin一样致力于大数据查询问题的开源产品如Apache Drill、Apache Impala、Druid、Hive、Presto（Facebook）、SparkSQL等。<br>从底层技术角度来看，这些开源产品有很大的共性，一些底层技术几乎被所有的产品一致采用。<br>1）大规模并行处理：可以通过增加机器的方式来扩容处理速度，在相同的时间里处理更多的数据。<br>2）列式存储：通过按列存储提高单位时间里数据的I/O吞吐率，还能跳过不需要访问的列。<br>3）索引：利用索引配合查询条件，可以迅速跳过不符合条件的数据块，仅扫描需要扫描的数据内容。<br>4）压缩：压缩数据然后存储，使得存储的密度更高，在有限的I/O速率下，在单位时间里读取更多的记录。<br>综上所述，我们可以注意到，所有这些方法都只是提高了单位时间内处理数据的能力，当大家都一致采用这些技术时，它们之间的区别将只停留在实现层面的代码细节上。最重要的是，这些技术都不会改变一个事实，那就是处理时间与数据量之间的正比例关系。当数据量翻倍时，MPP（在不扩容的前提下）需要翻倍的时间来完成计算；列式存储需要翻倍的存储空间；索引下符合条件的记录数据数也会翻倍；压缩事的数据大小也还是之间的两倍。因此查询速度也会随之就之前的两倍。当数据量成十倍地增长时，这些技术的查询速度就会成十倍地下降，最终变得不能接受。<br>Apache Kylin的特色在于，在上述的底层技术之外，另辟蹊径地使用了独特的Cube预计算技术。预计算将数据按维度组合进行了聚合，将结果保存为物化视图。经过聚合，物化视图的规模就只由维度的基数来决定，而不再随着数据量的增长呈线性增长。以电商为例，如果业务扩张，交易量增长了10倍，只要交易数据的维度不变（供应商/商品数量不变），聚合后的物化视图初依旧是原先的大小，查询的速度也将保持不变。<br>与那些类似产品相比，这一导技术的区别使得Kylin从外在功能上呈现出了不同的特性，具体如下：<br>1）SQL接口：除了Druid以外，所有的产品都支持SQL或类SQL接口。巧合的是Druid也是除了Kylin以外，查询性能相对更好的一个。这点除了Druid有自己的存储引擎之外，可能还利益于其较为受限的查询能力。　　<br>2）大数据支持：大数据产品的能力在亿级到十亿级数据量之间，再大的数据量将显著降低查询性能。而Kylin因为采用预计算技术，因此查询速度不受数据量的限制。<br>3）查询速度，不会随着数据量的增加而查询性能下降。<br>4）吞吐量：根据之前的实验数据，Kylin的单例吞吐量一般在每秒70个查询左右，并且可以线性扩展，而普通的产品因为所有计算都在查询时完成，所以需要调动集群的更多资源才能完成查询，通常极限在每秒20个查询左右，而且扩容成本较高，需要扩展整个集群。相对的，Kylin系统因为瓶颈不在整个集群，而在于Kylin服务器，因此只需要增加Kylin服务器就能成倍提高吞率，扩容成本低廉。</p>
<p>###Druid<br>Druid是什么？<br>Druid是一个分布式的支持实时分析的数据存储系统（Data Store）,是美国广告技术公司MetaMarkets于2011年创建，2012年开源的项目，Druid设计之初是为分析而生。官方网站是：<a href="http://druid.io" target="_blank" rel="noopener">http://druid.io</a></p>
<p>###Pinot<br>Pinot是Linkin于2015年开源的一个分布式列式数据存储系统。</p>
<p>###神秘的谷歌Dremel<br>Dremel是谷歌的“交互式”数据分析系统，支持上千台机器的集群部署，处理PB级别的数据，可以对网状数据的只读数据进行随机查询访问，帮助数据分析分提供Ad Hoc查询功能，进行尝试的数据探索（Exploration）。</p>
<p>###Apache Drill<br>Apache Drill通过开源方式实现了谷歌Dremel。Drill架构的整个思想还是通过优化查询引擎，进行快速全表扫描，以快速返回结果，其高层架构示意图如下：</p>
<p>Apache Drill基于SQL的数据分析和商业智能引入了JSON文件模型，这使得用户能查询固定架构，支持各种格式和数据存储中的模式无关数据。该体系架构中的关系查询引擎和数据库构建是有先决条件的，即假设所有数据都有一个简单的静态架构。</p>
<p>Apache Drill的架构是独一无二的，它是唯一一个支持复杂和无模式数据的柱状行引擎，也是唯一一个能在查询执行期间进行的数据驱动查询。</p>
<p>###Elasticsearch<br>Elasticsearch（ES）是Elastic公司推出一个基于Lucerne的分布式</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cenrise.com/2017/04/16/hadoop/Kylin入门概念/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongpo.jia">
      <meta itemprop="description" content="个人博客">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="中起之星">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/16/hadoop/Kylin入门概念/" itemprop="url">
                  Kylin入门概念
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-04-16 23:43:49" itemprop="dateCreated datePublished" datetime="2017-04-16T23:43:49+08:00">2017-04-16</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-08-18 09:44:35" itemprop="dateModified" datetime="2017-08-18T09:44:35+08:00">2017-08-18</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/大数据/" itemprop="url" rel="index"><span itemprop="name">大数据</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/大数据/kylin/" itemprop="url" rel="index"><span itemprop="name">kylin</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#Apache Kylin的工作原理<br>Apache Kylin的工作原理本质上是MOLAP（Multidimensional　Online　Analytical　Processing）Cube，也就是多维　立方体分析。这是数据分析中相当经典的理论，在关系数据库年代就已经有了广泛的应用，下面将其做简要的介绍。  </p>
<p>##维度和度量<br>简单来讲，维度就是观察数据的角度。比如电商的销售数据，可以从时间的维度来观察，也可以进一步细化，从时间和地区的维度来观察。维度一般是一组离散的值，比如时间维度上的每一个独立的日期，或者商品维度上的每一件独立的商品。因此统计时可以把维度值 相同的记录聚合在一起，然后应用聚合函数做累加、平均、去重计数等聚合计算。  <img src="/images/hadoop/kylin/维度和度量的例子.jpg" alt="&quot;维度和度量的例子&quot;"></p>
<p>度量就是被聚合的统计值，也是聚合运算的结果，它一般是连续的值，如图1-2中的销售额，抑或是销售商品的总件数据 。通过比较和测量试题，分析师可以对数据进行评估，比如今年的销售额相比去年有多大的增长，增长的速度是否达到预期，不同商品类别的增长比例是否合理等。  </p>
<p>##Cube和Cuboid<br>有了维度和度量，一个数据表或数据模型上的所有字段就可以分类了，它们要么是维度，要么是度量（可以被聚合）。于是就有了根据维度和度量来做预计算的Cube理论。<br>给定一个数据模型，我们可以对其上的所有维度进行组合。对于N个维度来说，组合的所有可能共2的n次方种。对于每一种维度的组合，将度量做聚合运算，然后将运算的结果保存为一个物化视图，称为Cuboid。所有维度组合的Coboid作为一个整体，被称为Cube。所以简单来说一个Cube就是许多按维度聚合的物化视图的集合。<br>下面来举一个具体的例子。假定有一个电商的销售数据集，其中维度包括时间（Time）、商品（Item）、地点（Location）和供应商（Supplier），度量为销售额（GMV）。那么所有维度的组合就有2的4次方=16种，比如一维度（ID）的组合有[Time]、[Item]、[Location]、[Supplier]4种；二维度（3D）的组合有[Time,Item]、[Time，Location]、[Time,Supplier]、[Item,Location]、[Item,Supplier]、[Location,Supplier]6种；三维度（3D）的组合也有4种；最后零维度（0D）和四维度（4D）的组合各有1种，总共有16种组合。<br><img src="/images/hadoop/kylin/一个四维Cube的例子.jpg" alt="&quot;一个四维Cube的例子&quot;"></p>
<p>计算Cuboid，即按维度来聚合销售额。如果用SQL语句来表达计算Cuboid[Time,Location]，那么SQL语句如下：<br>Select Time,Location,Sum(GMV) as GMV from Sales group by Time,Location.<br>将计算的结果保存为物化视图，所有Cuboid物化视图的总称是Cube。</p>
<p>##工作原理<br>Apache Kylin的工作原理就是对数据模型做Cube预计算，并利用计算的结果加速查询，具体工作过程如下：<br>1）指定数据模型，定义维度和度量<br>2）预计算Cube，计算所有Cuboid并保存为物化视图。<br>3）执行查询时，读取Cuboid，运算，产生查询结果。<br>由于Kylin的查询过程不会扫描原始记录，而是通过预计算预先完成表的关联、聚合等复杂运算，并利用预计算的结果来执行查询，因此相比非预计算的查询技术，其速度一般要快一到两个数据级，并且这点在超磊的数据集上优势更加明显。当数据集达到千亿及至万亿级别时，Kylin的速度甚至可以超越其他非预计算技术1000倍以上。</p>
<p>#技术架构<br>Apache Kylin系统可以分为在线查询和离线构建两部分，技术架构如下图所示，在线查询的模块主要处于上半区，而离线构建则处于下半区。<br><img src="/images/hadoop/kylin/Kylin的技术架构.jpg" alt="&quot;Kylin的技术架构&quot;">    </p>
<p>我们首先看看离线构建的部分。从图1-4可以看出，数据源在左侧，目前主要是Hadoop Hive，保存着待分析的用户数据。根据元数据的字义，下方构建引擎从数据源抽取数据，并构建Cube。数据以关系表的形式输入，且必须符合星形模型（Star Schema）（更复杂的雪花模型在成文时还不支持，可以通过视图将雪花模型转化为星形模型，再使用Kylin）。MapRecue是当前主要的构建技术。构建后的Cube保存在右侧的存储引擎中，一般选用HBase作为存储。<br>完成了离线构建之后，用户可以从上方查询系统发送SQL进行查询分析。Kylin提供了各种Rest　API、ＪＤＢＣ／ＯＤＢＣ接口。无论从哪个接口进入，SQL最终都会来到Rest服务层，再转交给查询引擎进行处理。这里需要注意的是，SQL语句是基于数据源的关系模型书写的，而不是Cube。Kylin在设计时刻意对查询用户屏蔽了Cube的概念，分析师只需要理解简单的关系模型就可以使用Kylin，没有额外的学习门槛，传统的SQL应用也很容易迁移。查询引擎解析SQL，生成基于关系表的逻辑执行计划，然后将其转义为基于Cube的物理执行计划，最后查询预计算生成的Cube并产生结果。整个过程不会访问原始数据源。  </p>
<p><strong>注意</strong>：对于查询引擎下方的路由选择，在最初设计时曾考虑过将Kylin不能执行查询引导去Hive中继续执行，但在实践后发现Hive与Kylin的速度差异过大，导致用户无法对查询的速度有一致的期望，很可能大多数据查询几秒内就返回结果了，而有些查询则要等几分钟到几十分钟，因此体验非常糟糕。最后这个路由功能在发行版中默认关闭。</p>
<p>Apache Kylin 1.5版本引入了“可扩展架构”的概念。在图1-4中显示为三个粗虚框，表示的抽象层。可扩展指Kylin可以对其主要依赖的三个模块做任意的扩展和替换。Kylin的三大依赖模型分别是数据源、构建引擎和存储引擎。在设计之初，作为Hadoop家族 一员，这三者分别是Hive、MapRecue和HBase。但随着推广和使用的深入，渐渐有用户发现它们均存在不足之处。比如，实时分析可能会希望从Kafka导入数据而不是Hive；而Spark的迅速崛起，又使我们不得不考虑将MapRecue替换为Spark，以期大幅提高Cube的构建速度；至于HBase，它的读性能可能还不如Cassandra或Kudu等 。可见，是否可以将一种技术替换为另一种技术已成为一个常见的问题。于在1.5版本的系统架构进行了重构，将数据源、构建引擎、存储引擎三大依赖抽象为接口，而Hive、MapRecue、HBase只是默认实现。深度用户可以根据自己的需要做二次开发，将其中的一个或多个替换为更适合的技术。  </p>
<p>#核心概念</p>
<p>##数据仓库<br>数据仓库（Data Warehouse）是一种系统的资料储存理论，此理论强调的是利用某些特殊的资料储存方式，让所包含的资料特别有利于分析和处理，从而产生有价值的资讯，并可依此做出决策。<br>利用数据仓库的方式存放资料，具有一旦存入，便不会随时间发生变动的特性，此外，存入的资料必定包含时间属性，通常一个数据仓库中会含有大量的历史性资料，并且它可利用特定的分析方式，从其中发掘特定的资讯。</p>
<p>##OLAP<br>OLAP（Online Analytical Process），联机分析处理，以多维度的方式分析数据，而且能够弹性地提供上卷（Roll-up）、下钻（Drill-down）和透视分析（Pivot）等操作，它呈现集成性决策信息的方法，多用于决策支持系统、商务智能或数据仓库。其主要的功能在于方便大规模数据分析及统计计算，可对决策提供参考和支持。与之相区别的是取机交易处理（OLTP），联机交易处理，更侧重于基本的、日常的事务处理，包括数据的增删改查。<br>OLAP需要以大量历史数据为基础，再配合时间点的差异，对多维度及汇整型的信息进行复杂的分析。<br>OLAP需要用户有主观的信息需求定义，因此系统效率较佳。<br>OLAP的概念，在实际应用中存在广义和狭义两种不同的理解方式。广义上的理解与字面上的意义相同，泛指一切不会对数据进行更新的分析处理。但更多的情况下OLAP被理解为其狭义上的含义，即与多维分析相关，基于立方体（Cube）计算而进行的分析。</p>
<p>##BI<br>BI（Business Intelligence），即商务智能，指现代数据仓库技术、在线分析技术、数据挖掘和数据展现技术进行数据分析以实现商业价值。</p>
<p>##维度和度量<br>维度和度量是数据分析中的两个基本的概念<br><strong>维度</strong>是指审视数据的角度，它通常是数据记录的一个属性，例如时间、地点等。<br><strong>度量</strong>是基于数据所计算出来的考量值；它通常是一个数值，如总销售额、不同的用户数等。分析人员往往要结合若干个维度来审查度量值，以便在其中找到变化规律。在一个SQL查询中，Group By的属性通常就是维度，而所计算的值则是度量。如下面的示例：<br>    select part_dt,lstg_iste_id,sum(price) as total_selled,count(distinct seller_id) as sellers from kylin_sales group by part_dt,lstg_site_id</p>
<p>##事实表和维度表<br><strong>事实表</strong>（Fact Table）是指存储有事实记录的表，如系统日志、销售记录等；事实表的记录在不断地动态增长，所以它的体积通常远大于其他表。</p>
<p><strong>维度表</strong>（Dimension Table）或维表，有时也称查找表（Lookup Table），是与事实表相对应的一种表；它保存了维度的属性值，可以跟事实表做关联；相当于将事实表上经常重复出现的属性抽取、规范出来用一张表进行管理。常见的维度表有：日期表（存储与日期对应的周、月、季度等属性）、地点表（包含国家、省、城市等属性）。使用维度表有诸多好处，具体如下：<br>a.缩小了事实表的大小<br>b.便于维度的管理和维护，增加、删除和修改维度的属性，不必对事实表的大量记录进行改动。<br>c.维度表可以为多个事实表重用，以减少重复工作。</p>
<p>##Cube、Cuboid和Cube Segment</p>
<p>###Cube<br>Cube（或Data Cube），即数据立方体，是一种常用于数据分析与索引的技术；它可以对原始数据建立多维度索引。通过Cube对数据进行分析，可以大大加快数据的查询效率。</p>
<p>###Cuboid<br>Cuboid在Kylin中特指在某一种维度组合下所计算的数据。</p>
<p>##Cube Segment<br>Cube Segment是指针对源数据中的某一片段，计算出来的Cube数据。通常数据仓库中的数据数量会随着时间的增长而增长，而Cube Segment也是按时间顺序来构建的。</p>
<p>#在Hive中准备数据<br>这里介绍准备Hive数据的一些注意事项。需要被分析的数据必须先保存为Hive表的形式，然后Kylin才能从Hive中导入数据，创建Cube。<br>Hive是一个基于Hadoop的数据仓库工具，可以将结构化的数据文件映射为数据库表，并可以将SQL语句转换为MapRecue或Tez任务进行运行，从而让用户以类SQL（HiveQL，也称HQL）的方式管理和查询Hadoop上的海量数据。<br>此外，Hive还提供了多种方式（如命令行、API和Web服务等）可供第三方方便地获取和使用元数据并进行查询。今天，Hive已经成为Hadoop数据仓库的首选，是Hadoop上不可或缺的一个重要组件，很多项目都已兼容或集成了Hive。基于此情况，Kylin选择Hive作为原始数据的主要来源。<br>在Hive中准备待分析的数据是使用Kylin的前提；将数据导入到Hive表中的方法有很多，用户管理数据的技术和工具也各式各样，因此具体步骤不在本书的讨论范围之内。</p>
<p>##星形模型<br>数据挖掘有几种常见的多维数据模型，如星形模型（Star Schema）、雪花模型（Snowf lake Schema）、事实星座模型（Fact Constellation）等。<br>星形模型中有一张事实表，以及零个或多个维度表；事实表与维度表通过主键外键相关联，维度表之间没有关联，就像很多星星围绕在一个恒星周围，帮取名为星形模型。<br>如果将星形模型中某些维度的表再做规范，抽取成更细的维度表，然后让维度表之间也进行关联，那么这种模型称为雪花模型。<br>星形模型是更复杂的模型，其中包含了多个事实表，而维度表是公用的，可以共享。<br>不过，Kylin只支持星形模型的数据集，这是基于以下考虑的。  </p>
<ul>
<li>星形模型是最简单，也是最常用的模型  </li>
<li>由于星形模型只有一张大表，因此它相比于其它模型更适合于大数据处理  </li>
<li>其他模型可以通过一定的转换，变成星形模型。  </li>
</ul>
<p>##维度表的设计<br>除了数据模型以外，Kylin还对维度表有一定的要求，具体要求如下。  </p>
<ul>
<li>要具有数据一致性，主键值必须是唯一的；Kylin会进行检查，如果有两行的主键值相同则会报错。</li>
<li>维度越小越好，因为Kylin会将维度表加载到内存中供查询；过大的表不适合作为维度表，默认的阈值是300MB。  </li>
<li>改变频率低，Kylin会在每次构建中试图重用维度表的快照，如果维度表经常改变的话，重用就会失效，这就会导致要经常对维度表创建快照。</li>
<li>维度表最好不要是Hive视图（View），虽然在Kylin1.5.3中加入了对维度表是视图这种情况的支持，但每次都需要将视图进行物化，从而导致额外的时间开销。</li>
</ul>
<p>##Hive表分区<br>Hive支持多分区（Partition）。简单来说，一个分区就是一个文件目录，存储了特定的数据文件。当有新的数据生成的时候，可以将数据加载到指定的分区，读取数据的时候也可以指定分区。对于 SQL查询，如果查询中指定了分区列的属性条件，则Hive会智能地选择特定分区（也就是目录），从而避免全量数据的扫描，减少读写操作对集群的压力。<br>下面举的一组SQL演示了如何使用分区：  </p>
<p>Hie&gt;create table invites(id int,name string) partitioned by(ds string) row format delimited fields terminated by ‘t’ stroed as textfile;<br>Hive&gt;load data local inpath ‘/user/hadoop/data.txt’ overwrite into table invites partition (ds=’2016-08-16’);<br>Hive&gt;select * from invites where ds = ‘2016-08-16’;<br>Kylin支持增量的Cube构建，通常是按时间属性来增量地从Hive表中抽取数据。如果Hive表正好是按此时间属性做分区的话，那么就可以利用到Hive分区的好处，每次在Hive构建的时候都可以直接跳过不相干的日期的数据，节省Cube构建的时间。这样的列在Kylin里也称为分割时间列（Partition Time Column），通常它应该也是Hive表的分区列。</p>
<p>##了解维度的基数<br>维度的基数（Cardinality）指的是该维度在数据集中出现的不同值的个数；例如“国家”是一个维度，如果有200个不同的值，那么此维度的基数就是200.通常一个维度的基数会从几十到几万个不等，个别维度如“用户ID”的基数会超过百万甚至千万。基数超过一百万的维度通常称为超高维度（Ulta Hight Cardinality，UHC），需要引起设计者的注意。<br>Cube中所有维度的基数都可以体现Cube的复杂度，如果一个Cube中有好几个超高基数维度，那么这个Cube膨胀就会很高。在创建Cube前需要对所有维度的基数做一个了解，这样就可以帮助设计合理的Cube。计算基数有多种途径，最简单的方法就是让Hive执行一个count distinct的SQL查询；Kylin也提供计算基数的方法，在导入Hive表定义后可以看到每一个列的基数，参数名为Cardinality</p>
<p>##Sample Data<br>如果需要快速体验Kylin，可以用Kylin自带的Sample Data。运行${KYLIN_HOME}/bin/sample.sh来导入Sample Data，然后就能按照下面的流程来创建模型和Cube。<br>具体请执行下面命令，将Sample Data导入到Hive数据库。<br>cd ${KYLIN_HOME}<br>bin/sample.sh<br>Sample Data测试的样例数据集总共仅1M左右，共计3张表，其中事实表有10000条数据。数据集是一个规范的星形模型结构，它总包含3个数据表：<br>KYLIN_SALES是事实表，保存了销售订单的明细信息。各列分别保存着卖家、商品、分类、订单金额、商品数据等信息，每一行对应着一笔交易订单。<br>KYLIN_CATEGORY_GROUPINGS是维表，保存了商品分类的详细介绍，例如商品分类名称等。<br>KYLIN_CAL_DT也是维表，保存了时间的扩展信息。如单个日期所在的年始、月始、周始、年份、月份等。<br>这3张表一起构成了整个星形模型。  </p>
<p>#设计Cube<br>如果数据已经在Hive中准备好了，就可以开始创建Cube了。</p>
<p>##导入Hive表定义<br>登陆Kylin的Web界面，创建新的或选择一个已有的项目之后，需要做的就是将Hive表的定义导入到Kylin中。<br>单击Web界面的Model-&gt;Data Source下的”Local Hive Table“图标，然后输入表的名称（可以一次导入多个表，以逗号分隔表名），单击按钮”Sync“，Kylin就会使用Hive的API从Hive中获取表的属性信息。<br>导入成功后，表的结构信息会以树状的形式显示在页面的左侧，可以单击展开或收缩。</p>
<p>同时Kylin会在后台触发一个MapRecue任务，计算此表的每个列的基数。通常稍过几分钟后再刷新页面，就会看到显示出来 的基数信息Cardinality</p>
<p>需要注意的是，这里Kylin对基数的计算方法采用的是HyperLogLog的近似算法，与精确值略有误差，只做参考值。</p>
<p>##创建数据模型<br>有了表信息之后，就可以开始创建数据模型（Data Model）了。数据模型是Cube的基础，它主要用于描述一个星形模型。有了数据模型以后，定义Cube的时候就可以直接从此模型定义的表和列中进行选择了，省去重复指定连接（join）条件的步骤。基于一个数据模型还可以创建多个Cube，以方便减少用户的重复性工作。<br>在Kylin界面中”Models“页面中单击”New”-&gt;”New Model”，开始创建数据模型。</p>
<p>接下来选择用作维度和度量的列。这里只是选择一个范围，不代表这些列将来一定要用作Cube 的维度或度量，你可以把所有可能会用到表都选进来，后续创建Cube的时候，将只能从这些列中进行选择。   </p>
<p>选择维度列时，维度可以来自事实表或维度表<br>选择度量列时，度量只能来自事实表<br>最后一步，是为模型补充侵害时间列信息和过滤条件。如果此模型中的事实表记录是按时间增长的，那么可以指定一个日期/时间列作为模型的分割时间列，从而可以让Cube按此列做增量构建。</p>
<p>过滤（Filter）条件是指，如果想把一些记录忽略掉，那么这里可以设置一个过滤条件。Kylin在向Hive请求源数据的时候，会带上此过滤条件。</p>
<p>随后“Save”后，出现在“Model”的列表中。</p>
<p>##创建Cube<br>单击“New”，选择“New Cube”，会开启一个包含若干步骤的向导。</p>
<p>第一页，选择要使用的数据模型，并为此Cube输入一个唯一的名称（必需的）和描述（可选的）；这里还可以输入一个邮件通知列表，用于在构建完成或出错时收到通知。如果不想接收处于某些状态的通知，那么可以从“Notification Events”中将其去掉。</p>
<p>第二页，选择Cube的维度。可以通过以下两个按钮来添加维度。<br><strong>“Add Mimension”</strong>：逐个添加维度，可以是普通维度也可以是衍生（Derived）维度。<br><strong>“Auto Generator”：</strong>批量选择并添加，让Kylin自动完成其它信息。<br>使用第一种方法的时候需要为每个维度起个名字，然后选择表和列。<br>如果是衍生维度的话，则必须是来自于某个维度表，一次可以选择多个列；由于这些列值都可以从该维度表的主键值中衍生出来，所以实际上只有主键列会被Cube加入计算。而在Kylin 的具体实现中，往往采用事实表上的外键替代主键进行计算和存储。但是在逻辑上可以认为衍生列来自于维度表的主键。<br>使用第二种方法，Kylin会用一个树状结构呈现出所有的列，用户只需要勾选所需要的列即可，Kylin会自动补充其他信息，从而方便用户的操作。请注意，在这里Kylin会把维度表上的列都创建成衍生维度，这也许不是最合适的，在这种情况下请使用第一种方法。</p>
<p>第三页，创建度量。Kylin默认会创建一个Count(1)的度量。可以单击“+Measure”按钮来添加新度量。Kylin支持的度量有：SUM、MIN、MAX、COUNT、COUNT　DISTINCT、ＴＯＰ＿Ｎ、RAW等。请选择需要的度量类型，然后再选择适当的参数（通常为列名）</p>
<p>重复上面的步骤，创建所需要的度量。Kylin可以支持在一个Cube中添加多达上百个度量；添加完成所有度量之后，单击“Next”。</p>
<p>第四页，是关于Cube数据刷新的设置。在这里可以设置自动合并的阈值、数据保留的最短时间，以及第一个Segment的起点时间（如果Cube有分割时间列的话）。</p>
<p>第五页，高级设置。在此页面上可以设置聚合组和Rowkey<br>Kylin默认会把所有的维度都放在同一个聚合中；如果维度数据较多（例如&gt;10），那么建议用户根据查询的习惯和模式，单击“New Aggregation Group+”，将维度分为多个聚合组。通过使用多个聚合组，可以大大降低Cube中的Cuboid数量。下面来举例说明，如果一个Cube有（M+N)个维度，那么默认它会有2的m+n次方个Cuboid；如果把这些维度分为两个不相交的聚合组，那么Cuboid的数量将被减少为2的m次方+2的n次方。<br>在单个聚合组中，可以对维度设置高级属性，例如Mandatory、Hierarchy、Joint等。这几个属性都是为了优化Cube的计算而设计的，了解这些属性的含义对日后更好地使用Cube至关重要。<br>Mandatory维度指的是那些总是会出现在where条件或Group By语句里的维度；通过将某个维度指定为Mandatory，Kylin就可以不用预计算那些不包含此维度的Cuboid，从而减少计算量。<br>Hierarchy是一组有层级关系的维度，例如：“国家”“省”“市”，这里的“国家”是高级的维度，“省”“市”依次是低级的维度。用户会按高级别维度进行查询，也会按低级别维度进行查询，但在查询低级别维度时，往往都会带上高级别维度的条件，而不会孤立地审视低级别维度的数据。例如，用户单击“国家”作为维度来查询汇总数据，也可能单击“国家”+“省”或者“国家”+“省”+“市”来查询，但是不会跨越国家直接Group By“省”或“市”。通过指定Hierarchy，Kylin可以省略不满足此模式的cuboid。<br>Joint是将多个维度组合成一个维度，其通常适用于如下两种情况。<br>1.总是会在一起查询的维度。<br>2.基数很低的维度<br>Kylin以Key-Value的方式将Cube存在到HBase中。HBase的key，也就是Rowkey，是由各维度的值拼接而成的；为了更高效地存储这些值，Kylin会对它们进行编码和压缩；每个维度均可以选择合适的编码（Encoding）方式，默认采用的是字典（Dictionary）编码技术；除了字典以外，还有整数（Int）和固定长度（Fixed Length）的编码。<br>字典编码是将此维度下所有值构建成一个从string到int的映射表；Kylin会将字典序列化保存，在Cube中存储int值，从而大大减小存储的大小。另外，字典是保持顺序的，即如果字符串A比字符串B大的话，那么A的编码后的int值也会比B编码后的值大；这样可以使得在HBase中进行比较查询的时候，依然使用编码后的值，而无需解码。</p>
<p>字典非常适合于非固定长度的string类型值的维度，而且用户无需指定编码后的长度；但是由于使用字典需要维护一张映射表，因些如果此维度的基数很高，那么字典的大小就非常可观，从而不适合于加载到内存中，在这种情况下就要选择其他的编码方式了。Kylin中字典编码允许的基数上限默认是500万（由参数”kylin.dictioinary.max.cardinality”配置）。<br>整数（int）编码适合于对int或bigint类型的值进行编码，它无需额外存储，同时还可以支持很大的基数。用户需要根据值域选择编码的长度。例如有一个手机号码的维度，它是一个11位的数字，如13800138000，我们知道它大于2的31次方，但是小于2的39次方减1，那么使用int(5)即可满足要求，每个值占用5字节，比按字符存储（11字节）要少占一半以上的空间。  </p>
<p>当上面几种编码方式都不适合的时候，就使用固定长度的编码了；此编码方式其实只是将原始值截断或补充成相同长度的一组字节，没有额外的转换，所以空间效率较差，通常只是作为一种权宜手段。<br>各维度在Rowkeys中的顺序，对于 查询的性能会产生较明显的影响。在这里用户可以根据查询的模式和习惯，通过拖拽的方式调整各个维度在Rowkeys上的顺序。通常的原则是，将过滤频率较高的列放置在过滤频率较低的列之前，将基数高的列放置在基数低的列之前。这样做的好处是，充分利用过滤条件来缩小在HBase中扫描的范围，从而提高查询的效率。<br>第五页，为Cube配置参数。和其他Hadoop工具一样，Kylin使用了很多配置参数以提高录活性，用户可以根据具体的环境、场景等配置不同的参数进行调优。Kylin全局的参数值可在conf/kylin.properties文件中进行配置；如果Cube需要覆盖全局设置的话，则需要在此页面中指定。单击“+Property”按钮，然后输入参数名和参数值。例如“kylin.hbase.region.cut=1”,这样此Cube在存储的时候，Kylin将会为每个HTbase Region分配1GB来创建一个HTbase Region。</p>
<p>#构建Cube<br>新创建的Cube只有定义，而没有计算的数据，它的状态是”DISABLED“，是不会被查询引擎挑中的。要想让Cube有数据，还需要对它进行构建。Cube的构建方式通常有两种：全量构建和增量构建；两者的构建步骤是完全一样的，区别只在于构建时读取的数据源是全集还是子集。<br>Cube的构建包含如下步骤，由任务引擎来调度执行。<br>1）创建临时的Hive平表（从Hive读取数据）<br>2）计算各维度的不同值，并收集各Cuboid的统计数据。<br>3）创建并保存字典。<br>4）保存Cuboid统计信息。<br>5）创建HTable。<br>6）计算Cube（一轮或若干轮MapRecue）。<br>7）将Cube的计算结果转成HFile。<br>8）加载HFile到HBase。<br>9）更新Cube元数据。<br>10）垃圾回收。<br>以上步骤中，前5步是计算Cube而做的准备工作，例如遍历维度值来创建字典，对数据做统计秋估算以创建HTable等；第6）步是真正的Cube计算，取决于所使用的Cube算法，它可能是一轮MapRecue任务，也可能是N（在没有优化的情况下，N可以被视作是维度数）轮迭代的MapRecue。由于Cube运算的中间结果是以SequenceFile的格式存储在HDFS上的，所以为了导入到HBase中，还需要第7）步将这些结果转换成HFile（HBase文件存储格式）。第8）步通过使用HBase BulkLoad工具，将HFile导入到HBase集群，这一步完成之后，HTable就可以查询到数据了。第9）步更新Cube的数据，将此次构建 Segment的状态从”NEW“更新为”ＲＥＡＤＹ＂，表示已经可借查询了。最后一步，清理构建过程中生成的临时文件等垃圾，释放集群资源。　　<br>Monitor页面会显示当前项目下近期的构建任务。　　</p>
<p>##全量构建和增量构建</p>
<p>###全量构建</p>
<p>###增量构建</p>
<p>##历史数据刷新</p>
<p>##合并</p>
<p>#查询Cube</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cenrise.com/2017/04/16/hadoop/Hadoop之分布式存储/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongpo.jia">
      <meta itemprop="description" content="个人博客">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="中起之星">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/16/hadoop/Hadoop之分布式存储/" itemprop="url">
                  分布式存储
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-04-16 23:43:49" itemprop="dateCreated datePublished" datetime="2017-04-16T23:43:49+08:00">2017-04-16</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-08-18 09:44:35" itemprop="dateModified" datetime="2017-08-18T09:44:35+08:00">2017-08-18</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/分布式/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/分布式/分布式存储/" itemprop="url" rel="index"><span itemprop="name">分布式存储</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##Bigtable<br>Bigtable是非关系型数据库，是一个稀疏的、分布式的、持久化存储的多维度排序map。Bigtable设计的目的是快速且可靠地处理PB级别的数据，并且能够部署到上千台机器上。</p>
<p>Bigtable是闭源的，Cloud Bigtable是Google提供的大数据存储云服务。业界相关的Bigtable模型的开源实现为Apache HBase。</p>
<p>##HBase<br>HBase是一个高可靠、高性能、面向列、可伸缩的分布式存储系统，利用HBase技术可以在廉价PC上搭建起大规模结构化存储集群。<br>HBase是Google Bigtable的开源实现，类似于Google Bigtable利用GFS作为其文件存储系统，HBase利用Hadoop HDFS作为其文件存储系统；Google运行MapRecue来处理Bigtable中的海量数据，HBase同样利用Hadoop MapRecue来处理HBase中的海量数据；Google Bigtable利用Chubby作为协同服务，HBase利用Zookeeper作为对应。</p>
<p>###特性：<br>强一致性读写：HBase不是“Eventual Consistentcy（最终一致性）”数据存储，这让它很适合高速计数聚合类任务；<br>自动分片（Automatic sharding）：HBase表通过region分布在集群中，数据增长时，region会自动分割并重新分布；<br>RegionServer自动故障转移<br>Hadoop/HDFS集成：HBase支持开箱即用HDFS作为它的分布式文件系统；<br>MapRecue：HBase通过MapRecue支持大并发处理；<br>Java客户端API：HBase支持易于使用的Java API进行编程访问;<br>Thrift/REST API：HBase也支持Thrift和Rest作为非Java前端访问；<br>Block Cache和Bloom Filter：对于大容量查询优化，HBase支持Block Cache和Bloom Filter;<br>运维管理：HBase支持JMX提供内置网页用于运维。</p>
<p>###HBase应用场景<br>HBase不适合所有场景。<br>首先，确信有足够多数据，如果有上亿或上千亿行数据，HBase是很好的备选。如果只有上千或上百万行，则用传统的RDBMS可能是更好的选择。因为所有数据如果只需要在一两个节点进行存储，会导致集群其他节点闲置。<br>其次，确信可以不依赖于RDBMS的额外特性。例如，列数据类型、第二索引、事务、高级查询语言等<br>最后，确保有足够的硬件。因为HDFS在小于5个数据节点时，基本上体现不出来它的优势。<br>虽然HBase能在单独的笔记本上运行良好，但这应仅当成是开发阶段的配置 。</p>
<p>###HBase的优点<br>列可以动态增加，并且列为空就不存储数据，节省存储空间；<br>HBase可以自动切分数据，使得数据存储自动具有水平扩展功能；<br>HBase可以提供高并发读写操作的支持；<br>与Hadoop MapRecue相结合有利于数据分析；<br>容错性；<br>版权免费；<br>非常灵活的模式设计（或者说没有固定模式的限制）；<br>可以跟Hive集成，使用类SQL查询；<br>自动故障转移；<br>客户端接口易于使用；<br>行级别原子性，即PUT操作一定是完全成功或者完全失败。</p>
<p>###HBase的缺点<br>不能支持条件查询，只支持按照row key来查询；<br>容易产生单点故障（在只使用一个HMaster的时候）；<br>不支持事务；<br>JOIN不是数据库层支持的，而需要用MapRecue；<br>只能在主键上索引和排序；<br>没有内置的身份和权限认证；</p>
<p>###HBase与Hadoop/HDFS的差异<br>HDFS是分布式文件系统，适合保存大文件。官方宣称它并非普通用途的文件系统，不提供文件的个别记录的快速查询。另一方面，HBase基于HDFS，并能够提供大表的记录快速查询和更新。HBase内部将数据放到索引好的“StoreFiles”存储文件中，以便提供高速查询，而存储文件位于HDFS中。</p>
<p>##Cassandra<br>Cassandra是Facebook于2008年7月在Google Code上开源的项目。Cassandra实现了Dynamo风格的副本复制模型和没有单点失效的架构，增加了更加强大的column family数据模型。</p>
<p>##Memcached<br>Memcached可以更好利用内存</p>
<p>##Redis<br>Redis是一个key-value模型的内在数据存储系统。</p>
<p>##MongoDB<br>MongoDB是一个介于关系型数据库和非关系性数据库之间的产品，是非关系型 数据库中功能最丰富、最像关系型 数据库的，旨在为Web应用提供可扩展的高性能数据存储解决方案。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cenrise.com/2017/04/15/kettle/Kettle插件架构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongpo.jia">
      <meta itemprop="description" content="个人博客">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="中起之星">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/15/kettle/Kettle插件架构/" itemprop="url">
                  Kettle插件架构
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-04-15 19:42:49" itemprop="dateCreated datePublished" datetime="2017-04-15T19:42:49+08:00">2017-04-15</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-08-18 09:44:35" itemprop="dateModified" datetime="2017-08-18T09:44:35+08:00">2017-08-18</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/开源项目/" itemprop="url" rel="index"><span itemprop="name">开源项目</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/开源项目/kettle/" itemprop="url" rel="index"><span itemprop="name">kettle</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Kettle插件体系"><a href="#Kettle插件体系" class="headerlink" title="#Kettle插件体系"></a>#Kettle插件体系</h1><p>最近公司内有业务系统到数据中心同步的升级改造需求，从各个业务系统收集增量数据到数据中心的数据仓库平台。因为开发周期短暂，需要快速的响应，开发出可用的产品，所以决定借鉴开源程序Kettle，开发一个文件解析组件，然后利用Kettle平台的大数据组件进行与数据中心大数据平台对接</p>
<p>数据同步部分是：业务系统（RDBMS）-&gt;Kettle(azkaban进行调度)-&gt;数据中心，因为Kettle的增量抽取组件经常出现数据不一致等问题，所以目前已更改为：业务系统（RDBMS）-&gt;OGG（CDC增量抽取）-&gt;数据中心的方式。</p>
<p>本文主要介绍如何扩展Kettle的功能，部分内容来自《Pentaho Kettle解决方案：使用PDI构建开源ETL解决方案》一书，推荐购买阅读。</p>
<h2 id="架构"><a href="#架构" class="headerlink" title="##架构"></a>##架构</h2><p>我们先看Kettle插件架构。<br> <img src="http://i.imgur.com/mLvXMuV.jpg" alt=""><br>从功能上看，Kettle内部的对象和外部插件没有任何区别。因为它们使用的API都是一样的，它们只是在运行时的加载方式不同。<br>从Kettle4以后，Kettle内部有一个插件注册系统，它负责加载各种内部和外部插件。插件有以下两个标识属性。<br><strong>插件类型</strong>：由PluginTypeInterface接口定义。例如StepPluginType、JobEntryPluginType、PartitionerPluginType和RepositoryPluginType。<br><strong>插件ID</strong>：这是一个字符串数组，用来唯一标识一个插件。因为旧的插件可以被新的插件代替，一个插件可以有多个ID。在大多数情况下，插件只使用一个单一的字符串，如TableInput是“表输入”步骤的ID，MYSQL是MySQL数据库类型的ID。<br>当Kettle环境初始化以后，插件注册系统首先加载所有的内部对象，Kettle读取下面的配置文件来加载内部对象，这些配置文件位于Kettle的.jar文件中。<br>     Kettle-steps.xml：内部转换步骤。<br>     Kettle-job-entries.xml：内部作业项。<br>     Kettle-partition-plugins.xml：内部分区类型。<br>     Kettle-database-types.xml：内部数据库类型。<br>     Kettle-repositories.xml：内部资源库类型。</p>
<p>插件注册系统加载了所有的内部对象后，就要搜索可用的外部插件。通过浏览plugins/目录的各个子目录下的.jar文件来完成。它搜索特定的Kettle annotations来判断一个类是否是插件。加载过程将在本章的后面介绍。<br>因为在内部对象加载后才加载插件，所以插件会替代相同ID的已加载的内部对象。例如，你创建了插件，插件的ID是TableInput，就可以替换Kettle标准的“表输入”步骤。这个功能可以让你用插件替换Kettle内置的步骤。可以通过子类继承方式，直接扩展已有步骤的某些功能。</p>
<h2 id="插件类型"><a href="#插件类型" class="headerlink" title="##插件类型"></a>##插件类型</h2><p>Kettle有下面几种插件类型（下面的插件是Kettle4.0的插件类型，新版kettle包含了很多新的插件，比如视图插件、大数据插件等等）。</p>
<ul>
<li>转换步骤插件：在Kettle转换中使用的步骤，用来处理数据行。</li>
</ul>
<ul>
<li>作业项插件：在Kettle作业中使用的作业项，用来实现某个任务。</li>
</ul>
<ul>
<li>分区方法插件：利用输入字段的值指定自己的分区规则。</li>
</ul>
<ul>
<li>数据库类型插件：用来扩展不同的数据库类型。</li>
</ul>
<ul>
<li>资源库类型插件：可以把Kettle元数据保存为自定义类型或格式。</li>
</ul>
<p>说明：除了这些类型，还有Spoon类型的插件，可以把功能扩展到Spoon，本书不介绍这个功能。</p>
<h2 id="转换步骤插件"><a href="#转换步骤插件" class="headerlink" title="##转换步骤插件"></a>##转换步骤插件</h2><p>转换步骤插件包括了四个Java类，这四个类分别实现四个接口。</p>
<ul>
<li>StepMetaInterface：这个接口对外 提供步骤的元数据并处理串行化。</li>
</ul>
<ul>
<li>StepInterface:这个接口根据上面接口提供的元数据，来实现步骤的具体功能。</li>
</ul>
<ul>
<li>StepDataInterface:这个接口用来存储步骤的临时数据、文件句柄等。</li>
</ul>
<ul>
<li>StepDialogInterface:这个接口是Spoon里的图形界面，用来编辑步骤的元数据。</li>
</ul>
<p>接下来，我们介绍这些接口的基本内容。对于每个接口，在一个简单的“Hello World”例子里提供这些类的相应实现。“Hello World”例子将在数据流里增加一个字段，字段名用户可以自定义，字段值是”Hello world!“。最后介绍一下如何部署这个例子。</p>
<h3 id="StepMetaInterface"><a href="#StepMetaInterface" class="headerlink" title="###StepMetaInterface"></a>###StepMetaInterface</h3><p>接口org.pentaho.di.trans.step.StepMetaInterface负责步骤里所有和元数据相关的任务。和元数据相关的工作包括：<br>元数据和XML(或资源库)之间的序列化和反序列化<br>getXML（）和loadXML()<br>saveRep()和readRep()  </p>
<p>描述输出字段<br>getFields()  </p>
<p>检验元数据是否正确<br>Check()  </p>
<p>获取步骤相应的要SQL语句，使步骤可以正确运行<br>getSQLStatements()  </p>
<p>给元数据设置默认值<br>setDefault()  </p>
<p>完成对数据库的影响分析<br>analyseImpact()  </p>
<p>描述各类输入和输出流<br>getStepIOMeta()<br>searchInfoAndTargetSteps()<br>handleStreamSelection()<br>getOptionalStreams()<br>resetStepIoMeta()  </p>
<p>导出元数据资源<br>exportResources()<br>getResourceDependencies()  </p>
<p>描述使用的库<br>getUsedLibraries()  </p>
<p>描述使用的数据库连接<br>getUsedDatabaseConnections()  </p>
<p>描述这个步骤需要的字段（通常是一个数据库表）<br>getRequiredFields()  </p>
<p>描述步骤是否具有某些功能<br>supportsErrorHandling()<br>excludeFromRowLayoutVerification()<br>excludeFromCopyDistributeVerification()  </p>
<p>这个接口里还定义了几个方法来说明这四个接口如何结合到一起。<br>String getDialogClassName():用来描述实现了StepDialogInterface接口的对话框类的名字。如果这个方法返回了null，调用类会根据实现了StepMetaInterface接口的类的类名和包名来自动生成对话框类的名字。<br>SetpInterface getStep():创建一个实现了StepInterface接口的类。<br>StepDataInterface getStepData():创建一个实现了StepDataInterface接口的类。<br>现在我们看看”Hello World”例子里对SetpMetaInterface接口的实现<br>HelloworldStepMeta.java<br>    package org.kettlesolutions.plugin.step.helloworld;</p>
<pre><code>import java.util.List;
import java.util.Map;

import org.pentaho.di.core.CheckResult;
import org.pentaho.di.core.CheckResultInterface;
import org.pentaho.di.core.Const;
import org.pentaho.di.core.Counter;
import org.pentaho.di.core.annotations.Step;
import org.pentaho.di.core.database.DatabaseMeta;
import org.pentaho.di.core.exception.KettleException;
import org.pentaho.di.core.exception.KettleStepException;
import org.pentaho.di.core.exception.KettleXMLException;
import org.pentaho.di.core.row.RowMetaInterface;
import org.pentaho.di.core.row.ValueMeta;
import org.pentaho.di.core.row.ValueMetaInterface;
import org.pentaho.di.core.variables.VariableSpace;
import org.pentaho.di.core.xml.XMLHandler;
import org.pentaho.di.i18n.BaseMessages;
import org.pentaho.di.repository.ObjectId;
import org.pentaho.di.repository.Repository;
import org.pentaho.di.trans.Trans;
import org.pentaho.di.trans.TransMeta;
import org.pentaho.di.trans.step.BaseStepMeta;
import org.pentaho.di.trans.step.StepDataInterface;
import org.pentaho.di.trans.step.StepInterface;
import org.pentaho.di.trans.step.StepMeta;
import org.pentaho.di.trans.step.StepMetaInterface;
import org.w3c.dom.Node;

@Step(
        id=&quot;Helloworld&quot;,
        name=&quot;name&quot;,
        description=&quot;description&quot;,
        categoryDescription=&quot;categoryDescription&quot;, 
        image=&quot;org/kettlesolutions/plugin/step/helloworld/HelloWorld.png&quot;,
        i18nPackageName=&quot;org.kettlesolutions.plugin.step.helloworld&quot;
) 
public class HelloworldStepMeta extends BaseStepMeta implements StepMetaInterface {
    /**
     * PKG变量说明了messages包的位置，在messages包里有各种国际化的资源文件。
     * 在本章后面经常要看到的BaseMessages.getString()方法，就是根据软件的国际化
     * 设置，从不同的文件中获取文字。PKG变量通常位于类的最上方，被国际化图形工具使用，
     * 通过国际化图形工具，国际化人员可以编辑不同的国际化资源文件。所以我们会在很多Kettle
     * 代码里看见这样的结构。
     */
    private static Class&lt;?&gt; PKG = HelloworldStep.class; //for i18n
    public enum Tag {//field_name用于保存用户输入的字段名：保存“Hello，world！&quot;字符串的字段名。
        field_name,
    };

    private String fieldName;

    /**
     * @return the fieldName
     */
    public String getFieldName() {
        return fieldName;
    }

    /**
     * @param fieldName the fieldName to set
     */
    public void setFieldName(String fieldName) {
        this.fieldName = fieldName;
    }

    /**
     * checks parameters, adds result to List&lt;CheckResultInterface&gt;
     * used in Action &gt; Verify transformation
     * 验证用户是否在对话框里输入了字段名，并把验证结果添加到检验转换时出现的问题列表里。（最好
     * 要检验用户输入的所有选项，而不只是容易出错的选项）
     */
    public void check(List&lt;CheckResultInterface&gt; remarks, TransMeta transMeta, StepMeta stepMeta, 
            RowMetaInterface prev, String input[], String output[], RowMetaInterface info) {

        if (Const.isEmpty(fieldName)) {
            CheckResultInterface error = new CheckResult(
                CheckResult.TYPE_RESULT_ERROR, 
                BaseMessages.getString(PKG, &quot;HelloworldMeta.CHECK_ERR_NO_FIELD&quot;), 
                stepMeta
            );
            remarks.add(error);
        } else {
            CheckResultInterface ok = new CheckResult(
                CheckResult.TYPE_RESULT_OK, 
                BaseMessages.getString(PKG, &quot;HelloworldMeta.CHECK_OK_FIELD&quot;), 
                stepMeta
            );
            remarks.add(ok);//把验证结果添加到检验转换时出现的问题列表里。
        }
    }

    /**
     *    creates a new instance of the step (factory)
     * getStep、getStepData和getDialogClassName()方法提供了与这个步骤里其它三个接口之间的桥梁
     这个接口里还定义了几个方法来说明这四个接口如何结合到一起。
    String getDialogClassName():用来描述实现了StepDialogInterace接口的对话框类的名字。如果这个方法返回
                了null，调用类会根据实现了StepMetaInterface接口的类的类名和包名来自动生成对话框类的名字。
    StepInterface getStep():创建一个实现了StepInterface接口的类。
    StepInterface getStepData():创建一个实现了StepDataInterface接口的类。

     */
    public StepInterface getStep(StepMeta stepMeta, StepDataInterface stepDataInterface,
            int copyNr, TransMeta transMeta, Trans trans) {
        return new HelloworldStep(stepMeta, stepDataInterface, copyNr, transMeta, trans);
    }

    /**
     * creates new instance of the step data (factory)
     * getStep、getStepData和getDialogClassName()方法提供了与这个步骤里其它三个接口之间的桥梁
     */
    public StepDataInterface getStepData() {
        return new HelloworldStepData();
    }
    /**
     * getStep、getStepData和getDialogClassName()方法提供了与这个步骤里其它三个接口之间的桥梁
     */
    @Override
    public String getDialogClassName() {
        return HelloworldStepDialog.class.getName();
    }

    /**
     * deserialize from xml 
     * databases = list of available connections
     * counters = list of sequence steps
     * 
     * 下面的四个方法loadXML()、getXML()、readRep()和saveRep()把元数据保存到XML文件或资源库里，
     * 或者从XML文件或资源库读取元数据。保存到文件的方法利用了像XStream（http://xstream.codehaus.org）这
     * 样的XML串行化技术。
     */
    public void loadXML(Node stepDomNode, List&lt;DatabaseMeta&gt; databases,
            Map&lt;String, Counter&gt; sequenceCounters) throws KettleXMLException {
        fieldName = XMLHandler.getTagValue(stepDomNode, Tag.field_name.name());
    }

    /**
     * @Override
     */
    public String getXML() throws KettleException {
        StringBuilder xml = new StringBuilder();
        xml.append(XMLHandler.addTagValue(Tag.field_name.name(), fieldName));
        return xml.toString();
    }

    /**
     * De-serialize from repository (see loadXML)
     */
    public void readRep(Repository repository, ObjectId stepIdInRepository,
            List&lt;DatabaseMeta&gt; databases, Map&lt;String, Counter&gt; sequenceCounters)
            throws KettleException {
        fieldName = repository.getStepAttributeString(stepIdInRepository, Tag.field_name.name());
    }

    /**
     * serialize to repository
     */
    public void saveRep(Repository repository, ObjectId idOfTransformation, ObjectId idOfStep)
            throws KettleException {
        repository.saveStepAttribute(idOfTransformation, idOfStep, Tag.field_name.name(), fieldName);
    }


    /**
     * initiailize parameters to default
     */
    public void setDefault() {
        fieldName = &quot;helloField&quot;;
    }

    /**
     * getFields()方法非常重要，因为它描述了输出数据行的结构。这个方法需要修改inputRowMeta对象，使这个对象和
     * 输出格式匹配。Spoon和后面的步骤都需要知道这个步骤要输出哪些字段。最常见的一种方法，可以给输出的RowMetaInterface对象
     * 添加一个ValueMetaInterface对象。在ValueMetaInterface对象里设置的信息越详细越好，可以设置的信息包括数据类型、长度、
     * 精度、格式掩码，等等。添加的字段描述元信息越多，后面生成的SQL就越准确。
     */
    @Override
    public void getFields(RowMetaInterface inputRowMeta, String name,
            RowMetaInterface[] info, StepMeta nextStep, VariableSpace space)
            throws KettleStepException {
        String realFieldName = space.environmentSubstitute(fieldName);
        //值的元数据使用ValueMetaInterface接口描述数据流里的一个字段。这个接口里定义了字段的名字、数据类型、长度、精度，等等。下面的例子用于创建一个ValueMetaInterface对象。
        ValueMetaInterface field = new ValueMeta(realFieldName, ValueMetaInterface.TYPE_STRING);
        field.setOrigin(name);        
        inputRowMeta.addValueMeta(field);
    }
}
</code></pre><p>代码解析<br>    @Step(<br>            id=”Helloworld”,<br>            name=”name”,<br>            description=”description”,<br>            categoryDescription=”categoryDescription”,<br>            image=”org/kettlesolutions/plugin/step/helloworld/HelloWorld.png”,<br>            i18nPackageName=”org.kettlesolutions.plugin.step.helloworld”<br>    )<br>这段代码里的@Step annotation用来通知Kettle的插件注册系统：这个类是一个步骤类型的插件。在annotation里可以指定插件的ID、图标、国际代的包、本地化的名称、类别、描述。其中后三项是资源文件里的Key，需要在资源文件里设置真正的值。i18nPackageName指定了资源文件的包名，例如我们这个例子的资源文件位于org/kettlesolutions/plugin/step/helloworld/messages目录下，en_US（英语，美国）的本地代资源文件是messages_en_US.properties。我们例子里的这个资源文件的内容是：<br>name=Hello world<br>description=A very simple step that adds a new “Helllo world” field to the incoming stream<br>注意，如果你指定了不存在的分类，Spoon会创建这个分类，并在Spoon的分类树的最上方显示这个分类。<br>最后，annotation里的image标签指定了插件的图标。需要32*32像素的PNG文件，可以使用透明样式。<br>后面的代码行说明这个类实现了StepMetaInterface接口。在BaseStepMeta抽象类里定义了这个接口的很多默认实现，可以直接继承这个抽象类，然后把工作集中在插件特有的功能上。</p>
<pre><code>public class HelloworldStepMeta extends BaseStepMeta implements StepMetaInterface
</code></pre><p>下面的四个方法loadXML()、getXML()、readRep()和saveRep()把元数据保存到XML文件或资源库里，或者从XML文件或资源库读取元数据。保存到文件的方法利用了像XStream（<a href="http://xstream.codehaus.org）这样的XML串行化技术。" target="_blank" rel="noopener">http://xstream.codehaus.org）这样的XML串行化技术。</a></p>
<p>getFields()方法非常重要，因为它描述了输出数据行的结构。这个方法需要修改inputRowMeta对象，使这个对象和输出格式匹配。Spoon和后面的步骤都需要知道这个步骤要输出哪些字段。最常见的一种方法，可以给输出的RowMetaInterface对象添加一个ValueMetaInterface对象。在ValueMetaInterface对象里设置的信息越详细越好，可以设置的信息包括数据类型、长度、精度、格式掩码，等等。添加的字段描述元信息越多，后面生成的SQL就越准确。</p>
<h4 id="值的元数据（Value-Metadata）"><a href="#值的元数据（Value-Metadata）" class="headerlink" title="####值的元数据（Value Metadata）"></a>####值的元数据（Value Metadata）</h4><p>值的元数据使用ValueMetaInterface接口描述数据流里的一个字段。这个接口里定义了字段的名字、数据类型、长度、精度，等等。下面的例子用于创建一个ValueMetaInterface对象。<br>    ValueMetaInterface dateMeta = new ValueMeta(“birthdate”,ValueMetaInterface.TYPE_DATE);<br>这个接口也负责转换数据格式。我们建议使用ValueMetaInterface接口来完成所有数据转换的工作。例如，日期类型的数据，如果想把它转换为dateMeta对象里定义的字符串格式，可以用下面的代码：<br>    //java.util.Date birthdate<br>    String birthDateString = dateMeta.getString(birthdate);<br>ValueMeta类负责转换。因为有ValueMetaInterface进行数据类型的转换，所以你不用再去做额外的数据类型转换的工作。<br>使用ValueMetaInterface接口时还要注意数据对象是否为Null。从上一个步骤可以接收到一个数据对象和一个描述数据对象的ValueMetaInterface对象。我们要检查这个数据对象是否为null，在某些情况下如果数据对象为空是不正确的。例如：<br>数据对象是String类型，有10个空格，Value Metadata需要trim这个字符串。<br>在Value Metadata里已经定义了从文本文件里加载的数据，要延迟转换为字符串。所以数据要由二进制的格式（原始数据格式），转换为字符串格式，然后再转换为其它格式的数据。<br>一般使用下面的方法检查数据对象是否为空：<br>    Boolean n = valueMeta.isNull(valueDate);<br>重要：要保证传给ValueMetaInterface对象的数据是在元数据里定义的数据类型。表23-1说明了  ValueMetaInterface里定义的数据类型和Java数据类型的对应关系。<br>Kettle元数据类型和Java里数据类型的对应关系  </p>
<table><br>    <tr><br>        <th>Value Meta Type</th><br>        <th>Java Class</th><br>    </tr><br>    <tr><br>        <td>ValueMetaInterface.TYPE_STRING</td><br>        <td>Java.lang.String</td><br>    </tr><br>    <tr><br>        <td>ValueMetaInterface.TYPE_DATE</td><br>        <td>Java.util.Date</td><br>    </tr><br>    <tr><br>        <td>ValueMetaInterface.TYPE_BOOLEAN</td><br>        <td>Java.lang.Boolean</td><br>    </tr><br>    <tr><br>        <td>ValueMetaInterface.TYPE_NUMBER</td><br>        <td>Java.lang.Double</td><br>    </tr><br>    <tr><br>        <td>ValueMetaInterface.TYPE_INTEGER</td><br>        <td>Java.lang.Long</td><br>    </tr><br>    <tr><br>        <td>ValueMetaInterface.TYPE_BIGNUMBER</td><br>        <td>Java.math.BigDecimal</td><br>    </tr><br>    <tr><br>        <td>ValueMetaInterface.TYPE_BINARY</td><br>        <td>Byte[]</td><br>    </tr><br></table>


<h4 id="行的元数据（Row-Meatadata）"><a href="#行的元数据（Row-Meatadata）" class="headerlink" title="####行的元数据（Row Meatadata）"></a>####行的元数据（Row Meatadata）</h4><p>行的元数据使用RowMetaInterface接口来描述数据行的元数据，而不是一个列的元数据。实际上，RowMetaInterface的类里包含了一组ValueMetaInterface。另外还包括了一些方法来操作行元数据，倒如查询值、检查值是否存、替换值的元数据等。<br>行的元数据里唯一的规则就是一行里的列的名字必须唯一。当你添加了一个新列时，如果新列的名字和已有列的名字相同，列名后面会自动加上“_2”后缀。如果再加一个同名的列会自动加上”_3“后缀，等等。<br>因为在步骤里通常是和数据行打交道，所以从数据行里直接取数据会更方便。可以使用很多类似于getNumber()、getString()这样的方法直接从数据行取数据。例如，销售数据存储在第四列里，可以用下面的代码获取这个数据：  </p>
<pre><code>Double sales = getInputRowMeta().getNumber(rowData,3);
</code></pre><p>通过索引获取数据是最快的方式。通过indexOfValue()方法可以获取列在一行里的索引。这个方法扫描列数组，速度并不快。所以，如果要处理所有数据行，我们建议只查询一次列索引。一般是在步骤接收到第一行数据时，就查询列索引，将查询到的列索引保存起来，供后面的数据行使用。  </p>
<h3 id="StepDatainterface"><a href="#StepDatainterface" class="headerlink" title="###StepDatainterface"></a>###StepDatainterface</h3><p>实现了org.pentaho.di.trans.step.StepDataInterface接口的类用来维护步骤的执行状态，以及存储临时对象。例如，可以把输出行的元数据、数据库连接、输入输出流等存储到这个对象里。<br>HelloworldStepData.java<br>    package org.kettlesolutions.plugin.step.helloworld;</p>
<p>import org.pentaho.di.core.row.RowMetaInterface;<br>import org.pentaho.di.trans.step.BaseStepData;<br>import org.pentaho.di.trans.step.StepDataInterface;</p>
<p>public class HelloworldStepData extends BaseStepData implements StepDataInterface {</p>
<pre><code>public RowMetaInterface outputRowMeta;
</code></pre><p>}</p>
<h3 id="StepDialogInterface"><a href="#StepDialogInterface" class="headerlink" title="###StepDialogInterface"></a>###StepDialogInterface</h3><p>实现org.pentaho.di.trans.step.StepDialogInterfac接口的类用来提供一个用户界面，用户通过这个界面输入元数据（转换参数）。用户界面就是一个对话框。这个接口里包含了类似open()和setRepository()等的几个简单的方法。    </p>
<h4 id="Eclipse-SWT"><a href="#Eclipse-SWT" class="headerlink" title="####Eclipse SWT"></a>####Eclipse SWT</h4><p>Kettle里使用Eclipse SWT作为界面开发包，所以你也要使用SWT来开发对话框窗口。SWT为不同的操作系统Windows、OS X、Linux和Unix提供了一个抽象层。所以SWT的图形界面和操作系统期货的程序的界面风格非常相近。<br>在开始进行SWT开发之前，建议先访问SWT主面以了解更多的内容<a href="http://www.eclipse/org/swt。在SWT的网站上，你可以了解到SWT能做出什么样的界面效果：" target="_blank" rel="noopener">http://www.eclipse/org/swt。在SWT的网站上，你可以了解到SWT能做出什么样的界面效果：</a><br>SWT控件页，<a href="http://www.eclipse.org/swt/widgets/，给出了你能使用的所有控件。" target="_blank" rel="noopener">http://www.eclipse.org/swt/widgets/，给出了你能使用的所有控件。</a><br>SWT样例页，<a href="http://www.eclipse.org/swt/snippets/，给出了许多代码例子。" target="_blank" rel="noopener">http://www.eclipse.org/swt/snippets/，给出了许多代码例子。</a><br>最好的资源就是Kettle里150个内置步骤的对话框源代码。  </p>
<p>HelloworldStepDialog.java<br>    package org.kettlesolutions.plugin.step.helloworld;</p>
<pre><code>import org.eclipse.swt.SWT;
import org.eclipse.swt.events.ModifyEvent;
import org.eclipse.swt.events.ModifyListener;
import org.eclipse.swt.events.SelectionAdapter;
import org.eclipse.swt.events.SelectionEvent;
import org.eclipse.swt.events.ShellAdapter;
import org.eclipse.swt.events.ShellEvent;
import org.eclipse.swt.layout.FormAttachment;
import org.eclipse.swt.layout.FormData;
import org.eclipse.swt.layout.FormLayout;
import org.eclipse.swt.widgets.Button;
import org.eclipse.swt.widgets.Control;
import org.eclipse.swt.widgets.Display;
import org.eclipse.swt.widgets.Event;
import org.eclipse.swt.widgets.Label;
import org.eclipse.swt.widgets.Listener;
import org.eclipse.swt.widgets.Shell;
import org.eclipse.swt.widgets.Text;
import org.pentaho.di.core.Const;
import org.pentaho.di.i18n.BaseMessages;
import org.pentaho.di.trans.TransMeta;
import org.pentaho.di.trans.step.BaseStepMeta;
import org.pentaho.di.trans.step.StepDialogInterface;
import org.pentaho.di.ui.core.widget.TextVar;
import org.pentaho.di.ui.trans.step.BaseStepDialog;

public class HelloworldStepDialog extends BaseStepDialog implements
        StepDialogInterface {

    private static Class&lt;?&gt; PKG = HelloworldStepMeta.class; // for i18n
                                                            // purposes, needed
                                                            // by Translator2!!
                                                            // $NON-NLS-1$

    private HelloworldStepMeta input;

    private TextVar wFieldname;

    public HelloworldStepDialog(Shell parent, Object baseStepMeta,
            TransMeta transMeta, String stepname) {
        //初始化元数据对象以及步骤对话框的父类
        super(parent, (BaseStepMeta) baseStepMeta, transMeta, stepname);
        input = (HelloworldStepMeta) baseStepMeta;
    }

    public String open() {
        Shell parent = getParent();
        Display display = parent.getDisplay();

        shell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MIN
                | SWT.MAX);
        props.setLook(shell);
        setShellImage(shell, input);

        ModifyListener lsMod = new ModifyListener() {
            public void modifyText(ModifyEvent e) {
                input.setChanged();
            }
        };
        changed = input.hasChanged();

        FormLayout formLayout = new FormLayout();
        formLayout.marginWidth = Const.FORM_MARGIN;
        formLayout.marginHeight = Const.FORM_MARGIN;

        shell.setLayout(formLayout);
        shell.setText(BaseMessages.getString(PKG,
                &quot;HelloworldDialog.Shell.Title&quot;)); //$NON-NLS-1$

        //所有控件的右侧使用一个自定义的百分对对齐。控件之间的间距使用一个常量，常量值是4像素。
        int middle = props.getMiddlePct();
        int margin = Const.MARGIN;

        // Stepname line
        wlStepname = new Label(shell, SWT.RIGHT);
        wlStepname.setText(BaseMessages.getString(PKG,
                &quot;HelloworldDialog.Stepname.Label&quot;)); //$NON-NLS-1$
        props.setLook(wlStepname);
        fdlStepname = new FormData();
        fdlStepname.left = new FormAttachment(0, 0);
        fdlStepname.right = new FormAttachment(middle, -margin);
        fdlStepname.top = new FormAttachment(0, margin);
        wlStepname.setLayoutData(fdlStepname);
        wStepname = new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);
        wStepname.setText(stepname);
        props.setLook(wStepname);
        wStepname.addModifyListener(lsMod);
        fdStepname = new FormData();
        fdStepname.left = new FormAttachment(middle, 0);
        fdStepname.top = new FormAttachment(0, margin);
        fdStepname.right = new FormAttachment(100, 0);
        wStepname.setLayoutData(fdStepname);
        Control lastControl = wStepname;

        // Fieldname line
        //创建一个新的标签控件，控件里文本靠右对齐
        Label wlFieldname = new Label(shell, SWT.RIGHT);
        wlFieldname.setText(BaseMessages.getString(PKG,
                &quot;HelloworldDialog.Fieldname.Label&quot;)); //$NON-NLS-1$
        //下面一行为控件设置用户定义的背景色和字体
        props.setLook(wlFieldname);
        FormData fdlFieldname = new FormData();
        fdlFieldname.left = new FormAttachment(0, 0);
        fdlFieldname.right = new FormAttachment(middle, -margin);
        fdlFieldname.top = new FormAttachment(lastControl, margin);
        wlFieldname.setLayoutData(fdlFieldname);
        wFieldname = new TextVar(transMeta, shell, SWT.SINGLE | SWT.LEFT
                | SWT.BORDER);
        props.setLook(wFieldname);
        wFieldname.addModifyListener(lsMod);
        FormData fdFieldname = new FormData();
        fdFieldname.left = new FormAttachment(middle, 0);
        fdFieldname.top = new FormAttachment(lastControl, margin);
        fdFieldname.right = new FormAttachment(100, 0);
        wFieldname.setLayoutData(fdFieldname);
        lastControl = wFieldname;

        // Some buttons
        wOK = new Button(shell, SWT.PUSH);
        wOK.setText(BaseMessages.getString(PKG, &quot;System.Button.OK&quot;)); //$NON-NLS-1$
        wCancel = new Button(shell, SWT.PUSH);
        wCancel.setText(BaseMessages.getString(PKG, &quot;System.Button.Cancel&quot;)); //$NON-NLS-1$

        setButtonPositions(new Button[] { wOK, wCancel }, margin, lastControl);

        // Add listeners
        lsCancel = new Listener() {
            public void handleEvent(Event e) {
                cancel();
            }
        };
        lsOK = new Listener() {
            public void handleEvent(Event e) {
                ok();
            }
        };

        wCancel.addListener(SWT.Selection, lsCancel);
        wOK.addListener(SWT.Selection, lsOK);

        lsDef = new SelectionAdapter() {
            public void widgetDefaultSelected(SelectionEvent e) {
                ok();
            }
        };

        wStepname.addSelectionListener(lsDef);
        wFieldname.addSelectionListener(lsDef);

        // Detect X or ALT-F4 or something that kills this window...
        shell.addShellListener(new ShellAdapter() {//保证了窗口在非正常关闭时，取消用户的编辑
            public void shellClosed(ShellEvent e) {
                cancel();
            }
        });

        // Populate the data of the controls
        //下面的代码把数据从步骤的元数据对象里复制到窗口的控件里
        getData();

        // Set the shell size, based upon previous time...
        //窗口的大小和位置将根据窗口的自然属性、上次窗口大小和位置，以及显示屏的大小自动设置
        setSize();

        input.setChanged(changed);

        shell.open();
        while (!shell.isDisposed()) {
            if (!display.readAndDispatch())
                display.sleep();
        }
        return stepname;
    }

    /**
     * Copy information from the meta-data input to the dialog fields.
     */
    public void getData() {
        wStepname.selectAll();
        //为了防止用户向控件里输入空值，Kettle提供了一个静态方法来检查宿舍，Const.NVL()
        wFieldname.setText(Const.NVL(input.getFieldName(), &quot;&quot;));
    }

    private void cancel() {
        stepname = null;
        input.setChanged(changed);
        dispose();
    }
    //单击OK把控件里用户输入的数据都写入到步骤的元数据对象中。
    private void ok() {
        if (Const.isEmpty(wStepname.getText()))
            return;

        stepname = wStepname.getText(); // return value

        input.setFieldName(wFieldname.getText());

        dispose();
    }
}
</code></pre><h4 id="窗体布局"><a href="#窗体布局" class="headerlink" title="####窗体布局"></a>####窗体布局</h4><p>如果你看过步骤对话框的源代码，你就会发现窗体类里有很多烦琐的代码。这些代码确保Kettle可以在各种操作系统下以合适的方式展现窗体。可以发现窗体里的大部分代码都和布局以及控件位置有关。<br>FormLayout是SWT里经常看到的布局方式。程序员可以通过FormLayout指定控件的百分比、偏移。下面是我们例子里的窗口布局的代码（HelloworldStepDialog.java）<br>    //创建一个新的标签控件，控件里文本靠右对齐<br>    Label label = new Label(shell, SWT.RIGHT);<br>    label.setText(BaseMessages.getString(PKG,”HelloworldDialog.Fieldname.Label”)); //$NON-NLS-1$<br>    //下面一行为控件设置用户定义的背景色和字体<br>    props.setLook(label);<br>    /**</p>
<pre><code>* 下面几行将标签的左侧和对话框的最左侧对齐，把标签的右侧放在对话框中间（50%）的左侧10个像素
* 的位置。标签的顶部放在距离对话框顶部25个像素的位置。
*/
FormData fdLabel = new FormData();
fdlFieldname.left = new FormAttachment(0, 0);
fdlFieldname.right = new FormAttachment(50, -10);
fdlFieldname.top = new FormAttachment(0, 25);
wlFieldname.setLayoutData(fdLabel);  
</code></pre><p>简而言之，不要感到痛苦；图形用户界面的代码都比较烦琐，但代码并不复杂。  </p>
<h4 id="Kettle-UI元素"><a href="#Kettle-UI元素" class="headerlink" title="####Kettle UI元素"></a>####Kettle UI元素</h4><p>除了标准的SWT组件，还可以使用Kettle自带的一些控件，Kettle开发人员的工作可以更简单一些。Kettle自带的组件包括以下一些。<br>TableView：这是一个数据表格组件，支持排序、选择、键盘快捷键和撤销/重做，以及右键菜单。<br>TextVar：这是一个支持变量的文本输入框，这个输入框的右上角有一个$符号。用户可以通过”Ctrl  +Alt+空格”的方式，在弹出的下拉列表中选择变量。其他功能和普通的文本框相同。<br>ComboVar：标准的组合下拉列表，支持变量。<br>ConditionEditor：过滤行步骤里使用的输入条件控件。<br>另外还有很多常用的对话框帮你完成相应的工作，如下所示:<br>EnterListDialog:从字符串列表里选择一个或多个字符串。左侧显示字符串列表，右侧是选中的字符串，并提供把字符串从左侧移动到右侧的按钮。<br>EnterNumberDialog:用户可以输入数字<br>EnterPasswordDialog:让用户输入密码<br>EnterSelectionDialog:通过高亮显示，从列表里选择多项<br>EnterMappingDialog:输入两组字符串的映射<br>PreviewRowsDialog:在对话框里预览一组数据行。<br>SQLEditor:一个简单的SQL编辑器，可以输入查询和DDL.<br>ErrorDialog:显示异常信息，列出详细的错误栈对话框  </p>
<h4 id="Hello-World例子对话框"><a href="#Hello-World例子对话框" class="headerlink" title="####Hello World例子对话框"></a>####Hello World例子对话框</h4><p>现在我们已经基本了解了SWT以及对话框的布局方式，再看看我们的例子，下面的代码是HelloWorldStepDialog.java里的例子。<br>代码的第一部分是初始化元数据对象以及步骤对话框的父类：<br>    public class HelloworldStepDialog extends BaseStepDialog implements<br>            StepDialogInterface {<br>        private static Class&lt;?&gt; PKG = HelloworldStepMeta.class;<br>        private HelloworldStepMeta input;<br>        private TextVar wFieldname;<br>        public HelloworldStepDialog(Shell parent, Object baseStepMeta,<br>                TransMeta transMeta, String stepname) {<br>            //初始化元数据对象以及步骤对话框的父类<br>            super(parent, (BaseStepMeta) baseStepMeta, transMeta, stepname);<br>            input = (HelloworldStepMeta) baseStepMeta;<br>        }<br>在下面的open()方法里创建对话框里的所有控件。SWT使用事件监听模式，可以为控件创建各种监听方法，以响应控件内容的变化和用户的动作。<br>    public String open() {<br>            Shell parent = getParent();<br>            Display display = parent.getDisplay();<br>            shell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MIN<br>                    | SWT.MAX);<br>            props.setLook(shell);<br>            setShellImage(shell, input);<br>            ModifyListener lsMod = new ModifyListener() {<br>                public void modifyText(ModifyEvent e) {<br>                    input.setChanged();<br>                }<br>            };<br>            changed = input.hasChanged();</p>
<p>下面代码说明窗体里的控件将使用formLayout的布局方式：<br>    FormLayout formLayout = new FormLayout();<br>            formLayout.marginWidth = Const.FORM_MARGIN;<br>            formLayout.marginHeight = Const.FORM_MARGIN;<br>            shell.setLayout(formLayout);<br>所有控件的右侧使用一个自定义的百分比对齐：props.getMiddlePct()；控件之间的间距使用一个常量，常量值是4像素。<br>    shell.setLayout(formLayout);<br>            shell.setText(BaseMessages.getString(PKG,<br>                    “HelloworldDialog.Shell.Title”)); //$NON-NLS-1$<br>            int middle = props.getMiddlePct();<br>            int margin = Const.MARGIN;<br>下面的代码在对话框的最上面添加了一行步骤名称标签和输入文本框：<br>    // Stepname line<br>            wlStepname = new Label(shell, SWT.RIGHT);<br>            wlStepname.setText(BaseMessages.getString(PKG,<br>                    “HelloworldDialog.Stepname.Label”)); //$NON-NLS-1$<br>            props.setLook(wlStepname);<br>            fdlStepname = new FormData();<br>            fdlStepname.left = new FormAttachment(0, 0);<br>            fdlStepname.right = new FormAttachment(middle, -margin);<br>            fdlStepname.top = new FormAttachment(0, margin);<br>            wlStepname.setLayoutData(fdlStepname);<br>            wStepname = new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);<br>            wStepname.setText(stepname);<br>            props.setLook(wStepname);<br>            wStepname.addModifyListener(lsMod);<br>            fdStepname = new FormData();<br>            fdStepname.left = new FormAttachment(middle, 0);<br>            fdStepname.top = new FormAttachment(0, margin);<br>            fdStepname.right = new FormAttachment(100, 0);<br>            wStepname.setLayoutData(fdStepname);<br>            Control lastControl = wStepname;</p>
<p>下面是新增输出列的列名设置的输入框：<br>    // Fieldname line<br>        //创建一个新的标签控件，控件里文本靠右对齐<br>        Label wlFieldname = new Label(shell, SWT.RIGHT);<br>        wlFieldname.setText(BaseMessages.getString(PKG,<br>                “HelloworldDialog.Fieldname.Label”)); //$NON-NLS-1$<br>        //下面一行为控件设置用户定义的背景色和字体<br>        props.setLook(wlFieldname);<br>        FormData fdlFieldname = new FormData();<br>        fdlFieldname.left = new FormAttachment(0, 0);<br>        fdlFieldname.right = new FormAttachment(middle, -margin);<br>        fdlFieldname.top = new FormAttachment(lastControl, margin);<br>        wlFieldname.setLayoutData(fdlFieldname);<br>        wFieldname = new TextVar(transMeta, shell, SWT.SINGLE | SWT.LEFT<br>                | SWT.BORDER);<br>        props.setLook(wFieldname);<br>        wFieldname.addModifyListener(lsMod);<br>        FormData fdFieldname = new FormData();<br>        fdFieldname.left = new FormAttachment(middle, 0);<br>        fdFieldname.top = new FormAttachment(lastControl, margin);<br>        fdFieldname.right = new FormAttachment(100, 0);<br>        wFieldname.setLayoutData(fdFieldname);<br>        lastControl = wFieldname;</p>
<p>然后创建两个按钮，“确认”和“取消”按钮，以及按钮单击事件的监听方法，把按钮放在对话框的最下面：<br>    // Some buttons<br>        wOK = new Button(shell, SWT.PUSH);<br>        wOK.setText(BaseMessages.getString(PKG, “System.Button.OK”)); //$NON-NLS-1$<br>        wCancel = new Button(shell, SWT.PUSH);<br>        wCancel.setText(BaseMessages.getString(PKG, “System.Button.Cancel”)); //$NON-NLS-1$</p>
<pre><code>setButtonPositions(new Button[] { wOK, wCancel }, margin, lastControl);

// Add listeners
lsCancel = new Listener() {
    public void handleEvent(Event e) {
        cancel();
    }
};
lsOK = new Listener() {
    public void handleEvent(Event e) {
        ok();
    }
};
wCancel.addListener(SWT.Selection, lsCancel);
wOK.addListener(SWT.Selection, lsOK);
</code></pre><p>下面的代码做了两件事情，上部代码可以保证当步骤名称或输出字段名称的输入框在编辑状态时，单击“确定”按钮，正在编辑的内容不会丢失；下部的代码保证了窗口在非正常关闭时（没有使用“确定”或“取消”按钮关闭），取消用户的编辑。<br>    lsDef = new SelectionAdapter() {<br>            public void widgetDefaultSelected(SelectionEvent e) {<br>                ok();<br>            }<br>        };</p>
<pre><code>wStepname.addSelectionListener(lsDef);
wFieldname.addSelectionListener(lsDef);

// Detect X or ALT-F4 or something that kills this window...
shell.addShellListener(new ShellAdapter() {//保证了窗口在非正常关闭时，取消用户的编辑
    public void shellClosed(ShellEvent e) {
        cancel();
    }
});
</code></pre><p>下面的代码把数据从步骤的元数据对象里复制到窗口的控件里：<br>    // Populate the data of the controls<br>            getData();<br>窗口的大小和位置将根据窗口的自然属性、上次窗口大小和位置，以及显示屏的大小自动设置。<br>    // Set the shell size, based upon previous time…<br>            //窗口的大小和位置将根据窗口的自然属性、上次窗口大小和位置，以及显示屏的大小自动设置<br>            setSize();<br>            input.setChanged(changed);</p>
<pre><code>    shell.open();
    while (!shell.isDisposed()) {
        if (!display.readAndDispatch())
            display.sleep();
    }
    return stepname;
}
</code></pre><p>为了防止用户身控件里输入空值，Kettle提供了一个静态方法来检查空值，ConstNVL();<br>    /**</p>
<pre><code> * Copy information from the meta-data input to the dialog fields.
 */
public void getData() {
    wStepname.selectAll();
    wFieldname.setText(Const.NVL(input.getFieldName(), &quot;&quot;));
}
</code></pre><p>最后，单击OK按钮后，把控件里用户输入的数据都写入到步骤的元数据对象中：<br>    private void cancel() {<br>            stepname = null;<br>            input.setChanged(changed);<br>            dispose();<br>        }<br>        //单击OK把控件里用户输入的数据都写入到步骤的元数据对象中。<br>        private void ok() {<br>            if (Const.isEmpty(wStepname.getText()))<br>                return;</p>
<pre><code>    stepname = wStepname.getText(); // return value

    input.setFieldName(wFieldname.getText());

    dispose();
}
</code></pre><h3 id="StepInteface"><a href="#StepInteface" class="headerlink" title="###StepInteface"></a>###StepInteface</h3><pre><code>这个类实现了org.pentaho.di.trans.step.StepInterface接口，这个类读取上个步骤传来的数据行，利用StepMetaInterface对象里定义的元数据，逐行转换和处理上个步骤传来的数据行，Kettle引擎直接使用这个接口里的很多方法来执行转换过程，但大部分方法都已经由BaseStep类实现了，通常开发人员只需要重载其中的几个方法。
Init():步骤初始化方法，用来初始化一个步骤。初始化结果是一个true或者false的Boolean值。如果你的步骤没有任何初始化的工作，可以不用重载这个方法。
Dispose():如果有需要释放的资源，可以在dispose()方法里释放，例如可以关闭数据库连接、释放文件、清除缓存等。在转换的最后Kettle引擎会调用这个方法。如果没有需要释放或清除的资源，可以不用重载这个方法。
processRow():这个方法，是步骤实现工作的地方。只要这个方法返回true，转换引擎就会重复调用这个方法。
</code></pre><p>下面是HellWorld例子实现的StepInterface接口（HelloworldStep.java）</p>
<p>HelloworldStep.java<br>    package org.kettlesolutions.plugin.step.helloworld;</p>
<pre><code>import org.pentaho.di.core.exception.KettleException;
import org.pentaho.di.core.row.RowDataUtil;
import org.pentaho.di.trans.Trans;
import org.pentaho.di.trans.TransMeta;
import org.pentaho.di.trans.step.BaseStep;
import org.pentaho.di.trans.step.StepDataInterface;
import org.pentaho.di.trans.step.StepInterface;
import org.pentaho.di.trans.step.StepMeta;
import org.pentaho.di.trans.step.StepMetaInterface;
/**
 * BaseStep抽象类已经实现了接口里的很多方法，我们只要覆盖需要修改的方法即可。
 * @author Administrator
 *
 */
public class HelloworldStep extends BaseStep implements StepInterface {
    /**
     * 类的构造函数通常直接把参数传递给BaseStep父类。由父类里的方法来构造对象，然后可以直接
     * 使用类似transMeta这样的对象。
     * @param stepMeta
     * @param stepDataInterface
     * @param copyNr
     * @param transMeta
     * @param trans
     */
    public HelloworldStep(StepMeta stepMeta, StepDataInterface stepDataInterface,
            int copyNr, TransMeta transMeta, Trans trans) {
        super(stepMeta, stepDataInterface, copyNr, transMeta, trans);
        // TODO Auto-generated constructor stub
    }


    public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException {

        HelloworldStepMeta meta  = (HelloworldStepMeta) smi;
        HelloworldStepData data = (HelloworldStepData) sdi;
        /**
         * getRow()方法从上一个步骤获取一行数据。如果没有更多要获取的数据行，这个方法就会返回null。
         * 如果前面的步骤不能及时提供数据，这个方法就会阻塞，直到有可用的数据行。这样这个步骤的速度就会降低，也会影响
         * 其它步骤的速度。
         */
        Object[] row = getRow();
        if (row==null) {
            /**
             * setOutputDone()方法用来通知其它的步骤，本步骤已经没有输出数据行。下一个步骤如果
             * 再调用getRow()方法就会返回null,转换也不再调用processRow()方法。
             */
            setOutputDone();
            return false;
        }

        if (first) {
            first=false;
            /**
             * 从性能上考虑，getRow()方法不提供数据行的元数据，只提供上个步骤输出的数据。可以使用getInputRowMeta()方法
            获取元数据，元数据只获取一次即可，所以在first代码块里获取元数据。
               如果要把数据传到下一个步骤，要使用putRow()方法。除了输出数据，还要输出RowMetaInterface元数据。
               第一行使用clone()方法把输入行的元数据结构复制给输出行。输出行的元数据结构是在输入行的基础上增加一个字段，但
               构造输出行的元数据结构只能构造一次，因为所有输出数据行的结构都是一样的，产生了输出行以后，元数据结构就不能再变化。
               所以输出行的元数据结构在first代码块里构造。first是一个内部成员，first代码块里的代码只在处理第一行数据时执行。
               下面代码的最后一行，给输出数据增加了一个字段。
             */
            data.outputRowMeta = getInputRowMeta().clone();
            meta.getFields(data.outputRowMeta, getStepname(), null, null, this);
        }
        /**
         * 下面的代码，把数据写入输出流。从性能角度考虑，数据行实现就是Java数组。为了开发方便，可以使用RowDataUtil类提供
         * 的一些静态方法来操作数据。使用RowDatautil静态方法复制数据，还可以提高性能。
         */
        String value = &quot;Hello, world!&quot;;

        Object[] outputRow = RowDataUtil.addValueData(row, getInputRowMeta().size(), value);

        putRow(data.outputRowMeta, outputRow);

        return true;
    }
}
</code></pre><p>解析：<br>public class HelloworldStep extends BaseStep implements StepInterface {<br>BaseStep抽象类已经实现了接口里的很多方法，我们只要覆盖需要修改的方法即可。<br>类的构造函数通常直接把参数传递给BaseStep父类。由父类里的方法来构造对象，然后可以直接使用类似transMeta这样的对象。<br>public HelloworldStep(StepMeta stepMeta, StepDataInterface stepDataInterface,<br>            int copyNr, TransMeta transMeta, Trans trans) {<br>        super(stepMeta, stepDataInterface, copyNr, transMeta, trans);<br>    }<br>getRow()方法从上一个步骤获取一行数据。如果没有更多要获取的数据行，这个方法就会返回null。如果前面的步骤不能及时提供数据，这个方法就会阻塞，直到有可用的数据行。这样这个步骤的速度就会降低，也会影响其它步骤的速度。<br>public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException {<br>        HelloworldStepMeta meta  = (HelloworldStepMeta) smi;<br>        HelloworldStepData data = (HelloworldStepData) sdi;<br>        Object[] row = getRow();<br>        if (row==null) {<br>            setOutputDone();<br>            return false;<br>        }</p>
<pre><code>    if (first) {
        first=false;
        data.outputRowMeta = getInputRowMeta().clone();
        meta.getFields(data.outputRowMeta, getStepname(), null, null, this);
    }
    String value = &quot;Hello, world!&quot;;
    Object[] outputRow = RowDataUtil.addValueData(row, getInputRowMeta().size(), value);

    putRow(data.outputRowMeta, outputRow);

    return true;
}
</code></pre><p>从性能上考虑，getRow()方法不提供数据行的元数据，只提供上个步骤输出的数据。可以使用getInputRowMeta()方法获取元数据，元数据只获取一次即可，所以在first代码块里获取元数据。<br>setOutputDone()方法用来通知其它的步骤，本步骤已经没有输出数据行。下一个步骤如果再调用getRow()方法就会返回null,转换也不再调用processRow()方法。</p>
<pre><code>Object[] row = getRow();
        if (row==null) {
            setOutputDone();
            return false;
        }
</code></pre><p>   如果要把数据传到下一个步骤，要使用putRow()方法。除了输出数据，还要输出RowMetaInterface元数据。<br>    data.outputRowMeta = getInputRowMeta().clone();<br>    meta.getFields(data.outputRowMeta, getStepname(), null, null, this);<br>第一行使用clone()方法把输入行的元数据结构复制给输出行。输出行的元数据结构是在输入行的基础上增加一个字段，但构造输出行的元数据结构只能构造一次，因为所有输出数据行的结构都是一样的，产生了输出行以后，元数据结构就不能再变化。所以输出行的元数据结构在first代码块里构造。first是一个内部成员，first代码块里的代码只在处理第一行数据时执行。下面代码的最后一行，给输出数据增加了一个字段。</p>
<p>下面的代码，把数据写入输出流。<br>        String value = “Hello, world!”;<br>        Object[] outputRow = RowDataUtil.addValueData(row, getInputRowMeta().size(), value);<br>        putRow(data.outputRowMeta, outputRow);<br>从性能角度考虑，数据行实现就是Java数组。为了开发方便，可以使用RowDataUtil类提供的一些静态方法来操作数据。使用RowDatautil静态方法复制数据，还可以提高性能。<br>从指定的步骤读取数据行<br>如果你想从前面的某个指定的步骤读取数据行，例如”流查询“步骤，可以使用getRowFrom()方法。<br>       RowSet rowSet = findInputRowSet(Source Step Name);<br>       Object[] rowData = getRowFrom(rowSet);<br>           还可以通过rowSet对象获得数据行的元数据：<br>       RowMetaInterface rowMeta = rowSet.getRowMeta();<br>把数据行写入指定的步骤<br>如果想把数据写入到某个特定的步骤，例如”过滤“步骤，可以使用putRowTo()方法<br>      RowSet rowSet = findOutputRowSet(Target Step Name);<br>      ….<br>      putRowTo(outputRowMeta,rowData,rowSet);<br>很明显，输入和输出的RowSet对象只需获得一次即可，这样才更有效率。<br>把数据行写入到错误处理步骤<br>如果想让你的步骤支持错误处理，而且元数据类返回的supportErrorHandling()方法返回了true，就可以把数据输出<br>      到错误处理步骤里。下面是使用putError()方法的例子：<br>      Object[] rowData = getRow();<br>      …<br>      try{<br>          …<br>          putRow(…);<br>      }catch(Exception e){<br>          if(getStepMeta().isDoingErrorHandling()){<br>              putError(getInputRowMeta(),rowData,errorCode);<br>          }else{<br>              throw(e);<br>          }<br>      }<br>      从例子里可以看到，这段代码把错误的行数、错误字段名、消息、错误编码都传递给错误处理步骤。<br>      错误处理的其他工作都自动完成了。</p>
<h4 id="识别一个步骤拷贝"><a href="#识别一个步骤拷贝" class="headerlink" title="####识别一个步骤拷贝"></a>####识别一个步骤拷贝</h4><p>因为一个步骤可以有多份拷贝同时执行，有时需要识别出正在使用的是哪个步骤拷贝，可以用下面几个方法。<br>     getCopy():获得拷贝号。拷贝号可以唯一标识出步骤的一个拷贝，拷贝号的聚会范围是0-N，N=getStepMeta().getCopies()-1<br>     getUniqueStepNrAcrossSlaves():获得在集群模式下运行的步骤拷贝号。<br>     getUniqueStepCountAcrossSlaves():获得在集群模式下运行的步骤拷贝总数。<br>     通过这些方法可以把一个步骤的工作分配给多份拷贝去完成。例如”CSV文件输入“和”固定文件输入“步骤里都有并行读取文件的选项，这样可以把读取文件的工作放在多个拷贝里或集群里来完成。</p>
<h4 id="结果反馈"><a href="#结果反馈" class="headerlink" title="####结果反馈"></a>####结果反馈</h4><p>在调用getRow()和putRow()方法时，引擎会自动计算两类度量值，读行数和写行数。这两类度量值可以在界面或日志中记录下来，以监控程序运行的状态。下面几个方法用来操作这两类度量值。<br>    incrementLinesRead():增加从前面步骤读取到的行数。<br>    incrementLinesWritten():增加定稿到后面步骤中的行数。<br>    incrementLinesInput():增加从文件、数据库、网络等资源读取到的行数<br>    incrementLinesOutput:增加写入到文件、数据库、网络等资源的行数。<br>    incrementLinesUpdate():增加更新的行数。<br>    incrementLinesSkipped()：增加跳过的数据行的行数。<br>    incrementLinesRejected():增加拒绝的数据行的行数。<br>    这些度量值用来说明步骤执行的情况。可以在Spoon的转换度量面板里看到，也可以存到日志数据库表里。<br>    使用addResultFile()方法，可以把步骤用到的文件保留下来，保存到结果文件列表里。结果文件列表可以被其它转换或作业项使用。例如，下面的”CSV文件输入“的代码：<br>ResultFile resultFile = new ResultFile(<br>    ResultFile.FILE_TYPE_GENERAL,<br>    fileObject,<br>getTransMeta().getName(),<br>getStepName()<br>);<br>resultFile.setComment(“File was read by a Csv Input step”);<br>addREsultFile(resultFile);</p>
<h4 id="变量替换"><a href="#变量替换" class="headerlink" title="####变量替换"></a>####变量替换</h4><pre><code>如果输入框需要支持变量，可以使用environmentSubstritute()方法获取变量。例如，若想在“Hello World”例子的字段名输入框里使用变量，就要把StepMetaInterface里的getFields()方法修改成下面的语句：
</code></pre><p>String realFiledName = apace. environmentSubstritute(fieldName)；<br>因为步骤本身是一个VariableSpace对象，所以也可以使用下面的语句做变量替换：String value = environmentSubstritute(meta.getSringWithVariables());</p>
<h4 id="Apache-VFS"><a href="#Apache-VFS" class="headerlink" title="####Apache VFS"></a>####Apache VFS</h4><p>Kettle里所有操作文件的步骤，都使用Apache VFS系统的方式操作。Apache VFS不但可以从文件系统读取文件（如java.io.File），还可以从很多其他来源读取文件，如FTP服务器、Z学压缩文件，等 等 。<br>Apache VFS里的FileObject对象提供了文件的抽象层，然后在Kettle的KettleVFS类里还提供了一系列的静态方法，来更方便使用FileObject对象，例如下面的代码 ：  </p>
<pre><code>FileObject fileObject = KettleVFS.getFileObject(“zip:http://www.example.com/archive.zip!file.txt”);
</code></pre><p><code>String value = environmentSubstritute(meta.getSringWithVariables());</code></p>
<p>应该尽可能多地使用KettleVFS,因为它解决了或饶过了很多Apache VFS目前已知的问题。它也增强了SFTP协议。</p>
<h4 id="步骤插件部署"><a href="#步骤插件部署" class="headerlink" title="####步骤插件部署"></a>####步骤插件部署</h4><p>部署之前，要把四个Java源代码文件编译为class文件。把编译好的class文件放到一个Jar包里。可以使用IDE来做这些事情，也可以手工使用ant脚本来做这些事情。<br>.jar文件应该放在Kettle的plugins/steps目录下。也可以使用一个子目录，把所有的依赖的jar包放在插件jar包所在目录的/lib目录下，不必再放Kettle的类路径中（Kettle的libext/目录）已经有了的jar包。另外可以把多个插件放在一个jar包里。<br>如果想在IDE里调试插件，可以把插件元数据类的名字放在Kettle_PLUGIN_CLASSES变量里（一个逗号分隔的列表）。关于这个主题的更多信息，请参考pentaho Wiki:<a href="http://wiki.pentaho.com/display/EAI/How+to+debug+a+Kettle+4+plugin" target="_blank" rel="noopener">http://wiki.pentaho.com/display/EAI/How+to+debug+a+Kettle+4+plugin</a> 。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cenrise.com/2017/04/15/kettle/开源ETL工具-kettle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongpo.jia">
      <meta itemprop="description" content="个人博客">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="中起之星">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/15/kettle/开源ETL工具-kettle/" itemprop="url">
                  开源ETL工具-kettle
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-04-15 14:43:49" itemprop="dateCreated datePublished" datetime="2017-04-15T14:43:49+08:00">2017-04-15</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-08-18 09:44:35" itemprop="dateModified" datetime="2017-08-18T09:44:35+08:00">2017-08-18</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/开源项目/" itemprop="url" rel="index"><span itemprop="name">开源项目</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/开源项目/kettle/" itemprop="url" rel="index"><span itemprop="name">kettle</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#开源ETL工具-kettle<br>说明：本文部分内容参考网络的资料，如果侵权之处请告知一下，不胜感激！</p>
<p>Kettle是Pentaho公司开发的一款ETL产品，以工作流为核心，强调面向解决方案而非工具的，基于java平台的商业智能(Business Intelligence,BI)套件。Kettle的开源协议是LGPL，该协议来自GNU，因功能强大，被FSF(Free Software Foundation)列为首选协议。LGPL协议允许Kettle作为商业（非开源）代码的链接库，使用Kettle的商业代码无须开源。LGPL带来的不仅是Kettle API，你还可以对它进行拓展对外提供商业软件或服务。</p>
<h2 id="ETL是什么"><a href="#ETL是什么" class="headerlink" title="##ETL是什么"></a>##ETL是什么</h2><p>ETL早期作为数据仓库的关键环节，负责将分布的、异构数据源中的数据如关系数据、平面数据文件等抽取到临时中间层后进行清洗、转换、集成，最后加载到数据仓库（Data Warehouse）或数据集市（Data Mart）中，成为联机分析处理（On-Line Analytical Processing，OLAP）、数据挖掘（Data Mining）的基础。</p>
<p>Exract：从多种异构数据源中抽取数据</p>
<p>Transform：经过清洗，统一化和转换</p>
<p>Load：将数据加载到目的数据源中</p>
<h2 id="Kettle产品特点"><a href="#Kettle产品特点" class="headerlink" title="##Kettle产品特点"></a>##Kettle产品特点</h2><p>适用于将多个应用系统的大批量的、异构的数据进行整合，有强大的数据转换功能。<br>高效适配多种类型的异构数据库、文件和应用系统。<br>快速构建复杂数据大集中应用、无需编码。</p>
<p>Kettle构成</p>
<p>TODO以Github上的名词进行定义Spoon，Cart等</p>
<p>左边是集成开发工具（Spoon），可以进行流程的开发、配置、调试、部署、执行(转换、任务)，也可以对运行情况进行监控、对处理过程的日志进行查看、也可以通过接口调用方式进行远程管理。</p>
<p>中间是服务器(Carte)，包括实际执行转换和任务的ETL引擎、监控管理的接口、认证授权接口，还有一个可以拓展的接口。</p>
<p>下面是在开发过程中，用于保存集成开发工具中创建的转换、任务、数据库等项的，资源库包含两类，一个是数据库资源库，一个是文件资源库。</p>
<p>右边个是是第三方平台，可以基于kettle提供的接口实现相应的功能包括状态监控、启停控制、日志查看等功能。</p>
<p>组成部分<br>名称<br>描述<br>Spoon<br>一个基于swt开发的流式处理客户端，用户开发转换、任务、创建数据库、集群、分区等<br>Pan<br>一个独立的命令行程序，支持通过命令行实现界面的功能，如果转换启停、任务启停。状态查看等<br>Kitchen<br>一个独立的命令行程序，用于执行由Spoon编辑的作业。<br>Carte<br>Carte是一个轻量级的Web容器，用于建立专用、远程的ETL Server。</p>
<p>PDI相关术语和概念<br>Job(任务)、Transformation(转换)是kettle的两个最重要的概念。任务做的一件完整的事，包含开始、结束等整个生命周期；而转换是要做这件事的某一个小的功能。比如你要从A数据源中解析数据后放入B数据源，那么你可以创建两个转换，一个是从A数据源加载数据-&gt;处理数据-&gt;放入存储中；另一个是把数据放入B数据源，然后在一个任务中处理他们。</p>
<p>下面我们通过集成开发工具去了解一个转换和任务</p>
<p>Transformation（转换）<br>Transformation（转换)是由step(步骤)和hops(节点连接线)组成，一个转换，可以看成一段数据流，每一个步骤完成一项数据处理的工作，节点连接线用于数据的流动。</p>
<p>转换可以单独运行完成某一项工作，文件的扩展名为.ktr</p>
<p>Steps（步骤）<br>Steps（步骤）是转换的重要组件部分，在Spoon中步骤根据功能分为输入类、输出类、脚本类等，每一个步骤完成一种特定的功能，比如excel输出组件，用于把数据流输出为excel文件格式。参考如下：</p>
<p>Hops（节点连接）<br>Hops（节点连接）是数据传输的通道，用于连接两个步骤，使数据从一个步骤传递到另一个步骤，支持分发、复制等方式。注意数据处理的顺序并不是按照节点连接箭头的顺序，因为第个步骤都是单独的线程。</p>
<p>Jobs（工作）<br>Jobs（工作）是基于工作流模型的，顺序处理。把步骤、转换组织在一起完成一件完整的事情。<br>文件扩展名为.kjb</p>
<p>下载使用<br>kettle下载 目前最新版7.0<br><a href="https://sourceforge.net/projects/pentaho/files/Data%20Integration/" target="_blank" rel="noopener">https://sourceforge.net/projects/pentaho/files/Data%20Integration/</a></p>
<p>下载解压后是一个如：pdi-ce-7.0.0.0-25的文件，目录内容如下</p>
<p>windown下直接双拼Spoon.bat、linux下直接运行./spoon.sh即可。<br>注： could not find the main class:org.pentaho.commons.launcher.Launcher. Program will exit. 表示jdk版本错误 。7.0版本只支持jdk1.8，可以单独配置kettle的jdk，添加配置到系统中即可：<br>名称：PENTAHO_JAVA_HOME<br>值：C:\Program Files\Java\jdk1.8.0_45<br>    mac系统下/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/<br>启动后界面如下</p>
<p>新建转换：快捷键Ctrl+N</p>
<p>首先从核心对象区选择“生成记录组件，编辑：</p>
<p>然后选择Excel输出组件到工作区，创建生成记录步骤到Excel输出步骤的连接线，编辑excel输出目录和字段</p>
<p>最后生成如下，点击运行：</p>
<p>运行后的结果是输出excel文件，并可以查看每个步骤的处理情况，读、写、输入、输出等</p>
<p>其它参考链接<br>kettle源码下载，可以选择各个版本下载，自己编译。<br><a href="https://github.com/pentaho/pentaho-kettle" target="_blank" rel="noopener">https://github.com/pentaho/pentaho-kettle</a><br>大数据插件源码<br><a href="https://github.com/pentaho/big-data-plugin" target="_blank" rel="noopener">https://github.com/pentaho/big-data-plugin</a><br>kettle支持的大数据环境源码，主要是hdp,cdh。<br><a href="https://github.com/pentaho/pentaho-hadoop-shims" target="_blank" rel="noopener">https://github.com/pentaho/pentaho-hadoop-shims</a><br>kettle nexus<br><a href="http://repo.pentaho.org/content/groups/omni/pentaho/" target="_blank" rel="noopener">http://repo.pentaho.org/content/groups/omni/pentaho/</a><br><a href="http://repository.pentaho.org/artifactory/repo/" target="_blank" rel="noopener">http://repository.pentaho.org/artifactory/repo/</a><br>所有组件实现说明<br><a href="http://wiki.pentaho.com/display/EAI/Pentaho+Data+Integration+Steps" target="_blank" rel="noopener">http://wiki.pentaho.com/display/EAI/Pentaho+Data+Integration+Steps</a><br>所有组件测试说明<br><a href="http://wiki.pentaho.com/display/EAI/test" target="_blank" rel="noopener">http://wiki.pentaho.com/display/EAI/test</a><br>帮助<br><a href="http://help.pentaho.com/Documentation" target="_blank" rel="noopener">http://help.pentaho.com/Documentation</a> </p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cenrise.com/2017/04/01/oracle/Oracle网络和数据库连接/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongpo.jia">
      <meta itemprop="description" content="个人博客">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="中起之星">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/01/oracle/Oracle网络和数据库连接/" itemprop="url">
                  Oracle网络和数据库连接
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-04-01 15:30:00" itemprop="dateCreated datePublished" datetime="2017-04-01T15:30:00+08:00">2017-04-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-08-18 09:44:35" itemprop="dateModified" datetime="2017-08-18T09:44:35+08:00">2017-08-18</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据库/oracle/" itemprop="url" rel="index"><span itemprop="name">oracle</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>内容来自《Oracle Database 11g 数据库管理艺术》</p>
<h1 id="网络概念：Oracle网络如何工作"><a href="#网络概念：Oracle网络如何工作" class="headerlink" title="网络概念：Oracle网络如何工作"></a>网络概念：Oracle网络如何工作</h1><p>在希望从客户机（不管是传统客户机还是基于浏览器的客户机）打开数据库会话时，需要通过网络连接到数据库。假如要将台式电脑通过现有网络连接到UNIX服务器上的一个Oracle数据库，则需要在电脑和Oracle数据库（它使用专门的软件）之间构造一个连接方法。需要某种界面来处理会话（在此例子中为SQL*Plus），并且需要某种与业内标准的网络协议（如TCP/IP）通信的方法。<br>为方便配置和管理网络连接，Oracle提供了Oracle Net Services，它是一套在分布式异构计算环境中提供连接方案的组件。Oracle Net Services由Oracle Net、Oracle Net Listener、Oracle Connection Manager、Oracle Net Configuration Assistant和Oracle Net Manager组成。Oracle Net Services软件是在Oracle Database Server或Oracle Client软件安装的过程中自动安装的。<br>Oracle Net是一个初始化、建立及维护客户机和服务器之间的连接的组件。这就是为什么必须在客户机和服务器上都安装Oracle Net的原因。Oracle Net主要由两个组件构成。<br>Oracle Network Foundation Layer：负责建立和维护客户机应用程序与服务器之间的连接，以及它们之间的交换信息。<br>Oracle Protocol Support： 负责映射Transparent Net Substrate（TNS）功能到连接使用的业内标准协议。<br>驻留Oracle数据库的所有服务器还运行一个名为Oracle Net Listener（通常也称为监听器）的服务，其主要功能是监听来自客户机服务登录Oracle数据库的请求。监听器在保证客户机服务具有与数据库匹配的信息（协议、端口和实例名）后，将客户机请求传递到数据库。假如用户名和密码通过认证，则数据库将允许客户机登录。一旦监听器把用户请求交付给数据库，客户机和数据库将直接连接，不再需要监听器的帮助。<br>Oracle提供了基于GUI的大量的实用程序，以帮助配置数据库的网络连接。这些实用程序包括Oracle Connection Manager、Oracle Net Manager和Oracle Net Configuragion Assistant等。这些工具帮助处理所有网络需求。在结束本章学习后，可单击这些程序的图标，开始测试连接的实验。  </p>
<h1 id="Web应用如何连接到Oracle数据库"><a href="#Web应用如何连接到Oracle数据库" class="headerlink" title="Web应用如何连接到Oracle数据库"></a>Web应用如何连接到Oracle数据库</h1><p>为了构造Oracle数据库的一个Internet连接，客户机上的Web浏览器要与Web服务器通信并使用HTTP进行连接请求。Web服务器将此请求传递给一个应用，该应用处理收到的请求并用Oracle Net（配置在数据库服务器和客户机上）与Oracle数据库服务器通信<br>    下面介绍Oracle网络中几个关键的术语  </p>
<h2 id="数据库实例名"><a href="#数据库实例名" class="headerlink" title="数据库实例名"></a>数据库实例名</h2><p>正如所知，Oracle实例由SGA和一组Oracle进程组成。数据库实例名在初始化文件（init.ora）中作为INSTANCE_NAME参数给出。在谈到Oracle SID（System identifier，系统标识符）时，指的是Oracle实例。<br>    通常，每个数据库只有一个与其关联的实例。但在Oracle RAC配置中，单个数据库可关联到多个实例。  </p>
<h2 id="全局数据库名"><a href="#全局数据库名" class="headerlink" title="全局数据库名"></a>全局数据库名</h2><p>全局数据库名唯一地标识一个Oracle数据库，其格式为database_name.database_domain，如sales.us.acme.com。在这个全局数据库中，sales为数据库名，us.acme.com为数据库域。因为相同的域中两个数据库不会有相同的数据库名，所以每个全局数据库名都是唯一的。  </p>
<h2 id="数据库服务名"><a href="#数据库服务名" class="headerlink" title="数据库服务名"></a>数据库服务名</h2><p>对于客户机，数据库在逻辑上简单地表现为一个服务。在服务和数据库之间存在一个多对多的关系，因为一个数据库可被一个或多个服务所代表，每个服务都专用于一组不同的客户机，而一个服务可覆盖不止一个数据库实例。我们在自己的系统中用每个数据库的服务名来标识它，用初始化参数SERVICE_NAMES来指定数据库的服务名。服务名参数值默认为全局数据库名。<br>请注意，一个数据库可由多个服务名来访问。如果希望不同的客户机组访问适合于它们的特定需求的不同数据库，应该这样做。例如，可对相同数据库创建如下两个服务名：<br>Sales.us.acme.com<br>Finance.us.acme.com<br>销售人员使用sales.us.acme.com服务名，而财务人员则使用finance.us.acme.com服务名。  </p>
<h2 id="连接描述符"><a href="#连接描述符" class="headerlink" title="连接描述符"></a>连接描述符</h2><p>为了将电脑连接到世界上的任何数据库服务，需要提供两个信息：<br>    数据库服务名；<br>    地址。<br>Oracle使用术语连接描述符(connect descriptor)来表示数据库连接的两个必需的部分：数据库服务名和地址。连接描述符的地址部分包含三个部分，分别是：连接使用的通信协议、主机名和端口号。<br>了解通信协议有助于保证使用合适的网络协议，以便建立连接。标准的协议为TCP/IP或带SSL（Secure Sockets Layer，安全套接层）的TCP/IP。UNIX服务器上的Oracle连接的标准端口为1521或1526.Windows机器上的默认端口为1521.因为任何主机上的数据库具有唯一服务名，所以一个Oracle数据库服务名和一个主机名将唯一地标识任何数据库。下面是一个典型的连接描述符的例子：<br>(DESCRIPTION<br>(ADDRESS=(PROTOCOL=tcp)(HOST=sales-server)(PORT=1521))<br>(CONNECT_DATA=<br>(SERVICE_NAME=sales.us.acme.com)))<br>在此连接描述符中，ADDRESS行指出网络通信将使用TCP协议。HOST指定UNIX（或Windows）服务器，服务器上的Oracle监听器正监听来自端口1521的连接请求。连接描述符的ADDRESS部分也称为协议地址(protocol address)。<br>希望连接数据库的客户机首先连接到Oracle监听器进程。监听器接收到达的请求并把它们交给数据库服务器。一旦客户机和数据库服务器通过监听器的引导连接上，它们就直接通信，在此客户机连接的通信过程中不再需要监听器。  </p>
<h2 id="连接标识符"><a href="#连接标识符" class="headerlink" title="连接标识符"></a>连接标识符</h2><p>连接标识符（connect identifier）与连接描述符紧密关联。可把连接描述符作为连接标识符，或者可简单地映射一个数据库服务名为一个连接描述符。例如，可以把一个服务名(如sales)映射为11.2.5节所看到的连接描述符。下面是说明映射sales连接标识符的例子。<br>Sales=<br>(DESCRIPTION<br>(ADDRESS=(PROTOCOL=tcp)(HOST=sales-server)(PORT=1521))<br>(CONNECT_DATA=<br>(SERVICE_NAME=sales.us.acme.com)))  </p>
<h2 id="连接串"><a href="#连接串" class="headerlink" title="连接串"></a>连接串</h2><p>通过提供一个连接串(connect string)连接到数据库。连接串包含用户名/密码组合及一个连接标识符。最常见的连接标识符之一是节点服务名，它是一个数据库服务的名字。<br>下面的例子给出一个连接串，它把一个完整的连接描述符作为连接标识符<br>    CONNECT scott/tiger@(DESCRIPTION=<br>    (ADDRESS=(PROTOCOL=tcp)<br>    (HOST=sales-server)<br>    (PORT=1521))<br>    (CONNECT_DATA=<br>    (SERVICE_NAME=sales.us.acme.com)))<br>下面是一个更简单的连接到相同数据库的方法，它使用连接标识符sales：<br>    CONNECT scott/tiger@sales<br>上面两个例子都能连接到sales数据库，但显然第二个连接串（使用sales连接标识符）简单得多。  </p>
<h2 id="使用Oracle网络服务工具"><a href="#使用Oracle网络服务工具" class="headerlink" title="使用Oracle网络服务工具"></a>使用Oracle网络服务工具</h2><p>Oracle Net提供了配置客户机与数据库服务之间的连接的几个GUI和命令行工具。最常用的命令行工具是isnrctl实用程序，它帮助管理Oracle监听器服务。下面是帮助管理Oracle Net Servcies的重要GUI工具。<br>Oracle NCA（Net Configuration Assistant，Oracle网络配置助手）。此工具主要用于在安装中配置网络组件，它允许在配置客户机连接的几个选项（本章稍后介绍这些选项）中进行选择。其便于使用的GUI界面使你能在所选择的任何命名方法下快速配置客户机连接。在UNIX/Linux系统上，可通过从$ORACLE_HOME/bin目录执行netca来启动NCA。在Window系统上，选择Start|Programs|Oracle-HOME_NAME|Configuration and Migration Tools|Net ConfigurationAssistant。<br>Oracle网络配置管理器（Oracle Net Manager）。Oracle Net Manager可在客户机和服务器上运行，它允许配置各种命名方法和监听器。利用此工具，可在本地tnsnames.ora文件或在集中式的OID中配置连接描述符，而且可以方便地增加和修改连接方法。<br>为了从Oracle企业管理器控制台启动Oracle Net Manager，选择Tools|Service Management|Oracle Net Manager。为了在Unix上作为独立的应用启动Oracle Net Manager，在ORACLE_HOME/bin目录执行netmgr。在windown上，选择Start|Programs|Oracle-HOME_NAME|Configuration and Migration Tools|NetManager。<br>Oracle企业管理器（Oracle Enterprise Manager）。Oracle Database 11g中的OEM可以完成Oracle Net Manager能完成的所有任务，但不能跨多个文件系统管理多个Oracle主目录。此外，使用OEM可导出目录命名项到tnsnames.ora文件。<br>Oracle目录管理器（Oracle Directory Manager）。这个功能强大的工具允许创建使用OID必需的各种域和环境。用此工具还可以执行密码策略管理及完成许多Oracle高级安全任务。在UNIX/LINUX系统上，可从$ORACLE_HOME/bin目录执行oidadmin来启动OID。在Window系统上，选择Start|Programs|Oracle-HOME_NAME|Integrated Manager Tools|Oracle Directory Manager。  </p>
<h1 id="即时客户机"><a href="#即时客户机" class="headerlink" title="即时客户机"></a>即时客户机</h1><p>之前说过Oracle客户机安装需要经历常规的Oracle数据库服务器软件安排的所有预备步骤。幸而为连接到Oracle数据库并不总是需要安装完整的Oracle客户机软件。Oracle的新Instant Client（即时客户机）软件允许执行应用程序而不必安装标准的Oracle客户机也不必具有ORACLE_HOME。不需要为访问Oracle数据库的每台机器安装Oracle客户机软件。所有现有的OCI、ODBC和JDBC应用程序都可以使用Instan Client。如果愿意，甚至可以用Instant Client使用SQL<em>Plus。<br>    相对于完整的Oracle客户机，Instant Clients提供以下好处：<br>A. 它是免费的；<br>B. 战胜磁盘空间较少<br>C. 安装更快（5分钟左右）<br>D. 不需要CD<br>E. 它具有Oracle客户机的所有特性，如果有必要甚至包括使用SQL</em>Plus。  </p>
<h1 id="安装Instant-Client"><a href="#安装Instant-Client" class="headerlink" title="安装Instant Client"></a>安装Instant Client</h1><p>以下是安装新Instant Client软件并快速连接到Oracle数据库的步骤。<br>(1) 从OTN Web站点下载Instant Client软件。你必须安装基本的客户机程序包，还可以包括其他高级可选的程序包。此程序包含以下内容：<br>    a) Basic：运行OCI、OCCI和JDBC-OCI应用程序所需的文件。<br>    b) SQL<em>Plus：为用Instant Client运行SQL</em>Plus需要的库和可执行文件。<br>    c) JDBC Supplement：另外支持XA、国际化及JDBC下的RowSet操作。<br>    d) ODBC Supplement：启用带Instant Client的ODBC应用的另外的库（仅对Windows）。<br>    e) SDK：用于Instant Client开发Oracle应用程序所需的其他文件。<br>(2) 将选择的程序包解压到某个目录，将些目录命名为instantclient或其它类似的名称。<br>(3) 在UNIX和Linux系统中，将环境变量LD_LIBRARY_PATH设置为instantclient（从而保证此参数的设置与程序包所有所在的目录名匹配）。在Winddows系统上，将环境变量PATH设置为instantclient。<br>(4) 测试对Oracle服务器的连接。  </p>
<h1 id="监听器和连接"><a href="#监听器和连接" class="headerlink" title="监听器和连接"></a>监听器和连接</h1><p>Oracle监听器是一个只运行在服务器上并监听连接请求的服务。Oracle提供一个名为lsnrctl的实用程序来管理监听器进程。以下是监听器如何配合Oracle网络的概述。<br>a. 数据库用监听器记录关于服务、实例及服务处理器的信息<br>b. 客户机与监听器进行初步连接<br>c. 监听器接收和验证客户机连接请求并把此请求交给数据库服务的服务处理器。一旦交付了客户机请求，监听器在该连接中不再起作用。<br>Listener.ora文件默认位置在UNIX系统上为$ORACLE_HOME/network/admin目录，在Windows系统上为$ORACLE_HOME\network\admin目录，它包含监听器的配置信息。因为监听器服务只运行在服务器上，因此在客户机上没有listener.ora文件。代码清单11-1给出了一个典型的listener.ora文件。<br>Listener中的所有配置参数都具有默认值，不需要手动配置监听器服务。在服务器上创建了第一个数据库后，监听器服务自动启动，并且将监听器配置文件listener.ora放于默认目录中。新数据库创建后，数据库的网络和服务信息自动添加到监听器的配置文件中。实例启动后，数据库自动向监听器注册，并且监听器开始监听对此数据库的连接请求。<br>代码清单11-1 典型的监听器配置文件<br>代码清单11-1 典型的监听器配置文件   </p>
<pre><code>#LISTENRE.ORA Network Configuration file 
/u01/app/oracle/product/11.1.0.6.0/db_1/network/admin/listener.ora
SID_LIST_LISTENER = 
(DESCRIPTION_LIST =
    (DESCRIPTION = 
          (ADDRESS_LIST = 
            (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC4))
        )
        (ADDRESS_LIST = 
            (ADDRESS = (PROTOCOL = TCP)(HOST = NTL-ALAPATISAM)(PORT = 1521))
        )
    )
)
SID_LIST_LISTENER = 
    (SID_LIST = 
    (SID_DESC = 
        (SID_NAME = PLSExtProc)
        (ORACLE_HOME = /u01/app/oracle/product/11.1.0/db_1)
        (PROGRAM = extproc)
    )
    (SID_DESC = 
        (GLOBAL_DBNAME = remorse.world)
        (ORACLE_HOME = /u01/app/oracle/product/11.1.0/db_1)
        (SID_NAME = remorse)
    )
    (SID_DESC = 
        (GLOBAL_DBNAME = finance.world)
        (ORACLE_HOME = /u01/app/oracle/product/11.1.0/db_1)
        (SID_NAME = finance)
    )
)
</code></pre><h2 id="自动服务注册"><a href="#自动服务注册" class="headerlink" title="自动服务注册"></a>自动服务注册</h2><p>Oracle PMON进程负责向监听器动态服务注册新Oracle数据库服务名，也就是说，在创建新Oracle数据库时，它们将自动向监听器服务注册。PMON进程将在每个新数据库在服务器上创建之后更新listener.ora文件。<br>为自动服务注册，ini.ora文件或SPFILE应该包含如下参数：<br>a. SERVICE_NAMES(如sales.us.oracle.com)<br>b. INSTANCE_NAME(如sales)<br>如果不指定SERVICE_NAMES参数的值，它默认为全局数据库名，全局数据库名是DB_NAME和DB_DOMAIN参数的组合。INSTANCE_NAME参数的默认值为Oracle安装或数据库创建时输入的SID。<br>可使用lsnrctl实用程序查看服务器上监听器的状态，如代码清单11-2所示。相应的输出说明监听器启动了多长时间，监听器服务的配置文件位于何处。它还给出监听器为连接请求而监听的数据库的名称。<br>代码清单11-2 使用lsnrctl实用程序查看监听器的状态<br>$ lsnrctl status  </p>
<p>在代码清单11-2的Services Summary部分，相应的状态可具有如下的某个值。<br>a. READY：此实例可接受连接<br>b. BLOCKED：此实例不能接受连接<br>c. UNKNOWN：此实例在listener.ora文件中注册而不是通过动态服务注册，因而不知道其状态  </p>
<h2 id="监听器命令"><a href="#监听器命令" class="headerlink" title="监听器命令"></a>监听器命令</h2><p>在调用lsnrctl实用程序后，除了status命令外还可以执行其他一些重要的命令。例如，service命令允许查看监听器正为连接请求而监控的是什么服务。<br>注解：还可以从Oracle企业管理器的Net Services Administration页面查看监听器服务的状态。<br>代码清单11-2 使用lsnrctl help列出lsnrctl命令<br>$lsnrctl help<br>可以调用lsnrctl实用程序后，使用start命令启动监听器，使用stop命令停业监听器。如果希望从操作系统命令行发布这些命令，可使用lsnrctl start和lsnrctl stop命令执行这两个任务。<br>如果对listener.ora文件做了更改，为使更改起作用的一种方法是重启监听器。另一种安全的方法是重新装载监听信息，包括对监听器配置文件所做的最新更改。Lsnrctl reload命令允许在运行中重新装载监听器，而不用重新启动它。在监听器重装载（甚至是重启）的过程中，当前连接的客户机将继续保持连接，因为监听器已经将连接“交付”给数据库，在客户和数据库服务之间不起作用。<br>注意：我的忠告是，如非绝对有必要，不要修改listener.ora文件，而且对于动态自动服务注册，几乎没有必要修改此文件。不过，有时可能需要修改监听器文件的某些部分，此文件由监听器监控连接请求的所有服务的网络配置信息组成。  </p>
<h2 id="命名和连接"><a href="#命名和连接" class="headerlink" title="命名和连接"></a>命名和连接</h2><p>在前面连接描述符和连接标识符的例子中，使用sales连接标识符来连接sales服务。连接标识符可以是连接描述符本身，也可以是一个能解析为连接描述符的简单名字(如sales)。一般使用的简单连接标识符称为net service name(网络服务名)。因此前面例子中的sales连接标识符就是一个net service name。<br>因为每次进行连接时都需要提供一下完整的连接描述符非常令人厌烦，使用网络服务名是明智的。但这需要维护网络服务名和连接描述信息之间所有映射的一个中心信息库(central repository)，以便Oracle验证这些网络服务名。因此，在一个用户使用网络服务名sales启动连接进程时，Oracle将搜索中心信息库查找sales的连接描述符。找到连接描述符后，Oracle Net会为指定服务器上的数据库初始化一个连接。<br>Oracle允许几种类型的命名信息库，可用下列4种命名方法访问存储在这些位置中的映射信息。<br>a. 本地命令(local naming )：使用存储在每个客户机上的名为tnsnames.ora的文件连接到数据库服务器。<br>b. 简易连接命名(easy connect naming)：允许连接而无需任何服务名配置。<br>c. 外部命名(external naming)：使用第三方命名服务来解析服务名。<br>d. 目录命令(directory naming)：使用一个集中式的符合LDAP的目录服务器来解析服务名。<br>    不管使用何种命名方法，名字解析过程都是相同的。每种命名法都遵循以下步骤将连接描述符解析为网络服务名：<br>i. 选择命令方法—本地、简易连接、外部命名或目录服务命名<br>ii. 映射连接描述符到服务名；<br>iii. 配置客户机以使用步骤1中选择的命名方法  </p>
<h2 id="本地命名方法"><a href="#本地命名方法" class="headerlink" title="本地命名方法"></a>本地命名方法</h2><p>本地命令是建立Oracle连接最简单、最容易的方法。使用这种方法，在名为tnsnames.ora的本地化配置文件中存储服务名及其连接描述符。此文件默认存储在$ORACLE_HOME/network/admin目录中。  </p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cenrise.com/2017/01/01/算法/常用算法概述/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongpo.jia">
      <meta itemprop="description" content="个人博客">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="中起之星">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/01/算法/常用算法概述/" itemprop="url">
                  TODO-常用算法概述
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-01-01 00:00:00" itemprop="dateCreated datePublished" datetime="2017-01-01T00:00:00+08:00">2017-01-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-08-18 09:44:35" itemprop="dateModified" datetime="2017-08-18T09:44:35+08:00">2017-08-18</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/软件工程/" itemprop="url" rel="index"><span itemprop="name">软件工程</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/软件工程/算法/" itemprop="url" rel="index"><span itemprop="name">算法</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#工作内容指导</p>
<p>#安全小组工作范围</p>
<p>#关注的领域</p>
<p>#分类</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cenrise.com/2017/01/01/oracle/Oracle SQL优化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongpo.jia">
      <meta itemprop="description" content="个人博客">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="中起之星">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/01/oracle/Oracle SQL优化/" itemprop="url">
                  TODO-Oracle SQL优化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-01-01 00:00:00" itemprop="dateCreated datePublished" datetime="2017-01-01T00:00:00+08:00">2017-01-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-08-18 09:44:35" itemprop="dateModified" datetime="2017-08-18T09:44:35+08:00">2017-08-18</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据库/oracle/" itemprop="url" rel="index"><span itemprop="name">oracle</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cenrise.com/2017/01/01/oracle/Oracle数据库系统架构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongpo.jia">
      <meta itemprop="description" content="个人博客">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="中起之星">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/01/oracle/Oracle数据库系统架构/" itemprop="url">
                  TODO-Oracle数据库系统架构
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-01-01 00:00:00" itemprop="dateCreated datePublished" datetime="2017-01-01T00:00:00+08:00">2017-01-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-08-18 09:44:35" itemprop="dateModified" datetime="2017-08-18T09:44:35+08:00">2017-08-18</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据库/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据库/oracle/" itemprop="url" rel="index"><span itemprop="name">oracle</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cenrise.com/2017/01/01/网络安全/企业安全组/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongpo.jia">
      <meta itemprop="description" content="个人博客">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="中起之星">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/01/网络安全/企业安全组/" itemprop="url">
                  TODO-企业安全组
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-01-01 00:00:00" itemprop="dateCreated datePublished" datetime="2017-01-01T00:00:00+08:00">2017-01-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-08-18 09:44:35" itemprop="dateModified" datetime="2017-08-18T09:44:35+08:00">2017-08-18</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/网络安全/" itemprop="url" rel="index"><span itemprop="name">网络安全</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/网络安全/安全小组/" itemprop="url" rel="index"><span itemprop="name">安全小组</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#工作内容指导</p>
<p>#安全小组工作范围</p>
<p>#关注的领域</p>
<p>#分类</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="dongpo.jia" />
            
              <p class="site-author-name" itemprop="name">dongpo.jia</p>
              <p class="site-description motion-element" itemprop="description">个人博客</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">49</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">43</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">40</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dongpo.jia</span>

  

  
</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.2.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.2.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.2.0"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
