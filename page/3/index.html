<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.2.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=6.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=6.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.2.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="中起之星">
<meta property="og:url" content="http://cenrise.com/page/3/index.html">
<meta property="og:site_name" content="中起之星">
<meta property="og:description" content="个人博客">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="中起之星">
<meta name="twitter:description" content="个人博客">






  <link rel="canonical" href="http://cenrise.com/page/3/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>中起之星</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">中起之星</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">Cenrise</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cenrise.com/2017/04/18/Markdown基础入门/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongpo.jia">
      <meta itemprop="description" content="个人博客">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="中起之星">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/18/Markdown基础入门/" itemprop="url">
                  Markdown基础入门
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-04-18 15:00:00" itemprop="dateCreated datePublished" datetime="2017-04-18T15:00:00+08:00">2017-04-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-08-18 09:44:35" itemprop="dateModified" datetime="2017-08-18T09:44:35+08:00">2017-08-18</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/markdown/" itemprop="url" rel="index"><span itemprop="name">markdown</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Markdown 的目标是实现「易读易写」。</p>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>实现表格的两种方式<br>方式一：当某项过长时，表格可能如下显示，不好看。<br>具体使用方式请看示例。<br>•    ——: 为右对齐。<br>•    :—— 为左对齐。<br>•    :——: 为居中对齐。<br>•    ——- 为使用默认居中对齐。<br>1.9.2 示例<br>|         属性项               |                    属性说明<br>|    ——: |    :——-:    |    :———   |    ——    |<br>|    组件名称    |    步骤的名字，这个名字在一个转换中必须是唯一的。    |<br>|    字段    |    指定字段名和排序方向(升序/降序);点击获取字段检索列表字段从输入流    |<br>|字段|指定排序的字段名。|<br>|升序|排序原则：升序或降序。如果选择升序，排序顺序将是：数字-&gt;英文-&gt;汉字，汉字是按照拼音排序的，也同样会按照声调排序。如果是多音字，只会取一个读音，无法根据语境判断其的读音。|</p>
<p>显示如下：  </p>
<p>注意  </p>
<ol>
<li>每个Markdown解析器都不一样，可能左右居中对齐方式的表示方式不一样。  </li>
</ol>
<p>方式二：表格形式（推荐）    </p>
<p><code>&lt;table&gt;
    &lt;tr&gt;  
        &lt;th&gt;属性项&lt;/th&gt;  
        &lt;th&gt;属性说明&lt;/th&gt;  
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;组件名称&lt;/td&gt;
        &lt;td&gt;步骤的名字，这个名字在一个转换中必须是唯一的。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;字段&lt;/td&gt;
        &lt;td&gt;指定字段名和排序方向(升序/降序);点击获取字段检索列表字段从输入流。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;字段&lt;/td&gt;
        &lt;td&gt;指定排序的字段名。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;升序&lt;/td&gt;
        &lt;td&gt;排序原则：升序或降序。如果选择升序，    
        排序顺序将是：数字-&gt;英文-&gt;汉字，汉字是按照拼音排序的，    
        也同样会按照声调排序。如果是多音字，只会取一个读音，    
        无法根据语境判断其的读音。&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;</code><br>输出如下：  </p>
<table><br>    <tr><br>        <th>属性项</th><br>        <th>属性说明</th><br>    </tr><br>    <tr><br>        <td>组件名称</td><br>        <td>步骤的名字，这个名字在一个转换中必须是唯一的。</td><br>    </tr><br>    <tr><br>        <td>字段</td><br>        <td>指定字段名和排序方向(升序/降序);</td><br>    </tr><br>    <tr><br>        <td>字段</td><br>        <td>指定排序的字段名。</td><br>    </tr><br>    <tr><br>        <td>升序</td><br>        <td>排序原则：升序或降序。如果选择升<br>    </td></tr><br></table>




<h2 id="首行缩进"><a href="#首行缩进" class="headerlink" title="首行缩进"></a>首行缩进</h2><p>由于markdown语法主要考虑的是英文，所以对于中文的首行缩进并不太友好，两种方法都可以完美解决这个问题。</p>
<ul>
<li>把输入法由半角改为全角。 两次空格之后就能够有两个汉字的缩进。  </li>
</ul>
<ul>
<li>在开头的时候，先输入下面的代码，然后紧跟着输入文本即可。分号也不要掉。   </li>
</ul>
<p>直接写<br>半方大的空白<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">全方大的空白```&amp;emsp;```或```&amp;#8195;```  </span><br><span class="line">不断行的空白格```&amp;nbsp;```或```&amp;#160;</span><br></pre></td></tr></table></figure></p>
<p>做为显示时这几个转义不能单独写，要在前后添加<code>`</code></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cenrise.com/2017/04/18/java/JDK源码分析之集合框架HashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongpo.jia">
      <meta itemprop="description" content="个人博客">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="中起之星">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/18/java/JDK源码分析之集合框架HashMap/" itemprop="url">
                  JDK源码分析之集合框架HashMap
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-04-18 10:00:00" itemprop="dateCreated datePublished" datetime="2017-04-18T10:00:00+08:00">2017-04-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-08-18 09:44:35" itemprop="dateModified" datetime="2017-08-18T09:44:35+08:00">2017-08-18</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/jdk源码/" itemprop="url" rel="index"><span itemprop="name">jdk源码</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#JDK源码分析之集合框架HashMap</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cenrise.com/2017/04/18/spring/Spring源码分析之环境准备/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongpo.jia">
      <meta itemprop="description" content="个人博客">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="中起之星">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/18/spring/Spring源码分析之环境准备/" itemprop="url">
                  Spring源码分析之环境准备
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-04-18 10:00:00" itemprop="dateCreated datePublished" datetime="2017-04-18T10:00:00+08:00">2017-04-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-08-18 09:44:35" itemprop="dateModified" datetime="2017-08-18T09:44:35+08:00">2017-08-18</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/开源项目/" itemprop="url" rel="index"><span itemprop="name">开源项目</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/开源项目/spring/" itemprop="url" rel="index"><span itemprop="name">spring</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#Spring源码分析之环境准备</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cenrise.com/2017/04/16/hadoop/Hadoop之流式计算/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongpo.jia">
      <meta itemprop="description" content="个人博客">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="中起之星">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/16/hadoop/Hadoop之流式计算/" itemprop="url">
                  流式计算
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-04-16 23:43:49" itemprop="dateCreated datePublished" datetime="2017-04-16T23:43:49+08:00">2017-04-16</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-08-18 09:44:35" itemprop="dateModified" datetime="2017-08-18T09:44:35+08:00">2017-08-18</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/大数据/" itemprop="url" rel="index"><span itemprop="name">大数据</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/大数据/流式计算/" itemprop="url" rel="index"><span itemprop="name">流式计算</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>MapRecue及其扩展解决了离线批处理问题，但是无法保证实时性。对于实时性要求高的场景，可以采用流式计算或者实时分析系统进行处理。<br>流式计算（Stream Processing）解决在线聚合（Online Aggregation）、在线过滤（Online Filter）等问题，流式计算同时具有存储系统和计算系统的特点，经常应用在一些类似于反作弊、交易异常监控等场景。流式计算的操作算子和时间相关，处理最近一段时间窗口内的数据。</p>
<p>#原理<br>流式计算强调的是数据流的实时性。MapRecue系统主要解决的是对静态数据的批量处理，当MapRecue作业启动时，已经准备好了输入数据，比如保存在分布式文件系统上。而流式计算系统在启动时，输入数据一般并没有完全到位，而是经由外部数据流源源不断地流入。另外，流式计算并不像批处理系统那样，重视数据处理的总吞吐量，而是更加重视对数据处理的延迟。<br>MapRecue及其扩展采用的是一种比较静态的模型，如果用它来做数据流的处理，首先需要将数据流缓存并分块，然后放入集群计算。如果MapRecue每次处理的数据量较小，缓存数据流的时间较短，但是，MapRecue框架造成的额外开销将会占用很大比重；如果MapRecue每次处理的数据量较大，缓存数据流的时间会很长，无法满足实时性的要求。</p>
<p>#Yahoo S4</p>
<p>#Twitter Stoorm</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cenrise.com/2017/04/16/hadoop/Apache Spark与Apache Hadoop的关系/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongpo.jia">
      <meta itemprop="description" content="个人博客">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="中起之星">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/16/hadoop/Apache Spark与Apache Hadoop的关系/" itemprop="url">
                  Apache Spark与Apache Hadoop的关系
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-04-16 23:43:49" itemprop="dateCreated datePublished" datetime="2017-04-16T23:43:49+08:00">2017-04-16</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-08-18 09:44:35" itemprop="dateModified" datetime="2017-08-18T09:44:35+08:00">2017-08-18</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/大数据/" itemprop="url" rel="index"><span itemprop="name">大数据</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/大数据/hadoop/" itemprop="url" rel="index"><span itemprop="name">hadoop</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>数据采集<br>本文主要是讲外部系统与Hadoop之间的数据传递，包括从外部系统采集数据导入到hadoop，以及从Hadoop中提取数据导入外部系统中。</p>
<p>#数据采集考量<br>虽然Hadoop提出了文件客户端，便于在Hadoop中和Hadoop外复制文件，但是大多数据 Hadoop应用需要从不同来源导入数据，而且对不同的导入频率也提出了要求，Hadoop常用的数据来源包括以下：<br>1.传统数据管理系统，如果关系型数据库与主机<br>2.日志、机器生成的数据，以及其他类型的事件数据。<br>3.从现有的企业数据存储中输入的文件。</p>
<p>将数据从不同的系统输入Hadoop时需要考虑很多因素。如下：<br>1.数据采集的时效性与可访问性<br>需要采集数据在采集频率方面有哪些要求？下游的处理要求数据多长时间准备完毕？</p>
<p>2.增量更新<br>如何添加新数据？需要将数据添加到现有数据库吗？需要重写现有数据吗？</p>
<p>3.数据访问和处理<br>数据会用于处理过程吗？如果会，数据会用于批处理任务吗？需要的数据是不是随机获取的？</p>
<p>4.数据分区及数据分片<br>数据采集后应该如何分区？需要将数据导入到多个目录系统（如HDFS与HBase）吗？</p>
<p>5.数据存储格式<br>数据存储的格式是哪一种？</p>
<p>6.数据变换<br>需要变换尚未落地的数据吗？</p>
<p>下面简单列举一下这几点考量？</p>
<p>##1.数据采集的时效性<br>这里的时效性是指可进行数据采集的时间与Hadoop中工具可访问数据的时间之间的间隔。采集架构的时间分类会对存储媒介和采集方法造成很大的影响。一般来说数据采集构架，可以使用以下分类中的一个<br>a.大型批处理<br>通常指15分钟到数据小时的任务，有时可能指时间跨度达到一天的任务</p>
<p>b.小型批处理<br>通常指大约2分钟发送一次任务，但是总的来说不会超过15分钟</p>
<p>c.近实时决策支持<br>指接受信息后“立即作出反应”，并在2秒到2分钟内发送数据</p>
<p>d.近实时事件处理<br>指在2秒内处理任务，速度可达到100毫秒</p>
<p>e.实时<br>这里指不超过100毫秒</p>
<p>可以注意到随着实现时间到达实时，实现的复杂度和成本会大大增加。从批处理出发（比如使用简单文件传输）通常是个不错的选择。HDFS对时效性的要求比较宽松，所以可能更加适合成为主要存储位置。而一个简单文件传输或Sqoop任务则适合作为采集数据的工具。比如，执行hadoop fs -put命令将复制一个文件，并进行全面的校验，以确定正确地复制数据。<br>使用hadoop fs -put命令与Sqoop时，你需要明白一点：HDFS上的数据存储格式可能并不适合数据的长期存储和处理。因此，在使用这些工具的时候，可能需要通过额外的批处理操作，以将数据存储为需要的格式。<br>当用户需要从简单的批处理转向更高频率的更新时，就应该考虑Flume或kafka之类的工具了。这里时间要求不起过2分钟，所以Sqoop与文件转换器不适用。而且，因为要求时间不起过2分钟，所以存储层可能需要变成HBase或Solr，这样插入与读取操作会获得更细的粒度。当要求到实时水平时，我们首先需要考虑内存，然后是永久性存储。全世界所有的平行化处理都不会有助于将反应要求控制在500毫秒以内，只要硬盘驱动器保持处理操作的状态。基于这一点，我们开始进入流处理领域，采用Storm或Spark Streaming之类的工具。这里需要强调的是，这些工具应该真正用于大数据处理，而不是像Flume或Sqoop那样用于数据采集。</p>
<p>##2.增量更新<br>新的数据是要添加到已有数据集中，还是要修改已有数据集。如果仅要求添加数据，那么HDFS对于大部分实现都很适用。HDFS能够并行 化多个驱动器的I/O操作，所以读写性能很高。HDFS的缺点是无法添加或者随机写入创建后的文件。</p>
<p>#数据采集的选择</p>
<p>##1.文件传输<br>将数据导入导出到Hadoop最简单的方法就是文件传输，就是hadoop fs -put与hadoop fs -get命令。这有时也是最快的方法，所以在设计Hadoop新的数据处理流水线时，首先应该考虑选择文件传输。</p>
<p>下面列一下文件传输的特点：<br>a.这是一种all-or-nothing批处理方法，所以如果文件传输过程中出现错误，则不会写入或读取任何数据。这种方法与Flume、Kafka之类的采集方法不同，后者提供一定程度的错误处理功能，并且有传输保障。<br>b.文件传输默认为单线程，不能并行 文件传输。<br>c.文件传输将文件从传统的文件系统导入HDFS<br>d.不支持数据转换，数据按原样导入HDFS。数据导入HDFS后才能进行处理，这一点与传输过程中的数据转换截然相反。类似于Flume的系统支持传输过程中的数据转换。<br>e.这种加载是逐字进行的，所以能传输任何类型的文件（文件、二进制、图书等）</p>
<p>##文件传输与其他采集方法的考量<br>简单文件传输在某些情况下是适用的，尤其是在需要将已存在 的一系列文件输入到HDFS中，而且可以接受保持源文件格式的情况下。否则，在决定是否可以接受文件传输或者是否使用类似于Flume的工具时，需要考虑以下因素。<br>a.需要将数据采集到多个位置吗？比如，是需要将数据同时输入HDFS和Solr，还是需要将数据同时输入HDFS和HBase？这种情况下，如果使用文件传输，那么在文件采集完成之后将需要额外的工作，因些采用Flume更合适。<br>b.对可靠性的要求高不高？如果高，那么一旦传输时出现错误，文件传输就必须重新开始，这时，Fluem同样是更好的选择。<br>e.数据采集之前需要转换操作吗？如果需要Flume无疑是适合的工具。<br>如果需要采集文件，可以考虑使用Flume Spooling  Directory源。采用这种方法，用户将文件放置到磁盘特定的目录就可以采集文件。这种采集文件的方法简单可靠，而且需要时能够实现传输过程中的数据转换。</p>
<p>##Sqoop：Hadoop与关系数据库的批量传输<br>Sqoop是一种工具，能批量地将数据从关系型数据管理系统导出到Hadoop中，也能批量地将数据从Hadoop导出至关系型数据库中。</p>
<p>Flume:基于事件的数据收集及处理<br>Flume是一种分布式的可靠开源系统，用于流数据的高效收集、聚焦和移动。Flume通常用于移动日志数据，但是也能移动大量事件数据，如社交媒体订阅、消息队列事件或网络流量数据。</p>
<p>##Kafka<br>Apache Kafka是一种发布订单消息的分布式系统，能够将消息归类为不同主题。应用程序能在Kafka上发布信息，或订阅主题进而接受特定主要下发布的消息。Producer发布消息，而Consumer收集并处理消息。作为分布式系统，Kafka在集群中运行，每个节点被称为Broker。<br>Kafka维护每个主题的分区日志。消息会发布到相应的主题中，每个分区都是一个有序的消息子集。同一个主题的多个分区能够通过集群中的多个Broker传送，这种方法提高了主题的容量与吞吐量，使其超越了单一机器所能提供的容量与吞吐量。消息在分区内被有序排列，每个消息都包含一个特定的偏移量。Kafka中消息可以通过一个包含主题、分区以及偏移量的组合来确定。Producer能够根据消息的主键选择消息应该写入哪一个分区，也能够简单地用循环的方式，让消息分布在各分区之间。<br>Consumer会在Consumer组中注册，每个组包括一个或多个Consumer，每个Consumer读取一个或多个主题分区。每组中的每条消息只能传送给一个Consumer。但是，如果多个组订阅了同一个主题，那么每个组都将得到所有的消息。一个组中包含多个Consumer有助于获得加载平衡（可以支持高于单个Consumer处理能力的吞吐量）与高可用性（如果一个Consumer出现错误，它所读取的分区将重新分配给组中其它Consumer）。<br>前面提到，对于应用层面的数据分类，主要单位是主题。一个Consumer或Consumer组将读取其订阅主题的所有数据，所以如果一个应用只关注一个数据子集，那么就应该将该数据子集与其他数据放在两个不同的主题中。如果多个信息集总是一起读取和处理，那么应该将它们归在同一个主题中。</p>
<p>#数据导出<br>数据导出的思路与导入类似。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cenrise.com/2017/04/16/hadoop/Kylin入门概念/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongpo.jia">
      <meta itemprop="description" content="个人博客">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="中起之星">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/16/hadoop/Kylin入门概念/" itemprop="url">
                  Kylin入门概念
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-04-16 23:43:49" itemprop="dateCreated datePublished" datetime="2017-04-16T23:43:49+08:00">2017-04-16</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-08-18 09:44:35" itemprop="dateModified" datetime="2017-08-18T09:44:35+08:00">2017-08-18</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/大数据/" itemprop="url" rel="index"><span itemprop="name">大数据</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/大数据/kylin/" itemprop="url" rel="index"><span itemprop="name">kylin</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#Apache Kylin的工作原理<br>Apache Kylin的工作原理本质上是MOLAP（Multidimensional　Online　Analytical　Processing）Cube，也就是多维　立方体分析。这是数据分析中相当经典的理论，在关系数据库年代就已经有了广泛的应用，下面将其做简要的介绍。  </p>
<p>##维度和度量<br>简单来讲，维度就是观察数据的角度。比如电商的销售数据，可以从时间的维度来观察，也可以进一步细化，从时间和地区的维度来观察。维度一般是一组离散的值，比如时间维度上的每一个独立的日期，或者商品维度上的每一件独立的商品。因此统计时可以把维度值 相同的记录聚合在一起，然后应用聚合函数做累加、平均、去重计数等聚合计算。  <img src="/images/hadoop/kylin/维度和度量的例子.jpg" alt="&quot;维度和度量的例子&quot;"></p>
<p>度量就是被聚合的统计值，也是聚合运算的结果，它一般是连续的值，如图1-2中的销售额，抑或是销售商品的总件数据 。通过比较和测量试题，分析师可以对数据进行评估，比如今年的销售额相比去年有多大的增长，增长的速度是否达到预期，不同商品类别的增长比例是否合理等。  </p>
<p>##Cube和Cuboid<br>有了维度和度量，一个数据表或数据模型上的所有字段就可以分类了，它们要么是维度，要么是度量（可以被聚合）。于是就有了根据维度和度量来做预计算的Cube理论。<br>给定一个数据模型，我们可以对其上的所有维度进行组合。对于N个维度来说，组合的所有可能共2的n次方种。对于每一种维度的组合，将度量做聚合运算，然后将运算的结果保存为一个物化视图，称为Cuboid。所有维度组合的Coboid作为一个整体，被称为Cube。所以简单来说一个Cube就是许多按维度聚合的物化视图的集合。<br>下面来举一个具体的例子。假定有一个电商的销售数据集，其中维度包括时间（Time）、商品（Item）、地点（Location）和供应商（Supplier），度量为销售额（GMV）。那么所有维度的组合就有2的4次方=16种，比如一维度（ID）的组合有[Time]、[Item]、[Location]、[Supplier]4种；二维度（3D）的组合有[Time,Item]、[Time，Location]、[Time,Supplier]、[Item,Location]、[Item,Supplier]、[Location,Supplier]6种；三维度（3D）的组合也有4种；最后零维度（0D）和四维度（4D）的组合各有1种，总共有16种组合。<br><img src="/images/hadoop/kylin/一个四维Cube的例子.jpg" alt="&quot;一个四维Cube的例子&quot;"></p>
<p>计算Cuboid，即按维度来聚合销售额。如果用SQL语句来表达计算Cuboid[Time,Location]，那么SQL语句如下：<br>Select Time,Location,Sum(GMV) as GMV from Sales group by Time,Location.<br>将计算的结果保存为物化视图，所有Cuboid物化视图的总称是Cube。</p>
<p>##工作原理<br>Apache Kylin的工作原理就是对数据模型做Cube预计算，并利用计算的结果加速查询，具体工作过程如下：<br>1）指定数据模型，定义维度和度量<br>2）预计算Cube，计算所有Cuboid并保存为物化视图。<br>3）执行查询时，读取Cuboid，运算，产生查询结果。<br>由于Kylin的查询过程不会扫描原始记录，而是通过预计算预先完成表的关联、聚合等复杂运算，并利用预计算的结果来执行查询，因此相比非预计算的查询技术，其速度一般要快一到两个数据级，并且这点在超磊的数据集上优势更加明显。当数据集达到千亿及至万亿级别时，Kylin的速度甚至可以超越其他非预计算技术1000倍以上。</p>
<p>#技术架构<br>Apache Kylin系统可以分为在线查询和离线构建两部分，技术架构如下图所示，在线查询的模块主要处于上半区，而离线构建则处于下半区。<br><img src="/images/hadoop/kylin/Kylin的技术架构.jpg" alt="&quot;Kylin的技术架构&quot;">    </p>
<p>我们首先看看离线构建的部分。从图1-4可以看出，数据源在左侧，目前主要是Hadoop Hive，保存着待分析的用户数据。根据元数据的字义，下方构建引擎从数据源抽取数据，并构建Cube。数据以关系表的形式输入，且必须符合星形模型（Star Schema）（更复杂的雪花模型在成文时还不支持，可以通过视图将雪花模型转化为星形模型，再使用Kylin）。MapRecue是当前主要的构建技术。构建后的Cube保存在右侧的存储引擎中，一般选用HBase作为存储。<br>完成了离线构建之后，用户可以从上方查询系统发送SQL进行查询分析。Kylin提供了各种Rest　API、ＪＤＢＣ／ＯＤＢＣ接口。无论从哪个接口进入，SQL最终都会来到Rest服务层，再转交给查询引擎进行处理。这里需要注意的是，SQL语句是基于数据源的关系模型书写的，而不是Cube。Kylin在设计时刻意对查询用户屏蔽了Cube的概念，分析师只需要理解简单的关系模型就可以使用Kylin，没有额外的学习门槛，传统的SQL应用也很容易迁移。查询引擎解析SQL，生成基于关系表的逻辑执行计划，然后将其转义为基于Cube的物理执行计划，最后查询预计算生成的Cube并产生结果。整个过程不会访问原始数据源。  </p>
<p><strong>注意</strong>：对于查询引擎下方的路由选择，在最初设计时曾考虑过将Kylin不能执行查询引导去Hive中继续执行，但在实践后发现Hive与Kylin的速度差异过大，导致用户无法对查询的速度有一致的期望，很可能大多数据查询几秒内就返回结果了，而有些查询则要等几分钟到几十分钟，因此体验非常糟糕。最后这个路由功能在发行版中默认关闭。</p>
<p>Apache Kylin 1.5版本引入了“可扩展架构”的概念。在图1-4中显示为三个粗虚框，表示的抽象层。可扩展指Kylin可以对其主要依赖的三个模块做任意的扩展和替换。Kylin的三大依赖模型分别是数据源、构建引擎和存储引擎。在设计之初，作为Hadoop家族 一员，这三者分别是Hive、MapRecue和HBase。但随着推广和使用的深入，渐渐有用户发现它们均存在不足之处。比如，实时分析可能会希望从Kafka导入数据而不是Hive；而Spark的迅速崛起，又使我们不得不考虑将MapRecue替换为Spark，以期大幅提高Cube的构建速度；至于HBase，它的读性能可能还不如Cassandra或Kudu等 。可见，是否可以将一种技术替换为另一种技术已成为一个常见的问题。于在1.5版本的系统架构进行了重构，将数据源、构建引擎、存储引擎三大依赖抽象为接口，而Hive、MapRecue、HBase只是默认实现。深度用户可以根据自己的需要做二次开发，将其中的一个或多个替换为更适合的技术。  </p>
<p>#核心概念</p>
<p>##数据仓库<br>数据仓库（Data Warehouse）是一种系统的资料储存理论，此理论强调的是利用某些特殊的资料储存方式，让所包含的资料特别有利于分析和处理，从而产生有价值的资讯，并可依此做出决策。<br>利用数据仓库的方式存放资料，具有一旦存入，便不会随时间发生变动的特性，此外，存入的资料必定包含时间属性，通常一个数据仓库中会含有大量的历史性资料，并且它可利用特定的分析方式，从其中发掘特定的资讯。</p>
<p>##OLAP<br>OLAP（Online Analytical Process），联机分析处理，以多维度的方式分析数据，而且能够弹性地提供上卷（Roll-up）、下钻（Drill-down）和透视分析（Pivot）等操作，它呈现集成性决策信息的方法，多用于决策支持系统、商务智能或数据仓库。其主要的功能在于方便大规模数据分析及统计计算，可对决策提供参考和支持。与之相区别的是取机交易处理（OLTP），联机交易处理，更侧重于基本的、日常的事务处理，包括数据的增删改查。<br>OLAP需要以大量历史数据为基础，再配合时间点的差异，对多维度及汇整型的信息进行复杂的分析。<br>OLAP需要用户有主观的信息需求定义，因此系统效率较佳。<br>OLAP的概念，在实际应用中存在广义和狭义两种不同的理解方式。广义上的理解与字面上的意义相同，泛指一切不会对数据进行更新的分析处理。但更多的情况下OLAP被理解为其狭义上的含义，即与多维分析相关，基于立方体（Cube）计算而进行的分析。</p>
<p>##BI<br>BI（Business Intelligence），即商务智能，指现代数据仓库技术、在线分析技术、数据挖掘和数据展现技术进行数据分析以实现商业价值。</p>
<p>##维度和度量<br>维度和度量是数据分析中的两个基本的概念<br><strong>维度</strong>是指审视数据的角度，它通常是数据记录的一个属性，例如时间、地点等。<br><strong>度量</strong>是基于数据所计算出来的考量值；它通常是一个数值，如总销售额、不同的用户数等。分析人员往往要结合若干个维度来审查度量值，以便在其中找到变化规律。在一个SQL查询中，Group By的属性通常就是维度，而所计算的值则是度量。如下面的示例：<br>    select part_dt,lstg_iste_id,sum(price) as total_selled,count(distinct seller_id) as sellers from kylin_sales group by part_dt,lstg_site_id</p>
<p>##事实表和维度表<br><strong>事实表</strong>（Fact Table）是指存储有事实记录的表，如系统日志、销售记录等；事实表的记录在不断地动态增长，所以它的体积通常远大于其他表。</p>
<p><strong>维度表</strong>（Dimension Table）或维表，有时也称查找表（Lookup Table），是与事实表相对应的一种表；它保存了维度的属性值，可以跟事实表做关联；相当于将事实表上经常重复出现的属性抽取、规范出来用一张表进行管理。常见的维度表有：日期表（存储与日期对应的周、月、季度等属性）、地点表（包含国家、省、城市等属性）。使用维度表有诸多好处，具体如下：<br>a.缩小了事实表的大小<br>b.便于维度的管理和维护，增加、删除和修改维度的属性，不必对事实表的大量记录进行改动。<br>c.维度表可以为多个事实表重用，以减少重复工作。</p>
<p>##Cube、Cuboid和Cube Segment</p>
<p>###Cube<br>Cube（或Data Cube），即数据立方体，是一种常用于数据分析与索引的技术；它可以对原始数据建立多维度索引。通过Cube对数据进行分析，可以大大加快数据的查询效率。</p>
<p>###Cuboid<br>Cuboid在Kylin中特指在某一种维度组合下所计算的数据。</p>
<p>##Cube Segment<br>Cube Segment是指针对源数据中的某一片段，计算出来的Cube数据。通常数据仓库中的数据数量会随着时间的增长而增长，而Cube Segment也是按时间顺序来构建的。</p>
<p>#在Hive中准备数据<br>这里介绍准备Hive数据的一些注意事项。需要被分析的数据必须先保存为Hive表的形式，然后Kylin才能从Hive中导入数据，创建Cube。<br>Hive是一个基于Hadoop的数据仓库工具，可以将结构化的数据文件映射为数据库表，并可以将SQL语句转换为MapRecue或Tez任务进行运行，从而让用户以类SQL（HiveQL，也称HQL）的方式管理和查询Hadoop上的海量数据。<br>此外，Hive还提供了多种方式（如命令行、API和Web服务等）可供第三方方便地获取和使用元数据并进行查询。今天，Hive已经成为Hadoop数据仓库的首选，是Hadoop上不可或缺的一个重要组件，很多项目都已兼容或集成了Hive。基于此情况，Kylin选择Hive作为原始数据的主要来源。<br>在Hive中准备待分析的数据是使用Kylin的前提；将数据导入到Hive表中的方法有很多，用户管理数据的技术和工具也各式各样，因此具体步骤不在本书的讨论范围之内。</p>
<p>##星形模型<br>数据挖掘有几种常见的多维数据模型，如星形模型（Star Schema）、雪花模型（Snowf lake Schema）、事实星座模型（Fact Constellation）等。<br>星形模型中有一张事实表，以及零个或多个维度表；事实表与维度表通过主键外键相关联，维度表之间没有关联，就像很多星星围绕在一个恒星周围，帮取名为星形模型。<br>如果将星形模型中某些维度的表再做规范，抽取成更细的维度表，然后让维度表之间也进行关联，那么这种模型称为雪花模型。<br>星形模型是更复杂的模型，其中包含了多个事实表，而维度表是公用的，可以共享。<br>不过，Kylin只支持星形模型的数据集，这是基于以下考虑的。  </p>
<ul>
<li>星形模型是最简单，也是最常用的模型  </li>
<li>由于星形模型只有一张大表，因此它相比于其它模型更适合于大数据处理  </li>
<li>其他模型可以通过一定的转换，变成星形模型。  </li>
</ul>
<p>##维度表的设计<br>除了数据模型以外，Kylin还对维度表有一定的要求，具体要求如下。  </p>
<ul>
<li>要具有数据一致性，主键值必须是唯一的；Kylin会进行检查，如果有两行的主键值相同则会报错。</li>
<li>维度越小越好，因为Kylin会将维度表加载到内存中供查询；过大的表不适合作为维度表，默认的阈值是300MB。  </li>
<li>改变频率低，Kylin会在每次构建中试图重用维度表的快照，如果维度表经常改变的话，重用就会失效，这就会导致要经常对维度表创建快照。</li>
<li>维度表最好不要是Hive视图（View），虽然在Kylin1.5.3中加入了对维度表是视图这种情况的支持，但每次都需要将视图进行物化，从而导致额外的时间开销。</li>
</ul>
<p>##Hive表分区<br>Hive支持多分区（Partition）。简单来说，一个分区就是一个文件目录，存储了特定的数据文件。当有新的数据生成的时候，可以将数据加载到指定的分区，读取数据的时候也可以指定分区。对于 SQL查询，如果查询中指定了分区列的属性条件，则Hive会智能地选择特定分区（也就是目录），从而避免全量数据的扫描，减少读写操作对集群的压力。<br>下面举的一组SQL演示了如何使用分区：  </p>
<p>Hie&gt;create table invites(id int,name string) partitioned by(ds string) row format delimited fields terminated by ‘t’ stroed as textfile;<br>Hive&gt;load data local inpath ‘/user/hadoop/data.txt’ overwrite into table invites partition (ds=’2016-08-16’);<br>Hive&gt;select * from invites where ds = ‘2016-08-16’;<br>Kylin支持增量的Cube构建，通常是按时间属性来增量地从Hive表中抽取数据。如果Hive表正好是按此时间属性做分区的话，那么就可以利用到Hive分区的好处，每次在Hive构建的时候都可以直接跳过不相干的日期的数据，节省Cube构建的时间。这样的列在Kylin里也称为分割时间列（Partition Time Column），通常它应该也是Hive表的分区列。</p>
<p>##了解维度的基数<br>维度的基数（Cardinality）指的是该维度在数据集中出现的不同值的个数；例如“国家”是一个维度，如果有200个不同的值，那么此维度的基数就是200.通常一个维度的基数会从几十到几万个不等，个别维度如“用户ID”的基数会超过百万甚至千万。基数超过一百万的维度通常称为超高维度（Ulta Hight Cardinality，UHC），需要引起设计者的注意。<br>Cube中所有维度的基数都可以体现Cube的复杂度，如果一个Cube中有好几个超高基数维度，那么这个Cube膨胀就会很高。在创建Cube前需要对所有维度的基数做一个了解，这样就可以帮助设计合理的Cube。计算基数有多种途径，最简单的方法就是让Hive执行一个count distinct的SQL查询；Kylin也提供计算基数的方法，在导入Hive表定义后可以看到每一个列的基数，参数名为Cardinality</p>
<p>##Sample Data<br>如果需要快速体验Kylin，可以用Kylin自带的Sample Data。运行${KYLIN_HOME}/bin/sample.sh来导入Sample Data，然后就能按照下面的流程来创建模型和Cube。<br>具体请执行下面命令，将Sample Data导入到Hive数据库。<br>cd ${KYLIN_HOME}<br>bin/sample.sh<br>Sample Data测试的样例数据集总共仅1M左右，共计3张表，其中事实表有10000条数据。数据集是一个规范的星形模型结构，它总包含3个数据表：<br>KYLIN_SALES是事实表，保存了销售订单的明细信息。各列分别保存着卖家、商品、分类、订单金额、商品数据等信息，每一行对应着一笔交易订单。<br>KYLIN_CATEGORY_GROUPINGS是维表，保存了商品分类的详细介绍，例如商品分类名称等。<br>KYLIN_CAL_DT也是维表，保存了时间的扩展信息。如单个日期所在的年始、月始、周始、年份、月份等。<br>这3张表一起构成了整个星形模型。  </p>
<p>#设计Cube<br>如果数据已经在Hive中准备好了，就可以开始创建Cube了。</p>
<p>##导入Hive表定义<br>登陆Kylin的Web界面，创建新的或选择一个已有的项目之后，需要做的就是将Hive表的定义导入到Kylin中。<br>单击Web界面的Model-&gt;Data Source下的”Local Hive Table“图标，然后输入表的名称（可以一次导入多个表，以逗号分隔表名），单击按钮”Sync“，Kylin就会使用Hive的API从Hive中获取表的属性信息。<br>导入成功后，表的结构信息会以树状的形式显示在页面的左侧，可以单击展开或收缩。</p>
<p>同时Kylin会在后台触发一个MapRecue任务，计算此表的每个列的基数。通常稍过几分钟后再刷新页面，就会看到显示出来 的基数信息Cardinality</p>
<p>需要注意的是，这里Kylin对基数的计算方法采用的是HyperLogLog的近似算法，与精确值略有误差，只做参考值。</p>
<p>##创建数据模型<br>有了表信息之后，就可以开始创建数据模型（Data Model）了。数据模型是Cube的基础，它主要用于描述一个星形模型。有了数据模型以后，定义Cube的时候就可以直接从此模型定义的表和列中进行选择了，省去重复指定连接（join）条件的步骤。基于一个数据模型还可以创建多个Cube，以方便减少用户的重复性工作。<br>在Kylin界面中”Models“页面中单击”New”-&gt;”New Model”，开始创建数据模型。</p>
<p>接下来选择用作维度和度量的列。这里只是选择一个范围，不代表这些列将来一定要用作Cube 的维度或度量，你可以把所有可能会用到表都选进来，后续创建Cube的时候，将只能从这些列中进行选择。   </p>
<p>选择维度列时，维度可以来自事实表或维度表<br>选择度量列时，度量只能来自事实表<br>最后一步，是为模型补充侵害时间列信息和过滤条件。如果此模型中的事实表记录是按时间增长的，那么可以指定一个日期/时间列作为模型的分割时间列，从而可以让Cube按此列做增量构建。</p>
<p>过滤（Filter）条件是指，如果想把一些记录忽略掉，那么这里可以设置一个过滤条件。Kylin在向Hive请求源数据的时候，会带上此过滤条件。</p>
<p>随后“Save”后，出现在“Model”的列表中。</p>
<p>##创建Cube<br>单击“New”，选择“New Cube”，会开启一个包含若干步骤的向导。</p>
<p>第一页，选择要使用的数据模型，并为此Cube输入一个唯一的名称（必需的）和描述（可选的）；这里还可以输入一个邮件通知列表，用于在构建完成或出错时收到通知。如果不想接收处于某些状态的通知，那么可以从“Notification Events”中将其去掉。</p>
<p>第二页，选择Cube的维度。可以通过以下两个按钮来添加维度。<br><strong>“Add Mimension”</strong>：逐个添加维度，可以是普通维度也可以是衍生（Derived）维度。<br><strong>“Auto Generator”：</strong>批量选择并添加，让Kylin自动完成其它信息。<br>使用第一种方法的时候需要为每个维度起个名字，然后选择表和列。<br>如果是衍生维度的话，则必须是来自于某个维度表，一次可以选择多个列；由于这些列值都可以从该维度表的主键值中衍生出来，所以实际上只有主键列会被Cube加入计算。而在Kylin 的具体实现中，往往采用事实表上的外键替代主键进行计算和存储。但是在逻辑上可以认为衍生列来自于维度表的主键。<br>使用第二种方法，Kylin会用一个树状结构呈现出所有的列，用户只需要勾选所需要的列即可，Kylin会自动补充其他信息，从而方便用户的操作。请注意，在这里Kylin会把维度表上的列都创建成衍生维度，这也许不是最合适的，在这种情况下请使用第一种方法。</p>
<p>第三页，创建度量。Kylin默认会创建一个Count(1)的度量。可以单击“+Measure”按钮来添加新度量。Kylin支持的度量有：SUM、MIN、MAX、COUNT、COUNT　DISTINCT、ＴＯＰ＿Ｎ、RAW等。请选择需要的度量类型，然后再选择适当的参数（通常为列名）</p>
<p>重复上面的步骤，创建所需要的度量。Kylin可以支持在一个Cube中添加多达上百个度量；添加完成所有度量之后，单击“Next”。</p>
<p>第四页，是关于Cube数据刷新的设置。在这里可以设置自动合并的阈值、数据保留的最短时间，以及第一个Segment的起点时间（如果Cube有分割时间列的话）。</p>
<p>第五页，高级设置。在此页面上可以设置聚合组和Rowkey<br>Kylin默认会把所有的维度都放在同一个聚合中；如果维度数据较多（例如&gt;10），那么建议用户根据查询的习惯和模式，单击“New Aggregation Group+”，将维度分为多个聚合组。通过使用多个聚合组，可以大大降低Cube中的Cuboid数量。下面来举例说明，如果一个Cube有（M+N)个维度，那么默认它会有2的m+n次方个Cuboid；如果把这些维度分为两个不相交的聚合组，那么Cuboid的数量将被减少为2的m次方+2的n次方。<br>在单个聚合组中，可以对维度设置高级属性，例如Mandatory、Hierarchy、Joint等。这几个属性都是为了优化Cube的计算而设计的，了解这些属性的含义对日后更好地使用Cube至关重要。<br>Mandatory维度指的是那些总是会出现在where条件或Group By语句里的维度；通过将某个维度指定为Mandatory，Kylin就可以不用预计算那些不包含此维度的Cuboid，从而减少计算量。<br>Hierarchy是一组有层级关系的维度，例如：“国家”“省”“市”，这里的“国家”是高级的维度，“省”“市”依次是低级的维度。用户会按高级别维度进行查询，也会按低级别维度进行查询，但在查询低级别维度时，往往都会带上高级别维度的条件，而不会孤立地审视低级别维度的数据。例如，用户单击“国家”作为维度来查询汇总数据，也可能单击“国家”+“省”或者“国家”+“省”+“市”来查询，但是不会跨越国家直接Group By“省”或“市”。通过指定Hierarchy，Kylin可以省略不满足此模式的cuboid。<br>Joint是将多个维度组合成一个维度，其通常适用于如下两种情况。<br>1.总是会在一起查询的维度。<br>2.基数很低的维度<br>Kylin以Key-Value的方式将Cube存在到HBase中。HBase的key，也就是Rowkey，是由各维度的值拼接而成的；为了更高效地存储这些值，Kylin会对它们进行编码和压缩；每个维度均可以选择合适的编码（Encoding）方式，默认采用的是字典（Dictionary）编码技术；除了字典以外，还有整数（Int）和固定长度（Fixed Length）的编码。<br>字典编码是将此维度下所有值构建成一个从string到int的映射表；Kylin会将字典序列化保存，在Cube中存储int值，从而大大减小存储的大小。另外，字典是保持顺序的，即如果字符串A比字符串B大的话，那么A的编码后的int值也会比B编码后的值大；这样可以使得在HBase中进行比较查询的时候，依然使用编码后的值，而无需解码。</p>
<p>字典非常适合于非固定长度的string类型值的维度，而且用户无需指定编码后的长度；但是由于使用字典需要维护一张映射表，因些如果此维度的基数很高，那么字典的大小就非常可观，从而不适合于加载到内存中，在这种情况下就要选择其他的编码方式了。Kylin中字典编码允许的基数上限默认是500万（由参数”kylin.dictioinary.max.cardinality”配置）。<br>整数（int）编码适合于对int或bigint类型的值进行编码，它无需额外存储，同时还可以支持很大的基数。用户需要根据值域选择编码的长度。例如有一个手机号码的维度，它是一个11位的数字，如13800138000，我们知道它大于2的31次方，但是小于2的39次方减1，那么使用int(5)即可满足要求，每个值占用5字节，比按字符存储（11字节）要少占一半以上的空间。  </p>
<p>当上面几种编码方式都不适合的时候，就使用固定长度的编码了；此编码方式其实只是将原始值截断或补充成相同长度的一组字节，没有额外的转换，所以空间效率较差，通常只是作为一种权宜手段。<br>各维度在Rowkeys中的顺序，对于 查询的性能会产生较明显的影响。在这里用户可以根据查询的模式和习惯，通过拖拽的方式调整各个维度在Rowkeys上的顺序。通常的原则是，将过滤频率较高的列放置在过滤频率较低的列之前，将基数高的列放置在基数低的列之前。这样做的好处是，充分利用过滤条件来缩小在HBase中扫描的范围，从而提高查询的效率。<br>第五页，为Cube配置参数。和其他Hadoop工具一样，Kylin使用了很多配置参数以提高录活性，用户可以根据具体的环境、场景等配置不同的参数进行调优。Kylin全局的参数值可在conf/kylin.properties文件中进行配置；如果Cube需要覆盖全局设置的话，则需要在此页面中指定。单击“+Property”按钮，然后输入参数名和参数值。例如“kylin.hbase.region.cut=1”,这样此Cube在存储的时候，Kylin将会为每个HTbase Region分配1GB来创建一个HTbase Region。</p>
<p>#构建Cube<br>新创建的Cube只有定义，而没有计算的数据，它的状态是”DISABLED“，是不会被查询引擎挑中的。要想让Cube有数据，还需要对它进行构建。Cube的构建方式通常有两种：全量构建和增量构建；两者的构建步骤是完全一样的，区别只在于构建时读取的数据源是全集还是子集。<br>Cube的构建包含如下步骤，由任务引擎来调度执行。<br>1）创建临时的Hive平表（从Hive读取数据）<br>2）计算各维度的不同值，并收集各Cuboid的统计数据。<br>3）创建并保存字典。<br>4）保存Cuboid统计信息。<br>5）创建HTable。<br>6）计算Cube（一轮或若干轮MapRecue）。<br>7）将Cube的计算结果转成HFile。<br>8）加载HFile到HBase。<br>9）更新Cube元数据。<br>10）垃圾回收。<br>以上步骤中，前5步是计算Cube而做的准备工作，例如遍历维度值来创建字典，对数据做统计秋估算以创建HTable等；第6）步是真正的Cube计算，取决于所使用的Cube算法，它可能是一轮MapRecue任务，也可能是N（在没有优化的情况下，N可以被视作是维度数）轮迭代的MapRecue。由于Cube运算的中间结果是以SequenceFile的格式存储在HDFS上的，所以为了导入到HBase中，还需要第7）步将这些结果转换成HFile（HBase文件存储格式）。第8）步通过使用HBase BulkLoad工具，将HFile导入到HBase集群，这一步完成之后，HTable就可以查询到数据了。第9）步更新Cube的数据，将此次构建 Segment的状态从”NEW“更新为”ＲＥＡＤＹ＂，表示已经可借查询了。最后一步，清理构建过程中生成的临时文件等垃圾，释放集群资源。　　<br>Monitor页面会显示当前项目下近期的构建任务。　　</p>
<p>##全量构建和增量构建</p>
<p>###全量构建</p>
<p>###增量构建</p>
<p>##历史数据刷新</p>
<p>##合并</p>
<p>#查询Cube</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cenrise.com/2017/04/16/hadoop/HDFS入门概念/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongpo.jia">
      <meta itemprop="description" content="个人博客">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="中起之星">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/16/hadoop/HDFS入门概念/" itemprop="url">
                  HDFS入门概念
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-04-16 23:43:49" itemprop="dateCreated datePublished" datetime="2017-04-16T23:43:49+08:00">2017-04-16</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-08-18 09:44:35" itemprop="dateModified" datetime="2017-08-18T09:44:35+08:00">2017-08-18</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/大数据/" itemprop="url" rel="index"><span itemprop="name">大数据</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/大数据/hdfs/" itemprop="url" rel="index"><span itemprop="name">hdfs</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#数据块<br> 每个磁盘都有默认的数据块大小，这是磁盘进行数据读/写的最小单位。构建于单个磁盘之上的文件系统通过磁盘块来管理该文件系统的块，该文件系统块的大小的可以是磁盘块的整数倍。文件系统块一般为几千字节，而磁盘块一般为512字节。这些信息–文件系统块大小—对于需要读/写文件的文件系统用户来说是透明的。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cenrise.com/2017/04/16/spark/TODO-Spark体系概述/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongpo.jia">
      <meta itemprop="description" content="个人博客">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="中起之星">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/16/spark/TODO-Spark体系概述/" itemprop="url">
                  Spark体系概述
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-04-16 23:43:49" itemprop="dateCreated datePublished" datetime="2017-04-16T23:43:49+08:00">2017-04-16</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-08-18 09:44:35" itemprop="dateModified" datetime="2017-08-18T09:44:35+08:00">2017-08-18</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/大数据/" itemprop="url" rel="index"><span itemprop="name">大数据</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/大数据/spark/" itemprop="url" rel="index"><span itemprop="name">spark</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文目的是介绍spark框架下的内容，以简要概述方式。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cenrise.com/2017/04/16/hadoop/数据分析软件分类/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongpo.jia">
      <meta itemprop="description" content="个人博客">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="中起之星">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/16/hadoop/数据分析软件分类/" itemprop="url">
                  数据分析软件分类
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-04-16 23:43:49" itemprop="dateCreated datePublished" datetime="2017-04-16T23:43:49+08:00">2017-04-16</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-08-18 09:44:35" itemprop="dateModified" datetime="2017-08-18T09:44:35+08:00">2017-08-18</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/大数据/" itemprop="url" rel="index"><span itemprop="name">大数据</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/大数据/数据分析/" itemprop="url" rel="index"><span itemprop="name">数据分析</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#数据分析软件分类<br>下面介绍一些适合大数据分析的存储数据库，或者面向大数据分析，适用于TB级以上的数据库存储和分析任务。分为如下几类介绍：<br>1.商业数据库<br>2.开源时序数据库<br>3.开源计算框架<br>4.开源SQL on hadoop<br>5.云端数据分析SaaS  </p>
<p>##商业软件<br>商业数据库软件种类繁多，但是真正能支持TB级别以上的数据存储和分析并不多，下面介绍几个有特点、支持大数据的商用数据库。  </p>
<p>###HP Vertica<br>Vertica公司成立于2005年，创立者为数据库巨擘Michael Stonebraker。2011成Vertica被惠普收购。Vertica是能够提供高效数据存储和快速查询数据存储数据库实时分析平台，还支持大规模并行 处理（MPP）。产品广泛应用于高端数据营销、互联网客户分析处理，数据达到PB级别。<br>Vertical特点如下：<br>面向列的存储<br>灵活的压缩算法，根据数据的排序性和基数决定压缩算法。<br>高可用数据库和查询<br>MPP架构，分布式存储和任务负载，Shared nothing架构。<br>支持标准SQL查询、ODBC/JDBC等..<br>支持Projection（数据投射）功能。</p>
<p>###Oracle Exadata<br>Oracle Exadata是数据库发展史上一个人传奇，它是数据库软件和最新硬件的完美结合。它提供最快、最可靠的数据库平台，不仅支持常规的数据库应用，也支持联机分析处理（OLAP）和数据仓库（DW）的场景。<br>Oracle Exadata采用了多种最新的硬件技术，例如40GB的InfiniBan网络</p>
<p>###Teradata<br>Teradata（天睿）公司是专注于大数据分析、数据仓库和整合营销管理解决方案的供应商。Teradata采用纯粹的Shared noting架构，支持MPP。对于多维度的查询更加灵活，专注于数据仓库的应用领域。  </p>
<p>##时序数据库<br>时序数据库用于记录过去时间的各个数据点的信息，典型的应用是服务器的各种性能指标，例如CPU、内存使用情况等 。目前时序数据库也广泛应用于各种传感器的数据收集分析工作中，这些数据的收集都有一个特点，就是对时间的依赖非常大，每天产生的数据量非常大，因此定入的量非常大，一般的关系型数据库无法满足这些场景。因此，时序数据库在设计上需要支持高吞吐、高效数据压缩，支持历史查询、分布式部署等。</p>
<p>###1.OpenTSDB<br>OpenTSDB是一个开源的时序数据库，支持存储千亿的数据点，并提供精确查询功能。它采用Java语言编写，通过基于HBaser存储实现横向扩展。</p>
<p>###2.InfluxDB<br>InfluxDB采用GoLang语言开发，也是一个开源应用，社区非常活跃。其技术特点包含：支持任意数量的列，支持方便、强大的查询语言，集成了数据采集、存储和可视化功能。</p>
<p>##开源分布式计算平台<br>一个是Hadoop，另一个是Spark，这里就不一一介绍了。</p>
<p>##开源分析数据库</p>
<p>###Kylin<br>Kylin是Apache开源的开源分布式分析引擎。<br>与Kylin一样致力于大数据查询问题的开源产品如Apache Drill、Apache Impala、Druid、Hive、Presto（Facebook）、SparkSQL等。<br>从底层技术角度来看，这些开源产品有很大的共性，一些底层技术几乎被所有的产品一致采用。<br>1）大规模并行处理：可以通过增加机器的方式来扩容处理速度，在相同的时间里处理更多的数据。<br>2）列式存储：通过按列存储提高单位时间里数据的I/O吞吐率，还能跳过不需要访问的列。<br>3）索引：利用索引配合查询条件，可以迅速跳过不符合条件的数据块，仅扫描需要扫描的数据内容。<br>4）压缩：压缩数据然后存储，使得存储的密度更高，在有限的I/O速率下，在单位时间里读取更多的记录。<br>综上所述，我们可以注意到，所有这些方法都只是提高了单位时间内处理数据的能力，当大家都一致采用这些技术时，它们之间的区别将只停留在实现层面的代码细节上。最重要的是，这些技术都不会改变一个事实，那就是处理时间与数据量之间的正比例关系。当数据量翻倍时，MPP（在不扩容的前提下）需要翻倍的时间来完成计算；列式存储需要翻倍的存储空间；索引下符合条件的记录数据数也会翻倍；压缩事的数据大小也还是之间的两倍。因此查询速度也会随之就之前的两倍。当数据量成十倍地增长时，这些技术的查询速度就会成十倍地下降，最终变得不能接受。<br>Apache Kylin的特色在于，在上述的底层技术之外，另辟蹊径地使用了独特的Cube预计算技术。预计算将数据按维度组合进行了聚合，将结果保存为物化视图。经过聚合，物化视图的规模就只由维度的基数来决定，而不再随着数据量的增长呈线性增长。以电商为例，如果业务扩张，交易量增长了10倍，只要交易数据的维度不变（供应商/商品数量不变），聚合后的物化视图初依旧是原先的大小，查询的速度也将保持不变。<br>与那些类似产品相比，这一导技术的区别使得Kylin从外在功能上呈现出了不同的特性，具体如下：<br>1）SQL接口：除了Druid以外，所有的产品都支持SQL或类SQL接口。巧合的是Druid也是除了Kylin以外，查询性能相对更好的一个。这点除了Druid有自己的存储引擎之外，可能还利益于其较为受限的查询能力。　　<br>2）大数据支持：大数据产品的能力在亿级到十亿级数据量之间，再大的数据量将显著降低查询性能。而Kylin因为采用预计算技术，因此查询速度不受数据量的限制。<br>3）查询速度，不会随着数据量的增加而查询性能下降。<br>4）吞吐量：根据之前的实验数据，Kylin的单例吞吐量一般在每秒70个查询左右，并且可以线性扩展，而普通的产品因为所有计算都在查询时完成，所以需要调动集群的更多资源才能完成查询，通常极限在每秒20个查询左右，而且扩容成本较高，需要扩展整个集群。相对的，Kylin系统因为瓶颈不在整个集群，而在于Kylin服务器，因此只需要增加Kylin服务器就能成倍提高吞率，扩容成本低廉。</p>
<p>###Druid<br>Druid是什么？<br>Druid是一个分布式的支持实时分析的数据存储系统（Data Store）,是美国广告技术公司MetaMarkets于2011年创建，2012年开源的项目，Druid设计之初是为分析而生。官方网站是：<a href="http://druid.io" target="_blank" rel="noopener">http://druid.io</a></p>
<p>###Pinot<br>Pinot是Linkin于2015年开源的一个分布式列式数据存储系统。</p>
<p>###神秘的谷歌Dremel<br>Dremel是谷歌的“交互式”数据分析系统，支持上千台机器的集群部署，处理PB级别的数据，可以对网状数据的只读数据进行随机查询访问，帮助数据分析分提供Ad Hoc查询功能，进行尝试的数据探索（Exploration）。</p>
<p>###Apache Drill<br>Apache Drill通过开源方式实现了谷歌Dremel。Drill架构的整个思想还是通过优化查询引擎，进行快速全表扫描，以快速返回结果，其高层架构示意图如下：</p>
<p>Apache Drill基于SQL的数据分析和商业智能引入了JSON文件模型，这使得用户能查询固定架构，支持各种格式和数据存储中的模式无关数据。该体系架构中的关系查询引擎和数据库构建是有先决条件的，即假设所有数据都有一个简单的静态架构。</p>
<p>Apache Drill的架构是独一无二的，它是唯一一个支持复杂和无模式数据的柱状行引擎，也是唯一一个能在查询执行期间进行的数据驱动查询。</p>
<p>###Elasticsearch<br>Elasticsearch（ES）是Elastic公司推出一个基于Lucerne的分布式</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cenrise.com/2017/04/16/hadoop/Hadoop之分布式计算 /">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongpo.jia">
      <meta itemprop="description" content="个人博客">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="中起之星">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/16/hadoop/Hadoop之分布式计算 /" itemprop="url">
                  分布式计算
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-04-16 23:43:49" itemprop="dateCreated datePublished" datetime="2017-04-16T23:43:49+08:00">2017-04-16</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-08-18 09:44:35" itemprop="dateModified" datetime="2017-08-18T09:44:35+08:00">2017-08-18</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/分布式/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/分布式/分布式计算/" itemprop="url" rel="index"><span itemprop="name">分布式计算</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#MapRecue<br>在过去的20年里，互联网产生了大量的数据，比如爬虫文档、Web讲求日志等；也包括了计算各种类型的派生数据，比如，倒排索引、Web文档的图结构的各种表示、每台主机页面数量概要、每天被请求数量最多的集合，等等。很多这样的计算在概念上很容易理解的。然而，当输入的数据量很大时，这些计算必须要被分割到成百上千的机器上才有可能在可以接受的时间内完成。怎样来实现并行计算？如何分发数据？如何进行错误处理？所有这些问题综合在一起，使得原来很简洁的计算，因为要大量的复杂代码来处理这些问题，而变得让人难以处理。 Google公司为了应对大数据的处理，内部已经实现了数据以百计的为专门目的而写的计算程序，其中MapRecue就是其著名的计算框架之王，与GFS、Bigtable一起被称为Google技术的“三宝”。 </p>
<p>##MapRecue简介<br>MapRecue是一个编程模型，用于大规模数据集（TB级）的并行运算。有关MapRecue的论文介绍，最早可以追溯到由Google的Jeffrey Dean和Sanjay Ghemawat发表在2004年OSDI（USENIX Symposium on Operationg Systems Design and Implementation）的《MapRecue：Simplified Data Processing on LargeClusters》。这篇文章描述了Google如何分割、处理、整合他们令人难以置信的大数据集。读者有兴趣可以在线阅读该论文<a href="https://www.usenix.org/legacy/events/osdi04/tech/full_papers/dean/dean.pdf。" target="_blank" rel="noopener">https://www.usenix.org/legacy/events/osdi04/tech/full_papers/dean/dean.pdf。</a> 随后，开源软件先驱Doug Cutting等人受到该论文的启发，开始尝试实现MapRecue计算框架，并将它与NDFS（Nutch Distributed File System）结合，用以支持Nutch引擎的主要算法。由于NDFS与MapRecue在Nutch引擎中有着良好的应用，所以它们于2006年2月被分离出来，成为一套完整而独立的软件，并命名为Hadoop。 MapRecue程序模型应用成功要归功于以下几个方面。首先，由于该模型隐藏了并行、容错、本地优化以及负载平衡的细节，所以即便是那些没有并行和分布式系统经验的程序员也易于使用该模型。其次MapRecue计算可以很容易地表达大数据的各种问题。比如，MapRecue用于为Google的网页搜索服务生成数据，用于排序，用于数据挖掘，用于机器学习以及其他许多系统。再次，MapRecue的实现符合“由数千机器组成的大集群”的尺度，有效地利用了机器资源，所以非常适合解决大型计算问题。 </p>
<p>##MapRecue的编程模型<br>MapRecue是一个用于大规模数据集（TB级）并行运算的编程模型，其基本原理就是将大的数据分成小块逐个分析，最后再将提取出来的数据汇总分析，最终获得我们想要的内容。从名字可以看出，“Map(映射)”和“Reduce（归纳）”是MapRecue模型的核心，其灵感来源于函数式语言（比如Lisp）中的内置函数map和reduce：用户通过定义一个Map函数，处理key/value（键值对）以生成一个中间key/value集合，MapRecue库将所有拥有相同的key(key I)的中间状态key合并起来传递到Redure职数；一个叫作Reduce的函数用以合并所有先前Map过后的有相同key（Key I）的中间量。map(k1,v1) -&gt; list&lt;k2,v2)reduce(k2,list(v2)) -&gt; list(k3,v3)但上面的定义显然还是过于抽象。现实世界中的许多任务在这个模型中得到了很好的表达。Shekhar Gulati就在他的博客里《How I explained MapReduce to my Wife?》举了一个辣椒酱制作过程的例子，来形象地描述MapRecue的原理，如下所述。1.MapRecue制作辣椒酱的过程辣椒酱制作的过程是这样的，先取一个洋葱，把它切碎，然后拌入盐和水，最后放进混合研磨机研磨。这样就能得到洋葱辣椒酱了。 现在，假设你想用薄荷、洋葱、番茄、辣椒、大蒜弄一瓶混合辣椒酱。你会怎么做呢？你会取薄荷叶一撮，洋葱一个，番茄一个，辣椒一根，大蒜一根，切碎后加入适量的盐和水，再放入混合研磨机里研磨，这样你就可以得到一瓶混合辣椒酱了。 现在把MapRecue的概念应用到食谱上，Map和Reduce其实就是两种操作。 Map：把洋葱、番茄、辣椒和大蒜切磋，是各自作用在这些物体上的一个Map操作。所以你给Map一个洋葱，Map就会把洋葱切碎。同样地，你把辣椒、大蒜和番茄一一地拿给Map，你也会得到各种碎块。所以，当你在切像洋葱这样的蔬菜时，你执行的就是一个Map操作。Map操作适用于每一种蔬菜，它会相应地生产出一种或多种碎块，在我们的例子中生产的是蔬菜块。在Map操作中可能会出现有个洋葱坏掉了的情况，你只要把洋葱丢了就行了。所以，如果出现坏洋葱了，Map操作就会过滤掉这个坏洋葱而不会生产出任何的坏洋葱块。 Reduce：在这一阶段，你将各种蔬菜都放入研磨机时在进行研磨，你就可以得到一瓶辣椒酱了。这意味要制成一瓶辣椒酱，你得研磨所有的原料。因此，研磨机通常将Map操作的蔬菜聚焦在了一起。 当然上面内容只是MapRecue的一部分，MapRecue的强大在于分布式计算。假设你每天需要生产10000瓶辣椒酱，你会怎么办？这个时候你就不得不雇佣更多的人和研磨机来完成这项工作了，你需要几个人一起切蔬菜。每个人都要处理满满一袋子的蔬菜，而每一个人都相当于在执行一个简单的Map操作。每一个人都将不断地从袋子里拿出蔬菜来，并且每次只对一种蔬菜进行处理，也就是将它们切碎，直到袋子空了为止。这样，当所有的工人都切完以后，工作台（每个人工作的地方）上就有了洋葱块、番茄块和蒜蓉，等等。 MapRecue将所有输出的蔬菜都搅拌在了一起，这些蔬菜都在以key为基础的Map操作下产生的。搅拌将自动完成，你可以假设key是一种原料的名字，你像洋葱一样。所以全部的洋葱key都搅拌在一起，并转移到研磨洋葱的研磨器里。这样，你就能得到洋葱辣椒酱了。同样地，所有的番茄也会被转移地标记着番茄的研磨器里，并制造出番茄辣椒酱。 </p>
<p>#Apache Hadoop<br>Apache Hadoop是一个由Apache基金会开发的分布式系统基础架构，它可以让用户在不了解分布式底层细节的情况下，开发出可靠、可扩展的分布式计算应用。<br>Apache Hadoop框架允许用户使用简单的编程模型来实现计算机集群的大型数据集的分布式处理。它的目的是支持从单一服务器到上千台机器的扩展，充分利用了每台机器所提供本地计算和存储，而不是依靠硬件来提高高可用性。其本身被设计成在应用层检测和处理故障的库，对于计算机集群来说，其中每台机器的顶层都被设计成可以容错的，以便提供一个高可用的服务。<br>Apache Hadoop的框架最核心的设计就是HDFS和MapRecue。HDFS为海量的数据提供了存储，而MapRecue则为海量的数据提供了计算。</p>
<p>##Apache Hadoop核心组件<br>Apache Hadoop包含以下模块：<br>Hadoop Common—常见实用工具，用来支持其他hadoop模块。<br>Hadoop Distributed File System（HDFS）—分布式文件系统，它提供对应用程序数据的高吞吐量访问<br>Hadoop YARN—-一个作业调度和集群资源管理框架<br>Hadoop MapRecue–基于YARN的大型数据集的并行处理系统</p>
<p>###其它Apache Hadoop 相关的项目包括：<br>Ambari—-一个基于Web的工具，用于配置、管理和监控的Apache Hadoop 集群，其中包括支持Hadoop  HDFS、Hadoop  MapRecue、Hive、HCatalog、HBase、ZooKeeperOozie、Pig和Sqoop。Ambari还提供了仪表盘用于查看集群的健康，如热图，并能够以用户友好的方式来查看MapRecue、Pig和Hive应用，方便诊断其性能。<br>Avro–数据序列化系统<br>Cassandra–可扩展的、无单点故障的多主数据库<br>Chukwa–数据采集系统，用于管理大型分布式系统。<br>Hbase–一个可扩展的分布式数据库，支持结构化数据的大表存储<br>Hive–数据仓库基础设施，提供数据汇总以及特定的查询<br>Mahout—一种可扩展的机器学习和数据挖掘库<br>Pig–一个高层次的数据流并行计算语言和执行框架<br>Spark—Hadoop数据的快速和通用计算引擎。Spark提供了简单和强大的编程模型用于支持广泛的应用，其中包括ETL、机器学习、流处理和图形处理。<br>TEZ–通用的数据流编程框架，建立在Hadoop YARN之上。它提供了一个强大而灵活的引擎来执行任意DAG任务，以实现批量和交互式数据的处理。TEZ正在被Hive、Pig和Hadoop生态系统中的其他框架所采用，也可以通过其他商业软件（例如，ETL工具），以取代hadoop mapreduce作为底层执行引擎。<br>ZooKeeper–一个高性能的分布式应用程序协调服务。</p>
<p>##Apache Spark<br>Spark是一个快速和通用的集群计算系统。特别：</p>
<ol>
<li>快速 Spack具有支持循环数据流和内存计算的先进的DAG执行引擎，所以比Hadoop MapRecue在内存计算上快100倍，在硬盘计算上快10倍。</li>
<li>易于使用 Spark提供了Java，Scala，Python和R等语言的高级API，可以用于快速开发相关语言应用。Spark提供了超过80个高级的操作，可以轻松构建并行应用程序。</li>
<li>全面 Spark提供了Spark SQL，机器学习的MLlib，进行图形处理的GraphX，以及Spark Streaming等库。你可以在同一应用程序无缝地合并这些库。</li>
<li>到处运行 可以standalone cluster mode运行EC2、Hadoop YARN、或者Apache Mesos中。可以访问HDFS、Cassandra、HBase、Hive、Tachyon，以及任意的Hadoop数据源。</li>
</ol>
<p>##Apache Mesos<br>在传统上，物理机和虚拟机是数据中心的典型的计算单元。当应用部署后，这些机器需要安装各种配置工具来管理这些应用。机器通常被组织成集群，提供独立的服务，而系统管理员则监督其日常的日常动作。当这些集群达到其最大容量时，需要多机联网来处理负载，这就是集群的扩展带来了挑战。<br>在2010年，UC Berkeley大学就对上述问题提出了解决方案，这就是现在的Apache Mesos，Mesos抽象了CPU、内存、硬盘资源，让数据中心的功能对外就像是一个大的机器。Mesos创建一个单独的底层集群来提供应用程序所需要的资源，而不会超出虚拟机和操作系统性能限制。</p>
<p>###Apache Mesos简介<br>Mesos是Apache下的开源分布式资源管理框架，它被称为分布式系统的内核，使用内置Linux内核相同的原理，只是在不同的抽象层次。该 Mesos内核运行在每个机器上，在整个数据中心和云环境内应用程序（例如Hadoop、Spark、Kafka、Elaborate等）提供资源管理和资源负载的API接口。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="dongpo.jia" />
            
              <p class="site-author-name" itemprop="name">dongpo.jia</p>
              <p class="site-description motion-element" itemprop="description">个人博客</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">49</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">43</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">40</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dongpo.jia</span>

  

  
</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.2.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.2.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.2.0"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
