<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.2.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=6.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=6.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.2.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="中起之星">
<meta property="og:url" content="http://cenrise.com/index.html">
<meta property="og:site_name" content="中起之星">
<meta property="og:description" content="个人博客">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="中起之星">
<meta name="twitter:description" content="个人博客">






  <link rel="canonical" href="http://cenrise.com/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>中起之星</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">中起之星</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">Cenrise</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cenrise.com/2018/05/22/分布式/负载均衡初识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongpo.jia">
      <meta itemprop="description" content="个人博客">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="中起之星">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/22/分布式/负载均衡初识/" itemprop="url">
                  负载均衡初识
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-05-22 16:43:49" itemprop="dateCreated datePublished" datetime="2018-05-22T16:43:49+08:00">2018-05-22</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-05-30 16:37:01" itemprop="dateModified" datetime="2018-05-30T16:37:01+08:00">2018-05-30</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/分布式/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/分布式/负载均衡/" itemprop="url" rel="index"><span itemprop="name">负载均衡</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="负载均衡的模式"><a href="#负载均衡的模式" class="headerlink" title="负载均衡的模式"></a>负载均衡的模式</h2><ul>
<li>ActiveWeight / LeastActive ：低并发度优先， referer 的某时刻的 call 数越小优先级越高。</li>
<li>Random ：随机，按权重设置随机概率。在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</li>
<li>RoundRobin ：轮循，按公约后的权重设置轮循比率。存在慢的提供者累积请求问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</li>
<li>LocalFirst ：本地服务优先获取策略。</li>
<li>Consistent ：一致性 Hash ，相同参数的请求总是发到同一提供者。当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</li>
<li>ConfigurableWeight ：权重可配置的负载均衡策略。</li>
</ul>
<h2 id="技术对比"><a href="#技术对比" class="headerlink" title="技术对比"></a>技术对比</h2><ul>
<li>Motan：支持 ActiveWeight 、Random 、 RoundRobin 、LocalFirst 、 Consistent 、ConfigurableWeight 。</li>
<li>Dubbo：支持 Random 、RoundRobin 、ConsistentHash 、 LeastActive。</li>
<li>gRPC：提供可插拔负载均衡器的机制。</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cenrise.com/2017/08/18/异常/Java_heap_space_OutOfMemoryError/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongpo.jia">
      <meta itemprop="description" content="个人博客">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="中起之星">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/18/异常/Java_heap_space_OutOfMemoryError/" itemprop="url">
                  Java_heap_space_OutOfMemoryError
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-08-18 20:30:00" itemprop="dateCreated datePublished" datetime="2017-08-18T20:30:00+08:00">2017-08-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-05-15 13:57:06" itemprop="dateModified" datetime="2018-05-15T13:57:06+08:00">2018-05-15</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/异常/" itemprop="url" rel="index"><span itemprop="name">异常</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/异常/tomcat/" itemprop="url" rel="index"><span itemprop="name">tomcat</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#java.lang.OutOfMemoryError: Java heap space</p>
<p>##问题描述<br>Tomcat 8.0.45在linux环境下启动错误</p>
<p>##原因分析<br>JVM堆是指java程序运行过程中JVM可以调配使用的内存空间,主要用于存放Instance。JVM在启动的时候会自动设置Heap size的值，其初始空间(即-Xms)是物理内存的1/64，最大空间(-Xmx)是物理内存的1/4。可以利用JVM提供的-Xmn -Xms -Xmx等选项可进行设置。Heap size 的大小是Young Generation 和Tenured Generaion 之和。在JVM中如果98％的时间是用于GC且可用的Heap size 不足2％的时候将抛出此异常信息。</p>
<p>##解决方案<br>手动设置Heap size<br>a.如果tomcat是以bat方式启动的，则如下设置：<br>修改TOMCAT_HOME/bin/catalina.sh<br>JAVA_OPTS=”-server -Xms1024m -Xmx1024m    -XX:MaxNewSize=256m”</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cenrise.com/2017/08/18/异常/JasperListener类找不到/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongpo.jia">
      <meta itemprop="description" content="个人博客">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="中起之星">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/18/异常/JasperListener类找不到/" itemprop="url">
                  JasperListener类找不到
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-08-18 09:59:00" itemprop="dateCreated datePublished" datetime="2017-08-18T09:59:00+08:00">2017-08-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-08-21 01:36:00" itemprop="dateModified" datetime="2017-08-21T01:36:00+08:00">2017-08-21</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/异常/" itemprop="url" rel="index"><span itemprop="name">异常</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/异常/tomcat/" itemprop="url" rel="index"><span itemprop="name">tomcat</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#Tomcat java.lang.ClassNotFoundException: org.apache.catalina.core.JasperListener</p>
<p>##问题描述<br>Linux下启动tomcat8.0.45错误，windons下可用。</p>
<p>##原因分析<br>ClassNotFoundException大致可能有两种情况，一是找不到jar包，二是jar包冲突，不知用哪个。</p>
<p>##解决方案<br>JasperListener好像是一个报表支持，目前不需要，可以暂时去掉。<br>在tomcat目录 /conf/server.xml里注释如下内容</p>
<listener classname="org.apache.catalina.core.JasperListener">   </listener>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cenrise.com/2017/08/18/异常/connection_holder_is_null/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongpo.jia">
      <meta itemprop="description" content="个人博客">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="中起之星">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/18/异常/connection_holder_is_null/" itemprop="url">
                  connection_holder_is_null
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-08-18 09:55:00" itemprop="dateCreated datePublished" datetime="2017-08-18T09:55:00+08:00">2017-08-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-08-21 01:36:00" itemprop="dateModified" datetime="2017-08-21T01:36:00+08:00">2017-08-21</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/异常/" itemprop="url" rel="index"><span itemprop="name">异常</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/异常/tomcat/" itemprop="url" rel="index"><span itemprop="name">tomcat</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#java.sql.SQLException: connection holder is null</p>
<p>##问题描述<br>使用druid连接池时出现的间歇性错误，偶尔会出现。</p>
<p>##原因分析<br>连接池可能对连接持有时间有限制，一种保护机制，如果某个连接很长时间不释放，其它应用就没有办法使用这个连接。</p>
<p>##解决方案</p>
<p>###方案一：<br>        延长这个超时时间，默认为300秒（推荐）<br>        <!--是否自动回收超时连接--><br>           <property name="removeAbandoned" value="true"><br>           <!--延长这个所谓的超时时间--><br>           <property name="removeAbandonedTimeout" value="1800"><br>           <!--将当前关闭动作记录到日志--><br>           <property name="logAbandoned" value="true">        </property></property></property></p>
<p>###方案二：<br>        关闭这个超时保护<br>        /<em>直接关闭这个   自动回收超时连接</em>/<br>        <property name="removeAbandoned" value="false"></property></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cenrise.com/2017/08/18/异常/permGen_space_OutOfMemoryError/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongpo.jia">
      <meta itemprop="description" content="个人博客">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="中起之星">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/18/异常/permGen_space_OutOfMemoryError/" itemprop="url">
                  permGen_space_OutOfMemoryError
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-08-18 09:55:00" itemprop="dateCreated datePublished" datetime="2017-08-18T09:55:00+08:00">2017-08-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-08-21 01:36:00" itemprop="dateModified" datetime="2017-08-21T01:36:00+08:00">2017-08-21</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/异常/" itemprop="url" rel="index"><span itemprop="name">异常</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/异常/tomcat/" itemprop="url" rel="index"><span itemprop="name">tomcat</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#Tomcat java.lang.OutOfMemoryError: PermGen space</p>
<p>##问题描述<br>Tomcat 8.0.45在linux环境下启动错误</p>
<p>##原因分析<br>PermGen space是指内存的永久保存区域内存溢出。这块内存主要是JVM来来存放Class和Meta信息的，Class在被Load的时候被放入PermGen space区域，它和存放Instance的Heap区域不同,GC(Garbage Collection)不会在主程序运行期对PermGen space进行清理，所以如果你的APP会LOAD很多CLASS的话，就很可能出现PermGen space错误。这种错误常见在web服务器对JSP进行预编译的时候。如果你的WEB APP下都用了大量的第三方jar, 其大小超过了jvm默认的大小(4M)那么就会产生此错误信息了。</p>
<p>##解决方案<br>手动设置MaxPermSize大小,修改TOMCAT_HOME/bin/catalina.sh<br>JAVA_OPTS=”-server -XX:PermSize=256M -XX:MaxPermSize=1024m”   </p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cenrise.com/2017/06/09/服务/和田市卫浴安装家具安装/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongpo.jia">
      <meta itemprop="description" content="个人博客">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="中起之星">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/09/服务/和田市卫浴安装家具安装/" itemprop="url">
                  和田市卫浴安装家具安装
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-06-09 17:28:00" itemprop="dateCreated datePublished" datetime="2017-06-09T17:28:00+08:00">2017-06-09</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-08-18 09:44:35" itemprop="dateModified" datetime="2017-08-18T09:44:35+08:00">2017-08-18</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/服务/" itemprop="url" rel="index"><span itemprop="name">服务</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#和田市卫浴安装工人<br>朱力<br>电话：139 9943 3811<br>介绍：从事家具（厨柜、床）、卫浴等工作20余年，目前在和田专业从事安具、厨卫安装、销售服务。</p>
<p>#和田市卫浴家具安装工人<br>朱力<br>电话：139 9943 3811<br>介绍：从事家具（厨柜、床）、卫浴等工作20余年，目前在和田专业从事安具、厨卫安装、销售服务。</p>
<h1 id="可以接收什么类型的工作"><a href="#可以接收什么类型的工作" class="headerlink" title="可以接收什么类型的工作"></a>可以接收什么类型的工作</h1><p>1.家具安装，包含床、柜子、书桌等。<br>2.卫浴安装<br>3.品牌家具销售  </p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cenrise.com/2017/05/30/review/Sonar代码审查-缺陷和修改/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongpo.jia">
      <meta itemprop="description" content="个人博客">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="中起之星">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/30/review/Sonar代码审查-缺陷和修改/" itemprop="url">
                  Sonar代码审查-缺陷和修改
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-05-30 16:43:49" itemprop="dateCreated datePublished" datetime="2017-05-30T16:43:49+08:00">2017-05-30</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-05-30 17:38:07" itemprop="dateModified" datetime="2018-05-30T17:38:07+08:00">2018-05-30</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/review/" itemprop="url" rel="index"><span itemprop="name">review</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Sonar代码审查-缺陷和修改"><a href="#Sonar代码审查-缺陷和修改" class="headerlink" title="Sonar代码审查-缺陷和修改"></a>Sonar代码审查-缺陷和修改</h2><p>Resources should be closed<br>资源未关闭，打开发现有两处用到的IO流没有关闭</p>
<p>Conditions should not unconditionally evaluate to “TRUE” or to “FALSE”<br>if/else判断里出现了重复判断，比如在if(a&gt;10)的执行体里面又判断if(a&lt;0)，而后者肯定不会是true</p>
<p>Exception handlers should preserve the original exception<br>处理异常的时候应该保留原始的异常情况，不要直接来个catch(Exception e)了事</p>
<p> Throwable.printStackTrace(…) should not be called<br>不应该直接调用e.printStackTrace()，而是用Loggers来处理（就是打Log）。</p>
<p>Loggers的优势是：Users are able to easily retrieve the logs.<br>The format of log messages is uniform and allow users to browse the logs easily.<br>Instance methods should not write to “static” fields6<br>不要用实例方法改变静态成员，理想情况下，静态变量只通过同步的静态方法来改变</p>
<p>“public static” fields should be constant<br>公共静态成员应该加上final，也就是public static final 一般不分家</p>
<p>Thread.run() and Runnable.run() should not be called directly<br>不应该直接调用Thread和Runnaale对象的run方法，直接调用run会使得run方法执行在当前线程，失去了开启新线程的意义。但有时候可能会这样做，下面有个例子。</p>
<p>Generic exceptions should never be thrown<br>不太理解，大意是说不要直接抛Error,RuntimeException/Throwable/Exception这样的通用的异常。我的具体应用是：throw new Error(“Error copying database”)，给出的建议是：Define and throw a dedicated exception instead of using a generic one（定义并抛出一个专用的异常来代替一个通用的异常）</p>
<p>Class variable fields should not have public accessibility<br>类变量不要设置为public，而是设为private，再提供get和set方法。</p>
<p>Sections of code should not be “commented out”<br>不要再注释中出现大量的代码段，会使代码可读性变差</p>
<p>Package declaration should match source file directory<br>这个没理解，包的声明应该与源文件目录匹配。</p>
<p>Utility classes should not have public constructors<br>工具类不应该有公共的构造器，也就是说至少要有一个private的构造器，如果没有，默认的构造器是public的。</p>
<p>The diamond operator (“&lt;&gt;”) should be used<br>在定义集合的时候，等号右边的&lt;&gt;内不需要再写上元素类型，直接空着就行。</p>
<p>Lambdas and anonymous classes should not have too many lines<br>Lambdas表达式和匿名内部类不要写太多行，一般最多写20行。</p>
<p>Anonymous inner classes containing only one method should become lambdas8<br>只包含一个方法的匿名内部类应该写成Lambdas表达式的形式，增强代码可读性</p>
<p>Try-with-resources should be used8<br>用Try-with-resources的形式取代try/catch/finally的形式，这个有待于以后学习。<br><figure class="highlight plain"><figcaption><span>con </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   try (PreparedStatement prep = con.prepareConnection(&quot;Update ...&quot;)) &#123;</span><br><span class="line">       //prep.doSomething();</span><br><span class="line">       //...</span><br><span class="line">       //etc</span><br><span class="line">con.commit();</span><br><span class="line">   &#125; catch (SQLException e) &#123;</span><br><span class="line">       //any other actions necessary on failure</span><br><span class="line">       con.rollback();</span><br><span class="line">       //consider a re-throw, throwing a wrapping exception, etc</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Methods should not be empty<br>不要写空方法，除非这种情况：An abstract class may have empty methods, in order to provide default implementations for child classes.</p>
<p>Source files should not have any duplicated blocks<br>源文件中不要出现任何重复的代码段或行或字符串等。没理解。</p>
<p>“switch case” clauses should not have too many lines<br>“switch case” 每个case里面的代码不要太长，太长的话可以考虑写个方法代替，主要是为了增强代码可读性</p>
<p>Nested blocks of code should not be left empty<br>嵌套代码块不要是空的，比如 if( a &gt; 0 ) {  doSomething()  } else { }，这时候应该把后面的else{}去掉。</p>
<p>Methods should not be too complex<br>方法不要太复杂，否则难以理解和维护。</p>
<p>Unused private fields should be removed<br>没有使用的private的成员变量应该移除掉。</p>
<p>Dead stores should be removed<br>没有用到的本地变量或其他死存储应该移除掉，也就是写方法的时候，定义的变量如果后来发现根本用不到，要记得删掉那行代码。</p>
<p>“switch” statements should end with a “default” clause<br>switch语句应该以default结束，这是一种defensive programming思想</p>
<p>Unused method parameters should be removed<br>没有用到的方法参数应该移除掉</p>
<p>Control flow statements “if”, “for”, “while”, “switch” and “try” should not be nested too deeply4<br>if /for/while/try这样的嵌套不要太复杂</p>
<p>Useless parentheses around expressions should be removed to prevent any misunderstanding3<br>没有意义的括号不要随便加，以免造成误解，比如”=”两边对象类型是相同的，就不要强转。</p>
<p>“for” loop stop conditions should be invariant<br>for循环的结果条件不能是变量，而应该是常量</p>
<p>“static” members should be accessed statically<br>static成员是与类、静态方法相联系的。</p>
<p>Catches should be combined<br>具体参考下面的18，我还没理解</p>
<p>Primitives should not be boxed just for “String” conversion<br>不要使用 4+” “这样的方式将int值转变为字符串，而是使用 Integer.toString(4)这样的方式。<br>就像Integer.parseInt(“我是字符串”)这样，不要偷懒。</p>
<p>Classes should not be empty<br>不要写空类</p>
<p>Unused local variables should be removed<br>没有用到的本地变量要删掉</p>
<p>“entrySet()” should be iterated when both the key and value are needed<br>直接看英文更直接：When only the keys from a map are needed in a loop, iterating the keySet makes sense. But when both the key and the value are needed, it’s more efficient to iterate theentrySet, which will give access to both the key and value, instead.<br>也就是说，如果只需要Map的Key，那么直接iterate这个Map的keySet就可以了，但是如果Key和value都需要，就iterate这个Map。具体看下面的19.</p>
<p>Method parameters, caught exceptions and foreach variables should not be reassigned<br>方法参数/捕获的异常/foreach的变量不应该被重新赋值。</p>
<p>Collection.isEmpty() should be used to test for emptiness<br>当判断集合是否为空的时候，不要使用if (myCollection.size() == 0) 这样的方式，而是使用if (myCollection.isEmpty()这样的方式，后者性能更高。</p>
<p>Standard outputs should not be used directly to log anything<br>标准输出不直接打印任何东西，也就是打log的时候，不要使用System.out.println(“My Message”)这样的方式，而是使用logger.log(“My Message”)这种方式。</p>
<p>Generic wildcard types should not be used in return parameters<br>通配符不应该出现在返回声明中。比如这句：List &lt;? extends Animal&gt;getAnimals(){…}， 我们无法知道“是否可以把a Dog, a Cat 等加进去”，等之后用到这个方法的时候，我们没必要去考虑这种问题（前面引号里面的）。</p>
<p>Synchronized classes Vector, Hashtable, Stack and StringBuffer should not be used1<br>不要使用同步的Vector/HashTable/Stack/StringBuffer等。在早期，出于线程安全问题考虑，java API 提供了这些类。但是同步会极大影响性能，即使是在同一个线程中使用他们。<br>通常可以这样取代：<br><code>ArrayList  or  LinkedList   instead of  Vector
Deque  instead of  Stack
HashMap  instead of  Hashtable
StringBuilder  instead of  StringBuffer
Exit methods should not be called</code><br>尽量不要调用system.exit()方法。</p>
<p>Local Variables should not be declared and then immediately returned or thrown<br>本地变量如果赋值之后直接return了，那就直接return本地变量的赋值语句。</p>
<p>Field names should comply with a naming convention<br>命名要规范</p>
<p>Local variable and method parameter names should comply with a naming convention<br>命名要规范</p>
<p>String literals should not be duplicated5<br>字符串不应该重复，如果多次用到同一字符串，建议将该字符串定义为字符串常量，再引用。</p>
<p>Return of boolean expressions should not be wrapped into an “if-then-else” statement3<br>不要写if (  a &gt; 4  ) {  return false  } else { return true }这样的代码，直接写return a &gt; 4。</p>
<p>Static non-final field names should comply with a naming convention<br>命名要规范</p>
<p>Modifiers should be declared in the correct order<br>修饰符等要按约定俗成的顺序书写 ，例如，写成public static 而不是static public </p>
<p>The members of an interface declaration or class should appear in a pre-defined order2<br>与前面的一个问题类似，根据Oracle定义的Java代码规范中，不同代码的出现位置应该如下所示：<br>class and instance variables–Constructors–Methods</p>
<p>Array designators “[]” should be on the type, not the variable<br>数组的括号要写在类型后面，而不是变量后面，例如 int[] a 而不是int a[]</p>
<p>Multiple variables should not be declared on the same line1<br>不要在同一行定义多个变量</p>
<p>“switch” statements should have at least 3 “case” clauses<br>当至少有3种或者3种以上的情况时，才考虑用switch，否则用if/else的形式。</p>
<p>Overriding methods should do more than simply call the same method in the super class<br>既然在子类中重写了父类的某个方法，那就再这个方法中做些与父类方法不同的事情，否则没必要重写。</p>
<p>Statements should be on separate lines<br>不要把这样的代码写在同一行：if(someCondition)    doSomething()；而是应该写成下面的形式<br>if(someCondition) {<br>doSomething()<br>}<br>Method names should comply with a naming convention1<br>命名要规范<br>“TODO” tags should be handle    TODO标签要及时处理，该做的事情不要忘了做</p>
<h2 id="部分规则详细说明"><a href="#部分规则详细说明" class="headerlink" title="部分规则详细说明"></a>部分规则详细说明</h2><h4 id="1-The-members-of-an-interface-declaration-or-class-should-appear-in-a-pre-defined-order"><a href="#1-The-members-of-an-interface-declaration-or-class-should-appear-in-a-pre-defined-order" class="headerlink" title="1.The members of an interface declaration or class should appear in a pre-defined order"></a>1.The members of an interface declaration or class should appear in a pre-defined order</h4><p>正确的顺序如下所示：静态成员变量→成员变量→构造器→方法</p>
<figure class="highlight plain"><figcaption><span>class Foo&#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static final int OPEN = 4;  //Class and instance variables</span><br><span class="line">private int field = 0;</span><br><span class="line">public Foo() &#123;...&#125;    //Constructors</span><br><span class="line">public boolean isTrue() &#123;...&#125;    //Methods</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-The-diamond-operator-“-lt-gt-”-should-be-used"><a href="#2-The-diamond-operator-“-lt-gt-”-should-be-used" class="headerlink" title="2.The diamond operator (“&lt;&gt;”) should be used"></a>2.The diamond operator (“&lt;&gt;”) should be used</h4><p>Noncompliant Code Example：不规范的示例</p>
<figure class="highlight plain"><figcaption><span>strings </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;Integer&gt;&gt; map = new HashMap&lt;String, List&lt;Integer&gt;&gt;();  // Noncompliant</span><br><span class="line">Compliant Solution ：规范的示例</span><br><span class="line">List&lt;String&gt; strings = new ArrayList&lt;&gt;();</span><br><span class="line">Map&lt;String, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>
<h4 id="3-Sections-of-code-should-not-be-“commented-out”"><a href="#3-Sections-of-code-should-not-be-“commented-out”" class="headerlink" title="3.Sections of code should not be “commented out”"></a>3.Sections of code should not be “commented out”</h4><p>代码片段不应该出现在注释中，这样会bloat程序，可读性变差<br><code>Programmers should not comment out code as it bloats programs and reduces readability.
Unused code should be deleted and can be retrieved from source control history if required.</code></p>
<h4 id="4-Utility-classes-should-not-have-public-constructors"><a href="#4-Utility-classes-should-not-have-public-constructors" class="headerlink" title="4.Utility classes should not have public constructors"></a>4.Utility classes should not have public constructors</h4><p>工具类不应该有public的构造器，也就是工具类至少要定义一个non-public的构造器<br>Utility classes, which are a collection of static members, are not meant to be instantiated. Even abstract utility classes, which can be extended, should not have public constructors.<br>Java adds an implicit public constructor to every class which does not define at least one explicitly. Hence, at least one non-public constructor should be defined.</p>
<figure class="highlight plain"><figcaption><span>StringUtils &#123;</span><a href="//">Noncompliant Code Example</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    public static String concatenate(String s1, String s2) &#123;</span><br><span class="line">          return s1 + s2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><figcaption><span>StringUtils &#123;</span><a href="//Compliant">Solution</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    private StringUtils() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public static String concatenate(String s1, String s2) &#123;</span><br><span class="line">    return s1 + s2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-”public-static”-fields-should-be-constant"><a href="#5-”public-static”-fields-should-be-constant" class="headerlink" title="5.”public static” fields should be constant"></a>5.”public static” fields should be constant</h4><p>公共的静态成员应该加上final来修饰<br>There is no good reason to declare a field “public” and “static” without also declaring it “final”. Most of the time this is a kludge to share a state among several objects. But with this approach, any object can do whatever it wants with the shared state, such as setting it to null.<br>public static Foo foo = new Foo();//不规范的<br>public static final Foo FOO = new Foo();//规范的</p>
<p>6.Class variable fields should not have public accessibility</p>
<figure class="highlight plain"><figcaption><span>class MyClass &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static final int SOME_CONSTANT = 0;    // Compliant - constants are not checked</span><br><span class="line">public String firstName;                      // Noncompliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><figcaption><span>class MyClass &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static final int SOME_CONSTANT = 0;    // Compliant - constants are not checked</span><br><span class="line">private String firstName;                      // Compliant</span><br><span class="line">public String getFirstName() &#123;</span><br><span class="line">return firstName;</span><br><span class="line">&#125;</span><br><span class="line">public void setFirstName(String firstName) &#123;</span><br><span class="line">this.firstName = firstName;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">#### 7.Static non-final field names should comply with a naming convention</span><br><span class="line">public final class MyClass &#123;//Noncompliant Code Example</span><br><span class="line">      private static String foo_bar;</span><br><span class="line">&#125;</span><br><span class="line">class MyClass &#123;//Compliant Solution</span><br><span class="line">private static String fooBar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-”switch”-statements-should-have-at-least-3-“case”-clauses"><a href="#8-”switch”-statements-should-have-at-least-3-“case”-clauses" class="headerlink" title="8.”switch” statements should have at least 3 “case” clauses"></a>8.”switch” statements should have at least 3 “case” clauses</h4><p>当有3种或3种情况以上的时候，才用switch，否则用if/else<br>switch statements are useful when there are many different cases depending on the value of the same expression.<br>For just one or two cases however, the code will be more readable with if statements.</p>
<h4 id="9-String-literals-should-not-be-duplicated"><a href="#9-String-literals-should-not-be-duplicated" class="headerlink" title="9.String literals should not be duplicated"></a>9.String literals should not be duplicated</h4><figure class="highlight plain"><figcaption><span> </span><a href="//">Noncompliant - "action1" is duplicated 3 times</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">execute(&quot;action1&quot;);</span><br><span class="line">release(&quot;action1&quot;);</span><br><span class="line"></span><br><span class="line">private static final String ACTION_1 = &quot;action1&quot;;  // Compliant</span><br><span class="line">prepare(ACTION_1);                                            // Compliant</span><br><span class="line">execute(ACTION_1);</span><br><span class="line">release(ACTION_1);</span><br></pre></td></tr></table></figure>
<h4 id="10-Return-of-boolean-expressions-should-not-be-wrapped-into-an-“if-then-else”-statement"><a href="#10-Return-of-boolean-expressions-should-not-be-wrapped-into-an-“if-then-else”-statement" class="headerlink" title="10.Return of boolean expressions should not be wrapped into an “if-then-else” statement"></a>10.Return of boolean expressions should not be wrapped into an “if-then-else” statement</h4><p>Replace this if-then-else statement by a single return statement</p>
<figure class="highlight plain"><figcaption><span>(expression) &#123;//Noncompliant Code Example</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">      return true;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">     return false;</span><br><span class="line">&#125;</span><br><span class="line">return expression;//Compliant Solution</span><br><span class="line">return !!expression;</span><br></pre></td></tr></table></figure>
<h4 id="11-Method-parameters-caught-exceptions-and-foreach-variables-should-not-be-reassigned"><a href="#11-Method-parameters-caught-exceptions-and-foreach-variables-should-not-be-reassigned" class="headerlink" title="11.Method parameters, caught exceptions and foreach variables should not be reassigned"></a>11.Method parameters, caught exceptions and foreach variables should not be reassigned</h4><p>方法参数，捕获的异常，foreach里的变量，都不应该重新赋值</p>
<figure class="highlight plain"><figcaption><span>MyClass &#123;//Noncompliant Code Example：不规范代码示例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    public String name;</span><br><span class="line">    public MyClass(String name) &#123;</span><br><span class="line">            name = name;          // Noncompliant - useless identity assignment</span><br><span class="line">    &#125;</span><br><span class="line">    public int add(int a, int b) &#123;</span><br><span class="line">        a = a + b;                // Noncompliant</span><br><span class="line">        return a;                 // Seems like the parameter is returned as is, what is the point?</span><br><span class="line">   &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyClass foo = new MyClass();</span><br><span class="line">        int a = 40;</span><br><span class="line">        int b = 2;</span><br><span class="line">        foo.add(a, b);                  // Variable &quot;a&quot; will still hold 40 after this call</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><figcaption><span>MyClass &#123;//Compliant Solution：规范代码示例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    public String name;</span><br><span class="line">    public MyClass(String name) &#123;</span><br><span class="line">         this.name = name;              // Compliant</span><br><span class="line">    &#125;</span><br><span class="line">    public int add(int a, int b) &#123;</span><br><span class="line">        return a + b;                  // Compliant</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    MyClass foo = new MyClass();</span><br><span class="line">        int a = 40;</span><br><span class="line">        int b = 2;</span><br><span class="line">        foo.add(a, b);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="12-Local-Variables-should-not-be-declared-and-then-immediately-returned-or-thrown"><a href="#12-Local-Variables-should-not-be-declared-and-then-immediately-returned-or-thrown" class="headerlink" title="12.Local Variables should not be declared and then immediately returned or thrown"></a>12.Local Variables should not be declared and then immediately returned or thrown</h4><p>Noncompliant Code Example：不规范代码示例</p>
<figure class="highlight plain"><figcaption><span>long computeDurationInMilliseconds() &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">long duration = (((hours * 60) + minutes) * 60 + seconds ) * 1000 ;</span><br><span class="line">return duration;</span><br><span class="line">&#125;</span><br><span class="line">public void doSomething() &#123;</span><br><span class="line">RuntimeException myException = new RuntimeException();</span><br><span class="line">throw myException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Compliant Solution：规范代码示例</p>
<figure class="highlight plain"><figcaption><span>long computeDurationInMilliseconds() &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">return (((hours * 60) + minutes) * 60 + seconds ) * 1000 ;</span><br><span class="line">&#125;</span><br><span class="line">public void doSomething() &#123;</span><br><span class="line">throw new RuntimeException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="13-Thread-run-and-Runnable-run-should-not-be-called-directly"><a href="#13-Thread-run-and-Runnable-run-should-not-be-called-directly" class="headerlink" title="13.Thread.run() and Runnable.run() should not be called directly"></a>13.Thread.run() and Runnable.run() should not be called directly</h4><p>The purpose of theThread.run()andRunnable.run()methods is to execute code in a separate, dedicated thread. Calling those methods directly doesn’t make sense because it causes their code to be executed in the current thread.<br>Thread和Runnable里面的run方法设计的目的是让run方法里面的代码在不同的线程中执行。如果直接调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Noncompliant Code Example：不规范的代码示例</span><br><span class="line">Thread myThread = new Thread(runnable);</span><br><span class="line">myThread.run(); // Noncompliant</span><br><span class="line"></span><br><span class="line">Compliant Solution：规范代码示例</span><br><span class="line">Thread myThread = new Thread(runnable);</span><br><span class="line">myThread.start(); // Compliant</span><br></pre></td></tr></table></figure></p>
<p>这部分内容为个人理解，可以略过<br>但在有些情况，也会直接调用Runnable的run方法，<br>下面这个postTaskSafely方法会保证task永远在主线程中执行</p>
<figure class="highlight plain"><figcaption><span>static void postTaskInMainThread(Runnable task) &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">     int curThreadId= android.os.Process.myTid();//得到当前线程的id</span><br><span class="line">    if(curThreadId==getMainThreadId()) &#123;// 如果当前线程是主线程</span><br><span class="line">            task.run();//直接执行</span><br><span class="line">    &#125;else&#123;// 如果当前线程不是主线程</span><br><span class="line">        getMainThreadHandler().post(task);//用主线程的Handler来post</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="14-Lambdas-and-anonymous-classes-should-not-have-too-many-lines"><a href="#14-Lambdas-and-anonymous-classes-should-not-have-too-many-lines" class="headerlink" title="14.Lambdas and anonymous classes should not have too many lines"></a>14.Lambdas and anonymous classes should not have too many lines</h4><p>Anonymous classes and lambdas (with Java 8) are a very convenient and compact way to inject a behavior without having to create a dedicated class. But those anonymous inner classes and lambdas should be used only if the behavior to be injected can be defined in a few lines of code, otherwise the source code can quickly become unreadable.<br>anonymous class number of lines ： at most 20</p>
<h4 id="15-Resources-should-be-closed：该关闭的一定记得关闭"><a href="#15-Resources-should-be-closed：该关闭的一定记得关闭" class="headerlink" title="15.Resources should be closed：该关闭的一定记得关闭"></a>15.Resources should be closed：该关闭的一定记得关闭</h4><p>Java’s garbage collection cannot be relied on to clean up everything. Specifically, connections, streams, files and other classes that implement theCloseableinterface or it’s super-interface,AutoCloseable, must be manually closed after creation. Failure to do so will result in a resource leak which could bring first the application and then perhaps the box it’s on to their knees.<br>Noncompliant Code Example：不规范的代码示例</p>
<figure class="highlight plain"><figcaption><span>stream </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    for (String property : propertyList) &#123;</span><br><span class="line">    stream = new FileOutputStream(&quot;myfile.txt&quot;);  // Noncompliant</span><br><span class="line">    // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;catch(Exception e)&#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">    stream.close();  // Multiple streams were opened. Only the last is closed.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Compliant Solution：规范代码示例</p>
<figure class="highlight plain"><figcaption><span>stream </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> try&#123;</span><br><span class="line">     stream = new FileOutputStream(&quot;myfile.txt&quot;);</span><br><span class="line">     for (String property : propertyList) &#123;</span><br><span class="line">         // ...</span><br><span class="line">     &#125;</span><br><span class="line">&#125;catch(Exception e)&#123;</span><br><span class="line">     // ...</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">    stream.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="16-Exception-handlers-should-preserve-the-original-exception"><a href="#16-Exception-handlers-should-preserve-the-original-exception" class="headerlink" title="16.Exception handlers should preserve the original exception"></a>16.Exception handlers should preserve the original exception</h4><p>Noncompliant Code Example:不规范的代码示例<br>// Noncompliant - exception is lost<br>try { /<em> … </em>/ } catch (Exception e) { LOGGER.info(“context”); }<br>// Noncompliant - exception is lost (only message is preserved)<br>try { /<em> … </em>/ } catch (Exception e) { LOGGER.info(e.getMessage()); }<br>// Noncompliant - exception is lost<br>try { /<em> … </em>/ } catch (Exception e) { throw new RuntimeException(“context”); }</p>
<p>Compliant Solution:规范的代码示例</p>
<figure class="highlight plain"><figcaption><span>&#123;</span><a href="/*">... */ &#125; catch (Exception e) &#123; LOGGER.info(e); &#125;</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try &#123; /* ... */ &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125;</span><br><span class="line">try &#123;</span><br><span class="line">/* ... */</span><br><span class="line">&#125; catch (RuntimeException e) &#123;</span><br><span class="line">doSomething();</span><br><span class="line">throw e;</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">// Conversion into unchecked exception is also allowed</span><br><span class="line">throw new RuntimeException(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="17-Catches-should-be-combined"><a href="#17-Catches-should-be-combined" class="headerlink" title="17.Catches should be combined"></a>17.Catches should be combined</h4><p>Since Java 7 it has been possible to catch multiple exceptions at once. Therefore, when multiplecatchblocks have the same code, they should be combined for better readability.<br>Note that this rule is automatically disabled when the project’ssonar.java.sourceis lower than7.</p>
<p>Noncompliant Code Example：不规范代码示例</p>
<figure class="highlight plain"><figcaption><span>(IOException e) &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    doCleanup();</span><br><span class="line">    logger.log(e);</span><br><span class="line">&#125;catch (SQLException e) &#123; //Noncompliant</span><br><span class="line">    doCleanup();</span><br><span class="line">    logger.log(e);</span><br><span class="line"> &#125;catch (TimeoutException e) &#123;  // Compliant; block contents are different</span><br><span class="line">     doCleanup();</span><br><span class="line">     throw e;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>Compliant Solution：规范代码示例</p>
<figure class="highlight plain"><figcaption><span>(IOException|SQLException e) &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    doCleanup();</span><br><span class="line">    logger.log(e);</span><br><span class="line"> &#125;catch (TimeoutException e) &#123;</span><br><span class="line">    doCleanup();</span><br><span class="line">    throw e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>18.”entrySet()” should be iterated when both the key and value are needed<br>Noncompliant Code Example：不规范的代码示例</p>
<figure class="highlight plain"><figcaption><span>void doSomethingWithMap(Map map) &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (String key : map.keySet()) &#123;  // Noncompliant; for each key the value is retrieved</span><br><span class="line">Object value = map.get(key);</span><br><span class="line">// ...</span><br><span class="line">&#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Compliant SolutionL：规范代码示例</p>
<figure class="highlight plain"><figcaption><span>void doSomethingWithMap(Map map) &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (Map.Entry entry : map.entrySet()) &#123;</span><br><span class="line">String key = entry.getKey();</span><br><span class="line">Object value = entry.getValue();</span><br><span class="line">// ...</span><br><span class="line">&#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Use a logger to log this exception<br>You should probably clarify which logger are you using.</p>
<p>org.apache.commons.logging.Log interface has method void error(Object message, Throwable t) (and method void info(Object message, Throwable t)), which logs the stack trace together with your custom message. Log4J implementation has this method too.</p>
<p>So, probably you need to write:<br>logger.error(“BOOM!”, e);<br>If you need to log it with INFO level (though, it might be a strange use case), then:<br>logger.info(“Just a stack trace, nothing to worry about”, e);<br>Hope it helps.</p>
<p>Rename ‘i’ as this name is already used in declaration at line 26</p>
<h2 id="阻断"><a href="#阻断" class="headerlink" title="阻断"></a>阻断</h2><h4 id="1、Close-this”FileInputStream”-in-a-“finally”-clause"><a href="#1、Close-this”FileInputStream”-in-a-“finally”-clause" class="headerlink" title="1、Close this”FileInputStream” in a “finally” clause."></a>1、Close this”FileInputStream” in a “finally” clause.</h4><p>在finally中关闭FileInputStream，这个最为常见，主要是关闭方式不对，finally代码块中，应该要对每个stream进行单独关闭，而不能统一写在一个try-catch代码中，jdk 7 可以考虑try-resources方式关闭，代码相对优雅。<br>另外数据库操作的statement和resultRs没有关闭的情况也非常多。这个也是要重点留意的地方。</p>
<h4 id="2、A”NullPointerException”-could-be-thrown-“tom”-is-nullablehere"><a href="#2、A”NullPointerException”-could-be-thrown-“tom”-is-nullablehere" class="headerlink" title="2、A”NullPointerException” could be thrown; “tom” is nullablehere"></a>2、A”NullPointerException” could be thrown; “tom” is nullablehere</h4><p>空指针，极为讨厌的问题，主要是编码经验缺少的体现。一般的高手在编码过程中，就会第一时间考虑到这类情况，并做相应的处理。解决方式无它，先判断或者先实例化，再访问里面的属性或者成员。</p>
<h2 id="严重"><a href="#严重" class="headerlink" title="严重"></a>严重</h2><h4 id="1、Define-and-throw-a-dedicated-exception-instead-of-using-a-generic-one"><a href="#1、Define-and-throw-a-dedicated-exception-instead-of-using-a-generic-one" class="headerlink" title="1、Define and throw a dedicated exception instead of using a generic one"></a>1、Define and throw a dedicated exception instead of using a generic one</h4><p>定义并抛出一个专用的异常来代替一个通用的异常。</p>
<h4 id="2、Removethis-hard-coded-password"><a href="#2、Removethis-hard-coded-password" class="headerlink" title="2、Removethis hard-coded password"></a>2、Removethis hard-coded password</h4><p>移除代码里硬编码的密码信息。会有少许的误判的情况，一般是变量包含：PWD或者password，所以如果真的不是硬编码，可以考虑更换变量名称，比如PWD改PW等等。</p>
<h4 id="3、Eitherlog-or-rethrow-this-exception"><a href="#3、Eitherlog-or-rethrow-this-exception" class="headerlink" title="3、Eitherlog or rethrow this exception"></a>3、Eitherlog or rethrow this exception</h4><p>catch异常之后，使用log方式或者throw异常的方式解决。如果业务上真的没有throw或者记录日志的话，可以使用log.debug的方式填充来解决问题。</p>
<h4 id="4、Makethis-IP-“127-0-0-1”-address-configurable"><a href="#4、Makethis-IP-“127-0-0-1”-address-configurable" class="headerlink" title="4、Makethis IP “127.0.0.1” address configurable"></a>4、Makethis IP “127.0.0.1” address configurable</h4><p>将IP弄到配置文件中，不要硬编码到代码里。个人觉得改动稍大！</p>
<h4 id="5、Make-this”public-static-JSAPI”-field-final"><a href="#5、Make-this”public-static-JSAPI”-field-final" class="headerlink" title="5、Make this”public static JSAPI” field final"></a>5、Make this”public static JSAPI” field final</h4><p>如果你将这个变量设置为public访问方式，同时又是静态Static方式，就要考虑将它设置为final了，因为这个是共享变量，其它类可以随时随地将它设置为别的值。所以如果是只是当前类使用，可以考虑将公开访问方式改为私有。</p>
<h4 id="6、Makethe-enclosing-method-“static”-or-remove-this-set"><a href="#6、Makethe-enclosing-method-“static”-or-remove-this-set" class="headerlink" title="6、Makethe enclosing method “static” or remove this set"></a>6、Makethe enclosing method “static” or remove this set</h4><p>见代码：</p>
<figure class="highlight plain"><figcaption><span>class MyClass &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  private static int count = 0;</span><br><span class="line">  public void doSomething() &#123;</span><br><span class="line">    //...</span><br><span class="line">    count++;  // Noncompliant</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">```不要使用非静态方法去更新静态字段，这样很难获得正确的结果，如果有多个类实例和/或多个线程，则很容易导致错误。理想情况下，静态字段仅从同步静态方法中更新。</span><br><span class="line">#### 7、Override&quot;equals(Object obj)&quot; to comply with the contract of the&quot;compareTo(T o)&quot; method</span><br><span class="line">如果重写了compareTo方法，同时也应重写equals方法。</span><br><span class="line">#### 8、Make&quot;body&quot; transient or serializable.</span><br><span class="line"></span><br><span class="line">```public class Address &#123;</span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br><span class="line">public class Person implements Serializable &#123;</span><br><span class="line">  private static final long serialVersionUID = 1905122041950251207L;</span><br><span class="line">  private String name;</span><br><span class="line"></span><br><span class="line">  private Address address;  // Noncompliant; Address isn&apos;t serializable</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果person已经序列化，其成员变量Address也进行序列化。不然转化时会有问题。</p>
<h4 id="9-Floating-point-numbers-should-not-be-tested-for-equality"><a href="#9-Floating-point-numbers-should-not-be-tested-for-equality" class="headerlink" title="9 Floating point numbers should not be tested for equality"></a>9 Floating point numbers should not be tested for equality</h4><p>浮点类型的数字，不要通过==或者!=方式其它类型比较，因为浮点是不精确的，所以在比较时，会进行类型升级升级原则如下：<br>·  如果运算符任意一方的类型为double，则另一方会转换为double<br>·  否则，如果运算符任意一方的类型为float，则另一方会转换为float<br>·  否则，如果运算符任意一方的类型为long，则另一方会转换为long<br>·  否则，两边都会转换为int</p>
<p>以下的方式得到的结果都是false。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">float myNumber = 3.146;</span><br><span class="line">if ( myNumber == 3.146f ) &#123; //Noncompliant. Because of floating point imprecision, this will be false</span><br><span class="line"> </span><br><span class="line">if ( myNumber != 3.146f ) &#123; //Noncompliant. Because of floating point imprecision, this will be true</span><br><span class="line">if (myNumber &lt; 4 || myNumber &gt; 4) &#123; // Noncompliant; indirect  </span><br><span class="line">float zeroFloat = 0.0f;</span><br><span class="line">if (zeroFloat == 0) &#123;  // Noncompliant. Computations may end up with a value close but not equal to zero.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，要比较浮点数是否相等，需要做的事情是：</p>
<pre><code>排除NaN和无穷

在精度范围内进行比较
</code></pre><p>正确的例子：</p>
<figure class="highlight plain"><figcaption><span>boolean isEqual(double a, double b) &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    if (Double.isNaN(a) || Double.isNaN(b) || Double.isInfinite(a) || Double.isInfinite(b)) &#123;</span><br><span class="line">       return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return (a - b) &lt; 0.001d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="10、Thiscall-to-“contains-”-may-be-a-performance-hot-spot-if-the-collectionis-large"><a href="#10、Thiscall-to-“contains-”-may-be-a-performance-hot-spot-if-the-collectionis-large" class="headerlink" title="10、Thiscall to “contains()” may be a performance hot spot if the collectionis large."></a>10、Thiscall to “contains()” may be a performance hot spot if the collectionis large.</h4><p>如果collection的记录数非常大的话，它的contains方法的时间复杂度是很高的。所以开发过程中要注意这一点。下面的是列表：</p>
<figure class="highlight plain"><figcaption><span>ArrayList</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">contains</span><br><span class="line">remove</span><br><span class="line">·  LinkedList</span><br><span class="line"></span><br><span class="line">get</span><br><span class="line">contains</span><br><span class="line">·  ConcurrentLinkedQueue</span><br><span class="line"></span><br><span class="line">size</span><br><span class="line">contains</span><br><span class="line">·  ConcurrentLinkedDeque</span><br><span class="line"></span><br><span class="line">size</span><br><span class="line">contains</span><br><span class="line">·  CopyOnWriteArrayList</span><br><span class="line"></span><br><span class="line">add</span><br><span class="line">contains</span><br><span class="line">remove</span><br><span class="line">·  CopyOnWriteArraySet</span><br><span class="line"></span><br><span class="line">add</span><br><span class="line">contains</span><br><span class="line">remove</span><br></pre></td></tr></table></figure>
<h5 id="1-Equality-tests-should-not-be-made-with-floating-point-value"><a href="#1-Equality-tests-should-not-be-made-with-floating-point-value" class="headerlink" title="1.Equality tests should not be made with floating point value"></a>1.Equality tests should not be made with floating point value</h5><p>　　代码举例： if (result == num) //result和num均为double 之间比较会有精度损失<br>　　解决：BigDecimal data1 = new BigDecimal(totalArea);<br>　　　　　BigDecimal data2 = new BigDecimal(s1);<br>　　　　    int num = data1.compareTo(data2);//num =0 相等  &gt;0前者大于后者 ，反之 &lt;0 前者小于后者</p>
<h5 id="2-This-class-overrides-“equals-”-and-should-therefore-also-override-“hashCode-”"><a href="#2-This-class-overrides-“equals-”-and-should-therefore-also-override-“hashCode-”" class="headerlink" title="2.This class overrides “equals()” and should therefore also override “hashCode()”.　"></a>2.This class overrides “equals()” and should therefore also override “hashCode()”.　</h5><p>　　代码举例：public boolean equals(Object obj){…}  //需要添加对应的hashCode方法<br>　　解决：可以添加一个最简单的hashCode方法　　<br>　　　　　public int hashCode() {return 0;}　　　</p>
<h5 id="3-Synchronize-on-a-new-“Object”-instead"><a href="#3-Synchronize-on-a-new-“Object”-instead" class="headerlink" title="3.Synchronize on a new “Object” instead"></a>3.Synchronize on a new “Object” instead</h5><p>　　代码举例：synchronized (“实例化”) {…}   //里边必须是对象<br>　　解决： private Object obj =”实例化”；<br>　　　　　synchronized (obj ) {…}</p>
<h5 id="4-Close-this”FileInputStream”-in-a-“finally”-clause"><a href="#4-Close-this”FileInputStream”-in-a-“finally”-clause" class="headerlink" title="4.Close this”FileInputStream” in a “finally” clause."></a>4.Close this”FileInputStream” in a “finally” clause.</h5><p>　　解决方法: 在finally中关闭FileInputStream，主要是关闭方式不对，finally代码块中，应该要对每个stream进行单独关闭，而不能统一写在一个try-catch代码中。</p>
<h5 id="5-A”NullPointerException”-could-be-thrown-“tom”-is-nullablehere"><a href="#5-A”NullPointerException”-could-be-thrown-“tom”-is-nullablehere" class="headerlink" title="5.A”NullPointerException” could be thrown; “tom” is nullablehere"></a>5.A”NullPointerException” could be thrown; “tom” is nullablehere</h5><p>　　空指针，解决方式：先判断或者先实例化，再访问里面的属性或者成员。</p>
<h5 id="6-Makethis-IP-“127-0-0-1”-address-configurable"><a href="#6-Makethis-IP-“127-0-0-1”-address-configurable" class="headerlink" title="6.Makethis IP “127.0.0.1” address configurable"></a>6.Makethis IP “127.0.0.1” address configurable</h5><p>　　解决方法:不要把IP地址写在此类中，应该在对应的系统文件或者相应的配置文件中配置</p>
<h5 id="7-Either-log-or-rethrow-this-exception"><a href="#7-Either-log-or-rethrow-this-exception" class="headerlink" title="7.Either log or rethrow this exception."></a>7.Either log or rethrow this exception.</h5><p>　　解决方法: 把对应的输出写成Logger.error(“aaa“);的形式 </p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cenrise.com/2017/05/30/review/Findbug代码审查-缺陷和修改/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongpo.jia">
      <meta itemprop="description" content="个人博客">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="中起之星">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/30/review/Findbug代码审查-缺陷和修改/" itemprop="url">
                  Findbug代码审查-缺陷和修改
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-05-30 16:43:49" itemprop="dateCreated datePublished" datetime="2017-05-30T16:43:49+08:00">2017-05-30</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-05-30 17:32:36" itemprop="dateModified" datetime="2018-05-30T17:32:36+08:00">2018-05-30</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/review/" itemprop="url" rel="index"><span itemprop="name">review</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="FindBugs使用实践-缺陷和修改"><a href="#FindBugs使用实践-缺陷和修改" class="headerlink" title="FindBugs使用实践-缺陷和修改"></a>FindBugs使用实践-缺陷和修改</h1><p>Confidence 是fingbug团队认为该代码导致bug的可能性。</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>1 Malicious code vulnerability 恶意代码<br>2 Performance 性能问题<br>3 Security 安全性问题<br>4 Dodgy code 小问题<br>5 Correctness 代码的正确性<br>6 Bad practice 不好的习惯<br>7 Internationalization 国际化问题<br>8 Experrimental 实验性问题<br>无     Multithreaded currectness 线程问题</p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h4 id="1-Bad-practice-坏的实践"><a href="#1-Bad-practice-坏的实践" class="headerlink" title="1 Bad practice 坏的实践"></a>1 Bad practice 坏的实践</h4><p>一些不好的实践，下面列举几个： HE：类定义了equals()，却没有hashCode()；或类定义了equals()，却使用Object.hashCode()；或类定义了hashCode()，却没有equals()；或类定义了hashCode()，却使用Object.equals()；类继承了equals()，却使用Object.hashCode()。<br>SQL：Statement 的execute方法调用了非常量的字符串；或Prepared Statement是由一个非常量的字符串产生。<br>DE：方法终止或不处理异常，一般情况下，异常应该被处理或报告，或被方法抛出。<br>Malicious code vulnerability 可能受到的恶意攻击<br>如果代码公开，可能受到恶意攻击的代码，下面列举几个： FI：一个类的finalize()应该是protected，而不是public的。MS：属性是可变的数组；属性是可变的Hashtable；属性应该是package protected的。</p>
<h4 id="2-Correctness-一般的正确性问题"><a href="#2-Correctness-一般的正确性问题" class="headerlink" title="2 Correctness 一般的正确性问题"></a>2 Correctness 一般的正确性问题</h4><p>可能导致错误的代码，下面列举几个： NP：空指针被引用；在方法的异常路径里，空指针被引用；方法没有检查参数是否null；null值产生并被引用；null值产生并在方法的异常路径被引用；传给方法一个声明为@NonNull的null参数；方法的返回值声明为@NonNull实际是null。 Nm：类定义了hashcode()方法，但实际上并未覆盖父类Object的hashCode()；类定义了tostring()方法，但实际上并未覆盖父类Object的toString()；很明显的方法和构造器混淆；方法名容易混淆。 SQL：方法尝试访问一个Prepared Statement的0索引；方法尝试访问一个ResultSet的0索引。 UwF：所有的write都把属性置成null，这样所有的读取都是null，这样这个属性是否有必要存在；或属性从没有被write。</p>
<h4 id="3-Dodgy-危险的"><a href="#3-Dodgy-危险的" class="headerlink" title="3 Dodgy 危险的"></a>3 Dodgy 危险的</h4><p>具有潜在危险的代码，可能运行期产生错误，下面列举几个： CI：类声明为final但声明了protected的属性。 DLS：对一个本地变量赋值，但却没有读取该本地变量；本地变量赋值成null，却没有读取该本地变量。 ICAST：整型数字相乘结果转化为长整型数字，应该将整型先转化为长整型数字再相乘。 INT：没必要的整型数字比较，如X &lt;= Integer.MAX_VALUE。 NP：对readline()的直接引用，而没有判断是否null；对方法调用的直接引用，而方法可能返回null。 REC：直接捕获Exception，而实际上可能是RuntimeException。 ST：从实例方法里直接修改类变量，即static属性。</p>
<h4 id="4-Performance-性能问题"><a href="#4-Performance-性能问题" class="headerlink" title="4 Performance 性能问题"></a>4 Performance 性能问题</h4><p>可能导致性能不佳的代码，下面列举几个： DM：方法调用了低效的Boolean的构造器，而应该用Boolean.valueOf(…)；用类似Integer.toString(1) 代替new Integer(1).toString()；方法调用了低效的float的构造器，应该用静态的valueOf方法。 SIC：如果一个内部类想在更广泛的地方被引用，它应该声明为static。 SS：如果一个实例属性不被读取，考虑声明为static。 UrF：如果一个属性从没有被read，考虑从类中去掉。 UuF：如果一个属性从没有被使用，考虑从类中去掉。</p>
<h4 id="5-Multithreaded-correctness-多线程的正确性多线程编程时，可能导致错误的代码，下面列举几个："><a href="#5-Multithreaded-correctness-多线程的正确性多线程编程时，可能导致错误的代码，下面列举几个：" class="headerlink" title="5 Multithreaded correctness 多线程的正确性多线程编程时，可能导致错误的代码，下面列举几个："></a>5 Multithreaded correctness 多线程的正确性多线程编程时，可能导致错误的代码，下面列举几个：</h4><p>ESync：空的同步块，很难被正确使用。 MWN：错误使用notify()，可能导致IllegalMonitorStateException异常；或错误的使用wait()。 No：使用notify()而不是notifyAll()，只是唤醒一个线程而不是所有等待的线程。 SC：构造器调用了Thread.start()，当该类被继承可能会导致错误。</p>
<h4 id="6-Internationalization-国际化当对字符串使用upper或lowercase方法，如果是国际的字符串，可能会不恰当的转换。"><a href="#6-Internationalization-国际化当对字符串使用upper或lowercase方法，如果是国际的字符串，可能会不恰当的转换。" class="headerlink" title="6 Internationalization 国际化当对字符串使用upper或lowercase方法，如果是国际的字符串，可能会不恰当的转换。"></a>6 Internationalization 国际化当对字符串使用upper或lowercase方法，如果是国际的字符串，可能会不恰当的转换。</h4><p>API： <a href="http://findbugs.sourceforge.net/api/index.html" target="_blank" rel="noopener">http://findbugs.sourceforge.net/api/index.html</a><br>技术手册： <a href="http://findbugs.sourceforge.net/manual/index.html" target="_blank" rel="noopener">http://findbugs.sourceforge.net/manual/index.html</a><br>更多请参见官网： <a href="http://findbugs.sourceforge.net/bugDescriptions.html" target="_blank" rel="noopener">http://findbugs.sourceforge.net/bugDescriptions.html</a></p>
<h5 id="6-1、-ES-COMPARING-PARAMETER-STRING-WITH-EQ"><a href="#6-1、-ES-COMPARING-PARAMETER-STRING-WITH-EQ" class="headerlink" title="6.1、       ES_COMPARING_PARAMETER_STRING_WITH_EQ"></a>6.1、       ES_COMPARING_PARAMETER_STRING_WITH_EQ</h5><pre><code>ES: Comparison of String parameter using == or != (ES_COMPARING_PARAMETER_STRING_WITH_EQ)
</code></pre><p>This code compares a java.lang.String parameter for reference equality using the == or != operators. Requiring callers to pass only String constants or interned strings to a method is unnecessarily fragile, and rarely leads to measurable performance gains. Consider using the equals(Object) method instead.<br>     使用 == 或者 != 来比较字符串或interned字符串，不会获得显著的性能提升，同时并不可靠，请考虑使用equals()方法。</p>
<h5 id="6-2、-HE-EQUALS-NO-HASHCODE"><a href="#6-2、-HE-EQUALS-NO-HASHCODE" class="headerlink" title="6.2、       HE_EQUALS_NO_HASHCODE"></a>6.2、       HE_EQUALS_NO_HASHCODE</h5><pre><code>HE: Class defines equals() but not hashCode() (HE_EQUALS_NO_HASHCODE)
</code></pre><p>This class overrides equals(Object), but does not override hashCode().  Therefore, the class may violate the invariant that equal objects must have equal hashcodes.<br>     类定义了equals()方法但没有重写hashCode()方法，这样违背了相同对象必须具有相同的hashcodes的原则</p>
<h5 id="6-3、IT-NO-SUCH-ELEMENT"><a href="#6-3、IT-NO-SUCH-ELEMENT" class="headerlink" title="6.3、IT_NO_SUCH_ELEMENT"></a>6.3、IT_NO_SUCH_ELEMENT</h5><pre><code>It: Iterator next() method can&apos;t throw NoSuchElement exception (IT_NO_SUCH_ELEMENT)
</code></pre><p>This class implements the java.util.Iterator interface.  However, its next() method is not capable of throwing java.util.NoSuchElementException.  The next() method should be changed so it throws NoSuchElementException if is called when there are no more elements to return.<br>     迭代器Iterator无法抛出NoSuchElement异常，类实现了java.util.Iterator接口，但是next()方法无法抛出java.util.NoSuchElementException异常，因此，next()方法应该做如此修改，当被调用时，如果没有element返回，则抛出NoSuchElementException异常</p>
<h5 id="6-4、J2EE-STORE-OF-NON-SERIALIZABLE-OBJECT-INTO-SESSION"><a href="#6-4、J2EE-STORE-OF-NON-SERIALIZABLE-OBJECT-INTO-SESSION" class="headerlink" title="6.4、J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION"></a>6.4、J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION</h5><pre><code>J2EE: Store of non serializable object into HttpSession (J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION)
</code></pre><p>This code seems to be storing a non-serializable object into an HttpSession. If this session is passivated or migrated, an error will result.<br>     将没有实现serializable的对象放到HttpSession中，当这个session被钝化和迁移时，将会产生错误，建议放到HttpSession中的对象都实现serializable接口。</p>
<h5 id="6-5、ODR-OPEN-DATABASE-RESOURCE"><a href="#6-5、ODR-OPEN-DATABASE-RESOURCE" class="headerlink" title="6.5、ODR_OPEN_DATABASE_RESOURCE"></a>6.5、ODR_OPEN_DATABASE_RESOURCE</h5><pre><code>ODR: Method may fail to close database resource (ODR_OPEN_DATABASE_RESOURCE)
</code></pre><p>The method creates a database resource (such as a database connection or row set), does not assign it to any fields, pass it to other methods, or return it, and does not appear to close the object on all paths out of the method.  Failure to close database resources on all paths out of a method may result in poor performance, and could cause the application to have problems communicating with the database.<br>     方法可能未关闭数据库资源，未关闭数据库资源将会导致性能变差，还可能引起应用与服务器间的通讯问题。</p>
<h5 id="6-6、OS-OPEN-STREAM"><a href="#6-6、OS-OPEN-STREAM" class="headerlink" title="6.6、OS_OPEN_STREAM"></a>6.6、OS_OPEN_STREAM</h5><pre><code>OS: Method may fail to close stream (OS_OPEN_STREAM)
</code></pre><p>The method creates an IO stream object, does not assign it to any fields, pass it to other methods that might close it, or return it, and does not appear to close the stream on all paths out of the method.  This may result in a file descriptor leak.  It is generally a good idea to use a finally block to ensure that streams are closed.<br>     方法可能未关闭stream，方法产生了一个IO流，却未关闭，将会导致文件描绘符的泄漏，建议使用finally block来确保io stream被关闭。</p>
<h5 id="6-7、-DMI-CALLING-NEXT-FROM-HASNEXT"><a href="#6-7、-DMI-CALLING-NEXT-FROM-HASNEXT" class="headerlink" title="6.7、       DMI_CALLING_NEXT_FROM_HASNEXT"></a>6.7、       DMI_CALLING_NEXT_FROM_HASNEXT</h5><pre><code>DMI: hasNext method invokes next (DMI_CALLING_NEXT_FROM_HASNEXT)
</code></pre><p>The hasNext() method invokes the next() method. This is almost certainly wrong, since the hasNext() method is not supposed to change the state of the iterator, and the next method is supposed to change the state of the iterator.</p>
<h5 id="6-8、-IL-INFINITE-LOOP"><a href="#6-8、-IL-INFINITE-LOOP" class="headerlink" title="6.8、       IL_INFINITE_LOOP"></a>6.8、       IL_INFINITE_LOOP</h5><pre><code>IL: An apparent infinite loop (IL_INFINITE_LOOP)
</code></pre><p>This loop doesn’t seem to have a way to terminate (other than by perhaps throwing an exception).<br>     明显的无限循环.</p>
<h5 id="6-9、-IL-INFINITE-RECURSIVE-LOOP"><a href="#6-9、-IL-INFINITE-RECURSIVE-LOOP" class="headerlink" title="6.9、       IL_INFINITE_RECURSIVE_LOOP"></a>6.9、       IL_INFINITE_RECURSIVE_LOOP</h5><pre><code>IL: An apparent infinite recursive loop (IL_INFINITE_RECURSIVE_LOOP)
</code></pre><p>This method unconditionally invokes itself. This would seem to indicate an infinite recursive loop that will result in a stack overflow.<br>     明显的无限迭代循环,将导致堆栈溢出.</p>
<h5 id="6-10、-WMI-WRONG-MAP-ITERATOR"><a href="#6-10、-WMI-WRONG-MAP-ITERATOR" class="headerlink" title="6.10、   WMI_WRONG_MAP_ITERATOR"></a>6.10、   WMI_WRONG_MAP_ITERATOR</h5><pre><code>WMI: Inefficient use of keySet iterator instead of entrySet iterator (WMI_WRONG_MAP_ITERATOR)
</code></pre><p>This method accesses the value of a Map entry, using a key that was retrieved from a keySet iterator. It is more efficient to use an iterator on the entrySet of the map, to avoid the Map.get(key) lookup.<br>     使用了keySet iterator和Map.get(key)来获取Map值,这种方式效率低,建议使用entrySet的iterator效率更高.</p>
<h5 id="6-11、-IM-BAD-CHECK-FOR-ODD"><a href="#6-11、-IM-BAD-CHECK-FOR-ODD" class="headerlink" title="6.11、   IM_BAD_CHECK_FOR_ODD"></a>6.11、   IM_BAD_CHECK_FOR_ODD</h5><pre><code>IM: Check for oddness that won&apos;t work for negative numbers (IM_BAD_CHECK_FOR_ODD)
</code></pre><p>The code uses x % 2 == 1 to check to see if a value is odd, but this won’t work for negative numbers (e.g., (-5) % 2 == -1). If this code is intending to check for oddness, consider using x &amp; 1 == 1, or x % 2 != 0.<br>     奇偶检测逻辑,未考虑负数情况.</p>
<h4 id="7-实际项目中Bug类型统计"><a href="#7-实际项目中Bug类型统计" class="headerlink" title="7.实际项目中Bug类型统计"></a>7.实际项目中Bug类型统计</h4><h5 id="7-1、-Call-to-equals-comparing-different-types"><a href="#7-1、-Call-to-equals-comparing-different-types" class="headerlink" title="7.1、       Call to equals() comparing different types"></a>7.1、       Call to equals() comparing different types</h5><p>id : EC_UNRELATED_TYPES, type : EC, category : CORRECTNESS This method calls equals(Object) on two references of different class types with no common subclasses. Therefore, the objects being compared are unlikely to be members of the same class at runtime (unless some application classes were not analyzed, or dynamic class loading can occur at runtime). According to the contract of equals(), objects of different classes should always compare as unequal; therefore, according to the contract defined by java.lang.Object.equals(Object), the result of this comparison will always be false at runtime.<br>原因分析：<br>这缺陷的意思是，大部分都是类型永远不会有这种情况， 比如a为DOUBLE类型所以EQUALS只匹配字符串 if(a.equals())或if(a.quals())这类判断是根本不会有用的；<br>示例：if(“1”.equals(DAOValue.valueofSuccess()))</p>
<h5 id="7-2、-Dead-store-to-local-variable"><a href="#7-2、-Dead-store-to-local-variable" class="headerlink" title="7.2、       Dead store to local variable"></a>7.2、       Dead store to local variable</h5><p>id: DLS_DEAD_LOCAL_STORE, type: DLS, category: STYLE<br>This instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used.<br>Note that Sun’s javac compiler often generates dead stores for final local variables. Because FindBugs is a bytecode-based tool, there is no easy way to eliminate these false positives.<br>原因分析：<br>DLS问题指的是给本地变量赋了一个值，但随后的代码并没有用到这个值。</p>
<h5 id="7-3、-Method-call-passes-null-for-nonnull-parameter"><a href="#7-3、-Method-call-passes-null-for-nonnull-parameter" class="headerlink" title="7.3、       Method call passes null for nonnull parameter"></a>7.3、       Method call passes null for nonnull parameter</h5><p>id: NP_NULL_PARAM_DEREF, type: NP, category: CORRECTNESS<br>This method call passes a null value for a nonnull method parameter. Either the parameter is annotated as a parameter that should always be nonnull, or analysis has shown that it will always be dereferenced.<br>原因分析：对参数为null的情况未作处理。<br>例如：</p>
<figure class="highlight plain"><figcaption><span>void method1() &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    String ip = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        ip = InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">    &#125; catch (UnknownHostException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    long ipCount = countIpAddress(ip);//可能会传入空引用 </span><br><span class="line">    //....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long countIpAddress(String ip) &#123;</span><br><span class="line">    long ipNum = 0;</span><br><span class="line">    String[] ipArray = ip.split(&quot;\\.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><figcaption><span>void method1() &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    String ip = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        ip = InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">    &#125; catch (UnknownHostException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    long ipCount = countIpAddress(ip);//可能会传入空引用</span><br><span class="line">    //....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long countIpAddress(String ip) &#123;</span><br><span class="line">    long ipNum = 0;</span><br><span class="line">    if(ip==null)&#123;</span><br><span class="line">        return 0;//抛出异常</span><br><span class="line">    &#125;</span><br><span class="line">    String[] ipArray = ip.split(&quot;\\.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于接口需要对参数校验合法性</p>
<h5 id="7-4、Method-with-Boolean-return-type-returns-explicit-null"><a href="#7-4、Method-with-Boolean-return-type-returns-explicit-null" class="headerlink" title="7.4、Method with Boolean return type returns explicit null"></a>7.4、Method with Boolean return type returns explicit null</h5><p>id: NP_BOOLEAN_RETURN_NULL, type: NP, category: BAD_PRACTICE<br>A method that returns either Boolean.TRUE, Boolean.FALSE or null is an accident waiting to happen. This method can be invoked as though it returned a value of type boolean, and the compiler will insert automatic unboxing of the Boolean value. If a null value is returned, this will result in a NullPointerException.<br>原因分析：<br>方法如果定义为返回类型Boolean，则可以返回Boolean.TRUE, Boolean.FALSE or null （如果 return 的是 true or  false， 则AutoBoxing 成 Boolean.TRUE, Boolean.FALSE）。因为JDK 支持 基本类型和装箱类型的自动转化， 所以下面的代码中：<br>boolean result = test_NP_BOOLEAN_RETURN_NULL();<br>因为此时test_NP_BOOLEAN_RETURN_NULL() 返回的是NULL， 所以 JDK 做 automatic unboxing 的操作时， 即调用了 object. booleanValue() 方法时，抛出了空指针。<br>改成：boolean result = test_NP_BOOLEAN_RETURN_NULL()==null?false:true;</p>
<h5 id="7-5、-No-relationship-between-generic-parameter-and-method-argument"><a href="#7-5、-No-relationship-between-generic-parameter-and-method-argument" class="headerlink" title="7.5、       No relationship between generic parameter and method argument"></a>7.5、       No relationship between generic parameter and method argument</h5><p>id: GC_UNRELATED_TYPES, type: GC, category: CORRECTNESS<br>This call to a generic collection method contains an argument with an incompatible class from that of the collection’s parameter (i.e., the type of the argument is neither a supertype nor a subtype of the corresponding generic type argument). Therefore, it is unlikely that the collection contains any objects that are equal to the method argument used here. Most likely, the wrong value is being passed to the method.<br>In general, instances of two unrelated classes are not equal. For example, if the Foo and Bar classes are not related by subtyping, then an instance of Foo should not be equal to an instance of Bar. Among other issues, doing so will likely result in an equals method that is not symmetrical. For example, if you define the Foo class so that a Foo can be equal to a String, your equals method isn’t symmetrical since a String can only be equal to a String.<br>In rare cases, people do define nonsymmetrical equals methods and still manage to make their code work. Although none of the APIs document or guarantee it, it is typically the case that if you check if a Collection<string> contains a Foo, the equals method of argument (e.g., the equals method of the Foo class) used to perform the equality checks.<br>原因分析：调用Collection类中的contains方法比较时，所比较的两个参数类型不致；</string></p>
<h5 id="7-6、-Null-pointer-dereference-in-method-on-exception-path"><a href="#7-6、-Null-pointer-dereference-in-method-on-exception-path" class="headerlink" title="7.6、       Null pointer dereference in method on exception path"></a>7.6、       Null pointer dereference in method on exception path</h5><p>id: NP_ALWAYS_NULL_EXCEPTION, type: NP, category: CORRECTNESS<br>A pointer which is null on an exception path is dereferenced here.  This will lead to a NullPointerException when the code is executed.  Note that because FindBugs currently does not prune infeasible exception paths, this may be a false warning.<br>Also note that FindBugs considers the default case of a switch statement to be an exception path, since the default case is often infeasible.<br>原因分析：在异常处理时，调用一个空对象的方法时可能引起空指针异常。</p>
<h5 id="7-7、-Nullcheck-of-value-previously-dereferenced"><a href="#7-7、-Nullcheck-of-value-previously-dereferenced" class="headerlink" title="7.7、       Nullcheck of value previously dereferenced"></a>7.7、       Nullcheck of value previously dereferenced</h5><p>id: RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE, type:RCN, category: CORRECTNESS<br>A value is checked here to see whether it is null, but this value can’t be null because it was previously dereferenced and if it were null a null pointer exception would have occurred at the earlier dereference. Essentially, this code and the previous dereference disagree as to whether this value is allowed to be null. Either the check is redundant or the previous dereference is erroneous.<br>原因分析：前面获取的对象，现在引用的时候没有交验是否为null。</p>
<h5 id="7-8、-Possible-null-pointer-dereference"><a href="#7-8、-Possible-null-pointer-dereference" class="headerlink" title="7.8、       Possible null pointer dereference"></a>7.8、       Possible null pointer dereference</h5><p>id: NP_NULL_ON_SOME_PATH, type: NP, category: CORRECTNESS<br>There is a branch of statement that, if executed, guarantees that a null value will be dereferenced, which would generate a NullPointerException when the code is executed. Of course, the problem might be that the branch or statement is infeasible and that the null pointer exception can’t ever be executed; deciding that is beyond the ability of FindBugs.<br>原因分析：可能存在空引用。</p>
<h5 id="7-9、-Possible-null-pointer-dereference-in-method-on-exception-path"><a href="#7-9、-Possible-null-pointer-dereference-in-method-on-exception-path" class="headerlink" title="7.9、       Possible null pointer dereference in method on exception path"></a>7.9、       Possible null pointer dereference in method on exception path</h5><p>id: NP_NULL_ON_SOME_PATH_EXCEPTION, type: NP, category:CORRECTNESS<br>A reference value which is null on some exception control path is dereferenced here.  This may lead to a NullPointerException when the code is executed.  Note that because FindBugs currently does not prune infeasible exception paths, this may be a false warning.<br>Also note that FindBugs considers the default case of a switch statement to be an exception path, since the default case is often infeasible.<br>原因分析：<br>代码调用时， 遇到异常分支， 可能造成一个对象没有获得赋值依旧保持NULL空指针。 接下来如果对这个对象有引用， 可能造成NullPointerException 空指针异常。<br>例如：</p>
<h5 id="7-10、-Test-for-floating-point-equality"><a href="#7-10、-Test-for-floating-point-equality" class="headerlink" title="7.10、   Test for floating point equality"></a>7.10、   Test for floating point equality</h5><p>id: FE_FLOATING_POINT_EQUALITY, type: FE, category: STYLE<br>This operation compares two floating point values for equality. Because floating point calculations may involve rounding, calculated float and double values may not be accurate. For values that must be precise, such as monetary values, consider using a fixed-precision type such as BigDecimal. For values that need not be precise, consider comparing for equality within some range, for example: if ( Math.abs(x - y) &lt; .0000001 ). See the java Language Specification, section 4.2.4.<br>原因分析：<br>Float类型的数据比较时，会存在的定的误差值，用!=来比较不是很准确，建议比较两个数的绝对值是否在一定的范围内来进行比较。如，if ( Math.abs(x - y) &lt; .0000001 )<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    return ResultVo.valueOfError(&quot;订单编号&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="7-11、-Useless-assignment-in-return-statement"><a href="#7-11、-Useless-assignment-in-return-statement" class="headerlink" title="7.11、   Useless assignment in return statement"></a>7.11、   Useless assignment in return statement</h5><p>id: DLS_DEAD_LOCAL_STORE_IN_RETURN, type: DLS, category: STYLE<br>This statement assigns to a local variable in a return statement. This assignment has effect. Please verify that this statement does the right thing.<br>原因分析：<br>在return的对象中，没有必要通过对象赋值再进行返回。<br>例如：</p>
<figure class="highlight plain"><figcaption><span>daoValue </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(lxrCpdlVoList.size()==0)&#123;</span><br><span class="line">    return daoValue = DAOValue.valueof(true,1,&quot;没有批量删除联系人业务大类信息失败&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="7-12、-Write-to-static-field-from-instance-method"><a href="#7-12、-Write-to-static-field-from-instance-method" class="headerlink" title="7.12、   Write to static field from instance method"></a>7.12、   Write to static field from instance method</h5><p>id: ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD, type: ST, category:STYLE<br>This instance method writes to a static field. This is tricky to get correct if multiple instances are being manipulated, and generally bad practice.<br>原因分析：向static字段中写入值。<br>例如：<br><figure class="highlight plain"><figcaption><span>static DBRBO dbrBO; </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> public final void refresh() &#123; </span><br><span class="line">        danskeBankBO = null; </span><br><span class="line">        dbrBO = null; </span><br><span class="line">        fileAndPathBO = null; </span><br><span class="line">    &#125;</span><br><span class="line">``` </span><br><span class="line">建议改为：去掉static。</span><br><span class="line">##### 7.13、   Incorrect lazy initialization and update of static field</span><br><span class="line">id: LI_LAZY_INIT_UPDATE_STATIC, type: LI, category: MT_CORRECTNESS</span><br><span class="line">This method contains an unsynchronized lazy initialization of a static field. After the field is set, the object stored into that location is further updated or accessed. The setting of the field is visible to other threads as soon as it is set. If the futher accesses in the method that set the field serve to initialize the object, then you have a very seriousmultithreading bug, unless something else prevents any other thread from accessing the stored object until it is fully initialized.</span><br><span class="line">Even if you feel confident that the method is never called by multiple threads, it might be better to not set the static field until the value you are setting it to is fully populated/initialized.</span><br><span class="line">原因分析：</span><br><span class="line">该方法的初始化中包含了一个迟缓初始化的静态变量。你的方法引用了一个静态变量，估计是类静态变量，那么多线程调用这个方法时，你的变量就会面临线程安全的问题了，除非别的东西阻止任何其他线程访问存储对象从直到它完全被初始化。</span><br><span class="line">##### 7.14、   Method ignores return value</span><br><span class="line">id: RV_RETURN_VALUE_IGNORED, type: RV, category: CORRECTNESS</span><br><span class="line">The return value of this method should be checked. One common cause of this warning is to invoke a method on an immutable object, thinking that it updates the object. For example, in the following code fragment,</span><br><span class="line">String dateString = getHeaderField(name);</span><br><span class="line">dateString.trim();</span><br><span class="line">the programmer seems to be thinking that the trim() method will update the String referenced by dateString. But since Strings are immutable, the trim() function returns a new String value, which is being ignored here. The code should be corrected to:</span><br><span class="line">String dateString = getHeaderField(name);</span><br><span class="line">dateString = dateString.trim();</span><br><span class="line">原因分析：方法忽略了设置返回值。</span><br><span class="line">例如：</span><br><span class="line"> </span><br><span class="line">```String dateString = getHeaderField(name);</span><br><span class="line">    dateString.trim();</span><br><span class="line">    </span><br><span class="line">    if(CustomActionEnum.Agee_SRT.equals(operationType)||CustomActionEnum.DISSAgee_SRT.equals(operationType)&#123;</span><br><span class="line">        //....</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="7-15、-Method-might-ignore-exception"><a href="#7-15、-Method-might-ignore-exception" class="headerlink" title="7.15、   Method might ignore exception"></a>7.15、   Method might ignore exception</h5><p>id: DE_MIGHT_IGNORE, type: DE, category: BAD_PRACTICE<br>This method might ignore an exception.Â  In general, exceptions should be handled or reported in some way, or they should be thrown out of the method.<br>原因分析：应该将异常 处理、打印或者抛出<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    //....</span><br><span class="line">&#125;catch(Exception e)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="7-16、-Unwritten-field"><a href="#7-16、-Unwritten-field" class="headerlink" title="7.16、   Unwritten field"></a>7.16、   Unwritten field</h5><p>id: UWF_UNWRITTEN_FIELD, type: UwF, category: CORRECTNESS<br>This field is never written.Â  All reads of it will return the default value. Check for errors (should it have been initialized?), or remove it if it is useless.<br>原因分析：从未被初始化的变量，调用它时，将返回默认值，要么初始化，要么删掉它。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    //....</span><br><span class="line">&#125;catch(Exception e)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="7-17、-Value-is-null-and-guaranteed-to-be-dereferenced-on-exception-path"><a href="#7-17、-Value-is-null-and-guaranteed-to-be-dereferenced-on-exception-path" class="headerlink" title="7.17、   Value is null and guaranteed to be dereferenced on exception path"></a>7.17、   Value is null and guaranteed to be dereferenced on exception path</h5><p>id: NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH, type: NP, category:CORRECTNESS<br>There is a statement or branch on an exception path that if executed guarantees that a value is null at this point, and that value that is guaranteed to be dereferenced (except on forward paths involving runtime exceptions).<br>原因分析：exception分支上，存在引用一个null对象的方法，引发空指针异常。<br>例如：<br><figure class="highlight plain"><figcaption><span>out </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    response.setContentType(&quot;text/html;charset=GBK&quot;);</span><br><span class="line">    response.setHeader(&quot;Cache-Control;no-cache&quot;);</span><br><span class="line">    out = response.getWriter();</span><br><span class="line">    out.flush();</span><br><span class="line">&#125;catch(Exception ex)&#123;</span><br><span class="line">    logger.debug(&quot;获取树的XML代码出错。&quot;+ex.getMessage());</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">    out.close();//out可能为空</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="7-18、-Very-confusing-method-names"><a href="#7-18、-Very-confusing-method-names" class="headerlink" title="7.18、   Very confusing method names"></a>7.18、   Very confusing method names</h5><p>id: NM_VERY_CONFUSING, type: Nm, category: CORRECTNESS<br>The referenced methods have names that differ only by capitalization. This is very confusing because if the capitalization were identical then one of the methods would override the other.<br>原因分析：被引用的方法中存在容易混淆的变量。<br>例如：fzgsdm改成 fzgsDm 即可。</p>
<figure class="highlight plain"><figcaption><span>String getFzgsdm() &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    return getFzgsdm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="7-19、-Method-invokes-inefficient-new-String-constructor"><a href="#7-19、-Method-invokes-inefficient-new-String-constructor" class="headerlink" title="7.19、   Method invokes inefficient new String() constructor"></a>7.19、   Method invokes inefficient new String() constructor</h5><p>id: DM_STRING_VOID_CTOR, type: Dm, category: Performance Creating a new java.lang.String object using the no-argument constructor wastes memory because the object so created will be functionally indistinguishable from the empty string constant “”.  Java guarantees that identical string constants will be represented by the same String object.  Therefore, you should just use the empty string constant directly.<br>原因分析：不使用new String()定义空的字符串<br>例如：</p>
<figure class="highlight plain"><figcaption><span>alarmCodeCond </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">应当</span><br><span class="line">String alarmCodeCond = &quot;&quot;;</span><br><span class="line">```      </span><br><span class="line"></span><br><span class="line">##### 7.20、   Load of known null value</span><br><span class="line">id: NP_LOAD_OF_KNOWN_NULL_VALUE, type: Np, category: Dodgy</span><br><span class="line">The variable referenced at this point is known to be null due to an earlier check against null. Although this is valid, it might be a mistake (perhaps you intended to refer to a different variable, or perhaps the earlier check to see if the variable is null should have been a check to see if it was nonnull).</span><br><span class="line">原因分析：null值的不当使用。</span><br><span class="line">例如：</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">if(devIds ==null &amp;&amp; devIds.size()==0)&#123; //.....&#125; </span><br><span class="line"></span><br><span class="line">if(null ==tempList||tempList.size()!=0)&#123; //.....&#125;</span><br><span class="line"></span><br><span class="line">if(batchNo ==null)&#123;</span><br><span class="line">   throw new Exception(&quot;the No. &quot;+batchNo + &quot;is not exists1&quot;）)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="7-21、-Method-concatenates-strings-using-in-a-loop"><a href="#7-21、-Method-concatenates-strings-using-in-a-loop" class="headerlink" title="7.21、   Method concatenates strings using + in a loop"></a>7.21、   Method concatenates strings using + in a loop</h5><p>id: SBSC_USE_STRINGBUFFER_CONCATENATION, type: SBSC, category: Performance<br>The method seems to be building a String using concatenation in a loop. In each iteration, the String is converted to a StringBuffer/StringBuilder, appended to, and converted back to a String. This can lead to a cost quadratic in the number of iterations, as the growing string is recopied in each iteration. Better performance can be obtained by using a StringBuffer (or StringBuilder in Java 1.5) explicitly.<br>For example:<br>  // This is bad<br>  String s = “”;<br>  for (int i = 0; i &lt; field.length; ++i) {<br>    s = s + field[i];<br>  }<br>  // This is better<br>  StringBuffer buf = new StringBuffer();<br>  for (int i = 0; i &lt; field.length; ++i) {<br>    buf.append(field[i]);<br>  }<br>  String s = buf.toString();<br>原因分析：在循环里使用字符串连接，效率低，应该使用StringBuilder/StringBuffer</p>
<h3 id="Bug列表"><a href="#Bug列表" class="headerlink" title="Bug列表"></a>Bug列表</h3><h4 id="BUG-0001"><a href="#BUG-0001" class="headerlink" title="BUG-0001"></a>BUG-0001</h4><p>Bug: Field only ever set to null: com.bettersoft.admin.BtCorpManager.ps<br>All writes to this field are of the constant value null, and thus all reads of the field will return null. Check for errors, or remove it if it is useless.<br>Confidence: Normal, Rank: Troubling (12)<br>Pattern: UWF_NULL_FIELD<br>Type: UwF, Category: CORRECTNESS (Correctness)<br>代码片段：、<br><figure class="highlight plain"><figcaption><span>class BtCorpManager &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private BtCorp btcorp=null;</span><br><span class="line">private Connection con = null;</span><br><span class="line">private Statement st = null;</span><br><span class="line">private PreparedStatement ps = null;</span><br><span class="line">private ResultSet rs = null;</span><br><span class="line">private void setConnection(String centerno) throws Exception&#123;</span><br><span class="line">    //con = DBManager.getConnection(centerno);</span><br><span class="line">    con = DBManager.getConnection();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>解释说明：在BtCorpManager类里面定了一个私有的成员变量PreparedStatement ps,但是这个成员变量ps在实例范围内没有得到任何的初始化(采用默认的构造方法)，始终为null,所以在实例范围内使用该成员变量时，如果不先对其进行初始化操作或者无意识的行为忘了初始化操作，那肯定是要报空指针异常，所以这无疑是一个bug<br>推荐修改： 自己看着办</p>
<h4 id="BUG-0002"><a href="#BUG-0002" class="headerlink" title="BUG-0002"></a>BUG-0002</h4><p>Bug: Nullcheck of form at line 36 of value previously dereferenced in com.bettersoft.admin.CorpEditAction.execute(ActionMapping, ActionForm, HttpServletRequest, HttpServletResponse)<br>A value is checked here to see whether it is null, but this value can’t be null because it was previously dereferenced and if it were null a null pointer exception would have occurred at the earlier dereference. Essentially, this code and the previous dereference disagree as to whether this value is allowed to be null. Either the check is redundant or the previous dereference is erroneous.<br>Confidence: High, Rank: Scary (9)<br>Pattern: RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE<br>Type: RCN, Category: CORRECTNESS (Correctness)<br>代码片段：</p>
<figure class="highlight plain"><figcaption><span>ActionForward execute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//throw new UnsupportedOperationException(&quot;Method is not implemented&quot;);</span><br><span class="line">ActionErrors errors = new ActionErrors();</span><br><span class="line">CreateCorpActionForm createCorp = new CreateCorpActionForm();</span><br><span class="line">createCorp = (CreateCorpActionForm)form;</span><br><span class="line">CreateCorpActionForm webcorp=new CreateCorpActionForm();</span><br><span class="line">BudgetWebcorpManager budgetWebcorpManager=new BudgetWebcorpManager();</span><br><span class="line">webcorp=budgetWebcorpManager.getCWebcorp(createCorp.getId());</span><br><span class="line">createCorp.setFbsaddapproveid(webcorp.getFbsaddapproveid());</span><br><span class="line">createCorp.setFbsinputapproveid(webcorp.getFbsinputapproveid());</span><br><span class="line">createCorp.setFbsprocessapproveid(webcorp.getFbsprocessapproveid());</span><br><span class="line"> </span><br><span class="line">boolean b=false;</span><br><span class="line">if(createCorp!=null)&#123;</span><br></pre></td></tr></table></figure>
<p>解释说明：注意到有个局部变量 CreateCorpActionForm createCorp;再看下它的初始化过程，先是通过new给它分配了内存空间，紧接着有让它引用了了另一个未知的变量，这里说未知是指这个新的引用可能为空，显然 createCorp有可能指向一个空的地址，所以在接下来的引用中极可能报空指针异常（在引用之前不进行判空操作的话）！ 在接下来的代码，如下<br><code>if(createCorp!=null){</code><br>其实也就没有存在的必要，因为如果为空的话，上面这行代码根本不可能执行到，所以findbug说这是冗余的空指针检查。当然考虑到特殊情况，这里显然是struts1的action,所以只要web应用正常启动，通常以下代码</p>
<p><code>createCorp = (CreateCorpActionForm)form;</code></p>
<p>是不会导致createCorp指向空的，唯一的缺陷就是之前的new操作是多余的。<br>推荐修改：自己看着办</p>
<h4 id="BUG-0003"><a href="#BUG-0003" class="headerlink" title="BUG-0003"></a>BUG-0003</h4><p>Bug: con is null guaranteed to be dereferenced in com.bettersoft.admin.leftAction.getLeft(int, String, String) on exception path<br>There is a statement or branch on an exception path that if executed guarantees that a value is null at this point, and that value that is guaranteed to be dereferenced (except on forward paths involving runtime exceptions).<br>Confidence: Normal, Rank: (Troubling 11)<br>Pattern: NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH<br>Type: NP, Category: CORRECTNESS (Correctness)<br>代码片段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        if(rs != null)</span><br><span class="line">            rs.close();</span><br><span class="line">        if(ps!=null)</span><br><span class="line">            ps.close();</span><br><span class="line">        con.close();</span><br><span class="line">    &#125;catch(Exception ee)</span><br><span class="line">    &#123;</span><br><span class="line">        ee.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释说明：这应该是大家很熟悉的代码片段了，可以想象Connection con是在catch代码块中进行的初始化操作，findbug对该bug说的很明白，说如果出现异常，Connection con将保证为空，因为很显然如果出现异常，con将得不到正确的初始化，即便初始化了，因为异常的出现，引用也会被解除，回到一开始定义处的null状态，那么在这里的finally代码块中调用Connection con的close()方法，将报空指针异常<br>推荐修改：自己看着办 </p>
<h4 id="BUG-0004"><a href="#BUG-0004" class="headerlink" title="BUG-0004"></a>BUG-0004</h4><p>Bug: Possible null pointer dereference of dbVersion in com.bettersoft.admin.LoginAction.loadVersion(HttpServletRequest, ActionErrors) on exception path<br>A reference value which is null on some exception control path is dereferenced here. This may lead to aNullPointerExceptionwhen the code is executed. Note that because FindBugs currently does not prune infeasible exception paths, this may be a false warning.<br>Also note that FindBugs considers the default case of a switch statement to be an exception path, since the default case is often infeasible.<br>Confidence: Normal, Rank: Troubling (11)<br>Pattern: NP_NULL_ON_SOME_PATH_EXCEPTION<br>Type: NP, Category: CORRECTNESS (Correctness)<br>代码片段：</p>
<figure class="highlight plain"><figcaption><span>dbVersion </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    try &#123;</span><br><span class="line">        con = DBManager.getConnection();</span><br><span class="line">        dbVersion = vm.getVersionInfo(con);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        // TODO Auto-generated catch block</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            con.close();</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            // TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">if (dbVersion.equals(programVersion)) &#123;</span><br><span class="line">    programVersion.setCorrent(true);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    programVersion.setCorrent(false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释说明：如果try catch 中捕获异常，那么dbVersion将为空， </p>
<p><code>dbVersion.equals(programVersion)</code></p>
<p>上面这行代码，将报空指针异常 </p>
<h4 id="BUG-0005"><a href="#BUG-0005" class="headerlink" title="BUG-0005"></a>BUG-0005</h4><p>Bug: Dead store to am in com.bettersoft.approve.action.CheckAction.execute(ActionMapping, ActionForm, HttpServletRequest, HttpServletResponse)<br>This instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used.<br>Note that Sun’s javac compiler often generates dead stores for final local variables. Because FindBugs is a bytecode-based tool, there is no easy way to eliminate these false positives.<br>Confidence: High, Rank: Of Concern (15)<br>Pattern: DLS_DEAD_LOCAL_STORE<br>Type: DLS, Category: STYLE (Dodgy code)<br>代码片段：</p>
<p><code>ApproveManager am = new ApproveManager();</code></p>
<p>解释说明：am这个局部变量创建出来后，没有在任何地方被引用。这里确实没有被引用，所以是个bug,但是findbug又说明了，这有可能是误报，因为javac编译器在编译局部常量时，也会产生dead stroes。所以这个要视情况而定，不能过于纠结 </p>
<h4 id="BUG-0006"><a href="#BUG-0006" class="headerlink" title="BUG-0006"></a>BUG-0006</h4><p>Bug: The class name com.bettersoft.approve.form.BtWebCorp shadows the simple name of the superclass com.bettersoft.admin.BtWebCorp<br>This class has a simple name that is identical to that of its superclass, except that its superclass is in a different package (e.g.,alpha.Fooextendsbeta.Foo). This can be exceptionally confusing, create lots of situations in which you have to look at import statements to resolve references and creates many opportunities to accidently define methods that do not override methods in their superclasses.<br>Confidence: High, Rank: Troubling (14)<br>Pattern: NM_SAME_SIMPLE_NAME_AS_SUPERCLASS<br>Type: Nm, Category: BAD_PRACTICE (Bad practice)<br>代码片段： </p>
<figure class="highlight plain"><figcaption><span>class BtWebCorp extends com.bettersoft.admin.BtWebCorp&#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释说明：这里子类和父类名称一样，findbug认为这回导致很多混淆。显然一旦出问题，将很难发现，运行结果将出乎意料 </p>
<h4 id="BUG-0007"><a href="#BUG-0007" class="headerlink" title="BUG-0007"></a>BUG-0007</h4><p>Bug: Comparison of String objects using == or != in com.byttersoft.admin.persistence.dao.MessageOpenDao.addOpenSave(MessageOpenForm)<br>This code comparesjava.lang.Stringobjects for reference equality using the == or != operators. Unless both strings are either constants in a source file, or have been interned using theString.intern()method, the same string value may be represented by two different String objects. Consider using theequals(Object)method instead.<br>Confidence: Normal, Rank: Troubling (11)<br>Pattern: ES_COMPARING_STRINGS_WITH_EQ<br>Type: ES, Category: BAD_PRACTICE (Bad practice)<br>代码片段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">        sql = &quot;insert into xx values (1,?,?,?)&quot;;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">        sql = &quot;insert into xx values ((select max(id) + 1 from xx),?,?,?)&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释说明： 直接使用==进行对象实例比较，而没有使用equals,本来没觉得这个bug咋样，但是发现项目里居然最多的bug就是这个，不管是很多年前的代码还是最近的代码，都存在这大量这样的问题。看来这是一个通病，所以大家注意一下，不光是我们公司的项目有这样的问题，这应该是一个普遍的问题，尤其实在比较String类型的时候，注意只要不是java基本类型都需要使用equals进行比较，哪怕是自动解封的Integer，Double等</p>
<h4 id="BUG-0008"><a href="#BUG-0008" class="headerlink" title="BUG-0008"></a>BUG-0008</h4><p>Bug: Call to String.equals(Double) in com.byttersoft.amm.util.BalanceInterzoneRateUtil.formatRate(Double)<br>This method calls equals(Object) on two references of different class types with no common subclasses. Therefore, the objects being compared are unlikely to be members of the same class at runtime (unless some application classes were not analyzed, or dynamic class loading can occur at runtime). According to the contract of equals(), objects of different classes should always compare as unequal; therefore, according to the contract defined by Java.lang.Object.equals(Object), the result of this comparison will always be false at runtime.<br>Confidence: High, Rank: Scariest (1)<br>Pattern: EC_UNRELATED_TYPES<br>Type: EC, Category: CORRECTNESS (Correctness)<br>代码片段：<br><figure class="highlight plain"><figcaption><span>static String  formatRate(Double r)&#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">if(r==null ||  (&quot;undefined&quot;).equals(r))&#123;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>解释说明：使用equals比较不同类型的数据，”undefined”是String类型，r是Double类型，这两个比较肯定返回false</p>
<p><code>(&quot;undefined&quot;).equals(r)</code></p>
<p>上面这行代码完全没有必要 ，不可能存在这种情况</p>
<h4 id="BUG-0009"><a href="#BUG-0009" class="headerlink" title="BUG-0009"></a>BUG-0009</h4><p>Bug: Class com.byttersoft.util.CertInfo defines non-transient non-serializable instance field subjectDnAttr<br>This Serializable class defines a non-primitive instance field which is neither transient, Serializable, orjava.lang.Object, and does not appear to implement theExternalizableinterface or thereadObject()andwriteObject()methods. Objects of this class will not be deserialized correctly if a non-Serializable object is stored in this field.<br>Confidence: High, Rank: Troubling (14)<br>Pattern: SE_BAD_FIELD<br>Type: Se, Category: BAD_PRACTICE (Bad practice)<br>代码片段： </p>
<figure class="highlight plain"><figcaption><span>class CertInfo implements java.io.Serializable</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    private String subjectDN=&quot;&quot;;</span><br><span class="line">    private String issuerDN=&quot;&quot;;</span><br><span class="line">    private String notAfterDate=&quot;&quot;;</span><br><span class="line">    private String notBeforeDate=&quot;&quot;;</span><br><span class="line">    private String serialNumber=&quot;&quot;;</span><br><span class="line">    private String sigAlgName=&quot;&quot;;</span><br><span class="line">    private String sigAlgOID=&quot;&quot;;</span><br><span class="line">    private String version=&quot;&quot;;</span><br><span class="line">    private String publicKeyFormat=&quot;&quot;;</span><br><span class="line">    private String publicKeyAlgorithm=&quot;&quot;;</span><br><span class="line">    private Names subjectDnAttr=null;</span><br><span class="line">｝</span><br><span class="line">public class Names</span><br><span class="line">&#123;&#125;&lt;span&gt;&lt;/span&gt;</span><br></pre></td></tr></table></figure>
<p>解释说明： CertInfo实现的序列话，但是他的成员变量Names subjectDnAttr没有实现序列化，这将会导致序列化失败，String已经默认实现了序列化。注意，序列化时所有的成员变量都必须递归的实现序列化，否则将导致序列化失败。如果某个成员变量不想被序列化要么标注为瞬态要么重写readObj方法</p>
<h4 id="BUG-0010"><a href="#BUG-0010" class="headerlink" title="BUG-0010"></a>BUG-0010</h4><p>Bug: Dead store to corpGourps rather than field with same name in com.byttersoft.admin.form.CorpGroupsForm.setCorpGourps(CorpGourps)<br>This instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used. There is a field with the same name as the local variable. Did you mean to assign to that variable instead?<br>Confidence: High, Rank: Scary (9)<br>Pattern: DLS_DEAD_LOCAL_STORE_SHADOWS_FIELD<br>Type: DLS, Category: STYLE (Dodgy code)<br>代码片段： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void setCorpGourps(CorpGourps corpGourps) &#123;</span><br><span class="line">        corpGourps = corpGourps;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>解释说明：成员变量和局部变量重名</p>
<h4 id="BUG-0011"><a href="#BUG-0011" class="headerlink" title="BUG-0011"></a>BUG-0011</h4><p>Bug: Invocation of toString on labelValue in com.byttersoft.approve.persistence.dao.MesAppDao.getMapByPara(String)<br>The code invokes toString on an array, which will generate a fairly useless result such as [C@16f0472. Consider using Arrays.toString to convert the array into a readable String that gives the contents of the array. See Programming Puzzlers, chapter 3, puzzle 12.<br>Confidence: Normal, Rank: Troubling (10)<br>Pattern: DMI_INVOKING_TOSTRING_ON_ARRAY<br>Type: USELESS_STRING, Category: CORRECTNESS (Correctness)<br>代码片段：</p>
<figure class="highlight plain"><figcaption><span>(String parameter : parameters) &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    String[] labelValue = parameter.split(&quot;=&quot;);</span><br><span class="line">    if (labelValue.length == 2) &#123;</span><br><span class="line">        String key = labelValue[0];</span><br><span class="line">        String value = labelValue[1];</span><br><span class="line">        hashMap.put(key, value);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        logger.debug(&quot;参数 &quot; + labelValue + &quot; 配置错误。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释说明：在进行日志输出时，直接输出对象，将默认调用对象的toString方法，而默认是输出对象的内存地址，所以这里显然有问题，本意应该是输出数组中的字符串 </p>
<h4 id="BUG-0012"><a href="#BUG-0012" class="headerlink" title="BUG-0012"></a>BUG-0012</h4><p>Bug: Write to static field com.byttersoft.admin.service.BtSysResService.map from instance method com.byttersoft.admin.service.BtSysResService.hashCatchOfSysRes(boolean)<br>This instance method writes to a static field. This is tricky to get correct if multiple instances are being manipulated, and generally bad practice.<br>Confidence: High, Rank: Of Concern (15)<br>Pattern: ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD<br>Type: ST, Category: STYLE (Dodgy code)<br>代码片段： </p>
<figure class="highlight plain"><figcaption><span>Map<string, btsysres=""> map </string,></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public Map&lt;String, BtSysRes&gt; hashCatchOfSysRes(boolean isRefresh) &#123;</span><br><span class="line">        if(isRefresh == true)&#123;</span><br><span class="line">            map = hashCatchOfSysRes();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            if(map == null || map.isEmpty())&#123;</span><br><span class="line">                map = hashCatchOfSysRes();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return map;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>解释说明：在实例方法中修改类变量的引用，这会导致共享问题，因为其他实例也会访问该静态变量，但是却不知道某个实例已经修改了该静态变量的引用，导致不可预知的问题<br>推荐修改：将该方法改为类方法</p>
<h4 id="BUG-0013"><a href="#BUG-0013" class="headerlink" title="BUG-0013"></a>BUG-0013</h4><p>Bug: Unwritten field: com.byttersoft.admin.service.importservice.ImportServices.bank<br>This field is never written. All reads of it will return the default value. Check for errors (should it have been initialized?), or remove it if it is useless.<br>Confidence: Normal, Rank: Troubling (12)<br>Pattern: UWF_UNWRITTEN_FIELD<br>Type: UwF, Category: CORRECTNESS (Correctness)<br>代码片段：</p>
<figure class="highlight plain"><figcaption><span>class ImportServices &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private IBankAccServices bank;</span><br><span class="line">public IBankAccServices getBank() &#123;</span><br><span class="line">        return bank;</span><br><span class="line">    &#125;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p>解释说明： bank对象为空，getBank方法返回了一个肯定为空的对象实例</p>
<h4 id="BUG-0014"><a href="#BUG-0014" class="headerlink" title="BUG-0014"></a>BUG-0014</h4><p>Bug: There is an apparent infinite recursive loop in com.byttersoft.amm.dao.impl.CheckLoanOrProvideInfoDaoImpl.addBatch(List)<br>This method unconditionally invokes itself. This would seem to indicate an infinite recursive loop that will result in a stack overflow.<br>Confidence: High, Rank: Scary (9)<br>Pattern: IL_INFINITE_RECURSIVE_LOOP<br>Type: IL, Category: CORRECTNESS (Correctness)<br>代码片段：<br><figure class="highlight plain"><figcaption><span>void addBatch(List<cmsploantobean> cmsPLoanBeans) &#123;</cmsploantobean></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    this.addBatch(cmsPLoanBeans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>解释说明：出现了递归调用addBatch,将出现死循环</p>
<h3 id="High"><a href="#High" class="headerlink" title="High"></a>High</h3><h4 id="1-DM-DEFAULT-ENCODING"><a href="#1-DM-DEFAULT-ENCODING" class="headerlink" title="1.DM_DEFAULT_ENCODING"></a>1.DM_DEFAULT_ENCODING</h4><h5 id="1-1-Found-reliance-on-default-encoding-in-com-cmcc-aoi-httprequest-service-HttpRequest-sendGet-String-String-new-java-io-InputStreamReader-InputStream"><a href="#1-1-Found-reliance-on-default-encoding-in-com-cmcc-aoi-httprequest-service-HttpRequest-sendGet-String-String-new-java-io-InputStreamReader-InputStream" class="headerlink" title="1.1 Found reliance on default encoding in com.cmcc.aoi.httprequest.service.HttpRequest.sendGet(String, String): new java.io.InputStreamReader(InputStream)"></a>1.1 Found reliance on default encoding in com.cmcc.aoi.httprequest.service.HttpRequest.sendGet(String, String): new java.io.InputStreamReader(InputStream)</h5><p>Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.</p>
<p>new BufferedReader(new InputStreamReader(connection.getInputStream()));</p>
<p>修改为： InputStreamReader fileData = new InputStreamReader(file ,”utf-8”);</p>
<h5 id="1-2-Found-reliance-on-default-encoding-in-com-cmcc-aoi-httprequest-service-HttpRequest-sendPost-String-JSONObject-new-java-io-PrintWriter-OutputStream"><a href="#1-2-Found-reliance-on-default-encoding-in-com-cmcc-aoi-httprequest-service-HttpRequest-sendPost-String-JSONObject-new-java-io-PrintWriter-OutputStream" class="headerlink" title="1.2 Found reliance on default encoding in com.cmcc.aoi.httprequest.service.HttpRequest.sendPost(String, JSONObject): new java.io.PrintWriter(OutputStream)"></a>1.2 Found reliance on default encoding in com.cmcc.aoi.httprequest.service.HttpRequest.sendPost(String, JSONObject): new java.io.PrintWriter(OutputStream)</h5><p>Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.<br>out = new PrintWriter(conn.getOutputStream());</p>
<p>修改为： out = new PrintWriter(new OutputStreamWriter(conn.getOutputStream(), “utf-8”));</p>
<h5 id="1-3-Found-reliance-on-default-encoding-in-com-cmcc-aoi-selfhelp-action-DeliverWebRequestAction-calculateUserCount-HttpServletRequest-String-getBytes"><a href="#1-3-Found-reliance-on-default-encoding-in-com-cmcc-aoi-selfhelp-action-DeliverWebRequestAction-calculateUserCount-HttpServletRequest-String-getBytes" class="headerlink" title="1.3 Found reliance on default encoding in com.cmcc.aoi.selfhelp.action.DeliverWebRequestAction.calculateUserCount(HttpServletRequest): String.getBytes()"></a>1.3 Found reliance on default encoding in com.cmcc.aoi.selfhelp.action.DeliverWebRequestAction.calculateUserCount(HttpServletRequest): String.getBytes()</h5><p>Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.<br>fileName = new String(req.getParameter(“fileName”).getBytes(), “UTF-8”);<br>修改为<br>fileName = new String(req.getParameter(“fileName”).getBytes(“UTF-8”), “UTF-8”);</p>
<h5 id="1-4-Found-reliance-on-default-encoding-in-com-cmcc-aoi-selfhelp-action-servlet-AoeRegAction-report-HttpServletRequest-HttpServletResponse-java-io-ByteArrayOutputStream-toString"><a href="#1-4-Found-reliance-on-default-encoding-in-com-cmcc-aoi-selfhelp-action-servlet-AoeRegAction-report-HttpServletRequest-HttpServletResponse-java-io-ByteArrayOutputStream-toString" class="headerlink" title="1.4 Found reliance on default encoding in com.cmcc.aoi.selfhelp.action.servlet.AoeRegAction.report(HttpServletRequest, HttpServletResponse): java.io.ByteArrayOutputStream.toString()"></a>1.4 Found reliance on default encoding in com.cmcc.aoi.selfhelp.action.servlet.AoeRegAction.report(HttpServletRequest, HttpServletResponse): java.io.ByteArrayOutputStream.toString()</h5><p>Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.<br>logger.info(“RECV STR: “ + baos.toString());<br>修改为<br>logger.info(“RECV STR: “ + baos.toString(“utf-8”));</p>
<h5 id="1-5-Found-reliance-on-default-encoding-in-com-cmcc-aoi-selfhelp-action-servlet-AoeUploadLogAction-report-HttpServletRequest-HttpServletResponse-new-java-io-FileWriter-File"><a href="#1-5-Found-reliance-on-default-encoding-in-com-cmcc-aoi-selfhelp-action-servlet-AoeUploadLogAction-report-HttpServletRequest-HttpServletResponse-new-java-io-FileWriter-File" class="headerlink" title="1.5 Found reliance on default encoding in com.cmcc.aoi.selfhelp.action.servlet.AoeUploadLogAction.report(HttpServletRequest, HttpServletResponse): new java.io.FileWriter(File)"></a>1.5 Found reliance on default encoding in com.cmcc.aoi.selfhelp.action.servlet.AoeUploadLogAction.report(HttpServletRequest, HttpServletResponse): new java.io.FileWriter(File)</h5><p>Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.<br>new FileWriter(f).append(baos.toString(“UTF-8”)).close();<br>修改为<br>BufferedWriter out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(f, true)));<br>out.write(baos.toString(“UTF-8”));<br>out.close();</p>
<p>BufferedWriter bw= new BufferedWriter( new OutputStreamWriter(new FileOutputStream(filePath, true), “utf-8”));</p>
<h5 id="1-6-Found-reliance-on-default-encoding-in-new-com-cmcc-aoi-util-TokenZipFileUtil-String-new-java-io-FileReader-String"><a href="#1-6-Found-reliance-on-default-encoding-in-new-com-cmcc-aoi-util-TokenZipFileUtil-String-new-java-io-FileReader-String" class="headerlink" title="1.6 Found reliance on default encoding in new com.cmcc.aoi.util.TokenZipFileUtil(String): new java.io.FileReader(String)"></a>1.6 Found reliance on default encoding in new com.cmcc.aoi.util.TokenZipFileUtil(String): new java.io.FileReader(String)</h5><p>Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.<br>FileReader in = new FileReader(file);<br>改为<br>BufferedReader reader = new BufferedReader(new InputStreamReader(newFileInputStream(file), “UTF-8”)); </p>
<h4 id="2-MS-SHOULD-BE-FINAL"><a href="#2-MS-SHOULD-BE-FINAL" class="headerlink" title="2.MS_SHOULD_BE_FINAL"></a>2.MS_SHOULD_BE_FINAL</h4><p>com.cmcc.aoi.selfhelp.action.DeliverWebRequestAction.logger isn’t final but should be<br>This static field public but not final, and could be changed by malicious code or by accident from another package. The field could be made final to avoid this vulnerability.</p>
<p>protected static   Logger logger = LoggerFactory.getLogger(DeliverWebRequestAction.class);<br>修改为 protected static final Logger logger = LoggerFactory.getLogger(DeliverWebRequestAction.class);</p>
<h4 id="3-DLS-DEAD-LOCAL-STORE"><a href="#3-DLS-DEAD-LOCAL-STORE" class="headerlink" title="3.DLS_DEAD_LOCAL_STORE"></a>3.DLS_DEAD_LOCAL_STORE</h4><p>Dead store to s in com.cmcc.aoi.selfhelp.action.DeliverWebRequestAction.textSend(WebSendTextForm, HttpServletRequest)<br>This instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used.<br>Note that Sun’s javac compiler often generates dead stores for final local variables. Because FindBugs is a bytecode-based tool, there is no easy way to eliminate these false positives.<br>ShopMappingDeliver shopMappingDeliver = null;<br>删除即可</p>
<h4 id="4-ST-WRITE-TO-STATIC-FROM-INSTANCE-METHOD"><a href="#4-ST-WRITE-TO-STATIC-FROM-INSTANCE-METHOD" class="headerlink" title="4.ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD"></a>4.ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD</h4><p>Write to static field com.cmcc.aoi.selfhelp.action.MultipleMediaAoeAction.linkRoot from instance method com.cmcc.aoi.selfhelp.action.MultipleMediaAoeAction.afterPropertiesSet()<br>This instance method writes to a static field. This is tricky to get correct if multiple instances are being manipulated, and generally bad practice.<br>linkRoot = sysConfigService.getDomainName() + “/“;<br>修改改为：<br><figure class="highlight plain"><figcaption><span>static String getLinkRoot() &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">        returnlinkRoot;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    publicstaticvoid setLinkRoot(String linkRoot) &#123;</span><br><span class="line">        MultipleMediaAoeAction.linkRoot = linkRoot;</span><br><span class="line">    &#125;</span><br><span class="line">   MultipleMediaAoeAction.setLinkRoot(sysConfigService.getDomainName() + &quot;/&quot;);</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">#### 5. J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION</span><br><span class="line">Store of non serializable com.cmcc.aoi.selfhelp.action.UploadFileAction$FileUploadStatus into HttpSession in new com.cmcc.aoi.selfhelp.action.UploadFileAction$MyProgressListener(UploadFileAction, HttpServletRequest)</span><br><span class="line">This code seems to be storing a non-serializable object into an HttpSession. If this session is passivated or migrated, an error will result.</span><br><span class="line">修改为 FileUploadStatus implements Serializable</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#### 6.  RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE</span><br><span class="line">Redundant nullcheck of rtr, which is known to be non-null in com.cmcc.aoi.selfhelp.action.servlet.AoeReportApplistAction.device(HttpServletRequest, HttpServletResponse)</span><br><span class="line">This method contains a redundant check of a known non-null value against the constant null.</span><br><span class="line">```if (rtr != null) &#123;</span><br><span class="line">            Writer writer;</span><br><span class="line">            try &#123;</span><br><span class="line">                writer = response.getWriter();</span><br><span class="line">                if (rtr != null) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line"> </span><br><span class="line">                        String s = JSONUtil.objToJson(rtr);</span><br><span class="line">                        if (LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">                            LOGGER.debug(&quot;SEND STR: &quot; + s);</span><br><span class="line">                        &#125;</span><br><span class="line">                        writer.write(s);</span><br><span class="line">                        writer.flush();</span><br><span class="line">                    &#125; catch (IOException e) &#123;</span><br><span class="line">                        LOGGER.warn(&quot;&quot;, e);</span><br><span class="line">                        if (writer != null) &#123;</span><br><span class="line">                            try &#123;</span><br><span class="line">                                writer.write(JSONUtil.objToJson(rtr));</span><br><span class="line">                            &#125; catch (IOException e1) &#123;</span><br><span class="line">                                LOGGER.warn(&quot;&quot;, e1);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    response.getWriter().write(&quot;&#123;\&quot;errorCode\&quot;:401&#125;&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (IOException e2) &#123;</span><br><span class="line">                LOGGER.warn(&quot;&quot;, e2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>修改为<br><figure class="highlight plain"><figcaption><span>(rtr !</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    Writer writer;</span><br><span class="line">    try &#123;</span><br><span class="line">        writer = response.getWriter();</span><br><span class="line">        try &#123;</span><br><span class="line"> </span><br><span class="line">            String s = JSONUtil.objToJson(rtr);</span><br><span class="line">            if (LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">                LOGGER.debug(&quot;SEND STR: &quot; + s);</span><br><span class="line">            &#125;</span><br><span class="line">            writer.write(s);</span><br><span class="line">            writer.flush();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            LOGGER.warn(&quot;&quot;, e);</span><br><span class="line">            if (writer != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    writer.write(JSONUtil.objToJson(rtr));</span><br><span class="line">                &#125; catch (IOException e1) &#123;</span><br><span class="line">                    LOGGER.warn(&quot;&quot;, e1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125; catch (IOException e2) &#123;</span><br><span class="line">        LOGGER.warn(&quot;&quot;, e2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    response.getWriter().write(&quot;&#123;\&quot;errorCode\&quot;:401&#125;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="7-RU-INVOKE-RUN"><a href="#7-RU-INVOKE-RUN" class="headerlink" title="7. RU_INVOKE_RUN"></a>7. RU_INVOKE_RUN</h4><p>com.cmcc.aoi.selfhelp.action.servlet.UploadTokensAction$TokenFileThread.run() explicitly invokes run on a thread (did you mean to start it instead?)<br>This method explicitly invokes run() on an object.  In general, classes implement the Runnable interface because they are going to have their run() method invoked in a new thread, in which case Thread.start() is the right method to call.</p>
<p><code>ti.run();</code><br>修改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    ti.join();</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">     e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-NM-SAME-SIMPLE-NAME-AS-SUPERCLASS"><a href="#8-NM-SAME-SIMPLE-NAME-AS-SUPERCLASS" class="headerlink" title="8. NM_SAME_SIMPLE_NAME_AS_SUPERCLASS"></a>8. NM_SAME_SIMPLE_NAME_AS_SUPERCLASS</h4><p>The class name com.cmcc.aoi.selfhelp.dao.BaseDao shadows the simple name of the superclass org.slave4j.orm.hibernate.BaseDao<br>This class has a simple name that is identical to that of its superclass, except that its superclass is in a different package (e.g., alpha.Foo extends beta.Foo). This can be exceptionally confusing, create lots of situations in which you have to look at import statements to resolve references and creates many opportunities to accidentally define methods that do not override methods in their superclasses<br>com.cmcc.aoi.selfhelp.dao.BaseDao<br>修改为<br>com.cmcc.aoi.selfhelp.dao.BasisDao</p>
<h4 id="9-SE-BAD-FIELD-INNER-CLASS"><a href="#9-SE-BAD-FIELD-INNER-CLASS" class="headerlink" title="9. SE_BAD_FIELD_INNER_CLASS"></a>9. SE_BAD_FIELD_INNER_CLASS</h4><p>com.cmcc.aoi.selfhelp.action.UploadFileAction$FileUploadStatus is serializable but also an inner class of a non-serializable class<br>This Serializable class is an inner class of a non-serializable class. Thus, attempts to serialize it will also attempt to associate instance of the outer class with which it is associated, leading to a runtime error.<br>If possible, making the inner class a static inner class should solve the problem. Making the outer class serializable might also work, but that would mean serializing an instance of the inner class would always also serialize the instance of the outer class, which it often not what you really want.<br>修改外部类<br>UploadFileAction extends BaseAction implements Serializable</p>
<h4 id="10-DM-BOXED-PRIMITIVE-FOR-PARSING"><a href="#10-DM-BOXED-PRIMITIVE-FOR-PARSING" class="headerlink" title="10. DM_BOXED_PRIMITIVE_FOR_PARSING"></a>10. DM_BOXED_PRIMITIVE_FOR_PARSING</h4><p>Boxing/unboxing to parse a primitive com.cmcc.aoi.selfhelp.dao.StatAppEveryHourDao.findWeekList(String)<br>A boxed primitive is created from a String, just to extract the unboxed primitive value. It is more efficient to just call the static parseXXX method.</p>
<figure class="highlight plain"><figcaption><span>statAppEveryHour.setAccnumber(Integer.valueOf(String.valueOf(objects[3])));</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">修改为</span><br><span class="line"></span><br><span class="line">```statAppEveryHour.setStattime(sdf.parse(String.valueOf(objects[1])));</span><br><span class="line">                    statAppEveryHour</span><br><span class="line">                            .setNewnumber(Integer.parseInt(String.valueOf(objects[2]) != null</span><br><span class="line">                                    &amp;&amp; !&quot;&quot;.equals(String.valueOf(objects[2]))</span><br><span class="line">                                            ? String.valueOf(objects[2]) : &quot;0&quot;));</span><br><span class="line">                    statAppEveryHour</span><br><span class="line">                            .setAccnumber(Integer.parseInt(String.valueOf(objects[3]) != null</span><br><span class="line">                                    &amp;&amp; !&quot;&quot;.equals(String.valueOf(objects[3]))</span><br><span class="line">                                            ? String.valueOf(objects[3]) : &quot;0&quot;));</span><br></pre></td></tr></table></figure>
<h3 id="Normal"><a href="#Normal" class="headerlink" title="Normal"></a>Normal</h3><h4 id="1-SBSC-USE-STRINGBUFFER-CONCATENATION"><a href="#1-SBSC-USE-STRINGBUFFER-CONCATENATION" class="headerlink" title="1.SBSC_USE_STRINGBUFFER_CONCATENATION"></a>1.SBSC_USE_STRINGBUFFER_CONCATENATION</h4><p>com.cmcc.aoi.httprequest.service.HttpRequest.sendGet(String, String) concatenates strings using + in a loop<br>The method seems to be building a String using concatenation in a loop. In each iteration, the String is converted to a StringBuffer/StringBuilder, appended to, and converted back to a String. This can lead to a cost quadratic in the number of iterations, as the growing string is recopied in each iteration.<br>Better performance can be obtained by using a StringBuffer (or StringBuilder in Java 1.5) explicitly.<br>For example:<br>  // This is bad<br>  String s = “”;<br>  for (int i = 0; i &lt; field.length; ++i) {<br>    s = s + field[i];<br>  }</p>
<p>  // This is better<br>  StringBuffer buf = new StringBuffer();<br>  for (int i = 0; i &lt; field.length; ++i) {<br>    buf.append(field[i]);<br>  }<br>  String s = buf.toString();</p>
<h4 id="2-WMI-WRONG-MAP-ITERATOR"><a href="#2-WMI-WRONG-MAP-ITERATOR" class="headerlink" title="2. WMI_WRONG_MAP_ITERATOR"></a>2. WMI_WRONG_MAP_ITERATOR</h4><figure class="highlight plain"><figcaption><span>(String key : map.keySet()) &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">                System.out.println(key + &quot;---&gt;&quot; + map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改为</p>
<figure class="highlight plain"><figcaption><span>(  Map.Entry<string, list<string="">> entry : map.entrySet()) &#123;</string,></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">                System.out.println(entry.getKey() + &quot;---&gt;&quot; + entry.getValue());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">#### 3.  EI_EXPOSE_REP</span><br><span class="line">com.cmcc.aoi.selfhelp.entity.Activation.getValidUntil() may expose internal representation by returning Activation.validUntil</span><br><span class="line">Returning a reference to a mutable object value stored in one of the object&apos;s fields exposes the internal representation of the object.  If instances are accessed by untrusted code, and unchecked changes to the mutable object would compromise security or other important properties, you will need to do something different. Returning a new copy of the object is better approach in many situations.</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    public Date getValidUntil() &#123;</span><br><span class="line">        returnvalidUntil;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">修改为</span><br><span class="line">public Date getValidUntil() &#123;</span><br><span class="line">        if(validUntil == null) &#123;</span><br><span class="line">            returnnull;</span><br><span class="line">        &#125;</span><br><span class="line">        return (Date) validUntil.clone();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">#### 4. EI_EXPOSE_REP2</span><br><span class="line">com.cmcc.aoi.selfhelp.entity.Activation.setValidUntil(Date) may expose internal representation by storing an externally mutable object into Activation.validUntil</span><br><span class="line">This code stores a reference to an externally mutable object into the internal representation of the object.  If instances are accessed by untrusted code, and unchecked changes to the mutable object would compromise security or other important properties, you will need to do something different. Storing a copy of the object is better approach in many situations.</span><br><span class="line"></span><br><span class="line">```publicvoid setValidUntil(Date validUntil) &#123;</span><br><span class="line">this.validUntil = validUntil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改为<br><figure class="highlight plain"><figcaption><span>setValidUntil(Date validUntil) &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">        if(validUntil == null) &#123;</span><br><span class="line">            this.validUntil = null;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            this.validUntil = (Date) validUntil.clone();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line"> </span><br><span class="line">#### 5. BC_VACUOUS_INSTANCEOF</span><br><span class="line">instanceof will always return true for all non-null values in com.cmcc.aoi.selfhelp.entity.AppType.compareTo(AppType), since all com.cmcc.aoi.selfhelp.entity.AppType are instances of com.cmcc.aoi.selfhelp.entity.AppType</span><br><span class="line">This instanceof test will always return true (unless the value being tested is null). Although this is safe, make sure it isn&apos;t an indication of some misunderstanding or some other logic error. If you really want to test the value for being null, perhaps it would be clearer to do better to do a null test rather than an instanceof test.</span><br><span class="line"> </span><br><span class="line">#### 6. MS_MUTABLE_ARRAY</span><br><span class="line">com.cmcc.aoi.selfhelp.entity.DeviceType.CURRENTUSEDDEVICES is a mutable array</span><br><span class="line">A final static field references an array and can be accessed by malicious code or by accident from another package. This code can freely modify the contents of the array.</span><br><span class="line"> </span><br><span class="line">public static final int[] CURRENTUSEDDEVICES = new int []&#123;Device.iOS.ordinal()，Device.Android.ordinal()，Device.WP.ordinal()&#125;；</span><br><span class="line">修改为</span><br><span class="line"> Public &gt; protected</span><br><span class="line"> </span><br><span class="line">#### 7. EQ_COMPARETO_USE_OBJECT_EQUALS</span><br><span class="line">com.cmcc.aoi.selfhelp.entity.AppType defines compareTo(AppType) and uses Object.equals()</span><br><span class="line">This class defines a compareTo(...) method but inherits its equals() method from java.lang.Object. Generally, the value of compareTo should return zero if and only if equals returns true. If this is violated, weird and unpredictable failures will occur in classes such as PriorityQueue. In Java 5 the PriorityQueue.remove method uses the compareTo method, while in Java 6 it uses the equals method.</span><br><span class="line">From the JavaDoc for the compareTo method in the Comparable interface:</span><br><span class="line">It is strongly recommended, but not strictly required that (x.compareTo(y)==0) == (x.equals(y)). Generally speaking, any class that implements the Comparable interface and violates this condition should clearly indicate this fact. The recommended language is &quot;Note: this class has a natural ordering that is inconsistent with equals.&quot;</span><br><span class="line"> </span><br><span class="line">修改</span><br><span class="line">添加 hashcode() 和 equals() 代码即可</span><br><span class="line"> </span><br><span class="line">#### 8. BC_VACUOUS_INSTANCEOF</span><br><span class="line">instanceof will always return true for all non-null values in com.cmcc.aoi.selfhelp.entity.AppType.compareTo(AppType), since all com.cmcc.aoi.selfhelp.entity.AppType are instances of com.cmcc.aoi.selfhelp.entity.AppType</span><br><span class="line">This instanceof test will always return true (unless the value being tested is null). Although this is safe, make sure it isn&apos;t an indication of some misunderstanding or some other logic error. If you really want to test the value for being null, perhaps it would be clearer to do better to do a null test rather than an instanceof test.</span><br><span class="line">  </span><br><span class="line">```@Override</span><br><span class="line">    publicint compareTo(AppType o) &#123;</span><br><span class="line">        if (oinstanceof AppType) &#123;</span><br><span class="line">            AppType p = (AppType) o;</span><br><span class="line">            returnthis.typeId &gt; p.typeId ? 1 : this.typeId == p.typeId ? 0 : -1;</span><br><span class="line">        &#125;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">修改为</span><br><span class="line">  </span><br><span class="line">```@Override</span><br><span class="line">    publicint compareTo(AppType o) &#123;</span><br><span class="line">        if (null != o) &#123;</span><br><span class="line">            AppType p  = (AppType) o ;</span><br><span class="line">            returnthis.typeId &gt; p.typeId ? 1 : this.typeId == p.typeId ? 0 : -1;</span><br><span class="line">        &#125;</span><br><span class="line">        return 1;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">#### 9. ME_ENUM_FIELD_SETTER</span><br><span class="line">com.cmcc.aoi.selfhelp.dto.ActivationSituation.setSituation(String) unconditionally sets the field situation</span><br><span class="line">This public method declared in public enum unconditionally sets enum field, thus this field can be changed by malicious code or by accident from another package. Though mutable enum fields may be used for lazy initialization, it&apos;s a bad practice to expose them to the outer world. Consider removing this method or declaring it package-private.</span><br><span class="line">    publicvoid setCode(String code) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">修改</span><br><span class="line"> 删除该无用代码</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#### 10.  IM_BAD_CHECK_FOR_ODD</span><br><span class="line">Check for oddness that won&apos;t work for negative numbers in com.cmcc.aoi.selfhelp.dto.WebSendTextForm.toDeliverWebRequest()</span><br><span class="line">The code uses x % 2 == 1 to check to see if a value is odd, but this won&apos;t work for negative numbers (e.g., (-5) % 2 == -1). If this code is intending to check for oddness, consider using x &amp; 1 == 1, or x % 2 != 0.</span><br><span class="line"></span><br><span class="line">```DeliverFactory</span><br><span class="line">                                    .createTextOpenApp(this.msgtype, &quot;&quot;, this.content,</span><br><span class="line">                                            this.isRingAndVibrate % 2 == 1,</span><br><span class="line">                                            isRingAndVibrate / 2 &gt;= 1, this.activity)</span><br><span class="line">                                    .toJsonString());</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">修改为</span><br><span class="line"></span><br><span class="line">```DeliverFactory</span><br><span class="line">                                    .createTextOpenApp(this.msgtype, &quot;&quot;, this.content,</span><br><span class="line">                                            this.isRingAndVibrate % 2 != 0,</span><br><span class="line">                                            isRingAndVibrate / 2 &gt;= 1, this.activity)</span><br><span class="line">                                    .toJsonString());</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line"> </span><br><span class="line">#### 11. MS_EXPOSE_REP</span><br><span class="line">Public static com.cmcc.aoi.selfhelp.dict.DeviceSupported.getSupportedDevs() may expose internal representation by returning DeviceSupported.DEVS</span><br><span class="line">A public static method returns a reference to an array that is part of the static state of the class. Any code that calls this method can freely modify the underlying array. One fix is to return a copy of the array.</span><br><span class="line"></span><br><span class="line">```public static Device[] getSupportedDevs() &#123;</span><br><span class="line">        return DEVS;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>修改为</p>
<figure class="highlight plain"><figcaption><span>Device[] getSupportedDevs() &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">        return DeviceSupported.DEVS.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">#### 12.URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD</span><br><span class="line">Unread public/protected field: com.cmcc.aoi.selfhelp.dict.OperatorDict.countryCode</span><br><span class="line">This field is never read.  The field is public or protected, so perhaps it is intended to be used with classes not seen as part of the analysis. If not, consider removing it from the class.</span><br><span class="line">publicintcode;</span><br><span class="line">    </span><br><span class="line">```public String enName;</span><br><span class="line">    public String cnName;</span><br><span class="line">    public String countryCode;</span><br><span class="line"> </span><br><span class="line">    public OperatorDict() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @param code</span><br><span class="line">     *            运营商代码,一般是5位</span><br><span class="line">     * @param enName</span><br><span class="line">     *            英文名</span><br><span class="line">     * @param countryCode</span><br><span class="line">     *            国家英文代码</span><br><span class="line">     * @param cnName</span><br><span class="line">     *            中文名</span><br><span class="line">     */</span><br><span class="line">    public OperatorDict(intcode, String enName, String countryCode, String cnName) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">        this.enName = enName;</span><br><span class="line">        this.countryCode = countryCode;</span><br><span class="line">        this.cnName = cnName == null ? Integer.toString(code) : cnName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">```修改为</span><br><span class="line">Public  -》 private</span><br><span class="line">  </span><br><span class="line">#### 13. ES_COMPARING_STRINGS_WITH_EQ</span><br><span class="line">Comparison of String objects using == or != in com.cmcc.aoi.selfhelp.entity.Provider.compareTo(Object)</span><br><span class="line">This code compares java.lang.String objects for reference equality using the == or != operators. Unless both strings are either constants in a source file, or have been interned using the String.intern() method, the same string value may be represented by two different String objects. Consider using the equals(Object) method instead.</span><br><span class="line"> </span><br><span class="line">return this.spid.compareTo(p.spid) &gt; 0 ? 1 : this.spid == p.spid ? 0 : -1;</span><br><span class="line">修改为</span><br><span class="line">this.spid.compareTo(p.spid) &gt; 0 ? 1 : this.spid.equals(p.spid) ? 0 : -1;</span><br><span class="line">14.DB_DUPLICATE_BRANCHES</span><br><span class="line">com.cmcc.aoi.selfhelp.dao.ShStatTerminalDao.getListQuery(String, int, Date, Date, boolean, int) uses the same code for two branches</span><br><span class="line">This method uses the same code to implement two branches of a conditional branch. Check to ensure that this isn&apos;t a coding mistake.</span><br><span class="line"></span><br><span class="line">```if (bool) &#123;</span><br><span class="line">                query.setInteger(i++, nodeType);</span><br><span class="line">                query.setInteger(i++, nodeType);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                query.setInteger(i++, nodeType);</span><br><span class="line">                query.setInteger(i++, nodeType);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">```修改为</span><br><span class="line"></span><br><span class="line">```query.setInteger(i++, nodeType);</span><br><span class="line">query.setInteger(i++, nodeType);</span><br></pre></td></tr></table></figure>
<h4 id="15-SE-COMPARATOR-SHOULD-BE-SERIALIZABLE"><a href="#15-SE-COMPARATOR-SHOULD-BE-SERIALIZABLE" class="headerlink" title="15. SE_COMPARATOR_SHOULD_BE_SERIALIZABLE"></a>15. SE_COMPARATOR_SHOULD_BE_SERIALIZABLE</h4><p>com.cmcc.aoi.selfhelp.task.entity.StatAppHabitComparator implements Comparator but not Serializable<br>This class implements the Comparator interface. You should consider whether or not it should also implement the Serializable interface. If a comparator is used to construct an ordered collection such as a TreeMap, then the TreeMap will be serializable only if the comparator is also serializable. As most comparators have little or no state, making them serializable is generally easy and good defensive programming.<br>修改为<br>implements Serializable</p>
<h4 id="16-UWF-UNWRITTEN-PUBLIC-OR-PROTECTED-FIELD"><a href="#16-UWF-UNWRITTEN-PUBLIC-OR-PROTECTED-FIELD" class="headerlink" title="16.  UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD"></a>16.  UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD</h4><p>Unwritten public or protected field: com.cmcc.aoi.selfhelp.task.entity.StatDevice.keyname<br>No writes were seen to this public/protected field.  All reads of it will return the default value. Check for errors (should it have been initialized?), or remove it if it is useless.<br>Public  String keyname;<br>修改为<br>Private  String keyname;</p>
<h4 id="18-RV-RETURN-VALUE-IGNORED-BAD-PRACTICE"><a href="#18-RV-RETURN-VALUE-IGNORED-BAD-PRACTICE" class="headerlink" title="18.  RV_RETURN_VALUE_IGNORED_BAD_PRACTICE"></a>18.  RV_RETURN_VALUE_IGNORED_BAD_PRACTICE</h4><p>Exceptional return value of java.io.File.mkdirs() ignored in com.cmcc.aoi.util.FileUtil.moveFile(File, String)<br>This method returns a value that is not checked. The return value should be checked since it can indicate an unusual or unexpected function execution. For example, the File.delete() method returns false if the file could not be successfully deleted (rather than throwing an Exception). If you don’t check the result, you won’t notice if the method invocation signals unexpected behavior by returning an atypical return value.<br>tmp.mkdirs()<br>修改为<br>booleanmkdirs = tmp.mkdirs();<br>logger.debug(“debug”,mkdirs);</p>
<p>REC_CATCH_EXCEPTION<br>Exception is caught when Exception is not thrown in com.cmcc.aoi.selfhelp.task.fileparser.TokenIncrease.parseLine(String[])<br>This method uses a try-catch block that catches Exception objects, but Exception is not thrown within the try block, and RuntimeException is not explicitly caught. It is a common bug pattern to say try { … } catch (Exception e) { something } as a shorthand for catching a number of types of exception each of whose catch blocks is identical, but this construct also accidentally catches RuntimeException as well, masking potential bugs.<br>A better approach is to either explicitly catch the specific exceptions that are thrown, or to explicitly catch RuntimeException exception, rethrow it, and then catch all non-Runtime Exceptions, as shown below:</p>
<figure class="highlight plain"><figcaption><span>&#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    ...</span><br><span class="line">  &#125; catch (RuntimeException e) &#123;</span><br><span class="line">    throw e;</span><br><span class="line">  &#125; catch (Exception e) &#123;</span><br><span class="line">    ... deal with all non-runtime exceptions ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line"> </span><br><span class="line">#### 19. ICAST_IDIV_CAST_TO_DOUBLE</span><br><span class="line">Integral division result cast to double or float in com.cmcc.aoi.selfhelp.service.BaseAnalysisService.getInterval(Date, Date, int)</span><br><span class="line">This code casts the result of an integral division (e.g., int or long division) operation to double or float. Doing division on integers truncates the result to the integer value closest to zero. The fact that the result was cast to double suggests that this precision should have been retained. What was probably meant was to cast one or both of the operands to double before performing the division. </span><br><span class="line">```Here is an example:</span><br><span class="line">int x = 2;</span><br><span class="line">int y = 5;</span><br><span class="line">// Wrong: yields result 0.0</span><br><span class="line">double value1 =  x / y;</span><br><span class="line"> </span><br><span class="line">// Right: yields result 0.4</span><br><span class="line">double value2 =  x / (double) y;</span><br></pre></td></tr></table></figure>
<h2 id="FindBugs规则整理"><a href="#FindBugs规则整理" class="headerlink" title="FindBugs规则整理"></a>FindBugs规则整理</h2><p>FindBugs是基于Bug Patterns概念，查找javabytecode（.class文件）中的潜在bug，主要检查bytecode中的bug patterns，如NullPoint空指针检查、没有合理关闭资源、字符串相同判断错（==，而不是equals）等</p>
<h3 id="一、Security-关于代码安全性防护"><a href="#一、Security-关于代码安全性防护" class="headerlink" title="一、Security 关于代码安全性防护"></a>一、Security 关于代码安全性防护</h3><p>1.Dm: Hardcoded constant database password (DMI_CONSTANT_DB_PASSWORD)<br>代码中创建DB的密码时采用了写死的密码。<br>2.Dm: Empty database password (DMI_EMPTY_DB_PASSWORD)<br>创建数据库连接时没有为数据库设置密码，这会使数据库没有必要的保护。<br>3.HRS: HTTP cookie formed from untrusted input (HRS_REQUEST_PARAMETER_TO_COOKIE)<br>此代码使用不受信任的HTTP参数构造一个HTTP Cookie。<br>4.HRS: HTTP Response splitting vulnerability (HRS_REQUEST_PARAMETER_TO_HTTP_HEADER)<br>在代码中直接把一个HTTP的参数写入一个HTTP头文件中，它为HTTP的响应暴露了漏洞。<br>5.SQL: Nonconstant string passed to execute method on an SQL statement (SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE)<br>该方法以字符串的形式来调用SQLstatement的execute方法，它似乎是动态生成SQL语句的方法。这会更容易受到SQL注入攻击。<br>6.XSS: JSP reflected cross site scripting vulnerability (XSS_REQUEST_PARAMETER_TO_JSP_WRITER)<br>在代码中在JSP输出中直接写入一个HTTP参数，这会造成一个跨站点的脚本漏洞。</p>
<h3 id="二、Experimental"><a href="#二、Experimental" class="headerlink" title="二、Experimental"></a>二、Experimental</h3><p>1.LG: Potential lost logger changes due to weak reference in OpenJDK (LG_LOST_LOGGER_DUE_TO_WEAK_REFERENCE)<br>OpenJDK的引入了一种潜在的不兼容问题，特别是，java.util.logging.Logger的行为改变时。它现在使用内部弱引用，而不是强引用。–logger配置改变，它就是丢失对logger的引用，这本是一个合理的变化，但不幸的是一些代码对旧的行为有依赖关系。这意味着，当进行垃圾收集时对logger配置将会丢失。例如：<br>public static void initLogging() throws Exception {<br> Logger logger = Logger.getLogger(“edu.umd.cs”);<br> logger.addHandler(new FileHandler()); // call to change logger configuration<br> logger.setUseParentHandlers(false); // another call to change logger configuration<br>}<br>该方法结束时logger的引用就丢失了，如果你刚刚结束调用initLogging方法后进行垃圾回收，logger的配置将会丢失（因为只有保持记录器弱引用）。<br>public static void main(String[] args) throws Exception {<br> initLogging(); // adds a file handler to the logger<br> System.gc(); // logger configuration lost<br> Logger.getLogger(“edu.umd.cs”).info(“Some message”); // this isn’t logged to the file as expected<br>}<br>2.OBL: Method may fail to clean up stream or resource (OBL_UNSATISFIED_OBLIGATION)<br>这种方法可能无法清除（关闭，处置）一个流，数据库对象，或其他资源需要一个明确的清理行动。<br>一般来说，如果一个方法打开一个流或其他资源，该方法应该使用try / finally块来确保在方法返回之前流或资源已经被清除了。这种错误模式基本上和OS_OPEN_STREAM和ODR_OPEN_DATABASE_RESOURCE错误模式相同，但是是在不同在静态分析技术。我们正为这个错误模式的效用收集反馈意见。</p>
<h3 id="三、Bad-practice代码实现中的一些坏习惯"><a href="#三、Bad-practice代码实现中的一些坏习惯" class="headerlink" title="三、Bad practice代码实现中的一些坏习惯"></a>三、Bad practice代码实现中的一些坏习惯</h3><p>1.AM: Creates an empty jar file entry (AM_CREATES_EMPTY_JAR_FILE_ENTRY)<br>调用putNextEntry()方法写入新的 jar 文件条目时立即调用closeEntry()方法。这样会造成JarFile条目为空。<br>2.AM: Creates an empty zip file entry (AM_CREATES_EMPTY_ZIP_FILE_ENTRY)<br>调用putNextEntry()方法写入新的 zip 文件条目时立即调用closeEntry()方法。这样会造成ZipFile条目为空。<br>3.BC: Equals method should not assume anything about the type of its argument (BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS)<br>equals(Object o)方法不能对参数o的类型做任何的假设。比较此对象与指定的对象。当且仅当该参数不为 null，并且是表示与此对象相同的类型的对象时，结果才为 true。<br>4.BC: Random object created and used only once (DMI_RANDOM_USED_ONLY_ONCE)<br>随机创建对象只使用过一次就抛弃<br>5.BIT: Check for sign of bitwise operation (BIT_SIGNED_CHECK)<br>检查位操作符运行是否合理<br>((event.detail &amp; SWT.SELECTED) &gt; 0)<br>If SWT.SELECTED is a negative number, this is a candidate for a bug. Even when SWT.SELECTED is not negative, it seems good practice to use ‘!= 0’ instead of ‘&gt; 0’.<br>6.CN: Class implements Cloneable but does not define or use clone method (CN_IDIOM)<br>按照惯例，实现此接口的类应该使用公共方法重写 Object.clone（它是受保护的），以获得有关重写此方法的详细信息。此接口不 包含 clone 方法。因此，因为某个对象实现了此接口就克隆它是不可能的,应该实现此接口的类应该使用公共方法重写 Object.clone<br>7.CN: clone method does not call super.clone() (CN_IDIOM_NO_SUPER_CALL)<br>一个非final类型的类定义了clone()方法而没有调用super.clone()方法。例如：B扩展自A，如果B中clone方法调用了spuer.clone（），而A中的clone没有调用spuer.clone()，就会造成结果类型不准确。要求A的clone方法中调用spuer.clone()方法。<br>8.CN: Class defines clone() but doesn’t implement Cloneable (CN_IMPLEMENTS_CLONE_BUT_NOT_CLONEABLE)<br>类中定义了clone方法但是它没有实现Cloneable接口<br>9.Co: Abstract class defines covariant compareTo() method (CO_ABSTRACT_SELF)<br>抽象类中定义了多个compareTo()方法，正确的是覆写Comparable中的compareTo方法，方法的参数为Object类型，如下例：<br>int compareTo(T o)  比较此对象与指定对象的顺序。<br>10.Co: Covariant compareTo() method defined (CO_SELF_NO_OBJECT)<br>类中定义了多个compareTo()方法，正确的是覆写Comparable中的compareTo方法，方法的参数为Object类型<br>11.DE: Method might drop exception (DE_MIGHT_DROP)<br>方法可能抛出异常<br>12.DE: Method might ignore exception (DE_MIGHT_IGNORE)<br>方法可能忽略异常<br>13.DMI: Don’t use removeAll to clear a collection (DMI_USING_REMOVEALL_TO_CLEAR_COLLECTION)<br>不要用removeAll方法去clear一个集合<br>14.DP: Classloaders should only be created inside doPrivileged block (DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED)<br>类加载器只能建立在特殊的方法体内<br>15.Dm: Method invokes System.exit(…) (DM_EXIT)<br>在方法中调用System.exit(…)语句，考虑用RuntimeException来代替<br>16.Dm: Method invokes dangerous method runFinalizersOnExit (DM_RUN_FINALIZERS_ON_EXIT)<br>在方法中调用了System.runFinalizersOnExit 或者Runtime.runFinalizersOnExit方法，因为这样做是很危险的。<br>17.ES: Comparison of String parameter using == or != (ES_COMPARING_PARAMETER_STRING_WITH_EQ)<br>用==或者!=方法去比较String类型的参数<br>18.ES: Comparison of String objects using == or != (ES_COMPARING_STRINGS_WITH_EQ)<br>用==或者！=去比较String类型的对象<br>19.Eq: Abstract class defines covariant equals() method (EQ_ABSTRACT_SELF)<br>20.Eq: Equals checks for noncompatible operand (EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS)<br>equals方法检查不一致的操作。两个类根本就是父子关系而去调用equals方法去判读对象是否相等。<br>public boolean equals(Object o) {<br>  if (o instanceof Foo)<br>    return name.equals(((Foo)o).name);<br>  else if (o instanceof String)<br>    return name.equals(o);<br>  else return false;<br>21.Eq: Class defines compareTo(…) and uses Object.equals() (EQ_COMPARETO_USE_OBJECT_EQUALS)<br>类中定义了compareTo方法但是继承了Object中的compareTo方法<br>22.Eq: equals method fails for subtypes (EQ_GETCLASS_AND_CLASS_CONSTANT)<br>类中的equals方法可能被子类中的方法所破坏，当使用类似于Foo.class == o.getClass()的判断时考虑用this.getClass() == o.getClass()来替换<br>23.Eq: Covariant equals() method defined (EQ_SELF_NO_OBJECT)<br>类中定义了多个equals方法。正确的做法是覆写Object中的equals方法，它的参数为Object类型的对象。<br>24.FI: Empty finalizer should be deleted (FI_EMPTY)<br>为空的finalizer方法应该删除。一下关于finalizer的内容省略<br>25.GC: Unchecked type in generic call (GC_UNCHECKED_TYPE_IN_GENERIC_CALL)<br>This call to a generic collection method passes an argument while compile type Object where a specific type from the generic type parameters is expected. Thus, neither the standard Java type system nor static analysis can provide useful information on whether the object being passed as a parameter is of an appropriate type.<br>26.HE: Class defines equals() but not hashCode() (HE_EQUALS_NO_HASHCODE)<br>方法定义了equals方法却没有定义hashCode方法<br>27.HE: Class defines hashCode() but not equals() (HE_HASHCODE_NO_EQUALS)<br> 类定义了hashCode方法去没有定义equal方法<br>28.HE: Class defines equals() and uses Object.hashCode() (HE_EQUALS_USE_HASHCODE)<br>一个类覆写了equals方法，没有覆写hashCode方法，使用了Object对象的hashCode方法<br>29.HE: Class inherits equals() and uses Object.hashCode() (HE_INHERITS_EQUALS_USE_HASHCODE)<br>子类继承了父类的equals方法却使用了Object的hashCode方法<br>30.IC: Superclass uses subclass during initialization (IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION)<br>子类在父类未初始化之前使用父类对象实例<br>public class CircularClassInitialization {<br>        static class InnerClassSingleton extends CircularClassInitialization {<br>static InnerClassSingleton singleton = new InnerClassSingleton();<br>        }<br>        static CircularClassInitialization foo = InnerClassSingleton.singleton;<br>}<br>31.IMSE: Dubious catching of IllegalMonitorStateException (IMSE_DONT_CATCH_IMSE)<br>捕捉违法的监控状态异常，例如当没有获取到对象锁时使用其wait和notify方法<br>32.ISC: Needless instantiation of class that only supplies static methods (ISC_INSTANTIATE_STATIC_CLASS)<br>为使用静态方法而创建一个实例对象。调用静态方法时只需要使用类名+静态方法名就可以了。<br>33.It: Iterator next() method can’t throw NoSuchElementException (IT_NO_SUCH_ELEMENT)<br>迭代器的next方法不能够抛出NoSuchElementException<br>34.J2EE: Store of non serializable object into HttpSession (J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION)<br>在HttpSession对象中保存非连续的对象<br>35.JCIP: Fields of immutable classes should be final (JCIP_FIELD_ISNT_FINAL_IN_IMMUTABLE_CLASS)<br> The class is annotated with net.jcip.annotations.Immutable, and the rules for that annotation require that all fields are final. .<br>36.NP: Method with Boolean return type returns explicit null (NP_BOOLEAN_RETURN_NULL)<br>返回值为boolean类型的方法直接返回null，这样会导致空指针异常<br>37.NP: equals() method does not check for null argument (NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT)<br>变量调用equals方法时没有进行是否为null的判断<br>38.NP: toString method may return null (NP_TOSTRING_COULD_RETURN_NULL)<br>toString方法可能返回null<br>39.Nm: Class names should start with an upper case letter (NM_CLASS_NAMING_CONVENTION)<br>类的名称以大写字母名称开头<br>40.Nm: Class is not derived from an Exception, even though it is named as such (NM_CLASS_NOT_EXCEPTION)<br>类的名称中含有Exception但是却不是一个异常类的子类，这种名称会造成混淆<br>41.Nm: Confusing method names (NM_CONFUSING)<br>令人迷惑的方面命名<br>42.Nm: Field names should start with a lower case letter (NM_FIELD_NAMING_CONVENTION)<br>非final类型的字段需要遵循驼峰命名原则<br>43.Nm: Use of identifier that is a keyword in later versions of Java (NM_FUTURE_KEYWORD_USED_AS_IDENTIFIER)<br>验证是否是java预留关键字<br>44.Nm: Use of identifier that is a keyword in later versions of Java (NM_FUTURE_KEYWORD_USED_AS_MEMBER_IDENTIFIER)<br>验证是否时java中的关键字<br>45.Nm: Method names should start with a lower case letter (NM_METHOD_NAMING_CONVENTION)<br>方法名称以小写字母开头<br>46.Nm: Class names shouldn’t shadow simple name of implemented interface (NM_SAME_SIMPLE_NAME_AS_INTERFACE)<br>实现同一接口实现类不能使用相同的名称，即使它们位于不同的包中<br>47.Nm: Class names shouldn’t shadow simple name of superclass (NM_SAME_SIMPLE_NAME_AS_SUPERCLASS)<br>继承同一父类的子类不能使用相同的名称，即使它们位于不同的包中<br>48.Nm: Very confusing method names (but perhaps intentional) (NM_VERY_CONFUSING_INTENTIONAL)<br>很容易混淆的方法命名，例如方法的名称名称使用使用大小写来区别两个不同的方法。<br>49.Nm: Method doesn’t override method in superclass due to wrong package for parameter (NM_WRONG_PACKAGE_INTENTIONAL)<br>由于错误引用了不同包中相同类名的对象而不能够正确的覆写父类中的方法<br>import alpha.Foo;<br>public class A {<br>  public int f(Foo x) { return 17; }<br>}<br>import beta.Foo;<br>public class B extends A {<br>  public int f(Foo x) { return 42; }<br>  public int f(alpha.Foo x) { return 27; }<br>}<br>50.ODR: Method may fail to close database resource (ODR_OPEN_DATABASE_RESOURCE)<br>方法中可能存在关闭数据连接失败的情况<br>51.OS: Method may fail to close stream (OS_OPEN_STREAM)<br>方法中可能存在关闭流失败的情况<br>52.OS: Method may fail to close stream on exception (OS_OPEN_STREAM_EXCEPTION_PATH)<br>方法中可能存在关闭流时出现异常情况<br>53.RC: Suspicious reference comparison to constant (RC_REF_COMPARISON_BAD_PRACTICE)<br>当两者为不同类型的对象时使用equals方法来比较它们的值是否相等，而不是使用==方法。例如比较的两者为java.lang.Integer, java.lang.Float<br>54.RC: Suspicious reference comparison of Boolean values (RC_REF_COMPARISON_BAD_PRACTICE_BOOLEAN)<br>使用== 或者 !=操作符来比较两个 Boolean类型的对象，建议使用equals方法。<br>55.RR: Method ignores results of InputStream.read() (RR_NOT_CHECKED)<br>InputStream.read方法忽略返回的多个字符，如果对结果没有检查就没法正确处理用户读取少量字符请求的情况。<br>56.RR: Method ignores results of InputStream.skip() (SR_NOT_CHECKED)<br>InputStream.skip()方法忽略返回的多个字符，如果对结果没有检查就没法正确处理用户跳过少量字符请求的情况<br>57.RV: Method ignores exceptional return value (RV_RETURN_VALUE_IGNORED_BAD_PRACTICE)<br>方法忽略返回值的异常信息<br>58.SI: Static initializer creates instance before all static final fields assigned (SI_INSTANCE_BEFORE_FINALS_ASSIGNED)<br>在所有的static final字段赋值之前去使用静态初始化的方法创建一个类的实例。<br>59.Se: Non-serializable value stored into instance field of a serializable class (SE_BAD_FIELD_STORE)<br>非序列化的值保存在声明为序列化的的非序列化字段中<br>60.Se: Comparator doesn’t implement Serializable (SE_COMPARATOR_SHOULD_BE_SERIALIZABLE)<br>Comparator接口没有实现Serializable接口<br>61.Se: Serializable inner class (SE_INNER_CLASS)<br>序列化内部类<br>62.Se: serialVersionUID isn’t final (SE_NONFINAL_SERIALVERSIONID)<br>关于UID类的检查内容省略<br>63.Se: Class is Serializable but its superclass doesn’t define a void constructor (SE_NO_SUITABLE_CONSTRUCTOR)<br>子类序列化时父类没有提供一个void的构造函数<br>64.Se: Class is Externalizable but doesn’t define a void constructor (SE_NO_SUITABLE_CONSTRUCTOR_FOR_EXTERNALIZATION)<br>Externalizable 实例类没有定义一个void类型的构造函数<br>65.Se: The readResolve method must be declared with a return type of Object. (SE_READ_RESOLVE_MUST_RETURN_OBJECT)<br>readResolve从流中读取类的一个实例，此方法必须声明返回一个Object类型的对象<br>66.Se: Transient field that isn’t set by deserialization. (SE_TRANSIENT_FIELD_NOT_RESTORED)<br>This class contains a field that is updated at multiple places in the class, thus it seems to be part of the state of the class. However, since the field is marked as transient and not set in readObject or readResolve, it will contain the default value in any deserialized instance of the class.<br>67.SnVI: Class is Serializable, but doesn’t define serialVersionUID (SE_NO_SERIALVERSIONID)<br>一个类实现了Serializable接口但是没有定义serialVersionUID类型的变量。序列化运行时使用一个称为 serialVersionUID 的版本号与每个可序列化类相关联，该序列号在反序列化过程中用于验证序列化对象的发送者和接收者是否为该对象加载了与序列化兼容的类。如果接收者加载的该对象的类的 serialVersionUID 与对应的发送者的类的版本号不同，则反序列化将会导致 InvalidClassException。可序列化类可以通过声明名为 “serialVersionUID” 的字段（该字段必须是静态 (static)、最终 (final) 的 long 型字段）显式声明其自己的 serialVersionUID：<br> ANY-ACCESS-MODIFIER static final long serialVersionUID = 42L;<br>68.UI: Usage of GetResource may be unsafe if class is extended (UI_INHERITANCE_UNSAFE_GETRESOURCE)<br>当一个类被子类继承后不要使用this.getClass().getResource(…)来获取资源</p>
<h3 id="四、Correctness关于代码正确性相关方面的"><a href="#四、Correctness关于代码正确性相关方面的" class="headerlink" title="四、Correctness关于代码正确性相关方面的"></a>四、Correctness关于代码正确性相关方面的</h3><p>1.BC: Impossible cast (BC_IMPOSSIBLE_CAST)<br>不可能的类转换，执行时会抛出ClassCastException<br>2.BC: Impossible downcast (BC_IMPOSSIBLE_DOWNCAST)<br>父类在向下进行类型转换时抛出ClassCastException<br>3.BC: Impossible downcast of toArray() result (BC_IMPOSSIBLE_DOWNCAST_OF_TOARRAY)<br>集合转换为数组元素时发生的类转换错误。<br>This code is casting the result of calling toArray() on a collection to a type more specific than Object[], as in:<br>String[] getAsArray(Collection<string> c) {<br>  return (String[]) c.toArray();<br>  }<br>This will usually fail by throwing a ClassCastException. The toArray() of almost all collections return an Object[]. They can’t really do anything else, since the Collection object has no reference to the declared generic type of the collection.<br>The correct way to do get an array of a specific type from a collection is to use c.toArray(new String[]); or c.toArray(new String[c.size()]); (the latter is slightly more efficient).<br>4.BC: instanceof will always return false (BC_IMPOSSIBLE_INSTANCEOF)<br>采用instaneof方法进行比较时总是返回false。前提是保证它不是由于某些逻辑错误造成的。<br>5.BIT: Incompatible bit masks (BIT_AND)<br>错误的使用&amp;位操作符，例如(e &amp; C)<br>6.BIT: Check to see if ((…) &amp; 0) == 0 (BIT_AND_ZZ)<br>检查恒等的逻辑错误<br>7.BIT: Incompatible bit masks (BIT_IOR)<br>错误的使用|位操作符，例如(e | C)<br>8.BIT: Check for sign of bitwise operation (BIT_SIGNED_CHECK_HIGH_BIT)<br>检查逻辑运算符操作返回的标识。例如((event.detail &amp; SWT.SELECTED) &gt; 0)，建议采用!=0代替&gt;0<br>9.BOA: Class overrides a method implemented in super class Adapter wrongly (BOA_BADLY_OVERRIDDEN_ADAPTER)<br>子类错误的覆写父类中用于适配监听其他事件的方法，从而导致当触发条件发生时不能被监听者调用<br>10.Bx: Primitive value is unboxed and coerced for ternary operator (BX_UNBOXED_AND_COERCED_FOR_TERNARY_OPERATOR)<br>在三元运算符操作时如果没有对值进行封装或者类型转换。例如：b ? e1 : e2<br>11.DLS: Dead store of class literal (DLS_DEAD_STORE_OF_CLASS_LITERAL)<br>以类的字面名称方式为一个字段赋值后再也没有去使用它，在1.4jdk中它会自动调用静态的初始化方法，而在jdk1.5中却不会去执行。<br>12.DLS: Overwritten increment (DLS_OVERWRITTEN_INCREMENT)<br>覆写增量增加错误i = i++<br>13.DMI: Bad constant value for month (DMI_BAD_MONTH)<br>hashNext方法调用next方法。<br>14.DMI: Collections should not contain themselves (DMI_COLLECTIONS_SHOULD_NOT_CONTAIN_THEMSELVES)<br>集合没有包含他们自己本身。<br>15.DMI: Invocation of hashCode on an array (DMI_INVOKING_HASHCODE_ON_ARRAY)<br>数组直接使用hashCode方法来返回哈希码。<br>int [] a1 = new int[]{1,2,3,4};<br>        System.out.println(a1.hashCode());<br>        System.out.println(java.util.Arrays.hashCode(a1));<br>16.DMI: Double.longBitsToDouble invoked on an int (DMI_LONG_BITS_TO_DOUBLE_INVOKED_ON_INT)<br>17.DMI: Vacuous call to collections (DMI_VACUOUS_SELF_COLLECTION_CALL)<br>集合的调用不能被感知。例如c.containsAll(c)总是返回true，而c.retainAll(c)的返回值不能被感知。<br>18.Dm: Can’t use reflection to check for presence of annotation without runtime retention (DMI_ANNOTATION_IS_NOT_VISIBLE_TO_REFLECTION)<br>Unless an annotation has itself been annotated with @Retention(RetentionPolicy.RUNTIME), the annotation can’t be observed using reflection (e.g., by using the isAnnotationPresent method). .<br>19.Dm: Useless/vacuous call to EasyMock method (DMI_VACUOUS_CALL_TO_EASYMOCK_METHOD)<br>While ScheduledThreadPoolExecutor inherits from ThreadPoolExecutor, a few of the inherited tuning methods are not useful for it. In particular, because it acts as a fixed-sized pool using corePoolSize threads and an unbounded queue, adjustments to maximumPoolSize have no useful effect.<br>20.EC: equals() used to compare array and nonarray (EC_ARRAY_AND_NONARRAY)<br>数组对象使用equals方法和非数组对象进行比较。即使比较的双方都是数组对象也不应该使用equals方法，而应该比较它们的内容是否相等使用java.util.Arrays.equals(Object[], Object[]);<br>21.EC: equals(…) used to compare incompatible arrays (EC_INCOMPATIBLE_ARRAY_COMPARE)<br>使用equls方法去比较类型不相同的数组。例如：String[] and StringBuffer[], or String[] and int[]<br>22.EC: Call to equals() with null argument (EC_NULL_ARG)<br>调用equals的对象为null<br>23.EC: Call to equals() comparing unrelated class and interface (EC_UNRELATED_CLASS_AND_INTERFACE)<br>使用equals方法比较不相关的类和接口<br>24.EC: Call to equals() comparing different interface types (EC_UNRELATED_INTERFACES)<br>调用equals方法比较不同类型的接口<br>25.EC: Call to equals() comparing different types (EC_UNRELATED_TYPES)<br>调用equals方法比较不同类型的类<br>26.EC: Using pointer equality to compare different types (EC_UNRELATED_TYPES_USING_POINTER_EQUALITY)<br>This method uses using pointer equality to compare two references that seem to be of different types. The result of this comparison will always be false at runtime.<br>27.Eq: equals method always returns false (EQ_ALWAYS_FALSE)<br>使用equals方法返回值总是false<br>28.Eq: equals method always returns true (EQ_ALWAYS_TRUE)<br>equals方法返回值总是true<br>29.Eq: equals method compares class names rather than class objects (EQ_COMPARING_CLASS_NAMES)<br>使用equals方法去比较一个类的实例和类的类型<br>30.Eq: Covariant equals() method defined for enum (EQ_DONT_DEFINE_EQUALS_FOR_ENUM)<br>This class defines an enumeration, and equality on enumerations are defined using object identity. Defining a covariant equals method for an enumeration value is exceptionally bad practice, since it would likely result in having two different enumeration values that compare as equals using the covariant enum method, and as not equal when compared normally. Don’t do it.<br>31.Eq: equals() method defined that doesn’t override equals(Object) (EQ_OTHER_NO_OBJECT)<br>类中定义的equals方法时不要覆写equals（Object）方法<br>32.Eq: equals() method defined that doesn’t override Object.equals(Object) (EQ_OTHER_USE_OBJECT)<br>类中定义的equals方法时不要覆写Object中的equals（Object）方法<br>33.Eq: equals method overrides equals in superclass and may not be symmetric (EQ_OVERRIDING_EQUALS_NOT_SYMMETRIC)<br>34.Eq: Covariant equals() method defined, Object.equals(Object) inherited (EQ_SELF_USE_OBJECT)<br>类中定义了一组equals方法，但是都是继承的java.lang.Object class中的equals(Object)方法<br>35.FE: Doomed test for equality to NaN (FE_TEST_IF_EQUAL_TO_NOT_A_NUMBER)<br>This code checks to see if a floating point value is equal to the special Not A Number value (e.g., if (x == Double.NaN)). However, because of the special semantics of NaN, no value is equal to Nan, including NaN. Thus, x == Double.NaN always evaluates to false. To check to see if a value contained in x is the special Not A Number value, use Double.isNaN(x) (or Float.isNaN(x) if x is floating point precision).<br>36.FS: Format string placeholder incompatible with passed argument (VA_FORMAT_STRING_BAD_ARGUMENT)<br>错误使用参数类型来格式化字符串<br>37.FS: The type of a supplied argument doesn’t match format specifier (VA_FORMAT_STRING_BAD_CONVERSION)<br>指定的格式字符串和参数类型不匹配，例如：String.format(“%d”, “1”)<br>38.FS: MessageFormat supplied where printf style format expected (VA_FORMAT_STRING_EXPECTED_MESSAGE_FORMAT_SUPPLIED)<br>但用String的format方法时实际调用了ＭｅｓｓａｇｅＦｏｒｍａｔ中干的格式化方法而引起格式化结果出错。<br>39.FS: More arguments are passed than are actually used in the format string (VA_FORMAT_STRING_EXTRA_ARGUMENTS_PASSED)<br>使用String的format方法时有非法的参数也经过了格式化操作。<br>40.FS: Illegal format string (VA_FORMAT_STRING_ILLEGAL)<br>格式化String对象语句错误<br>41.FS: Format string references missing argument (VA_FORMAT_STRING_MISSING_ARGUMENT)<br>String的format操作缺少必要的参数。<br>42.FS: No previous argument for format string (VA_FORMAT_STRING_NO_PREVIOUS_ARGUMENT)<br>格式字符串定义错误，例如：formatter.format(“%&lt;s %s”, “a”, “b”); 抛出MissingFormatArgumentException异常<br>43.GC: No relationship between generic parameter and method argument (GC_UNRELATED_TYPES)<br>This call to a generic collection method contains an argument with an incompatible class from that of the collection’s parameter (i.e., the type of the argument is neither a supertype nor a subtype of the corresponding generic type argument). Therefore, it is unlikely that the collection contains any objects that are equal to the method argument used here. Most likely, the wrong value is being passed to the method.<br>In general, instances of two unrelated classes are not equal. For example, if the Foo and Bar classes are not related by subtyping, then an instance of Foo should not be equal to an instance of Bar. Among other issues, doing so will likely result in an equals method that is not symmetrical. For example, if you define the Foo class so that a Foo can be equal to a String, your equals method isn’t symmetrical since a String can only be equal to a String.<br>In rare cases, people do define nonsymmetrical equals methods and still manage to make their code work. Although none of the APIs document or guarantee it, it is typically the case that if you check if a Collection<string> contains a Foo, the equals method of argument (e.g., the equals method of the Foo class) used to perform the equality checks.<br>44.HE: Signature declares use of unhashable class in hashed construct (HE_SIGNATURE_DECLARES_HASHING_OF_UNHASHABLE_CLASS)<br>A method, field or class declares a generic signature where a non-hashable class is used in context where a hashable class is required. A class that declares an equals method but inherits a hashCode() method from Object is unhashable, since it doesn’t fulfill the requirement that equal objects have equal hashCodes.<br>45.HE: Use of class without a hashCode() method in a hashed data structure (HE_USE_OF_UNHASHABLE_CLASS)<br>A class defines an equals(Object) method but not a hashCode() method, and thus doesn’t fulfill the requirement that equal objects have equal hashCodes. An instance of this class is used in a hash data structure, making the need to fix this problem of highest importance.<br>46.ICAST: integral value cast to double and then passed to Math.ceil (ICAST_INT_CAST_TO_DOUBLE_PASSED_TO_CEIL)<br>integral的值转换为double后使用了Math.ceil方法<br>47.ICAST: int value cast to float and then passed to Math.round (ICAST_INT_CAST_TO_FLOAT_PASSED_TO_ROUND)<br>int 类型的值转换为float类型之后调用了Math.round方法<br>48.IJU: JUnit assertion in run method will not be noticed by JUnit (IJU_ASSERT_METHOD_INVOKED_FROM_RUN_METHOD)<br>在JUnit中的断言在run方法中不会被告知<br>49.IJU: TestCase declares a bad suite method (IJU_BAD_SUITE_METHOD)<br>在一个JUnit类中声明的一个suite()方法必须声明为<br>public static junit.framework.Test suite()<br>或者<br>public static junit.framework.TestSuite suite()的形式。<br>50.IL: A collection is added to itself (IL_CONTAINER_ADDED_TO_ITSELF)<br>集合本身作为add方法的参数，这样会引起内容溢出。<br>51.IL: An apparent infinite loop (IL_INFINITE_LOOP)<br>方法的自调用引起的死循环<br>52.IM: Integer multiply of result of integer remainder (IM_MULTIPLYING_RESULT_OF_IREM)<br>和整数余数进行乘法运算。例如：i % 60 <em> 1000 是进行(i % 60) </em> 1000运算而不是 i % (60 * 1000)<br>53.INT: Bad comparison of nonnegative value with negative constant (INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE)<br>保证非负数和负数进行比较<br>54.INT: Bad comparison of signed byte (INT_BAD_COMPARISON_WITH_SIGNED_BYTE)<br>比较有符合数，要先把有符号数转换为无符合数再进行比较<br>55.IO: Doomed attempt to append to an object output stream (IO_APPENDING_TO_OBJECT_OUTPUT_STREAM)<br>宣布试图在对象的输出流处添加元素，如果你希望能够添加进一个对象的输出流中必须保证对象的输出流处于打开状态。<br>56.IP: A parameter is dead upon entry to a method but overwritten (IP_PARAMETER_IS_DEAD_BUT_OVERWRITTEN)<br>The initial value of this parameter is ignored, and the parameter is overwritten here. This often indicates a mistaken belief that the write to the parameter will be conveyed back to the caller.<br>传入参数的值被忽略，但是对传入值进行了修改，并返回给了调用者<br>57.MF: Class defines field that masks a superclass field (MF_CLASS_MASKS_FIELD)<br>子类中定义了和父类中同名的字段。在调用时会出错<br>58.MF: Method defines a variable that obscures a field (MF_METHOD_MASKS_FIELD)<br>在方法中定义的局部变量和类变量或者父类变量同名，从而引起字段混淆。<br>59.NP: Null pointer dereference (NP_ALWAYS_NULL)<br>对象赋为null值后 没有被重新赋值<br>60.NP: Null pointer dereference in method on exception path (NP_ALWAYS_NULL_EXCEPTION)<br>A pointer which is null on an exception path is dereferenced here.  This will lead to a NullPointerException when the code is executed.  Note that because FindBugs currently does not prune infeasible exception paths, this may be a false warning.<br>Also note that FindBugs considers the default case of a switch statement to be an exception path, since the default case is often infeasible.<br>空指针引用上调用去除引用方法，将发生空指针异常<br>61.NP: Method does not check for null argument (NP_ARGUMENT_MIGHT_BE_NULL)<br>方法没有判断参数是否为空<br>62.NP: close() invoked on a value that is always null (NP_CLOSING_NULL)<br>一个为空的对象调用close方法<br>63.NP: Null value is guaranteed to be dereferenced (NP_GUARANTEED_DEREF)<br>There is a statement or branch that if executed guarantees that a value is null at this point, and that value that is guaranteed to be dereferenced (except on forward paths involving runtime exceptions).<br>在正常的null判断分支上，对象去除引用操作是受保护的不允许的<br>64.NP: Value is null and guaranteed to be dereferenced on exception path (NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH)<br>There is a statement or branch on an exception path that if executed guarantees that a value is null at this point, and that value that is guaranteed to be dereferenced (except on forward paths involving runtime exceptions).<br>65.NP: Method call passes null to a nonnull parameter (NP_NONNULL_PARAM_VIOLATION)<br>方法中为null的参数没有被重新赋值<br>        void test(){<br>String ss = null;<br>sya(ss);<br>        }<br>        public void sya(String ad){<br>ad.getBytes();<br>        }<br>66.NP: Method may return null, but is declared @NonNull (NP_NONNULL_RETURN_VIOLATION)<br>方法声明了返回值不能为空，但是方法中有可能返回null<br>67.NP: A known null value is checked to see if it is an instance of a type (NP_NULL_INSTANCEOF)<br>检查一个为null的值是否是想要的类型对象，而不是由于粗心或者逻辑错误引起的<br>68.NP: Possible null pointer dereference (NP_NULL_ON_SOME_PATH)<br>对象可能没有重新赋值<br>69.NP: Possible null pointer dereference in method on exception path (NP_NULL_ON_SOME_PATH_EXCEPTION)<br>A reference value which is null on some exception control path is dereferenced here.  This may lead to a NullPointerException when the code is executed.  Note that because FindBugs currently does not prune infeasible exception paths, this may be a false warning.<br>Also note that FindBugs considers the default case of a switch statement to be an exception path, since the default case is often infeasible.<br>在异常null值处理分支调用的方法上，可能存在对象去除引用操作<br>70.NP: Method call passes null for nonnull parameter (NP_NULL_PARAM_DEREF_ALL_TARGETS_DANGEROUS)<br>方法参数中声明为nonnull类型的参数为null<br>void test(){<br>String ss = null;<br>sya(ss);<br>        }<br>        public void sya(@nonnull String ad){<br>ad.getBytes();<br>        }<br>71.NP: Store of null value into field annotated NonNull (NP_STORE_INTO_NONNULL_FIELD)<br>为一个已经声明为不能为null值的属性赋值为null。<br>72.Nm: Class defines equal(Object); should it be equals(Object)? (NM_BAD_EQUAL)<br>类中定义了一个equal方法但是却不是覆写的Object对象的equals方法<br>73.Nm: Class defines hashcode(); should it be hashCode()? (NM_LCASE_HASHCODE)<br>类中定义了一个hashCode方法但是却不是覆写的Object中的hashCode方法<br>74.Nm: Class defines tostring(); should it be toString()? (NM_LCASE_TOSTRING)<br>类中定义了一个toString方法但是却不是覆写的Object中的toString方法<br>75.Nm: Apparent method/constructor confusion (NM_METHOD_CONSTRUCTOR_CONFUSION)<br>构造方法定义混乱，保证一个标准的构造函数。        例如：<br>        SA(){        }<br>        void SA(){<br>        }<br>76.Nm: Very confusing method names (NM_VERY_CONFUSING)<br>混乱的方法命名，如getName和getname方法同时出现的时候<br>77.Nm: Method doesn’t override method in superclass due to wrong package for parameter (NM_WRONG_PACKAGE)<br>方法因为取了不同包中的同名的对象而没有正确覆写父类中的同名方法<br>import alpha.Foo;<br>public class A {<br>  public int f(Foo x) { return 17; }<br>}</string></string></p>
<p>import beta.Foo;<br>public class B extends A {<br>  public int f(Foo x) { return 42; }<br>}<br>78.QBA: Method assigns boolean literal in boolean expression (QBA_QUESTIONABLE_BOOLEAN_ASSIGNMENT)<br>再if或者while表达式中使用boolean类型的值时应该使用==去判断，而不是采用=操作<br>79.RC: Suspicious reference comparison (RC_REF_COMPARISON)<br>比较两个对象值是否相等时应该采用equals方法，而不是==方法<br>80.RE: Invalid syntax for regular expression (RE_BAD_SYNTAX_FOR_REGULAR_EXPRESSION)<br>对正则表达式使用了错误的语法，会抛出未经检查的异常，表明正则表达式模式中的语法错误。<br>81.RE: File.separator used for regular expression (RE_CANT_USE_FILE_SEPARATOR_AS_REGULAR_EXPRESSION)<br>使用正则表达式使用了错误的文件分隔符，在windows系统中正则表达式不会匹配’\’而应该使用’\‘<br>82.RV: Random value from 0 to 1 is coerced to the integer 0 (RV_01_TO_INT)<br>从0到1随机值被强制为整数值0。在强制得到一个整数之前，你可能想得到多个随机值。或使用Random.nextInt（n）的方法。<br>83.RV: Bad attempt to compute absolute value of signed 32-bit hashcode (RV_ABSOLUTE_VALUE_OF_HASHCODE)<br>此代码生成一个哈希码，然后计算该哈希码的绝对值。如果哈希码是Integer.MIN_VALUE的，那么结果将是负数（因为Math.abs（Integer.MIN_VALUE的）== Integer.MIN_VALUE的）。<br>在2^ 32值之外字符串有一个Integer.MIN_VALUE的hashCode包括“polygenelubricants”，“GydZG_”和“，”DESIGNING WORKHOUSES “。<br>84.RV: Bad attempt to compute absolute value of signed 32-bit random integer (RV_ABSOLUTE_VALUE_OF_RANDOM_INT)<br>此代码生成一个随机的符号整数，然后计算该随机整数的绝对值。如果随机数生成数绝对值为Integer.MIN_VALUE的，那么结果将是负数（因为Math.abs（Integer.MIN_VALUE的）== Integer.MIN_VALUE的）。<br>85.RV: Exception created and dropped rather than thrown (RV_EXCEPTION_NOT_THROWN)<br>此代码创建一个异常（或错误）的对象，但不会用它做任何事情。例如：if (x &lt; 0)<br>  new IllegalArgumentException(“x must be nonnegative”);<br>这可能是程序员的意图抛出创建的异常：<br>if (x &lt; 0)<br>  throw new IllegalArgumentException(“x must be nonnegative”);<br>86.RV: Method ignores return value (RV_RETURN_VALUE_IGNORED)<br>该方法的返回值应该进行检查。这种警告通常出现在调用一个不可变对象的方法，认为它更新了对象的值。例如：String dateString = getHeaderField(name);<br>dateString.trim();<br>程序员似乎以为trim（）方法将更新dateString引用的字符串。但由于字符串是不可改变的，trim（）函数返回一个新字符串值，在这里它是被忽略了。该代码应更正：<br>String dateString = getHeaderField(name);<br>dateString = dateString.trim();<br>87.RpC: Repeated conditional tests (RpC_REPEATED_CONDITIONAL_TEST)<br>该代码包含对同一个条件试验了两次，两边完全一样例如：（如X == 0 | | x == 0）。可能第二次出现是打算判断别的不同条件（如X == 0 | | y== 0）。<br>88.SA: Double assignment of field (SA_FIELD_DOUBLE_ASSIGNMENT)<br>方法中的字段包含了双重任务，例如：<br> int x;<br>  public void foo() {<br>   x = x = 17;<br>  }<br>这种为变量赋值是无用的，并可能表明一个逻辑错误或拼写错误。<br>89.SA: Self assignment of field (SA_FIELD_SELF_ASSIGNMENT)<br>方法中包含自己对自己赋值的字段。例如：<br>int x;<br>  public void foo() {<br>    x = x;<br>  }<br>90.SA: Self comparison of field with itself (SA_FIELD_SELF_COMPARISON)<br>字段自己进行自比较可能表明错误或逻辑错误。<br>91.SA: Self comparison of value with itself (SA_LOCAL_SELF_COMPARISON)<br>方法中对一个局部变量自身进行比较运算，并可说明错误或逻辑错误。请确保您是比较正确的事情。<br>92.SA: Nonsensical self computation involving a variable (e.g., x &amp; x) (SA_LOCAL_SELF_COMPUTATION)<br>此方法对同一变量执行了荒谬的计算（如x&amp;x或x-x）操作。由于计算的性质，这一行动似乎没有意义，并可能表明错误或逻辑错误。<br>93.SF: Dead store due to switch statement fall through (SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH)<br>在swtich中先前的case值因为swtich执行失败而被覆写，这就像是忘记使用break推出或者没有使用return语句放回先前的值一样。<br>94.SF: Dead store due to switch statement fall through to throw (SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH_TO_THROW)<br>在swtich中因为出现异常而忽略了对case值的保存。<br>95.SIC: Deadly embrace of non-static inner class and thread local (SIC_THREADLOCAL_DEADLY_EMBRACE)<br>如果是一个静态内部类。实际上，在内部类和当前线程有死锁的可能。由于内部类不是静态的，它保留了对外部类的引用。如果线程包含对一个内部类实例的引用，那么内外实例的实例都可以被获取，这样就不具备垃圾会回收的资格。<br>96.SIO: Unnecessary type check done using instanceof operator (SIO_SUPERFLUOUS_INSTANCEOF)<br>在进行instanceof操作时进行没有必要的类型检查<br>97.STI: Unneeded use of currentThread() call, to call interrupted() (STI_INTERRUPTED_ON_CURRENTTHREAD)<br>此方法调用Thread.currentThread（）调用，只需调用interrupted（）方法。由于interrupted（）是一个静态方法， Thread.interrupted（）更简单易用。<br>98.STI: Static Thread.interrupted() method invoked on thread instance (STI_INTERRUPTED_ON_UNKNOWNTHREAD)<br>调用不是当前线程对象的Thread.interrupted()方法，由于interrupted（）方法是静态的，interrupted方法将会调用一个和作者原计划不同的对象。<br>99.Se: Method must be private in order for serialization to work (SE_METHOD_MUST_BE_PRIVATE)<br>这个类实现了Serializable接口，并定义自定义序列化的方法/反序列化。但由于这种方法不能声明为private，将被序列化/反序列化的API忽略掉。<br>100.Se: The readResolve method must not be declared as a static method. (SE_READ_RESOLVE_IS_STATIC)<br>为使readResolve方法得到序列化机制的识别，不能作为一个静态方法来声明。<br>101.UMAC: Uncallable method defined in anonymous class (UMAC_UNCALLABLE_METHOD_OF_ANONYMOUS_CLASS)<br>在匿名类中定义了一个既没有覆写超类中方法也不能直接调用的方法。因为在其他类的方法不能直接引用匿名类声明的方法，似乎这种方法不能被调用，这种方法可能只是没有任何作用的代码，但也可能覆写超类中声明。<br>102.UR: Uninitialized read of field in constructor (UR_UNINIT_READ)<br>此构造方法中使用了一个尚未赋值的字段或属性。<br>        String a;<br>        public SA() {<br>String abc = a;<br>System.out.println(abc);<br>        }<br>103.UR: Uninitialized read of field method called from constructor of superclass (UR_UNINIT_READ_CALLED_FROM_SUPER_CONSTRUCTOR)<br>方法被超类的构造函数调用时，在当前类中的字段或属性还没有被初始化。例如：<br>abstract class A {<br>  int hashCode;<br>  abstract Object getValue();<br>  A() {<br>    hashCode = getValue().hashCode();<br>    }<br>  }<br>class B extends A {<br>  Object value;<br>  B(Object v) {<br>    this.value = v;<br>    }<br>  Object getValue() {<br>    return value;<br>  }<br>  }<br>当B是创建时，A的构造函数将在B为value赋值之前触发，然而在A的初始化方法调用getValue方法时value这个变量还没有被初始化。<br>104.USELESS_STRING: Invocation of toString on an array (DMI_INVOKING_TOSTRING_ON_ANONYMOUS_ARRAY)<br>该代码调用上匿名数组的toString（）方法，产生的结果形如[@ 16f0472并没有实际的意义。考虑使用Arrays.toString方法来转换成可读的字符串，提供该数组的内容数组。例如：<br>String[] a = { “a” };<br>System.out.println(a.toString());<br>//正确的使用为<br>System.out.println(Arrays.toString(a));<br>105.USELESS_STRING: Invocation of toString on an array (DMI_INVOKING_TOSTRING_ON_ARRAY)<br>该代码调用上数组的toString（）方法，产生的结果形如[@ 16f0472并不能显示数组的真实内容。考虑使用Arrays.toString方法来转换成可读的字符串，提供该数组的内容数组<br>106.UwF: Field only ever set to null (UWF_NULL_FIELD)<br>字段的值总是为null值，所有读取该字段的值都为null。检查错误，如果它确实没有用就删除掉。<br>107.UwF: Unwritten field (UWF_UNWRITTEN_FIELD<br>此字段是永远不会写入值。所有读取将返回默认值。检查错误（如果它被初始化？），如果它确实没有用就删除掉。</p>
<h3 id="五：Performance关于代码性能相关方面的"><a href="#五：Performance关于代码性能相关方面的" class="headerlink" title="五：Performance关于代码性能相关方面的"></a>五：Performance关于代码性能相关方面的</h3><p>1.Bx: Primitive value is boxed and then immediately unboxed (BX_BOXING_IMMEDIATELY_UNBOXED)<br>对原始值进行装箱，然后立即取消装箱。这可能是在一个未要求装箱的地方进行了手动装箱，从而迫使编译器进行立即撤消装箱的操作<br>2.Bx: Primitive value is boxed then unboxed to perform primitive coercion (BX_BOXING_IMMEDIATELY_UNBOXED_TO_PERFORM_COERCION)<br>对原始值进行装箱然后立即把它强制转换为另外一种原始类型。例如：<br>new Double(d).intValue()应该直接进行强制转换例如：(int) d<br>3.Bx: Method allocates a boxed primitive just to call toString (DM_BOXED_PRIMITIVE_TOSTRING)<br>仅仅为了调用封装类的toString()而对原始类型进行封装操作。比这种方法更有效的是调用封装类的toString(…)方法例如：<br>new Integer(1).toString()    替换为   Integer.toString(1)<br>new Long(1).toString()    替换为   Long.toString(1)<br>new Float(1.0).toString()    替换为   Float.toString(1.0)<br>new Double(1.0).toString()    替换为   Double.toString(1.0)<br>new Byte(1).toString()    替换为   Byte.toString(1)<br>new Short(1).toString()    替换为   Short.toString(1)<br>new Boolean(true).toString()    替换为   Boolean.toString(true)<br>4.Bx: Method invokes inefficient floating-point Number constructor; use static valueOf instead (DM_FP_NUMBER_CTOR)<br>使用new Double(double)方法总是会创建一个新的对象，然而使用Double.valueOf(double)方法可以把值保存在编辑器或者class library、JVM中。使用存储值的方式来避免对象的分配可以或得更好的代码性能<br>除非类必须符合Java 1.5以前的JVM，否则请使用自动装箱或valueOf（）方法创建Double和Float实例。<br>5.Bx: Method invokes inefficient Number constructor; use static valueOf instead (DM_NUMBER_CTOR)<br>使用new Integer(int)方法总是会创建一个新的对象，然而使用Integer.valueOf(int)方法可以把值保存在编辑器或者class library、JVM中。使用存储值的方式来避免对象的分配可以或得更好的代码性能<br>除非类必须符合Java 1.5以前的JVM，否则请使用自动装箱或valueOf（）方法创建Long, Integer, Short, Character, Byte实例。<br>6.Dm: The equals and hashCode methods of URL are blocking (DMI_BLOCKING_METHODS_ON_URL)<br>使用equals和hashCode方法来对url进行资源标识符解析时会引起堵塞。考虑使用java.net.URI来代替。<br>7.Dm: Maps and sets of URLs can be performance hogs (DMI_COLLECTION_OF_URLS)<br>方法或者字段使用url的map/set集合。因为equals方法或者hashCode方法来进行资源标识符解析时都会引起堵塞。考虑使用java.net.URI来代替。<br>8.Dm: Method invokes inefficient Boolean constructor; use Boolean.valueOf(…) instead (DM_BOOLEAN_CTOR)<br>使用new方法创建一个java.lang.Boolean类型能够的实例对象是浪费空间的，因为Boolean对象是不可变的而且只有两个有用的值。使用Boolean.valueOf()或者Java1.5中的自动装箱功能来创建一个Boolean实例。<br>9.Dm: Explicit garbage collection; extremely dubious except in benchmarking code (DM_GC)<br>在代码中显式的调用垃圾回收命名，这样做并不能起作用。在过去，有人在关闭操作或者finalize方法中调用垃圾回收方法导致了很多的性能浪费。这样大规模回收对象时会造成处理器运行缓慢。<br>10.Dm: Use the nextInt method of Random rather than nextDouble to generate a random integer (DM_NEXTINT_VIA_NEXTDOUBLE)<br> 如果r是一个java.util.Random对象，你可以使r.nextInt(n)生成一个0到n-1之前的随机数，而不是使用(int)(r.nextDouble() * n)<br>11.Dm: Method invokes inefficient new String(String) constructor (DM_STRING_CTOR)<br>使用java.lang.String(String)构造函数会浪费内存因为这种构造方式和String作为参数在功能上容易混乱。只是使用String直接作为参数的形式<br>12.Dm: Method invokes toString() method on a String (DM_STRING_TOSTRING)<br>调用String.toString()是多余的操作，只要使用String就可以了。<br>13.Dm: Method invokes inefficient new String() constructor (DM_STRING_VOID_CTOR)<br>使用没有参数的构造方法去创建新的String对象是浪费内存空间的，因为这样创建会和空字符串“”混淆。Java中保证完成相同的构造方法会产生描绘相同的String对象。所以你只要使用空字符串来创建就可以了。<br>14.ITA: Method uses toArray() with zero-length array argument (ITA_INEFFICIENT_TO_ARRAY)<br>当使用集合的toArray()方法时使用数组长度为0的数组作为参数。比这更有效的一种方法是<br>myCollection.toArray(new Foo[myCollection.size()])，如果数组的长度足够大就可以直接把集合中的内容包装到数组中直接返回从而避免了第二次创建一个新的数组来存放集合中值。<br>15.SBSC: Method concatenates strings using + in a loop (SBSC_USE_STRINGBUFFER_CONCATENATION)<br>在循环中构建一个String对象时从性能上讲使用StringBuffer来代替String对象<br>例如：<br>// This is bad<br>  String s = “”;<br>  for (int i = 0; i &lt; field.length; ++i) {<br>    s = s + field[i];<br>  }<br>  // This is better<br>  StringBuffer buf = new StringBuffer();<br>  for (int i = 0; i &lt; field.length; ++i) {<br>    buf.append(field[i]);<br>  }<br>  String s = buf.toString();<br>16.SS: Unread field: should this field be static? (SS_SHOULD_BE_STATIC)<br>类中所包含的final属性字段在编译器中初始化为静态的值。考虑在定义时就把它定义为static类型的。<br>17.UM: Method calls static Math class method on a constant value (UM_UNNECESSARY_MATH)<br>在方法中使用了java.lang.Math的静态方法代替常量来使用，使用常量速度和准确度会更好。 以下为Math中的方法产生的值。<br>Method Parameter<br>abs -any-<br>acos 0.0 or 1.0<br>asin 0.0 or 1.0<br>atan 0.0 or 1.0<br>atan2 0.0 cbrt 0.0 or 1.0<br>ceil -any-<br>cos 0.0<br>cosh 0.0<br>exp 0.0 or 1.0<br>expm1 0.0<br>floor -any-<br>log 0.0 or 1.0<br>log10 0.0 or 1.0<br>rint -any-<br>round -any-<br>sin 0.0<br>sinh 0.0<br>sqrt 0.0 or 1.0<br>tan 0.0<br>tanh 0.0<br>toDegrees 0.0 or 1.0<br>toRadians 0.0<br>18.UPM: Private method is never called (UPM_UNCALLED_PRIVATE_METHOD)<br>定义为Private类型方法从未被调用，应该被删除。<br>19.UrF: Unread field (URF_UNREAD_FIELD)<br>类中定义的属性从未被调用，建议删除。<br>20.UuF: Unused field (UUF_UNUSED_FIELD)<br>类中定义的属性从未被使用，建议删除。<br>21.WMI: Inefficient use of keySet iterator instead of entrySet iterator (WMI_WRONG_MAP_ITERATOR)<br>当方法中接受一个Map类型的参数时，使用keySet的迭代器比使用entrySet的迭代器效率要高。</p>
<h3 id="六：Internationalization关于代码国际化相关方面的"><a href="#六：Internationalization关于代码国际化相关方面的" class="headerlink" title="六：Internationalization关于代码国际化相关方面的"></a>六：Internationalization关于代码国际化相关方面的</h3><p>Dm: Consider using Locale parameterized version of invoked method (DM_CONVERT_CASE)<br>使用平台默认的编码格式对字符串进行大小写转换，这可能导致国际字符的转换不当。使用以下方式对字符进行转换<br>String.toUpperCase( Locale l )<br>String.toLowerCase( Locale l )</p>
<h3 id="七：Multithreaded-correctness关于代码多线程正确性相关方面的"><a href="#七：Multithreaded-correctness关于代码多线程正确性相关方面的" class="headerlink" title="七：Multithreaded correctness关于代码多线程正确性相关方面的"></a>七：Multithreaded correctness关于代码多线程正确性相关方面的</h3><p>1.DL: Synchronization on Boolean could lead to deadlock (DL_SYNCHRONIZATION_ON_BOOLEAN)<br>该代码同步一个封装的原始常量，例如一个Boolean类型。<br>private static Boolean inited = Boolean.FALSE;<br>…<br>  synchronized(inited) {<br>    if (!inited) {<br>       init();<br>       inited = Boolean.TRUE;<br>       }<br>     }<br>…<br>由于通常只存在两个布尔对象，此代码可能是同步的其他无关的代码中相同的对象，这时会导致反应迟钝和可能死锁<br>2.DL: Synchronization on boxed primitive could lead to deadlock (DL_SYNCHRONIZATION_ON_BOXED_PRIMITIVE)<br>该代码同步一个封装的原始常量，例如一个Integer类型。<br>private static Integer count = 0;<br>…<br>  synchronized(count) {<br>     count++;<br>     }<br>…<br>由于Integer对象可以共享和保存，此代码可能是同步的其他无关的代码中相同的对象，这时会导致反应迟钝和可能死锁<br>3.DL: Synchronization on interned String could lead to deadlock (DL_SYNCHRONIZATION_ON_SHARED_CONSTANT)<br>同步String类型的常量时，由于它被JVM中多个其他的对象所共有，这样在其他代码中会引起死锁。<br>4.DL: Synchronization on boxed primitive values (DL_SYNCHRONIZATION_ON_UNSHARED_BOXED_PRIMITIVE)<br>同步一个显然不是共有封装的原始值，例如一个Integer类型的对象。例如：<br>private static final Integer fileLock = new Integer(1);<br>…<br>  synchronized(fileLock) {<br>     .. do something ..<br>     }<br>…<br>它最后被定义为以下方式来代替：private static final Object fileLock = new Object();<br>5.Dm: Monitor wait() called on Condition (DM_MONITOR_WAIT_ON_CONDITION)<br>方法中以java.util.concurrent.locks.Condition对象调用wait（）。等待一个条件发生时应该使用在Condition接口中定义的await()方法。<br>6.Dm: A thread was created using the default empty run method (DM_USELESS_THREAD)<br>这个方法没有通过run方法或者具体声明Thread类，也没有通过一个Runnable对象去定义一个线程，而这个线程出来浪费资源却什么也没有去做。<br>7.ESync: Empty synchronized block (ESync_EMPTY_SYNC)<br>该代码包含一个空的同步块：synchronized() {}<br>8.IS: Inconsistent synchronization (IS2_INCONSISTENT_SYNC)<br>不合理的同步<br>9.IS: Field not guarded against concurrent access (IS_FIELD_NOT_GUARDED)<br>域不是良好的同步访问—<br>此字段被标注为net.jcip.annotations.GuardedBy，但可以在某种程度上违反注释而去访问<br>10.JLM: Synchronization performed on Lock (JLM_JSR166_LOCK_MONITORENTER)<br>实现java.util.concurrent.locks.Lock的对象调用了同步的方法。应该这样处理，对象被锁定/解锁时使用acquire（）/ release（）方法而不是使用同步的方法。<br>11.LI: Incorrect lazy initialization of static field (LI_LAZY_INIT_STATIC)<br>静态域不正确的延迟初始化–<br>这种方法包含了一个不同步延迟初始化的非volatile静态字段。因为编译器或处理器可能会重新排列指令，如果该方法可以被多个线程调用，线程不能保证看到一个完全初始化的对象。你可以让字段可变来解决此问题<br>12.LI: Incorrect lazy initialization and update of static field (LI_LAZY_INIT_UPDATE_STATIC)<br>这种方法包含一个不同步延迟初始化的静态字段。之后为字段赋值，对象存储到该位置后进一步更新或访问。字段后尽快让其他线程能够访问。如果该方法的进一步访问该字段为初始化对象提供服务，然后你有一个非常严重的多线程bug，除非别的东西阻止任何其他线程访问存储的对象，直到它完全初始化。<br>即使你有信心，该方法是永远不会被多个线程调用时，在它的值还没有被充分初始化或移动，不把它设定为static字段时它可能会更好。<br>13.ML: Method synchronizes on an updated field (ML_SYNC_ON_UPDATED_FIELD)<br>对象获取一个可变字段时进行同步。这是没有意义的，因为不同的线程可以在不同的对象同步。<br>14.MSF: Mutable servlet field (MSF_MUTABLE_SERVLET_FIELD)<br>一个web服务一般只能创建一个servlet或者jsp的实例（例如：treates是一个单利类），它会被多个线程调用这个实例的方法服务于多个同时的请求。因此使用易变的字段属性产生竞争的情况。<br>15.MWN: Mismatched notify() (MWN_MISMATCHED_NOTIFY)<br>此方法调用Object.notify（）或Object.notifyAll（）而没有获取到该对象的对象锁。调用notify（）或notifyAll（）而没有持有该对象的对象锁，将导致IllegalMonitorStateException异常。<br>16.MWN: Mismatched wait() (MWN_MISMATCHED_WAIT)<br>此方法调用Object.wait()而没有获取到该对象的对象锁。调用wait（）而没有持有该对象的对象锁，将导致IllegalMonitorStateException异常。<br>17.NP: Synchronize and null check on the same field. (NP_SYNC_AND_NULL_CHECK_FIELD)<br>如果代码块是同步的，那么久不可能为空。如果是空，同步时就会抛出NullPointerException异常。最好是在另一个代码块中进行同步。<br>18.No: Using notify() rather than notifyAll() (NO_NOTIFY_NOT_NOTIFYALL)<br>调用notify（）而不是notifyAll（）方法。 Java的监控器通常用于多个条件。调用notify（）只唤醒一个线程，这意味着该线程被唤醒只是满足的当前的唯一条件。<br>19.RS: Class’s readObject() method is synchronized (RS_READOBJECT_SYNC)<br>序列化类中定义了同步的readObject（）。通过定义，反序列化创建的对象只有一个线程可以访问，因此没有必要的readObject（）进行同步。如果的readObject（）方法本身造成对象对另一个线程可见，那么这本身就是不好的编码方式。<br>20.Ru: Invokes run on a thread (did you mean to start it instead?) (RU_INVOKE_RUN)<br>这种方法显式调用一个对象的run（）。一般来说，类是实现Runnable接口的，因为在一个新的线程他们将有自己的run（）方法，在这种情况下Thread.start（）方法调用是正确的。<br>21.SC: Constructor invokes Thread.start() (SC_START_IN_CTOR)<br>在构造函数中启动一个线程。如果类曾经被子类扩展过，那么这很可能是错的，因为线程将在子类构造之前开始启动。<br>22.SP: Method spins on field (SP_SPIN_ON_FIELD)<br>方法无限循环读取一个字段。编译器可合法悬挂宣读循环，变成一个无限循环的代码。这个类应该改变，所以使用适当的同步（包括等待和通知要求）<br>23.STCAL: Call to static Calendar (STCAL_INVOKE_ON_STATIC_CALENDAR_INSTANCE)<br>即使JavaDoc对此不包含暗示，而Calendars本身在多线程中使用就是不安全的。探测器发现当调用Calendars的实例时将会获得一个静态对象。<br>Calendar rightNow = Calendar.getInstance();<br>24.STCAL: Call to static DateFormat (STCAL_INVOKE_ON_STATIC_DATE_FORMAT_INSTANCE)<br>在官方的JavaDoc，DateFormats多线程使用本事就是不安全的。探测器发现调用一个DateFormat的实例将会获得一个静态对象。<br>myString = DateFormat.getDateInstance().format(myDate);<br>25.STCAL: Static Calendar (STCAL_STATIC_CALENDAR_INSTANCE)<br>Calendar在多线程中本身就是不安全的，如果在线程范围中共享一个Calendarde 实例而不使用一个同步的方法在应用中就会出现一些奇怪的行为。在sun.util.calendar.BaseCalendar.getCalendarDateFromFixedDate()中会抛出ArrayIndexOutOfBoundsExceptions or IndexOutOfBoundsExceptions异常。<br>26.STCAL: Static DateFormat (STCAL_STATIC_SIMPLE_DATE_FORMAT_INSTANCE)<br>DateFormat 在多线程中本身就是不安全的，如果在线程范围中共享一个DateFormat的实例而不使用一个同步的方法在应用中就会出现一些奇怪的行为。<br>27.SWL: Method calls Thread.sleep() with a lock held (SWL_SLEEP_WITH_LOCK_HELD)<br>当持有对象时调用Thread.sleep（）。这可能会导致很差的性能和可扩展性，或陷入死锁，因为其他线程可能正在等待获得锁。调用wait（）是一个更好的主意，释放对象的持有以允许其他线程运行。<br>28.UG: Unsynchronized get method, synchronized set method (UG_SYNC_SET_UNSYNC_GET)<br>这个类包含类似命名的get和set方法。在set方法是同步方法和get方法是非同步方法。这可能会导致在运行时的不正确行为，因为调用的get方法不一定返回对象一致状态。 GET方法应该同步。<br>29.UL: Method does not release lock on all paths (UL_UNRELEASED_LOCK)<br>方法获得了当前的对象所，但是在方法中始终没有释放它。一个正确的示例如下：<br>  Lock l = …;<br>    l.lock();<br>    try {<br>        // do something<br>    } finally {<br>        l.unlock();<br>    }<br>30.UL: Method does not release lock on all exception paths (UL_UNRELEASED_LOCK_EXCEPTION_PATH)<br>方法获得了当前的对象所，但是在所有的异常处理中始终没有释放它。一个正确的示例如下：<br>  Lock l = …;<br>    l.lock();<br>    try {<br>        // do something<br>    } finally {<br>        l.unlock();<br>    }<br>31.UW: Unconditional wait (UW_UNCOND_WAIT)<br>方法中包含调用java.lang.Object.wait（），而却没有放到条件流程控制中。该代码应确认条件尚未满足之前等待;先前任何通知将被忽略。<br>32.VO: A volatile reference to an array doesn’t treat the array elements as volatile (VO_VOLATILE_REFERENCE_TO_ARRAY)<br>声明一个变量引用数组，这可能不是你想要的。如果一个变量引用数组，那么对引用数组的读和写都是不安全的，但是数组元素不是变量。取得数组的变量值你可以使用java.util.concurrent包中的数组的原子性特性<br>33.WL: Sychronization on getClass rather than class literal (WL_USING_GETCLASS_RATHER_THAN_CLASS_LITERAL)<br>实例的方法中同步this.getClass()，如果这个类有子类集合，那么子类集合中的对象将会在这个类的各个子类上进行同步，这不是我们想要的效果，我们只要同步当前的类对象而不包含它的所有子类，可以同步类名.getClass()。例如，java.awt.Label的代码：<br>     private static final String base = “label”;<br>     private static int nameCounter = 0;<br>     String constructComponentName() {<br>        synchronized (getClass()) {<br>            return base + nameCounter++;<br>        }<br>     }<br>Label中的子类集合不可能在同一个子对象上进行同步，替换上面的方法为：<br>    private static final String base = “label”;<br>     private static int nameCounter = 0;<br>     String constructComponentName() {<br>        synchronized (Label.class) {<br>            return base + nameCounter++;<br>        }<br>     }<br>34.WS: Class’s writeObject() method is synchronized but nothing else is (WS_WRITEOBJECT_SYNC)<br>这个类有一个writeObject（）方法是同步的，但是这个类中没有其他的同步方法。<br>35.Wa: Condition.await() not in loop (WA_AWAIT_NOT_IN_LOOP)<br>方法没有在循环中调用java.util.concurrent.await()。如果对象是用于多种条件，打算调用wait()方法的条件可能不是实际发生的。<br>36.Wa: Wait not in loop (WA_NOT_IN_LOOP)<br>这种方法包含调用java.lang.Object.wait（），而这并不是一个循环。如果监视器用于多个条件，打算调用wait()方法的条件可能不是实际发生的。</p>
<h3 id="八：Malicious-codevulnerability关于恶意破坏代码相关方面的"><a href="#八：Malicious-codevulnerability关于恶意破坏代码相关方面的" class="headerlink" title="八：Malicious codevulnerability关于恶意破坏代码相关方面的"></a>八：Malicious codevulnerability关于恶意破坏代码相关方面的</h3><p>1.EI: May expose internal representation by returning reference to mutable object (EI_EXPOSE_REP)<br>返回一个易变对象引用并把它保存在对象字段中时会暴露对象内部的字段描述，如果接受不守信任的代码访问或者没有检查就去改变易变对象的会涉及对象的安全和其他重要属性的安全。返回一个对象的新副本，在很多情况下更好的办法。<br>2.EI2: May expose internal representation by incorporating reference to mutable object (EI_EXPOSE_REP2)<br>此代码把外部可变对象引用存储到对象的内部表示。如果实例受到不信任的代码的访问和没有检查的变化危及对象和重要属性的安全。存储一个对象的副本，在很多情况下是更好的办法。<br>3.FI: Finalizer should be protected, not public (FI_PUBLIC_SHOULD_BE_PROTECTED)<br>一个类中的finalize（）方法必须声明为protected，而不能为public类型<br>4.MS: Public static method may expose internal representation by returning array (MS_EXPOSE_REP)<br>一个public类型的静态方法返回一个数组，可能引用内部属性的暴露。任何代码调用此方法都可以自由修改底层数组。一个解决办法是返回一个数组的副本。<br>5.MS: Field should be both final and package protected (MS_FINAL_PKGPROTECT)<br>一个静态字段可能被恶意代码或另外一个包所改变的。字段可以放到protected包中也可以定义为final类型的以避免此问题。<br>6.MS: Field is a mutable array (MS_MUTABLE_ARRAY)<br>一个定义为final类型的静态字段引用一个数组时它可以被恶意代码或在另其他包中所使用。这些代码可以自由修改数组的内容。<br>7.MS: Field is a mutable Hashtable (MS_MUTABLE_HASHTABLE)<br>一个定义为final类型的静态字段引用一个Hashtable时可以被恶意代码或者在其他包中被调用，这些方法可以修改Hashtable的值。<br>8.MS: Field should be moved out of an interface and made package protected (MS_OOI_PKGPROTECT)<br>将域尽量不要定义在接口中，并声明为包保护<br>在接口中定义了一个final类型的静态字段，如数组或哈希表等易变对象。这些对象可以被恶意代码或者在其他包中被调用，为了解决这个问题，需要把它定义到一个具体的实体类中并且声明为保护类型以避免这种错误。<br>9.MS: Field should be package protected (MS_PKGPROTECT)<br>一个静态字段是可以改变的恶意代码或其他的包访问修改。可以把这种类型的字段声明为final类型的以防止这种错误。</p>
<h3 id="十：Dodgy关于代码运行期安全方面的"><a href="#十：Dodgy关于代码运行期安全方面的" class="headerlink" title="十：Dodgy关于代码运行期安全方面的"></a>十：Dodgy关于代码运行期安全方面的</h3><p>1.XSS: Servlet reflected cross site scripting vulnerability (XSS_REQUEST_PARAMETER_TO_SEND_ERROR)<br>在代码中在Servlet输出中直接写入一个HTTP参数，这会造成一个跨站点的脚本漏洞。<br>2.XSS: Servlet reflected cross site scripting vulnerability (XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER)<br>代码直接写入参数的HTTP服务器错误页（使用HttpServletResponse.sendError）。表达了类似的不受信任的输入会引起跨站点脚本漏洞。<br>3.BC: Questionable cast to abstract collection (BC_BAD_CAST_TO_ABSTRACT_COLLECTION)<br>在代码投把一个集合强制类型转换为一个抽象的集合（如list，set或map）。保证该对象类型和将要转换的类型是一致的。如果你只是想要便利一个集合，那么你就不必将它转换为Set或List。<br>4.BC: Questionable cast to concrete collection (BC_BAD_CAST_TO_CONCRETE_COLLECTION)<br>代码把抽象的集合（如List，Set，或Collection）强制转换为具体落实类型（如一个ArrayList或HashSet）。这可能不正确，也可能使您的代码很脆弱，因为它使得难以在今后的切换指向其他具体实现。除非你有特别理由这样做，否则只需要使用抽象的集合类。<br>5.BC: Unchecked/unconfirmed cast (BC_UNCONFIRMED_CAST)<br>强制类型转换操作没有经过验证，而且不是所有的此种类型装换过的类都可以再强制类型转换为原类型。在代码中需要进行逻辑判断以保证可以进行这样的操作。<br>6.BC: instanceof will always return true (BC_VACUOUS_INSTANCEOF)<br>instanceof测试将始终返回真（除非被测试的值为空）。虽然这是安全，确保它是不是说明一些误解或其他一些逻辑错误。如果你真的想测试是空的价值，也许会更清楚这样做的更好空试验，而不是一个instanceof测试。<br>7.BSHIFT: Unsigned right shift cast to short/byte (ICAST_QUESTIONABLE_UNSIGNED_RIGHT_SHIFT)<br>无符号数右移后进行转换为short或者byte类型时可能会丢弃掉高位的值，这样的结果就是有符合数和无符号数无法区分（这取决于移位大小）<br>8.CI: Class is final but declares protected field (CI_CONFUSED_INHERITANCE)<br>这个类被声明为final的，而是字段属性却声明为保护类型的。由于是final类，它不能再被继承，而再声明为保护类型的很容易造成混淆。为了从外部能正确的使用它应该把它们声明为private或者public类型。<br>9.DB: Method uses the same code for two branches (DB_DUPLICATE_BRANCHES)<br>此方法使用相同的代码，以实现两个有条件的分支。检查以确保这是不是一个编码错误。<br>10.DB: Method uses the same code for two switch clauses (DB_DUPLICATE_SWITCH_CLAUSES)<br>他的方法使用相同的代码来实现两个switch的声明条款。这可能是重复代码的情况，但可能也显示出编码的错误。<br>11.DLS: Dead store to local variable (DLS_DEAD_LOCAL_STORE)<br>该指令为局部变量赋值，但在其后的没有对她做任何使用。通常，这表明一个错误，因为值从未使用过。<br>12.DLS: Useless assignment in return statement (DLS_DEAD_LOCAL_STORE_IN_RETURN)<br>本声明把一个局部变量放到方法的返回语句中。这对于方法中局部变量来说是没有意思的。<br>13.DLS: Dead store of null to local variable (DLS_DEAD_LOCAL_STORE_OF_NULL)<br>把一个本地变量赋值为null值，并且再也没有对这个变量做任何的操作。这样可能是为了垃圾回收，而是Java SE 6.0，这已不再需要。<br>14.DMI: Code contains a hard coded reference to an absolute pathname (DMI_HARDCODED_ABSOLUTE_FILENAME)<br>此代码包含文件对象为一个绝对路径名（例如，新的文件（“/ home/dannyc/workspace/j2ee/src/share/com/sun/enterprise/deployment”）;<br>15.DMI: Non serializable object written to ObjectOutput (DMI_NONSERIALIZABLE_OBJECT_WRITTEN)<br>代码中让一个非序列化的对象出现在ObjectOutput.writeObject()方法中，这样会引起一个错误。<br>16.DMI: Invocation of substring(0), which returns the original value (DMI_USELESS_SUBSTRING)<br>此代码调用了subString(0)方法，它将返回原来的值。<br>17.Eq: Class doesn’t override equals in superclass (EQ_DOESNT_OVERRIDE_EQUALS)<br>子类定义了一个新的equals方法但是却不是覆写了父类本省的equals()方法。<br>18.FE: Test for floating point equality (FE_FLOATING_POINT_EQUALITY)<br>此操作比较两个浮点值是否相等。由于浮点运算可能会涉及到舍入，计算float和double值可能不准确。如果要求值必须准确，如货币值，可以考虑使用固定精度类型，如BigDecimal类型的值来比较<br>19.FS: Non-Boolean argument formatted using %b format specifier (VA_FORMAT_STRING_BAD_CONVERSION_TO_BOOLEAN)<br>使用%b去格式化Boolean类型的值不正确的但是它不会抛出异常，任何非空的值都会输出true，任何为空的值都会输出false<br>20.IC: Initialization circularity (IC_INIT_CIRCULARITY)<br>在引用两个相互调用为环状static方法去初始化一个实例时是错误的。<br>21.ICAST: integral division result cast to double or float (ICAST_IDIV_CAST_TO_DOUBLE)<br>整形数除法强制转换为double或者float类型。<br>int x = 2;<br>int y = 5;<br>// Wrong: yields result 0.0<br>double value1 =  x / y;<br>// Right: yields result 0.4<br>double value2 =  x / (double) y;<br>22.ICAST: Result of integer multiplication cast to long (ICAST_INTEGER_MULTIPLY_CAST_TO_LONG)<br>整形数做乘法运算结果转换为long值时如果采用<br>long convertDaysToMilliseconds(int days) { return 1000<em>3600</em>24<em>days; } 结果会因为超出整形的范围而出错。<br>如果使用：<br>long convertDaysToMilliseconds(int days) { return 1000L</em>3600<em>24</em>days; }<br>或者：<br>static final long MILLISECONDS_PER_DAY = 24L<em>3600</em>1000;<br>        long convertDaysToMilliseconds(int days) { return days * MILLISECONDS_PER_DAY; }<br>都可以避免此问题。<br>23.IM: Computation of average could overflow (IM_AVERAGE_COMPUTATION_COULD_OVERFLOW)<br>代码中使用x % 2 == 1的方法去验证运算是否存在余数的情况，但是如果出现负数的情况就不起作用了。使用x &amp; 1 == 1, or x % 2 != 0来代替<br>24.INT: Vacuous comparison of integer value (INT_VACUOUS_COMPARISON)<br>整形数进行比较结果总是不变。例如：x &lt;= Integer.MAX_VALUE<br>25.MTIA: Class extends Servlet class and uses instance variables (MTIA_SUSPECT_SERVLET_INSTANCE_FIELD)<br>这个类扩展从Servlet类，并使用实例的成员变量。由于只有一个Servlet类的实例，并在多线程方式使用，这种模式有可能存在问题。考虑只使用方法的局部变量。<br>26.MTIA: Class extends Struts Action class and uses instance variables (MTIA_SUSPECT_STRUTS_INSTANCE_FIELD)<br>类扩展自Struts的Action类并使用这个实例的成员变量，因为在Struts框架中只存在一个Action实例对象并且使用在多线程的情况下很可能会出现问题。<br>27.NP: Dereference of the result of readLine() without nullcheck (NP_DEREFERENCE_OF_READLINE_VALUE)<br>对readLine()的结果值没有进行判空操作就去重新赋值，这样的操作可以会抛出空指针异常。<br>28.NP: Immediate dereference of the result of readLine() (NP_IMMEDIATE_DEREFERENCE_OF_READLINE)<br>对readLine()的结果立即赋值，这样的操作可以会抛出空指针异常。<br>29.NP: Possible null pointer dereference due to return value of called method (NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE)<br>方法的返回值没有进行是否为空的检查就重新赋值，这样可能会出现空指针异常。<br>30.NP: Parameter must be nonnull but is marked as nullable (NP_PARAMETER_MUST_BE_NONNULL_BUT_MARKED_AS_NULLABLE)<br>参数值在任何情况下都不能为空，但是有明确的注释它可以为空。<br>31.NS: Potentially dangerous use of non-short-circuit logic (NS_DANGEROUS_NON_SHORT_CIRCUIT)<br>代码中使用（&amp; or |）代替（&amp;&amp; or ||）操作，这会造成潜在的危险。<br>32.NS: Questionable use of non-short-circuit logic (NS_NON_SHORT_CIRCUIT)<br>代码中使用（&amp; or |）代替（&amp;&amp; or ||）操作，会引起不安全的操作<br>33.PZLA: Consider returning a zero length array rather than null (PZLA_PREFER_ZERO_LENGTH_ARRAYS)<br>考虑返回一个零长度的数组，而不是null值<br>34.QF: Complicated, subtle or wrong increment in for-loop (QF_QUESTIONABLE_FOR_LOOP)<br>确定这个循环是正确的变量递增，看起来，另一个变量被初始化，检查的循环。这是由于for循环中太复杂的定义造成的。<br>35.RCN: Redundant comparison of non-null value to null (RCN_REDUNDANT_COMPARISON_OF_NULL_AND_NONNULL_VALUE)<br>方法中包含一个不能为空的赋值还包含一个可以为空的赋值。冗余比较非空值为空。<br>36.RCN: Redundant comparison of two null values (RCN_REDUNDANT_COMPARISON_TWO_NULL_VALUES)<br>方法中对两个null值进行比较<br>37.RCN: Redundant nullcheck of value known to be non-null (RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE)<br>方法中对不为空的值进行为空的判断。<br>38.REC: Exception is caught when Exception is not thrown (REC_CATCH_EXCEPTION)<br>在try/catch块中捕获异常，但是异常没有在try语句中抛出而RuntimeException又没有明确的被捕获<br>39.RI: Class implements same interface as superclass (RI_REDUNDANT_INTERFACES)<br>子类和父类都实现了同一个接口，这种定义是多余的。<br>40.RV: Method discards result of readLine after checking if it is nonnull (RV_DONT_JUST_NULL_CHECK_READLINE)<br>readLine方法的结果不为空时被抛弃<br>41.RV: Remainder of 32-bit signed random integer (RV_REM_OF_RANDOM_INT)<br>此代码生成一个随机的符号整数，然后计算另一个值的。由于随机数可以是负数，所以其余操作的结果也可以是负面的。考虑使用Random.nextInt（int）方法代替。<br>42.SA: Double assignment of local variable (SA_LOCAL_DOUBLE_ASSIGNMENT)<br>为一个局部变量两次赋值，这样是没有意义的。例如：<br>public void foo() {<br>    int x,y;<br>    x = x = 17;<br>  }<br>43.SA: Self assignment of local variable (SA_LOCAL_SELF_ASSIGNMENT)<br>局部变量使用自身给自己赋值<br>public void foo() {<br>    int x = 3;<br>    x = x;<br>  }<br>44.SF: Switch statement found where one case falls through to the next case (SF_SWITCH_FALLTHROUGH)<br>Switch语句中一个分支执行后又执行了下一个分支。通常case后面要跟break 或者return语句来跳出。<br>45.SF: Switch statement found where default case is missing (SF_SWITCH_NO_DEFAULT)<br>Switch没有默认情况下执行的case语句。<br>46.Se: private readResolve method not inherited by subclasses (SE_PRIVATE_READ_RESOLVE_NOT_INHERITED)<br>声明为private的序列化方法被子类继承<br>47.UCF: Useless control flow (UCF_USELESS_CONTROL_FLOW)<br>没有任何作用的条件语句。<br>if (argv.length == 0) {<br>        // TODO: handle this case<br>        }<br>48.UCF: Useless control flow to next line (UCF_USELESS_CONTROL_FLOW_NEXT_LINE)<br>无效的条件控制语句，注意if (argv.length == 1);以“;”结尾，下面的语句无论是否满足都会运行。<br>if (argv.length == 1);<br>        System.out.println(“Hello, “ + argv[0]);<br>49.UwF: Field not initialized in constructor (UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR)<br>字段从来没有在任何构造函数初始化，对象被创建后值为空。如果该字段未被定义就重新赋值会产生一个空指针异常。<br>50.XFB: Method directly allocates a specific implementation of xml interfaces (XFB_XML_FACTORY_BYPASS)<br>方法自定义了一种XML接口的实现类。最好是使用官方提供的工厂类来创建这些对象，以便可以在运行期中改变。例如：<br>javax.xml.parsers.DocumentBuilderFactory<br>javax.xml.parsers.SAXParserFactory<br>javax.xml.transform.TransformerFactory<br>org.w3c.dom.Document.createXXXX</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cenrise.com/2017/05/16/网络安全/安全组第一次会议提出的问题整理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongpo.jia">
      <meta itemprop="description" content="个人博客">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="中起之星">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/16/网络安全/安全组第一次会议提出的问题整理/" itemprop="url">
                  安全组第一次会议提出的问题整理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-05-16 10:30:00" itemprop="dateCreated datePublished" datetime="2017-05-16T10:30:00+08:00">2017-05-16</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-08-18 09:44:35" itemprop="dateModified" datetime="2017-08-18T09:44:35+08:00">2017-08-18</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/网络安全/" itemprop="url" rel="index"><span itemprop="name">网络安全</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/网络安全/安全小组/" itemprop="url" rel="index"><span itemprop="name">安全小组</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>创建安全组是个长期的、不断迭代的过程，目前我们公司系统百废末兴之际，各方面的系统也都在创建初期如果安全控制要求高，势必会影响部分工作进度；当然，从开始就严格控制，也会为后期不必要的重构提供有利条件。根据现有情况，可以优先进行投入少，回报多的工作，慢慢渗透。  </p>
<h1 id="事前-防范"><a href="#事前-防范" class="headerlink" title="事前-防范"></a>事前-防范</h1><p>1.制定漏洞管理制度<br>为规范生产网和办公网安全漏洞发现、评估及处理，首先应该制定《漏洞管理制度》对漏洞评级，根据评级做不同和响应处理。<br>漏洞处理流程：发现漏洞-&gt;评估漏洞-&gt;如果是不可接受的风险对业务下线-&gt;修补漏洞-&gt;测试验收-&gt;上线  </p>
<p>2.敏感数据保护<br>    1) 银行卡可以显示首末4，手机号可以显示首3末4位，电话可以显示区号和末4位，身份证、邮箱、地址等。<br>    2) 日志文件里的敏感信息<br>    3) 用户名密码加密<br>    4) 数据库防篡改签名  </p>
<p>3.访问控制管理<br>    1) 制定信息授权的策略，及访问权限的管理策略；<br>    2) 规定每个用户或每组用户的访问控制规则和权力；  </p>
<p>4.用户帐号及权限安全。<br>    1) 最小权限原则<br>    最小权限是指限定系统中每个用户所必须的最小访问权限的原则，设定账号访问权限，控制用户仅能够访问到工作需要的信息。<br>    2) 职责分离原则<br>    职责分离主要是防止单个用户利用其所拥有的多重权限进行舞弊、盗窃或其它的非法行为，或对工作错误和违规活动进行掩盖。<br>    账号权限管理应按照职责分离的原则，确保不存在权限交叉而形成舞弊的可能  </p>
<ol start="5">
<li>产品安全功能设计规范<br> 需要对产品的安全功能设计，如身份认证基本策略、用户登录失败/超时处理、账户信息输入防护、接口认证。  </li>
</ol>
<p>6.保密管理<br>     对文档、内容做好密级分类，哪些文件是对内，对外，或机密。  </p>
<p>7.测试规范，<br>    1) 依据《漏洞管理制度》判定漏洞等级，凡存在高危漏洞，除大领导特批外，禁止上线；低危或中危漏洞，可先上线后排期修复。<br>    任何系统未经过黑盒和白盒测试，禁止上线，特批和紧急情况除外。<br>    2) 为避免安全测试人员漏测，需定期对生产进行全面安全测试：<br>    • 半年内至少执行一次全面渗透测试；<br>    • 每个季度至少需要一次全面的ACL验证，系统底层漏洞检测；  </p>
<p>8.研发规范：<br>    1) 研发流程规范<br>    2) 代码规范<br>    3) 对技术的选型，比如组件、中间容器、中间件使用版本统一及安全、架构评审。  </p>
<h1 id="事中-应急的规定"><a href="#事中-应急的规定" class="headerlink" title="事中-应急的规定"></a>事中-应急的规定</h1><p>  1) 建议成立应急指挥小组主要是在事故处理过程中进行信息收集、资源调度和沟通反馈信息。  应急处理流程如：信息收集-&gt;初步判断-&gt;事故处理-&gt;信息通报-&gt;事后处理-故障报告。  原则：以尽快恢复业务为第一优先。<br>  2) 故障时间之前做相关系统的上线或系统变更备份，在3分钟内无法定位故障原因的，立即执行回滚变更操作。  </p>
<h1 id="事后-总结"><a href="#事后-总结" class="headerlink" title="事后-总结"></a>事后-总结</h1><p>  1) 做好故障记录，主要包括事故、事故发生时间，事故恢复时间、持续时间，等级、影响产品、影响商户、影响交易、事故发现、事故类型、产生原因等<br>  2) 故障报告改进措施跟进 ，主要是改进措施、目前的完成情况，遗留问题  </p>
<h1 id="漏洞发现和处理流程"><a href="#漏洞发现和处理流程" class="headerlink" title="漏洞发现和处理流程"></a>漏洞发现和处理流程</h1><p>1.注册补天、漏洞盒子、乌云等国内外漏洞平台的企业帐号，针对企业贴平台会第一时间推送最新漏洞并进行安全指导。<br>2.可以在补天、漏洞盒子等平台以企业帐号方式创建安全测试平台，对外的白帽子增加奖励，鼓励大众参与众测。  </p>
<h1 id="安全网站参考"><a href="#安全网站参考" class="headerlink" title="安全网站参考"></a>安全网站参考</h1><p>安全资讯<br><a href="http://www.freebuf.com/" target="_blank" rel="noopener">http://www.freebuf.com/</a>  </p>
<p>乌云 (WooYun)(已停服)<br><a href="http://wooyun.org/" target="_blank" rel="noopener">http://wooyun.org/</a><br>可通过如下查乌云数据：<a href="http://wooyun.tangscan.cn/" target="_blank" rel="noopener">http://wooyun.tangscan.cn/</a>  </p>
<p>补天<br><a href="http://loudong.360.cn/" target="_blank" rel="noopener">http://loudong.360.cn/</a>  </p>
<p>漏洞盒子<br><a href="https://www.vulbox.com/bounties" target="_blank" rel="noopener">https://www.vulbox.com/bounties</a>  </p>
<p>阿里SRC<br><a href="https://security.alibaba.com/" target="_blank" rel="noopener">https://security.alibaba.com/</a>  </p>
<p>腾讯SRC<br><a href="https://security.tencent.com/" target="_blank" rel="noopener">https://security.tencent.com/</a>  </p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cenrise.com/2017/05/08/hadoop/Hadoop知识点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongpo.jia">
      <meta itemprop="description" content="个人博客">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="中起之星">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/08/hadoop/Hadoop知识点/" itemprop="url">
                  Hadoop知识点
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-05-08 23:43:49" itemprop="dateCreated datePublished" datetime="2017-05-08T23:43:49+08:00">2017-05-08</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-08-18 09:44:35" itemprop="dateModified" datetime="2017-08-18T09:44:35+08:00">2017-08-18</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/大数据/" itemprop="url" rel="index"><span itemprop="name">大数据</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/大数据/hadoop/" itemprop="url" rel="index"><span itemprop="name">hadoop</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#Hadoop数据管理<br>主要包括Hadoop的分布式文件系统HDFS、分布式数据库HBase和数据仓库工具Hive</p>
<p>##HDFS的数据管理<br>HDFS是分布式计算的存储基石，Hadoop分布式文件系统和其它文件系统有很多类似的特性；<br>1）对于整个集群有单一的命名空间；<br>2）具有数据一致性，都适合一次写入多次读取的模型，客户端在文件没有被成功创建之前是无法看到文件存在的。<br>3）文件会被分割成多个文件块，每个文件块被分配存储到数据节点上，而且会根据配置由复制文件块来保证数据的安全性。<br>HDFS有三个重要的角色来进行文件系统的管理：NameNode、DataNode和Client。NameNode可以看做是分布式文件系统的管理者，主要负责管理文件系统的命名空间、集群配置信息和存储块的复制等。NameNode会将文件系统的Metadata存储在内存中，这些信息主要包括文件信息、每一个文件对应的文件块的信息和每一个文件块在DataNode中的信息等。DataNode是文件存储的基本单元，它将文件块（Block）存储在本地文件系统中，保存了所有Block的Metadata，同时周期性地将所有存在的Block信息发送给NameNode。Client就是需要获取分布式文件系统文件的应用程序。接下来三个具体的操作来说明HDFS对数据的管理。<br>（1）文件写入<br>1）Client向NameNode发起文件写入的请求。<br>2）NameNode根据文件的大小和文件块配置情况，返回给Client所管理的DataNode的信息。<br>3）Client将文件划分为多个Block，根据DataNode的地址信息，按顺序将其写入到每一个DataNode块中。<br>（2）文件读取<br>1）Client向NameNode发起文件读取的请求。<br>2）NameNode返回文件存储的DataNode信息。<br>3）Client读取文件信息。<br>（3）文件块（Block）复制<br>1）NameNode发现部分文件的Block不符合最小复制数这一要求或部分DataNode失效。<br>2）通知DataNode相互复制Block。<br>3）DataNode开始直接相互复制。  </p>
<p>作为分布式文件系统，HDFS在数据管理方面还有值得借鉴的几个功能：<br>a.文件块（Block）的放置：一个Block会有三份备份，一份放在NameNode指定的DataNode上，另一份放在与指定DataNode不在同一机器上的DataNode上，最后一份放在与指定DataNode同一Rack的DataNode上。备份的目的是为了数据安全，采用这种配置方式主要是考虑同一Rack失败的情况，以及不同Rack之间进行数据复制会带来的性能问题。<br>b.心跳检测：用心跳检测DataNode的健康状况，如果发现问题就采取数据备份的方式来保证数据的安全性。<br>c.数据复制（场景为DataNode失败、需要平衡DataNode的存储利用率和平衡DataNode数据交互压力等情况）；使用Hadoop时可以用HDFS的balancer命令配置Threshold来平衡每一个DataNode的磁盘利用率。假设设置了Threshold为10%，那么执行balancer命令时，首先会统计所有的DataNode的磁盘利用率的平均值，然后判断如果某一个DataNode的磁盘利用率超过这个平均值，那么将会把这个DataNode的Block转移到磁盘利用率低的DataNode上，这对于新的节点为加入十分有用。<br>d.数据校验：采用CRC32做数据校验。在写入文件块的时候，除了会写入数据外还会写入校验信息，在读取的时候则需要先校验后读入。<br>e.数据管道性的写入：当客户端要写入文件到DataNode上时，首先会读取一个Block，然后将其写到每一个DataNode上，接着由第一个DataNode将其传递到备份的DataNode上，直到所有需要写入这个Block的DataNode都成功写入后，客户端才会开始写下一个Block。<br>f.安全模型：分布式文件系统启动时会进入安全模式（系统运行期间也可以通过命令进入安全模式），当分布式文件处于安全模式时，文件系统中的内容不允许修改也不允许删除，直到安DataNode上数据块的有效性，同时根据策略进行必要的复制或删除部分数据块。在实际操作过程中，如果在系统启动时修改和删除文件会出现安全模式不允许修改的错误提示，只需要等待一会即可。  </p>
<p>##HBase的数据管理<br>HBase是一个类似Bigtable的分布式数据库，它的大部分特性和Bigtable一样，是一个稀疏的、长期存储的（存在硬盘上）、多维度的排序映射表，这张表的索引是行关键字、列关键字和时间戳。表中的每个值是一个纯字符数组，数据都是字符串，没有类型，所以同一张表中的每一行数据都可以有截然不同的列。列名字的格式是“<family>:<label>“，它是由字符串组成的，每一张表有一个family集合，这个集合是固定不变的，相当于表的结构，只能通过改变表结构来改变表的family集合。但是label值相对于每一行来说都是可以改变的。<br>HBase把同一个family中的数据存储在同一个目录下，而HB的写操作是锁行的。每一行都是一个原子元素，都可以加锁。所有数据库的更新都有一个时间戳标记，每次更新都会生成一个新的版本，而HBase会保留一定数量的版本，这个值是可以设定的。客户端可以选择获取距离某个时间点最近的版本，或者一次获取所有版本。  </label></family></p>
<p>以上从微观上介绍了HBase的一些数据管理措施，那么HBase作为分布式数据为顺整体上从集群出发又是如何管理数据的呢？<br>HBase在分布式集群上主要依赖于HRegion、HMaster、HClient组成的体系结构从整体上管理数据。<br>HBase体系结构有三大重要组成部分：<br>a.HBaseMaster：HBase主服务器，与Bigtable的主服务器类似。<br>b.HRegionServer：HBase域服务器，与Bigtable的Tablet服务器类似。<br>c.Hbase Client：HBase客户端是由org.apache.hadoop.Hbase.client.HTable定义的。<br>下面将对这三个组件进行详细的介绍。<br>（1）HBaseMaster<br>一个HBase只部署一台主服务器，它通过领导选举算法确保只有唯一的主服务器是活跃的，ZooKeeper保存主服务器的服务器地址信息。如果主服务器瘫痪，可以通过领导选举算法从备用服务器中选择新的主服务器。<br>主服务器承担着初始化集群的任务。当主服务器每一次启动时，会试图从HDFS获取根或根域目录，如果获取失败则创建根或根域目录，以及第一个元域目录。在下次启动时，主服务器就可以获取集群和集群中所有域 的信息了。同时主服务器还负责集群中域的分配、域服务器运行状态的监控、表格的管理等工作。  </p>
<p>（2）HRegionServer<br>HBase域服务器的主要职责有服务于主服务器分配的域、处理端的读写请求、本地缓冲回写、本地数据压缩和分割域等功能。<br>每个域只能由一台域服务器来提供服务。当它开始服务于某域时，它会从HDFS文件系统中读取该域的日志和所有存储文件，同时还会管理操作HDFS文件的持久性存储工作。客户端通过与主服务器通信获取域或域服务器的列表信息后，就可以直接向域服务器发送域读写请求，来完成操作。  </p>
<p>（3）HBaseClient<br> HBase客户端负责查找用户域所在的域服务器地址。HBase客户端会与HBase主机交换消息以查找根域的位置，这是两者之间唯一的交流。<br>定位根域后，客户端连接根域所在的服务器，并扫描根域获取元域信息。元域信息中包含所需用户域的域服务器地址。客户端再连接元域所在的服务器，扫描元域以获取所需用户域所在的域服务器地址。客户端再连接元域所在的域服务器，扫描元域以获取所需用户域所有的域服务器地址。定位用户域后，客户端连接用户域所在的域服务器并发出读写请求。用户域的地址将在客户端被缓存，后续的请求无须重复上述过程。  </p>
<p>综上所述，HBase的体系结构中，HBase主要由主服务器、域服务器和客户端三部分组成。主服务器作为HBase的中心，管理整个集群中的所有域，监控每台域服务器的运行情况等；域服务器接收来自服务器的分配域，处理管理端的域读写请求并回写映射文件等；客户端主要用来查找用户域所在的域服务器地址信息。  </p>
<p>##Hive的数据管理<br>Hive是建立在Hadoop上的数据仓库基础架构。它提供了一系列的工具，用来进行数据提取、转化、加载，这是一种可以存储、查询和分析存储在Hadoop中的大规模数据的机制。Hive定义了简单的类SQL的查询语言，称为HiveQL，它允许熟悉SQL的用户用SQL语言查询数据。作为一个数据仓库，Hive的数据管理按照使用层次可以从元数据存储、数据存储和数据交换三方面来介绍。<br>（1）元数据存储<br>Hive将元数据存储在RDBMS中，有三种模式可以连接到数据库。<br>1）Single User Mode:此模式连接到一个In-memory的数据库Derby，一般用于Unit Test。<br>2）Multi User Mode：通过网络连接到一个数据库中，这是最常用的模式。<br>3）Remote Server Mode：用于非Java客户端访问元数据，在服务器端启动一个MetaStoreServer，客户端利用Thrift协议通过MetaStoreServer来访问元数据库。<br>（2）数据存储<br>首先，Hive没有专门的数据存储格式，也没有为数据建立索引，用户可以非常自由地组织Hive中的表，只需要在创建表的时候告诉Hive数据中的列分隔符和行分隔符，它就可以解析数据了。<br>其次，Hive中所有的数据都存储在HDFS中，Hive中包含4种数据模型：Table、External Table、Partition和Bucket。<br>Hive中的Table和数据库中的Table在概念上是类似的，每一个Table在Hive中都有一个相应的目录来存储数据。例如，一个表pvs，它在HDFS中的路径为:/wh/pvs，其中wh是在hive-site.xml中由${hive.metastore.warehouse.dir}指定的数据仓库的目录，所有的Table数据（不包括External Table）都保存在这个目录中。<br>（3）数据交换<br>数据交换主要分为以下部分，如图：</p>
<p>a）用户接口：包括客户端、Web界面和数据库接口。<br>b)元数据存储：通常存在在关系型数据库中，如MYSQL、Derby中。<br>c)解释器、编译器、优化器、执行器。<br>d)Hadoop：利用HDFS进行存储，利用MapRecue进行计算。<br>用户接口主要有三个：客户端、数据库接口和Web界面，其中最常用的是客户端。Client是Hive的客户端，当启动Client模式时，用户会想要连接Hive Server，这时需要指出Hive Server所在的节点，并且在该节点启动HiveServer。Web界面是通过浏览器访问Hive的。<br>Hive元数据存储在数据库中，如MYSQL、Derby中。Hive中的元数据包括表的名字、表的列、表的分区、表分区的属性、表的属性、表的数据所在目录等。<br>解释器、编译器、优化器完成HiveQL查询语句从记法分析、语法分析、编译、优化到查询计划的生成。生成的查询计划存储在HDFS中，并且随后由MapRecue调用执行。<br>Hive的数据存储在HDFS中，大部分的查询由MapRecue完成（包括<em>的查询不会生成MapRecue任务，比如select </em> from tbl).  </p>
<p>#安装并运行Hadoop<br>介绍Hadoop安装之前，先介绍一下Hadoop对各个节点的角色定义。<br>Hadoop分别从三个角度将主机划分为两种角色。第一，最基本的划分为Master和Slave，即主人和奴隶；第二，从HDFS的角度，将主机划分为NameNode和DataNode（在分布式文件系统中，目录的管理很重要，管理目录相当于主人，而NameNode就是目录管理者）；第三，从MapRecue的角度，将主机划分为JobTracker和TaskTracker（一个Job经常被划分为多个Task，从这个角度不难理解它们之间的关系）。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="dongpo.jia" />
            
              <p class="site-author-name" itemprop="name">dongpo.jia</p>
              <p class="site-description motion-element" itemprop="description">个人博客</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">49</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">43</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">40</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dongpo.jia</span>

  

  
</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.2.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.2.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.2.0"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
