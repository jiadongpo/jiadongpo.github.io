<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.2.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=6.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico?v=6.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.2.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="中起之星">
<meta property="og:url" content="http://cenrise.com/index.html">
<meta property="og:site_name" content="中起之星">
<meta property="og:description" content="个人博客">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="中起之星">
<meta name="twitter:description" content="个人博客">






  <link rel="canonical" href="http://cenrise.com/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>中起之星</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">中起之星</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">Cenrise</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cenrise.com/2018/07/07/读书/《卖掉法拉利的高僧》摘要 /">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongpo.jia">
      <meta itemprop="description" content="个人博客">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="中起之星">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/07/读书/《卖掉法拉利的高僧》摘要 /" itemprop="url">
                  《卖掉法拉利的高僧》摘要
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-07-07 18:03:41 / 修改时间：18:04:08" itemprop="dateCreated datePublished" datetime="2018-07-07T18:03:41+08:00">2018-07-07</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/读书/" itemprop="url" rel="index"><span itemprop="name">读书</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这是一部有方法的个人价值实现指南。故事以对话的方式讲述，在审视自我的过程中，重新发现想要的生活。</p>
<p>刚开始看到这个书名时，感觉是一本精彩的小说，这么少的文字，被翻译成70多种语言，一定很有意义，就试着读了读。读了之后才发现这是一本实践性很强的自我价值实现指导书，里边有非常具体的方法论及使用方法，同时被里边的故事吸引了。</p>
<p>本书通过瑜伽师拉曼一个寓言，来讲解充满丰富精神内涵的七项品质，这个寓言里，包含了人生的奥妙。下面就开始吧。</p>
<p>“闭上眼睛，在脑海中浮现出以下画面……”<br>你坐在一个漂亮的、郁郁葱葱的花园当中。花园里满眼都是你所见过的最引人陶醉的鲜花。四周极度寂静，了无声息。品味这花园带给你的快乐，想象自己有大把的时间来欣赏这片自然的绿洲。若你向四周环顾，就会看到，在这个神奇花园的中心伫立着一座高耸的、六层高的红色灯塔。<br>突然，花园里的静默被一阵嘈杂的吱吱嘎嘎声打破，灯塔底部的门被打开了。跌跌撞撞地走出来一个两米七高、四百公斤重的日本相扑选手，他是在不经意间闯进花园中心的。<br>“下面就更有意思了，”朱利安哧哧笑着说，“那个日本相扑选手几乎全身赤裸，只有私处覆盖着多股丝线织成的粉色带子。”<br>然后这个相扑选手开始在花园里走来走去。他找到了一个闪闪发亮的金质秒表，不知是谁很多年以前遗留在那儿的。他不小心踩在秒表上，“砰”的一声巨响，结结实实地摔倒在地上。这个相扑选手变得毫无知觉，无声无息地躺在那里。就在你觉得他就要咽下最后一口气的时候，他慢慢地苏醒过来了，可能是因为受到附近那些黄玫瑰芬芳的刺激。仿佛吸收了新的能量似的，这个选手一跃而起，下意识地往左边望去。他被眼前的一幕惊呆了：<br>透过花园边上的灌木丛，他看到一条蜿蜒曲折的林间小路，路上覆盖着数不清的闪闪发光的钻石。仿佛有一股神奇的力量，他渐渐地被吸引，顺着那条路慢慢地走了过去。就是这条路把他带上了充满无尽快乐和无上幸福的大道上。 </p>
<p><strong>基于以上故事，引出的七个品质</strong></p>
<h1 id="花园，代表心智"><a href="#花园，代表心智" class="headerlink" title="花园，代表心智"></a>花园，代表心智</h1><p>心智的控制要通过心理调节才能奏效</p>
<p>不管你的生活中发生了什么样的变故，你都一直有权利选择自己对待事件的反应态度。当你养成了在每件事情当中都认真寻找积极因素的习惯时，你的人生就会变得鲜活有趣，生活就会升华到最高境界。</p>
<p><strong>你的外在世界其实就是内心世界的外显。通过控制自己的想法，控制你对人生中每件事情的反应，你就能够开始掌控自己的命运。</strong></p>
<p>我要郑重地建议你，不要动不动就贸然判断一件事情究竟是积极的，还是消极的。你最好先去经历它们，赞美它们并认真从中学习。生活中的每件事都会教你一些东西。它们是你完善内在世界和外在世界的力量。如果没有它们，你就会停滞不前。想一想它们在你生命中起到的作用吧。大部分人的生活之所以经历了突飞猛进的成长，起因都是因为遭遇到最具有挑战性的人生经历。假如结果让你有些出乎意料，也许会让你感到微微的失望，这个时候你就好好地想想自然的法则吧，因为它总是会确保在一扇门关闭的同时打开另一扇门。所以说，失败中潜藏着成功，挑战与机遇同在。一旦你把这个原则持之以恒地应用到你的日常生活中，以此为标准，努力训练自己的心智，积极地看待每件事情，善于从中汲取力量，那你就会永远忘却那些不必要的烦恼。你将不再是逝去的时光的囚徒，而将成为规划自己未来的设计师。</p>
<p><strong>除此之外，我还应该做些什么呢？</strong><br>首先，<strong>开始依靠你的想象力而不是记忆力来过日子。</strong><br>我想说的就是，要想释放你心智的、身体的和灵魂的潜能，首先就得学会扩展自己的想象力。你看，事情通常都会发生两次：第一次是在头脑中形成；接下来才会在现实中发生。我把这个过程称之为‘蓝图’，因为你周围发生的任何事情都来源于你脑中的蓝图。要是你学会了控制自己的想法，学会了生动地想象所有你期望的东西，蛰伏在你身体内的意志力就会渐渐苏醒。你就能够释放出心智中真正的潜力，从而创造出一种神奇的生活。从今天晚上开始，你就可以尝试努力忘掉过去的一切，大胆地想象比现实状况好得多的生活，去想象生命中最好的境界。你会为梦想的结果而感到惊讶。 </p>
<p><strong>获取幸福的奥秘其实很简单：</strong>找到你内心中最喜欢做的事情，然后把自己所有的精力都集中到那个方向，然后付出自己最大的努力。如果你对我们这个世界上最幸福、最健康、最心满意足的人做一个抽样调查，你就会发现，他们中的每个人都寻找到了生命中属于自己的热情，然后用一生的时间去追求它。这种使命感在某种程度上还可以为其他人服务。一旦你把自己的心智能量和生命力全都集中在了你所热爱的追求上，你的生活就会变得丰富多彩，目标的实现也会变得轻松而愉快，就像你在车库边哼着小曲边贴壁纸一样，充满了闲适的乐趣。</p>
<p>湿婆神的智者每天都要花时间静思默想，不仅思考自己身在何处，还要思考自己将去何方。他们每天都在思考，最重要的是，他们尤其重视如何通过思考指导自己不断进步，哪怕这种进步看起来是如此的微不足道。因为他们知道，只要每一天都获得一些微小的进步，那么日积月累就会产生持久而有效的成果，反过来就会引起精神世界的巨大改观。</p>
<h2 id="玫瑰之心"><a href="#玫瑰之心" class="headerlink" title="玫瑰之心"></a>玫瑰之心</h2><p>“有一种控制心智的方法要远远地胜过其他方法。这是瑜伽师拉曼钟爱的方法，也是在他教给我的所有方法中最好的一个。在接受了这项指导以后，我仅仅练习了21天，就感到精力旺盛，比我在青壮年时期都更加热情饱满、活力四射。这个练习法已经有四千多年的历史了，它的名字叫作‘玫瑰之心’。”<br>“‘玫瑰之心’？很文雅的名字嘛。能不能给我讲得再具体些呢？”<br>“<strong>你用这个方法进行练习时，只需要准备一朵鲜艳的玫瑰和一处安静的地方。自然的环境当然最好，不过在一个安静的房间里也可以做得很好。一开始，你要集中注意力凝视玫瑰的花心，这就是它的心脏。瑜伽师拉曼告诉过我，所谓一花一世界，一朵玫瑰花如同一个生命：在路上你会遇到尖刺，但是如果你有信心，坚信自己的梦想会实现，最终就会越过那些尖刺，进入灿烂的鲜花世界。你要学会目不转睛地凝视着这朵玫瑰，感觉它的颜色、质地和模样，深深地呼吸它的芬芳，头脑中浮想着那些无限美好的事物。在这个过程中，别的念头会悄悄溜进来，慢慢侵入你的心智，分散你的注意。这是没有经受过特别训练的心智的特征。不过你不必为此担心，这种状况将很快就得到改善。你只需要把注意力再次返回到花心点上来。很快，你的心智就会因为经受了成千上百次的训练而变得强大有力。</strong>”<br>“要做的只有这么多吗？听起来确实再简单不过了。”<br>“这就是这个方法的优点，约翰，”朱利安回答说，“不过，<strong>这个方法必须每天坚持做才会起效。在开始的几天里，你会感到这种练习看上去容易，做起来却有很大的难度，也许你连5分钟都坚持不到。这也说明我们大部分人的生活节奏太快，都好像得了躁狂症一般，真正的安宁和沉默仿佛是宇宙之外的东西，让人感到很不舒服。</strong>  很多人听到‘玫瑰之心’的建议之后都会说他们没有时间坐下来盯着一朵花傻乎乎地看上半天。有趣的是，也是这帮人还会向我诉苦说，他们没有时间享受孩子的笑声，也没有时间光着脚在雨中漫步。这些人们总是抱怨说他们太忙了，没有时间过那种闲适的生活。他们甚至没有时间去结交新朋友，因为建立友谊也是要占用大量时间和精力的。” </p>
<p>“<strong>要学习持之以恒的信念，花越来越长的时间去感知花心</strong>，”朱利安继续用他低沉的声音说，“<strong>也许在一两个星期以后，你就差不多可以在这个练习中坚持到20分钟，而不让自己的思想分散到其他的事情上去。这将是你修心养性并有所获得的第一个标志，你夺回了心智的控制权。你命令它关注哪个事物，它就会把注意力集中到哪个事物上去。那时，心智就成了最好的仆人，可以为你完成许多不可思议的事情。记住，不是你控制心智，就是它反过来控制你。</strong>” </p>
<h2 id="静思默想"><a href="#静思默想" class="headerlink" title="静思默想"></a>静思默想</h2><p>湿婆神的智者每天都要花时间静思默想，不仅思考自己身在何处，还要思考自己将去何方。他们每天都在思考，最重要的是，他们尤其重视如何通过思考指导自己不断进步，哪怕这种进步看起来是如此的微不足道。因为他们知道，只要每一天都获得一些微小的进步，那么日积月累就会产生持久而有效的成果，反过来就会引起精神世界的巨大改观。</p>
<p>最少每天抽出10分钟也是可以的。</p>
<h2 id="对立思维法"><a href="#对立思维法" class="headerlink" title="对立思维法"></a>对立思维法</h2><p>在消除内心烦恼和其他负面情绪方面，还有一项特别有效的技巧。这项技巧建立在瑜伽师拉曼称之为‘对立思维法’的基础之上。<strong>在伟大的自然法则下，大脑在同一时间只能拥有一个想法。</strong><br>因此，任何人都可以在短暂的时间内很轻松地创造出一种积极、有新意的思维。过程简单而直接：如果有一个令人不快的想法在头脑中占据了主要的位置，就马上试着用一个鼓舞人心的想法去替代它。你的头脑就好比一个非常巨大的幻灯放映机，出现在头脑中的每一个念头都仿佛一张幻灯片。每当银幕上出现了令人不悦的画面，就用最快的速度拿起一张内容积极的幻灯片去替换掉它。</p>
<h2 id="湖水的秘密"><a href="#湖水的秘密" class="headerlink" title="湖水的秘密"></a>湖水的秘密</h2><p>每件事情都会发生两次，第一次发生在头脑中，第二次是在现实中得到印证。我已经意识到思想也是现实，是物质性的信息，当我们把思想散播出来，其实也就改变了现实的世界。我也曾经对你说过，如果你希望在外部世界中获得显著的改善，首先就得从内在精神世界的改善开始，要学会改变你自身的思想与品格。<br>“喜马拉雅山上的智者有一个很好的办法来确保他们思想的纯净，而且有益于身心的发展。这个方法在把人的内在愿望转化为现实力量方面也显得极为高效，尽管它很简单。而且这个方法对任何人都有效。无论是汲汲于扩充人生财富的年轻律师，还是希望丰富家庭生活的妈妈，或者是希望完成更多销售量的推销员，都可以从这个方法中受益。智者给它命名为‘湖水的秘密’。在训练这个方法时，智者早晨四点钟就起床洗漱了，因为他们认为清晨时光之中包含着神秘的要素，他们可以从中感受到宇宙的脉动。这些智者沿着陡峭而狭窄的山路缓缓行走，这些道路最终把他们引向河流的下游。他们到那儿以后，就顺着一条几乎看不出来的小径继续走，两边是伟岸的青松和异样繁茂的鲜花。他们就这样一直走到一片开阔的空旷地。空地边上是一汪青绿色的湖水，这时水鸟还在沉睡，四周一片寂静。那种安静平和的情景仿若仙境。智者告诉我说，这个湖在很早很早以前就已经是他们祖先的朋友了。”<br>“<strong>‘湖水的秘密’是什么？</strong>”我不耐烦地打断了他的话。<br>朱利安不急不躁地解释说，<strong>智者会观察平静的湖水，想象他们的梦想化为现实。湖水如同一面命运的镜子，所有的欲望都能够完整地投射于其上。如果他们希望在生活中养成训练有素的良好习惯，他们会想象出自己在凌晨起床的样子，一丝不苟地完成他们严格的身体养生锻炼，时间在静默无声地提高个人意志力量的过程中悄悄流逝。如果他们想要寻找更多的快乐，就会满怀喜悦地注视着湖面，想象自己毫无节制地大笑的模样，或者回想自己遇到兄弟姊妹时在脸上浮现出的发自内心的微笑。如果他们寻求勇气，就会想象自己在面对危机和挑战的时刻是如何非常有力地行动着。而湖水就像一位仁厚的智者给他们以巨大的支持。中国人所说的“仁者乐山，智者乐水”，也许就是这个意思。</strong><br>“还有一次瑜伽师拉曼悄悄对我说，当他还是个孩子的时候其实也非常缺乏自信心，因为他比同龄男孩的个头要小得多。虽然他们的教养都很好，依然能够态度温和地对待他，可在自卑感的暗示下，他还是变成了一个害羞的、没有安全感的人。为了弥补这个欠缺，拉曼独自来到那个天堂似的所在，把湖面当作内心映像的屏幕，尽力想象他所希望成为的那种人的形象。有些天里他看到自己成为了强有力的领导者，坐在高高的殿堂上，声音宏亮而果断地发号施令。而另外一些时候，他会看到自己老年的形象：一个博学的智者，具有无限的内在潜力和坚韧的性格。所有他希望在自己的生命中能够拥有的美德，他全部都在湖面上先看到了。<br>“通过几个月时间的静观，瑜伽师拉曼真的成为了他在意念中看到自己想要成为的那种人。你看，约翰，心智就这样通过头脑的想象产生了巨大的效果。<strong>内心的图像可以影响到你的自我想象，而你的自我想象又会影响你在感觉、行动和进取方面的方式。</strong>如果你的自我想象告诉你，你太年轻，成为不了一名成功的律师，或者你年纪太大，改不掉那些坏习惯，那么你就永远不能实现这些目标。如果你的自我想象告诉你说，要过一种丰富的、有目标的生活，要有良好的健康状态和幸福感，这些不仅是为了你自己，也是为了身边人们的幸福，那么这类预言最终会成为你的现实。<br>“而且，当你在头脑的屏幕上播放这些令人欢欣鼓舞的图像时，良好的变化就会开始显现在你的生命里。爱因斯坦曾说过，想象力比知识更加重要。<strong>每天你都得抽出一些时间来进行冥想，即使只有短短的几分钟，也要有意练习创造性的想象。</strong>在这一刻，尽可以把自己视作自己希望成为的那种人，不管这个形象是一位大法官，还是一个好父亲，或者是社区里的一个好居民。”<br> “我知道，这一定是一个非常古老但是也非常有效的办法。我的孩子在看《哈里・波特》，里面有一面魔镜，波特照镜子的时候看到了他父母的模样，而他的好朋友红头发的荣恩照镜子时看到的却是自己成为了全校国际象棋冠军的时刻。镜子折射出的形象往往是自己最渴望见到的模样，畅销书就是这样感动我们的，不是吗？”我毫无顾忌地说出自己的想法。“还有啊，我一定要找到一汪特殊的湖水才能练习‘湖水的秘密’这个方法吗？我一定要每天一大早跑到郊外去苦思冥想吗？”我忍不住继续问，“你知道，这对生活在都市中的人来说简直是天方夜谭啊。”<br> “你不必这么循规蹈矩。<strong>‘湖水的奥秘’只是智者对这个古老技巧给出的一个称呼而已，其目的是要用积极的想象来影响心智，并不是让你拘泥于其中。你可以根据自身情况灵活机动地作出调整，比如在自己的客厅里，甚至就在办公室里来练习这个方法。只要你真的想这么做，那么随时随地都可以。</strong>你可以试一试，先关紧房门，关掉手机，闭上眼睛，然后慢慢地做几次深呼吸。两三分钟之后你就会注意到，你真的开始感到周身放松。接下来，在头脑里想象出所有你希望的东西，想要拥有的，或者想要达到的。如果你想成为世界上最好的父亲，就想着自己正在开怀大笑，你的孩子们正围着你快乐地玩耍，而你呢，则不厌其烦地解答他们各种各样匪夷所思的问题。你还可以想象自己举止优雅、充满爱心的样子。通过这种方法，先在头脑中演练自己的形象，等到相仿的场景在现实的情境中真的出现时，你就可以完全施展自己的潜能了。<br> “想象自己形象的方法可以适用于很多种情况。你可以利用它来使自己在法庭辩论中更富有逻辑，你可以利用它来改善自己的人际关系，当然你也可以借此发掘自己的精神潜能。持之以恒地使用这种方法还会带给你社会声望的回报，以及丰厚的物质收获，如果你觉得这些东西对你很重要。<strong>如果你觉得生活中缺少了什么，那是因为你的头脑中并没有这种东西。记住，要在头脑中留住美好的画面。一旦你开始练习这种方法，它就会让你彻底领会到心智所具有的神奇威力，开启大脑的潜力，它实现你生命中一切渴望的东西。</strong>”<br> “瑜伽师拉曼和与他居住在一起的<strong>智者都经常提到一句老话，这句话世代相传，流传至今。我很幸运在这个对我们两个来说都很重要的夜晚将这句话转告给你。话是这么说的：“凌驾于他人之上毫无尊贵可言；真正的尊贵是超越以往的自我。’如果你想达到我真正达到的那个境界，与你认为有意义的东西并驾齐驱的话，你就必须首先和自己赛跑，向自己发起挑战。何必在意别人怎么议论你呢？最关键的是你自己的想法。只要你能够确定自己的所作所为是正确的，就不要总是去在意他人的眼光，那样会让你变得畏首畏尾。你要告诉自己，你可以做任何你想做的事情，只要你的良知和内心都认为它是对的。千万不要为自己做了正确的事情而感到害羞。根据你所认为的好坏标准来作决定，然后毫不犹豫地坚持这种看法与做法。一定记住，千万不要堕入那种器量狭隘的计较之中，把自己的自尊和别人的非议评判作比较。就像瑜伽师拉曼倡导的那样，‘你在思考他人的梦想时耗费掉的每一分钟，都会将你到达自己梦想的时刻向后推迟一分钟。’</strong>”<br>现在已经是半夜十二点零七分了。和平常不一样的是，我丝毫也没有感觉到疲惫。当我把这种感觉告诉朱利安时，他又一次露出恬静的微笑：“你已经学会了另一种开启生命的方法。就大部分人来说，疲惫是心智匮乏的产物。没有梦想、没有方向感的人所过的生活常常是碌碌无为、疲惫不堪的。让我给你举一个例子。你有没有这样的体验，比如整整一个下午待在办公室里，强迫自己阅读那些干巴巴的案情报告。很快，你的心智就开始溜号，然后你也逐渐地睡意蒙眬起来？”<br>“有时候的确是这个样子的。”我回答说，其实内心并不愿承认，但事实上这恰恰正是我目前的工作常态。“当然，我们大多数人都会在遵循惯例、按部就班的工作中感到昏昏欲睡。”<br>“可是，如果有一个朋友打电话来，问你想不想晚上出来一起看场棒球比赛，或者请你为他的周末高尔夫球比赛出谋划策，我敢说你一下子就精神起来了，任何疲惫的痕迹都一股脑儿地飞到爪哇国去了。我说得对吧？”<br>“我承认确实如此，尊敬的顾问先生。”面对朱利安我只好讲实话，当然也故意用一种油腔滑调的语气来掩盖自己被人窥破心思时的不安。<br>朱利安从我的语气中知道他抓住了问题的关键，于是他更来劲了。“所以，你的疲惫不是别的，无非是匮乏的心智的产物。你的心智养成了坏习惯，当你从事一项单调而冗长的工作时，心智就成了挡路石。很明显，今天晚上你被我讲的故事吸引住了，开始对我希望与你分享的智慧感兴趣。<strong>记住，你的兴趣爱好和心智注意力都会给你的日常生活带来源源不断的活力。在这个晚上，你的心智既不再关注过去，也不再关注未来，它就聚焦在当下，聚焦在我们的话题上。如果你经常把心智引向当前的生活，你就一定会得到无尽的活力，不管钟表上指示的时间是深夜十点钟还是十二点钟。</strong>” </p>
<h1 id="灯塔，代表目标"><a href="#灯塔，代表目标" class="headerlink" title="灯塔，代表目标"></a>灯塔，代表目标</h1><p>在花园的中央伫立着一座明亮的灯塔。这个象征提醒你记起另一条启示生命奥义的古老原则：<strong>生命的目的就是有目的地生活。</strong>那些真正开悟了的人们知道他们将要从生活中得到什么，比如情感的、物质的、身体的，或者是精神的。他们把先后的顺序排列得清清楚楚，经过严密的统筹安排之后，生活中每个方面的目标都会发挥出类似于灯塔那样的作用，在海面上风起浪涌的时候会给你指引航向，为你提供安全的避难所。你看，约翰，只要彻底地改变了人生的进取方向，任何人都可以将自己的生活来个焕然一新的改变。但是如果你根本不知道你从哪儿来，又要到哪里去，那你又怎么可能知道自己什么时候会到达那个不知所终的地方呢？</p>
<p>“生命真是太奇妙了，”瑜伽师拉曼大发感慨，“人们可能会认为一个人工作得越少，就越有机会体验到闲适的幸福。然而并非如此，或者说这是片面地理解了幸福的含义。<strong>一言以蔽之，幸福的真正源泉就是一个词：成就。</strong>永恒的幸福来自于为了完成目标而进行的脚踏实地的工作，来自于在接近人生目标的过程中持之以恒的努力。只要点燃潜藏在内心中的火焰，它就会创造出一个令你我无法想象的新世界。我知道这听起来多多少少有点讽刺，因为我不辞辛苦离开自己以事业成就为本位的社会，艰难跋涉了几千里路，向居住在喜马拉雅山高峰上的神秘智者请教，希望得到关于幸福的永恒奥秘，却听说孜孜以求的幸福奥秘在于成就，可事实的确如此。</p>
<p>成就并不一定需要用物质来衡量。就我个人而言，我的目标就在于获得内心安宁，学会控制自我，学会了悟人生。如果直到生命的尽头，我还是不能达到以上这些目标，我相信我会死不瞑目，因为我没有抵达自己的圆满状态。</p>
<p>我的意思其实很简单。当你已经明确知道在你的一生当中最希望达到的目标是什么，不管这些目标是物质的、情感的、身体的还是精神的，你都要为抵达这一目标而倾注大量的时间与精力，只有这样才能最终体验到永恒的欢悦。你的生命将和我的生命一样充满快乐，而且你将逐渐看到自己的梦想一步步演变成为光灿灿的现实。但是这一切的前提在于，你必须首先了解自己，制订出明确的人生目标，然后通过持续不懈的努力把它转化为现实。我们称其为“达摩”，这是一句梵语，意思是‘生命的目标’。</p>
<p><strong>很多人在发现了自己存在的真正目标之后马上放弃了限制自己人性发展的工作，即便这项工作为他们赢得了巨大成功和丰厚的物质回报。</strong>这的确像是一场冒险，伴随着对自我的研究和灵魂的探索，你要学会不断地丢弃一些身外之物。可是也不能完全将它说成是一项冒险，因为在发现自我和人生的使命方面原本没有什么风险可言——在智者看来，发现自我这项工作本身就是人生体验中相当重要的一个环节。自我认知是开启人生的DNA生命链，它的确是生命中最关键的东西。</p>
<p>我的达摩相当简单：无私地帮助他人，丝毫不考虑任何回报。记住，你不能在呼呼大睡中发现人生真正的快乐。同样，在游乐场或者像个游手好闲的人那样恣意消磨时光，也不可能抵达人生的真知。正如本杰明・迪斯雷利[3] 说的那样：<strong>“成功的秘密在于不屈不挠地坚持自己的目标。’你所寻求的幸福是从有价值的目标中得来的，你付出所有的精力去争取成功，每天、每小时都努力地去接近这个目标。这是永恒哲理在现实生活中的应用，它规定了哪些事情是最重要的，永远不能被另外一些不重要的事情掩盖掉。在瑜伽师拉曼的寓言里出现的灯塔会一直提醒你，制订明确而有意义的目标有多重要，以及实现这些目标需要怎样的力量。</strong></p>
<p>确立目标是最基本的出发点。制订出你的方向和目标，就可以把创造力的潜能加以放大释放，最终促使你踏上通向目标实现的道路。信不信由你，瑜伽师拉曼和其他智者都热衷于不断设定目标*。</p>
<p>把我所有的智慧都和你分享。今天的这个例子就是为了进一步说明在人生中设立一个明确目标，以及清楚地知道你将往哪里去的重要性。你刚才见到的那一幕就说明了这个最为重要的原则：<strong>你一定不可能命中你根本看不见的目标。人们用去整整一生的时间来希望自己变得更加幸福，活得更有活力，拥有更加丰沛的激情，然而他们没有发现这个重要原则。你要学会，每个月抽出10分钟的时间，把自己的目标写出来，仔细地想一想生活的意义何在、人生根本目的何在。设立一个明确的目标可以让你的人生过得与众不同。你会变得更加丰富，更加愉快，拥有更加不可思议的精力。</strong></p>
<p>任何一个希望同时提高自己的内心品质和外在条件的人都要学会定期拿出一张白纸，认真地在上面写下自己的人生目标。</p>
<h2 id="一页纸在上面写出自己的目标"><a href="#一页纸在上面写出自己的目标" class="headerlink" title="一页纸在上面写出自己的目标"></a>一页纸在上面写出自己的目标</h2><p>此前我已经告诉过你，我们的头脑中平均每天会出现60,000个想法，然而这些想法太多了，多得你自己都容易迷失在欲望的丛林中。这个时候，在一张纸上写出你的愿望和目标就显得尤为关键。这一举动意味着你给潜意识的幽昧丛林中插上了一杆红旗，让这个想法比其余的59,999个想法突出得多。你的心智因此就像雷达一样，开始寻找一切机会去实现你的愿望。这个过程的确非常有效，可惜我们当中的绝大部分人对此视而不见。</p>
<p>愿望成真，一共需要有五个步骤<br>第一步是要对自己预期的结果有清楚而具体的认识。第二步是制造一种积极的压力来鼓舞自己。相对来说，第三步是非常简单的，那就是绝对不要好高骛远，设立一些不合时宜的目标。当你决心将人生和某一个目标相连，就意味着你必须给它设定一个明确的最终实现期限。这就如同你在为庭审准备大量的卷宗，你的注意力会一直集中在法官身上，因为他将决定庭审的日程安排。相反，其他人的话对你似乎没有任何影响。<br>让我们回到达到目的、实现目标的五步法上面吧。一旦你对未来的结果有了一个非常清晰的成形设想，也为此创造出了一点积极的压力，并划定了最后实现的期限，甚至当众许下了完成它的诺言，那么接下来要做的一个步骤就是瑜伽师拉曼称之为‘神奇的21天法则’的方法了。<br>最后我所说的就是，在你实现自己目标的过程中，一定要确保自己随时处在兴致盎然的状态。永远也不要忘记纵情狂欢的重要性，永远也不要忽视在所有的生命中都能看到精致的美丽。今天，以及你我一起分享智慧的这一刻都是上天的恩赐。保持你昂扬的精神、愉快的心情和好奇心。随时都要密切关注自己的毕生事业，随时都准备好要给予别人无私的帮助。宇宙对万物都一视同仁，这也是大自然的真理法则之一</p>
<h2 id="热情"><a href="#热情" class="headerlink" title="热情"></a>热情</h2><p>热情。这个词汇你一定要始终牢记在头脑里面。热情是实现梦想最根本的动力源泉。在我们这个碌碌无为的社会中，生命的热情早已经消失了。有的时候我们之所以什么也不愿意做，那是因为我们喜欢这样一直待着。而当我们开始动手做事情的时候，则是因为我们感到不得不做，只好没精打采地应付差事。这就是制造痛苦恶性循环的公式。不过我现在说的并不是那种浪漫的热情，尽管那也是促进成功、振奋人生的要素之一。我现在所说的是对生活的热情。每天早晨醒来时就要不停地对自己加油鼓劲，让自己浑身活力充沛，快乐无拘。热情是你工作中的加油站，热情的火焰越烧越旺，那么通向自信与成功的道路就越光明。你很快就会有丰厚的物质收获，同样还会获得精神上的巨大回报。</p>
<h2 id="禅悟"><a href="#禅悟" class="headerlink" title="禅悟"></a>禅悟</h2><p>意思是指不间断的、永不尽头的提升。</p>
<p>怎么用来丰富智者的生活呢？<br><strong>外在的成功首先开始于内在的成功。如果你确实想要改善自己的外在世界，不管这种外在世界指的是你的健康，你的人际关系，还是你的财产状况，你都必须先努力提升自己的内心世界。最有效的途径就是持续不断地进行改善自我的实践与练习。掌握自我就是掌握人生的DNA密码。</strong></p>
<p>中国古老的智者曾经说过：“道在屎溺中。’意思就是说宏大的人生哲理其实恰恰隐藏在看似平淡的日常生活细节之中。</p>
<p>在我们这个社会里，我们都太轻易地把无知看作是缺陷。然而，那些表现出自己缺乏知识，希望找到指引的人其实并不需要感到害羞，因为他们比其他人更早地意识到自己的问题，也就能够去更早地发现通向开悟的道路。你提出这个问题证明你非常诚实，让我看出来你的确愿意接受新理念。要知道在我们目前的这个社会里，改变是最强大的动力。大部分平庸的人害怕改变，而智慧的人则拥抱它的威力。禅悟代表的东方修行传统着重讲的是起步者的心智：那些敞开自己的头脑，随时准备接受新观念的人——也就是那些总是让自己的杯子空空如也的人——总是会在成就和满足感的方面达到更高的水平。千万不要羞于提出哪怕是最基本的问题。提问是获得正确知识的最有效的途径。</p>
<p>当我说到提升你的内心世界时，我只是简单地描绘了一下自我改善和个体发展的功效，并告诉你这是你能够为自己做的最有价值的事。或许你会觉得太忙了，没有时间花在自己身上，当然也无须奢谈什么改变。如果你这么想，那就大错而特错了。你要知道，当你把自己培养成一个纪律严明、活力充沛，充满乐观情绪的人时，你就可以在外部世界中拥有所有的东西，做所有你想做的事情。当你对自己的能力和不屈不挠的精神产生了深刻的自信，那么任何东西要想成为阻挡你胜利的拦路石，那真的就是螳臂当车了。在控制自我心智上多花些时间，时刻关注自己的身体，丰富自己的灵魂，都会使你的生活会变得更加丰富，更有生命力。许多年以前，斯多葛学派的爱比克泰德就曾经说过：“一个不能控制自己的人就不是自由人。</p>
<p><strong>禅的本意是静虑、冥想，悟与迷对称，指觉醒、觉悟。悟是意义的转化、精神的转化、生命的转化，含有解脱的意义。禅是修持方式，悟则是修持结果，两者是有区别的。但是东方的禅宗学人却把禅由坐禅静思变为日常行事，由心理平衡变为生命体验，这就从根本上改变了禅的内涵。东方的禅宗学人还认为觉悟要由日常行事来体现，由生命体验来提升。禅与悟是不可分的，悟必须通过禅来获得，禅没有悟也就不成其为禅。没有禅就没有悟，没有悟也就没有禅。</strong></p>
<p>接下来我开始思考究竟能够从哪些方面来提高自己的修养。让我一项一项地来看看吧。第一，定期的锻炼可以给我带来活力，这样我才能够保持健康良好的体格与心态。第二，控制我的坏脾气，不要随便打断别人的谈话。如果能够改正这些毛病，可能会在人际关系方面给我和妻子、孩子以及同事的相处带来意想不到的好处。第三，改掉忧虑的坏习惯。这可以带给我心智上的安宁和平静的幸福感。第四……我越想越兴奋，因为我发现在我身上能够进行改善的地方实在太多了，可这些我以前却从来没有注意过。 </p>
<h2 id="建立人格力量、培养心智和充满勇气地去生活"><a href="#建立人格力量、培养心智和充满勇气地去生活" class="headerlink" title="建立人格力量、培养心智和充满勇气地去生活"></a>建立人格力量、培养心智和充满勇气地去生活</h2><p>他耐心地谈到建立人格力量、培养心智和充满勇气地去生活具有多么重要的地位。他告诉我说：“这三种品质不仅可以让人拥有高尚的生活，而且可以使他的生活中充满成就感、满足感和内心的安宁。勇气这个宝贵的品质是每个人都可以培养得到的，它在经久不息的跋涉中带给你巨大的回报。<strong>”<br>  “</strong>勇气和自我领导、自我发展又有什么关系呢？<strong>”我大声问他。<br>  “</strong>勇气使你敢于正视自己，与自己的惰性赛跑。勇气使你敢于去做所有你认为是对的事情。勇气使你能够控制自我，在其他人失败的地方仍旧支撑你继续坚持下去。最终，你拥有勇气的多寡程度决定了你可以获得的成就的总量，这是一个有趣的正比例关系。它能够使你确切地从自己的生活中看到所有不同寻常的奇迹。另外，我还想告诉你，能够掌控自我的人都是拥有非凡勇气的人。</p>
<h2 id="心智、身体和灵魂"><a href="#心智、身体和灵魂" class="headerlink" title="心智、身体和灵魂"></a>心智、身体和灵魂</h2><p>在我的新生活里也就更加信奉禅悟的哲学，让心智、身体和灵魂都持续地、永不休止地获得自然的点化，在丰富心性的过程中不断提高。朱利安这样说。<br>为什么这些天以来我听到这么多次‘心智’‘身体’和‘灵魂’之类的词语？你要是不稍微解释一下，我还真拐不过弯来。<br>  “**这三个词语是你作为人的天赋中非常重要的三部分。简单地说，它们三者之间是相辅相成的关系。比如不锻炼身体，仅仅注重于提高心智，就只会得到非常空洞的胜利。如果你把心智和身体能力都提升到了最高水平，却没有认真地丰富自己的灵魂，会使自己感到异常地空虚，无法获得满足感。但是一旦你用出所有的力量来释放本性中这三个部分所有潜能的话，你就会在人生突然开悟的那一刻享受到神圣的狂喜。</p>
<h2 id="人们在艰难地进入未知区域的时候会变得最为强大"><a href="#人们在艰难地进入未知区域的时候会变得最为强大" class="headerlink" title="人们在艰难地进入未知区域的时候会变得最为强大"></a>人们在艰难地进入未知区域的时候会变得最为强大</h2><p>首先我必须和你一起分享一个实际的例子。请你摆出俯卧撑的姿势来。当然，依你现在的身材，你还能趴下吗？”朱利安不失时机地揶揄了我一下。<br>  “天哪，朱利安变成军事训练官了。”我暗自想着。出于好奇，也是为了像朱利安所说的“保持我的杯子空空如也”，我只有老老实实地照办。<br>  “现在，使出全身的力量做俯卧撑，不要停下来，直到你确定自己彻底没劲为止。让我们数一数你到底还能够做几个。”朱利安在一旁笑着说。我的天，他只差手里再握一只秒表了。 我挣扎着做起了俯卧撑。多少年了，我那肥胖的身躯从来都没有进行过这么多的运动，除了有那么屈指可数的几次，我和孩子们一起走到最近的一家麦当劳快餐店，或者和我的法律界同行们一边漫步一边打一轮高尔夫球。最初的15个俯卧撑完全像是垂死挣扎。我开始暗自抱怨这个闷热的夏季，黎明之前的气温依然使得我大汗淋漓。然而，我已经下定决心，坚决不要显出任何虚弱的迹象，坚持下去，直到我的虚荣心和手臂一起无法坚持的时候再停下。<br>  不过我的虚荣心显然没有那么坚强。在做到第23个的时候我放弃了努力，结结实实地趴在地上。<br>  “不行了，朱利安。”我一边喘气一边忍不住抱怨起来，“这简直是要杀了我。你这是打算干什么？”<br>  “你确定自己一个也做不起来了吗？”朱利安的表情十分严肃，丝毫没有开玩笑的意思。<br>  “我确定。算啦，让我喘口气吧。我唯一的感觉就是，我再动一动就会造成一次心脏病突然发作。那时你一定记着打急救电话啊。”<br>  “再做10个。然后你就可以休息了。”朱利安命令道，他的口气似乎没有商量的余地。<br>  “你说话不算数！”我愤愤不平地抗议道。然而为了能够获得朱利安的教导，我只好咬着牙坚持继续做下去。1个……2个……5个……8个……最后总算做了10个。我连翻身的力气都没有了，直接趴在地板上，觉得天都快要塌下来了。这时，耳边响起朱利安清晰的声音：<br>  “瑜伽师拉曼和我在一起分享他的特别寓言的那个晚上，我也像你这样经受了训练。不过，唯一的区别在于我做的俯卧撑是你的好几倍。”朱利安说。“当我体力不支趴在冰冷的地板上的时候，拉曼镇静地对我说，痛苦是最伟大的老师。”<br>  “痛苦是最伟大的老师？从这样枯燥的身体练习中究竟能够学到什么呢？”我气喘吁吁地问他，丝毫也不掩饰我的抱怨之情。<br>  “瑜伽师拉曼，还有所有居住在喜马拉雅山上的智者在这个问题上都保持了完全一致的看法。他们认为，<strong>人们在艰难地进入未知区域的时候会变得最为强大。</strong>”<br>  “好吧。我相信你的话是有道理的。但是这和俯卧撑有什么关系呢？又有什么理由让我非得做这么多俯卧撑不可呢？”<br>  “当你做了23个俯卧撑之后，你告诉我力气用完了，一个也做不起来了。我相信你对我说的话，在你的意识表层中，那真的是你的极限。然而，当我一定要求你再多做几个，你听从了我的话以后就又多做了10个俯卧撑。这说明了什么呢？”<br>  朱利安不等我回答，紧接着给出了答案：“<strong>这说明潜伏在你身体里的力量还有很多，只不过平时它们都在沉睡状态，缺乏足够的刺激将它们一一激活。一旦这些力量醒来，一旦你发现了自身力量源泉的时候，你就会发现自己其实比预想的要强大得多。其实类似的事情在生活中也是屡见不鲜的。比如报纸上会登载一条新闻说，某人因矿难而被深埋在地下半月之久，却能够依靠强大的求生意志而存活下来。或者说一个人从高空坠落，因为掌握好了身体的平衡感而幸免于死。相信你一定读到过这些新闻，不过你通常是把它们当作茶余饭后的街头怪谈，却没有冷静下来仔细想想其中的一些奥妙。这是关于生命的奥妙</strong>。<br>  “<strong>当我还是瑜伽师拉曼的学生时，他向我解释了这个基本原理：“生命中唯一的极限是你自己给自己设下的。’当你勇于从惰性的圈子中跳出来，打破陈规，向未知领域探索，你就开始释放本性中的潜能了。这是走向自我控制的第一步。当你把自己的极限推得更远，就像你在这次小小的示例中做的这样，你就会不断地开发出心智和体力的潜能，那是你从来不曾想、也不敢想的东西。而事实上，你原本有足够的能力去获得它。</strong>” </p>
<p>“太棒了。”我心想。突然，我记起了在最近看过的一本书里说，普通人的个人才能只有很微小的部分得到了利用，如果每个人都把自己沉睡的才能唤醒，那每个人都将是天才。“我很想知道，如果我们学会运用能力中其余那些沉睡的部分，我们又能做出什么呢？”<br>这个问题让朱利安有些为难。他挠了挠头，想了一下，然后回答道：“你刚才实践了‘禅悟’的技巧，相信我，这种技巧每天都可以使你进步。也许以下这些方面是你近期要努力的事情。<br>“<strong>努力提高自己的心智，改善身体的健康状况，让自己能够随时做到聚精会神。做那些让你感到恐惧的事情，这样就可以消除心魔，开始拥有无限的精力和无边的热忱</strong>。<br>“<strong>你还要学会融入大自然，认真观察日出时的动人情景，也可以试着在雨中自由舞蹈。</strong><br>“<strong>你要坚守自己的目标，每天都朝这个方向行进，这样才能真正成为你梦想成为的那种人。 </strong></p>
<p>“<strong>不要害怕出错，要鼓足勇气做你一直想做的事情，而不是自欺欺人地找借口拖延，嫌自己太年轻或者太年老，太贫穷或者太富裕。</strong><br>“<strong>准备好过一种目标远大，精神活跃的生活。在东方，人们常常会说，机会总是留给有准备的人。而我则深信，生活也偏爱有准备的人。</strong>”<br>**朱利安继续他热情洋溢的谈话，好像是一所大学课堂上的哲学老师。“认真分析生活中那些阻碍你的因素，然后想方设法去克服它。从多方面好好反省自己，比如你是不是害怕演讲，或者在人际关系上有麻烦？你是不是缺乏积极的人生态度，或者需要更多的精力？接着列出一份详细的目录，将自己的弱点一一登记在案，然后有的放矢地改正它们。在工作中容易得到满足感的人们往往比不思进取的人更加深思熟虑。把时间花在寻根究底上，就可以让你明白自己和所希望的生活之间的差距究竟有多远，还要对眼下的生活状态了若指掌。”<br>“一旦你看到了自己的弱点所在，那下一步的工作就是要直接面对它们，向自己的恐惧心理开战。中国有句俗话叫作‘怕处有鬼’，人们通常会被自己臆想出来的怪物吓傻了。恐惧只不过是你自己在头脑中制造出来的怪物，是一连串的负面意识。所以，要克服自己的心理痼疾。如果你惧怕当众演讲，就专门签约进行20场演讲，哪怕你要为此支付主办方一定的费用。如果你固守陈规，害怕开展新业务，或者想逃避不愉快的人际关系，那就专门给自己制造这方面的挑战环节。只要你迈出第一步，后面的路就好走了。当你像一只蝴蝶从蛹中破茧而出的时候，那将是你在这么多年以来第一次尝到真正的自由的滋味。</p>
<p>恐惧是一种条件反射，如果你不留神的话，它很快就会把生命力、创造力和精神都消耗殆尽。一旦恐惧满怀恶意地探出它丑陋的脑袋，你就应该一下子把它击垮。最有效的办法就是去做让自己感到害怕的事情，借此完全了解恐惧的内在结构。当你进入了恐惧的内部，就会发现它不过是源于你自己的胡思乱想。就像任何其他人创造出来的东西一样，把它揭穿就像把它创造出来一样简单。你可以学着有系统、有方法地查明底细，看清楚蛰伏在你心智深处的每一种恐惧到底都是什么，而后再一一击破。长此以往就会带来无限的信心、幸福和内心的安宁。**” </p>
<p><strong>“真的有人拥有无所畏惧的心灵吗？”我问他。<br>“问得好。我将毫不犹豫地断然回答：‘是的！’喜马拉雅山上的智者个个都毫无畏惧。你可以从他们走路的样子上看出这一点，可以从他们的谈吐内容上听出来这一点，也可以在深深凝视他们双眼时发现这一点。其实生活中有很多这样的例子，电影《勇敢的心》你看过吧？”<br>朱利安顿了顿，接着凑近我说：“我再给你说点别的，约翰。”<br>“什么啊？”我问他，心中对他刚才讲到的事情充满了好奇。<br>“</strong>我也曾一度胆小如鼠。对此我心知肚明，因此就打算进行一次自我清理，找到天生的意志力和无限的潜能。后来我找到了胆小的根源，正是因为这么多年来一直忽略自我以及思想发展的不平衡阻碍了我的发展。我再告诉你一件事。当你把恐惧从头脑中彻底驱逐出去之后，你就会变得更年轻，也变得更有活力。**” </p>
<p>“啊哈，<strong>古老的身心联系</strong>。</p>
<h2 id="迎着弱点和恐惧直面而上"><a href="#迎着弱点和恐惧直面而上" class="headerlink" title="迎着弱点和恐惧直面而上"></a>迎着弱点和恐惧直面而上</h2><p>另外一条非常有效的法则，我也时常会想到它。我觉得，当你走在引导自我和控制自我的道路上时，这条法则对你而言将是无价之宝。每当我想要投机取巧的时候，它就会批评我，给我以上进心。这一人生哲学可以简单地归纳为：行事高效的人和死气沉沉的人之间的最大区别在于，前者会去做后者不喜欢做的事——尽管他们可能也不愿意去做。<strong><br>“</strong>真正开悟的人，每天都可以体味到深沉的幸福感，随时准备着为了长久的满足而放弃短暂的快乐。他们就这样迎着弱点和恐惧直面而上，即便有时因为深陷未知的领域而感到极大的不自在也无所谓。他们下定决心，要依靠‘禅悟’的智慧来生活，永不间断地提高人生的各个层面。过去曾阻碍他们获得快乐、健康和富有的恐惧也会败下阵来。</p>
<h2 id="幸福要通过对一个有价值目标的渐进实现才能得到"><a href="#幸福要通过对一个有价值目标的渐进实现才能得到" class="headerlink" title="幸福要通过对一个有价值目标的渐进实现才能得到"></a>幸福要通过对一个有价值目标的渐进实现才能得到</h2><p>我最喜欢的教授给我讲过的一个古老故事。<br>有一天晚上，一位父亲在办公室工作了一整天以后开始拿着报纸看，想享一会儿清闲。可他的儿子很想玩，就一直缠着爸爸。最后，这位父亲被搞得不耐烦了，气呼呼地扯下一张地球画报，撕成了一大把小小碎片。“来吧，儿子，过来把它们重新拼在一起。”他说着，希望这一招可以让孩子忙上好一阵子，以便自己可以从容地看完手中的报纸。<br>让他大吃一惊的是，还不到一分钟，他的儿子就兴冲冲地带着一张拼贴无误的图片回来了。当这位目瞪口呆的父亲问儿子是怎样完成这个拼地图的壮举时，儿子笑得甜甜的，轻松地回答说：“爸爸，在这张地球图片的反面是一个人的图片，只要我把这个人拼在一起了，世界地图也就完整了。”<br>“真是棒极了。”我不由得赞叹起来。<br>“你看，约翰，从喜马拉雅山上的智者到哈佛法学院的教授，在我认识的最有智慧的人当中，似乎每个人都洞悉了幸福公式的要领。</p>
<p>幸福要通过对一个有价值目标的渐进实现才能得到。当你在做自己全心全意热爱着的事情时，就一定会感到深深的满足。</p>
<h2 id="做你喜欢的事情，需要很大"><a href="#做你喜欢的事情，需要很大" class="headerlink" title="做你喜欢的事情，需要很大"></a>做你喜欢的事情，需要很大</h2><p>我不妨再说得明确点，约翰。做你喜欢的事情，需要很大的勇气。它意味着你为了当演员要放弃手边正在做的工作，在不那么重要的事情上少花些时间，留下时间给更有意义的事情。它要求你离开习以为常的规律，也就是抛弃惰性，勇于创新。这种变化在最初的时候总会有些让人难以适应，而且具有一定的风险。但请一定记住我前面反复说的话，这正是走向快乐人生的起点。</p>
<p>一个人究竟应该怎样鼓起勇气呢？<br>这也像刚才故事里所说的：只要你可以控制自己，你的世界就没问题了。只要你能控制自己的心智、身体和品质，幸福和富裕就奇迹般地来到你的生命中。但是，你每天都要在自我完善上花一些时间，哪怕只有10到15分钟。</p>
<h1 id="相扑选手，注意‘禅悟’的提示者"><a href="#相扑选手，注意‘禅悟’的提示者" class="headerlink" title="相扑选手，注意‘禅悟’的提示者"></a>相扑选手，注意‘禅悟’的提示者</h1><p>这位肌肉发达的大块头就是不断提醒我们注意‘禅悟’的提示者。这个词在日语中的意思就是持续的自我发展和进步。</p>
<p>我已经明白了自己的心智其实是那么神奇，宝贵的潜能又将创造怎样的奇迹。我已经学会了非常高效的技巧，可以把能量集中到我的愿望和梦想上。我已经知道在生命中树立明确目标的重要性，要在我人生、职业和精神世界的每一个方面都设立非常清楚的目标。现在我已经完全接受了那个自我掌控的古老法则：“禅悟”</p>
<h2 id="活力生活的十个招数"><a href="#活力生活的十个招数" class="headerlink" title="活力生活的十个招数"></a>活力生活的十个招数</h2><h3 id="孤独的习惯"><a href="#孤独的习惯" class="headerlink" title="孤独的习惯"></a>孤独的习惯</h3><p>第一个办法被智者称作‘孤独的习惯’。所要求的无非是你在每天的日程表上划出来一段时间，这段时间用来保持自我的宁静，哪怕是一段强制性的自我宁静。</p>
<p>这段时间少则15分钟，多则50分钟。在此期间你要感受沉默的力量，要渐渐领悟到你究竟是谁。</p>
<p>把‘孤独的习惯’想成是灵魂长途跋涉中的短暂休息。它的目的就在于获得自我更新的机会，通过独自一人沉浸在美丽的沉默当中来实现。” </p>
<p>“沉默有什么特别之处吗？<strong>”<br>“问得好。</strong>沉默和宁静把你和内部世界的创造力源泉联结在一起，解放所有智力的束缚。你看，约翰，心智好比一汪湖水。在我们这个嘈杂的世界上，大部分人的头脑里都安静不下来，因为我们的内心充满混乱。然而，只要你肯每天花一点时间来静心沉默，心智也就会变得平静如镜。内在的安宁会带来丰厚的回报，包括健康舒适的感觉，内在心态的平和以及无穷的精力。你甚至会睡得更香，而且在日复一日的劳作中享受到自我更新的平衡感。</p>
<p>“我应该到哪里去寻找这一刻的安静呢？”<br>“从理论上说，你可以在任何地方，无论是在卧室还是在办公室。关键是要找到一个真正安静的地方——而且环境要很优美。”<br>“为什么必须是优美的环境呢？”<br>“<strong>优美的环境能够慰藉不安的灵魂，”朱利安解释说，深深地叹了一口气，“一束玫瑰，或者仅仅是一支孤零零的水仙，都会很好地改善你的情绪，让你得到非常有益的放松。说得更理想化一点，你应该在“个人避难所”中尽情享受这样的优美。我突然想到了一句东方禅语：菩提本无树，明镜亦非台，本来无一物，何处惹尘埃。</strong>”<br>“什么，什么？”<br>“<strong>简单说来，就是你为了自己的心智得到扩展，为了提升自己的精神境界，要学会把一个地方变成密室。这可能是你家中的空余房间，或者仅仅是一间小公寓中的安静角落。问题是你要给自己的更新行动保留一个相对固定的空间，一个静静地等待你到来的地方。</strong>”<br>“我喜欢这种说法。我想如果我在下班回家以后有了一个安静的地方可去，就会大大改变一切。我可以在那儿先待上一会儿，缓冲一下，消除一天当中的压力。这可能让我对周围的人更加有耐心。”<br>“<strong>这就涉及另外一个重要的问题。如果你每天都在同一时间来练习孤独静处的习惯，效果才会是最好的。</strong>”<br>“为什么？”<br>“<strong>因为它会作为一个习惯进入你的日常生活，成为一个有机组成的部分。如果在每天的同一时刻都来练习它，每日按时到来的静默很快就成为不容忽略的习惯。而积极的人生习惯将最终引导你到达目标。</strong>”<br>“还有别的吗？”<br>“是的。<strong>如果有可能的话，每天都和大自然谈谈心。在树林里做个短短的散步，或者哪怕是到后院，在你的西红柿苗圃里花上几分钟去浇水施肥，都会把你和安静的源泉重新连在一起。或许现在想一想这些事情就能让你的内心恢复平静。和大自然在一起，会激发你自身无穷的智慧。这种自我认知可以在自我潜力的方向上持之以恒地推动你的进步。别忘了这一点。</strong>”朱利安建议道。他的声音因为充满热情而慢慢提高，无论如何也听不出来是一夜未眠的人。<br>“这一招对你有效吗，朱利安？”<br>“绝对有效。在阳光尚未跃出地平线的时候，我就早早起床，做的第一件事就是走到我的‘个人避难所’。那是我在练习‘玫瑰之心’时发现的，后来一直秘密地使用着。有时候我静默地沉思冥想几个小时。有的时候也许只需花费10分钟。结果大致相似：我获得了一种内在和谐的深刻感受，以及无限的身体精力。</p>
<h3 id="体格锻炼的习惯"><a href="#体格锻炼的习惯" class="headerlink" title="体格锻炼的习惯"></a>体格锻炼的习惯</h3><p>“关于<strong>如何养护身体。</strong>”<br>“什么？”<br>“很简单。<strong>体格锻炼的习惯是基于一个基本原理：你只有通过养护身体才能进而养护心智。给身体做好充分地准备，才会给心智做好相应的准备。训练好了身体，才会训练好心智。你没有听东方的哲学家常常说什么‘天将降大任于斯人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为，所以动心忍性，曾益其所不能。’抽出一个整天，通过健身训练来滋养盛放心灵的殿堂。让身体活起来，让血液沸腾起来。你知道吗？一周有168个小时呢。</strong>”<br>“不，知道得不那么确切。”<br>“这是真的。其中至少有5个小时应该投入在某种方式的身体活动上。喜马拉雅山上的智者一直从事着一种古老的瑜伽训练，借此来唤醒身体内的潜能。天长日久，他们变得强壮有力，生机勃勃。这些身体超群的人很特别，<strong>他们常常在村子中央倒立，以此来保持年轻。</strong>” </p>
<p>“那些智者还做过别的什么来养护身体吗？”<br>“<strong>瑜伽师拉曼和他的兄弟姐妹们都相信，精力充沛地在自然的环境中散步，不管是在高高的山路上，还是在茂密的森林深处，这些都将有助于缓解疲劳，修复身体内部的细微差错，以及恢复人体活力。要是天气太差，没法散步，他们就会在小屋中的密室里锻炼。他们可能会忘记吃一顿饭，但是决不可能忘记每天的练习。</strong>” “他们的茅屋中有什么东西？跑步机吗？”我开玩笑说。<br>“当然不是。他们有时候练习瑜伽。有时候他们会做双手或者单手直立的俯卧撑。开始我还很好奇，后来我渐渐意识到他们做什么其实并不重要。他们虽然姿势不同，但目的却是一致的，那就是充分活动身体，让四周的新鲜空气在肺部畅通地流淌，也让血脉贯通起来。”<br>“呼吸新鲜空气会有什么用呢？”<br>“我要借用瑜伽师拉曼最爱说的一句话来回答你：<strong>“适当的呼吸就等于适当的生活。</strong>’”<br>“呼吸有这么重要吗？”我奇怪地问道。<br>“当我到那儿之后，智者很快就教会了我如何使自己获得两倍甚至三倍精力的捷径，我也因此学会了进行有效的呼吸方法。”<br>“可是难道我们不懂得呼吸吗？这连新生的婴儿都会呀！”<br>“不完全是这样，约翰。<strong>我们中的大部分人都只是知道怎么呼吸才可以活下去，却不知道怎样通过呼吸来让自己更有活力。这是完全不同的两个层面的问题，前一个是生存问题，后一个是生活问题。大部分人的呼吸都太浅了，这样我们就不能吸入足够的氧气，导致我们的身体不能处在最佳的状态。</strong>”<br>“听上去，正确的呼吸还包含着很多科学知识呢。”<br>“确实如此。那些智者是这样对待呼吸的：<strong>通过有效的呼吸吸入更多的氧气，释放体内储藏的精力，从而达到活力收放自如的自然状态。</strong>”<br>“好啊，那么我应该从哪里开始呢？”<br>“<strong>事实上非常简单。每天两到三次，花一二分钟来深呼吸，使空气能够深深地渗透到你身体内的每一个细胞。</strong>”<br>“<em>我怎么才知道自己的呼吸变得有效了？</em>”<br>“<strong>嗯，当你使用正确呼吸方法的时候，你的腹部会稍稍鼓出来一点。这个迹象说明你开始从腹部呼吸了，这就很好。现在试试看……嗯，挺不错。瑜伽师拉曼教我的一个方法是，把双手扣在肚子上感受起伏。如果我吸气的时候肚子鼓起来了，我的呼吸技巧就算是达标了。</strong>” </p>
<h3 id="生命滋养法"><a href="#生命滋养法" class="headerlink" title="生命滋养法"></a>生命滋养法</h3><p>那就是‘生命滋养法’。在我做律师的那些日子里，我每天的食谱都是固定的，主要是牛排、油炸食品还有其他形形色色的垃圾食品。虽然我总是在城里最好的餐馆吃饭，可还是感到身体里面塞满了垃圾。那时候我并不特别清楚，这就是让我感到不愉快的主要原因之一。<strong>”<br>“真的吗？”<br>“是的。一份糟糕的食谱对你的生命有着显著的影响。它抽干你的脑力和体力，它影响你的情绪，还会扰乱你的逻辑能力。瑜伽师拉曼是这样说的：“</strong>你在滋养身体的同时，就是在养育心智。<strong>’”<br>“那么我猜你改变了食谱喽？”<br>“</strong>我已经彻底改变了自己的餐饮习惯，比如我从来不喝有色素与人工添加剂的饮料，也不再光顾快餐食品店。不久之后，控制饮食的效果就出现了，我的感觉和相貌发生了令人惊异的变化。以前我总是以为，我之所以那么死气沉沉主要是因为工作中的压力和疲劳，而且上了年纪以后身体渐渐不中用了。到了喜马拉雅山上，我才发现我的昏睡懒散其实是因为自己给身体内注入的动力燃料实在是太低劣了。<strong>”<br>“那些智者靠吃什么东西来保持青春和愉快呢？”<br>“</strong>吃新鲜的食物。<strong>”他的回答很简明。<br>“啊？”<br>“</strong>答案就是新鲜的食物。它指的就是没有死去的东西。<strong>”<br>“说说呀，朱利安。哪些东西属于新鲜的食物？”我急躁地问他。<br>“</strong>说得简单点，所谓的新鲜食物就是在自然当中吐故纳新的食物，是通过太阳、空气、土壤和水之间的相互作用中而产生的。我要告诉你的是一种蔬菜食谱。只要你能保证在盘子里堆满蔬菜、水果和谷物，然后就可能长命百岁。<strong>”<br>“真的有可能吗？”<br>“生活在喜马拉雅山顶的大部分智者都已经有一百多岁了，而且看不出有任何衰老的迹象。就在上个星期，我在报纸上读到了一篇报道，大体说一群人生活在中国东海冲绳群岛中一个小岛上。研究者之所以关注这个小岛是因为被一个事实给震惊了：这个岛上聚居着世上最大的百岁老人群落。”<br>“这些研究者发现了什么长寿诀窍没有？”<br>“</strong>结果是，素食是他们长寿的主要秘诀。<strong>”<br>“但是这种食谱健康吗？你知道素食可不一定能够提供足够的气力。请注意，我可还是个忙忙碌碌的律师，朱利安。我总不至于为了长寿而饿昏在庭审现场吧。”<br>“不必担心，</strong>这是一个充分自然的、人性化设计的食谱。它会让你有生气，有活力，而且极其健康。智者已经依靠这个食谱生活了数千年。他们称之为‘悦性食物’，也可以叫作‘纯净饮食’。<strong>既然你最关心力量，那我想提醒你注意，地球上最强有力的动物，从大猩猩到大象，它们都是不折不扣的素食主义者。然而你知道吗？一头大猩猩的力量可比一个男人大30倍。”<br>“真的不可思议啊。谢谢你告诉我这则趣闻。”<br>“看，智者并不是走极端的人。</strong>相反我们现代人却是常常执迷不悟。智者所有的智慧都建立在一条古老的法则上，那就是‘生活适度，做事中庸。’因此，如果你喜欢吃肉，当然还可以继续吃，智者也不会阻拦你。只是你要明白一点，你是在吞下已经死去了的东西。如果可以，尽量少吃红肉，因为红肉很难消化。你的消化系统在整个身体里面是消耗能量最多的部分，非常有价值的精力就这样被肉类食品毫无必要地消耗掉了。你有没有这样的体验，当你中午吃了一份牛排大餐之后，你很快会觉得自己的嘴巴里充满了不洁的味道，不断地打饱嗝儿。接下来，你就会觉得昏昏欲睡，整个人好像梦游一样？<strong>”<br>“确实如此。”我承认。每次午饭前我会因为饥饿而头昏脑胀，而饱餐一顿后我又会因为吃得太饱而昏昏沉沉。就这样，每天上午的十一点到下午两点都是我工作效率最低的时候。<br>朱利安同情地看了看我，我想他一定联想到我在午饭后睡眼蒙眬的丑态。他接着说：“</strong>难道你没有发现我目前的变化吗？建议你给自己的能量标准做个对比，在吃完一份牛排和一盘色拉之后，你的感觉一样吗？如果你不希望一下子就变成一个地地道道的素食主义者，那么至少要在每顿饭里加一道色拉，用水果代替甜点。即便这一点微小的改变也会为你的生活质量带来巨大的改变。**</p>
<h3 id="扩展知识法"><a href="#扩展知识法" class="headerlink" title="扩展知识法"></a>扩展知识法</h3><p>第四招被称作‘扩展知识法’。<strong>它是一个</strong>关于终身学习，为了给自己和周围的人造福的理念。**”<br>“听起来好像那句老话‘知识就是力量’，是不是？”<br>“它的内涵更加丰富，约翰。知识不仅仅是潜在的力量。因为力量是显而易见的，而你必须进入实践的层面。大部分人在特定的情况下，或者在生活遇到困难时，都明白应该怎么去做。问题在于他们不是天天都这样，没有在使用知识和实现梦想方面持续地加以努力。扩展知识法的宗旨就是成为生活虔诚的学生。而更为主要的是，它要求你把教室里学到的知识顺利地应用到现实生活中去。</p>
<p>“瑜伽师拉曼和其他智者是怎样应用这个方法的？”<br>“在日常使用中，他们有很多辅助的方法可以和‘扩展知识法’配套使用。最重要的一个技巧也是最简单的。今天你就可以开始试一试。”<br>“不会花很多时间吧？”<br>朱利安颔首微笑。“我和你分享的这些策略、方法和小技巧都会使你变得比以前更加能干，更加高效。不要捡了芝麻，丢了西瓜。想一想那些说自己太忙，顾不得在电脑上备份文件的人吧。一旦他们的机器出了意外，几个月以来的重要工作都将毁于一旦，他们就会捶胸顿足，遗憾自己为什么没有每天花一点点时间去保存文件。你明白我的意思了吗？”<br>“就是说<strong>要先弄明白生命中的主次关系，不要本末倒置？</strong>”<br>“<strong>完全正确。努力使你的生活挣脱时间表的束缚。把精神集中到你的良知和内心告诉你要去做的事情上。当你开始探知自我，并且开始把自己的时间花在提高心智、身体和个性的品质上，你很快就会感到自己的体内仿佛存在着一个领航员似的，他会随时告诉你哪些事情值得去做，而且会带来最丰厚、最有价值的回报。你将不再会为钟表上的时间感到焦虑，而是开始尽情享受生命内在的律动。</strong>”<br>“啊，我明白了。那么接下来你要教给我的<strong>那个简单的辅助办法是什么？</strong>”<br>“<strong>定期读书。每天读书30分钟会给你带来意想不到的结果。但是我必须提醒你，不要碰到什么就读什么。你一定要仔细拣选才行，因为它们将要进入你丰饶的心智花园。它一定得是非常有营养的物质，否则将会适得其反。它们要帮助你改善自我，而且还要提升你的生命品质。</strong>” </p>
<p>“那些智者平常喜欢读什么书呢？”<br>“<strong>他们在醒来以后，就会花很多时间去阅读古人留下来的教诲。他们对这些哲学著作如饥似渴。迄今我还记得那些非常俊美的人们坐在小竹椅上阅读外形奇怪、装帧精美的书，脸上和唇边都洋溢着淡淡的微笑。正是在那里我真正意识到了书本的力量，知道了‘书本是智慧最好的朋友’这个道理。” </strong><br>“那么我应该开始阅读我能够找到的所有好书吗？”<br>“可以说是，但又不是。<br>”他这样模棱两可地回答我。“我从来都会支持你尽己所能地去读书。但是要记住，有些书只需要浅尝辄止，有些书却需要细细咀嚼，有一些需要辨证学习，而另一些则值得完全吸收。这让我想起另外一个问题。”<br>“你是不是饿了？冰箱里还有些酸奶。”<br>“不是，约翰，”朱利安笑了，“我只不过想要告诉你，<strong>一定要善于从伟大的书籍中获得最为精华的部分。你必须要好好地研究它，而不仅仅限于阅读。深入全面地研究它，就像你研读你的重要委托人给你的案子那样。切实地考虑它，和它相互切磋，成为伙伴。智者在广泛的阅读中，会把很多书读上10到15遍。在他们眼中，伟大的书籍就像是神赐的圣书。</strong>”<br>“哎哟！读书真的这么重要啊？”<br>“<strong>每天坚持读书30分钟，会给你的生活带来可喜的变化。因为你很快就会发现，有那么广博的知识宝库供你选择使用。你会变得谈吐不凡，思维敏捷，文思泉涌。你曾经遇到的每一个问题的答案都会历历在册，信手拈来。如果你想要成为一名更为出色的律师、父亲或者恋人，都会有相应的书籍知识帮你快速达到目的，避免走弯路。你在人生中犯下的所有错误都已经被前人们尝试过，因此你也将会很快找到改正的方案。你是不是真的以为你所面对的挑战都是独一无二的？</strong>”<br>“老实说，我从来没有这样想过，朱利安。但是我理解你所说的，而且我知道你是对的。”<br>“<strong>任何一个人遇到过的任何问题，在他的生命之前都已经被前人遭遇过了，而且不止一次，”朱利安断言道，“更重要的是，答案和解决办法都已经在书页上记下来了，就看你会不会发现它。养成正确阅读的习惯，学习前辈的珍贵经验，他们成功的策略会帮助你从容面对生命中遭遇的种种挑战。你会为发生在人生中的点滴进步而感到惊奇的。</strong>”<br>“什么样的书才是‘正确的好书’？”我追问着，很快就体会到朱利安的意见确实很不错。<br>“这个要留给你自己来判断，我的朋友。就我个人而言，自打我从东方回来以后，就把一天中最好的时光花在了阅读上。当然，每个人兴趣不同，我最感兴趣的是那些我所钦佩的男男女女的人物传记和大量的智慧之作。”<br>“你能不能为我这个还算得上勤奋工作的人列出一些有用的推荐篇目呢？”我一边说，一边难为情地笑了一下。<br>“没问题。<strong>比如你可以从伟大的本杰明・富兰克林的传记中获益颇多。我觉得你还可以从圣雄甘地的传记中发现很多成长的动力，那本书的名字叫作《甘地自传》。我还建议你读读赫尔曼・黑塞[7] 写的《悉达多》，还有马可・奥勒留[8] 写的实践性很强的书，以及塞涅卡[9] 的一些著作。你甚至还可以读一读拿破仑・希尔的《思考致富》。上个星期我认真地读了这本书，觉得真是回味深远。</strong>” </p>
<p>书只是帮助你发现早已存在于自身之内的东西。这是一种唤醒，一种提示。这就是启蒙，如一束光照亮你的人生。我在经过了那么多的旅行和探险之后，最终发现我其实是走完了一个循环，回到了我还是孩子时的出发点。但是现在，我非常了解自己，知道我是谁，我也知道自己最终会成为怎样的人。**”<br> “所以说‘知识扩展法’就是大量读书，探索外界的丰富知识？”<br> “你只说对了一部分。因为在眼下一天只读30分钟书，你的理解也仅此而已。随着你对书籍的爱好与日俱增，其他意想不到的东西自然也会到来。”朱利安的话里暗含着玄机。</p>
<h3 id="个人反思法"><a href="#个人反思法" class="headerlink" title="个人反思法"></a>个人反思法</h3><p>它的名字是‘个人反思法’。那些智者都坚信内在沉思的力量。通过一定时间的沉思来了解自我，就可能步入生命的另一个维度，这也许是你从来都不知道自己还具有的更高维度。</p>
<p>其实说到根本上，个人反思不过是一种思考的习惯。</p>
<p>对，是富兰克林。每天晚上在完成了一天的高效率工作之后，他一回到家里就会躲在一个安静的角落里，反思这一天的行为处世。他会反思他的全部行为，看其中哪些属于积极而富有建设性的，哪些属于消极而需要及时修正的。当他清楚地知道白天里犯下了什么错误时，他就会迅速采取措施进行改进，沿着自我控制的道路前进。等到以后再遇到类似的情况，他就会心知肚明，游刃有余。智者也是这样做的。每天晚上，他们都会躲进小棚屋里的清净角落，那里铺满了芳香的玫瑰花瓣，他们坐下来陷入深深的沉思。瑜伽师拉曼还会把他的一天经历写在日记里。</p>
<p>“他写下来的都是些什么事？”我好奇地问。<br> “<strong>首先他会列出当天所有做过的事情，从早晨的身体锻炼，到他和其他智者之间的交流，再到他到森林里去找木柴和新鲜食物的经历。很有趣的是，他还会写下来在这一天里曾经在头脑中出现过的各种念头。</strong>”<br> “这样做岂不是难了点儿？我根本记不起来5分钟以前自己曾经想过什么，更不要说12个小时以前的想法了。”<br> “如果你每天都坚持做同样的练习就不会觉得难了。任何一个人都可以获得在我身上发生的改变，任何人。真正的问题是，有太多的人都饱受令人讨厌的疾病的折磨，这种疾病叫‘借口’。”<br> “我想我可能也染上了这种疾病。”我完全明白我聪明的朋友在说什么。<br> “别再找借口了，只管去做就好了！”朱利安提高声音说道，他的语调中充满了坚定的力量。<br> “做什么？”<br> “<strong>花时间去认真思考，并在生活中养成定期进行自我反省的良好习惯。有时候瑜伽师拉曼会将笔记纸的一页从中对折一下，把当天所有做过的事情、想到过的念头都写在一栏里，然后在另外一栏里作出相应的评价。当他面对书面记录下的行为和想法时，他会扪心自问，它们在本质上究竟是不是积极的。如果是积极的，他就决定继续为此付出宝贵的精力，因为从长远来看，它们会给他带来巨大的收益。</strong>” </p>
<p>我认为现在你已经发现了‘个人反思法’的神奇力量。通过审视自己做过的事情，仔细反省自己是如何度过一天的。你要注意归纳自己在一天内一共出现了几种想法，这样一来你就给自己提供一个进步的标准。要在明天实现进步的唯一途径就是知道今天做了哪些错事，并且知道如何来加以改进。</p>
<p>只有人类才会走出自我的阴影，并且能够分析他所做的事情中哪些是正确的，哪些是错误的。一条狗做不到这一点，一只鸟也不会这么做，就连聪明的猴子也不可能。但是你可以。这就是‘自我反思法’的根本宗旨，在每天的生活和整个人生当中，辨明什么是正确的，什么是错误的，然后尽快着手完善自己。</p>
<h3 id="早早醒来法"><a href="#早早醒来法" class="headerlink" title="早早醒来法"></a>早早醒来法</h3><p>“<strong>我在遥远的喜马拉雅山上得到的最有用的一个建议就是，和太阳一起起床，然后成功地开始新的一天。我们大部分人的睡眠时间都比实际的需求要多得多。其实普通人睡六个小时就可以起床了——这已经足够他保持健康和思维的机敏了。睡眠无非一种习惯，像其他习惯一样，你可以训练自己达到你所希望的成果。试一试，能不能在这一个环节中睡得少一些。</strong>”<br> “可是，如果我起床太早了的话，我真的会感到精疲力竭。”我说。<br> “在刚开始的几天里，你可能会感到疲倦。我也曾有同感。你甚至有可能在练习早些起床的第一个星期里一直有这样的疲劳感。不过，请把这看成是为了得到长期的巨大收益而付出的短暂的、少量的痛苦。在你确立一个新习惯的时候当然会多多少少感到有些不舒服。这就像你穿上了一双新鞋子——刚开始穿上的时候觉得有点疼，很快就很惬意了。正像我此前告诉你的那样，痛苦往往是个人成长的前奏。别害怕起早。相反，接受它。”<br> “好吧，我喜欢这个训练自己早点起床的观念。可是先得让我问问你，<strong>‘早’起意味着几点钟起？</strong>”<br> “又是一个好问题。这跟时间没有关系。就像我到现在为止和你分享的各种方法一样，都是要你按照认为正确的标准去做。记住瑜伽师拉曼的警告：“凡事不可过分，处处都要适度。’”<br> “日出时起床，这听起来已经很过分啦。”<br> “实际上并不过分。几乎没有什么比一天当中新射出的第一缕阳光更加光辉灿烂的了。智者坚信，阳光是来自上苍的礼物。尽管他们都很小心，不过多地暴露在阳光下，但是他们会定期做日光浴，还经常在阳光明媚的清晨顽皮地舞蹈。我完全相信这是他们保持长寿的另一个秘诀。”<br> “你也做日光浴吗？”我问。<br> “当然做。阳光使我恢复活力。当我感到劳累时，阳光会让我高兴起来。在东方古老的文化里，太阳被认为与灵魂相连。人们崇拜太阳，因为太阳让庄稼和他们的精神一起丰收。阳光可以释放你的生命力，恢复情感和身体上的活力。它是一位令人心情愉快的医生，不过前提是你适当地接触它。唉，我又跑题了。我们讨论的是早点起床，每天坚持。”<br> “哈哈。我怎么才能把这个习惯纳入日常的生活？”<br> “<strong>这里有两个简便易行的小诀窍。首先，千万别忘了，重要的是睡眠的质量而非睡眠的数量。在不受干扰的情况下沉沉地睡上六个小时要比时常被打断的十个小时睡眠好得多。睡眠的目的在于让你的身体得到休息，这个自然的生理过程可以修复、重建你的身体，减少日常消耗带来的压力和挣扎，使你的身体恢复自然的状态。很多智者的习惯都基于这一原则。举个例子来看，瑜伽师拉曼在晚上八点以后就再也不吃东西了。他说消化活动及其附带的生理活动会降低他的睡眠质量。智者还有另一个习惯，睡觉之前他们会在轻柔的竖琴乐声中冥想。</strong>”<br> “这种行为的原因是什么？”<br> “让我来问问你，约翰。每天晚上睡觉之前你会做些什么？”<br> “我和詹妮一起看新闻节目，我知道这和大部分人做的事情一样。” “我就知道。”朱利安回答，眼睛中有奇异的闪光。<br> “我不明白。在睡觉以前看上一点新闻有什么错的？”<br> “<strong>你睡觉之前的10分钟，还有醒来之前的10分钟，都会在你的潜意识里留下长久的影响。在这两个时间段，你应该只向你的头脑输入最愉悦、最安静的想法。</strong>”<br> “瞧你说的，人的头脑听起来就跟电脑似的。”<br> “<strong>这么来看待头脑也不失为一种好办法——你输入的东西就是将要产出的东西。更加重要的事实是，程序员只有你一个人。通过决定让哪些念头进入头脑，你也就可以明确地知道哪些念头将会产生出来。所以在你去睡觉之前，不要看什么新闻，不要和任何人争吵，也不要在脑海中回顾一天的所作所为。放松，如果你喜欢的话，慢慢地喝一杯花茶，听一点轻柔的古典音乐，做好准备，让自己渐渐滑入甜美的熟睡中。</strong>”<br> “有道理。睡得越好，睡得越少。”<br> “确实如此。<strong>一定要记住古老的21天法则：如果你连续21天做一件事情，它就会确定成为你的习惯。所以，在你因为感到不舒服而放弃早起的行为前，你要坚持三个星期。</strong>到了那时，早起就成为了你生活的一部分。在很短的时期内，你就能够轻轻松松地在早晨五点半，甚至是五点钟起床，准备好领略新一天到来时的壮丽场景了。”<br>  “好吧，那么如果说，我现在每天都是五点半起床的话，我又该做些什么呢？”<br>  “<strong>从你问的问题就可以看出你确实是在思考，我的朋友。对此我很欣赏。起床之后，你可以做很多事情。要在头脑里面时刻记住的基本原则是，好好开始新的一天是非常重要的。就像我曾建议过的，在你醒来以后的十分钟内，最先进入到脑海里的念头和最先着手的行为，往往会在接下来的一天中产生非常明显的效果。</strong>”<br>  “此话当真？”<br>  “当然。<strong>去想那些积极的念头；对你所拥有的一切做感恩祈祷；感谢你要感谢的人；倾听一些伟大的音乐；看太阳升起。兴之所至的时候，你还可以去自然环境中散步。实际上，智者还常常让自己开怀大笑，不管是不是有高兴事，这不过是为了让快乐在清晨便开始流动。</strong>”<br>  “朱利安，我尽力使自己的头脑能够接受你的讲解——而且我想你也会承认，作为一个初学者我做得已经很不错了。可是，就算是对一群生活在喜马拉雅山高峰上的高僧来说，那样的事情听起来也真的太奇怪了。”<br>  “其实不足为奇。你猜一猜，一般来说，一个四岁的孩子一天要大笑几次？”<br>  “谁知道呢！”<br>  “我知道，一共三百次。嗨，你不要做出这么惊讶的表情。现在再猜猜看，在我们的社会中一个成年人在一天之内会大笑几次？”<br>  “五十次？”我猜测着。<br>  “勉勉强强十五次，”朱利安回答道，微笑中充满胜利感。“你明白我的意思了吧？<strong>大笑是灵魂的良药。如果你能对着镜子开怀大笑几分钟，即使你并不喜欢这样做，你也会忍不住感到很奇妙。威廉・詹姆斯说过：‘我们不是因为快乐才笑，而是因为笑才感到快乐。’所以，让你的一天从快乐开始。大笑，玩耍，为你拥有的一切感恩。由此，每一天都会变得极其有意义。</strong>”<br>  “那么你是如何积极地开始自己的一天呢？”<br>  “说实话，我已经养成了一套非常系统的晨练方式，包括所有的内容，从练习‘玫瑰之心’到喝几杯鲜榨水果汁。但是有一个方法我特别要和你一起分享。”<br>  “听起来很重要嘛。”<br>  “是很重要。<strong>你在刚醒来以后，就到你那个‘个人避难所’去，静下心来，集中精神，然后问自己这个问题：“如果今天就是生命里的最后一天，我将做些什么？’答案就在于准确理解这个问题的含义。在头脑里列出来所有你想做的事情，你想打电话的人们，以及你想享受的时刻。想象你自己正在兴致高昂地完成这些事情。想象自己对待家庭、朋友和完全陌生的人的样子。如果今天就是你活在这个星球上的最后一日，想象自己该怎样度过这珍贵的一天。正如我早先告诉你的，当你在度过每一天时都像对待生命的最后一天那样，你的生活将会焕发出奇异的色彩。</strong> </p>
<h3 id="音乐法"><a href="#音乐法" class="headerlink" title="音乐法"></a>音乐法</h3><p>智者很热爱他们的音乐。音乐就像太阳一样给予他们同样的精神鼓舞。音乐让他们开怀大笑，让他们闻之起舞，应和歌唱。它对你也会起到同样的作用。千万别忘了音乐的力量。每天在音乐上花一点时间，哪怕只是在你驱车上班的路上听几首轻音乐也好。当你觉得消沉或者疲倦，演奏一会儿音乐吧。这是我所知道的最有效的动力之一。</p>
<h3 id="口语练习法"><a href="#口语练习法" class="headerlink" title="口语练习法"></a>口语练习法</h3><p><strong>第八招的名字叫‘口语练习法’。智者有成套的‘真言’供他们在早、中、晚念诵。他们对我说这个练习非常有效果，可以帮助他们保持专注，变得更强壮和幸福。 </strong>”<br>  “‘真言’是什么？”我问。<br>  “<strong>真言就是一连串能够产生积极影响的话语。在梵语里面，‘man’的意思是心智，‘tra’的意思是解脱束缚。因此真言‘mantra’这个词语指的就是对心智有计划的解放。而且请你相信我，约翰，真言是达到这一目的的非常有效的方法。</strong>”<br>  “那么你在日常生活中也练习说真言吗？”<br>  “我当然也是这样。无论我走到什么地方，它们都是我最忠实的同伴。不管我是坐在长途巴士上，在走去图书馆的路上，还是穿过一个公园观察着周遭的世界，我总是通过诵读真言来肯定我生命中所有美好的东西。”<br>  “所以真言是口头的？” </p>
<p>  “<strong>也不一定非要说出来。写出来的形式也一样很有效。但是我发现，大声背诵真言会对我的精神起到奇妙的效果。当我觉得需要动力支持时，就会重复说‘我有创造力，有自制力，有精力’这句真言二百到三百次。如果要保持高度的自信，我就会重复说，‘我很强壮，很能干，很镇静。’我甚至还使用这些真言来保持我的青春和活力。</strong>”朱利安坦言道。<br>  “一句真言又怎么能够让你保持年轻呢？”<br>  “<strong>语言会长久地作用于心智。这是一种古老的心理暗示法，并且屡试不爽。无论是写下来还是说出来，它们都会产生强有力的影响。你对别人说什么很重要，但更重要的是你对自己说什么。</strong>”<br>  “自言自语吗？”<br>  “对呀，<strong>你每天怎样想的，你就是什么样的。你每天对自己说什么，就会变成什么样子。如果你说你又衰老、又劳累，这句话就会在你的外在世界中显形。如果你说自己很虚弱，缺乏热情，这也会成为你现实中的特点。但是，假如你说你很健康，很活跃，充满活力，那么你的生活将得到改变。想想那些身患绝症却依然乐观向上的人们吧，他们就是通过有效的心理暗示为自己争得了珍贵的生命时光。</strong>”<br>  朱利安略微休息了一下，然后接着说：“<strong>你看，你对自己说出的话语影响到你的自我形象的想象，而你的自我想象又将决定你会采取什么样的行动。举个例子说，如果你想象的自我形象是一个没有信心去做任何有价值的事情的人，你所能采取的就不过是与这个特点相似的行动。如果你想象自己是一个充满活力，无所畏惧的人，同样，你所有的行为都会和这一品质相适应。在某种程度上，你的自我形象想象就是对于自我的长久预言。</strong>”<br>  “怎么会是这样呢？”<br>  “<strong>如果你相信自己做不到什么事情，比如说，无法找到一个完美的伴侣或者无法过上没有压力的生活，你的信念就会影响你的自我想象。反过来，你的自我想象也会阻止你采取行动去找到一个完美的伴侣或是为自己创造出一种平静的生活。事实上，它会妨碍你在这个方向上作出的任何努力。</strong>”<br>  “为什么会这样呢？”<br>  “<strong>很简单。你的自我想象其实是某种心理控制。它绝不会允许你在与它不相一致的方式上行事。但是好在你可以改变自我想象，就像你改变人生中其他的方面一样。真言就是完成这一目标的有效方式。</strong>”<br>  “而且啊，当我改变内在世界的时候，也就改变了外在世界。”我发自内心地说。 </p>
<h3 id="个性调试法"><a href="#个性调试法" class="headerlink" title="个性调试法"></a>个性调试法</h3><p><strong>活力人生的第九招。这个方法是‘个性调试法’。它是我们刚才讨论的自我想象概念的分支。简而言之，这个方法是要求你每天循序渐进地塑造自己的性格。这一过程将影响到你对自我的看法和所采取的行动。你所进行的行为会集中起来，渐渐形成你自己的固定习惯，而你的习惯将会决定你的命运。瑜伽师拉曼对此说得很明了：‘你种下一粒思想，就收获一个行动；种下一个行动，就收获一种习惯；种下一种习惯，就收获一种性格；种下一种性格，就收获了整个命运。</strong>’”<br>  “我应该做些什么事情来塑造自己的性格呢？”<br>  “你可以做任何可以培养美德的事情。在你问我何谓‘美德’之前，先让我澄清一下这个概念。<strong>喜马拉雅山的智者相信，有德行的人生才是意义丰富的人生。所以他们用一系列的古老原则来支配自己的行动。</strong>”<br>  “但是我记得你曾经说过，<strong>他们是用自己的目标来支配人生？</strong>”<br>  “是的，基本上差不多，但是他们的生活愿望在某种意义上还与这些原则相协调，那是他们的祖先在几千年前就已经深深植入他们心灵的。”<br>  “那些原则是什么，朱利安？”我问。<br>  “<strong>简单地说就是：勤劳、慈爱、谦逊、耐心、诚实和勇敢。如果你的行动和这些原则完全相符，你就会感到内在深深的和谐与安宁。依照这种原则来生活无疑会将引领你走上精神世界的成功。这是因为你所做的事情都是正确的。你将按照和自然法则以及宇宙法则相一致的方式来行事。你开始吸收另一个维度上的精力，或者称之为更高的力量。这同时也意味着你的生活将从庸常进入超凡境界，开始体味人生存在的神圣感。这也是毕生启蒙的第一步。</strong>”<br>  “你有过这样的经验吗？”我问。<br>  “有过，而且我相信你也会有的。做正确的事情。依照和你的真实性格相匹配的方式来行动。正直地行事。接受内心的指引。如此一来，其他的事情也会自然而然地好起来。约翰，你永远都不会孤独。”朱利安回答。<br>  “你这话是什么意思？”<br>  “也许我下一次再解释给你听吧，眼下我们不能总是跑题。<strong>你得记住，必须每天做一些小事来培养自己的品格。正如爱默生说的那样：‘品格高于才智。一个伟大的灵魂不仅善于思考，更善于生活。’如果你按照我刚才提到的那些方法来做事，你就会塑造出高尚的品格。如果你不这样做，真正的幸福就会弃你远去。</strong>”</p>
<h3 id="化简法"><a href="#化简法" class="headerlink" title="化简法"></a>化简法</h3><p>这个方法要求你过一种简单的生活。就像瑜伽师拉曼所说的，‘一个人千万不要生活在肤浅事物中。集中精力于那些最重要的、有意义的事情。这样，你的生活将会清晰有条理，有价值而且格外安宁。这一点我可以向你保证。</p>
<p>怎样养成化简的习惯？<br>要学会做减法，我们的生活本来已经够复杂的了，不要总是给自己找不痛快。就像我吧，我不再穿昂贵的衣服，我戒掉了一天看六份报纸的瘾，我不再需要让自己随叫随到，我变成了一个素食主义者而且吃得比以前少。从根本上说，我削减了自己的需要。东方的智者曾经有过精辟的总结：‘有容乃大，无欲则刚’。这话多有用啊。你看，约翰，除非你削减自己的需要，否则你永远不会得到满足。你会一直像拉斯维加斯赌场中急红了眼的赌徒，守在轮盘赌转盘前面期待着‘再转一次’，不停地祷告，盼着你的幸运号码马上到来。你会一直想要得到比现在拥有的更多的东西。可事实怎么样，相信不用我再赘言了。</p>
<p>如果我想把‘化简法’纳入自己的生活，我应该做哪些事情？</p>
<p> “你能做的事情太多了。即使是小事情也能带来改变。”<br>  “比如说？”<br>  “<strong>电话响起的时候不要每次都慌慌张张地去接听，或许是人家打错了电话；不要在阅读垃圾信件上浪费时间，因为你看后即忘；不再每星期在外面吃三次饭，那样你会变得大腹便便；放弃你的高尔夫会员资格，花更多的时间和孩子们待在一起；一周之内有一天不看手表，你要学会告诉自己：“少了我，地球照样转动’；每过几天就去看一次日出，感受大自然的神奇；把你的手机卖掉，不要成为别人随叫随到的奴役……还要我继续说下去吗？</strong>”朱利安反问道。 </p>
<p>我向你担保，通过练习这些策略和方法，你会从那一刻起，在一个月之内看到显著的提高。你在生活中的各个方面都将会有更多精力，更少烦恼，更多创造力，更小压力。我前面也已经说过了，智者的方法不是速成型的，肯定没有驱虫药的功效那么神奇。它们都是古老的修行传统，为了你今后生活的宁静，你需要天天练习。如果你停下来一段时间，就会发现自己又逐渐回到旧日的道路上去了。</p>
<h2 id="精神"><a href="#精神" class="headerlink" title="精神"></a>精神</h2><p>我向你解释的那些秘诀会让你在生活中创造出所希望的一切。但是那些智者的哲学视野要远远高于我们所能看到的地方。到目前为止我教给你的都是非常实用的知识。但是你一定要明白，在我列出的种种原则之下，其实还涌动着许多潜在的精神力量。也就是东方哲人所说的那句‘言有尽而意无穷’。如果你不理解我所说的这些话，不要太担心了。只要你肯听进去，再好好地想上一会儿，之后就会慢慢地理解和接受了。<strong>”<br>  “学生做好准备的时候，老师就会出现，是吗？”<br>  “正是这样，”朱利安说，露出笑容，“你一直学得很快。”<br>  “好吧，</strong>让我们来听听精神的部分<strong>，”我充满活力地说，根本没有注意现在已经快早上五点半了。<br>  “</strong>想象一下，你现在正栖息于日月天空之下，生活在宇宙的所有奇妙之间。创造这些奇迹的智慧就与把你创造出来的那种力量完全相同。你身边的任何东西都是来自同一个地方，我们本是一体，万物皆为一体。”<br>  “我不确定自己是否明白你的意思。”<br>  “地球上每一种活着的生物，地球上每一件看似静止的事物其实都有自己的灵魂。所有的灵魂都汇成一个，那就是宇宙的灵魂。就像是一滴水融入大海，汇成海洋的波浪彭湃。同样，我们也能够从大海中感受到那一滴水的生命律动。你看，约翰，当你养护自己的心智和精神时，你的确也是在滋养宇宙的灵魂。而当你提高了自我，也就是在提高所有存在于你四周的生命。当你有勇气不断接近梦想的方向，你也就开始利用宇宙的力量。正如我此前已经告诉你的，生命回报给你所要求得到的任何东西。它一直在侧耳谛听。<strong>”<br>  “所以说自我控制和‘禅悟’都将通过帮助自己而对别人有所帮助？”<br>  “可以这样说。当你丰富自己的心智头脑，养护自己的身体以及滋养自己的精神时，你都会逐渐确切地理解我所说的这些。”<br>  “朱利安。我知道你讲得很好。但是自我控制对于一个体重97公斤重，在发展客户上花费的时间远远多于自我发展的时间的男人来说，无论如何都是过高的奢望啊。如果我失败了，会发生什么事？”<br>  “</strong>失败是不必费心去尝试的，没有什么大不了。横亘在人们和梦想之间的唯一事物就是对失败的恐惧，然而恐惧又是任何成功都不可缺少的。失败可以检验我们的毅力，让我们得到不断的成长。它给我们教训，并且引导我们走向启蒙的道路。东方的先哲曾经说过，每一支射中公牛眼睛的利箭，都是一百次失误的结果。这就是要求我们明白一个道理：从失去的机会中不断获益，不要害怕失败。失败是你的朋友。**”</p>
<p>“让我拥抱失败吗？”我半信半疑地问。<br>  “<strong>宇宙青睐勇敢者。一旦当你下定决心要把自己的人生提高到最高的层次上，你灵魂的力量就会指引你方向。瑜伽师拉曼相信，每一个人的命运在他出生的那一刻就已经铺展开了。这条道路将一直通向一个盛满瑰丽宝藏的奇妙所在。每个人都能够培养起走上这条道路的勇气，这是人的天赋。他给我讲过一个故事，在此我想转述给你听。</strong>”<br>  <strong>以前，在古老的印度，有一个邪恶的巨人拥有一座可以远眺大海的辉煌城堡。在巨人去打仗的很多年里，附近村子里的孩子们常常跑到巨人美丽的花园里，非常快乐地玩耍。有一天，巨人回来了，把所有的小孩子都赶出了他的花园。“谁也不许再来！”他一边高喊，一边怒气冲冲地把橡木大门“砰”的一声关上。后来他围着花园建起了一道高大的大理石墙，把孩子们都挡在花园外面。<br>  寒冷的冬天到来了，这在印度是再自然不过的，而那个巨人盼望着温暖早早回来。不久，春天造访了巨人城堡下方的村子，但是冬天的寒冷魔爪依旧拒绝离开他的花园。有一天，巨人闻到了春天的芬芳，感到了太阳穿过窗子照耀进来的温暖。“春天终于回来了！”他大声喊着，跑到他的花园里去了。可是巨人没有想到映入眼帘的是那样一幅场景。村里的孩子们不知用了什么方法终于翻进了城堡，正在花园里高兴地玩儿。正是由于他们的到来，花园从冰封的冻土变成了富饶的土地，盛开着玫瑰、水仙和紫兰花。<br>  所有的孩子都开心地哈哈大笑，除了一个孩子以外。在眼角的余光里，巨人瞥见一个很小的小孩，他比其他孩子个子小得多。他因为没有力气翻过墙头进花园去玩，眼泪从脸上流下来。巨人为那个孩子感到难过，而且在他的一生中，他第一次为自己的恶行感到悔恨。“我要帮助这个孩子。”他说，向他跑过去。当其他的孩子看见巨人出来时，他们都感到害怕得要命，跑出了花园。但是那个个头很小的孩子还站在那儿。“我要杀死巨人，”他结结巴巴地说，“我要保卫我们的游乐场。”<br>  巨人走近小孩子，他张开双臂。“我是你的朋友，”他说，“我来帮助你翻过墙头到花园里去。现在它是你的花园了。”这个小孩子，现在成了孩子群中的英雄。他感到很高兴，把自己一直戴在脖子上的金项链送给了巨人。“这是我的幸运护身符，”他说，“我希望你来拥有它。”<br>  从那一天起，孩子们一直在巨人美丽的花园里玩耍。但是那个最受巨人宠爱的勇敢小孩子却再也没有回来过。时间一天天过去，巨人生病了，越来越虚弱。孩子们还继续在花园里面玩儿，可是巨人再也没有力气和他们作伴了。在那些安静的日子里，巨人最想念的就是那个小孩子。<br>  一天，在特别寒冷的冬季里，巨人从他的窗子里向外看了一眼，看到一个堪称奇迹的景象：尽管大部分花园都被白雪覆盖，在花园的正中却站立着一株漂亮的玫瑰花树，上面开满颜色各异的鲜花。就在玫瑰花树的旁边，站着巨人最喜爱的那个小孩子。小孩子笑得非常甜美。巨人快乐得手舞足蹈，冲出去拥抱了孩子。“这么多年你去哪儿了，我的小伙伴？我一直都在想念你。”<br>  孩子的回答却意味深长：“很多年以前你把我托过了墙头，让我进入你漂亮的花园。现在，我来带你去我的花园。”那天晚些时候，当孩子们再来看望巨人时，他们发现他已经躺在地上去世了，而他的身上从头到脚覆盖着上千朵美丽的玫瑰花。<br>  “只管让自己勇敢起来，约翰，就像那个小小的孩子。站稳你的脚跟，追随自己的梦想，它们会引领你找到自己的命运。跟随你的命运，它将带你领略宇宙的奇妙，带你进入一个满是玫瑰的神秘花园。”<br>  当我抬头看向朱利安，打算告诉他这个故事对我的触动有多么深时，我看到了极其震惊的场面：这个曾经把一生中最好的时光都花在追名逐利上的坚如磐石的律师，在这一刻竟然泪流满面</strong>。 </p>
<h1 id="粉色带子，代表意志力"><a href="#粉色带子，代表意志力" class="headerlink" title="粉色带子，代表意志力"></a>粉色带子，代表意志力</h1><p>那条粉色的带子用来提醒你记起，在建构起一个更加丰富、幸福和开明的人生中自我控制和纪律所具有的作用。在我遇到的所有人当中，我的那些智者导师无疑是最健康、最安详、最有满足感的一群人。同时他们还是最有纪律性的人。智者教育我说，自律的美德就像那条遮在关键部位上的粉色带子。你有没有花时间研究过一条多股编织的粉色带子，约翰？<strong>”<br>“这个我似乎不太感兴趣。”我咧嘴一笑。<br>“好吧，</strong>有机会好好看上一看。你会发现上面连着很多细小的钢丝，彼此首尾相连。如果单独来看，每一根都很脆弱，不结实。但是一旦把它们合在一起，就要比单根线要结实得多，最后这股带子变得比钢绳铁索还坚韧。自我控制和意志力就与这个道理相类似。为了建起钢铁般的意志，最不可缺少的一个环节，就是坚持做微不足道的小事情，以此来培养自我约束的优良品质。持之以恒，一个小作为累积在另一些更小的作为之上，最终就能像核聚变一样，产生出充沛的内驱力。”<br>朱利安意味深长地看了看我，接着说：“也许有一句古老的非洲谚语最能说明这个道理：‘把蜘蛛网一股一股地连起来，就能捆住一头凶猛的狮子。’当你将自己的意志力释放出来，你就变成了自我世界的主人。当你不断练习古老的自我支配的技巧，就不再会有高得让你跨不过去的障碍，也不再会有难得让你无法克服的挑战，更不再会有紧张得让你无法平息的危机。自我约束会在人生最磕磕绊绊的时候向你提供心智中储备的无穷能力，保证你可以继续坚持下去，直到胜利。<strong>”<br>“</strong>我还必须告诉你一个事实，缺乏意志力将会导致各种不同的心理疾病。这是已经为医学界所证明了的。”朱利安突然又补充说。“如果你饱受意志力缺乏之苦，就要首先尽快改变这一现状。充沛的意志力和纪律性是坚强的性格和多彩人生的主要缔造者。在强大的意志力的支持下，你能够兑现你的诺言。你可以每天坚持在早晨五点钟起床，通过冥想来培养自己的心智。或是在寒冷冬季里的一天，尽管你很留恋被窝的温暖，但强大的意志力还是让你起床到树林中散步，借此滋养自己的精神。在受到别人无礼的指责时，强大的意志力让你保持冷静和沉默。面对突发事件，强大的意志力促使你能够连续克服难关，不断实现自己的梦想。简而言之，正是意志力源源不断地提供内在的激情与力量，让你信守对他人的承诺，而且更重要的是，信守对自己的承诺。</p>
<p>意志力是一种优秀的品质，人生将因此而变得热情似火，变得宁静而致远。</p>
<p>艰难时日里就是这段话帮助了我。我希望在你遇到苦难的时候，它也能让你的心灵得到慰藉。这段话说的是：<br>通过铁一般的纪律，你会铸造出勇敢而平和的性格；通过意志与美德的培养，你一定会达到人生最高的理想境界，你会生活在美好、快乐和生机盎然的天堂世界。如果没有这些，你就会像遗失了指南针的水手一样彷徨失路，最终与船只一起沉没。</p>
<p>你是说，只要进行了正确的训练和适当的准备，我就能达到像圣雄甘地那样高超的意志力水平？”<br>“为什么非要像别人呢，约翰？<strong>其实每个人都是不一样的。瑜伽师拉曼教给我最基本的原则是，真正开悟了的人们绝不以与别人相似为荣。他们更乐意成为新型自我的开创者。不要跟别人赛跑，你要和自己赛跑。”朱利安回答说</strong>。<br>“**当你有了自我控制的能力时，你就会下决心去做你一直想做的事情。对你来说，可能是去参加马拉松长跑训练，掌握橡皮艇冲浪的技巧，甚至是放弃法律职业而成为一位艺术家。无论你的梦想是物质上的富足还是精神上的丰富，我都不会对你指手画脚。我只是想要告诉你，如果你能开启沉睡着的意志力，一切尽在你的掌握之中。”<br>朱利安补充说：“在你的生活中，进行自我控制以及加强纪律性还会带给你巨大的自由感。单单这一点就足以引发巨大的变化。</p>
<p>“你的意思是？”<br>“<strong>大部分人都是自由的。他们可以去想去的地方，做他们喜欢做的事情。但是有更多的人仍旧是冲动的奴隶。他们消极被动，习惯于见招拆招，却并不具有前瞻性。打个比喻，这些人就像被浪花冲上海岸的泡沫，任凭海潮把它们推向任何方向。当他们正和家人在一起时，如果有同事打电话说有急事，他们就会立刻赶过去，从不停下来想想，到底哪件事情对他们的人生目标来说更重要。所以就我的观察经验来说，无论是在西方还是东方，这种人都拥有自由的权利，却没有享受到真正的自由。在他们身上缺乏一种至关紧要的元素：从看似紧急的情况中选择正确的事情的自由。</strong>” </p>
<p>“培养意志力能够给我带来更多的自由吗？”<br><strong>“自由好比一所齐整的房子，你一砖一瓦把它垒起来。你要放上去的第一块砖就是意志力。这个品质可以激励你在任何情况下去做正确的事情。它给你提供精力和勇气，让你过上所期望的生活，而不是成为生活的奴隶。</strong>”<br>朱利安还列出了培养意志力能带来的其他很多实际好处。<br>“信不信由你，<strong>培养你的意志力量可以让你消除忧虑的习惯，让你保持健康，给你带来比以往多得多的精力。要知道，约翰，自我控制实际上就是心智控制。意志是心理力量的统帅。如果你掌握了心智，也就掌握了你的人生。对心智的控制源于你能够控制每一个出现在你头脑中的想法。如果你能够把所有软弱的念头都清理出去，仅仅注意那些积极美好的念头，那么积极美好的行为也将相继而来。这样你的人生中也会很快变得积极而美好</strong>。</p>
<p>“这儿有一个例子。假设说你的个人发展目标之一是每天早晨六点半起床，然后围着你家后面的公园跑步。让我们假定现在正处于严寒当中，你的闹钟铃声把你从恬静的沉睡中唤醒。你的第一反应就是按下闹铃的按钮，然后接着呼呼大睡，心想明天再去真正实行你的锻炼计划。这种状况拖了好久好久，直到你觉得自己太老了，健身计划对你已经太不现实了，于是就放弃了你的计划。”<br>“你太了解我了。”我诚恳地说。<br>“现在让我们来考虑另一种情形。还是在严冬时节，早晨的时候突然铃声大作，你产生了继续待在床上的想法。为了不再成为习惯的奴隶，你开始用更加强大的意志力去战胜它们。你开始在头脑里想象，如果你的体形好到极致，那将是一种什么样子，会有什么感觉，会做什么事情。当你在办公室里信步走过的时候，你会听到同事们的大声恭维你匀称而良好的身材。你不断想象定期的锻炼计划能够让你达到的目标。你再也不会说出庭了一天之后就累得什么也不愿意做，最终只能在电视机前打发晚上的时间。你的生活中将充满了活力、热情和意义。”</p>
<p>“但是假如我这样做了，还是想回去睡觉，不出去锻炼呢？”<br>“最初的几天当然会有一点困难，你更容易回到旧习惯中去。但是瑜伽师拉曼特别坚信一条古老的法则：积极总是能战胜消极。所以，如果你能够继续向那些多年来渐渐蚕食掉你的软弱思想作斗争，最终这些思想会像自知不受欢迎的访客一样灰溜溜地不告而别。”<br>“你是想要告诉我思想也是一种实际存在的东西？”<br>“是的，而且它完全在你的控制之中。思考积极的想法和消极的念头一样容易，然而效果大相径庭。”<br>“<strong>那么为什么还有那么多人在忧虑，在关注我们这个世界上的负面信息？</strong>”<br>“<strong>因为他们还没有学会自我控制的技巧，不会限制思考的方向。在我曾经交谈过的人群当中，有很多人都根本没有想过，自己竟然还有力量去掌控生活中每天、每分、每秒出现的每一个想法。他们相信思想不过是偶然发生的，却根本没有认识到，如果你不花时间去控制自己的想法，它们反过来就会控制你。这是一场控制与反控制的战争，可能很漫长，甚至会终其一生。如果你能够把注意力集中在美好的事物上，借助真正的意志力拒绝那些负面思想出现，我向你保证，它们很快就会卷铺盖离开了。</strong>”<br>“所以，如果我想要拥有内在的力量，能够早些起床，少吃饭、多读书，不忧虑、更热情，我要做的就是将意志的力量全部发挥出来净化我的思想。”<br>“<strong>当你控制了你的思想，你就控制了自己的心智。当你控制了自己的心智，你就控制了自己的人生。一旦你能够完全控制自己生活，你就成为了自己命运的主人。</strong>” </p>
<h2 id="培养意志力的方案"><a href="#培养意志力的方案" class="headerlink" title="培养意志力的方案"></a>培养意志力的方案</h2><h3 id="重复一些简单的语句：真言-创造性想象"><a href="#重复一些简单的语句：真言-创造性想象" class="headerlink" title="重复一些简单的语句：真言/创造性想象"></a>重复一些简单的语句：真言/创造性想象</h3><p>尽管只有为数不多的喜马拉雅山上的智者知道这些真言，但是它们已经历经了五千余年时光的磨炼。瑜伽师拉曼告诉我，如果不断念诵它们，就可以在很短的时间内培养起自我控制能力和内在的意志力。记住，语言具有巨大的影响力和暗示效果，词语就是自身力量的文字体现。在你的头脑里装满充满希望的话语，你就会变得信心十足；在你的头脑里装上善良的话语；你就会变得善良而开朗；在你的头脑里装上勇敢的话语，你就会富有勇气。话语就是力量。<strong>”朱利安总结说。<br>“好吧，我洗耳恭听。”<br>“</strong>我建议你每天把这句真言至少重复三十遍：“我比外表看起来更强大，世界上所有的力量都在我的身体里。’它会在你的生活中带来持久的改变。要是想让这句话迅速起效，就把这句话和我前面告诉过你的创造性想象的练习结合起来。比如说，去找一个安静的地方。坐在那里闭上双眼，不要分散心神，保持身体静止不动，因为意志薄弱者最明显的一个特征就是身体闲不下来。然后大声重复这句真言，一遍又一遍地重复。在你做这些的时候，把自己看作是一个遵守纪律、意志坚定的人，能够完全控制自己的心智、身体和精神。在内心里想自己要像甘地和特蕾莎修女在面对艰难时刻的所作所为那样行事。随后产生的效果一定会让你大吃一惊的。”朱利安信誓旦旦地说**</p>
<h2 id="两个方法"><a href="#两个方法" class="headerlink" title="两个方法"></a>两个方法</h2><h3 id="试着去做你不喜欢做的事情"><a href="#试着去做你不喜欢做的事情" class="headerlink" title="试着去做你不喜欢做的事情"></a>试着去做你不喜欢做的事情</h3><p>第一件事就是试着去做那些你不喜欢做的事情。对你来说，这些事情可能很简单，比如早晨起来叠被子，步行上班而不是驾车去。通过养成尽力而为的习惯，你会很快改变顺从软弱和冲动的毛病。**”<br>“不用则废？”<br>“完全正确。为了塑造意志力和内在力量，你首先要使用它。你越是努力培养内在约束的胚芽，就会让它成熟得越快，让你更快地看到你所希望的结果。” </p>
<h3 id="沉默的誓约"><a href="#沉默的誓约" class="headerlink" title="沉默的誓约"></a>沉默的誓约</h3><p>实际上那种誓约就是这样的，约翰。那些推崇这一方法的西藏喇嘛相信，长时间的完全的噤声有助于提高一个人的内在自律性。<strong>”<br>“这是怎样做到的？”<br>“</strong>从原理上说，通过一天的沉默不语，你可以使你的意志完成你命令它做的事情。每当想要说话的念头出现，你就立刻抑制这个冲动，继续保持安静。你看，意志本身不会产生任何想法。它等待着接受你的引导，刺激它采取行动。你越能控制自己，意志的力量也就越强大。问题是大部分人根本就没有使用他们的意志力。<strong>”<br>“为什么会这样？”我问。<br>“</strong>也许是因为大部分人认为他们根本就没有意志力。他们为这种明显的软弱怨天尤人，却不从自己身上找原因。那些火暴脾气的人会对你说：‘我抑制不住呀，我的父亲也是这个样子。’那些过度焦虑的人会对你说：‘不是我的错，我的工作压力太大了。’那些整日酣睡的人会说：‘我能怎么样呢？我的身体需要每晚十个小时的睡眠。’这些缺乏自我负责能力的人从不知道，在我们每个人的体内都沉睡着不可思议的潜能，期待着受到鼓舞，然后转化为具体的行动。当你渐渐了解古老的自然法则，知道它们支配着宇宙的运转以及所有生活在其中的生命，你就会明白成为你想成为的人是你天赋的权利，你有能力改变你所处的环境。同样，你有能力摆脱过去时光的束缚，让自己得到前所未有的自由。为了达到这一目的，你必须成为意志的主人。</p>
<h1 id="金秒表，代表时间"><a href="#金秒表，代表时间" class="headerlink" title="金秒表，代表时间"></a>金秒表，代表时间</h1><p>原来是一个缩微型的沙漏，用褐色的玻璃和一小块檀木底座制成。看到我略带惊讶的表情，迪维笑了笑，温和地告诉我，每一个智者在孩提时期都收到过一件同样的器具。‘尽管我们身无长物，过着纯粹、朴素的生活，但是我们尊崇时间，并且注意到它在一刻不停地流逝。这只小小的沙漏是对我们每个生命一刻不停走向死亡的提醒，提醒我们在向目标接近的过程中，过一种充实的生活和有所创造的日子是多么重要。因为，正如人不可能同时踏入第二条河流之中，人也不可能返回来，重新开始同一次生命的历程。’<strong>”<br>“那么，这些生活在喜马拉雅山上的高僧也重视时间吗？”<br>“他们中的每一个人都深知时间的重要性。</strong>他们每个人都培养起了我所说的‘时间意识’。你瞧我们已经明白地意识到，时间就像沙粒一样从我们的指缝中毫不留情地漏下去，不再复还。那些早年就能够明智地利用时间的人会收获一个丰富的、多产的、心满意足的人生。而与此相反，那些从来没有感受到‘掌握时间就是掌握生命’这一原则的人，永远也不会发现他们本性中其实曾经拥有着巨大的潜能。时间是最伟大的神，也是最公平的分配者。无论我们是特权者还是贫苦阶层，无论是生活在得克萨斯还是生活在东京，我们都被分配到一天二十四小时的时间，谁也不多一秒钟，谁也不少一秒钟。而最终真正能把创建了杰出人生的大人物和随波逐流的庸才区分开的，恰恰是他们对时间的不同使用方式，简而言之，就是不同的时间观念。<strong>”<br>“但是我曾经听我父亲说过，正是最忙碌的人才最有空闲。你对此怎么评价？”<br>“我赞同。忙碌的、能干的人总是能够高效地使用他们的时间——他们必须要生存下去。但是，成为一名最优异的时间安排者，却并不意味着必须把自己变成一个彻头彻尾的工作狂。相反，有效的时间控制能够让你有更多的空闲去做自己喜欢的，真正有意义的事情。控制好时间才能控制好人生，所以要好好守护时间。记住，这是不可再生的资源。”<br>“那我现在就给我的表上好发条。”我们一起笑了起来。<br>“让我再给你举一个例子吧，”朱利安提出建议，“</strong>让我们假设这是星期一的早晨，你的时间表上排满了约见、会议和庭审出席的日程。往常，你会在早晨六点半就起床，一口吞下一杯速溶咖啡，飞奔着赶去工作，然后昏天黑地地度过了非常紧迫的一天。好，接下来让我们假设有一次，你在星期天的晚上抽出了十五分钟的时间来计划自己的安排。或者说为了更加高效，让我们假设你在平静的周日上午抽出了一个小时来安排整个一周的生活。在你的每日计划表中，你标出什么时候会见客户，什么时候你要做法律研究，还有什么时候你要回一些重要的电话。最重要的是，在一个星期之内，你把在个人、社会和精神方面的发展目标也都列入了你的记事本。这个简单的举动是保持生活节奏平衡的奥秘。通过在每天的日程表上锁定生活中所有最至关重要的方面，你可以确保这一个星期的生活过得充实又有条不紊。<strong>”<br>“你是不是建议我从每天繁忙的工作中抽出一点时间来休息，然后去公园里散步或者躲到一个地方沉思冥想？”<br>“是的。你为什么非要那么严格地遵守惯例呢？你为什么一定要像其他人一样用同样的方式行事呢？</strong>走你自己的路好了，不要在乎别人怎么看，关键是要让自己觉得舒服自然。你为什么不提前一个小时开始工作，这样就可以有足够的闲暇在中午的时候放下手头的工作，到办公室附近的美丽公园里平心静气地散步。还有，为什么不在一周刚刚开始的时候就向工作里投入更多的时间与精力，这样就可以在周五下班之前早早收尾，然后快快乐乐地带上孩子去动物园玩一会儿。还有，为什么不在一个星期内抽出两天的时间在家里工作，这样就可以更多地照顾家庭。我说的所有这些都是为了让你更有创造性地作出一周的计划，合理地安排时间，当然并不是非如此不可。一定要把时间列在你首要关注的核心位置上，它会让你明白，人生中最有意义的事情决不应该为了最不重要的事情而作出无谓的牺牲。**” </p>
<p>忙碌并不是借口。真正的问题是，你要随时问自己，你究竟在忙些什么？我从那些年老的智者那里学会了一条伟大的法则：你在一生中获得的80％的成果，常常来自于你仅仅花了20％的时间来完成的事情。瑜伽师拉曼把它叫作‘古老的二八法则’。</p>
<p>你的意思是指，那些‘高效能’的时间就是指我花在提高自己法律知识上的时间，和我的客户一起丰富人际关系的时间，还有为了成为更能干的律师而投入的时间？”<br>“是的，还有你为了培养亲情而和詹妮以及孩子们一起度过的那些时间。” 朱利安的回答相当肯定，然后他又做了一个补充：“还有花在自然中的时间，这是你对自己有幸拥有的一切而表示感恩的时间，也是用来更新你的心智、身体和精神空间的时间。以上这些都是‘高效能’的行为，帮助你得以从容规划出一个值得度过的人生。当然，有一些无效的时间付出是你没有办法避免的。我的意思是说，设法将自己的时间尽量多地投入在这些有意义的行为上。古希腊的哲人早就说过：‘已经得到启蒙的人最先获得生命的动力。’这就是控制时间的秘诀。</p>
<p>那么就尽量学着去简化你的生活吧，”朱利安同情地建议我，“把减法应用在生活的每个方面。这样做以后，你就可以有时间去欣赏美好的、奇妙的事物。最难过的事情是我们任何一个人都不能为了领略到更多的美好而把自己的生命向后推延。我常常会有一种时不我待的悲伤。然而，有太多的人梦想在遥远的将来能看到神奇的玫瑰，却不去看一眼长在自家后院里的花朵。这真是一个莫大的悲剧。</p>
<h2 id="把时间花在精肉部位"><a href="#把时间花在精肉部位" class="headerlink" title="把时间花在精肉部位"></a>把时间花在精肉部位</h2><p>生活就像一长条熏猪肉，”我插话说，“为了有效掌握你的时间，就必须把肥的、瘦的细细地区分开来。” </p>
<p>“说得好极了，约翰，你真讲到点子上了。尽管我的素食主义立场告诉我不应该选取这样一个禁忌性的话题，不过说老实话，我还是很喜欢这个比喻。<strong>尽管有些粗俗，但你的确一语道破了机关。当你把时间和珍贵的心智精力投入到精肉部位以后，就没有时间在肥肉问题上浪费那些无谓的时间了。这就是你的生活从平庸变为非凡的关键。</strong></p>
<h2 id="要学会说‘不’"><a href="#要学会说‘不’" class="headerlink" title="要学会说‘不’"></a>要学会说‘不’</h2><p>你的话让我想到另外一个问题。别让他人窃取你的时间，要警惕无处不在的时间窃贼。<strong>在你哄孩子睡觉，或者刚刚在心爱的椅子上坐下开始读一本你早已如雷贯耳的惊悚类小说时，总是有些人会在这个时候打来电话，然后天南海北地和你胡侃一通，然而他们不知所云的所谓高见早已将你的兴致破坏得面目全非。他们这类人专门会在某个特定时刻敲开你的办公室，然后赖在那里高谈阔论。而那时你好不容易才从疯狂忙碌的一天中抽出几分钟来，想一个人静静地待一会儿，喘上一口气，清理一下思路。这些情形听起来还熟悉吗？”<br>“太常见了，朱利安，你说的一点也不错。我相信，以前你受到的骚扰比我更甚，因为你比我更有名气。不过，这些人似乎总是很难拒绝的，我感觉如果直接请他们离开或者紧闭房门是不礼貌的。”我向朱利安说出自己的心事。<br>“</strong>你必须学会不留情面，才能真正履行自己的时间规划。要学会说‘不’，要有勇气对生活中的琐事断然说‘不’，只有这样，你才会有力量对那些重要的大事说‘好吧’。当你需要花费几个小时来专攻一个大案件的时候，当然要关紧办公室的门，连秘书都是非请莫入。记着我告诉你的话，不要每次电话一响你就去接听。这要看你是否方便，而不是看其他人的方便。要将主动权牢牢掌握在自己的手中。很讽刺的是，当他们发现你是一个惜时如金的人时，不但不会非议你的‘无礼’，相反会对你更加尊敬。他们会觉得你的时间很宝贵，因此就会重视你的时间安排，也不会无端地打扰你，从而还你一份清静。**” </p>
<h2 id="拖延时间又该怎么解决？"><a href="#拖延时间又该怎么解决？" class="headerlink" title="拖延时间又该怎么解决？"></a>拖延时间又该怎么解决？</h2><p>我总是把不喜欢做的事情不断地、不断地向后推延，要到非做不可的地步才怏怏地动手。可是另一方面我又把大量的时间花在浏览垃圾信件、翻阅成堆的过期法律杂志上。也许我这样做只是为了消磨时间？”<br>“消磨时间只是一种说法。实际上，<strong>人的本性是趋利避害的。你不喜欢做一些事情，因此你的天性就会传达一种负面的情绪。但你同时又知道，这些事情如果不及时处理，那结果就会更糟糕，这个时候现实理性又会逼迫你及早动手。于是痛苦就产生了。但是就像我早先说过的，这个世界上最能干高产的人具有做好任何事情的习惯，哪怕这些事情可能是他们不喜欢做的，而不能干的人却养成了不做事的习惯。</strong>”<br>我不再答话，开始深刻反思刚才听到的话。<strong>也许拖延并不是我个人的问题，或许只是因为我的生活变得太复杂了，而朱利安一下子就抓住了我的关键。 </strong></p>
<p>“<strong>瑜伽师拉曼告诉我说，那些掌握了时间的人生活会更加简单。匆忙、狂热的节奏并不是人类本性的趋向。他坚信并一直向我重申，只有那些做事高效并为自己设有明确目标的人才能得到永恒的幸福。这就是我所学到的智慧中最令人着迷的地方。它使我的工作优质而高产，同时又能够完全满足精神上的渴望。在某些时候，工作反倒成为了游戏。</strong>” </p>
<h2 id="打一个小盹儿"><a href="#打一个小盹儿" class="headerlink" title="打一个小盹儿"></a>打一个小盹儿</h2><p>我喜欢在下午的时候打一个小盹儿。我感到这能使我保持活力充沛，更新精力，有蓬勃的朝气。我想可以这么说，我需要美容觉。</p>
<h2 id="临终心态"><a href="#临终心态" class="headerlink" title="临终心态"></a>临终心态</h2><p>迪维在送给我这个小沙漏时还给了我几条忠告，我永远也不会忘记。”<br>“她说了什么？”<br>“<strong>她告诉我，种树的最佳时间是四十年前，其次就是今天。不要浪费生命里的任何一分钟。要有一种临终心态。</strong>”<br>“你再说一遍？”我问他，朱利安采用的生动词语使我惊呆了。<br>“什么叫临终心态？”<br>“<strong>这是东方哲学中的一种生命观，也可以称其为‘向死而生’。这是你看待人生的新角度。它会提醒你，也许今天就是生命的最后一日，所以好好享用吧。</strong>”<br>“哈，如果你想知道我的真实感觉，朱利安，那我就老老实实地告诉你，这个话题我觉得很可怕啊，它让我想到了死亡。”<br>“*<em>确实如此，这就是生命的哲理。当你抱着这种临终心态，你会把生命中的每一天都当成最后一天。想象一下，每天早晨醒来以后，问自己一个简单的问题：“如果今天是我生命的最后一日，我将会做些什么？’接下来，考虑你将如何对待自己的家庭、同事，乃至你根本不认识的人们。想一想你将多么能干，多么振奋，在你手中，每一时刻的价值都实现了最大化。单单是这个临终问题就拥有改变人生的力量。它会让你每天都活力充沛，在做每件事时都带着丰富的热情和开朗的精神。你会开始注意那些一度被你不断拖延的、意义深远的事情，而不会在那些把你拖入危机和深渊之中的琐屑小事上无谓地浪费时间。”<br>朱利安继续说：“鞭策自己去做更多的事，体验到更多的新鲜事物，促使你把精力用在扩展自己的梦想上。对，扩展你的梦想。不要安于碌碌无为的人生。既然你在心智的源泉中拥有如此无限的潜力，就要敢于让‘伟大’这个词和自己的生命联系起来。这是你的天赋权利。</em></p>
<h2 id="表现得好像你不可能失败"><a href="#表现得好像你不可能失败" class="headerlink" title="表现得好像你不可能失败"></a>表现得好像你不可能失败</h2><p>有一个简单的方法，可以为很多人消除意志消沉的苦恼，这种苦恼的确会让人感到非常难受<strong>。”<br>“我的杯子正空着呢。”我虚心地说。<br>“</strong>表现得好像你不可能失败，这样你的成功就有保证了。把所有觉得不能达到目标的想法都从头脑中清除出去，无论是物质方面的，还是精神方面的。勇敢点，不要给自己的想象设限。不要成为过去记忆的奴隶，而是要做未来的设计师。从此，你就不再是从前的自己了。</p>
<h2 id="奉献是人生的终极目标"><a href="#奉献是人生的终极目标" class="headerlink" title="奉献是人生的终极目标"></a>奉献是人生的终极目标</h2><p>在印度有一句古老的谚语：‘我们不是有着精神体验的生命存在，而是有着生命经验的精神存在。’通过长时间的修行和游历，我想现在可以说，我真正理解了自己在宇宙中的角色。我终于在自我的镜像之中看到了我是谁。我不再处于世界当中，世界在我的心中。那种体验是什么样的呢？我也描绘不出来。这样吧，我给你诵念东方哲人的两句诗：君掌盛无边，刹那含永劫。<strong>”<br>“我觉得我必须好好考虑一会儿你刚才说的那句话，尤其是最后那两句诗。你知道，我在大学里最害怕文学与语法修辞类的考试。”我老老实实地说，因为我真的不太理解朱利安说的话。<br>“当然。我理解，我的朋友，总有一天你会理解我所说的一切。如果你能够按照我告诉你的方法去做，认真练习我向你提供的诸多技巧，你就一定会在启蒙的道路上不断前进。你将慢慢掌握支配自我的技巧，而且你也将发现自己生命的意义到底是什么：那不过是永恒图景上的一点微光。而且你也将逐渐明白你究竟是谁，知道人生中的终极目标是什么。”<br>“</strong>那目标是什么呢？”我越来越有好奇心了。<br>“当然是奉献。无论你的房子有多么大，或者你开的汽车有多么炫目，但是你在生命结束的时候都不能将它们带入坟墓，唯一相伴的只有自己的良心。所以，你要时刻侧耳倾听自己良心的声音，让良知引导你。它知道什么是对的，它会告诉你，你的使命就是无私地帮助他人。这就是我的人生漫游经历带给我的最大的收获。眼下，我有非常多的人要去会面，为他们服务、治疗。我的使命就是把智者的古老智慧传播给所有需要学习它的人们。这就是我的目的。**” </p>
<h1 id="玫瑰花，代表无私地帮助别人"><a href="#玫瑰花，代表无私地帮助别人" class="headerlink" title="玫瑰花，代表无私地帮助别人"></a>玫瑰花，代表无私地帮助别人</h1><p>我和你分享的品质中最不可缺少的一条，约翰，就是这个：无论你取得怎样的成就，无论你拥有了多少套夏季别墅，无论你家的车道上泊着几辆高档小汽车，你的人生质量还是要归结到你所作出的贡献的质量上来。<strong>”<br>“这是不是和瑜伽师拉曼的寓言里那些鲜艳的黄玫瑰多少有点关系？”<br>“当然有关系。</strong>这些花会提醒你想起一句古老的中国谚语：送人玫瑰，手留余香。这句谚语的意思很清楚——当你致力于提高别人的生活时，在这个过程中你也间接地提高了自己的人生品质。如果你每天都有意地随时随地做出一些善举，你自己的人生也将因此而变得更加丰富，更加有意义。为了培养日常生活中的神圣感和尊严感，从现在开始就用各种方式帮助他人吧。<strong>”<br>“你是不是在建议我多去参加一些志愿者活动？”<br>“嗯，</strong>应该说那是一个良好的开端。但是我所说的比参加志愿者活动这个具体的事件具有更多的哲学性。我是在建议你，你要对自己在这个星球上要扮演的角色采取一种新的理解‘范式’。<strong>”<br>“你又把我搞糊涂了。拜托你把‘范式’解释得清楚一点，我实在不熟悉这个词。”我请求道。<br>“</strong>简单来说，范式就是人们通常看待生活境况和生命过程的一种方式。有些悲观主义的人把人生看成一只半空的杯子，而乐观主义者则视之为半满的杯子。你看，‘半空’与‘半满’，对于同一种存在的境况竟然有不同的解释，这就是因为观察者采用的范式不一样。范式从根本上说就是一面透镜，你要通过它来观察人生历程中各种事件，无论是对外在世界还是内在世界。<strong>”<br>“因此当你建议我采用一种新的范式来看我的人生意义，是不是说我应该换一种眼光？”<br>“</strong>在一定程度上是这样的。为了显著提高你的生活品质，你必须针对自己为什么会在地球的这一处地方生活而不是那一处地方生活找出一个原因。你必须认识到，正如你两手空空来到这个世上一样，你注定是要两手空空地离开的。在这种情况下，只有一个真正的原因说明你身在此地的存在价值。<strong>”<br>“那会是什么？”<br>“</strong>把自己无私地奉献给他人，通过有意义的工作方式来作出应有的贡献。<strong>”朱利安回答说。<br>“我并不是说你不能享受你的生活，或者说你必须放弃自己的法律事业，然后有意让自己的生活变得穷困潦倒，好像只有这样才能全身心地投入到无私服务社会的行动中去——虽然我最近常常见到一大批散尽家财、投身慈善事业的人，而且看上去他们个个都心满意足——你要明白，我们的世界目前正处于大变革当中。”<br>“大变革？”我有些迷惑不解了。<br>“</strong>是的，大变革。对比一下过去30年和今天的生活，你就会发现人们对于意义与价值的理解发生了翻天覆地的变化，人们开始用钱换取人生意义。比如过去的律师只会按照委托人钱包的尺寸来做出是与否的判断，而现在则不同了，真正的律师会按照人们对他人的责任大小和爱心的大小来作出自己的判断。教师们辞去稳定又保险的大学工作，为生活在城乡结合部的贫困孩子无偿提供义务素质教育。在这个大变革的时代里，有良知的人们已经听到了呼唤价值改变的铃声，人们已经重新认识到自己生存的目的。这一目的无法用金钱和社会地位来衡量，而且他们已经得到了帮助自己去实现这个目的的特殊天赋。<strong>”<br>“究竟是什么特殊天赋？”<br>“</strong>确切地说，就是我花了整整一个晚上来告诉你的那些因素：丰富的心智，无穷的精力，无限的创造力，坚强的意志力和内心的安宁。而现在你要做的就是勇敢地开启这些宝藏，在日常生活为了公众的利益而使用它们**。</p>
<h2 id="摆脱自我的枷锁"><a href="#摆脱自我的枷锁" class="headerlink" title="摆脱自我的枷锁"></a>摆脱自我的枷锁</h2><p>那么<strong>怎样才可以开始做好事呢？</strong>”<br>“<strong>做好事不分时间先后、事情大小，你可以随时随地将自己的爱心传递给别人。再稍微抽象一些，那我的回答也很简单，就是把‘做好事’这种理念放在改变自己人生观、世界观的首要位置上，这样你就可以不再把自己看成是一个简单的个体，而会开始把自己看作是集体洪流中生动鲜活的一分子。</strong>”<br>“那么我是不是得变得再善良点儿，再温柔点儿？”<br>“要知道，你能做的最崇高的事情就是给予。”朱利安双手伸向空中。<br>“<strong>东方的智者将这个过程叫作‘摆脱自我的枷锁’，就是要你丢掉自我意识，开始关注更高的目标。也许这在某种程度上意味着你要向周围的人付出更多的时间和精力，尽管它们是你最有价值的两种资源。</strong>”<br>“资源？”我有些不解地问。<br>“对，是资源，”朱利安再次露出耐心的微笑，“如果按照最高标准来要求的话，可能是你抽出一年当中休假的时间，毫无报偿地为街区里的穷人做义工；如果按照最低标准来要求的话，可能是在交通极端堵塞的时刻，不再骂骂咧咧，不再抢着见缝插针，而是摆一摆手，让车流中别的车子先开走。”<br>“哦，听起来像个交通警察在给我上课，朱利安。”我想起下班路上一到塞车时候就灌满满街道的喇叭疯响，不由得有些烦躁。<br>“哈，朋友，安静点。<strong>听起来是有些老生常谈，但是在我所有领会到的道理中有一条非常重要——只有当你开始努力让世界变得更加美好，你的生活才会因此向更好的方向上推进。我崇敬的智者瑜伽师拉曼说过：在我们出生的时候，世界一片欢腾而我们哇哇大哭；如果我们一生的时间都在帮助别人，在为世界变得更美好的工作中度过了一生，那么等到我们死去的时候，世界在哭泣，而我们却很欢喜。</strong>” </p>
<h2 id="每天做好事"><a href="#每天做好事" class="headerlink" title="每天做好事"></a>每天做好事</h2><p>他们不过是需要有一点良知的火花来点亮同情的蜡烛。丰富的同情心和日常的善行会使你的人生更加丰富。每天早上在鸟鸣中醒来时，先别忙着起床，躺在温暖的枕头上抽出一点时间来考虑一下，在这即将开始的一天当中，你将为别人做哪些好事。你可以赞美那些对自己失去了信心的人，赞美那些最不指望得到赞美的人，给陷入困境的朋友送去温暖，还可以向家里的亲人们表示自己的感激和爱意。所有这些加起来，不就构成了更加美好的生活吗？而说到了友谊，你一定要不断维护它。一个拥有三个铁哥们儿的人其实是非常富有的。</p>
<p>我得承认，我的内心已经完全被朱利安的话征服了，不过我还是故作轻松地和他打趣：“在中国话里这就叫作‘一个好汉三个帮’对吗？”<br>朱利安对我竟然知道一句中国的谚语表示惊奇，不过他还是点点头赞许了我。“是啊，朋友给生活中增添了欢乐、兴趣和美丽。没有什么比和一个老朋友在一起开怀大笑更能让人恢复青春活力了。当你在工作上有了点成就，就开始狂妄自大，太拿自己当回事的时候，朋友的良言会帮助你保持谦卑。当生活给你带来了小小的挫折，你以为世界末日就要到来时，好朋友会一如既往地守在那里给你帮助。就以我为例吧，当我还是一名忙忙碌碌的律师的时候，我几乎没有时间交朋友，当然那些生意上的伙伴不算。在经过了长期与世隔绝的生活之后，在这个世俗的社会里，我是彻彻底底的孤家寡人了——除了你以外，约翰。我找不到一个人来陪伴自己去森林里远足，因为他们每个人都舒舒服服地待在温柔醉人的睡眠安乐窝里。当我读完了一本非常精彩的、深深地打动了我的书以后，却找不到人可以与我一起分享，我甚至连一个可以一起争辩讨论的朋友都没有。当金秋的阳光温暖了我的心扉，让我满怀欣喜的时候，我找不到一个值得信任的朋友可以敞开灵魂去倾诉。”<br>朱利安很快控制住了自己的情绪，也许他很快便想起了住在喜马拉雅山顶的那些智者。他们不仅是他的老师，也是他的朋友，甚至从某种意义上说已经成为他的家人了。<br>“不过，我没有时间让自己深陷于遗憾情绪的负面影响。<strong>我的智者导师们一直在教育我说：“对于开悟的人来说，每个黎明都将是崭新的一天。</strong>’” </p>
<h1 id="钻石，代表活在当下"><a href="#钻石，代表活在当下" class="headerlink" title="钻石，代表活在当下"></a>钻石，代表活在当下</h1><p>我基本上同意你的观点。我们确实应当对那些能够激发兴趣的目标表示出孜孜以求的积极态度，因为这是确保个人成就感的根源。但是还不止与此，你要记住，幸福是一场旅行，不是目的地。因此，你要时刻提醒自己，要为了今天的生活质量而活着——再也不会有另外一天会和今天一样了。”朱利安说，双手安详地交叠在一起。 **<br> “在瑜伽师拉曼的寓言里，这个道理的象征物就是那条铺满钻石的小路吧？”我问他。 </p>
<p> “是的，”朱利安的回答简洁而明快，“<strong>那位高大的相扑选手走在钻石小路上，最终获得永恒的满足感和欢乐。就像他一样，只要你明白你当前所走的道路也铺满了钻石和其他诸多无价珍宝，那么你也能够拥有你想要获得的生活。不要再把时间过多地花在纵情享乐之中，因为人生更多地是由那些微小的快乐组成。尽管你常常忽视它们的存在，但正是它们在浸润着你的内心世界，让你变得善良而乐观，无私而勇敢。我的朋友，好好地享受围绕在你身边的美丽和圣洁吧，这些神奇之物全靠你自己去发现。</strong>”<br> “你的意思是不是说我应该先停下来，不再给未来的人生设置远大目标，而是要把注意力转移到当前的生活中来？”<br> “当然不是这个意思，”朱利安斩钉截铁地回答，“<strong>正如我在前面和你说过的那样，面向未来的目标和梦想非常重要，这在每一个真正成功的人生当中都是不可缺少的。正是因为怀有对未来事物的热望，才让你每天早晨坚持从热被窝中迅速爬起来，并且在一天的工作中保持着饱满的精神和注意力。树立人生的目标，就意味着给你的生活加油。我的意思只是说，不要为了成就就放弃快乐。不要把那些可以带给你幸福感和满足感的事情推迟到以后再去做。今天，就是今天就要活得畅快淋漓，而不是苦苦等到赢了体育彩票或者终于熬到退休以后。千万不要把生活中的幸福向后推迟，因为再晚可能就没有机会了。</strong>”<br> 朱利安站了起来，开始在起居室里来来回回地踱步。这时候他似乎又恢复了大律师的样子，在即将结束一场热情洋溢的辩论时作最后陈词。 “不要再自欺欺人，以为只要你为律师事务所再多雇用几个初出茅庐的律师来减轻工作负担，你就会马上变成一个更爱你的妻子，肯为家庭付出的好丈夫。”他的最后陈词和以往一样精彩，我看着此时的朱利安，竟然有些恍惚，觉得他从来都没有离开似的。但是他坚定的声音把我再次拉回眼前。<br> “<strong>不要自欺欺人，以为只要银行户头上有了足够大的数目，自己就自然会有更多的自由时间，可以为所欲为，放肆起来。不要试图让自己想象，只要有了钱有了闲，你就会开始丰富自己的心智，开始关心自己的身体，开始滋养自己的灵魂。这些都是自欺欺人，我们都很明白这一点。今天，就是今天，是你享受多年来努力成果的时候。今天就是抓住眼前一刻，度过充实人生的时候。今天就是抛开忧虑的想象，让心中的梦想跃然成真的时候。而且，在你为自己创造幸福的时候，请你千万、千万不要忘记家庭给予你的丰厚馈赠。</strong>” </p>
<p>“我不敢肯定自己完全理解你的意思了，朱利安。”我没有跟上他的语言跳跃。<br> “<strong>和自己孩子一起经历童年。</strong>”非常简单的回答背后似乎隐藏了什么。<br> “嗯哼？”我小声咕哝了一句，在这句似是而非的话面前仍然摸不着头脑。<br> “<strong>在人的一生中，几乎没有什么事能比你和孩子们一起分享童年更有意义了。如果你在第一个阶段里就忘了和孩子相伴，又怎么可能走向此后的幸福呢？然而，要是你根本没有时间没有能力来创造一个家庭，那么就算你拥有了整个街区当中最大的房子又有什么好处呢？如果你的孩子们根本就不知道给他们生命的父亲是谁，那么就算你名满全国，当上了炙手可热的第一辩护律师又有什么用处呢？我知道我说的是什么。</strong><br> ”朱利安用我们的职业举例子，我感到他的声音因为激动而微微有些发颤。 朱利安的最后一句话使我感到困惑。我所了解的朱利安是一个超级明星律师，每天周旋在珠光宝气和灯红酒绿之中。他和红极一时的时装模特在豪华酒店里的浪漫约会，和他在法庭上滔滔不绝的辩论技术一样广为人知。这个做了多年花花公子的百万富翁怎么可能知道如何做好一位父亲？他又怎么可能知道我每天都要面对的挣扎，想要做好每一个角色要求的每一件事，在家里我得是一个了不起的父亲，出门以后我得是一个成功的大律师？所有这些琐碎的烦恼，朱利安怎么可能知道？我虽然这样想着，却尽量掩饰自己的怀疑，但是敏感的朱利安还是凭着直觉发现了我的想法。<br> “也许你不知道，我确实了解一些关于孩子的事情。”他温和地说，渐渐从刚才的律师状态恢复了他智者的模样。<br> “不过，说句实话，我还一直以为你没有孩子，是现代城市里人见人爱的钻石王老五，至少在你认输辞职之前，我们一直这样认为。你知道的，有多少女实习生为了进入你的办公室大耍花样？有多少……”<br> “稍等，稍等，”朱利安竖起手掌做了个暂停的手势。<br> “老朋友，你对我的了解从12小时前才开始，对不对？”<br> 我看了看他，朱利安脸上的确没有矫揉造作的羞涩。有一种人，无论男女，一听到自己很受异性的欢迎就故意加以否认，但是脸上得意的神态完全暴露出内心的浅薄。朱利安脸上仍然是一潭秋水般的平静。<br> 他继续说道：“人们都知道我过着一种节奏快、心情飘的生活方式，同事们以为我那样的人生应该很过瘾吧。我也曾经这样认为，直到我明白那只不过是自欺欺人的幻象。<br> ”这时竟然有一丝苦笑出现在他平和的脸上，“你知道我是结过婚的。”<br> “是的。”我清了清喉咙。 然后，朱利安在开口前顿了一下，很像一个孩子正准备向最好的朋友吐露内心中隐藏最深的秘密。<br> “但是，你不知道的是我曾经有一个小女儿。她是我最心爱的宝贝，是我一生中见过的最精致最可爱的小精灵。那个时候，我很像我们第一次见面时候的你，自高自大，野心勃勃，而且满怀着希望。我似乎很幸运，拥有世界上每个人想要得到的一切。所有认识我的人都纷纷夸我前程远大，羡慕我有一个美艳惊人的妻子和可爱极了的女儿。然而，当生活看起来非常完美的时候，幸福马上就又离我远去了。”<br> 这是第一次，从朱利安踏入我的家门以后，忧伤第一次完全吞没了他欢乐的神色。一滴眼泪从他晒黑的脸颊上滑落，落在他天鹅绒般柔软的宝石红长袍上。我张口结舌，不知怎样安慰，因为我已经完全被老朋友的真情流露惊呆了。<br> “你不必继续讲下去，朱利安。”我同情地建议说，把一只胳膊搭在他的肩膀上去，希望能够安慰他。<br> “不，我要说，约翰，请听我说吧。在我过去认识的所有人当中，你是最信守承诺的，也是我最信任的。正如我所说过的那样，你常常让我回想起我自己年轻的时候。说真的，即使是现在，你的身上还有很多东西吸引着我。但是我知道一定要告诉你，用我自己的教训来告诉你，如果你继续按照现行的生活方式去生活，总有一天你明白其实这样是在自找苦吃。我来到这里就是为了向你表明，世上有那么多奇迹等待着你去探索，还有那么多美好的时刻等待着你去品味。<br> “那个夺去我女儿生命的喝醉酒的司机，在太阳都为之哭泣的10月的一个下午，不仅仅夺去了一条珍贵的生命——而是两条。自从我的女儿意外去世后，我的生活也打了死结。我开始在办公室里度过每一分钟清醒的时间，愚蠢地希望我的法律事业能够成为破碎心灵中的痛苦的替代品。有些日子，我甚至就睡在办公室里的长沙发上，因为我害怕回到家去，害怕回到那个还残留着那么多甜蜜回忆的家。我的妻子，从我读法学院的时候就一直陪伴着我的伴侣，后来也离开了。她说我的心里只有工作，这简直是压倒我的最后一根稻草。在痛苦、逃避、更痛苦的恶性循环中，我的健康越发糟糕，名声也变得不可收拾，我眼看自己一天天陷入声名狼藉的生活。那就是我们初次见面时我的生活状态，你眼中的同情向我证明我的回忆是准确的。的确，金钱可以买来的东西我一样也不缺，但那是我出卖了灵魂以后换回来的，我真的这样做了，交出我的灵魂。”朱利安激动地说着，声音仍然是哽咽的。<br> “所以你对我说‘和孩子一起分享童年的时光’，其实是让我每天都抽出时间观察他们的成长和发展变化。是这样，对不对？<br> ”我怎么能够不同情面前这个痛苦的朋友呢。 “当时我们开车送她去参加她最好的朋友的生日聚会。即使到今天，她离开我已经二十七年了，但是只要能够再次听到女儿的咯咯笑声，只要能够再和她一起玩儿捉迷藏的游戏，就像我们俩经常在我家后院里玩的那样，我愿意付出一切代价！”朱利安捂住了脸，大口喘息着。<br> “是的，我明白，我明白。”我不知怎样安慰他。<br> “<strong>我最喜欢把她抱在怀里，温柔地梳理她的金色卷发。她离开以后，把我的心也带走了。尽管我在喜马拉雅山上找到了开启心智和自我掌控的方法，我的人生因为找到了新的意义而重新振作起来，但是在我度过的所有日子中，没有一天不在头脑的静默回忆中看到我可爱的小女儿的粉红小脸。你也有这么好的孩子，约翰。不要为了几棵树木而失去了整片森林。你能够给予孩子们的最好馈赠就是你的爱和关心。像第一天见到他们那样去重新认识他们。一定要让他们明白，他们对于你来说，要比职场事业中过眼云烟般的名利回报重要得多。不久之后他们就会长大，就会一个个离你而去，去建立自己的家庭和生活，去建立自己人生中的失落和幸福。到那时候你再表白你对他们的珍惜就太迟了，时间一去不复返。</strong>”<br> 毫无疑问，朱利安拨动了我心底最深处的那根弦。我猜我在有些时候已经隐隐约约察觉到了，我的工作狂心态正在慢慢地瓦解着我和家庭的联系。这种瓦解就像是余烟缭绕的火苗，静静地燃烧，缓慢地积攒力量，直到有一天向四面八方爆发出毁灭性的能量。我知道孩子们需要我，我也知道内心中我多么眷恋他们，尽管我们谁都没有对彼此说过这样的话。我需要朱利安的提醒。时间飞逝，孩子们长大得太快了。我已经记不起来，我和儿子安迪最后一次在清新的周日早晨，偷偷地跑到他的祖父最喜欢的钓鱼池边度过一天的确切时候了。曾经有一段时间我们一起快乐地度过每个周末。而现在，这个由来已久的习惯简直就像是别人回忆中的故事了。 我越想越感到内心沉重。安迪在学校里的钢琴独奏会，圣诞节的化妆演出，还有他的少年棒球联赛，我一个都没参加，都被我用来换取事业上晋职升迁了。那么安迪的心中会怎么想呢？天哪，他千万不要以为我把工作看的比他更重要啊！<br> “我都做了些什么啊？”我抱着头苦苦思索。我的确已经身不由己地滑到了朱利安所描述的灾难的边缘。好吧，接下来，我决心要改变一切。<br><strong> “幸福犹如一场没有终点的旅程，”朱利安继续说，他的声音已经滤去了刚才的感伤和波动，再一次因为饱含热情而高昂起来，“这也是你给自己创造的一次机会。你可以一直顺着那条铺满钻石的曲折小路向前走，也可以继续草草挥霍所剩的时间，追求彩虹尽头的那一坛黄金，最终却发现这不过是一场空。欣赏每一天中的任何一个不同的时刻吧，因为今天才是你完全拥有的一天。</strong>”<br> “每个人都能学会‘活在当下’吗？”我问道。<br> “当然。无论你目前的境遇怎么样，你都可以训练自己，学会欣赏并且珍惜生命和家庭的馈赠，在每一天的生活中都使自己的存在充满了珍宝般的价值。”<br> “但是这是不是有点太过于乐观了？要是有谁在一场糟糕的商业交易中损失了一切，他该怎么办？我们不仅是说他们的经济破产了，而且指的是他们精神上也完全垮掉了。”<br> “唉，”朱利安轻轻叹息，“<strong>我就是希望人们知道，你在银行户头上有多少存款，或者你住的房子是大是小，根本就和你能不能带着欢乐的情绪和好奇心去生活毫无关系。这个世界上开心的穷光蛋不多，可闷闷不乐的百万富翁到处都是。如果你学会在一天里抽出5分钟来练习感恩的艺术，你就会得到一直在寻找的丰富生活。就连你在举例中说到的那些人也可以发现，生活中其实还有很多东西值得他们去一再感恩，即使他们遭遇到了可怕的经济困境和精神困境。让我们去问问他，是不是还拥有自己的健康，是不是还有可爱的家庭和社交中的好口碑？他难道不以在这个伟大的国家里拥有公民资格而感到幸福吗？他的头顶上难道不是还有一方遮风挡雨的屋顶吗？也许他不再拥有成功时的霸气，不再有事业顺利时的大笔财富，不能重复一掷千金的气概，不能随心所欲地签支票购买所有感兴趣的东西。然而，还有另外一些财富是他应该用一生的时间来感恩的。我们都有很多需要感恩的东西。即使是阳光灿烂的夏天里，一只鸟儿在你的落地长窗前面婉转啼鸣，一个睿智的人也会认出来它们其实是上天赐予的馈赠。记住，约翰，生活并不总是给你想要的东西，却永远会给你需要的东西。</strong>” </p>
<p>我们都有命里注定要去完成的事情。当你发现更高的目标，投入所有的精力时，你的才能将会迸发出来，幸福会充满你的生活。一旦你认识到你的使命，无论是成为一位成绩突出的教育孩子们的老师，还是做一个灵感丰富创作惊人的艺术家，所有的愿望都会轻而易举地被实现。你甚至都不必先去尝试。不瞒你说，我觉得你越是先去尝试，在目标实现之前所花的准备时间也就越长。相反的是，只要你跟随梦想的道路，所有在期望中想要获得的东西都一定会纷至沓来。它将引领着你走向神圣的终点。这就是我所说的铸就命运的含义。</p>
<h2 id="极乐世界？"><a href="#极乐世界？" class="headerlink" title="极乐世界？"></a>极乐世界？</h2><p>不幸的是，约翰，你听到彼得的故事，还有那根奇妙的魔法线仅仅是一个故事，一个神话故事。而我们此时正生活在一个绝对现实的世界里，根本没有第二次机会让你重新来过一遍，去实现圆满的人生。今天，唯有今天才是你领受生活馈赠的时机——在还不是太晚之前。约翰，让这新的一天成为你人生中的分界线，你在这一天完完全全下定决心，把所有的精力都集中在对你来说是真正重要的事情上。你要下定决心，在那些可以使你的生活具有更有意义的事情上多花些时间。对生命中特殊的时刻心存敬畏，为它们的蕴含而沉醉。做那些你一直想要做的事情。去爬你一直想要去攀登的高山，或者去学一种乐器，自己做一支曲子，写一首歌词。在大雨天冲出去跳舞，或者另起炉灶从事一门新职业。学会热爱音乐，聆听音乐和鉴赏音乐，学会一门新的外语，重新点燃童年的欢乐时光。不要出于成功的考虑就把幸福向后推延。相反的是，开始学会欣赏过程中的美，重新振作你的精神，认识你的灵魂并且开始爱护它。这就是通向极乐世界的道路。” **</p>
<p> <strong> “极乐世界？</strong>听起来像佛教里的词语？”我重复着。<br>  “<strong>极乐世界不单单是佛教里的词语。喜马拉雅山上的智者相信，真正开悟了的灵魂要前往的最终目的地是一个名叫极乐世界的地方。事实上，它不仅仅是一个地方，智者相信极乐世界是一种状态，人们可以超越此前他们所知道的一切。在极乐世界中，一切都是可能的。那里没有苦难，生命的舞蹈奔放到了极致，神圣而完美。在抵达极乐世界的途中，智者感到自己正在走向天堂。这就是他们人生中的最终目标。”朱利安总结说，他的脸笼罩在安宁之中，简直就是天使的模样</strong>。<br>  “<strong>我们之所以在这里都是出于某些特定的原因，”他预言般的继续总结着，“静心思考真正召唤你的是什么，想一想你将怎样帮助他人。不要再做惯性和惰性的奴隶，不要再拿贷款作为不快乐的借口。今天，用人生真正的意义点亮你的生命火花，让它明亮地熊熊燃烧起来。开始练习我和你分享的那些道理和方法，去做你能做的一切。当你感到内心里非常渴望尝到极乐世界果实的滋味时，那一时刻就会自然来临。</strong>”朱利安眼睛里的光芒使他看上去像一位神殿里的预言祭祀。 </p>
<h2 id="开悟"><a href="#开悟" class="headerlink" title="开悟"></a>开悟</h2><p>“会有一些微小的迹象出现，向你显示极乐世界的入口。你开始注意到身边每一件事物当中蕴含的神圣性：比如一束月光的完美，炎热夏季里湛蓝的天空所具有的吸引力，雏菊盛开时的芬芳，或者小孩子淘气的大笑声。<br>  ”我听出他的语气中充满鼓励。 “朱利安，我向你保证，你和我在一起度过的时间不会白白浪费掉。我准备让自己完全按照智者的智慧来用心地生活，而且我将信守承诺，把我从你那里分享来的所有知识，和那些可能会从中受益的人们一起温习。我说这些话是发自内心的。我向你保证。<br>  ”我真诚地说道，感到内心里激情涌动。 “把智者的丰富智慧统统传播给身边所有的人们吧。他们很快就会从中受益，提升他们的生活品质，就像你提升了自己的生活品质一样。而且还要记住，要享受过程本身，沿途和终点一样美好。”<br>  我请朱利安继续说下去。他说：“瑜伽师拉曼是一个非常伟大的讲故事的人，但是有一个故事在他讲给我的所有故事当中显得与众不同。现在我可以讲给你听吗？”<br>  “当然好啊，你知道我一直在聆听你的每一句话。”<br>  “很多年以前，在古老的印度，有一位王侯准备为他的妻子修建一座宏大的建筑，作为他对妻子的深爱和感情的象征。这个王侯想创造出一种世界上从来都不曾见到过的建筑结构，它将在月光照耀下的夜晚里微微放光，让世世代代的人们都因为仰慕而特地赶来朝拜。于是，他的工匠们每天都忍受着酷暑骄阳，一砖一瓦地劳作。每过一天，结构就更加清楚一点，越来越像一座丰碑，也越来越像爱的灯塔，直指蔚蓝色的印度天空。最后，在经过了日复一日的20年的重复劳作之后，这座完全用白色大理石建成的宫殿终于竣工了。你猜一猜我说的是什么？”<br>  “我对印度的文明几乎一无所知。”我老老实实地承认。<br>  “就是泰姬陵。”朱利安回答我说，“我的意思很简单。这个星球上的每个人都是一个奇迹。从某种意义上来说，我们中的每一个人都是天才，都是英雄。我们中的每一个人都有潜力取得超凡的成就，取得巨大的幸福感和永恒的满足感，所需要的只是朝着我们梦想的方向踏实前行。就像泰姬陵的建筑过程一样，在简单重复的劳动中整整耗时20年。<strong>一个充满生命的奇迹就是这样日复一日，一砖一瓦建成的。小的成功会通向大的胜利。微小的、循序渐进的变化将会在一起形成积极的习惯。而后，积极的习惯会带来好的成果。积极的成果则会激励你继续朝着更加伟大的个人目标去努力。开始像对待生命中最后一天那样过好每一天的生活。从今天开始，多多学习，多多大笑，去做你真正喜欢做的事情。不要逃避自己的命运，更不要否定自己的命运。因为和存在于你自身中的那些珍贵的东西相比，那些身前身后的浮云名利根本都是无关紧要的。</strong>” </p>
<p>如上是内容摘要，如果想更细的了解，可以购买相应的图书。这个内容是需要不段实践才能看到效果。加油吧，共同探索。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cenrise.com/2018/05/22/分布式/负载均衡初识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongpo.jia">
      <meta itemprop="description" content="个人博客">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="中起之星">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/22/分布式/负载均衡初识/" itemprop="url">
                  负载均衡初识
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-05-22 16:43:49" itemprop="dateCreated datePublished" datetime="2018-05-22T16:43:49+08:00">2018-05-22</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-05-30 16:37:01" itemprop="dateModified" datetime="2018-05-30T16:37:01+08:00">2018-05-30</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/分布式/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/分布式/负载均衡/" itemprop="url" rel="index"><span itemprop="name">负载均衡</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="负载均衡的模式"><a href="#负载均衡的模式" class="headerlink" title="负载均衡的模式"></a>负载均衡的模式</h2><ul>
<li>ActiveWeight / LeastActive ：低并发度优先， referer 的某时刻的 call 数越小优先级越高。</li>
<li>Random ：随机，按权重设置随机概率。在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。</li>
<li>RoundRobin ：轮循，按公约后的权重设置轮循比率。存在慢的提供者累积请求问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。</li>
<li>LocalFirst ：本地服务优先获取策略。</li>
<li>Consistent ：一致性 Hash ，相同参数的请求总是发到同一提供者。当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</li>
<li>ConfigurableWeight ：权重可配置的负载均衡策略。</li>
</ul>
<h2 id="技术对比"><a href="#技术对比" class="headerlink" title="技术对比"></a>技术对比</h2><ul>
<li>Motan：支持 ActiveWeight 、Random 、 RoundRobin 、LocalFirst 、 Consistent 、ConfigurableWeight 。</li>
<li>Dubbo：支持 Random 、RoundRobin 、ConsistentHash 、 LeastActive。</li>
<li>gRPC：提供可插拔负载均衡器的机制。</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cenrise.com/2017/08/18/异常/Java_heap_space_OutOfMemoryError/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongpo.jia">
      <meta itemprop="description" content="个人博客">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="中起之星">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/18/异常/Java_heap_space_OutOfMemoryError/" itemprop="url">
                  Java_heap_space_OutOfMemoryError
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-08-18 20:30:00" itemprop="dateCreated datePublished" datetime="2017-08-18T20:30:00+08:00">2017-08-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-05-15 13:57:06" itemprop="dateModified" datetime="2018-05-15T13:57:06+08:00">2018-05-15</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/异常/" itemprop="url" rel="index"><span itemprop="name">异常</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/异常/tomcat/" itemprop="url" rel="index"><span itemprop="name">tomcat</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#java.lang.OutOfMemoryError: Java heap space</p>
<p>##问题描述<br>Tomcat 8.0.45在linux环境下启动错误</p>
<p>##原因分析<br>JVM堆是指java程序运行过程中JVM可以调配使用的内存空间,主要用于存放Instance。JVM在启动的时候会自动设置Heap size的值，其初始空间(即-Xms)是物理内存的1/64，最大空间(-Xmx)是物理内存的1/4。可以利用JVM提供的-Xmn -Xms -Xmx等选项可进行设置。Heap size 的大小是Young Generation 和Tenured Generaion 之和。在JVM中如果98％的时间是用于GC且可用的Heap size 不足2％的时候将抛出此异常信息。</p>
<p>##解决方案<br>手动设置Heap size<br>a.如果tomcat是以bat方式启动的，则如下设置：<br>修改TOMCAT_HOME/bin/catalina.sh<br>JAVA_OPTS=”-server -Xms1024m -Xmx1024m    -XX:MaxNewSize=256m”</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cenrise.com/2017/08/18/异常/JasperListener类找不到/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongpo.jia">
      <meta itemprop="description" content="个人博客">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="中起之星">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/18/异常/JasperListener类找不到/" itemprop="url">
                  JasperListener类找不到
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-08-18 09:59:00" itemprop="dateCreated datePublished" datetime="2017-08-18T09:59:00+08:00">2017-08-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-08-21 01:36:00" itemprop="dateModified" datetime="2017-08-21T01:36:00+08:00">2017-08-21</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/异常/" itemprop="url" rel="index"><span itemprop="name">异常</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/异常/tomcat/" itemprop="url" rel="index"><span itemprop="name">tomcat</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#Tomcat java.lang.ClassNotFoundException: org.apache.catalina.core.JasperListener</p>
<p>##问题描述<br>Linux下启动tomcat8.0.45错误，windons下可用。</p>
<p>##原因分析<br>ClassNotFoundException大致可能有两种情况，一是找不到jar包，二是jar包冲突，不知用哪个。</p>
<p>##解决方案<br>JasperListener好像是一个报表支持，目前不需要，可以暂时去掉。<br>在tomcat目录 /conf/server.xml里注释如下内容</p>
<listener classname="org.apache.catalina.core.JasperListener">   </listener>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cenrise.com/2017/08/18/异常/permGen_space_OutOfMemoryError/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongpo.jia">
      <meta itemprop="description" content="个人博客">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="中起之星">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/18/异常/permGen_space_OutOfMemoryError/" itemprop="url">
                  permGen_space_OutOfMemoryError
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-08-18 09:55:00" itemprop="dateCreated datePublished" datetime="2017-08-18T09:55:00+08:00">2017-08-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-08-21 01:36:00" itemprop="dateModified" datetime="2017-08-21T01:36:00+08:00">2017-08-21</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/异常/" itemprop="url" rel="index"><span itemprop="name">异常</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/异常/tomcat/" itemprop="url" rel="index"><span itemprop="name">tomcat</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#Tomcat java.lang.OutOfMemoryError: PermGen space</p>
<p>##问题描述<br>Tomcat 8.0.45在linux环境下启动错误</p>
<p>##原因分析<br>PermGen space是指内存的永久保存区域内存溢出。这块内存主要是JVM来来存放Class和Meta信息的，Class在被Load的时候被放入PermGen space区域，它和存放Instance的Heap区域不同,GC(Garbage Collection)不会在主程序运行期对PermGen space进行清理，所以如果你的APP会LOAD很多CLASS的话，就很可能出现PermGen space错误。这种错误常见在web服务器对JSP进行预编译的时候。如果你的WEB APP下都用了大量的第三方jar, 其大小超过了jvm默认的大小(4M)那么就会产生此错误信息了。</p>
<p>##解决方案<br>手动设置MaxPermSize大小,修改TOMCAT_HOME/bin/catalina.sh<br>JAVA_OPTS=”-server -XX:PermSize=256M -XX:MaxPermSize=1024m”   </p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cenrise.com/2017/08/18/异常/connection_holder_is_null/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongpo.jia">
      <meta itemprop="description" content="个人博客">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="中起之星">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/18/异常/connection_holder_is_null/" itemprop="url">
                  connection_holder_is_null
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-08-18 09:55:00" itemprop="dateCreated datePublished" datetime="2017-08-18T09:55:00+08:00">2017-08-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-08-21 01:36:00" itemprop="dateModified" datetime="2017-08-21T01:36:00+08:00">2017-08-21</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/异常/" itemprop="url" rel="index"><span itemprop="name">异常</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/异常/tomcat/" itemprop="url" rel="index"><span itemprop="name">tomcat</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#java.sql.SQLException: connection holder is null</p>
<p>##问题描述<br>使用druid连接池时出现的间歇性错误，偶尔会出现。</p>
<p>##原因分析<br>连接池可能对连接持有时间有限制，一种保护机制，如果某个连接很长时间不释放，其它应用就没有办法使用这个连接。</p>
<p>##解决方案</p>
<p>###方案一：<br>        延长这个超时时间，默认为300秒（推荐）<br>        <!--是否自动回收超时连接--><br>           <property name="removeAbandoned" value="true"><br>           <!--延长这个所谓的超时时间--><br>           <property name="removeAbandonedTimeout" value="1800"><br>           <!--将当前关闭动作记录到日志--><br>           <property name="logAbandoned" value="true">        </property></property></property></p>
<p>###方案二：<br>        关闭这个超时保护<br>        /<em>直接关闭这个   自动回收超时连接</em>/<br>        <property name="removeAbandoned" value="false"></property></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cenrise.com/2017/06/09/服务/和田市卫浴安装家具安装/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongpo.jia">
      <meta itemprop="description" content="个人博客">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="中起之星">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/09/服务/和田市卫浴安装家具安装/" itemprop="url">
                  和田市卫浴安装家具安装
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-06-09 17:28:00" itemprop="dateCreated datePublished" datetime="2017-06-09T17:28:00+08:00">2017-06-09</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-08-18 09:44:35" itemprop="dateModified" datetime="2017-08-18T09:44:35+08:00">2017-08-18</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/服务/" itemprop="url" rel="index"><span itemprop="name">服务</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#和田市卫浴安装工人<br>朱力<br>电话：139 9943 3811<br>介绍：从事家具（厨柜、床）、卫浴等工作20余年，目前在和田专业从事安具、厨卫安装、销售服务。</p>
<p>#和田市卫浴家具安装工人<br>朱力<br>电话：139 9943 3811<br>介绍：从事家具（厨柜、床）、卫浴等工作20余年，目前在和田专业从事安具、厨卫安装、销售服务。</p>
<h1 id="可以接收什么类型的工作"><a href="#可以接收什么类型的工作" class="headerlink" title="可以接收什么类型的工作"></a>可以接收什么类型的工作</h1><p>1.家具安装，包含床、柜子、书桌等。<br>2.卫浴安装<br>3.品牌家具销售  </p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cenrise.com/2017/05/30/review/Findbug代码审查-缺陷和修改/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongpo.jia">
      <meta itemprop="description" content="个人博客">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="中起之星">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/30/review/Findbug代码审查-缺陷和修改/" itemprop="url">
                  Findbug代码审查-缺陷和修改
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-05-30 16:43:49" itemprop="dateCreated datePublished" datetime="2017-05-30T16:43:49+08:00">2017-05-30</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-05-30 17:32:36" itemprop="dateModified" datetime="2018-05-30T17:32:36+08:00">2018-05-30</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/review/" itemprop="url" rel="index"><span itemprop="name">review</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="FindBugs使用实践-缺陷和修改"><a href="#FindBugs使用实践-缺陷和修改" class="headerlink" title="FindBugs使用实践-缺陷和修改"></a>FindBugs使用实践-缺陷和修改</h1><p>Confidence 是fingbug团队认为该代码导致bug的可能性。</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>1 Malicious code vulnerability 恶意代码<br>2 Performance 性能问题<br>3 Security 安全性问题<br>4 Dodgy code 小问题<br>5 Correctness 代码的正确性<br>6 Bad practice 不好的习惯<br>7 Internationalization 国际化问题<br>8 Experrimental 实验性问题<br>无     Multithreaded currectness 线程问题</p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h4 id="1-Bad-practice-坏的实践"><a href="#1-Bad-practice-坏的实践" class="headerlink" title="1 Bad practice 坏的实践"></a>1 Bad practice 坏的实践</h4><p>一些不好的实践，下面列举几个： HE：类定义了equals()，却没有hashCode()；或类定义了equals()，却使用Object.hashCode()；或类定义了hashCode()，却没有equals()；或类定义了hashCode()，却使用Object.equals()；类继承了equals()，却使用Object.hashCode()。<br>SQL：Statement 的execute方法调用了非常量的字符串；或Prepared Statement是由一个非常量的字符串产生。<br>DE：方法终止或不处理异常，一般情况下，异常应该被处理或报告，或被方法抛出。<br>Malicious code vulnerability 可能受到的恶意攻击<br>如果代码公开，可能受到恶意攻击的代码，下面列举几个： FI：一个类的finalize()应该是protected，而不是public的。MS：属性是可变的数组；属性是可变的Hashtable；属性应该是package protected的。</p>
<h4 id="2-Correctness-一般的正确性问题"><a href="#2-Correctness-一般的正确性问题" class="headerlink" title="2 Correctness 一般的正确性问题"></a>2 Correctness 一般的正确性问题</h4><p>可能导致错误的代码，下面列举几个： NP：空指针被引用；在方法的异常路径里，空指针被引用；方法没有检查参数是否null；null值产生并被引用；null值产生并在方法的异常路径被引用；传给方法一个声明为@NonNull的null参数；方法的返回值声明为@NonNull实际是null。 Nm：类定义了hashcode()方法，但实际上并未覆盖父类Object的hashCode()；类定义了tostring()方法，但实际上并未覆盖父类Object的toString()；很明显的方法和构造器混淆；方法名容易混淆。 SQL：方法尝试访问一个Prepared Statement的0索引；方法尝试访问一个ResultSet的0索引。 UwF：所有的write都把属性置成null，这样所有的读取都是null，这样这个属性是否有必要存在；或属性从没有被write。</p>
<h4 id="3-Dodgy-危险的"><a href="#3-Dodgy-危险的" class="headerlink" title="3 Dodgy 危险的"></a>3 Dodgy 危险的</h4><p>具有潜在危险的代码，可能运行期产生错误，下面列举几个： CI：类声明为final但声明了protected的属性。 DLS：对一个本地变量赋值，但却没有读取该本地变量；本地变量赋值成null，却没有读取该本地变量。 ICAST：整型数字相乘结果转化为长整型数字，应该将整型先转化为长整型数字再相乘。 INT：没必要的整型数字比较，如X &lt;= Integer.MAX_VALUE。 NP：对readline()的直接引用，而没有判断是否null；对方法调用的直接引用，而方法可能返回null。 REC：直接捕获Exception，而实际上可能是RuntimeException。 ST：从实例方法里直接修改类变量，即static属性。</p>
<h4 id="4-Performance-性能问题"><a href="#4-Performance-性能问题" class="headerlink" title="4 Performance 性能问题"></a>4 Performance 性能问题</h4><p>可能导致性能不佳的代码，下面列举几个： DM：方法调用了低效的Boolean的构造器，而应该用Boolean.valueOf(…)；用类似Integer.toString(1) 代替new Integer(1).toString()；方法调用了低效的float的构造器，应该用静态的valueOf方法。 SIC：如果一个内部类想在更广泛的地方被引用，它应该声明为static。 SS：如果一个实例属性不被读取，考虑声明为static。 UrF：如果一个属性从没有被read，考虑从类中去掉。 UuF：如果一个属性从没有被使用，考虑从类中去掉。</p>
<h4 id="5-Multithreaded-correctness-多线程的正确性多线程编程时，可能导致错误的代码，下面列举几个："><a href="#5-Multithreaded-correctness-多线程的正确性多线程编程时，可能导致错误的代码，下面列举几个：" class="headerlink" title="5 Multithreaded correctness 多线程的正确性多线程编程时，可能导致错误的代码，下面列举几个："></a>5 Multithreaded correctness 多线程的正确性多线程编程时，可能导致错误的代码，下面列举几个：</h4><p>ESync：空的同步块，很难被正确使用。 MWN：错误使用notify()，可能导致IllegalMonitorStateException异常；或错误的使用wait()。 No：使用notify()而不是notifyAll()，只是唤醒一个线程而不是所有等待的线程。 SC：构造器调用了Thread.start()，当该类被继承可能会导致错误。</p>
<h4 id="6-Internationalization-国际化当对字符串使用upper或lowercase方法，如果是国际的字符串，可能会不恰当的转换。"><a href="#6-Internationalization-国际化当对字符串使用upper或lowercase方法，如果是国际的字符串，可能会不恰当的转换。" class="headerlink" title="6 Internationalization 国际化当对字符串使用upper或lowercase方法，如果是国际的字符串，可能会不恰当的转换。"></a>6 Internationalization 国际化当对字符串使用upper或lowercase方法，如果是国际的字符串，可能会不恰当的转换。</h4><p>API： <a href="http://findbugs.sourceforge.net/api/index.html" target="_blank" rel="noopener">http://findbugs.sourceforge.net/api/index.html</a><br>技术手册： <a href="http://findbugs.sourceforge.net/manual/index.html" target="_blank" rel="noopener">http://findbugs.sourceforge.net/manual/index.html</a><br>更多请参见官网： <a href="http://findbugs.sourceforge.net/bugDescriptions.html" target="_blank" rel="noopener">http://findbugs.sourceforge.net/bugDescriptions.html</a></p>
<h5 id="6-1、-ES-COMPARING-PARAMETER-STRING-WITH-EQ"><a href="#6-1、-ES-COMPARING-PARAMETER-STRING-WITH-EQ" class="headerlink" title="6.1、       ES_COMPARING_PARAMETER_STRING_WITH_EQ"></a>6.1、       ES_COMPARING_PARAMETER_STRING_WITH_EQ</h5><pre><code>ES: Comparison of String parameter using == or != (ES_COMPARING_PARAMETER_STRING_WITH_EQ)
</code></pre><p>This code compares a java.lang.String parameter for reference equality using the == or != operators. Requiring callers to pass only String constants or interned strings to a method is unnecessarily fragile, and rarely leads to measurable performance gains. Consider using the equals(Object) method instead.<br>     使用 == 或者 != 来比较字符串或interned字符串，不会获得显著的性能提升，同时并不可靠，请考虑使用equals()方法。</p>
<h5 id="6-2、-HE-EQUALS-NO-HASHCODE"><a href="#6-2、-HE-EQUALS-NO-HASHCODE" class="headerlink" title="6.2、       HE_EQUALS_NO_HASHCODE"></a>6.2、       HE_EQUALS_NO_HASHCODE</h5><pre><code>HE: Class defines equals() but not hashCode() (HE_EQUALS_NO_HASHCODE)
</code></pre><p>This class overrides equals(Object), but does not override hashCode().  Therefore, the class may violate the invariant that equal objects must have equal hashcodes.<br>     类定义了equals()方法但没有重写hashCode()方法，这样违背了相同对象必须具有相同的hashcodes的原则</p>
<h5 id="6-3、IT-NO-SUCH-ELEMENT"><a href="#6-3、IT-NO-SUCH-ELEMENT" class="headerlink" title="6.3、IT_NO_SUCH_ELEMENT"></a>6.3、IT_NO_SUCH_ELEMENT</h5><pre><code>It: Iterator next() method can&apos;t throw NoSuchElement exception (IT_NO_SUCH_ELEMENT)
</code></pre><p>This class implements the java.util.Iterator interface.  However, its next() method is not capable of throwing java.util.NoSuchElementException.  The next() method should be changed so it throws NoSuchElementException if is called when there are no more elements to return.<br>     迭代器Iterator无法抛出NoSuchElement异常，类实现了java.util.Iterator接口，但是next()方法无法抛出java.util.NoSuchElementException异常，因此，next()方法应该做如此修改，当被调用时，如果没有element返回，则抛出NoSuchElementException异常</p>
<h5 id="6-4、J2EE-STORE-OF-NON-SERIALIZABLE-OBJECT-INTO-SESSION"><a href="#6-4、J2EE-STORE-OF-NON-SERIALIZABLE-OBJECT-INTO-SESSION" class="headerlink" title="6.4、J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION"></a>6.4、J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION</h5><pre><code>J2EE: Store of non serializable object into HttpSession (J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION)
</code></pre><p>This code seems to be storing a non-serializable object into an HttpSession. If this session is passivated or migrated, an error will result.<br>     将没有实现serializable的对象放到HttpSession中，当这个session被钝化和迁移时，将会产生错误，建议放到HttpSession中的对象都实现serializable接口。</p>
<h5 id="6-5、ODR-OPEN-DATABASE-RESOURCE"><a href="#6-5、ODR-OPEN-DATABASE-RESOURCE" class="headerlink" title="6.5、ODR_OPEN_DATABASE_RESOURCE"></a>6.5、ODR_OPEN_DATABASE_RESOURCE</h5><pre><code>ODR: Method may fail to close database resource (ODR_OPEN_DATABASE_RESOURCE)
</code></pre><p>The method creates a database resource (such as a database connection or row set), does not assign it to any fields, pass it to other methods, or return it, and does not appear to close the object on all paths out of the method.  Failure to close database resources on all paths out of a method may result in poor performance, and could cause the application to have problems communicating with the database.<br>     方法可能未关闭数据库资源，未关闭数据库资源将会导致性能变差，还可能引起应用与服务器间的通讯问题。</p>
<h5 id="6-6、OS-OPEN-STREAM"><a href="#6-6、OS-OPEN-STREAM" class="headerlink" title="6.6、OS_OPEN_STREAM"></a>6.6、OS_OPEN_STREAM</h5><pre><code>OS: Method may fail to close stream (OS_OPEN_STREAM)
</code></pre><p>The method creates an IO stream object, does not assign it to any fields, pass it to other methods that might close it, or return it, and does not appear to close the stream on all paths out of the method.  This may result in a file descriptor leak.  It is generally a good idea to use a finally block to ensure that streams are closed.<br>     方法可能未关闭stream，方法产生了一个IO流，却未关闭，将会导致文件描绘符的泄漏，建议使用finally block来确保io stream被关闭。</p>
<h5 id="6-7、-DMI-CALLING-NEXT-FROM-HASNEXT"><a href="#6-7、-DMI-CALLING-NEXT-FROM-HASNEXT" class="headerlink" title="6.7、       DMI_CALLING_NEXT_FROM_HASNEXT"></a>6.7、       DMI_CALLING_NEXT_FROM_HASNEXT</h5><pre><code>DMI: hasNext method invokes next (DMI_CALLING_NEXT_FROM_HASNEXT)
</code></pre><p>The hasNext() method invokes the next() method. This is almost certainly wrong, since the hasNext() method is not supposed to change the state of the iterator, and the next method is supposed to change the state of the iterator.</p>
<h5 id="6-8、-IL-INFINITE-LOOP"><a href="#6-8、-IL-INFINITE-LOOP" class="headerlink" title="6.8、       IL_INFINITE_LOOP"></a>6.8、       IL_INFINITE_LOOP</h5><pre><code>IL: An apparent infinite loop (IL_INFINITE_LOOP)
</code></pre><p>This loop doesn’t seem to have a way to terminate (other than by perhaps throwing an exception).<br>     明显的无限循环.</p>
<h5 id="6-9、-IL-INFINITE-RECURSIVE-LOOP"><a href="#6-9、-IL-INFINITE-RECURSIVE-LOOP" class="headerlink" title="6.9、       IL_INFINITE_RECURSIVE_LOOP"></a>6.9、       IL_INFINITE_RECURSIVE_LOOP</h5><pre><code>IL: An apparent infinite recursive loop (IL_INFINITE_RECURSIVE_LOOP)
</code></pre><p>This method unconditionally invokes itself. This would seem to indicate an infinite recursive loop that will result in a stack overflow.<br>     明显的无限迭代循环,将导致堆栈溢出.</p>
<h5 id="6-10、-WMI-WRONG-MAP-ITERATOR"><a href="#6-10、-WMI-WRONG-MAP-ITERATOR" class="headerlink" title="6.10、   WMI_WRONG_MAP_ITERATOR"></a>6.10、   WMI_WRONG_MAP_ITERATOR</h5><pre><code>WMI: Inefficient use of keySet iterator instead of entrySet iterator (WMI_WRONG_MAP_ITERATOR)
</code></pre><p>This method accesses the value of a Map entry, using a key that was retrieved from a keySet iterator. It is more efficient to use an iterator on the entrySet of the map, to avoid the Map.get(key) lookup.<br>     使用了keySet iterator和Map.get(key)来获取Map值,这种方式效率低,建议使用entrySet的iterator效率更高.</p>
<h5 id="6-11、-IM-BAD-CHECK-FOR-ODD"><a href="#6-11、-IM-BAD-CHECK-FOR-ODD" class="headerlink" title="6.11、   IM_BAD_CHECK_FOR_ODD"></a>6.11、   IM_BAD_CHECK_FOR_ODD</h5><pre><code>IM: Check for oddness that won&apos;t work for negative numbers (IM_BAD_CHECK_FOR_ODD)
</code></pre><p>The code uses x % 2 == 1 to check to see if a value is odd, but this won’t work for negative numbers (e.g., (-5) % 2 == -1). If this code is intending to check for oddness, consider using x &amp; 1 == 1, or x % 2 != 0.<br>     奇偶检测逻辑,未考虑负数情况.</p>
<h4 id="7-实际项目中Bug类型统计"><a href="#7-实际项目中Bug类型统计" class="headerlink" title="7.实际项目中Bug类型统计"></a>7.实际项目中Bug类型统计</h4><h5 id="7-1、-Call-to-equals-comparing-different-types"><a href="#7-1、-Call-to-equals-comparing-different-types" class="headerlink" title="7.1、       Call to equals() comparing different types"></a>7.1、       Call to equals() comparing different types</h5><p>id : EC_UNRELATED_TYPES, type : EC, category : CORRECTNESS This method calls equals(Object) on two references of different class types with no common subclasses. Therefore, the objects being compared are unlikely to be members of the same class at runtime (unless some application classes were not analyzed, or dynamic class loading can occur at runtime). According to the contract of equals(), objects of different classes should always compare as unequal; therefore, according to the contract defined by java.lang.Object.equals(Object), the result of this comparison will always be false at runtime.<br>原因分析：<br>这缺陷的意思是，大部分都是类型永远不会有这种情况， 比如a为DOUBLE类型所以EQUALS只匹配字符串 if(a.equals())或if(a.quals())这类判断是根本不会有用的；<br>示例：if(“1”.equals(DAOValue.valueofSuccess()))</p>
<h5 id="7-2、-Dead-store-to-local-variable"><a href="#7-2、-Dead-store-to-local-variable" class="headerlink" title="7.2、       Dead store to local variable"></a>7.2、       Dead store to local variable</h5><p>id: DLS_DEAD_LOCAL_STORE, type: DLS, category: STYLE<br>This instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used.<br>Note that Sun’s javac compiler often generates dead stores for final local variables. Because FindBugs is a bytecode-based tool, there is no easy way to eliminate these false positives.<br>原因分析：<br>DLS问题指的是给本地变量赋了一个值，但随后的代码并没有用到这个值。</p>
<h5 id="7-3、-Method-call-passes-null-for-nonnull-parameter"><a href="#7-3、-Method-call-passes-null-for-nonnull-parameter" class="headerlink" title="7.3、       Method call passes null for nonnull parameter"></a>7.3、       Method call passes null for nonnull parameter</h5><p>id: NP_NULL_PARAM_DEREF, type: NP, category: CORRECTNESS<br>This method call passes a null value for a nonnull method parameter. Either the parameter is annotated as a parameter that should always be nonnull, or analysis has shown that it will always be dereferenced.<br>原因分析：对参数为null的情况未作处理。<br>例如：</p>
<figure class="highlight plain"><figcaption><span>void method1() &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    String ip = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        ip = InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">    &#125; catch (UnknownHostException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    long ipCount = countIpAddress(ip);//可能会传入空引用 </span><br><span class="line">    //....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long countIpAddress(String ip) &#123;</span><br><span class="line">    long ipNum = 0;</span><br><span class="line">    String[] ipArray = ip.split(&quot;\\.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><figcaption><span>void method1() &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    String ip = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        ip = InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">    &#125; catch (UnknownHostException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    long ipCount = countIpAddress(ip);//可能会传入空引用</span><br><span class="line">    //....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">long countIpAddress(String ip) &#123;</span><br><span class="line">    long ipNum = 0;</span><br><span class="line">    if(ip==null)&#123;</span><br><span class="line">        return 0;//抛出异常</span><br><span class="line">    &#125;</span><br><span class="line">    String[] ipArray = ip.split(&quot;\\.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于接口需要对参数校验合法性</p>
<h5 id="7-4、Method-with-Boolean-return-type-returns-explicit-null"><a href="#7-4、Method-with-Boolean-return-type-returns-explicit-null" class="headerlink" title="7.4、Method with Boolean return type returns explicit null"></a>7.4、Method with Boolean return type returns explicit null</h5><p>id: NP_BOOLEAN_RETURN_NULL, type: NP, category: BAD_PRACTICE<br>A method that returns either Boolean.TRUE, Boolean.FALSE or null is an accident waiting to happen. This method can be invoked as though it returned a value of type boolean, and the compiler will insert automatic unboxing of the Boolean value. If a null value is returned, this will result in a NullPointerException.<br>原因分析：<br>方法如果定义为返回类型Boolean，则可以返回Boolean.TRUE, Boolean.FALSE or null （如果 return 的是 true or  false， 则AutoBoxing 成 Boolean.TRUE, Boolean.FALSE）。因为JDK 支持 基本类型和装箱类型的自动转化， 所以下面的代码中：<br>boolean result = test_NP_BOOLEAN_RETURN_NULL();<br>因为此时test_NP_BOOLEAN_RETURN_NULL() 返回的是NULL， 所以 JDK 做 automatic unboxing 的操作时， 即调用了 object. booleanValue() 方法时，抛出了空指针。<br>改成：boolean result = test_NP_BOOLEAN_RETURN_NULL()==null?false:true;</p>
<h5 id="7-5、-No-relationship-between-generic-parameter-and-method-argument"><a href="#7-5、-No-relationship-between-generic-parameter-and-method-argument" class="headerlink" title="7.5、       No relationship between generic parameter and method argument"></a>7.5、       No relationship between generic parameter and method argument</h5><p>id: GC_UNRELATED_TYPES, type: GC, category: CORRECTNESS<br>This call to a generic collection method contains an argument with an incompatible class from that of the collection’s parameter (i.e., the type of the argument is neither a supertype nor a subtype of the corresponding generic type argument). Therefore, it is unlikely that the collection contains any objects that are equal to the method argument used here. Most likely, the wrong value is being passed to the method.<br>In general, instances of two unrelated classes are not equal. For example, if the Foo and Bar classes are not related by subtyping, then an instance of Foo should not be equal to an instance of Bar. Among other issues, doing so will likely result in an equals method that is not symmetrical. For example, if you define the Foo class so that a Foo can be equal to a String, your equals method isn’t symmetrical since a String can only be equal to a String.<br>In rare cases, people do define nonsymmetrical equals methods and still manage to make their code work. Although none of the APIs document or guarantee it, it is typically the case that if you check if a Collection<string> contains a Foo, the equals method of argument (e.g., the equals method of the Foo class) used to perform the equality checks.<br>原因分析：调用Collection类中的contains方法比较时，所比较的两个参数类型不致；</string></p>
<h5 id="7-6、-Null-pointer-dereference-in-method-on-exception-path"><a href="#7-6、-Null-pointer-dereference-in-method-on-exception-path" class="headerlink" title="7.6、       Null pointer dereference in method on exception path"></a>7.6、       Null pointer dereference in method on exception path</h5><p>id: NP_ALWAYS_NULL_EXCEPTION, type: NP, category: CORRECTNESS<br>A pointer which is null on an exception path is dereferenced here.  This will lead to a NullPointerException when the code is executed.  Note that because FindBugs currently does not prune infeasible exception paths, this may be a false warning.<br>Also note that FindBugs considers the default case of a switch statement to be an exception path, since the default case is often infeasible.<br>原因分析：在异常处理时，调用一个空对象的方法时可能引起空指针异常。</p>
<h5 id="7-7、-Nullcheck-of-value-previously-dereferenced"><a href="#7-7、-Nullcheck-of-value-previously-dereferenced" class="headerlink" title="7.7、       Nullcheck of value previously dereferenced"></a>7.7、       Nullcheck of value previously dereferenced</h5><p>id: RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE, type:RCN, category: CORRECTNESS<br>A value is checked here to see whether it is null, but this value can’t be null because it was previously dereferenced and if it were null a null pointer exception would have occurred at the earlier dereference. Essentially, this code and the previous dereference disagree as to whether this value is allowed to be null. Either the check is redundant or the previous dereference is erroneous.<br>原因分析：前面获取的对象，现在引用的时候没有交验是否为null。</p>
<h5 id="7-8、-Possible-null-pointer-dereference"><a href="#7-8、-Possible-null-pointer-dereference" class="headerlink" title="7.8、       Possible null pointer dereference"></a>7.8、       Possible null pointer dereference</h5><p>id: NP_NULL_ON_SOME_PATH, type: NP, category: CORRECTNESS<br>There is a branch of statement that, if executed, guarantees that a null value will be dereferenced, which would generate a NullPointerException when the code is executed. Of course, the problem might be that the branch or statement is infeasible and that the null pointer exception can’t ever be executed; deciding that is beyond the ability of FindBugs.<br>原因分析：可能存在空引用。</p>
<h5 id="7-9、-Possible-null-pointer-dereference-in-method-on-exception-path"><a href="#7-9、-Possible-null-pointer-dereference-in-method-on-exception-path" class="headerlink" title="7.9、       Possible null pointer dereference in method on exception path"></a>7.9、       Possible null pointer dereference in method on exception path</h5><p>id: NP_NULL_ON_SOME_PATH_EXCEPTION, type: NP, category:CORRECTNESS<br>A reference value which is null on some exception control path is dereferenced here.  This may lead to a NullPointerException when the code is executed.  Note that because FindBugs currently does not prune infeasible exception paths, this may be a false warning.<br>Also note that FindBugs considers the default case of a switch statement to be an exception path, since the default case is often infeasible.<br>原因分析：<br>代码调用时， 遇到异常分支， 可能造成一个对象没有获得赋值依旧保持NULL空指针。 接下来如果对这个对象有引用， 可能造成NullPointerException 空指针异常。<br>例如：</p>
<h5 id="7-10、-Test-for-floating-point-equality"><a href="#7-10、-Test-for-floating-point-equality" class="headerlink" title="7.10、   Test for floating point equality"></a>7.10、   Test for floating point equality</h5><p>id: FE_FLOATING_POINT_EQUALITY, type: FE, category: STYLE<br>This operation compares two floating point values for equality. Because floating point calculations may involve rounding, calculated float and double values may not be accurate. For values that must be precise, such as monetary values, consider using a fixed-precision type such as BigDecimal. For values that need not be precise, consider comparing for equality within some range, for example: if ( Math.abs(x - y) &lt; .0000001 ). See the java Language Specification, section 4.2.4.<br>原因分析：<br>Float类型的数据比较时，会存在的定的误差值，用!=来比较不是很准确，建议比较两个数的绝对值是否在一定的范围内来进行比较。如，if ( Math.abs(x - y) &lt; .0000001 )<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    return ResultVo.valueOfError(&quot;订单编号&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="7-11、-Useless-assignment-in-return-statement"><a href="#7-11、-Useless-assignment-in-return-statement" class="headerlink" title="7.11、   Useless assignment in return statement"></a>7.11、   Useless assignment in return statement</h5><p>id: DLS_DEAD_LOCAL_STORE_IN_RETURN, type: DLS, category: STYLE<br>This statement assigns to a local variable in a return statement. This assignment has effect. Please verify that this statement does the right thing.<br>原因分析：<br>在return的对象中，没有必要通过对象赋值再进行返回。<br>例如：</p>
<figure class="highlight plain"><figcaption><span>daoValue </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(lxrCpdlVoList.size()==0)&#123;</span><br><span class="line">    return daoValue = DAOValue.valueof(true,1,&quot;没有批量删除联系人业务大类信息失败&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="7-12、-Write-to-static-field-from-instance-method"><a href="#7-12、-Write-to-static-field-from-instance-method" class="headerlink" title="7.12、   Write to static field from instance method"></a>7.12、   Write to static field from instance method</h5><p>id: ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD, type: ST, category:STYLE<br>This instance method writes to a static field. This is tricky to get correct if multiple instances are being manipulated, and generally bad practice.<br>原因分析：向static字段中写入值。<br>例如：<br><figure class="highlight plain"><figcaption><span>static DBRBO dbrBO; </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> public final void refresh() &#123; </span><br><span class="line">        danskeBankBO = null; </span><br><span class="line">        dbrBO = null; </span><br><span class="line">        fileAndPathBO = null; </span><br><span class="line">    &#125;</span><br><span class="line">``` </span><br><span class="line">建议改为：去掉static。</span><br><span class="line">##### 7.13、   Incorrect lazy initialization and update of static field</span><br><span class="line">id: LI_LAZY_INIT_UPDATE_STATIC, type: LI, category: MT_CORRECTNESS</span><br><span class="line">This method contains an unsynchronized lazy initialization of a static field. After the field is set, the object stored into that location is further updated or accessed. The setting of the field is visible to other threads as soon as it is set. If the futher accesses in the method that set the field serve to initialize the object, then you have a very seriousmultithreading bug, unless something else prevents any other thread from accessing the stored object until it is fully initialized.</span><br><span class="line">Even if you feel confident that the method is never called by multiple threads, it might be better to not set the static field until the value you are setting it to is fully populated/initialized.</span><br><span class="line">原因分析：</span><br><span class="line">该方法的初始化中包含了一个迟缓初始化的静态变量。你的方法引用了一个静态变量，估计是类静态变量，那么多线程调用这个方法时，你的变量就会面临线程安全的问题了，除非别的东西阻止任何其他线程访问存储对象从直到它完全被初始化。</span><br><span class="line">##### 7.14、   Method ignores return value</span><br><span class="line">id: RV_RETURN_VALUE_IGNORED, type: RV, category: CORRECTNESS</span><br><span class="line">The return value of this method should be checked. One common cause of this warning is to invoke a method on an immutable object, thinking that it updates the object. For example, in the following code fragment,</span><br><span class="line">String dateString = getHeaderField(name);</span><br><span class="line">dateString.trim();</span><br><span class="line">the programmer seems to be thinking that the trim() method will update the String referenced by dateString. But since Strings are immutable, the trim() function returns a new String value, which is being ignored here. The code should be corrected to:</span><br><span class="line">String dateString = getHeaderField(name);</span><br><span class="line">dateString = dateString.trim();</span><br><span class="line">原因分析：方法忽略了设置返回值。</span><br><span class="line">例如：</span><br><span class="line"> </span><br><span class="line">```String dateString = getHeaderField(name);</span><br><span class="line">    dateString.trim();</span><br><span class="line">    </span><br><span class="line">    if(CustomActionEnum.Agee_SRT.equals(operationType)||CustomActionEnum.DISSAgee_SRT.equals(operationType)&#123;</span><br><span class="line">        //....</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="7-15、-Method-might-ignore-exception"><a href="#7-15、-Method-might-ignore-exception" class="headerlink" title="7.15、   Method might ignore exception"></a>7.15、   Method might ignore exception</h5><p>id: DE_MIGHT_IGNORE, type: DE, category: BAD_PRACTICE<br>This method might ignore an exception.Â  In general, exceptions should be handled or reported in some way, or they should be thrown out of the method.<br>原因分析：应该将异常 处理、打印或者抛出<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    //....</span><br><span class="line">&#125;catch(Exception e)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="7-16、-Unwritten-field"><a href="#7-16、-Unwritten-field" class="headerlink" title="7.16、   Unwritten field"></a>7.16、   Unwritten field</h5><p>id: UWF_UNWRITTEN_FIELD, type: UwF, category: CORRECTNESS<br>This field is never written.Â  All reads of it will return the default value. Check for errors (should it have been initialized?), or remove it if it is useless.<br>原因分析：从未被初始化的变量，调用它时，将返回默认值，要么初始化，要么删掉它。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    //....</span><br><span class="line">&#125;catch(Exception e)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="7-17、-Value-is-null-and-guaranteed-to-be-dereferenced-on-exception-path"><a href="#7-17、-Value-is-null-and-guaranteed-to-be-dereferenced-on-exception-path" class="headerlink" title="7.17、   Value is null and guaranteed to be dereferenced on exception path"></a>7.17、   Value is null and guaranteed to be dereferenced on exception path</h5><p>id: NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH, type: NP, category:CORRECTNESS<br>There is a statement or branch on an exception path that if executed guarantees that a value is null at this point, and that value that is guaranteed to be dereferenced (except on forward paths involving runtime exceptions).<br>原因分析：exception分支上，存在引用一个null对象的方法，引发空指针异常。<br>例如：<br><figure class="highlight plain"><figcaption><span>out </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    response.setContentType(&quot;text/html;charset=GBK&quot;);</span><br><span class="line">    response.setHeader(&quot;Cache-Control;no-cache&quot;);</span><br><span class="line">    out = response.getWriter();</span><br><span class="line">    out.flush();</span><br><span class="line">&#125;catch(Exception ex)&#123;</span><br><span class="line">    logger.debug(&quot;获取树的XML代码出错。&quot;+ex.getMessage());</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">    out.close();//out可能为空</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="7-18、-Very-confusing-method-names"><a href="#7-18、-Very-confusing-method-names" class="headerlink" title="7.18、   Very confusing method names"></a>7.18、   Very confusing method names</h5><p>id: NM_VERY_CONFUSING, type: Nm, category: CORRECTNESS<br>The referenced methods have names that differ only by capitalization. This is very confusing because if the capitalization were identical then one of the methods would override the other.<br>原因分析：被引用的方法中存在容易混淆的变量。<br>例如：fzgsdm改成 fzgsDm 即可。</p>
<figure class="highlight plain"><figcaption><span>String getFzgsdm() &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    return getFzgsdm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="7-19、-Method-invokes-inefficient-new-String-constructor"><a href="#7-19、-Method-invokes-inefficient-new-String-constructor" class="headerlink" title="7.19、   Method invokes inefficient new String() constructor"></a>7.19、   Method invokes inefficient new String() constructor</h5><p>id: DM_STRING_VOID_CTOR, type: Dm, category: Performance Creating a new java.lang.String object using the no-argument constructor wastes memory because the object so created will be functionally indistinguishable from the empty string constant “”.  Java guarantees that identical string constants will be represented by the same String object.  Therefore, you should just use the empty string constant directly.<br>原因分析：不使用new String()定义空的字符串<br>例如：</p>
<figure class="highlight plain"><figcaption><span>alarmCodeCond </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">应当</span><br><span class="line">String alarmCodeCond = &quot;&quot;;</span><br><span class="line">```      </span><br><span class="line"></span><br><span class="line">##### 7.20、   Load of known null value</span><br><span class="line">id: NP_LOAD_OF_KNOWN_NULL_VALUE, type: Np, category: Dodgy</span><br><span class="line">The variable referenced at this point is known to be null due to an earlier check against null. Although this is valid, it might be a mistake (perhaps you intended to refer to a different variable, or perhaps the earlier check to see if the variable is null should have been a check to see if it was nonnull).</span><br><span class="line">原因分析：null值的不当使用。</span><br><span class="line">例如：</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">if(devIds ==null &amp;&amp; devIds.size()==0)&#123; //.....&#125; </span><br><span class="line"></span><br><span class="line">if(null ==tempList||tempList.size()!=0)&#123; //.....&#125;</span><br><span class="line"></span><br><span class="line">if(batchNo ==null)&#123;</span><br><span class="line">   throw new Exception(&quot;the No. &quot;+batchNo + &quot;is not exists1&quot;）)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="7-21、-Method-concatenates-strings-using-in-a-loop"><a href="#7-21、-Method-concatenates-strings-using-in-a-loop" class="headerlink" title="7.21、   Method concatenates strings using + in a loop"></a>7.21、   Method concatenates strings using + in a loop</h5><p>id: SBSC_USE_STRINGBUFFER_CONCATENATION, type: SBSC, category: Performance<br>The method seems to be building a String using concatenation in a loop. In each iteration, the String is converted to a StringBuffer/StringBuilder, appended to, and converted back to a String. This can lead to a cost quadratic in the number of iterations, as the growing string is recopied in each iteration. Better performance can be obtained by using a StringBuffer (or StringBuilder in Java 1.5) explicitly.<br>For example:<br>  // This is bad<br>  String s = “”;<br>  for (int i = 0; i &lt; field.length; ++i) {<br>    s = s + field[i];<br>  }<br>  // This is better<br>  StringBuffer buf = new StringBuffer();<br>  for (int i = 0; i &lt; field.length; ++i) {<br>    buf.append(field[i]);<br>  }<br>  String s = buf.toString();<br>原因分析：在循环里使用字符串连接，效率低，应该使用StringBuilder/StringBuffer</p>
<h3 id="Bug列表"><a href="#Bug列表" class="headerlink" title="Bug列表"></a>Bug列表</h3><h4 id="BUG-0001"><a href="#BUG-0001" class="headerlink" title="BUG-0001"></a>BUG-0001</h4><p>Bug: Field only ever set to null: com.bettersoft.admin.BtCorpManager.ps<br>All writes to this field are of the constant value null, and thus all reads of the field will return null. Check for errors, or remove it if it is useless.<br>Confidence: Normal, Rank: Troubling (12)<br>Pattern: UWF_NULL_FIELD<br>Type: UwF, Category: CORRECTNESS (Correctness)<br>代码片段：、<br><figure class="highlight plain"><figcaption><span>class BtCorpManager &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private BtCorp btcorp=null;</span><br><span class="line">private Connection con = null;</span><br><span class="line">private Statement st = null;</span><br><span class="line">private PreparedStatement ps = null;</span><br><span class="line">private ResultSet rs = null;</span><br><span class="line">private void setConnection(String centerno) throws Exception&#123;</span><br><span class="line">    //con = DBManager.getConnection(centerno);</span><br><span class="line">    con = DBManager.getConnection();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>解释说明：在BtCorpManager类里面定了一个私有的成员变量PreparedStatement ps,但是这个成员变量ps在实例范围内没有得到任何的初始化(采用默认的构造方法)，始终为null,所以在实例范围内使用该成员变量时，如果不先对其进行初始化操作或者无意识的行为忘了初始化操作，那肯定是要报空指针异常，所以这无疑是一个bug<br>推荐修改： 自己看着办</p>
<h4 id="BUG-0002"><a href="#BUG-0002" class="headerlink" title="BUG-0002"></a>BUG-0002</h4><p>Bug: Nullcheck of form at line 36 of value previously dereferenced in com.bettersoft.admin.CorpEditAction.execute(ActionMapping, ActionForm, HttpServletRequest, HttpServletResponse)<br>A value is checked here to see whether it is null, but this value can’t be null because it was previously dereferenced and if it were null a null pointer exception would have occurred at the earlier dereference. Essentially, this code and the previous dereference disagree as to whether this value is allowed to be null. Either the check is redundant or the previous dereference is erroneous.<br>Confidence: High, Rank: Scary (9)<br>Pattern: RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE<br>Type: RCN, Category: CORRECTNESS (Correctness)<br>代码片段：</p>
<figure class="highlight plain"><figcaption><span>ActionForward execute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//throw new UnsupportedOperationException(&quot;Method is not implemented&quot;);</span><br><span class="line">ActionErrors errors = new ActionErrors();</span><br><span class="line">CreateCorpActionForm createCorp = new CreateCorpActionForm();</span><br><span class="line">createCorp = (CreateCorpActionForm)form;</span><br><span class="line">CreateCorpActionForm webcorp=new CreateCorpActionForm();</span><br><span class="line">BudgetWebcorpManager budgetWebcorpManager=new BudgetWebcorpManager();</span><br><span class="line">webcorp=budgetWebcorpManager.getCWebcorp(createCorp.getId());</span><br><span class="line">createCorp.setFbsaddapproveid(webcorp.getFbsaddapproveid());</span><br><span class="line">createCorp.setFbsinputapproveid(webcorp.getFbsinputapproveid());</span><br><span class="line">createCorp.setFbsprocessapproveid(webcorp.getFbsprocessapproveid());</span><br><span class="line"> </span><br><span class="line">boolean b=false;</span><br><span class="line">if(createCorp!=null)&#123;</span><br></pre></td></tr></table></figure>
<p>解释说明：注意到有个局部变量 CreateCorpActionForm createCorp;再看下它的初始化过程，先是通过new给它分配了内存空间，紧接着有让它引用了了另一个未知的变量，这里说未知是指这个新的引用可能为空，显然 createCorp有可能指向一个空的地址，所以在接下来的引用中极可能报空指针异常（在引用之前不进行判空操作的话）！ 在接下来的代码，如下<br><code>if(createCorp!=null){</code><br>其实也就没有存在的必要，因为如果为空的话，上面这行代码根本不可能执行到，所以findbug说这是冗余的空指针检查。当然考虑到特殊情况，这里显然是struts1的action,所以只要web应用正常启动，通常以下代码</p>
<p><code>createCorp = (CreateCorpActionForm)form;</code></p>
<p>是不会导致createCorp指向空的，唯一的缺陷就是之前的new操作是多余的。<br>推荐修改：自己看着办</p>
<h4 id="BUG-0003"><a href="#BUG-0003" class="headerlink" title="BUG-0003"></a>BUG-0003</h4><p>Bug: con is null guaranteed to be dereferenced in com.bettersoft.admin.leftAction.getLeft(int, String, String) on exception path<br>There is a statement or branch on an exception path that if executed guarantees that a value is null at this point, and that value that is guaranteed to be dereferenced (except on forward paths involving runtime exceptions).<br>Confidence: Normal, Rank: (Troubling 11)<br>Pattern: NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH<br>Type: NP, Category: CORRECTNESS (Correctness)<br>代码片段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">        if(rs != null)</span><br><span class="line">            rs.close();</span><br><span class="line">        if(ps!=null)</span><br><span class="line">            ps.close();</span><br><span class="line">        con.close();</span><br><span class="line">    &#125;catch(Exception ee)</span><br><span class="line">    &#123;</span><br><span class="line">        ee.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释说明：这应该是大家很熟悉的代码片段了，可以想象Connection con是在catch代码块中进行的初始化操作，findbug对该bug说的很明白，说如果出现异常，Connection con将保证为空，因为很显然如果出现异常，con将得不到正确的初始化，即便初始化了，因为异常的出现，引用也会被解除，回到一开始定义处的null状态，那么在这里的finally代码块中调用Connection con的close()方法，将报空指针异常<br>推荐修改：自己看着办 </p>
<h4 id="BUG-0004"><a href="#BUG-0004" class="headerlink" title="BUG-0004"></a>BUG-0004</h4><p>Bug: Possible null pointer dereference of dbVersion in com.bettersoft.admin.LoginAction.loadVersion(HttpServletRequest, ActionErrors) on exception path<br>A reference value which is null on some exception control path is dereferenced here. This may lead to aNullPointerExceptionwhen the code is executed. Note that because FindBugs currently does not prune infeasible exception paths, this may be a false warning.<br>Also note that FindBugs considers the default case of a switch statement to be an exception path, since the default case is often infeasible.<br>Confidence: Normal, Rank: Troubling (11)<br>Pattern: NP_NULL_ON_SOME_PATH_EXCEPTION<br>Type: NP, Category: CORRECTNESS (Correctness)<br>代码片段：</p>
<figure class="highlight plain"><figcaption><span>dbVersion </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    try &#123;</span><br><span class="line">        con = DBManager.getConnection();</span><br><span class="line">        dbVersion = vm.getVersionInfo(con);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        // TODO Auto-generated catch block</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            con.close();</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            // TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">if (dbVersion.equals(programVersion)) &#123;</span><br><span class="line">    programVersion.setCorrent(true);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    programVersion.setCorrent(false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释说明：如果try catch 中捕获异常，那么dbVersion将为空， </p>
<p><code>dbVersion.equals(programVersion)</code></p>
<p>上面这行代码，将报空指针异常 </p>
<h4 id="BUG-0005"><a href="#BUG-0005" class="headerlink" title="BUG-0005"></a>BUG-0005</h4><p>Bug: Dead store to am in com.bettersoft.approve.action.CheckAction.execute(ActionMapping, ActionForm, HttpServletRequest, HttpServletResponse)<br>This instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used.<br>Note that Sun’s javac compiler often generates dead stores for final local variables. Because FindBugs is a bytecode-based tool, there is no easy way to eliminate these false positives.<br>Confidence: High, Rank: Of Concern (15)<br>Pattern: DLS_DEAD_LOCAL_STORE<br>Type: DLS, Category: STYLE (Dodgy code)<br>代码片段：</p>
<p><code>ApproveManager am = new ApproveManager();</code></p>
<p>解释说明：am这个局部变量创建出来后，没有在任何地方被引用。这里确实没有被引用，所以是个bug,但是findbug又说明了，这有可能是误报，因为javac编译器在编译局部常量时，也会产生dead stroes。所以这个要视情况而定，不能过于纠结 </p>
<h4 id="BUG-0006"><a href="#BUG-0006" class="headerlink" title="BUG-0006"></a>BUG-0006</h4><p>Bug: The class name com.bettersoft.approve.form.BtWebCorp shadows the simple name of the superclass com.bettersoft.admin.BtWebCorp<br>This class has a simple name that is identical to that of its superclass, except that its superclass is in a different package (e.g.,alpha.Fooextendsbeta.Foo). This can be exceptionally confusing, create lots of situations in which you have to look at import statements to resolve references and creates many opportunities to accidently define methods that do not override methods in their superclasses.<br>Confidence: High, Rank: Troubling (14)<br>Pattern: NM_SAME_SIMPLE_NAME_AS_SUPERCLASS<br>Type: Nm, Category: BAD_PRACTICE (Bad practice)<br>代码片段： </p>
<figure class="highlight plain"><figcaption><span>class BtWebCorp extends com.bettersoft.admin.BtWebCorp&#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释说明：这里子类和父类名称一样，findbug认为这回导致很多混淆。显然一旦出问题，将很难发现，运行结果将出乎意料 </p>
<h4 id="BUG-0007"><a href="#BUG-0007" class="headerlink" title="BUG-0007"></a>BUG-0007</h4><p>Bug: Comparison of String objects using == or != in com.byttersoft.admin.persistence.dao.MessageOpenDao.addOpenSave(MessageOpenForm)<br>This code comparesjava.lang.Stringobjects for reference equality using the == or != operators. Unless both strings are either constants in a source file, or have been interned using theString.intern()method, the same string value may be represented by two different String objects. Consider using theequals(Object)method instead.<br>Confidence: Normal, Rank: Troubling (11)<br>Pattern: ES_COMPARING_STRINGS_WITH_EQ<br>Type: ES, Category: BAD_PRACTICE (Bad practice)<br>代码片段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">        sql = &quot;insert into xx values (1,?,?,?)&quot;;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">        sql = &quot;insert into xx values ((select max(id) + 1 from xx),?,?,?)&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释说明： 直接使用==进行对象实例比较，而没有使用equals,本来没觉得这个bug咋样，但是发现项目里居然最多的bug就是这个，不管是很多年前的代码还是最近的代码，都存在这大量这样的问题。看来这是一个通病，所以大家注意一下，不光是我们公司的项目有这样的问题，这应该是一个普遍的问题，尤其实在比较String类型的时候，注意只要不是java基本类型都需要使用equals进行比较，哪怕是自动解封的Integer，Double等</p>
<h4 id="BUG-0008"><a href="#BUG-0008" class="headerlink" title="BUG-0008"></a>BUG-0008</h4><p>Bug: Call to String.equals(Double) in com.byttersoft.amm.util.BalanceInterzoneRateUtil.formatRate(Double)<br>This method calls equals(Object) on two references of different class types with no common subclasses. Therefore, the objects being compared are unlikely to be members of the same class at runtime (unless some application classes were not analyzed, or dynamic class loading can occur at runtime). According to the contract of equals(), objects of different classes should always compare as unequal; therefore, according to the contract defined by Java.lang.Object.equals(Object), the result of this comparison will always be false at runtime.<br>Confidence: High, Rank: Scariest (1)<br>Pattern: EC_UNRELATED_TYPES<br>Type: EC, Category: CORRECTNESS (Correctness)<br>代码片段：<br><figure class="highlight plain"><figcaption><span>static String  formatRate(Double r)&#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">if(r==null ||  (&quot;undefined&quot;).equals(r))&#123;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>解释说明：使用equals比较不同类型的数据，”undefined”是String类型，r是Double类型，这两个比较肯定返回false</p>
<p><code>(&quot;undefined&quot;).equals(r)</code></p>
<p>上面这行代码完全没有必要 ，不可能存在这种情况</p>
<h4 id="BUG-0009"><a href="#BUG-0009" class="headerlink" title="BUG-0009"></a>BUG-0009</h4><p>Bug: Class com.byttersoft.util.CertInfo defines non-transient non-serializable instance field subjectDnAttr<br>This Serializable class defines a non-primitive instance field which is neither transient, Serializable, orjava.lang.Object, and does not appear to implement theExternalizableinterface or thereadObject()andwriteObject()methods. Objects of this class will not be deserialized correctly if a non-Serializable object is stored in this field.<br>Confidence: High, Rank: Troubling (14)<br>Pattern: SE_BAD_FIELD<br>Type: Se, Category: BAD_PRACTICE (Bad practice)<br>代码片段： </p>
<figure class="highlight plain"><figcaption><span>class CertInfo implements java.io.Serializable</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    private String subjectDN=&quot;&quot;;</span><br><span class="line">    private String issuerDN=&quot;&quot;;</span><br><span class="line">    private String notAfterDate=&quot;&quot;;</span><br><span class="line">    private String notBeforeDate=&quot;&quot;;</span><br><span class="line">    private String serialNumber=&quot;&quot;;</span><br><span class="line">    private String sigAlgName=&quot;&quot;;</span><br><span class="line">    private String sigAlgOID=&quot;&quot;;</span><br><span class="line">    private String version=&quot;&quot;;</span><br><span class="line">    private String publicKeyFormat=&quot;&quot;;</span><br><span class="line">    private String publicKeyAlgorithm=&quot;&quot;;</span><br><span class="line">    private Names subjectDnAttr=null;</span><br><span class="line">｝</span><br><span class="line">public class Names</span><br><span class="line">&#123;&#125;&lt;span&gt;&lt;/span&gt;</span><br></pre></td></tr></table></figure>
<p>解释说明： CertInfo实现的序列话，但是他的成员变量Names subjectDnAttr没有实现序列化，这将会导致序列化失败，String已经默认实现了序列化。注意，序列化时所有的成员变量都必须递归的实现序列化，否则将导致序列化失败。如果某个成员变量不想被序列化要么标注为瞬态要么重写readObj方法</p>
<h4 id="BUG-0010"><a href="#BUG-0010" class="headerlink" title="BUG-0010"></a>BUG-0010</h4><p>Bug: Dead store to corpGourps rather than field with same name in com.byttersoft.admin.form.CorpGroupsForm.setCorpGourps(CorpGourps)<br>This instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used. There is a field with the same name as the local variable. Did you mean to assign to that variable instead?<br>Confidence: High, Rank: Scary (9)<br>Pattern: DLS_DEAD_LOCAL_STORE_SHADOWS_FIELD<br>Type: DLS, Category: STYLE (Dodgy code)<br>代码片段： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void setCorpGourps(CorpGourps corpGourps) &#123;</span><br><span class="line">        corpGourps = corpGourps;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>解释说明：成员变量和局部变量重名</p>
<h4 id="BUG-0011"><a href="#BUG-0011" class="headerlink" title="BUG-0011"></a>BUG-0011</h4><p>Bug: Invocation of toString on labelValue in com.byttersoft.approve.persistence.dao.MesAppDao.getMapByPara(String)<br>The code invokes toString on an array, which will generate a fairly useless result such as [C@16f0472. Consider using Arrays.toString to convert the array into a readable String that gives the contents of the array. See Programming Puzzlers, chapter 3, puzzle 12.<br>Confidence: Normal, Rank: Troubling (10)<br>Pattern: DMI_INVOKING_TOSTRING_ON_ARRAY<br>Type: USELESS_STRING, Category: CORRECTNESS (Correctness)<br>代码片段：</p>
<figure class="highlight plain"><figcaption><span>(String parameter : parameters) &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    String[] labelValue = parameter.split(&quot;=&quot;);</span><br><span class="line">    if (labelValue.length == 2) &#123;</span><br><span class="line">        String key = labelValue[0];</span><br><span class="line">        String value = labelValue[1];</span><br><span class="line">        hashMap.put(key, value);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        logger.debug(&quot;参数 &quot; + labelValue + &quot; 配置错误。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释说明：在进行日志输出时，直接输出对象，将默认调用对象的toString方法，而默认是输出对象的内存地址，所以这里显然有问题，本意应该是输出数组中的字符串 </p>
<h4 id="BUG-0012"><a href="#BUG-0012" class="headerlink" title="BUG-0012"></a>BUG-0012</h4><p>Bug: Write to static field com.byttersoft.admin.service.BtSysResService.map from instance method com.byttersoft.admin.service.BtSysResService.hashCatchOfSysRes(boolean)<br>This instance method writes to a static field. This is tricky to get correct if multiple instances are being manipulated, and generally bad practice.<br>Confidence: High, Rank: Of Concern (15)<br>Pattern: ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD<br>Type: ST, Category: STYLE (Dodgy code)<br>代码片段： </p>
<figure class="highlight plain"><figcaption><span>Map<string, btsysres=""> map </string,></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public Map&lt;String, BtSysRes&gt; hashCatchOfSysRes(boolean isRefresh) &#123;</span><br><span class="line">        if(isRefresh == true)&#123;</span><br><span class="line">            map = hashCatchOfSysRes();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            if(map == null || map.isEmpty())&#123;</span><br><span class="line">                map = hashCatchOfSysRes();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return map;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>解释说明：在实例方法中修改类变量的引用，这会导致共享问题，因为其他实例也会访问该静态变量，但是却不知道某个实例已经修改了该静态变量的引用，导致不可预知的问题<br>推荐修改：将该方法改为类方法</p>
<h4 id="BUG-0013"><a href="#BUG-0013" class="headerlink" title="BUG-0013"></a>BUG-0013</h4><p>Bug: Unwritten field: com.byttersoft.admin.service.importservice.ImportServices.bank<br>This field is never written. All reads of it will return the default value. Check for errors (should it have been initialized?), or remove it if it is useless.<br>Confidence: Normal, Rank: Troubling (12)<br>Pattern: UWF_UNWRITTEN_FIELD<br>Type: UwF, Category: CORRECTNESS (Correctness)<br>代码片段：</p>
<figure class="highlight plain"><figcaption><span>class ImportServices &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private IBankAccServices bank;</span><br><span class="line">public IBankAccServices getBank() &#123;</span><br><span class="line">        return bank;</span><br><span class="line">    &#125;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p>解释说明： bank对象为空，getBank方法返回了一个肯定为空的对象实例</p>
<h4 id="BUG-0014"><a href="#BUG-0014" class="headerlink" title="BUG-0014"></a>BUG-0014</h4><p>Bug: There is an apparent infinite recursive loop in com.byttersoft.amm.dao.impl.CheckLoanOrProvideInfoDaoImpl.addBatch(List)<br>This method unconditionally invokes itself. This would seem to indicate an infinite recursive loop that will result in a stack overflow.<br>Confidence: High, Rank: Scary (9)<br>Pattern: IL_INFINITE_RECURSIVE_LOOP<br>Type: IL, Category: CORRECTNESS (Correctness)<br>代码片段：<br><figure class="highlight plain"><figcaption><span>void addBatch(List<cmsploantobean> cmsPLoanBeans) &#123;</cmsploantobean></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    this.addBatch(cmsPLoanBeans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>解释说明：出现了递归调用addBatch,将出现死循环</p>
<h3 id="High"><a href="#High" class="headerlink" title="High"></a>High</h3><h4 id="1-DM-DEFAULT-ENCODING"><a href="#1-DM-DEFAULT-ENCODING" class="headerlink" title="1.DM_DEFAULT_ENCODING"></a>1.DM_DEFAULT_ENCODING</h4><h5 id="1-1-Found-reliance-on-default-encoding-in-com-cmcc-aoi-httprequest-service-HttpRequest-sendGet-String-String-new-java-io-InputStreamReader-InputStream"><a href="#1-1-Found-reliance-on-default-encoding-in-com-cmcc-aoi-httprequest-service-HttpRequest-sendGet-String-String-new-java-io-InputStreamReader-InputStream" class="headerlink" title="1.1 Found reliance on default encoding in com.cmcc.aoi.httprequest.service.HttpRequest.sendGet(String, String): new java.io.InputStreamReader(InputStream)"></a>1.1 Found reliance on default encoding in com.cmcc.aoi.httprequest.service.HttpRequest.sendGet(String, String): new java.io.InputStreamReader(InputStream)</h5><p>Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.</p>
<p>new BufferedReader(new InputStreamReader(connection.getInputStream()));</p>
<p>修改为： InputStreamReader fileData = new InputStreamReader(file ,”utf-8”);</p>
<h5 id="1-2-Found-reliance-on-default-encoding-in-com-cmcc-aoi-httprequest-service-HttpRequest-sendPost-String-JSONObject-new-java-io-PrintWriter-OutputStream"><a href="#1-2-Found-reliance-on-default-encoding-in-com-cmcc-aoi-httprequest-service-HttpRequest-sendPost-String-JSONObject-new-java-io-PrintWriter-OutputStream" class="headerlink" title="1.2 Found reliance on default encoding in com.cmcc.aoi.httprequest.service.HttpRequest.sendPost(String, JSONObject): new java.io.PrintWriter(OutputStream)"></a>1.2 Found reliance on default encoding in com.cmcc.aoi.httprequest.service.HttpRequest.sendPost(String, JSONObject): new java.io.PrintWriter(OutputStream)</h5><p>Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.<br>out = new PrintWriter(conn.getOutputStream());</p>
<p>修改为： out = new PrintWriter(new OutputStreamWriter(conn.getOutputStream(), “utf-8”));</p>
<h5 id="1-3-Found-reliance-on-default-encoding-in-com-cmcc-aoi-selfhelp-action-DeliverWebRequestAction-calculateUserCount-HttpServletRequest-String-getBytes"><a href="#1-3-Found-reliance-on-default-encoding-in-com-cmcc-aoi-selfhelp-action-DeliverWebRequestAction-calculateUserCount-HttpServletRequest-String-getBytes" class="headerlink" title="1.3 Found reliance on default encoding in com.cmcc.aoi.selfhelp.action.DeliverWebRequestAction.calculateUserCount(HttpServletRequest): String.getBytes()"></a>1.3 Found reliance on default encoding in com.cmcc.aoi.selfhelp.action.DeliverWebRequestAction.calculateUserCount(HttpServletRequest): String.getBytes()</h5><p>Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.<br>fileName = new String(req.getParameter(“fileName”).getBytes(), “UTF-8”);<br>修改为<br>fileName = new String(req.getParameter(“fileName”).getBytes(“UTF-8”), “UTF-8”);</p>
<h5 id="1-4-Found-reliance-on-default-encoding-in-com-cmcc-aoi-selfhelp-action-servlet-AoeRegAction-report-HttpServletRequest-HttpServletResponse-java-io-ByteArrayOutputStream-toString"><a href="#1-4-Found-reliance-on-default-encoding-in-com-cmcc-aoi-selfhelp-action-servlet-AoeRegAction-report-HttpServletRequest-HttpServletResponse-java-io-ByteArrayOutputStream-toString" class="headerlink" title="1.4 Found reliance on default encoding in com.cmcc.aoi.selfhelp.action.servlet.AoeRegAction.report(HttpServletRequest, HttpServletResponse): java.io.ByteArrayOutputStream.toString()"></a>1.4 Found reliance on default encoding in com.cmcc.aoi.selfhelp.action.servlet.AoeRegAction.report(HttpServletRequest, HttpServletResponse): java.io.ByteArrayOutputStream.toString()</h5><p>Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.<br>logger.info(“RECV STR: “ + baos.toString());<br>修改为<br>logger.info(“RECV STR: “ + baos.toString(“utf-8”));</p>
<h5 id="1-5-Found-reliance-on-default-encoding-in-com-cmcc-aoi-selfhelp-action-servlet-AoeUploadLogAction-report-HttpServletRequest-HttpServletResponse-new-java-io-FileWriter-File"><a href="#1-5-Found-reliance-on-default-encoding-in-com-cmcc-aoi-selfhelp-action-servlet-AoeUploadLogAction-report-HttpServletRequest-HttpServletResponse-new-java-io-FileWriter-File" class="headerlink" title="1.5 Found reliance on default encoding in com.cmcc.aoi.selfhelp.action.servlet.AoeUploadLogAction.report(HttpServletRequest, HttpServletResponse): new java.io.FileWriter(File)"></a>1.5 Found reliance on default encoding in com.cmcc.aoi.selfhelp.action.servlet.AoeUploadLogAction.report(HttpServletRequest, HttpServletResponse): new java.io.FileWriter(File)</h5><p>Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.<br>new FileWriter(f).append(baos.toString(“UTF-8”)).close();<br>修改为<br>BufferedWriter out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(f, true)));<br>out.write(baos.toString(“UTF-8”));<br>out.close();</p>
<p>BufferedWriter bw= new BufferedWriter( new OutputStreamWriter(new FileOutputStream(filePath, true), “utf-8”));</p>
<h5 id="1-6-Found-reliance-on-default-encoding-in-new-com-cmcc-aoi-util-TokenZipFileUtil-String-new-java-io-FileReader-String"><a href="#1-6-Found-reliance-on-default-encoding-in-new-com-cmcc-aoi-util-TokenZipFileUtil-String-new-java-io-FileReader-String" class="headerlink" title="1.6 Found reliance on default encoding in new com.cmcc.aoi.util.TokenZipFileUtil(String): new java.io.FileReader(String)"></a>1.6 Found reliance on default encoding in new com.cmcc.aoi.util.TokenZipFileUtil(String): new java.io.FileReader(String)</h5><p>Found a call to a method which will perform a byte to String (or String to byte) conversion, and will assume that the default platform encoding is suitable. This will cause the application behaviour to vary between platforms. Use an alternative API and specify a charset name or Charset object explicitly.<br>FileReader in = new FileReader(file);<br>改为<br>BufferedReader reader = new BufferedReader(new InputStreamReader(newFileInputStream(file), “UTF-8”)); </p>
<h4 id="2-MS-SHOULD-BE-FINAL"><a href="#2-MS-SHOULD-BE-FINAL" class="headerlink" title="2.MS_SHOULD_BE_FINAL"></a>2.MS_SHOULD_BE_FINAL</h4><p>com.cmcc.aoi.selfhelp.action.DeliverWebRequestAction.logger isn’t final but should be<br>This static field public but not final, and could be changed by malicious code or by accident from another package. The field could be made final to avoid this vulnerability.</p>
<p>protected static   Logger logger = LoggerFactory.getLogger(DeliverWebRequestAction.class);<br>修改为 protected static final Logger logger = LoggerFactory.getLogger(DeliverWebRequestAction.class);</p>
<h4 id="3-DLS-DEAD-LOCAL-STORE"><a href="#3-DLS-DEAD-LOCAL-STORE" class="headerlink" title="3.DLS_DEAD_LOCAL_STORE"></a>3.DLS_DEAD_LOCAL_STORE</h4><p>Dead store to s in com.cmcc.aoi.selfhelp.action.DeliverWebRequestAction.textSend(WebSendTextForm, HttpServletRequest)<br>This instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used.<br>Note that Sun’s javac compiler often generates dead stores for final local variables. Because FindBugs is a bytecode-based tool, there is no easy way to eliminate these false positives.<br>ShopMappingDeliver shopMappingDeliver = null;<br>删除即可</p>
<h4 id="4-ST-WRITE-TO-STATIC-FROM-INSTANCE-METHOD"><a href="#4-ST-WRITE-TO-STATIC-FROM-INSTANCE-METHOD" class="headerlink" title="4.ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD"></a>4.ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD</h4><p>Write to static field com.cmcc.aoi.selfhelp.action.MultipleMediaAoeAction.linkRoot from instance method com.cmcc.aoi.selfhelp.action.MultipleMediaAoeAction.afterPropertiesSet()<br>This instance method writes to a static field. This is tricky to get correct if multiple instances are being manipulated, and generally bad practice.<br>linkRoot = sysConfigService.getDomainName() + “/“;<br>修改改为：<br><figure class="highlight plain"><figcaption><span>static String getLinkRoot() &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">        returnlinkRoot;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    publicstaticvoid setLinkRoot(String linkRoot) &#123;</span><br><span class="line">        MultipleMediaAoeAction.linkRoot = linkRoot;</span><br><span class="line">    &#125;</span><br><span class="line">   MultipleMediaAoeAction.setLinkRoot(sysConfigService.getDomainName() + &quot;/&quot;);</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">#### 5. J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION</span><br><span class="line">Store of non serializable com.cmcc.aoi.selfhelp.action.UploadFileAction$FileUploadStatus into HttpSession in new com.cmcc.aoi.selfhelp.action.UploadFileAction$MyProgressListener(UploadFileAction, HttpServletRequest)</span><br><span class="line">This code seems to be storing a non-serializable object into an HttpSession. If this session is passivated or migrated, an error will result.</span><br><span class="line">修改为 FileUploadStatus implements Serializable</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#### 6.  RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE</span><br><span class="line">Redundant nullcheck of rtr, which is known to be non-null in com.cmcc.aoi.selfhelp.action.servlet.AoeReportApplistAction.device(HttpServletRequest, HttpServletResponse)</span><br><span class="line">This method contains a redundant check of a known non-null value against the constant null.</span><br><span class="line">```if (rtr != null) &#123;</span><br><span class="line">            Writer writer;</span><br><span class="line">            try &#123;</span><br><span class="line">                writer = response.getWriter();</span><br><span class="line">                if (rtr != null) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line"> </span><br><span class="line">                        String s = JSONUtil.objToJson(rtr);</span><br><span class="line">                        if (LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">                            LOGGER.debug(&quot;SEND STR: &quot; + s);</span><br><span class="line">                        &#125;</span><br><span class="line">                        writer.write(s);</span><br><span class="line">                        writer.flush();</span><br><span class="line">                    &#125; catch (IOException e) &#123;</span><br><span class="line">                        LOGGER.warn(&quot;&quot;, e);</span><br><span class="line">                        if (writer != null) &#123;</span><br><span class="line">                            try &#123;</span><br><span class="line">                                writer.write(JSONUtil.objToJson(rtr));</span><br><span class="line">                            &#125; catch (IOException e1) &#123;</span><br><span class="line">                                LOGGER.warn(&quot;&quot;, e1);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    response.getWriter().write(&quot;&#123;\&quot;errorCode\&quot;:401&#125;&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (IOException e2) &#123;</span><br><span class="line">                LOGGER.warn(&quot;&quot;, e2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>修改为<br><figure class="highlight plain"><figcaption><span>(rtr !</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    Writer writer;</span><br><span class="line">    try &#123;</span><br><span class="line">        writer = response.getWriter();</span><br><span class="line">        try &#123;</span><br><span class="line"> </span><br><span class="line">            String s = JSONUtil.objToJson(rtr);</span><br><span class="line">            if (LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">                LOGGER.debug(&quot;SEND STR: &quot; + s);</span><br><span class="line">            &#125;</span><br><span class="line">            writer.write(s);</span><br><span class="line">            writer.flush();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            LOGGER.warn(&quot;&quot;, e);</span><br><span class="line">            if (writer != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    writer.write(JSONUtil.objToJson(rtr));</span><br><span class="line">                &#125; catch (IOException e1) &#123;</span><br><span class="line">                    LOGGER.warn(&quot;&quot;, e1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125; catch (IOException e2) &#123;</span><br><span class="line">        LOGGER.warn(&quot;&quot;, e2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    response.getWriter().write(&quot;&#123;\&quot;errorCode\&quot;:401&#125;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="7-RU-INVOKE-RUN"><a href="#7-RU-INVOKE-RUN" class="headerlink" title="7. RU_INVOKE_RUN"></a>7. RU_INVOKE_RUN</h4><p>com.cmcc.aoi.selfhelp.action.servlet.UploadTokensAction$TokenFileThread.run() explicitly invokes run on a thread (did you mean to start it instead?)<br>This method explicitly invokes run() on an object.  In general, classes implement the Runnable interface because they are going to have their run() method invoked in a new thread, in which case Thread.start() is the right method to call.</p>
<p><code>ti.run();</code><br>修改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    ti.join();</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">     e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-NM-SAME-SIMPLE-NAME-AS-SUPERCLASS"><a href="#8-NM-SAME-SIMPLE-NAME-AS-SUPERCLASS" class="headerlink" title="8. NM_SAME_SIMPLE_NAME_AS_SUPERCLASS"></a>8. NM_SAME_SIMPLE_NAME_AS_SUPERCLASS</h4><p>The class name com.cmcc.aoi.selfhelp.dao.BaseDao shadows the simple name of the superclass org.slave4j.orm.hibernate.BaseDao<br>This class has a simple name that is identical to that of its superclass, except that its superclass is in a different package (e.g., alpha.Foo extends beta.Foo). This can be exceptionally confusing, create lots of situations in which you have to look at import statements to resolve references and creates many opportunities to accidentally define methods that do not override methods in their superclasses<br>com.cmcc.aoi.selfhelp.dao.BaseDao<br>修改为<br>com.cmcc.aoi.selfhelp.dao.BasisDao</p>
<h4 id="9-SE-BAD-FIELD-INNER-CLASS"><a href="#9-SE-BAD-FIELD-INNER-CLASS" class="headerlink" title="9. SE_BAD_FIELD_INNER_CLASS"></a>9. SE_BAD_FIELD_INNER_CLASS</h4><p>com.cmcc.aoi.selfhelp.action.UploadFileAction$FileUploadStatus is serializable but also an inner class of a non-serializable class<br>This Serializable class is an inner class of a non-serializable class. Thus, attempts to serialize it will also attempt to associate instance of the outer class with which it is associated, leading to a runtime error.<br>If possible, making the inner class a static inner class should solve the problem. Making the outer class serializable might also work, but that would mean serializing an instance of the inner class would always also serialize the instance of the outer class, which it often not what you really want.<br>修改外部类<br>UploadFileAction extends BaseAction implements Serializable</p>
<h4 id="10-DM-BOXED-PRIMITIVE-FOR-PARSING"><a href="#10-DM-BOXED-PRIMITIVE-FOR-PARSING" class="headerlink" title="10. DM_BOXED_PRIMITIVE_FOR_PARSING"></a>10. DM_BOXED_PRIMITIVE_FOR_PARSING</h4><p>Boxing/unboxing to parse a primitive com.cmcc.aoi.selfhelp.dao.StatAppEveryHourDao.findWeekList(String)<br>A boxed primitive is created from a String, just to extract the unboxed primitive value. It is more efficient to just call the static parseXXX method.</p>
<figure class="highlight plain"><figcaption><span>statAppEveryHour.setAccnumber(Integer.valueOf(String.valueOf(objects[3])));</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">修改为</span><br><span class="line"></span><br><span class="line">```statAppEveryHour.setStattime(sdf.parse(String.valueOf(objects[1])));</span><br><span class="line">                    statAppEveryHour</span><br><span class="line">                            .setNewnumber(Integer.parseInt(String.valueOf(objects[2]) != null</span><br><span class="line">                                    &amp;&amp; !&quot;&quot;.equals(String.valueOf(objects[2]))</span><br><span class="line">                                            ? String.valueOf(objects[2]) : &quot;0&quot;));</span><br><span class="line">                    statAppEveryHour</span><br><span class="line">                            .setAccnumber(Integer.parseInt(String.valueOf(objects[3]) != null</span><br><span class="line">                                    &amp;&amp; !&quot;&quot;.equals(String.valueOf(objects[3]))</span><br><span class="line">                                            ? String.valueOf(objects[3]) : &quot;0&quot;));</span><br></pre></td></tr></table></figure>
<h3 id="Normal"><a href="#Normal" class="headerlink" title="Normal"></a>Normal</h3><h4 id="1-SBSC-USE-STRINGBUFFER-CONCATENATION"><a href="#1-SBSC-USE-STRINGBUFFER-CONCATENATION" class="headerlink" title="1.SBSC_USE_STRINGBUFFER_CONCATENATION"></a>1.SBSC_USE_STRINGBUFFER_CONCATENATION</h4><p>com.cmcc.aoi.httprequest.service.HttpRequest.sendGet(String, String) concatenates strings using + in a loop<br>The method seems to be building a String using concatenation in a loop. In each iteration, the String is converted to a StringBuffer/StringBuilder, appended to, and converted back to a String. This can lead to a cost quadratic in the number of iterations, as the growing string is recopied in each iteration.<br>Better performance can be obtained by using a StringBuffer (or StringBuilder in Java 1.5) explicitly.<br>For example:<br>  // This is bad<br>  String s = “”;<br>  for (int i = 0; i &lt; field.length; ++i) {<br>    s = s + field[i];<br>  }</p>
<p>  // This is better<br>  StringBuffer buf = new StringBuffer();<br>  for (int i = 0; i &lt; field.length; ++i) {<br>    buf.append(field[i]);<br>  }<br>  String s = buf.toString();</p>
<h4 id="2-WMI-WRONG-MAP-ITERATOR"><a href="#2-WMI-WRONG-MAP-ITERATOR" class="headerlink" title="2. WMI_WRONG_MAP_ITERATOR"></a>2. WMI_WRONG_MAP_ITERATOR</h4><figure class="highlight plain"><figcaption><span>(String key : map.keySet()) &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">                System.out.println(key + &quot;---&gt;&quot; + map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改为</p>
<figure class="highlight plain"><figcaption><span>(  Map.Entry<string, list<string="">> entry : map.entrySet()) &#123;</string,></span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">                System.out.println(entry.getKey() + &quot;---&gt;&quot; + entry.getValue());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">#### 3.  EI_EXPOSE_REP</span><br><span class="line">com.cmcc.aoi.selfhelp.entity.Activation.getValidUntil() may expose internal representation by returning Activation.validUntil</span><br><span class="line">Returning a reference to a mutable object value stored in one of the object&apos;s fields exposes the internal representation of the object.  If instances are accessed by untrusted code, and unchecked changes to the mutable object would compromise security or other important properties, you will need to do something different. Returning a new copy of the object is better approach in many situations.</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    public Date getValidUntil() &#123;</span><br><span class="line">        returnvalidUntil;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">修改为</span><br><span class="line">public Date getValidUntil() &#123;</span><br><span class="line">        if(validUntil == null) &#123;</span><br><span class="line">            returnnull;</span><br><span class="line">        &#125;</span><br><span class="line">        return (Date) validUntil.clone();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">#### 4. EI_EXPOSE_REP2</span><br><span class="line">com.cmcc.aoi.selfhelp.entity.Activation.setValidUntil(Date) may expose internal representation by storing an externally mutable object into Activation.validUntil</span><br><span class="line">This code stores a reference to an externally mutable object into the internal representation of the object.  If instances are accessed by untrusted code, and unchecked changes to the mutable object would compromise security or other important properties, you will need to do something different. Storing a copy of the object is better approach in many situations.</span><br><span class="line"></span><br><span class="line">```publicvoid setValidUntil(Date validUntil) &#123;</span><br><span class="line">this.validUntil = validUntil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改为<br><figure class="highlight plain"><figcaption><span>setValidUntil(Date validUntil) &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">        if(validUntil == null) &#123;</span><br><span class="line">            this.validUntil = null;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            this.validUntil = (Date) validUntil.clone();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line"> </span><br><span class="line">#### 5. BC_VACUOUS_INSTANCEOF</span><br><span class="line">instanceof will always return true for all non-null values in com.cmcc.aoi.selfhelp.entity.AppType.compareTo(AppType), since all com.cmcc.aoi.selfhelp.entity.AppType are instances of com.cmcc.aoi.selfhelp.entity.AppType</span><br><span class="line">This instanceof test will always return true (unless the value being tested is null). Although this is safe, make sure it isn&apos;t an indication of some misunderstanding or some other logic error. If you really want to test the value for being null, perhaps it would be clearer to do better to do a null test rather than an instanceof test.</span><br><span class="line"> </span><br><span class="line">#### 6. MS_MUTABLE_ARRAY</span><br><span class="line">com.cmcc.aoi.selfhelp.entity.DeviceType.CURRENTUSEDDEVICES is a mutable array</span><br><span class="line">A final static field references an array and can be accessed by malicious code or by accident from another package. This code can freely modify the contents of the array.</span><br><span class="line"> </span><br><span class="line">public static final int[] CURRENTUSEDDEVICES = new int []&#123;Device.iOS.ordinal()，Device.Android.ordinal()，Device.WP.ordinal()&#125;；</span><br><span class="line">修改为</span><br><span class="line"> Public &gt; protected</span><br><span class="line"> </span><br><span class="line">#### 7. EQ_COMPARETO_USE_OBJECT_EQUALS</span><br><span class="line">com.cmcc.aoi.selfhelp.entity.AppType defines compareTo(AppType) and uses Object.equals()</span><br><span class="line">This class defines a compareTo(...) method but inherits its equals() method from java.lang.Object. Generally, the value of compareTo should return zero if and only if equals returns true. If this is violated, weird and unpredictable failures will occur in classes such as PriorityQueue. In Java 5 the PriorityQueue.remove method uses the compareTo method, while in Java 6 it uses the equals method.</span><br><span class="line">From the JavaDoc for the compareTo method in the Comparable interface:</span><br><span class="line">It is strongly recommended, but not strictly required that (x.compareTo(y)==0) == (x.equals(y)). Generally speaking, any class that implements the Comparable interface and violates this condition should clearly indicate this fact. The recommended language is &quot;Note: this class has a natural ordering that is inconsistent with equals.&quot;</span><br><span class="line"> </span><br><span class="line">修改</span><br><span class="line">添加 hashcode() 和 equals() 代码即可</span><br><span class="line"> </span><br><span class="line">#### 8. BC_VACUOUS_INSTANCEOF</span><br><span class="line">instanceof will always return true for all non-null values in com.cmcc.aoi.selfhelp.entity.AppType.compareTo(AppType), since all com.cmcc.aoi.selfhelp.entity.AppType are instances of com.cmcc.aoi.selfhelp.entity.AppType</span><br><span class="line">This instanceof test will always return true (unless the value being tested is null). Although this is safe, make sure it isn&apos;t an indication of some misunderstanding or some other logic error. If you really want to test the value for being null, perhaps it would be clearer to do better to do a null test rather than an instanceof test.</span><br><span class="line">  </span><br><span class="line">```@Override</span><br><span class="line">    publicint compareTo(AppType o) &#123;</span><br><span class="line">        if (oinstanceof AppType) &#123;</span><br><span class="line">            AppType p = (AppType) o;</span><br><span class="line">            returnthis.typeId &gt; p.typeId ? 1 : this.typeId == p.typeId ? 0 : -1;</span><br><span class="line">        &#125;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">修改为</span><br><span class="line">  </span><br><span class="line">```@Override</span><br><span class="line">    publicint compareTo(AppType o) &#123;</span><br><span class="line">        if (null != o) &#123;</span><br><span class="line">            AppType p  = (AppType) o ;</span><br><span class="line">            returnthis.typeId &gt; p.typeId ? 1 : this.typeId == p.typeId ? 0 : -1;</span><br><span class="line">        &#125;</span><br><span class="line">        return 1;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">#### 9. ME_ENUM_FIELD_SETTER</span><br><span class="line">com.cmcc.aoi.selfhelp.dto.ActivationSituation.setSituation(String) unconditionally sets the field situation</span><br><span class="line">This public method declared in public enum unconditionally sets enum field, thus this field can be changed by malicious code or by accident from another package. Though mutable enum fields may be used for lazy initialization, it&apos;s a bad practice to expose them to the outer world. Consider removing this method or declaring it package-private.</span><br><span class="line">    publicvoid setCode(String code) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">修改</span><br><span class="line"> 删除该无用代码</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#### 10.  IM_BAD_CHECK_FOR_ODD</span><br><span class="line">Check for oddness that won&apos;t work for negative numbers in com.cmcc.aoi.selfhelp.dto.WebSendTextForm.toDeliverWebRequest()</span><br><span class="line">The code uses x % 2 == 1 to check to see if a value is odd, but this won&apos;t work for negative numbers (e.g., (-5) % 2 == -1). If this code is intending to check for oddness, consider using x &amp; 1 == 1, or x % 2 != 0.</span><br><span class="line"></span><br><span class="line">```DeliverFactory</span><br><span class="line">                                    .createTextOpenApp(this.msgtype, &quot;&quot;, this.content,</span><br><span class="line">                                            this.isRingAndVibrate % 2 == 1,</span><br><span class="line">                                            isRingAndVibrate / 2 &gt;= 1, this.activity)</span><br><span class="line">                                    .toJsonString());</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">修改为</span><br><span class="line"></span><br><span class="line">```DeliverFactory</span><br><span class="line">                                    .createTextOpenApp(this.msgtype, &quot;&quot;, this.content,</span><br><span class="line">                                            this.isRingAndVibrate % 2 != 0,</span><br><span class="line">                                            isRingAndVibrate / 2 &gt;= 1, this.activity)</span><br><span class="line">                                    .toJsonString());</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line"> </span><br><span class="line">#### 11. MS_EXPOSE_REP</span><br><span class="line">Public static com.cmcc.aoi.selfhelp.dict.DeviceSupported.getSupportedDevs() may expose internal representation by returning DeviceSupported.DEVS</span><br><span class="line">A public static method returns a reference to an array that is part of the static state of the class. Any code that calls this method can freely modify the underlying array. One fix is to return a copy of the array.</span><br><span class="line"></span><br><span class="line">```public static Device[] getSupportedDevs() &#123;</span><br><span class="line">        return DEVS;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>修改为</p>
<figure class="highlight plain"><figcaption><span>Device[] getSupportedDevs() &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">        return DeviceSupported.DEVS.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">#### 12.URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD</span><br><span class="line">Unread public/protected field: com.cmcc.aoi.selfhelp.dict.OperatorDict.countryCode</span><br><span class="line">This field is never read.  The field is public or protected, so perhaps it is intended to be used with classes not seen as part of the analysis. If not, consider removing it from the class.</span><br><span class="line">publicintcode;</span><br><span class="line">    </span><br><span class="line">```public String enName;</span><br><span class="line">    public String cnName;</span><br><span class="line">    public String countryCode;</span><br><span class="line"> </span><br><span class="line">    public OperatorDict() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @param code</span><br><span class="line">     *            运营商代码,一般是5位</span><br><span class="line">     * @param enName</span><br><span class="line">     *            英文名</span><br><span class="line">     * @param countryCode</span><br><span class="line">     *            国家英文代码</span><br><span class="line">     * @param cnName</span><br><span class="line">     *            中文名</span><br><span class="line">     */</span><br><span class="line">    public OperatorDict(intcode, String enName, String countryCode, String cnName) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">        this.enName = enName;</span><br><span class="line">        this.countryCode = countryCode;</span><br><span class="line">        this.cnName = cnName == null ? Integer.toString(code) : cnName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">```修改为</span><br><span class="line">Public  -》 private</span><br><span class="line">  </span><br><span class="line">#### 13. ES_COMPARING_STRINGS_WITH_EQ</span><br><span class="line">Comparison of String objects using == or != in com.cmcc.aoi.selfhelp.entity.Provider.compareTo(Object)</span><br><span class="line">This code compares java.lang.String objects for reference equality using the == or != operators. Unless both strings are either constants in a source file, or have been interned using the String.intern() method, the same string value may be represented by two different String objects. Consider using the equals(Object) method instead.</span><br><span class="line"> </span><br><span class="line">return this.spid.compareTo(p.spid) &gt; 0 ? 1 : this.spid == p.spid ? 0 : -1;</span><br><span class="line">修改为</span><br><span class="line">this.spid.compareTo(p.spid) &gt; 0 ? 1 : this.spid.equals(p.spid) ? 0 : -1;</span><br><span class="line">14.DB_DUPLICATE_BRANCHES</span><br><span class="line">com.cmcc.aoi.selfhelp.dao.ShStatTerminalDao.getListQuery(String, int, Date, Date, boolean, int) uses the same code for two branches</span><br><span class="line">This method uses the same code to implement two branches of a conditional branch. Check to ensure that this isn&apos;t a coding mistake.</span><br><span class="line"></span><br><span class="line">```if (bool) &#123;</span><br><span class="line">                query.setInteger(i++, nodeType);</span><br><span class="line">                query.setInteger(i++, nodeType);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                query.setInteger(i++, nodeType);</span><br><span class="line">                query.setInteger(i++, nodeType);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">```修改为</span><br><span class="line"></span><br><span class="line">```query.setInteger(i++, nodeType);</span><br><span class="line">query.setInteger(i++, nodeType);</span><br></pre></td></tr></table></figure>
<h4 id="15-SE-COMPARATOR-SHOULD-BE-SERIALIZABLE"><a href="#15-SE-COMPARATOR-SHOULD-BE-SERIALIZABLE" class="headerlink" title="15. SE_COMPARATOR_SHOULD_BE_SERIALIZABLE"></a>15. SE_COMPARATOR_SHOULD_BE_SERIALIZABLE</h4><p>com.cmcc.aoi.selfhelp.task.entity.StatAppHabitComparator implements Comparator but not Serializable<br>This class implements the Comparator interface. You should consider whether or not it should also implement the Serializable interface. If a comparator is used to construct an ordered collection such as a TreeMap, then the TreeMap will be serializable only if the comparator is also serializable. As most comparators have little or no state, making them serializable is generally easy and good defensive programming.<br>修改为<br>implements Serializable</p>
<h4 id="16-UWF-UNWRITTEN-PUBLIC-OR-PROTECTED-FIELD"><a href="#16-UWF-UNWRITTEN-PUBLIC-OR-PROTECTED-FIELD" class="headerlink" title="16.  UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD"></a>16.  UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD</h4><p>Unwritten public or protected field: com.cmcc.aoi.selfhelp.task.entity.StatDevice.keyname<br>No writes were seen to this public/protected field.  All reads of it will return the default value. Check for errors (should it have been initialized?), or remove it if it is useless.<br>Public  String keyname;<br>修改为<br>Private  String keyname;</p>
<h4 id="18-RV-RETURN-VALUE-IGNORED-BAD-PRACTICE"><a href="#18-RV-RETURN-VALUE-IGNORED-BAD-PRACTICE" class="headerlink" title="18.  RV_RETURN_VALUE_IGNORED_BAD_PRACTICE"></a>18.  RV_RETURN_VALUE_IGNORED_BAD_PRACTICE</h4><p>Exceptional return value of java.io.File.mkdirs() ignored in com.cmcc.aoi.util.FileUtil.moveFile(File, String)<br>This method returns a value that is not checked. The return value should be checked since it can indicate an unusual or unexpected function execution. For example, the File.delete() method returns false if the file could not be successfully deleted (rather than throwing an Exception). If you don’t check the result, you won’t notice if the method invocation signals unexpected behavior by returning an atypical return value.<br>tmp.mkdirs()<br>修改为<br>booleanmkdirs = tmp.mkdirs();<br>logger.debug(“debug”,mkdirs);</p>
<p>REC_CATCH_EXCEPTION<br>Exception is caught when Exception is not thrown in com.cmcc.aoi.selfhelp.task.fileparser.TokenIncrease.parseLine(String[])<br>This method uses a try-catch block that catches Exception objects, but Exception is not thrown within the try block, and RuntimeException is not explicitly caught. It is a common bug pattern to say try { … } catch (Exception e) { something } as a shorthand for catching a number of types of exception each of whose catch blocks is identical, but this construct also accidentally catches RuntimeException as well, masking potential bugs.<br>A better approach is to either explicitly catch the specific exceptions that are thrown, or to explicitly catch RuntimeException exception, rethrow it, and then catch all non-Runtime Exceptions, as shown below:</p>
<figure class="highlight plain"><figcaption><span>&#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    ...</span><br><span class="line">  &#125; catch (RuntimeException e) &#123;</span><br><span class="line">    throw e;</span><br><span class="line">  &#125; catch (Exception e) &#123;</span><br><span class="line">    ... deal with all non-runtime exceptions ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line"> </span><br><span class="line">#### 19. ICAST_IDIV_CAST_TO_DOUBLE</span><br><span class="line">Integral division result cast to double or float in com.cmcc.aoi.selfhelp.service.BaseAnalysisService.getInterval(Date, Date, int)</span><br><span class="line">This code casts the result of an integral division (e.g., int or long division) operation to double or float. Doing division on integers truncates the result to the integer value closest to zero. The fact that the result was cast to double suggests that this precision should have been retained. What was probably meant was to cast one or both of the operands to double before performing the division. </span><br><span class="line">```Here is an example:</span><br><span class="line">int x = 2;</span><br><span class="line">int y = 5;</span><br><span class="line">// Wrong: yields result 0.0</span><br><span class="line">double value1 =  x / y;</span><br><span class="line"> </span><br><span class="line">// Right: yields result 0.4</span><br><span class="line">double value2 =  x / (double) y;</span><br></pre></td></tr></table></figure>
<h2 id="FindBugs规则整理"><a href="#FindBugs规则整理" class="headerlink" title="FindBugs规则整理"></a>FindBugs规则整理</h2><p>FindBugs是基于Bug Patterns概念，查找javabytecode（.class文件）中的潜在bug，主要检查bytecode中的bug patterns，如NullPoint空指针检查、没有合理关闭资源、字符串相同判断错（==，而不是equals）等</p>
<h3 id="一、Security-关于代码安全性防护"><a href="#一、Security-关于代码安全性防护" class="headerlink" title="一、Security 关于代码安全性防护"></a>一、Security 关于代码安全性防护</h3><p>1.Dm: Hardcoded constant database password (DMI_CONSTANT_DB_PASSWORD)<br>代码中创建DB的密码时采用了写死的密码。<br>2.Dm: Empty database password (DMI_EMPTY_DB_PASSWORD)<br>创建数据库连接时没有为数据库设置密码，这会使数据库没有必要的保护。<br>3.HRS: HTTP cookie formed from untrusted input (HRS_REQUEST_PARAMETER_TO_COOKIE)<br>此代码使用不受信任的HTTP参数构造一个HTTP Cookie。<br>4.HRS: HTTP Response splitting vulnerability (HRS_REQUEST_PARAMETER_TO_HTTP_HEADER)<br>在代码中直接把一个HTTP的参数写入一个HTTP头文件中，它为HTTP的响应暴露了漏洞。<br>5.SQL: Nonconstant string passed to execute method on an SQL statement (SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE)<br>该方法以字符串的形式来调用SQLstatement的execute方法，它似乎是动态生成SQL语句的方法。这会更容易受到SQL注入攻击。<br>6.XSS: JSP reflected cross site scripting vulnerability (XSS_REQUEST_PARAMETER_TO_JSP_WRITER)<br>在代码中在JSP输出中直接写入一个HTTP参数，这会造成一个跨站点的脚本漏洞。</p>
<h3 id="二、Experimental"><a href="#二、Experimental" class="headerlink" title="二、Experimental"></a>二、Experimental</h3><p>1.LG: Potential lost logger changes due to weak reference in OpenJDK (LG_LOST_LOGGER_DUE_TO_WEAK_REFERENCE)<br>OpenJDK的引入了一种潜在的不兼容问题，特别是，java.util.logging.Logger的行为改变时。它现在使用内部弱引用，而不是强引用。–logger配置改变，它就是丢失对logger的引用，这本是一个合理的变化，但不幸的是一些代码对旧的行为有依赖关系。这意味着，当进行垃圾收集时对logger配置将会丢失。例如：<br>public static void initLogging() throws Exception {<br> Logger logger = Logger.getLogger(“edu.umd.cs”);<br> logger.addHandler(new FileHandler()); // call to change logger configuration<br> logger.setUseParentHandlers(false); // another call to change logger configuration<br>}<br>该方法结束时logger的引用就丢失了，如果你刚刚结束调用initLogging方法后进行垃圾回收，logger的配置将会丢失（因为只有保持记录器弱引用）。<br>public static void main(String[] args) throws Exception {<br> initLogging(); // adds a file handler to the logger<br> System.gc(); // logger configuration lost<br> Logger.getLogger(“edu.umd.cs”).info(“Some message”); // this isn’t logged to the file as expected<br>}<br>2.OBL: Method may fail to clean up stream or resource (OBL_UNSATISFIED_OBLIGATION)<br>这种方法可能无法清除（关闭，处置）一个流，数据库对象，或其他资源需要一个明确的清理行动。<br>一般来说，如果一个方法打开一个流或其他资源，该方法应该使用try / finally块来确保在方法返回之前流或资源已经被清除了。这种错误模式基本上和OS_OPEN_STREAM和ODR_OPEN_DATABASE_RESOURCE错误模式相同，但是是在不同在静态分析技术。我们正为这个错误模式的效用收集反馈意见。</p>
<h3 id="三、Bad-practice代码实现中的一些坏习惯"><a href="#三、Bad-practice代码实现中的一些坏习惯" class="headerlink" title="三、Bad practice代码实现中的一些坏习惯"></a>三、Bad practice代码实现中的一些坏习惯</h3><p>1.AM: Creates an empty jar file entry (AM_CREATES_EMPTY_JAR_FILE_ENTRY)<br>调用putNextEntry()方法写入新的 jar 文件条目时立即调用closeEntry()方法。这样会造成JarFile条目为空。<br>2.AM: Creates an empty zip file entry (AM_CREATES_EMPTY_ZIP_FILE_ENTRY)<br>调用putNextEntry()方法写入新的 zip 文件条目时立即调用closeEntry()方法。这样会造成ZipFile条目为空。<br>3.BC: Equals method should not assume anything about the type of its argument (BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS)<br>equals(Object o)方法不能对参数o的类型做任何的假设。比较此对象与指定的对象。当且仅当该参数不为 null，并且是表示与此对象相同的类型的对象时，结果才为 true。<br>4.BC: Random object created and used only once (DMI_RANDOM_USED_ONLY_ONCE)<br>随机创建对象只使用过一次就抛弃<br>5.BIT: Check for sign of bitwise operation (BIT_SIGNED_CHECK)<br>检查位操作符运行是否合理<br>((event.detail &amp; SWT.SELECTED) &gt; 0)<br>If SWT.SELECTED is a negative number, this is a candidate for a bug. Even when SWT.SELECTED is not negative, it seems good practice to use ‘!= 0’ instead of ‘&gt; 0’.<br>6.CN: Class implements Cloneable but does not define or use clone method (CN_IDIOM)<br>按照惯例，实现此接口的类应该使用公共方法重写 Object.clone（它是受保护的），以获得有关重写此方法的详细信息。此接口不 包含 clone 方法。因此，因为某个对象实现了此接口就克隆它是不可能的,应该实现此接口的类应该使用公共方法重写 Object.clone<br>7.CN: clone method does not call super.clone() (CN_IDIOM_NO_SUPER_CALL)<br>一个非final类型的类定义了clone()方法而没有调用super.clone()方法。例如：B扩展自A，如果B中clone方法调用了spuer.clone（），而A中的clone没有调用spuer.clone()，就会造成结果类型不准确。要求A的clone方法中调用spuer.clone()方法。<br>8.CN: Class defines clone() but doesn’t implement Cloneable (CN_IMPLEMENTS_CLONE_BUT_NOT_CLONEABLE)<br>类中定义了clone方法但是它没有实现Cloneable接口<br>9.Co: Abstract class defines covariant compareTo() method (CO_ABSTRACT_SELF)<br>抽象类中定义了多个compareTo()方法，正确的是覆写Comparable中的compareTo方法，方法的参数为Object类型，如下例：<br>int compareTo(T o)  比较此对象与指定对象的顺序。<br>10.Co: Covariant compareTo() method defined (CO_SELF_NO_OBJECT)<br>类中定义了多个compareTo()方法，正确的是覆写Comparable中的compareTo方法，方法的参数为Object类型<br>11.DE: Method might drop exception (DE_MIGHT_DROP)<br>方法可能抛出异常<br>12.DE: Method might ignore exception (DE_MIGHT_IGNORE)<br>方法可能忽略异常<br>13.DMI: Don’t use removeAll to clear a collection (DMI_USING_REMOVEALL_TO_CLEAR_COLLECTION)<br>不要用removeAll方法去clear一个集合<br>14.DP: Classloaders should only be created inside doPrivileged block (DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED)<br>类加载器只能建立在特殊的方法体内<br>15.Dm: Method invokes System.exit(…) (DM_EXIT)<br>在方法中调用System.exit(…)语句，考虑用RuntimeException来代替<br>16.Dm: Method invokes dangerous method runFinalizersOnExit (DM_RUN_FINALIZERS_ON_EXIT)<br>在方法中调用了System.runFinalizersOnExit 或者Runtime.runFinalizersOnExit方法，因为这样做是很危险的。<br>17.ES: Comparison of String parameter using == or != (ES_COMPARING_PARAMETER_STRING_WITH_EQ)<br>用==或者!=方法去比较String类型的参数<br>18.ES: Comparison of String objects using == or != (ES_COMPARING_STRINGS_WITH_EQ)<br>用==或者！=去比较String类型的对象<br>19.Eq: Abstract class defines covariant equals() method (EQ_ABSTRACT_SELF)<br>20.Eq: Equals checks for noncompatible operand (EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS)<br>equals方法检查不一致的操作。两个类根本就是父子关系而去调用equals方法去判读对象是否相等。<br>public boolean equals(Object o) {<br>  if (o instanceof Foo)<br>    return name.equals(((Foo)o).name);<br>  else if (o instanceof String)<br>    return name.equals(o);<br>  else return false;<br>21.Eq: Class defines compareTo(…) and uses Object.equals() (EQ_COMPARETO_USE_OBJECT_EQUALS)<br>类中定义了compareTo方法但是继承了Object中的compareTo方法<br>22.Eq: equals method fails for subtypes (EQ_GETCLASS_AND_CLASS_CONSTANT)<br>类中的equals方法可能被子类中的方法所破坏，当使用类似于Foo.class == o.getClass()的判断时考虑用this.getClass() == o.getClass()来替换<br>23.Eq: Covariant equals() method defined (EQ_SELF_NO_OBJECT)<br>类中定义了多个equals方法。正确的做法是覆写Object中的equals方法，它的参数为Object类型的对象。<br>24.FI: Empty finalizer should be deleted (FI_EMPTY)<br>为空的finalizer方法应该删除。一下关于finalizer的内容省略<br>25.GC: Unchecked type in generic call (GC_UNCHECKED_TYPE_IN_GENERIC_CALL)<br>This call to a generic collection method passes an argument while compile type Object where a specific type from the generic type parameters is expected. Thus, neither the standard Java type system nor static analysis can provide useful information on whether the object being passed as a parameter is of an appropriate type.<br>26.HE: Class defines equals() but not hashCode() (HE_EQUALS_NO_HASHCODE)<br>方法定义了equals方法却没有定义hashCode方法<br>27.HE: Class defines hashCode() but not equals() (HE_HASHCODE_NO_EQUALS)<br> 类定义了hashCode方法去没有定义equal方法<br>28.HE: Class defines equals() and uses Object.hashCode() (HE_EQUALS_USE_HASHCODE)<br>一个类覆写了equals方法，没有覆写hashCode方法，使用了Object对象的hashCode方法<br>29.HE: Class inherits equals() and uses Object.hashCode() (HE_INHERITS_EQUALS_USE_HASHCODE)<br>子类继承了父类的equals方法却使用了Object的hashCode方法<br>30.IC: Superclass uses subclass during initialization (IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION)<br>子类在父类未初始化之前使用父类对象实例<br>public class CircularClassInitialization {<br>        static class InnerClassSingleton extends CircularClassInitialization {<br>static InnerClassSingleton singleton = new InnerClassSingleton();<br>        }<br>        static CircularClassInitialization foo = InnerClassSingleton.singleton;<br>}<br>31.IMSE: Dubious catching of IllegalMonitorStateException (IMSE_DONT_CATCH_IMSE)<br>捕捉违法的监控状态异常，例如当没有获取到对象锁时使用其wait和notify方法<br>32.ISC: Needless instantiation of class that only supplies static methods (ISC_INSTANTIATE_STATIC_CLASS)<br>为使用静态方法而创建一个实例对象。调用静态方法时只需要使用类名+静态方法名就可以了。<br>33.It: Iterator next() method can’t throw NoSuchElementException (IT_NO_SUCH_ELEMENT)<br>迭代器的next方法不能够抛出NoSuchElementException<br>34.J2EE: Store of non serializable object into HttpSession (J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION)<br>在HttpSession对象中保存非连续的对象<br>35.JCIP: Fields of immutable classes should be final (JCIP_FIELD_ISNT_FINAL_IN_IMMUTABLE_CLASS)<br> The class is annotated with net.jcip.annotations.Immutable, and the rules for that annotation require that all fields are final. .<br>36.NP: Method with Boolean return type returns explicit null (NP_BOOLEAN_RETURN_NULL)<br>返回值为boolean类型的方法直接返回null，这样会导致空指针异常<br>37.NP: equals() method does not check for null argument (NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT)<br>变量调用equals方法时没有进行是否为null的判断<br>38.NP: toString method may return null (NP_TOSTRING_COULD_RETURN_NULL)<br>toString方法可能返回null<br>39.Nm: Class names should start with an upper case letter (NM_CLASS_NAMING_CONVENTION)<br>类的名称以大写字母名称开头<br>40.Nm: Class is not derived from an Exception, even though it is named as such (NM_CLASS_NOT_EXCEPTION)<br>类的名称中含有Exception但是却不是一个异常类的子类，这种名称会造成混淆<br>41.Nm: Confusing method names (NM_CONFUSING)<br>令人迷惑的方面命名<br>42.Nm: Field names should start with a lower case letter (NM_FIELD_NAMING_CONVENTION)<br>非final类型的字段需要遵循驼峰命名原则<br>43.Nm: Use of identifier that is a keyword in later versions of Java (NM_FUTURE_KEYWORD_USED_AS_IDENTIFIER)<br>验证是否是java预留关键字<br>44.Nm: Use of identifier that is a keyword in later versions of Java (NM_FUTURE_KEYWORD_USED_AS_MEMBER_IDENTIFIER)<br>验证是否时java中的关键字<br>45.Nm: Method names should start with a lower case letter (NM_METHOD_NAMING_CONVENTION)<br>方法名称以小写字母开头<br>46.Nm: Class names shouldn’t shadow simple name of implemented interface (NM_SAME_SIMPLE_NAME_AS_INTERFACE)<br>实现同一接口实现类不能使用相同的名称，即使它们位于不同的包中<br>47.Nm: Class names shouldn’t shadow simple name of superclass (NM_SAME_SIMPLE_NAME_AS_SUPERCLASS)<br>继承同一父类的子类不能使用相同的名称，即使它们位于不同的包中<br>48.Nm: Very confusing method names (but perhaps intentional) (NM_VERY_CONFUSING_INTENTIONAL)<br>很容易混淆的方法命名，例如方法的名称名称使用使用大小写来区别两个不同的方法。<br>49.Nm: Method doesn’t override method in superclass due to wrong package for parameter (NM_WRONG_PACKAGE_INTENTIONAL)<br>由于错误引用了不同包中相同类名的对象而不能够正确的覆写父类中的方法<br>import alpha.Foo;<br>public class A {<br>  public int f(Foo x) { return 17; }<br>}<br>import beta.Foo;<br>public class B extends A {<br>  public int f(Foo x) { return 42; }<br>  public int f(alpha.Foo x) { return 27; }<br>}<br>50.ODR: Method may fail to close database resource (ODR_OPEN_DATABASE_RESOURCE)<br>方法中可能存在关闭数据连接失败的情况<br>51.OS: Method may fail to close stream (OS_OPEN_STREAM)<br>方法中可能存在关闭流失败的情况<br>52.OS: Method may fail to close stream on exception (OS_OPEN_STREAM_EXCEPTION_PATH)<br>方法中可能存在关闭流时出现异常情况<br>53.RC: Suspicious reference comparison to constant (RC_REF_COMPARISON_BAD_PRACTICE)<br>当两者为不同类型的对象时使用equals方法来比较它们的值是否相等，而不是使用==方法。例如比较的两者为java.lang.Integer, java.lang.Float<br>54.RC: Suspicious reference comparison of Boolean values (RC_REF_COMPARISON_BAD_PRACTICE_BOOLEAN)<br>使用== 或者 !=操作符来比较两个 Boolean类型的对象，建议使用equals方法。<br>55.RR: Method ignores results of InputStream.read() (RR_NOT_CHECKED)<br>InputStream.read方法忽略返回的多个字符，如果对结果没有检查就没法正确处理用户读取少量字符请求的情况。<br>56.RR: Method ignores results of InputStream.skip() (SR_NOT_CHECKED)<br>InputStream.skip()方法忽略返回的多个字符，如果对结果没有检查就没法正确处理用户跳过少量字符请求的情况<br>57.RV: Method ignores exceptional return value (RV_RETURN_VALUE_IGNORED_BAD_PRACTICE)<br>方法忽略返回值的异常信息<br>58.SI: Static initializer creates instance before all static final fields assigned (SI_INSTANCE_BEFORE_FINALS_ASSIGNED)<br>在所有的static final字段赋值之前去使用静态初始化的方法创建一个类的实例。<br>59.Se: Non-serializable value stored into instance field of a serializable class (SE_BAD_FIELD_STORE)<br>非序列化的值保存在声明为序列化的的非序列化字段中<br>60.Se: Comparator doesn’t implement Serializable (SE_COMPARATOR_SHOULD_BE_SERIALIZABLE)<br>Comparator接口没有实现Serializable接口<br>61.Se: Serializable inner class (SE_INNER_CLASS)<br>序列化内部类<br>62.Se: serialVersionUID isn’t final (SE_NONFINAL_SERIALVERSIONID)<br>关于UID类的检查内容省略<br>63.Se: Class is Serializable but its superclass doesn’t define a void constructor (SE_NO_SUITABLE_CONSTRUCTOR)<br>子类序列化时父类没有提供一个void的构造函数<br>64.Se: Class is Externalizable but doesn’t define a void constructor (SE_NO_SUITABLE_CONSTRUCTOR_FOR_EXTERNALIZATION)<br>Externalizable 实例类没有定义一个void类型的构造函数<br>65.Se: The readResolve method must be declared with a return type of Object. (SE_READ_RESOLVE_MUST_RETURN_OBJECT)<br>readResolve从流中读取类的一个实例，此方法必须声明返回一个Object类型的对象<br>66.Se: Transient field that isn’t set by deserialization. (SE_TRANSIENT_FIELD_NOT_RESTORED)<br>This class contains a field that is updated at multiple places in the class, thus it seems to be part of the state of the class. However, since the field is marked as transient and not set in readObject or readResolve, it will contain the default value in any deserialized instance of the class.<br>67.SnVI: Class is Serializable, but doesn’t define serialVersionUID (SE_NO_SERIALVERSIONID)<br>一个类实现了Serializable接口但是没有定义serialVersionUID类型的变量。序列化运行时使用一个称为 serialVersionUID 的版本号与每个可序列化类相关联，该序列号在反序列化过程中用于验证序列化对象的发送者和接收者是否为该对象加载了与序列化兼容的类。如果接收者加载的该对象的类的 serialVersionUID 与对应的发送者的类的版本号不同，则反序列化将会导致 InvalidClassException。可序列化类可以通过声明名为 “serialVersionUID” 的字段（该字段必须是静态 (static)、最终 (final) 的 long 型字段）显式声明其自己的 serialVersionUID：<br> ANY-ACCESS-MODIFIER static final long serialVersionUID = 42L;<br>68.UI: Usage of GetResource may be unsafe if class is extended (UI_INHERITANCE_UNSAFE_GETRESOURCE)<br>当一个类被子类继承后不要使用this.getClass().getResource(…)来获取资源</p>
<h3 id="四、Correctness关于代码正确性相关方面的"><a href="#四、Correctness关于代码正确性相关方面的" class="headerlink" title="四、Correctness关于代码正确性相关方面的"></a>四、Correctness关于代码正确性相关方面的</h3><p>1.BC: Impossible cast (BC_IMPOSSIBLE_CAST)<br>不可能的类转换，执行时会抛出ClassCastException<br>2.BC: Impossible downcast (BC_IMPOSSIBLE_DOWNCAST)<br>父类在向下进行类型转换时抛出ClassCastException<br>3.BC: Impossible downcast of toArray() result (BC_IMPOSSIBLE_DOWNCAST_OF_TOARRAY)<br>集合转换为数组元素时发生的类转换错误。<br>This code is casting the result of calling toArray() on a collection to a type more specific than Object[], as in:<br>String[] getAsArray(Collection<string> c) {<br>  return (String[]) c.toArray();<br>  }<br>This will usually fail by throwing a ClassCastException. The toArray() of almost all collections return an Object[]. They can’t really do anything else, since the Collection object has no reference to the declared generic type of the collection.<br>The correct way to do get an array of a specific type from a collection is to use c.toArray(new String[]); or c.toArray(new String[c.size()]); (the latter is slightly more efficient).<br>4.BC: instanceof will always return false (BC_IMPOSSIBLE_INSTANCEOF)<br>采用instaneof方法进行比较时总是返回false。前提是保证它不是由于某些逻辑错误造成的。<br>5.BIT: Incompatible bit masks (BIT_AND)<br>错误的使用&amp;位操作符，例如(e &amp; C)<br>6.BIT: Check to see if ((…) &amp; 0) == 0 (BIT_AND_ZZ)<br>检查恒等的逻辑错误<br>7.BIT: Incompatible bit masks (BIT_IOR)<br>错误的使用|位操作符，例如(e | C)<br>8.BIT: Check for sign of bitwise operation (BIT_SIGNED_CHECK_HIGH_BIT)<br>检查逻辑运算符操作返回的标识。例如((event.detail &amp; SWT.SELECTED) &gt; 0)，建议采用!=0代替&gt;0<br>9.BOA: Class overrides a method implemented in super class Adapter wrongly (BOA_BADLY_OVERRIDDEN_ADAPTER)<br>子类错误的覆写父类中用于适配监听其他事件的方法，从而导致当触发条件发生时不能被监听者调用<br>10.Bx: Primitive value is unboxed and coerced for ternary operator (BX_UNBOXED_AND_COERCED_FOR_TERNARY_OPERATOR)<br>在三元运算符操作时如果没有对值进行封装或者类型转换。例如：b ? e1 : e2<br>11.DLS: Dead store of class literal (DLS_DEAD_STORE_OF_CLASS_LITERAL)<br>以类的字面名称方式为一个字段赋值后再也没有去使用它，在1.4jdk中它会自动调用静态的初始化方法，而在jdk1.5中却不会去执行。<br>12.DLS: Overwritten increment (DLS_OVERWRITTEN_INCREMENT)<br>覆写增量增加错误i = i++<br>13.DMI: Bad constant value for month (DMI_BAD_MONTH)<br>hashNext方法调用next方法。<br>14.DMI: Collections should not contain themselves (DMI_COLLECTIONS_SHOULD_NOT_CONTAIN_THEMSELVES)<br>集合没有包含他们自己本身。<br>15.DMI: Invocation of hashCode on an array (DMI_INVOKING_HASHCODE_ON_ARRAY)<br>数组直接使用hashCode方法来返回哈希码。<br>int [] a1 = new int[]{1,2,3,4};<br>        System.out.println(a1.hashCode());<br>        System.out.println(java.util.Arrays.hashCode(a1));<br>16.DMI: Double.longBitsToDouble invoked on an int (DMI_LONG_BITS_TO_DOUBLE_INVOKED_ON_INT)<br>17.DMI: Vacuous call to collections (DMI_VACUOUS_SELF_COLLECTION_CALL)<br>集合的调用不能被感知。例如c.containsAll(c)总是返回true，而c.retainAll(c)的返回值不能被感知。<br>18.Dm: Can’t use reflection to check for presence of annotation without runtime retention (DMI_ANNOTATION_IS_NOT_VISIBLE_TO_REFLECTION)<br>Unless an annotation has itself been annotated with @Retention(RetentionPolicy.RUNTIME), the annotation can’t be observed using reflection (e.g., by using the isAnnotationPresent method). .<br>19.Dm: Useless/vacuous call to EasyMock method (DMI_VACUOUS_CALL_TO_EASYMOCK_METHOD)<br>While ScheduledThreadPoolExecutor inherits from ThreadPoolExecutor, a few of the inherited tuning methods are not useful for it. In particular, because it acts as a fixed-sized pool using corePoolSize threads and an unbounded queue, adjustments to maximumPoolSize have no useful effect.<br>20.EC: equals() used to compare array and nonarray (EC_ARRAY_AND_NONARRAY)<br>数组对象使用equals方法和非数组对象进行比较。即使比较的双方都是数组对象也不应该使用equals方法，而应该比较它们的内容是否相等使用java.util.Arrays.equals(Object[], Object[]);<br>21.EC: equals(…) used to compare incompatible arrays (EC_INCOMPATIBLE_ARRAY_COMPARE)<br>使用equls方法去比较类型不相同的数组。例如：String[] and StringBuffer[], or String[] and int[]<br>22.EC: Call to equals() with null argument (EC_NULL_ARG)<br>调用equals的对象为null<br>23.EC: Call to equals() comparing unrelated class and interface (EC_UNRELATED_CLASS_AND_INTERFACE)<br>使用equals方法比较不相关的类和接口<br>24.EC: Call to equals() comparing different interface types (EC_UNRELATED_INTERFACES)<br>调用equals方法比较不同类型的接口<br>25.EC: Call to equals() comparing different types (EC_UNRELATED_TYPES)<br>调用equals方法比较不同类型的类<br>26.EC: Using pointer equality to compare different types (EC_UNRELATED_TYPES_USING_POINTER_EQUALITY)<br>This method uses using pointer equality to compare two references that seem to be of different types. The result of this comparison will always be false at runtime.<br>27.Eq: equals method always returns false (EQ_ALWAYS_FALSE)<br>使用equals方法返回值总是false<br>28.Eq: equals method always returns true (EQ_ALWAYS_TRUE)<br>equals方法返回值总是true<br>29.Eq: equals method compares class names rather than class objects (EQ_COMPARING_CLASS_NAMES)<br>使用equals方法去比较一个类的实例和类的类型<br>30.Eq: Covariant equals() method defined for enum (EQ_DONT_DEFINE_EQUALS_FOR_ENUM)<br>This class defines an enumeration, and equality on enumerations are defined using object identity. Defining a covariant equals method for an enumeration value is exceptionally bad practice, since it would likely result in having two different enumeration values that compare as equals using the covariant enum method, and as not equal when compared normally. Don’t do it.<br>31.Eq: equals() method defined that doesn’t override equals(Object) (EQ_OTHER_NO_OBJECT)<br>类中定义的equals方法时不要覆写equals（Object）方法<br>32.Eq: equals() method defined that doesn’t override Object.equals(Object) (EQ_OTHER_USE_OBJECT)<br>类中定义的equals方法时不要覆写Object中的equals（Object）方法<br>33.Eq: equals method overrides equals in superclass and may not be symmetric (EQ_OVERRIDING_EQUALS_NOT_SYMMETRIC)<br>34.Eq: Covariant equals() method defined, Object.equals(Object) inherited (EQ_SELF_USE_OBJECT)<br>类中定义了一组equals方法，但是都是继承的java.lang.Object class中的equals(Object)方法<br>35.FE: Doomed test for equality to NaN (FE_TEST_IF_EQUAL_TO_NOT_A_NUMBER)<br>This code checks to see if a floating point value is equal to the special Not A Number value (e.g., if (x == Double.NaN)). However, because of the special semantics of NaN, no value is equal to Nan, including NaN. Thus, x == Double.NaN always evaluates to false. To check to see if a value contained in x is the special Not A Number value, use Double.isNaN(x) (or Float.isNaN(x) if x is floating point precision).<br>36.FS: Format string placeholder incompatible with passed argument (VA_FORMAT_STRING_BAD_ARGUMENT)<br>错误使用参数类型来格式化字符串<br>37.FS: The type of a supplied argument doesn’t match format specifier (VA_FORMAT_STRING_BAD_CONVERSION)<br>指定的格式字符串和参数类型不匹配，例如：String.format(“%d”, “1”)<br>38.FS: MessageFormat supplied where printf style format expected (VA_FORMAT_STRING_EXPECTED_MESSAGE_FORMAT_SUPPLIED)<br>但用String的format方法时实际调用了ＭｅｓｓａｇｅＦｏｒｍａｔ中干的格式化方法而引起格式化结果出错。<br>39.FS: More arguments are passed than are actually used in the format string (VA_FORMAT_STRING_EXTRA_ARGUMENTS_PASSED)<br>使用String的format方法时有非法的参数也经过了格式化操作。<br>40.FS: Illegal format string (VA_FORMAT_STRING_ILLEGAL)<br>格式化String对象语句错误<br>41.FS: Format string references missing argument (VA_FORMAT_STRING_MISSING_ARGUMENT)<br>String的format操作缺少必要的参数。<br>42.FS: No previous argument for format string (VA_FORMAT_STRING_NO_PREVIOUS_ARGUMENT)<br>格式字符串定义错误，例如：formatter.format(“%&lt;s %s”, “a”, “b”); 抛出MissingFormatArgumentException异常<br>43.GC: No relationship between generic parameter and method argument (GC_UNRELATED_TYPES)<br>This call to a generic collection method contains an argument with an incompatible class from that of the collection’s parameter (i.e., the type of the argument is neither a supertype nor a subtype of the corresponding generic type argument). Therefore, it is unlikely that the collection contains any objects that are equal to the method argument used here. Most likely, the wrong value is being passed to the method.<br>In general, instances of two unrelated classes are not equal. For example, if the Foo and Bar classes are not related by subtyping, then an instance of Foo should not be equal to an instance of Bar. Among other issues, doing so will likely result in an equals method that is not symmetrical. For example, if you define the Foo class so that a Foo can be equal to a String, your equals method isn’t symmetrical since a String can only be equal to a String.<br>In rare cases, people do define nonsymmetrical equals methods and still manage to make their code work. Although none of the APIs document or guarantee it, it is typically the case that if you check if a Collection<string> contains a Foo, the equals method of argument (e.g., the equals method of the Foo class) used to perform the equality checks.<br>44.HE: Signature declares use of unhashable class in hashed construct (HE_SIGNATURE_DECLARES_HASHING_OF_UNHASHABLE_CLASS)<br>A method, field or class declares a generic signature where a non-hashable class is used in context where a hashable class is required. A class that declares an equals method but inherits a hashCode() method from Object is unhashable, since it doesn’t fulfill the requirement that equal objects have equal hashCodes.<br>45.HE: Use of class without a hashCode() method in a hashed data structure (HE_USE_OF_UNHASHABLE_CLASS)<br>A class defines an equals(Object) method but not a hashCode() method, and thus doesn’t fulfill the requirement that equal objects have equal hashCodes. An instance of this class is used in a hash data structure, making the need to fix this problem of highest importance.<br>46.ICAST: integral value cast to double and then passed to Math.ceil (ICAST_INT_CAST_TO_DOUBLE_PASSED_TO_CEIL)<br>integral的值转换为double后使用了Math.ceil方法<br>47.ICAST: int value cast to float and then passed to Math.round (ICAST_INT_CAST_TO_FLOAT_PASSED_TO_ROUND)<br>int 类型的值转换为float类型之后调用了Math.round方法<br>48.IJU: JUnit assertion in run method will not be noticed by JUnit (IJU_ASSERT_METHOD_INVOKED_FROM_RUN_METHOD)<br>在JUnit中的断言在run方法中不会被告知<br>49.IJU: TestCase declares a bad suite method (IJU_BAD_SUITE_METHOD)<br>在一个JUnit类中声明的一个suite()方法必须声明为<br>public static junit.framework.Test suite()<br>或者<br>public static junit.framework.TestSuite suite()的形式。<br>50.IL: A collection is added to itself (IL_CONTAINER_ADDED_TO_ITSELF)<br>集合本身作为add方法的参数，这样会引起内容溢出。<br>51.IL: An apparent infinite loop (IL_INFINITE_LOOP)<br>方法的自调用引起的死循环<br>52.IM: Integer multiply of result of integer remainder (IM_MULTIPLYING_RESULT_OF_IREM)<br>和整数余数进行乘法运算。例如：i % 60 <em> 1000 是进行(i % 60) </em> 1000运算而不是 i % (60 * 1000)<br>53.INT: Bad comparison of nonnegative value with negative constant (INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE)<br>保证非负数和负数进行比较<br>54.INT: Bad comparison of signed byte (INT_BAD_COMPARISON_WITH_SIGNED_BYTE)<br>比较有符合数，要先把有符号数转换为无符合数再进行比较<br>55.IO: Doomed attempt to append to an object output stream (IO_APPENDING_TO_OBJECT_OUTPUT_STREAM)<br>宣布试图在对象的输出流处添加元素，如果你希望能够添加进一个对象的输出流中必须保证对象的输出流处于打开状态。<br>56.IP: A parameter is dead upon entry to a method but overwritten (IP_PARAMETER_IS_DEAD_BUT_OVERWRITTEN)<br>The initial value of this parameter is ignored, and the parameter is overwritten here. This often indicates a mistaken belief that the write to the parameter will be conveyed back to the caller.<br>传入参数的值被忽略，但是对传入值进行了修改，并返回给了调用者<br>57.MF: Class defines field that masks a superclass field (MF_CLASS_MASKS_FIELD)<br>子类中定义了和父类中同名的字段。在调用时会出错<br>58.MF: Method defines a variable that obscures a field (MF_METHOD_MASKS_FIELD)<br>在方法中定义的局部变量和类变量或者父类变量同名，从而引起字段混淆。<br>59.NP: Null pointer dereference (NP_ALWAYS_NULL)<br>对象赋为null值后 没有被重新赋值<br>60.NP: Null pointer dereference in method on exception path (NP_ALWAYS_NULL_EXCEPTION)<br>A pointer which is null on an exception path is dereferenced here.  This will lead to a NullPointerException when the code is executed.  Note that because FindBugs currently does not prune infeasible exception paths, this may be a false warning.<br>Also note that FindBugs considers the default case of a switch statement to be an exception path, since the default case is often infeasible.<br>空指针引用上调用去除引用方法，将发生空指针异常<br>61.NP: Method does not check for null argument (NP_ARGUMENT_MIGHT_BE_NULL)<br>方法没有判断参数是否为空<br>62.NP: close() invoked on a value that is always null (NP_CLOSING_NULL)<br>一个为空的对象调用close方法<br>63.NP: Null value is guaranteed to be dereferenced (NP_GUARANTEED_DEREF)<br>There is a statement or branch that if executed guarantees that a value is null at this point, and that value that is guaranteed to be dereferenced (except on forward paths involving runtime exceptions).<br>在正常的null判断分支上，对象去除引用操作是受保护的不允许的<br>64.NP: Value is null and guaranteed to be dereferenced on exception path (NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH)<br>There is a statement or branch on an exception path that if executed guarantees that a value is null at this point, and that value that is guaranteed to be dereferenced (except on forward paths involving runtime exceptions).<br>65.NP: Method call passes null to a nonnull parameter (NP_NONNULL_PARAM_VIOLATION)<br>方法中为null的参数没有被重新赋值<br>        void test(){<br>String ss = null;<br>sya(ss);<br>        }<br>        public void sya(String ad){<br>ad.getBytes();<br>        }<br>66.NP: Method may return null, but is declared @NonNull (NP_NONNULL_RETURN_VIOLATION)<br>方法声明了返回值不能为空，但是方法中有可能返回null<br>67.NP: A known null value is checked to see if it is an instance of a type (NP_NULL_INSTANCEOF)<br>检查一个为null的值是否是想要的类型对象，而不是由于粗心或者逻辑错误引起的<br>68.NP: Possible null pointer dereference (NP_NULL_ON_SOME_PATH)<br>对象可能没有重新赋值<br>69.NP: Possible null pointer dereference in method on exception path (NP_NULL_ON_SOME_PATH_EXCEPTION)<br>A reference value which is null on some exception control path is dereferenced here.  This may lead to a NullPointerException when the code is executed.  Note that because FindBugs currently does not prune infeasible exception paths, this may be a false warning.<br>Also note that FindBugs considers the default case of a switch statement to be an exception path, since the default case is often infeasible.<br>在异常null值处理分支调用的方法上，可能存在对象去除引用操作<br>70.NP: Method call passes null for nonnull parameter (NP_NULL_PARAM_DEREF_ALL_TARGETS_DANGEROUS)<br>方法参数中声明为nonnull类型的参数为null<br>void test(){<br>String ss = null;<br>sya(ss);<br>        }<br>        public void sya(@nonnull String ad){<br>ad.getBytes();<br>        }<br>71.NP: Store of null value into field annotated NonNull (NP_STORE_INTO_NONNULL_FIELD)<br>为一个已经声明为不能为null值的属性赋值为null。<br>72.Nm: Class defines equal(Object); should it be equals(Object)? (NM_BAD_EQUAL)<br>类中定义了一个equal方法但是却不是覆写的Object对象的equals方法<br>73.Nm: Class defines hashcode(); should it be hashCode()? (NM_LCASE_HASHCODE)<br>类中定义了一个hashCode方法但是却不是覆写的Object中的hashCode方法<br>74.Nm: Class defines tostring(); should it be toString()? (NM_LCASE_TOSTRING)<br>类中定义了一个toString方法但是却不是覆写的Object中的toString方法<br>75.Nm: Apparent method/constructor confusion (NM_METHOD_CONSTRUCTOR_CONFUSION)<br>构造方法定义混乱，保证一个标准的构造函数。        例如：<br>        SA(){        }<br>        void SA(){<br>        }<br>76.Nm: Very confusing method names (NM_VERY_CONFUSING)<br>混乱的方法命名，如getName和getname方法同时出现的时候<br>77.Nm: Method doesn’t override method in superclass due to wrong package for parameter (NM_WRONG_PACKAGE)<br>方法因为取了不同包中的同名的对象而没有正确覆写父类中的同名方法<br>import alpha.Foo;<br>public class A {<br>  public int f(Foo x) { return 17; }<br>}</string></string></p>
<p>import beta.Foo;<br>public class B extends A {<br>  public int f(Foo x) { return 42; }<br>}<br>78.QBA: Method assigns boolean literal in boolean expression (QBA_QUESTIONABLE_BOOLEAN_ASSIGNMENT)<br>再if或者while表达式中使用boolean类型的值时应该使用==去判断，而不是采用=操作<br>79.RC: Suspicious reference comparison (RC_REF_COMPARISON)<br>比较两个对象值是否相等时应该采用equals方法，而不是==方法<br>80.RE: Invalid syntax for regular expression (RE_BAD_SYNTAX_FOR_REGULAR_EXPRESSION)<br>对正则表达式使用了错误的语法，会抛出未经检查的异常，表明正则表达式模式中的语法错误。<br>81.RE: File.separator used for regular expression (RE_CANT_USE_FILE_SEPARATOR_AS_REGULAR_EXPRESSION)<br>使用正则表达式使用了错误的文件分隔符，在windows系统中正则表达式不会匹配’\’而应该使用’\‘<br>82.RV: Random value from 0 to 1 is coerced to the integer 0 (RV_01_TO_INT)<br>从0到1随机值被强制为整数值0。在强制得到一个整数之前，你可能想得到多个随机值。或使用Random.nextInt（n）的方法。<br>83.RV: Bad attempt to compute absolute value of signed 32-bit hashcode (RV_ABSOLUTE_VALUE_OF_HASHCODE)<br>此代码生成一个哈希码，然后计算该哈希码的绝对值。如果哈希码是Integer.MIN_VALUE的，那么结果将是负数（因为Math.abs（Integer.MIN_VALUE的）== Integer.MIN_VALUE的）。<br>在2^ 32值之外字符串有一个Integer.MIN_VALUE的hashCode包括“polygenelubricants”，“GydZG_”和“，”DESIGNING WORKHOUSES “。<br>84.RV: Bad attempt to compute absolute value of signed 32-bit random integer (RV_ABSOLUTE_VALUE_OF_RANDOM_INT)<br>此代码生成一个随机的符号整数，然后计算该随机整数的绝对值。如果随机数生成数绝对值为Integer.MIN_VALUE的，那么结果将是负数（因为Math.abs（Integer.MIN_VALUE的）== Integer.MIN_VALUE的）。<br>85.RV: Exception created and dropped rather than thrown (RV_EXCEPTION_NOT_THROWN)<br>此代码创建一个异常（或错误）的对象，但不会用它做任何事情。例如：if (x &lt; 0)<br>  new IllegalArgumentException(“x must be nonnegative”);<br>这可能是程序员的意图抛出创建的异常：<br>if (x &lt; 0)<br>  throw new IllegalArgumentException(“x must be nonnegative”);<br>86.RV: Method ignores return value (RV_RETURN_VALUE_IGNORED)<br>该方法的返回值应该进行检查。这种警告通常出现在调用一个不可变对象的方法，认为它更新了对象的值。例如：String dateString = getHeaderField(name);<br>dateString.trim();<br>程序员似乎以为trim（）方法将更新dateString引用的字符串。但由于字符串是不可改变的，trim（）函数返回一个新字符串值，在这里它是被忽略了。该代码应更正：<br>String dateString = getHeaderField(name);<br>dateString = dateString.trim();<br>87.RpC: Repeated conditional tests (RpC_REPEATED_CONDITIONAL_TEST)<br>该代码包含对同一个条件试验了两次，两边完全一样例如：（如X == 0 | | x == 0）。可能第二次出现是打算判断别的不同条件（如X == 0 | | y== 0）。<br>88.SA: Double assignment of field (SA_FIELD_DOUBLE_ASSIGNMENT)<br>方法中的字段包含了双重任务，例如：<br> int x;<br>  public void foo() {<br>   x = x = 17;<br>  }<br>这种为变量赋值是无用的，并可能表明一个逻辑错误或拼写错误。<br>89.SA: Self assignment of field (SA_FIELD_SELF_ASSIGNMENT)<br>方法中包含自己对自己赋值的字段。例如：<br>int x;<br>  public void foo() {<br>    x = x;<br>  }<br>90.SA: Self comparison of field with itself (SA_FIELD_SELF_COMPARISON)<br>字段自己进行自比较可能表明错误或逻辑错误。<br>91.SA: Self comparison of value with itself (SA_LOCAL_SELF_COMPARISON)<br>方法中对一个局部变量自身进行比较运算，并可说明错误或逻辑错误。请确保您是比较正确的事情。<br>92.SA: Nonsensical self computation involving a variable (e.g., x &amp; x) (SA_LOCAL_SELF_COMPUTATION)<br>此方法对同一变量执行了荒谬的计算（如x&amp;x或x-x）操作。由于计算的性质，这一行动似乎没有意义，并可能表明错误或逻辑错误。<br>93.SF: Dead store due to switch statement fall through (SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH)<br>在swtich中先前的case值因为swtich执行失败而被覆写，这就像是忘记使用break推出或者没有使用return语句放回先前的值一样。<br>94.SF: Dead store due to switch statement fall through to throw (SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH_TO_THROW)<br>在swtich中因为出现异常而忽略了对case值的保存。<br>95.SIC: Deadly embrace of non-static inner class and thread local (SIC_THREADLOCAL_DEADLY_EMBRACE)<br>如果是一个静态内部类。实际上，在内部类和当前线程有死锁的可能。由于内部类不是静态的，它保留了对外部类的引用。如果线程包含对一个内部类实例的引用，那么内外实例的实例都可以被获取，这样就不具备垃圾会回收的资格。<br>96.SIO: Unnecessary type check done using instanceof operator (SIO_SUPERFLUOUS_INSTANCEOF)<br>在进行instanceof操作时进行没有必要的类型检查<br>97.STI: Unneeded use of currentThread() call, to call interrupted() (STI_INTERRUPTED_ON_CURRENTTHREAD)<br>此方法调用Thread.currentThread（）调用，只需调用interrupted（）方法。由于interrupted（）是一个静态方法， Thread.interrupted（）更简单易用。<br>98.STI: Static Thread.interrupted() method invoked on thread instance (STI_INTERRUPTED_ON_UNKNOWNTHREAD)<br>调用不是当前线程对象的Thread.interrupted()方法，由于interrupted（）方法是静态的，interrupted方法将会调用一个和作者原计划不同的对象。<br>99.Se: Method must be private in order for serialization to work (SE_METHOD_MUST_BE_PRIVATE)<br>这个类实现了Serializable接口，并定义自定义序列化的方法/反序列化。但由于这种方法不能声明为private，将被序列化/反序列化的API忽略掉。<br>100.Se: The readResolve method must not be declared as a static method. (SE_READ_RESOLVE_IS_STATIC)<br>为使readResolve方法得到序列化机制的识别，不能作为一个静态方法来声明。<br>101.UMAC: Uncallable method defined in anonymous class (UMAC_UNCALLABLE_METHOD_OF_ANONYMOUS_CLASS)<br>在匿名类中定义了一个既没有覆写超类中方法也不能直接调用的方法。因为在其他类的方法不能直接引用匿名类声明的方法，似乎这种方法不能被调用，这种方法可能只是没有任何作用的代码，但也可能覆写超类中声明。<br>102.UR: Uninitialized read of field in constructor (UR_UNINIT_READ)<br>此构造方法中使用了一个尚未赋值的字段或属性。<br>        String a;<br>        public SA() {<br>String abc = a;<br>System.out.println(abc);<br>        }<br>103.UR: Uninitialized read of field method called from constructor of superclass (UR_UNINIT_READ_CALLED_FROM_SUPER_CONSTRUCTOR)<br>方法被超类的构造函数调用时，在当前类中的字段或属性还没有被初始化。例如：<br>abstract class A {<br>  int hashCode;<br>  abstract Object getValue();<br>  A() {<br>    hashCode = getValue().hashCode();<br>    }<br>  }<br>class B extends A {<br>  Object value;<br>  B(Object v) {<br>    this.value = v;<br>    }<br>  Object getValue() {<br>    return value;<br>  }<br>  }<br>当B是创建时，A的构造函数将在B为value赋值之前触发，然而在A的初始化方法调用getValue方法时value这个变量还没有被初始化。<br>104.USELESS_STRING: Invocation of toString on an array (DMI_INVOKING_TOSTRING_ON_ANONYMOUS_ARRAY)<br>该代码调用上匿名数组的toString（）方法，产生的结果形如[@ 16f0472并没有实际的意义。考虑使用Arrays.toString方法来转换成可读的字符串，提供该数组的内容数组。例如：<br>String[] a = { “a” };<br>System.out.println(a.toString());<br>//正确的使用为<br>System.out.println(Arrays.toString(a));<br>105.USELESS_STRING: Invocation of toString on an array (DMI_INVOKING_TOSTRING_ON_ARRAY)<br>该代码调用上数组的toString（）方法，产生的结果形如[@ 16f0472并不能显示数组的真实内容。考虑使用Arrays.toString方法来转换成可读的字符串，提供该数组的内容数组<br>106.UwF: Field only ever set to null (UWF_NULL_FIELD)<br>字段的值总是为null值，所有读取该字段的值都为null。检查错误，如果它确实没有用就删除掉。<br>107.UwF: Unwritten field (UWF_UNWRITTEN_FIELD<br>此字段是永远不会写入值。所有读取将返回默认值。检查错误（如果它被初始化？），如果它确实没有用就删除掉。</p>
<h3 id="五：Performance关于代码性能相关方面的"><a href="#五：Performance关于代码性能相关方面的" class="headerlink" title="五：Performance关于代码性能相关方面的"></a>五：Performance关于代码性能相关方面的</h3><p>1.Bx: Primitive value is boxed and then immediately unboxed (BX_BOXING_IMMEDIATELY_UNBOXED)<br>对原始值进行装箱，然后立即取消装箱。这可能是在一个未要求装箱的地方进行了手动装箱，从而迫使编译器进行立即撤消装箱的操作<br>2.Bx: Primitive value is boxed then unboxed to perform primitive coercion (BX_BOXING_IMMEDIATELY_UNBOXED_TO_PERFORM_COERCION)<br>对原始值进行装箱然后立即把它强制转换为另外一种原始类型。例如：<br>new Double(d).intValue()应该直接进行强制转换例如：(int) d<br>3.Bx: Method allocates a boxed primitive just to call toString (DM_BOXED_PRIMITIVE_TOSTRING)<br>仅仅为了调用封装类的toString()而对原始类型进行封装操作。比这种方法更有效的是调用封装类的toString(…)方法例如：<br>new Integer(1).toString()    替换为   Integer.toString(1)<br>new Long(1).toString()    替换为   Long.toString(1)<br>new Float(1.0).toString()    替换为   Float.toString(1.0)<br>new Double(1.0).toString()    替换为   Double.toString(1.0)<br>new Byte(1).toString()    替换为   Byte.toString(1)<br>new Short(1).toString()    替换为   Short.toString(1)<br>new Boolean(true).toString()    替换为   Boolean.toString(true)<br>4.Bx: Method invokes inefficient floating-point Number constructor; use static valueOf instead (DM_FP_NUMBER_CTOR)<br>使用new Double(double)方法总是会创建一个新的对象，然而使用Double.valueOf(double)方法可以把值保存在编辑器或者class library、JVM中。使用存储值的方式来避免对象的分配可以或得更好的代码性能<br>除非类必须符合Java 1.5以前的JVM，否则请使用自动装箱或valueOf（）方法创建Double和Float实例。<br>5.Bx: Method invokes inefficient Number constructor; use static valueOf instead (DM_NUMBER_CTOR)<br>使用new Integer(int)方法总是会创建一个新的对象，然而使用Integer.valueOf(int)方法可以把值保存在编辑器或者class library、JVM中。使用存储值的方式来避免对象的分配可以或得更好的代码性能<br>除非类必须符合Java 1.5以前的JVM，否则请使用自动装箱或valueOf（）方法创建Long, Integer, Short, Character, Byte实例。<br>6.Dm: The equals and hashCode methods of URL are blocking (DMI_BLOCKING_METHODS_ON_URL)<br>使用equals和hashCode方法来对url进行资源标识符解析时会引起堵塞。考虑使用java.net.URI来代替。<br>7.Dm: Maps and sets of URLs can be performance hogs (DMI_COLLECTION_OF_URLS)<br>方法或者字段使用url的map/set集合。因为equals方法或者hashCode方法来进行资源标识符解析时都会引起堵塞。考虑使用java.net.URI来代替。<br>8.Dm: Method invokes inefficient Boolean constructor; use Boolean.valueOf(…) instead (DM_BOOLEAN_CTOR)<br>使用new方法创建一个java.lang.Boolean类型能够的实例对象是浪费空间的，因为Boolean对象是不可变的而且只有两个有用的值。使用Boolean.valueOf()或者Java1.5中的自动装箱功能来创建一个Boolean实例。<br>9.Dm: Explicit garbage collection; extremely dubious except in benchmarking code (DM_GC)<br>在代码中显式的调用垃圾回收命名，这样做并不能起作用。在过去，有人在关闭操作或者finalize方法中调用垃圾回收方法导致了很多的性能浪费。这样大规模回收对象时会造成处理器运行缓慢。<br>10.Dm: Use the nextInt method of Random rather than nextDouble to generate a random integer (DM_NEXTINT_VIA_NEXTDOUBLE)<br> 如果r是一个java.util.Random对象，你可以使r.nextInt(n)生成一个0到n-1之前的随机数，而不是使用(int)(r.nextDouble() * n)<br>11.Dm: Method invokes inefficient new String(String) constructor (DM_STRING_CTOR)<br>使用java.lang.String(String)构造函数会浪费内存因为这种构造方式和String作为参数在功能上容易混乱。只是使用String直接作为参数的形式<br>12.Dm: Method invokes toString() method on a String (DM_STRING_TOSTRING)<br>调用String.toString()是多余的操作，只要使用String就可以了。<br>13.Dm: Method invokes inefficient new String() constructor (DM_STRING_VOID_CTOR)<br>使用没有参数的构造方法去创建新的String对象是浪费内存空间的，因为这样创建会和空字符串“”混淆。Java中保证完成相同的构造方法会产生描绘相同的String对象。所以你只要使用空字符串来创建就可以了。<br>14.ITA: Method uses toArray() with zero-length array argument (ITA_INEFFICIENT_TO_ARRAY)<br>当使用集合的toArray()方法时使用数组长度为0的数组作为参数。比这更有效的一种方法是<br>myCollection.toArray(new Foo[myCollection.size()])，如果数组的长度足够大就可以直接把集合中的内容包装到数组中直接返回从而避免了第二次创建一个新的数组来存放集合中值。<br>15.SBSC: Method concatenates strings using + in a loop (SBSC_USE_STRINGBUFFER_CONCATENATION)<br>在循环中构建一个String对象时从性能上讲使用StringBuffer来代替String对象<br>例如：<br>// This is bad<br>  String s = “”;<br>  for (int i = 0; i &lt; field.length; ++i) {<br>    s = s + field[i];<br>  }<br>  // This is better<br>  StringBuffer buf = new StringBuffer();<br>  for (int i = 0; i &lt; field.length; ++i) {<br>    buf.append(field[i]);<br>  }<br>  String s = buf.toString();<br>16.SS: Unread field: should this field be static? (SS_SHOULD_BE_STATIC)<br>类中所包含的final属性字段在编译器中初始化为静态的值。考虑在定义时就把它定义为static类型的。<br>17.UM: Method calls static Math class method on a constant value (UM_UNNECESSARY_MATH)<br>在方法中使用了java.lang.Math的静态方法代替常量来使用，使用常量速度和准确度会更好。 以下为Math中的方法产生的值。<br>Method Parameter<br>abs -any-<br>acos 0.0 or 1.0<br>asin 0.0 or 1.0<br>atan 0.0 or 1.0<br>atan2 0.0 cbrt 0.0 or 1.0<br>ceil -any-<br>cos 0.0<br>cosh 0.0<br>exp 0.0 or 1.0<br>expm1 0.0<br>floor -any-<br>log 0.0 or 1.0<br>log10 0.0 or 1.0<br>rint -any-<br>round -any-<br>sin 0.0<br>sinh 0.0<br>sqrt 0.0 or 1.0<br>tan 0.0<br>tanh 0.0<br>toDegrees 0.0 or 1.0<br>toRadians 0.0<br>18.UPM: Private method is never called (UPM_UNCALLED_PRIVATE_METHOD)<br>定义为Private类型方法从未被调用，应该被删除。<br>19.UrF: Unread field (URF_UNREAD_FIELD)<br>类中定义的属性从未被调用，建议删除。<br>20.UuF: Unused field (UUF_UNUSED_FIELD)<br>类中定义的属性从未被使用，建议删除。<br>21.WMI: Inefficient use of keySet iterator instead of entrySet iterator (WMI_WRONG_MAP_ITERATOR)<br>当方法中接受一个Map类型的参数时，使用keySet的迭代器比使用entrySet的迭代器效率要高。</p>
<h3 id="六：Internationalization关于代码国际化相关方面的"><a href="#六：Internationalization关于代码国际化相关方面的" class="headerlink" title="六：Internationalization关于代码国际化相关方面的"></a>六：Internationalization关于代码国际化相关方面的</h3><p>Dm: Consider using Locale parameterized version of invoked method (DM_CONVERT_CASE)<br>使用平台默认的编码格式对字符串进行大小写转换，这可能导致国际字符的转换不当。使用以下方式对字符进行转换<br>String.toUpperCase( Locale l )<br>String.toLowerCase( Locale l )</p>
<h3 id="七：Multithreaded-correctness关于代码多线程正确性相关方面的"><a href="#七：Multithreaded-correctness关于代码多线程正确性相关方面的" class="headerlink" title="七：Multithreaded correctness关于代码多线程正确性相关方面的"></a>七：Multithreaded correctness关于代码多线程正确性相关方面的</h3><p>1.DL: Synchronization on Boolean could lead to deadlock (DL_SYNCHRONIZATION_ON_BOOLEAN)<br>该代码同步一个封装的原始常量，例如一个Boolean类型。<br>private static Boolean inited = Boolean.FALSE;<br>…<br>  synchronized(inited) {<br>    if (!inited) {<br>       init();<br>       inited = Boolean.TRUE;<br>       }<br>     }<br>…<br>由于通常只存在两个布尔对象，此代码可能是同步的其他无关的代码中相同的对象，这时会导致反应迟钝和可能死锁<br>2.DL: Synchronization on boxed primitive could lead to deadlock (DL_SYNCHRONIZATION_ON_BOXED_PRIMITIVE)<br>该代码同步一个封装的原始常量，例如一个Integer类型。<br>private static Integer count = 0;<br>…<br>  synchronized(count) {<br>     count++;<br>     }<br>…<br>由于Integer对象可以共享和保存，此代码可能是同步的其他无关的代码中相同的对象，这时会导致反应迟钝和可能死锁<br>3.DL: Synchronization on interned String could lead to deadlock (DL_SYNCHRONIZATION_ON_SHARED_CONSTANT)<br>同步String类型的常量时，由于它被JVM中多个其他的对象所共有，这样在其他代码中会引起死锁。<br>4.DL: Synchronization on boxed primitive values (DL_SYNCHRONIZATION_ON_UNSHARED_BOXED_PRIMITIVE)<br>同步一个显然不是共有封装的原始值，例如一个Integer类型的对象。例如：<br>private static final Integer fileLock = new Integer(1);<br>…<br>  synchronized(fileLock) {<br>     .. do something ..<br>     }<br>…<br>它最后被定义为以下方式来代替：private static final Object fileLock = new Object();<br>5.Dm: Monitor wait() called on Condition (DM_MONITOR_WAIT_ON_CONDITION)<br>方法中以java.util.concurrent.locks.Condition对象调用wait（）。等待一个条件发生时应该使用在Condition接口中定义的await()方法。<br>6.Dm: A thread was created using the default empty run method (DM_USELESS_THREAD)<br>这个方法没有通过run方法或者具体声明Thread类，也没有通过一个Runnable对象去定义一个线程，而这个线程出来浪费资源却什么也没有去做。<br>7.ESync: Empty synchronized block (ESync_EMPTY_SYNC)<br>该代码包含一个空的同步块：synchronized() {}<br>8.IS: Inconsistent synchronization (IS2_INCONSISTENT_SYNC)<br>不合理的同步<br>9.IS: Field not guarded against concurrent access (IS_FIELD_NOT_GUARDED)<br>域不是良好的同步访问—<br>此字段被标注为net.jcip.annotations.GuardedBy，但可以在某种程度上违反注释而去访问<br>10.JLM: Synchronization performed on Lock (JLM_JSR166_LOCK_MONITORENTER)<br>实现java.util.concurrent.locks.Lock的对象调用了同步的方法。应该这样处理，对象被锁定/解锁时使用acquire（）/ release（）方法而不是使用同步的方法。<br>11.LI: Incorrect lazy initialization of static field (LI_LAZY_INIT_STATIC)<br>静态域不正确的延迟初始化–<br>这种方法包含了一个不同步延迟初始化的非volatile静态字段。因为编译器或处理器可能会重新排列指令，如果该方法可以被多个线程调用，线程不能保证看到一个完全初始化的对象。你可以让字段可变来解决此问题<br>12.LI: Incorrect lazy initialization and update of static field (LI_LAZY_INIT_UPDATE_STATIC)<br>这种方法包含一个不同步延迟初始化的静态字段。之后为字段赋值，对象存储到该位置后进一步更新或访问。字段后尽快让其他线程能够访问。如果该方法的进一步访问该字段为初始化对象提供服务，然后你有一个非常严重的多线程bug，除非别的东西阻止任何其他线程访问存储的对象，直到它完全初始化。<br>即使你有信心，该方法是永远不会被多个线程调用时，在它的值还没有被充分初始化或移动，不把它设定为static字段时它可能会更好。<br>13.ML: Method synchronizes on an updated field (ML_SYNC_ON_UPDATED_FIELD)<br>对象获取一个可变字段时进行同步。这是没有意义的，因为不同的线程可以在不同的对象同步。<br>14.MSF: Mutable servlet field (MSF_MUTABLE_SERVLET_FIELD)<br>一个web服务一般只能创建一个servlet或者jsp的实例（例如：treates是一个单利类），它会被多个线程调用这个实例的方法服务于多个同时的请求。因此使用易变的字段属性产生竞争的情况。<br>15.MWN: Mismatched notify() (MWN_MISMATCHED_NOTIFY)<br>此方法调用Object.notify（）或Object.notifyAll（）而没有获取到该对象的对象锁。调用notify（）或notifyAll（）而没有持有该对象的对象锁，将导致IllegalMonitorStateException异常。<br>16.MWN: Mismatched wait() (MWN_MISMATCHED_WAIT)<br>此方法调用Object.wait()而没有获取到该对象的对象锁。调用wait（）而没有持有该对象的对象锁，将导致IllegalMonitorStateException异常。<br>17.NP: Synchronize and null check on the same field. (NP_SYNC_AND_NULL_CHECK_FIELD)<br>如果代码块是同步的，那么久不可能为空。如果是空，同步时就会抛出NullPointerException异常。最好是在另一个代码块中进行同步。<br>18.No: Using notify() rather than notifyAll() (NO_NOTIFY_NOT_NOTIFYALL)<br>调用notify（）而不是notifyAll（）方法。 Java的监控器通常用于多个条件。调用notify（）只唤醒一个线程，这意味着该线程被唤醒只是满足的当前的唯一条件。<br>19.RS: Class’s readObject() method is synchronized (RS_READOBJECT_SYNC)<br>序列化类中定义了同步的readObject（）。通过定义，反序列化创建的对象只有一个线程可以访问，因此没有必要的readObject（）进行同步。如果的readObject（）方法本身造成对象对另一个线程可见，那么这本身就是不好的编码方式。<br>20.Ru: Invokes run on a thread (did you mean to start it instead?) (RU_INVOKE_RUN)<br>这种方法显式调用一个对象的run（）。一般来说，类是实现Runnable接口的，因为在一个新的线程他们将有自己的run（）方法，在这种情况下Thread.start（）方法调用是正确的。<br>21.SC: Constructor invokes Thread.start() (SC_START_IN_CTOR)<br>在构造函数中启动一个线程。如果类曾经被子类扩展过，那么这很可能是错的，因为线程将在子类构造之前开始启动。<br>22.SP: Method spins on field (SP_SPIN_ON_FIELD)<br>方法无限循环读取一个字段。编译器可合法悬挂宣读循环，变成一个无限循环的代码。这个类应该改变，所以使用适当的同步（包括等待和通知要求）<br>23.STCAL: Call to static Calendar (STCAL_INVOKE_ON_STATIC_CALENDAR_INSTANCE)<br>即使JavaDoc对此不包含暗示，而Calendars本身在多线程中使用就是不安全的。探测器发现当调用Calendars的实例时将会获得一个静态对象。<br>Calendar rightNow = Calendar.getInstance();<br>24.STCAL: Call to static DateFormat (STCAL_INVOKE_ON_STATIC_DATE_FORMAT_INSTANCE)<br>在官方的JavaDoc，DateFormats多线程使用本事就是不安全的。探测器发现调用一个DateFormat的实例将会获得一个静态对象。<br>myString = DateFormat.getDateInstance().format(myDate);<br>25.STCAL: Static Calendar (STCAL_STATIC_CALENDAR_INSTANCE)<br>Calendar在多线程中本身就是不安全的，如果在线程范围中共享一个Calendarde 实例而不使用一个同步的方法在应用中就会出现一些奇怪的行为。在sun.util.calendar.BaseCalendar.getCalendarDateFromFixedDate()中会抛出ArrayIndexOutOfBoundsExceptions or IndexOutOfBoundsExceptions异常。<br>26.STCAL: Static DateFormat (STCAL_STATIC_SIMPLE_DATE_FORMAT_INSTANCE)<br>DateFormat 在多线程中本身就是不安全的，如果在线程范围中共享一个DateFormat的实例而不使用一个同步的方法在应用中就会出现一些奇怪的行为。<br>27.SWL: Method calls Thread.sleep() with a lock held (SWL_SLEEP_WITH_LOCK_HELD)<br>当持有对象时调用Thread.sleep（）。这可能会导致很差的性能和可扩展性，或陷入死锁，因为其他线程可能正在等待获得锁。调用wait（）是一个更好的主意，释放对象的持有以允许其他线程运行。<br>28.UG: Unsynchronized get method, synchronized set method (UG_SYNC_SET_UNSYNC_GET)<br>这个类包含类似命名的get和set方法。在set方法是同步方法和get方法是非同步方法。这可能会导致在运行时的不正确行为，因为调用的get方法不一定返回对象一致状态。 GET方法应该同步。<br>29.UL: Method does not release lock on all paths (UL_UNRELEASED_LOCK)<br>方法获得了当前的对象所，但是在方法中始终没有释放它。一个正确的示例如下：<br>  Lock l = …;<br>    l.lock();<br>    try {<br>        // do something<br>    } finally {<br>        l.unlock();<br>    }<br>30.UL: Method does not release lock on all exception paths (UL_UNRELEASED_LOCK_EXCEPTION_PATH)<br>方法获得了当前的对象所，但是在所有的异常处理中始终没有释放它。一个正确的示例如下：<br>  Lock l = …;<br>    l.lock();<br>    try {<br>        // do something<br>    } finally {<br>        l.unlock();<br>    }<br>31.UW: Unconditional wait (UW_UNCOND_WAIT)<br>方法中包含调用java.lang.Object.wait（），而却没有放到条件流程控制中。该代码应确认条件尚未满足之前等待;先前任何通知将被忽略。<br>32.VO: A volatile reference to an array doesn’t treat the array elements as volatile (VO_VOLATILE_REFERENCE_TO_ARRAY)<br>声明一个变量引用数组，这可能不是你想要的。如果一个变量引用数组，那么对引用数组的读和写都是不安全的，但是数组元素不是变量。取得数组的变量值你可以使用java.util.concurrent包中的数组的原子性特性<br>33.WL: Sychronization on getClass rather than class literal (WL_USING_GETCLASS_RATHER_THAN_CLASS_LITERAL)<br>实例的方法中同步this.getClass()，如果这个类有子类集合，那么子类集合中的对象将会在这个类的各个子类上进行同步，这不是我们想要的效果，我们只要同步当前的类对象而不包含它的所有子类，可以同步类名.getClass()。例如，java.awt.Label的代码：<br>     private static final String base = “label”;<br>     private static int nameCounter = 0;<br>     String constructComponentName() {<br>        synchronized (getClass()) {<br>            return base + nameCounter++;<br>        }<br>     }<br>Label中的子类集合不可能在同一个子对象上进行同步，替换上面的方法为：<br>    private static final String base = “label”;<br>     private static int nameCounter = 0;<br>     String constructComponentName() {<br>        synchronized (Label.class) {<br>            return base + nameCounter++;<br>        }<br>     }<br>34.WS: Class’s writeObject() method is synchronized but nothing else is (WS_WRITEOBJECT_SYNC)<br>这个类有一个writeObject（）方法是同步的，但是这个类中没有其他的同步方法。<br>35.Wa: Condition.await() not in loop (WA_AWAIT_NOT_IN_LOOP)<br>方法没有在循环中调用java.util.concurrent.await()。如果对象是用于多种条件，打算调用wait()方法的条件可能不是实际发生的。<br>36.Wa: Wait not in loop (WA_NOT_IN_LOOP)<br>这种方法包含调用java.lang.Object.wait（），而这并不是一个循环。如果监视器用于多个条件，打算调用wait()方法的条件可能不是实际发生的。</p>
<h3 id="八：Malicious-codevulnerability关于恶意破坏代码相关方面的"><a href="#八：Malicious-codevulnerability关于恶意破坏代码相关方面的" class="headerlink" title="八：Malicious codevulnerability关于恶意破坏代码相关方面的"></a>八：Malicious codevulnerability关于恶意破坏代码相关方面的</h3><p>1.EI: May expose internal representation by returning reference to mutable object (EI_EXPOSE_REP)<br>返回一个易变对象引用并把它保存在对象字段中时会暴露对象内部的字段描述，如果接受不守信任的代码访问或者没有检查就去改变易变对象的会涉及对象的安全和其他重要属性的安全。返回一个对象的新副本，在很多情况下更好的办法。<br>2.EI2: May expose internal representation by incorporating reference to mutable object (EI_EXPOSE_REP2)<br>此代码把外部可变对象引用存储到对象的内部表示。如果实例受到不信任的代码的访问和没有检查的变化危及对象和重要属性的安全。存储一个对象的副本，在很多情况下是更好的办法。<br>3.FI: Finalizer should be protected, not public (FI_PUBLIC_SHOULD_BE_PROTECTED)<br>一个类中的finalize（）方法必须声明为protected，而不能为public类型<br>4.MS: Public static method may expose internal representation by returning array (MS_EXPOSE_REP)<br>一个public类型的静态方法返回一个数组，可能引用内部属性的暴露。任何代码调用此方法都可以自由修改底层数组。一个解决办法是返回一个数组的副本。<br>5.MS: Field should be both final and package protected (MS_FINAL_PKGPROTECT)<br>一个静态字段可能被恶意代码或另外一个包所改变的。字段可以放到protected包中也可以定义为final类型的以避免此问题。<br>6.MS: Field is a mutable array (MS_MUTABLE_ARRAY)<br>一个定义为final类型的静态字段引用一个数组时它可以被恶意代码或在另其他包中所使用。这些代码可以自由修改数组的内容。<br>7.MS: Field is a mutable Hashtable (MS_MUTABLE_HASHTABLE)<br>一个定义为final类型的静态字段引用一个Hashtable时可以被恶意代码或者在其他包中被调用，这些方法可以修改Hashtable的值。<br>8.MS: Field should be moved out of an interface and made package protected (MS_OOI_PKGPROTECT)<br>将域尽量不要定义在接口中，并声明为包保护<br>在接口中定义了一个final类型的静态字段，如数组或哈希表等易变对象。这些对象可以被恶意代码或者在其他包中被调用，为了解决这个问题，需要把它定义到一个具体的实体类中并且声明为保护类型以避免这种错误。<br>9.MS: Field should be package protected (MS_PKGPROTECT)<br>一个静态字段是可以改变的恶意代码或其他的包访问修改。可以把这种类型的字段声明为final类型的以防止这种错误。</p>
<h3 id="十：Dodgy关于代码运行期安全方面的"><a href="#十：Dodgy关于代码运行期安全方面的" class="headerlink" title="十：Dodgy关于代码运行期安全方面的"></a>十：Dodgy关于代码运行期安全方面的</h3><p>1.XSS: Servlet reflected cross site scripting vulnerability (XSS_REQUEST_PARAMETER_TO_SEND_ERROR)<br>在代码中在Servlet输出中直接写入一个HTTP参数，这会造成一个跨站点的脚本漏洞。<br>2.XSS: Servlet reflected cross site scripting vulnerability (XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER)<br>代码直接写入参数的HTTP服务器错误页（使用HttpServletResponse.sendError）。表达了类似的不受信任的输入会引起跨站点脚本漏洞。<br>3.BC: Questionable cast to abstract collection (BC_BAD_CAST_TO_ABSTRACT_COLLECTION)<br>在代码投把一个集合强制类型转换为一个抽象的集合（如list，set或map）。保证该对象类型和将要转换的类型是一致的。如果你只是想要便利一个集合，那么你就不必将它转换为Set或List。<br>4.BC: Questionable cast to concrete collection (BC_BAD_CAST_TO_CONCRETE_COLLECTION)<br>代码把抽象的集合（如List，Set，或Collection）强制转换为具体落实类型（如一个ArrayList或HashSet）。这可能不正确，也可能使您的代码很脆弱，因为它使得难以在今后的切换指向其他具体实现。除非你有特别理由这样做，否则只需要使用抽象的集合类。<br>5.BC: Unchecked/unconfirmed cast (BC_UNCONFIRMED_CAST)<br>强制类型转换操作没有经过验证，而且不是所有的此种类型装换过的类都可以再强制类型转换为原类型。在代码中需要进行逻辑判断以保证可以进行这样的操作。<br>6.BC: instanceof will always return true (BC_VACUOUS_INSTANCEOF)<br>instanceof测试将始终返回真（除非被测试的值为空）。虽然这是安全，确保它是不是说明一些误解或其他一些逻辑错误。如果你真的想测试是空的价值，也许会更清楚这样做的更好空试验，而不是一个instanceof测试。<br>7.BSHIFT: Unsigned right shift cast to short/byte (ICAST_QUESTIONABLE_UNSIGNED_RIGHT_SHIFT)<br>无符号数右移后进行转换为short或者byte类型时可能会丢弃掉高位的值，这样的结果就是有符合数和无符号数无法区分（这取决于移位大小）<br>8.CI: Class is final but declares protected field (CI_CONFUSED_INHERITANCE)<br>这个类被声明为final的，而是字段属性却声明为保护类型的。由于是final类，它不能再被继承，而再声明为保护类型的很容易造成混淆。为了从外部能正确的使用它应该把它们声明为private或者public类型。<br>9.DB: Method uses the same code for two branches (DB_DUPLICATE_BRANCHES)<br>此方法使用相同的代码，以实现两个有条件的分支。检查以确保这是不是一个编码错误。<br>10.DB: Method uses the same code for two switch clauses (DB_DUPLICATE_SWITCH_CLAUSES)<br>他的方法使用相同的代码来实现两个switch的声明条款。这可能是重复代码的情况，但可能也显示出编码的错误。<br>11.DLS: Dead store to local variable (DLS_DEAD_LOCAL_STORE)<br>该指令为局部变量赋值，但在其后的没有对她做任何使用。通常，这表明一个错误，因为值从未使用过。<br>12.DLS: Useless assignment in return statement (DLS_DEAD_LOCAL_STORE_IN_RETURN)<br>本声明把一个局部变量放到方法的返回语句中。这对于方法中局部变量来说是没有意思的。<br>13.DLS: Dead store of null to local variable (DLS_DEAD_LOCAL_STORE_OF_NULL)<br>把一个本地变量赋值为null值，并且再也没有对这个变量做任何的操作。这样可能是为了垃圾回收，而是Java SE 6.0，这已不再需要。<br>14.DMI: Code contains a hard coded reference to an absolute pathname (DMI_HARDCODED_ABSOLUTE_FILENAME)<br>此代码包含文件对象为一个绝对路径名（例如，新的文件（“/ home/dannyc/workspace/j2ee/src/share/com/sun/enterprise/deployment”）;<br>15.DMI: Non serializable object written to ObjectOutput (DMI_NONSERIALIZABLE_OBJECT_WRITTEN)<br>代码中让一个非序列化的对象出现在ObjectOutput.writeObject()方法中，这样会引起一个错误。<br>16.DMI: Invocation of substring(0), which returns the original value (DMI_USELESS_SUBSTRING)<br>此代码调用了subString(0)方法，它将返回原来的值。<br>17.Eq: Class doesn’t override equals in superclass (EQ_DOESNT_OVERRIDE_EQUALS)<br>子类定义了一个新的equals方法但是却不是覆写了父类本省的equals()方法。<br>18.FE: Test for floating point equality (FE_FLOATING_POINT_EQUALITY)<br>此操作比较两个浮点值是否相等。由于浮点运算可能会涉及到舍入，计算float和double值可能不准确。如果要求值必须准确，如货币值，可以考虑使用固定精度类型，如BigDecimal类型的值来比较<br>19.FS: Non-Boolean argument formatted using %b format specifier (VA_FORMAT_STRING_BAD_CONVERSION_TO_BOOLEAN)<br>使用%b去格式化Boolean类型的值不正确的但是它不会抛出异常，任何非空的值都会输出true，任何为空的值都会输出false<br>20.IC: Initialization circularity (IC_INIT_CIRCULARITY)<br>在引用两个相互调用为环状static方法去初始化一个实例时是错误的。<br>21.ICAST: integral division result cast to double or float (ICAST_IDIV_CAST_TO_DOUBLE)<br>整形数除法强制转换为double或者float类型。<br>int x = 2;<br>int y = 5;<br>// Wrong: yields result 0.0<br>double value1 =  x / y;<br>// Right: yields result 0.4<br>double value2 =  x / (double) y;<br>22.ICAST: Result of integer multiplication cast to long (ICAST_INTEGER_MULTIPLY_CAST_TO_LONG)<br>整形数做乘法运算结果转换为long值时如果采用<br>long convertDaysToMilliseconds(int days) { return 1000<em>3600</em>24<em>days; } 结果会因为超出整形的范围而出错。<br>如果使用：<br>long convertDaysToMilliseconds(int days) { return 1000L</em>3600<em>24</em>days; }<br>或者：<br>static final long MILLISECONDS_PER_DAY = 24L<em>3600</em>1000;<br>        long convertDaysToMilliseconds(int days) { return days * MILLISECONDS_PER_DAY; }<br>都可以避免此问题。<br>23.IM: Computation of average could overflow (IM_AVERAGE_COMPUTATION_COULD_OVERFLOW)<br>代码中使用x % 2 == 1的方法去验证运算是否存在余数的情况，但是如果出现负数的情况就不起作用了。使用x &amp; 1 == 1, or x % 2 != 0来代替<br>24.INT: Vacuous comparison of integer value (INT_VACUOUS_COMPARISON)<br>整形数进行比较结果总是不变。例如：x &lt;= Integer.MAX_VALUE<br>25.MTIA: Class extends Servlet class and uses instance variables (MTIA_SUSPECT_SERVLET_INSTANCE_FIELD)<br>这个类扩展从Servlet类，并使用实例的成员变量。由于只有一个Servlet类的实例，并在多线程方式使用，这种模式有可能存在问题。考虑只使用方法的局部变量。<br>26.MTIA: Class extends Struts Action class and uses instance variables (MTIA_SUSPECT_STRUTS_INSTANCE_FIELD)<br>类扩展自Struts的Action类并使用这个实例的成员变量，因为在Struts框架中只存在一个Action实例对象并且使用在多线程的情况下很可能会出现问题。<br>27.NP: Dereference of the result of readLine() without nullcheck (NP_DEREFERENCE_OF_READLINE_VALUE)<br>对readLine()的结果值没有进行判空操作就去重新赋值，这样的操作可以会抛出空指针异常。<br>28.NP: Immediate dereference of the result of readLine() (NP_IMMEDIATE_DEREFERENCE_OF_READLINE)<br>对readLine()的结果立即赋值，这样的操作可以会抛出空指针异常。<br>29.NP: Possible null pointer dereference due to return value of called method (NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE)<br>方法的返回值没有进行是否为空的检查就重新赋值，这样可能会出现空指针异常。<br>30.NP: Parameter must be nonnull but is marked as nullable (NP_PARAMETER_MUST_BE_NONNULL_BUT_MARKED_AS_NULLABLE)<br>参数值在任何情况下都不能为空，但是有明确的注释它可以为空。<br>31.NS: Potentially dangerous use of non-short-circuit logic (NS_DANGEROUS_NON_SHORT_CIRCUIT)<br>代码中使用（&amp; or |）代替（&amp;&amp; or ||）操作，这会造成潜在的危险。<br>32.NS: Questionable use of non-short-circuit logic (NS_NON_SHORT_CIRCUIT)<br>代码中使用（&amp; or |）代替（&amp;&amp; or ||）操作，会引起不安全的操作<br>33.PZLA: Consider returning a zero length array rather than null (PZLA_PREFER_ZERO_LENGTH_ARRAYS)<br>考虑返回一个零长度的数组，而不是null值<br>34.QF: Complicated, subtle or wrong increment in for-loop (QF_QUESTIONABLE_FOR_LOOP)<br>确定这个循环是正确的变量递增，看起来，另一个变量被初始化，检查的循环。这是由于for循环中太复杂的定义造成的。<br>35.RCN: Redundant comparison of non-null value to null (RCN_REDUNDANT_COMPARISON_OF_NULL_AND_NONNULL_VALUE)<br>方法中包含一个不能为空的赋值还包含一个可以为空的赋值。冗余比较非空值为空。<br>36.RCN: Redundant comparison of two null values (RCN_REDUNDANT_COMPARISON_TWO_NULL_VALUES)<br>方法中对两个null值进行比较<br>37.RCN: Redundant nullcheck of value known to be non-null (RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE)<br>方法中对不为空的值进行为空的判断。<br>38.REC: Exception is caught when Exception is not thrown (REC_CATCH_EXCEPTION)<br>在try/catch块中捕获异常，但是异常没有在try语句中抛出而RuntimeException又没有明确的被捕获<br>39.RI: Class implements same interface as superclass (RI_REDUNDANT_INTERFACES)<br>子类和父类都实现了同一个接口，这种定义是多余的。<br>40.RV: Method discards result of readLine after checking if it is nonnull (RV_DONT_JUST_NULL_CHECK_READLINE)<br>readLine方法的结果不为空时被抛弃<br>41.RV: Remainder of 32-bit signed random integer (RV_REM_OF_RANDOM_INT)<br>此代码生成一个随机的符号整数，然后计算另一个值的。由于随机数可以是负数，所以其余操作的结果也可以是负面的。考虑使用Random.nextInt（int）方法代替。<br>42.SA: Double assignment of local variable (SA_LOCAL_DOUBLE_ASSIGNMENT)<br>为一个局部变量两次赋值，这样是没有意义的。例如：<br>public void foo() {<br>    int x,y;<br>    x = x = 17;<br>  }<br>43.SA: Self assignment of local variable (SA_LOCAL_SELF_ASSIGNMENT)<br>局部变量使用自身给自己赋值<br>public void foo() {<br>    int x = 3;<br>    x = x;<br>  }<br>44.SF: Switch statement found where one case falls through to the next case (SF_SWITCH_FALLTHROUGH)<br>Switch语句中一个分支执行后又执行了下一个分支。通常case后面要跟break 或者return语句来跳出。<br>45.SF: Switch statement found where default case is missing (SF_SWITCH_NO_DEFAULT)<br>Switch没有默认情况下执行的case语句。<br>46.Se: private readResolve method not inherited by subclasses (SE_PRIVATE_READ_RESOLVE_NOT_INHERITED)<br>声明为private的序列化方法被子类继承<br>47.UCF: Useless control flow (UCF_USELESS_CONTROL_FLOW)<br>没有任何作用的条件语句。<br>if (argv.length == 0) {<br>        // TODO: handle this case<br>        }<br>48.UCF: Useless control flow to next line (UCF_USELESS_CONTROL_FLOW_NEXT_LINE)<br>无效的条件控制语句，注意if (argv.length == 1);以“;”结尾，下面的语句无论是否满足都会运行。<br>if (argv.length == 1);<br>        System.out.println(“Hello, “ + argv[0]);<br>49.UwF: Field not initialized in constructor (UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR)<br>字段从来没有在任何构造函数初始化，对象被创建后值为空。如果该字段未被定义就重新赋值会产生一个空指针异常。<br>50.XFB: Method directly allocates a specific implementation of xml interfaces (XFB_XML_FACTORY_BYPASS)<br>方法自定义了一种XML接口的实现类。最好是使用官方提供的工厂类来创建这些对象，以便可以在运行期中改变。例如：<br>javax.xml.parsers.DocumentBuilderFactory<br>javax.xml.parsers.SAXParserFactory<br>javax.xml.transform.TransformerFactory<br>org.w3c.dom.Document.createXXXX</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cenrise.com/2017/05/30/review/Sonar代码审查-缺陷和修改/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongpo.jia">
      <meta itemprop="description" content="个人博客">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="中起之星">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/30/review/Sonar代码审查-缺陷和修改/" itemprop="url">
                  Sonar代码审查-缺陷和修改
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-05-30 16:43:49" itemprop="dateCreated datePublished" datetime="2017-05-30T16:43:49+08:00">2017-05-30</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-05-30 17:38:07" itemprop="dateModified" datetime="2018-05-30T17:38:07+08:00">2018-05-30</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/review/" itemprop="url" rel="index"><span itemprop="name">review</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Sonar代码审查-缺陷和修改"><a href="#Sonar代码审查-缺陷和修改" class="headerlink" title="Sonar代码审查-缺陷和修改"></a>Sonar代码审查-缺陷和修改</h2><p>Resources should be closed<br>资源未关闭，打开发现有两处用到的IO流没有关闭</p>
<p>Conditions should not unconditionally evaluate to “TRUE” or to “FALSE”<br>if/else判断里出现了重复判断，比如在if(a&gt;10)的执行体里面又判断if(a&lt;0)，而后者肯定不会是true</p>
<p>Exception handlers should preserve the original exception<br>处理异常的时候应该保留原始的异常情况，不要直接来个catch(Exception e)了事</p>
<p> Throwable.printStackTrace(…) should not be called<br>不应该直接调用e.printStackTrace()，而是用Loggers来处理（就是打Log）。</p>
<p>Loggers的优势是：Users are able to easily retrieve the logs.<br>The format of log messages is uniform and allow users to browse the logs easily.<br>Instance methods should not write to “static” fields6<br>不要用实例方法改变静态成员，理想情况下，静态变量只通过同步的静态方法来改变</p>
<p>“public static” fields should be constant<br>公共静态成员应该加上final，也就是public static final 一般不分家</p>
<p>Thread.run() and Runnable.run() should not be called directly<br>不应该直接调用Thread和Runnaale对象的run方法，直接调用run会使得run方法执行在当前线程，失去了开启新线程的意义。但有时候可能会这样做，下面有个例子。</p>
<p>Generic exceptions should never be thrown<br>不太理解，大意是说不要直接抛Error,RuntimeException/Throwable/Exception这样的通用的异常。我的具体应用是：throw new Error(“Error copying database”)，给出的建议是：Define and throw a dedicated exception instead of using a generic one（定义并抛出一个专用的异常来代替一个通用的异常）</p>
<p>Class variable fields should not have public accessibility<br>类变量不要设置为public，而是设为private，再提供get和set方法。</p>
<p>Sections of code should not be “commented out”<br>不要再注释中出现大量的代码段，会使代码可读性变差</p>
<p>Package declaration should match source file directory<br>这个没理解，包的声明应该与源文件目录匹配。</p>
<p>Utility classes should not have public constructors<br>工具类不应该有公共的构造器，也就是说至少要有一个private的构造器，如果没有，默认的构造器是public的。</p>
<p>The diamond operator (“&lt;&gt;”) should be used<br>在定义集合的时候，等号右边的&lt;&gt;内不需要再写上元素类型，直接空着就行。</p>
<p>Lambdas and anonymous classes should not have too many lines<br>Lambdas表达式和匿名内部类不要写太多行，一般最多写20行。</p>
<p>Anonymous inner classes containing only one method should become lambdas8<br>只包含一个方法的匿名内部类应该写成Lambdas表达式的形式，增强代码可读性</p>
<p>Try-with-resources should be used8<br>用Try-with-resources的形式取代try/catch/finally的形式，这个有待于以后学习。<br><figure class="highlight plain"><figcaption><span>con </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   try (PreparedStatement prep = con.prepareConnection(&quot;Update ...&quot;)) &#123;</span><br><span class="line">       //prep.doSomething();</span><br><span class="line">       //...</span><br><span class="line">       //etc</span><br><span class="line">con.commit();</span><br><span class="line">   &#125; catch (SQLException e) &#123;</span><br><span class="line">       //any other actions necessary on failure</span><br><span class="line">       con.rollback();</span><br><span class="line">       //consider a re-throw, throwing a wrapping exception, etc</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Methods should not be empty<br>不要写空方法，除非这种情况：An abstract class may have empty methods, in order to provide default implementations for child classes.</p>
<p>Source files should not have any duplicated blocks<br>源文件中不要出现任何重复的代码段或行或字符串等。没理解。</p>
<p>“switch case” clauses should not have too many lines<br>“switch case” 每个case里面的代码不要太长，太长的话可以考虑写个方法代替，主要是为了增强代码可读性</p>
<p>Nested blocks of code should not be left empty<br>嵌套代码块不要是空的，比如 if( a &gt; 0 ) {  doSomething()  } else { }，这时候应该把后面的else{}去掉。</p>
<p>Methods should not be too complex<br>方法不要太复杂，否则难以理解和维护。</p>
<p>Unused private fields should be removed<br>没有使用的private的成员变量应该移除掉。</p>
<p>Dead stores should be removed<br>没有用到的本地变量或其他死存储应该移除掉，也就是写方法的时候，定义的变量如果后来发现根本用不到，要记得删掉那行代码。</p>
<p>“switch” statements should end with a “default” clause<br>switch语句应该以default结束，这是一种defensive programming思想</p>
<p>Unused method parameters should be removed<br>没有用到的方法参数应该移除掉</p>
<p>Control flow statements “if”, “for”, “while”, “switch” and “try” should not be nested too deeply4<br>if /for/while/try这样的嵌套不要太复杂</p>
<p>Useless parentheses around expressions should be removed to prevent any misunderstanding3<br>没有意义的括号不要随便加，以免造成误解，比如”=”两边对象类型是相同的，就不要强转。</p>
<p>“for” loop stop conditions should be invariant<br>for循环的结果条件不能是变量，而应该是常量</p>
<p>“static” members should be accessed statically<br>static成员是与类、静态方法相联系的。</p>
<p>Catches should be combined<br>具体参考下面的18，我还没理解</p>
<p>Primitives should not be boxed just for “String” conversion<br>不要使用 4+” “这样的方式将int值转变为字符串，而是使用 Integer.toString(4)这样的方式。<br>就像Integer.parseInt(“我是字符串”)这样，不要偷懒。</p>
<p>Classes should not be empty<br>不要写空类</p>
<p>Unused local variables should be removed<br>没有用到的本地变量要删掉</p>
<p>“entrySet()” should be iterated when both the key and value are needed<br>直接看英文更直接：When only the keys from a map are needed in a loop, iterating the keySet makes sense. But when both the key and the value are needed, it’s more efficient to iterate theentrySet, which will give access to both the key and value, instead.<br>也就是说，如果只需要Map的Key，那么直接iterate这个Map的keySet就可以了，但是如果Key和value都需要，就iterate这个Map。具体看下面的19.</p>
<p>Method parameters, caught exceptions and foreach variables should not be reassigned<br>方法参数/捕获的异常/foreach的变量不应该被重新赋值。</p>
<p>Collection.isEmpty() should be used to test for emptiness<br>当判断集合是否为空的时候，不要使用if (myCollection.size() == 0) 这样的方式，而是使用if (myCollection.isEmpty()这样的方式，后者性能更高。</p>
<p>Standard outputs should not be used directly to log anything<br>标准输出不直接打印任何东西，也就是打log的时候，不要使用System.out.println(“My Message”)这样的方式，而是使用logger.log(“My Message”)这种方式。</p>
<p>Generic wildcard types should not be used in return parameters<br>通配符不应该出现在返回声明中。比如这句：List &lt;? extends Animal&gt;getAnimals(){…}， 我们无法知道“是否可以把a Dog, a Cat 等加进去”，等之后用到这个方法的时候，我们没必要去考虑这种问题（前面引号里面的）。</p>
<p>Synchronized classes Vector, Hashtable, Stack and StringBuffer should not be used1<br>不要使用同步的Vector/HashTable/Stack/StringBuffer等。在早期，出于线程安全问题考虑，java API 提供了这些类。但是同步会极大影响性能，即使是在同一个线程中使用他们。<br>通常可以这样取代：<br><code>ArrayList  or  LinkedList   instead of  Vector
Deque  instead of  Stack
HashMap  instead of  Hashtable
StringBuilder  instead of  StringBuffer
Exit methods should not be called</code><br>尽量不要调用system.exit()方法。</p>
<p>Local Variables should not be declared and then immediately returned or thrown<br>本地变量如果赋值之后直接return了，那就直接return本地变量的赋值语句。</p>
<p>Field names should comply with a naming convention<br>命名要规范</p>
<p>Local variable and method parameter names should comply with a naming convention<br>命名要规范</p>
<p>String literals should not be duplicated5<br>字符串不应该重复，如果多次用到同一字符串，建议将该字符串定义为字符串常量，再引用。</p>
<p>Return of boolean expressions should not be wrapped into an “if-then-else” statement3<br>不要写if (  a &gt; 4  ) {  return false  } else { return true }这样的代码，直接写return a &gt; 4。</p>
<p>Static non-final field names should comply with a naming convention<br>命名要规范</p>
<p>Modifiers should be declared in the correct order<br>修饰符等要按约定俗成的顺序书写 ，例如，写成public static 而不是static public </p>
<p>The members of an interface declaration or class should appear in a pre-defined order2<br>与前面的一个问题类似，根据Oracle定义的Java代码规范中，不同代码的出现位置应该如下所示：<br>class and instance variables–Constructors–Methods</p>
<p>Array designators “[]” should be on the type, not the variable<br>数组的括号要写在类型后面，而不是变量后面，例如 int[] a 而不是int a[]</p>
<p>Multiple variables should not be declared on the same line1<br>不要在同一行定义多个变量</p>
<p>“switch” statements should have at least 3 “case” clauses<br>当至少有3种或者3种以上的情况时，才考虑用switch，否则用if/else的形式。</p>
<p>Overriding methods should do more than simply call the same method in the super class<br>既然在子类中重写了父类的某个方法，那就再这个方法中做些与父类方法不同的事情，否则没必要重写。</p>
<p>Statements should be on separate lines<br>不要把这样的代码写在同一行：if(someCondition)    doSomething()；而是应该写成下面的形式<br>if(someCondition) {<br>doSomething()<br>}<br>Method names should comply with a naming convention1<br>命名要规范<br>“TODO” tags should be handle    TODO标签要及时处理，该做的事情不要忘了做</p>
<h2 id="部分规则详细说明"><a href="#部分规则详细说明" class="headerlink" title="部分规则详细说明"></a>部分规则详细说明</h2><h4 id="1-The-members-of-an-interface-declaration-or-class-should-appear-in-a-pre-defined-order"><a href="#1-The-members-of-an-interface-declaration-or-class-should-appear-in-a-pre-defined-order" class="headerlink" title="1.The members of an interface declaration or class should appear in a pre-defined order"></a>1.The members of an interface declaration or class should appear in a pre-defined order</h4><p>正确的顺序如下所示：静态成员变量→成员变量→构造器→方法</p>
<figure class="highlight plain"><figcaption><span>class Foo&#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static final int OPEN = 4;  //Class and instance variables</span><br><span class="line">private int field = 0;</span><br><span class="line">public Foo() &#123;...&#125;    //Constructors</span><br><span class="line">public boolean isTrue() &#123;...&#125;    //Methods</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-The-diamond-operator-“-lt-gt-”-should-be-used"><a href="#2-The-diamond-operator-“-lt-gt-”-should-be-used" class="headerlink" title="2.The diamond operator (“&lt;&gt;”) should be used"></a>2.The diamond operator (“&lt;&gt;”) should be used</h4><p>Noncompliant Code Example：不规范的示例</p>
<figure class="highlight plain"><figcaption><span>strings </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;Integer&gt;&gt; map = new HashMap&lt;String, List&lt;Integer&gt;&gt;();  // Noncompliant</span><br><span class="line">Compliant Solution ：规范的示例</span><br><span class="line">List&lt;String&gt; strings = new ArrayList&lt;&gt;();</span><br><span class="line">Map&lt;String, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>
<h4 id="3-Sections-of-code-should-not-be-“commented-out”"><a href="#3-Sections-of-code-should-not-be-“commented-out”" class="headerlink" title="3.Sections of code should not be “commented out”"></a>3.Sections of code should not be “commented out”</h4><p>代码片段不应该出现在注释中，这样会bloat程序，可读性变差<br><code>Programmers should not comment out code as it bloats programs and reduces readability.
Unused code should be deleted and can be retrieved from source control history if required.</code></p>
<h4 id="4-Utility-classes-should-not-have-public-constructors"><a href="#4-Utility-classes-should-not-have-public-constructors" class="headerlink" title="4.Utility classes should not have public constructors"></a>4.Utility classes should not have public constructors</h4><p>工具类不应该有public的构造器，也就是工具类至少要定义一个non-public的构造器<br>Utility classes, which are a collection of static members, are not meant to be instantiated. Even abstract utility classes, which can be extended, should not have public constructors.<br>Java adds an implicit public constructor to every class which does not define at least one explicitly. Hence, at least one non-public constructor should be defined.</p>
<figure class="highlight plain"><figcaption><span>StringUtils &#123;</span><a href="//">Noncompliant Code Example</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    public static String concatenate(String s1, String s2) &#123;</span><br><span class="line">          return s1 + s2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><figcaption><span>StringUtils &#123;</span><a href="//Compliant">Solution</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    private StringUtils() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public static String concatenate(String s1, String s2) &#123;</span><br><span class="line">    return s1 + s2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-”public-static”-fields-should-be-constant"><a href="#5-”public-static”-fields-should-be-constant" class="headerlink" title="5.”public static” fields should be constant"></a>5.”public static” fields should be constant</h4><p>公共的静态成员应该加上final来修饰<br>There is no good reason to declare a field “public” and “static” without also declaring it “final”. Most of the time this is a kludge to share a state among several objects. But with this approach, any object can do whatever it wants with the shared state, such as setting it to null.<br>public static Foo foo = new Foo();//不规范的<br>public static final Foo FOO = new Foo();//规范的</p>
<p>6.Class variable fields should not have public accessibility</p>
<figure class="highlight plain"><figcaption><span>class MyClass &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static final int SOME_CONSTANT = 0;    // Compliant - constants are not checked</span><br><span class="line">public String firstName;                      // Noncompliant</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><figcaption><span>class MyClass &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static final int SOME_CONSTANT = 0;    // Compliant - constants are not checked</span><br><span class="line">private String firstName;                      // Compliant</span><br><span class="line">public String getFirstName() &#123;</span><br><span class="line">return firstName;</span><br><span class="line">&#125;</span><br><span class="line">public void setFirstName(String firstName) &#123;</span><br><span class="line">this.firstName = firstName;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">#### 7.Static non-final field names should comply with a naming convention</span><br><span class="line">public final class MyClass &#123;//Noncompliant Code Example</span><br><span class="line">      private static String foo_bar;</span><br><span class="line">&#125;</span><br><span class="line">class MyClass &#123;//Compliant Solution</span><br><span class="line">private static String fooBar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="8-”switch”-statements-should-have-at-least-3-“case”-clauses"><a href="#8-”switch”-statements-should-have-at-least-3-“case”-clauses" class="headerlink" title="8.”switch” statements should have at least 3 “case” clauses"></a>8.”switch” statements should have at least 3 “case” clauses</h4><p>当有3种或3种情况以上的时候，才用switch，否则用if/else<br>switch statements are useful when there are many different cases depending on the value of the same expression.<br>For just one or two cases however, the code will be more readable with if statements.</p>
<h4 id="9-String-literals-should-not-be-duplicated"><a href="#9-String-literals-should-not-be-duplicated" class="headerlink" title="9.String literals should not be duplicated"></a>9.String literals should not be duplicated</h4><figure class="highlight plain"><figcaption><span> </span><a href="//">Noncompliant - "action1" is duplicated 3 times</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">execute(&quot;action1&quot;);</span><br><span class="line">release(&quot;action1&quot;);</span><br><span class="line"></span><br><span class="line">private static final String ACTION_1 = &quot;action1&quot;;  // Compliant</span><br><span class="line">prepare(ACTION_1);                                            // Compliant</span><br><span class="line">execute(ACTION_1);</span><br><span class="line">release(ACTION_1);</span><br></pre></td></tr></table></figure>
<h4 id="10-Return-of-boolean-expressions-should-not-be-wrapped-into-an-“if-then-else”-statement"><a href="#10-Return-of-boolean-expressions-should-not-be-wrapped-into-an-“if-then-else”-statement" class="headerlink" title="10.Return of boolean expressions should not be wrapped into an “if-then-else” statement"></a>10.Return of boolean expressions should not be wrapped into an “if-then-else” statement</h4><p>Replace this if-then-else statement by a single return statement</p>
<figure class="highlight plain"><figcaption><span>(expression) &#123;//Noncompliant Code Example</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">      return true;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">     return false;</span><br><span class="line">&#125;</span><br><span class="line">return expression;//Compliant Solution</span><br><span class="line">return !!expression;</span><br></pre></td></tr></table></figure>
<h4 id="11-Method-parameters-caught-exceptions-and-foreach-variables-should-not-be-reassigned"><a href="#11-Method-parameters-caught-exceptions-and-foreach-variables-should-not-be-reassigned" class="headerlink" title="11.Method parameters, caught exceptions and foreach variables should not be reassigned"></a>11.Method parameters, caught exceptions and foreach variables should not be reassigned</h4><p>方法参数，捕获的异常，foreach里的变量，都不应该重新赋值</p>
<figure class="highlight plain"><figcaption><span>MyClass &#123;//Noncompliant Code Example：不规范代码示例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    public String name;</span><br><span class="line">    public MyClass(String name) &#123;</span><br><span class="line">            name = name;          // Noncompliant - useless identity assignment</span><br><span class="line">    &#125;</span><br><span class="line">    public int add(int a, int b) &#123;</span><br><span class="line">        a = a + b;                // Noncompliant</span><br><span class="line">        return a;                 // Seems like the parameter is returned as is, what is the point?</span><br><span class="line">   &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyClass foo = new MyClass();</span><br><span class="line">        int a = 40;</span><br><span class="line">        int b = 2;</span><br><span class="line">        foo.add(a, b);                  // Variable &quot;a&quot; will still hold 40 after this call</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><figcaption><span>MyClass &#123;//Compliant Solution：规范代码示例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    public String name;</span><br><span class="line">    public MyClass(String name) &#123;</span><br><span class="line">         this.name = name;              // Compliant</span><br><span class="line">    &#125;</span><br><span class="line">    public int add(int a, int b) &#123;</span><br><span class="line">        return a + b;                  // Compliant</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    MyClass foo = new MyClass();</span><br><span class="line">        int a = 40;</span><br><span class="line">        int b = 2;</span><br><span class="line">        foo.add(a, b);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="12-Local-Variables-should-not-be-declared-and-then-immediately-returned-or-thrown"><a href="#12-Local-Variables-should-not-be-declared-and-then-immediately-returned-or-thrown" class="headerlink" title="12.Local Variables should not be declared and then immediately returned or thrown"></a>12.Local Variables should not be declared and then immediately returned or thrown</h4><p>Noncompliant Code Example：不规范代码示例</p>
<figure class="highlight plain"><figcaption><span>long computeDurationInMilliseconds() &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">long duration = (((hours * 60) + minutes) * 60 + seconds ) * 1000 ;</span><br><span class="line">return duration;</span><br><span class="line">&#125;</span><br><span class="line">public void doSomething() &#123;</span><br><span class="line">RuntimeException myException = new RuntimeException();</span><br><span class="line">throw myException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Compliant Solution：规范代码示例</p>
<figure class="highlight plain"><figcaption><span>long computeDurationInMilliseconds() &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">return (((hours * 60) + minutes) * 60 + seconds ) * 1000 ;</span><br><span class="line">&#125;</span><br><span class="line">public void doSomething() &#123;</span><br><span class="line">throw new RuntimeException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="13-Thread-run-and-Runnable-run-should-not-be-called-directly"><a href="#13-Thread-run-and-Runnable-run-should-not-be-called-directly" class="headerlink" title="13.Thread.run() and Runnable.run() should not be called directly"></a>13.Thread.run() and Runnable.run() should not be called directly</h4><p>The purpose of theThread.run()andRunnable.run()methods is to execute code in a separate, dedicated thread. Calling those methods directly doesn’t make sense because it causes their code to be executed in the current thread.<br>Thread和Runnable里面的run方法设计的目的是让run方法里面的代码在不同的线程中执行。如果直接调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Noncompliant Code Example：不规范的代码示例</span><br><span class="line">Thread myThread = new Thread(runnable);</span><br><span class="line">myThread.run(); // Noncompliant</span><br><span class="line"></span><br><span class="line">Compliant Solution：规范代码示例</span><br><span class="line">Thread myThread = new Thread(runnable);</span><br><span class="line">myThread.start(); // Compliant</span><br></pre></td></tr></table></figure></p>
<p>这部分内容为个人理解，可以略过<br>但在有些情况，也会直接调用Runnable的run方法，<br>下面这个postTaskSafely方法会保证task永远在主线程中执行</p>
<figure class="highlight plain"><figcaption><span>static void postTaskInMainThread(Runnable task) &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">     int curThreadId= android.os.Process.myTid();//得到当前线程的id</span><br><span class="line">    if(curThreadId==getMainThreadId()) &#123;// 如果当前线程是主线程</span><br><span class="line">            task.run();//直接执行</span><br><span class="line">    &#125;else&#123;// 如果当前线程不是主线程</span><br><span class="line">        getMainThreadHandler().post(task);//用主线程的Handler来post</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="14-Lambdas-and-anonymous-classes-should-not-have-too-many-lines"><a href="#14-Lambdas-and-anonymous-classes-should-not-have-too-many-lines" class="headerlink" title="14.Lambdas and anonymous classes should not have too many lines"></a>14.Lambdas and anonymous classes should not have too many lines</h4><p>Anonymous classes and lambdas (with Java 8) are a very convenient and compact way to inject a behavior without having to create a dedicated class. But those anonymous inner classes and lambdas should be used only if the behavior to be injected can be defined in a few lines of code, otherwise the source code can quickly become unreadable.<br>anonymous class number of lines ： at most 20</p>
<h4 id="15-Resources-should-be-closed：该关闭的一定记得关闭"><a href="#15-Resources-should-be-closed：该关闭的一定记得关闭" class="headerlink" title="15.Resources should be closed：该关闭的一定记得关闭"></a>15.Resources should be closed：该关闭的一定记得关闭</h4><p>Java’s garbage collection cannot be relied on to clean up everything. Specifically, connections, streams, files and other classes that implement theCloseableinterface or it’s super-interface,AutoCloseable, must be manually closed after creation. Failure to do so will result in a resource leak which could bring first the application and then perhaps the box it’s on to their knees.<br>Noncompliant Code Example：不规范的代码示例</p>
<figure class="highlight plain"><figcaption><span>stream </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    for (String property : propertyList) &#123;</span><br><span class="line">    stream = new FileOutputStream(&quot;myfile.txt&quot;);  // Noncompliant</span><br><span class="line">    // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;catch(Exception e)&#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">    stream.close();  // Multiple streams were opened. Only the last is closed.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Compliant Solution：规范代码示例</p>
<figure class="highlight plain"><figcaption><span>stream </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> try&#123;</span><br><span class="line">     stream = new FileOutputStream(&quot;myfile.txt&quot;);</span><br><span class="line">     for (String property : propertyList) &#123;</span><br><span class="line">         // ...</span><br><span class="line">     &#125;</span><br><span class="line">&#125;catch(Exception e)&#123;</span><br><span class="line">     // ...</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">    stream.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="16-Exception-handlers-should-preserve-the-original-exception"><a href="#16-Exception-handlers-should-preserve-the-original-exception" class="headerlink" title="16.Exception handlers should preserve the original exception"></a>16.Exception handlers should preserve the original exception</h4><p>Noncompliant Code Example:不规范的代码示例<br>// Noncompliant - exception is lost<br>try { /<em> … </em>/ } catch (Exception e) { LOGGER.info(“context”); }<br>// Noncompliant - exception is lost (only message is preserved)<br>try { /<em> … </em>/ } catch (Exception e) { LOGGER.info(e.getMessage()); }<br>// Noncompliant - exception is lost<br>try { /<em> … </em>/ } catch (Exception e) { throw new RuntimeException(“context”); }</p>
<p>Compliant Solution:规范的代码示例</p>
<figure class="highlight plain"><figcaption><span>&#123;</span><a href="/*">... */ &#125; catch (Exception e) &#123; LOGGER.info(e); &#125;</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try &#123; /* ... */ &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125;</span><br><span class="line">try &#123;</span><br><span class="line">/* ... */</span><br><span class="line">&#125; catch (RuntimeException e) &#123;</span><br><span class="line">doSomething();</span><br><span class="line">throw e;</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">// Conversion into unchecked exception is also allowed</span><br><span class="line">throw new RuntimeException(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="17-Catches-should-be-combined"><a href="#17-Catches-should-be-combined" class="headerlink" title="17.Catches should be combined"></a>17.Catches should be combined</h4><p>Since Java 7 it has been possible to catch multiple exceptions at once. Therefore, when multiplecatchblocks have the same code, they should be combined for better readability.<br>Note that this rule is automatically disabled when the project’ssonar.java.sourceis lower than7.</p>
<p>Noncompliant Code Example：不规范代码示例</p>
<figure class="highlight plain"><figcaption><span>(IOException e) &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    doCleanup();</span><br><span class="line">    logger.log(e);</span><br><span class="line">&#125;catch (SQLException e) &#123; //Noncompliant</span><br><span class="line">    doCleanup();</span><br><span class="line">    logger.log(e);</span><br><span class="line"> &#125;catch (TimeoutException e) &#123;  // Compliant; block contents are different</span><br><span class="line">     doCleanup();</span><br><span class="line">     throw e;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>Compliant Solution：规范代码示例</p>
<figure class="highlight plain"><figcaption><span>(IOException|SQLException e) &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    doCleanup();</span><br><span class="line">    logger.log(e);</span><br><span class="line"> &#125;catch (TimeoutException e) &#123;</span><br><span class="line">    doCleanup();</span><br><span class="line">    throw e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>18.”entrySet()” should be iterated when both the key and value are needed<br>Noncompliant Code Example：不规范的代码示例</p>
<figure class="highlight plain"><figcaption><span>void doSomethingWithMap(Map map) &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (String key : map.keySet()) &#123;  // Noncompliant; for each key the value is retrieved</span><br><span class="line">Object value = map.get(key);</span><br><span class="line">// ...</span><br><span class="line">&#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Compliant SolutionL：规范代码示例</p>
<figure class="highlight plain"><figcaption><span>void doSomethingWithMap(Map map) &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (Map.Entry entry : map.entrySet()) &#123;</span><br><span class="line">String key = entry.getKey();</span><br><span class="line">Object value = entry.getValue();</span><br><span class="line">// ...</span><br><span class="line">&#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Use a logger to log this exception<br>You should probably clarify which logger are you using.</p>
<p>org.apache.commons.logging.Log interface has method void error(Object message, Throwable t) (and method void info(Object message, Throwable t)), which logs the stack trace together with your custom message. Log4J implementation has this method too.</p>
<p>So, probably you need to write:<br>logger.error(“BOOM!”, e);<br>If you need to log it with INFO level (though, it might be a strange use case), then:<br>logger.info(“Just a stack trace, nothing to worry about”, e);<br>Hope it helps.</p>
<p>Rename ‘i’ as this name is already used in declaration at line 26</p>
<h2 id="阻断"><a href="#阻断" class="headerlink" title="阻断"></a>阻断</h2><h4 id="1、Close-this”FileInputStream”-in-a-“finally”-clause"><a href="#1、Close-this”FileInputStream”-in-a-“finally”-clause" class="headerlink" title="1、Close this”FileInputStream” in a “finally” clause."></a>1、Close this”FileInputStream” in a “finally” clause.</h4><p>在finally中关闭FileInputStream，这个最为常见，主要是关闭方式不对，finally代码块中，应该要对每个stream进行单独关闭，而不能统一写在一个try-catch代码中，jdk 7 可以考虑try-resources方式关闭，代码相对优雅。<br>另外数据库操作的statement和resultRs没有关闭的情况也非常多。这个也是要重点留意的地方。</p>
<h4 id="2、A”NullPointerException”-could-be-thrown-“tom”-is-nullablehere"><a href="#2、A”NullPointerException”-could-be-thrown-“tom”-is-nullablehere" class="headerlink" title="2、A”NullPointerException” could be thrown; “tom” is nullablehere"></a>2、A”NullPointerException” could be thrown; “tom” is nullablehere</h4><p>空指针，极为讨厌的问题，主要是编码经验缺少的体现。一般的高手在编码过程中，就会第一时间考虑到这类情况，并做相应的处理。解决方式无它，先判断或者先实例化，再访问里面的属性或者成员。</p>
<h2 id="严重"><a href="#严重" class="headerlink" title="严重"></a>严重</h2><h4 id="1、Define-and-throw-a-dedicated-exception-instead-of-using-a-generic-one"><a href="#1、Define-and-throw-a-dedicated-exception-instead-of-using-a-generic-one" class="headerlink" title="1、Define and throw a dedicated exception instead of using a generic one"></a>1、Define and throw a dedicated exception instead of using a generic one</h4><p>定义并抛出一个专用的异常来代替一个通用的异常。</p>
<h4 id="2、Removethis-hard-coded-password"><a href="#2、Removethis-hard-coded-password" class="headerlink" title="2、Removethis hard-coded password"></a>2、Removethis hard-coded password</h4><p>移除代码里硬编码的密码信息。会有少许的误判的情况，一般是变量包含：PWD或者password，所以如果真的不是硬编码，可以考虑更换变量名称，比如PWD改PW等等。</p>
<h4 id="3、Eitherlog-or-rethrow-this-exception"><a href="#3、Eitherlog-or-rethrow-this-exception" class="headerlink" title="3、Eitherlog or rethrow this exception"></a>3、Eitherlog or rethrow this exception</h4><p>catch异常之后，使用log方式或者throw异常的方式解决。如果业务上真的没有throw或者记录日志的话，可以使用log.debug的方式填充来解决问题。</p>
<h4 id="4、Makethis-IP-“127-0-0-1”-address-configurable"><a href="#4、Makethis-IP-“127-0-0-1”-address-configurable" class="headerlink" title="4、Makethis IP “127.0.0.1” address configurable"></a>4、Makethis IP “127.0.0.1” address configurable</h4><p>将IP弄到配置文件中，不要硬编码到代码里。个人觉得改动稍大！</p>
<h4 id="5、Make-this”public-static-JSAPI”-field-final"><a href="#5、Make-this”public-static-JSAPI”-field-final" class="headerlink" title="5、Make this”public static JSAPI” field final"></a>5、Make this”public static JSAPI” field final</h4><p>如果你将这个变量设置为public访问方式，同时又是静态Static方式，就要考虑将它设置为final了，因为这个是共享变量，其它类可以随时随地将它设置为别的值。所以如果是只是当前类使用，可以考虑将公开访问方式改为私有。</p>
<h4 id="6、Makethe-enclosing-method-“static”-or-remove-this-set"><a href="#6、Makethe-enclosing-method-“static”-or-remove-this-set" class="headerlink" title="6、Makethe enclosing method “static” or remove this set"></a>6、Makethe enclosing method “static” or remove this set</h4><p>见代码：</p>
<figure class="highlight plain"><figcaption><span>class MyClass &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  private static int count = 0;</span><br><span class="line">  public void doSomething() &#123;</span><br><span class="line">    //...</span><br><span class="line">    count++;  // Noncompliant</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">```不要使用非静态方法去更新静态字段，这样很难获得正确的结果，如果有多个类实例和/或多个线程，则很容易导致错误。理想情况下，静态字段仅从同步静态方法中更新。</span><br><span class="line">#### 7、Override&quot;equals(Object obj)&quot; to comply with the contract of the&quot;compareTo(T o)&quot; method</span><br><span class="line">如果重写了compareTo方法，同时也应重写equals方法。</span><br><span class="line">#### 8、Make&quot;body&quot; transient or serializable.</span><br><span class="line"></span><br><span class="line">```public class Address &#123;</span><br><span class="line">  //...</span><br><span class="line">&#125;</span><br><span class="line">public class Person implements Serializable &#123;</span><br><span class="line">  private static final long serialVersionUID = 1905122041950251207L;</span><br><span class="line">  private String name;</span><br><span class="line"></span><br><span class="line">  private Address address;  // Noncompliant; Address isn&apos;t serializable</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果person已经序列化，其成员变量Address也进行序列化。不然转化时会有问题。</p>
<h4 id="9-Floating-point-numbers-should-not-be-tested-for-equality"><a href="#9-Floating-point-numbers-should-not-be-tested-for-equality" class="headerlink" title="9 Floating point numbers should not be tested for equality"></a>9 Floating point numbers should not be tested for equality</h4><p>浮点类型的数字，不要通过==或者!=方式其它类型比较，因为浮点是不精确的，所以在比较时，会进行类型升级升级原则如下：<br>·  如果运算符任意一方的类型为double，则另一方会转换为double<br>·  否则，如果运算符任意一方的类型为float，则另一方会转换为float<br>·  否则，如果运算符任意一方的类型为long，则另一方会转换为long<br>·  否则，两边都会转换为int</p>
<p>以下的方式得到的结果都是false。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">float myNumber = 3.146;</span><br><span class="line">if ( myNumber == 3.146f ) &#123; //Noncompliant. Because of floating point imprecision, this will be false</span><br><span class="line"> </span><br><span class="line">if ( myNumber != 3.146f ) &#123; //Noncompliant. Because of floating point imprecision, this will be true</span><br><span class="line">if (myNumber &lt; 4 || myNumber &gt; 4) &#123; // Noncompliant; indirect  </span><br><span class="line">float zeroFloat = 0.0f;</span><br><span class="line">if (zeroFloat == 0) &#123;  // Noncompliant. Computations may end up with a value close but not equal to zero.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，要比较浮点数是否相等，需要做的事情是：</p>
<pre><code>排除NaN和无穷

在精度范围内进行比较
</code></pre><p>正确的例子：</p>
<figure class="highlight plain"><figcaption><span>boolean isEqual(double a, double b) &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    if (Double.isNaN(a) || Double.isNaN(b) || Double.isInfinite(a) || Double.isInfinite(b)) &#123;</span><br><span class="line">       return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return (a - b) &lt; 0.001d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="10、Thiscall-to-“contains-”-may-be-a-performance-hot-spot-if-the-collectionis-large"><a href="#10、Thiscall-to-“contains-”-may-be-a-performance-hot-spot-if-the-collectionis-large" class="headerlink" title="10、Thiscall to “contains()” may be a performance hot spot if the collectionis large."></a>10、Thiscall to “contains()” may be a performance hot spot if the collectionis large.</h4><p>如果collection的记录数非常大的话，它的contains方法的时间复杂度是很高的。所以开发过程中要注意这一点。下面的是列表：</p>
<figure class="highlight plain"><figcaption><span>ArrayList</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">contains</span><br><span class="line">remove</span><br><span class="line">·  LinkedList</span><br><span class="line"></span><br><span class="line">get</span><br><span class="line">contains</span><br><span class="line">·  ConcurrentLinkedQueue</span><br><span class="line"></span><br><span class="line">size</span><br><span class="line">contains</span><br><span class="line">·  ConcurrentLinkedDeque</span><br><span class="line"></span><br><span class="line">size</span><br><span class="line">contains</span><br><span class="line">·  CopyOnWriteArrayList</span><br><span class="line"></span><br><span class="line">add</span><br><span class="line">contains</span><br><span class="line">remove</span><br><span class="line">·  CopyOnWriteArraySet</span><br><span class="line"></span><br><span class="line">add</span><br><span class="line">contains</span><br><span class="line">remove</span><br></pre></td></tr></table></figure>
<h5 id="1-Equality-tests-should-not-be-made-with-floating-point-value"><a href="#1-Equality-tests-should-not-be-made-with-floating-point-value" class="headerlink" title="1.Equality tests should not be made with floating point value"></a>1.Equality tests should not be made with floating point value</h5><p>　　代码举例： if (result == num) //result和num均为double 之间比较会有精度损失<br>　　解决：BigDecimal data1 = new BigDecimal(totalArea);<br>　　　　　BigDecimal data2 = new BigDecimal(s1);<br>　　　　    int num = data1.compareTo(data2);//num =0 相等  &gt;0前者大于后者 ，反之 &lt;0 前者小于后者</p>
<h5 id="2-This-class-overrides-“equals-”-and-should-therefore-also-override-“hashCode-”"><a href="#2-This-class-overrides-“equals-”-and-should-therefore-also-override-“hashCode-”" class="headerlink" title="2.This class overrides “equals()” and should therefore also override “hashCode()”.　"></a>2.This class overrides “equals()” and should therefore also override “hashCode()”.　</h5><p>　　代码举例：public boolean equals(Object obj){…}  //需要添加对应的hashCode方法<br>　　解决：可以添加一个最简单的hashCode方法　　<br>　　　　　public int hashCode() {return 0;}　　　</p>
<h5 id="3-Synchronize-on-a-new-“Object”-instead"><a href="#3-Synchronize-on-a-new-“Object”-instead" class="headerlink" title="3.Synchronize on a new “Object” instead"></a>3.Synchronize on a new “Object” instead</h5><p>　　代码举例：synchronized (“实例化”) {…}   //里边必须是对象<br>　　解决： private Object obj =”实例化”；<br>　　　　　synchronized (obj ) {…}</p>
<h5 id="4-Close-this”FileInputStream”-in-a-“finally”-clause"><a href="#4-Close-this”FileInputStream”-in-a-“finally”-clause" class="headerlink" title="4.Close this”FileInputStream” in a “finally” clause."></a>4.Close this”FileInputStream” in a “finally” clause.</h5><p>　　解决方法: 在finally中关闭FileInputStream，主要是关闭方式不对，finally代码块中，应该要对每个stream进行单独关闭，而不能统一写在一个try-catch代码中。</p>
<h5 id="5-A”NullPointerException”-could-be-thrown-“tom”-is-nullablehere"><a href="#5-A”NullPointerException”-could-be-thrown-“tom”-is-nullablehere" class="headerlink" title="5.A”NullPointerException” could be thrown; “tom” is nullablehere"></a>5.A”NullPointerException” could be thrown; “tom” is nullablehere</h5><p>　　空指针，解决方式：先判断或者先实例化，再访问里面的属性或者成员。</p>
<h5 id="6-Makethis-IP-“127-0-0-1”-address-configurable"><a href="#6-Makethis-IP-“127-0-0-1”-address-configurable" class="headerlink" title="6.Makethis IP “127.0.0.1” address configurable"></a>6.Makethis IP “127.0.0.1” address configurable</h5><p>　　解决方法:不要把IP地址写在此类中，应该在对应的系统文件或者相应的配置文件中配置</p>
<h5 id="7-Either-log-or-rethrow-this-exception"><a href="#7-Either-log-or-rethrow-this-exception" class="headerlink" title="7.Either log or rethrow this exception."></a>7.Either log or rethrow this exception.</h5><p>　　解决方法: 把对应的输出写成Logger.error(“aaa“);的形式 </p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://cenrise.com/2017/05/16/网络安全/安全组第一次会议提出的问题整理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="dongpo.jia">
      <meta itemprop="description" content="个人博客">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="中起之星">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/16/网络安全/安全组第一次会议提出的问题整理/" itemprop="url">
                  安全组第一次会议提出的问题整理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-05-16 10:30:00" itemprop="dateCreated datePublished" datetime="2017-05-16T10:30:00+08:00">2017-05-16</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2017-08-18 09:44:35" itemprop="dateModified" datetime="2017-08-18T09:44:35+08:00">2017-08-18</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/网络安全/" itemprop="url" rel="index"><span itemprop="name">网络安全</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/网络安全/安全小组/" itemprop="url" rel="index"><span itemprop="name">安全小组</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>创建安全组是个长期的、不断迭代的过程，目前我们公司系统百废末兴之际，各方面的系统也都在创建初期如果安全控制要求高，势必会影响部分工作进度；当然，从开始就严格控制，也会为后期不必要的重构提供有利条件。根据现有情况，可以优先进行投入少，回报多的工作，慢慢渗透。  </p>
<h1 id="事前-防范"><a href="#事前-防范" class="headerlink" title="事前-防范"></a>事前-防范</h1><p>1.制定漏洞管理制度<br>为规范生产网和办公网安全漏洞发现、评估及处理，首先应该制定《漏洞管理制度》对漏洞评级，根据评级做不同和响应处理。<br>漏洞处理流程：发现漏洞-&gt;评估漏洞-&gt;如果是不可接受的风险对业务下线-&gt;修补漏洞-&gt;测试验收-&gt;上线  </p>
<p>2.敏感数据保护<br>    1) 银行卡可以显示首末4，手机号可以显示首3末4位，电话可以显示区号和末4位，身份证、邮箱、地址等。<br>    2) 日志文件里的敏感信息<br>    3) 用户名密码加密<br>    4) 数据库防篡改签名  </p>
<p>3.访问控制管理<br>    1) 制定信息授权的策略，及访问权限的管理策略；<br>    2) 规定每个用户或每组用户的访问控制规则和权力；  </p>
<p>4.用户帐号及权限安全。<br>    1) 最小权限原则<br>    最小权限是指限定系统中每个用户所必须的最小访问权限的原则，设定账号访问权限，控制用户仅能够访问到工作需要的信息。<br>    2) 职责分离原则<br>    职责分离主要是防止单个用户利用其所拥有的多重权限进行舞弊、盗窃或其它的非法行为，或对工作错误和违规活动进行掩盖。<br>    账号权限管理应按照职责分离的原则，确保不存在权限交叉而形成舞弊的可能  </p>
<ol start="5">
<li>产品安全功能设计规范<br> 需要对产品的安全功能设计，如身份认证基本策略、用户登录失败/超时处理、账户信息输入防护、接口认证。  </li>
</ol>
<p>6.保密管理<br>     对文档、内容做好密级分类，哪些文件是对内，对外，或机密。  </p>
<p>7.测试规范，<br>    1) 依据《漏洞管理制度》判定漏洞等级，凡存在高危漏洞，除大领导特批外，禁止上线；低危或中危漏洞，可先上线后排期修复。<br>    任何系统未经过黑盒和白盒测试，禁止上线，特批和紧急情况除外。<br>    2) 为避免安全测试人员漏测，需定期对生产进行全面安全测试：<br>    • 半年内至少执行一次全面渗透测试；<br>    • 每个季度至少需要一次全面的ACL验证，系统底层漏洞检测；  </p>
<p>8.研发规范：<br>    1) 研发流程规范<br>    2) 代码规范<br>    3) 对技术的选型，比如组件、中间容器、中间件使用版本统一及安全、架构评审。  </p>
<h1 id="事中-应急的规定"><a href="#事中-应急的规定" class="headerlink" title="事中-应急的规定"></a>事中-应急的规定</h1><p>  1) 建议成立应急指挥小组主要是在事故处理过程中进行信息收集、资源调度和沟通反馈信息。  应急处理流程如：信息收集-&gt;初步判断-&gt;事故处理-&gt;信息通报-&gt;事后处理-故障报告。  原则：以尽快恢复业务为第一优先。<br>  2) 故障时间之前做相关系统的上线或系统变更备份，在3分钟内无法定位故障原因的，立即执行回滚变更操作。  </p>
<h1 id="事后-总结"><a href="#事后-总结" class="headerlink" title="事后-总结"></a>事后-总结</h1><p>  1) 做好故障记录，主要包括事故、事故发生时间，事故恢复时间、持续时间，等级、影响产品、影响商户、影响交易、事故发现、事故类型、产生原因等<br>  2) 故障报告改进措施跟进 ，主要是改进措施、目前的完成情况，遗留问题  </p>
<h1 id="漏洞发现和处理流程"><a href="#漏洞发现和处理流程" class="headerlink" title="漏洞发现和处理流程"></a>漏洞发现和处理流程</h1><p>1.注册补天、漏洞盒子、乌云等国内外漏洞平台的企业帐号，针对企业贴平台会第一时间推送最新漏洞并进行安全指导。<br>2.可以在补天、漏洞盒子等平台以企业帐号方式创建安全测试平台，对外的白帽子增加奖励，鼓励大众参与众测。  </p>
<h1 id="安全网站参考"><a href="#安全网站参考" class="headerlink" title="安全网站参考"></a>安全网站参考</h1><p>安全资讯<br><a href="http://www.freebuf.com/" target="_blank" rel="noopener">http://www.freebuf.com/</a>  </p>
<p>乌云 (WooYun)(已停服)<br><a href="http://wooyun.org/" target="_blank" rel="noopener">http://wooyun.org/</a><br>可通过如下查乌云数据：<a href="http://wooyun.tangscan.cn/" target="_blank" rel="noopener">http://wooyun.tangscan.cn/</a>  </p>
<p>补天<br><a href="http://loudong.360.cn/" target="_blank" rel="noopener">http://loudong.360.cn/</a>  </p>
<p>漏洞盒子<br><a href="https://www.vulbox.com/bounties" target="_blank" rel="noopener">https://www.vulbox.com/bounties</a>  </p>
<p>阿里SRC<br><a href="https://security.alibaba.com/" target="_blank" rel="noopener">https://security.alibaba.com/</a>  </p>
<p>腾讯SRC<br><a href="https://security.tencent.com/" target="_blank" rel="noopener">https://security.tencent.com/</a>  </p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="dongpo.jia" />
            
              <p class="site-author-name" itemprop="name">dongpo.jia</p>
              <p class="site-description motion-element" itemprop="description">个人博客</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">50</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">44</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">41</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dongpo.jia</span>

  

  
</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.2.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.2.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.2.0"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
